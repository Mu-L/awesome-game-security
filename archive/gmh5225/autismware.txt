Project Path: arc_gmh5225_autismware_o74ex05t

Source Tree:

```txt
arc_gmh5225_autismware_o74ex05t
├── AutismWare.sln
├── CSGO SDK
│   ├── CSGO SDK.vcxproj
│   ├── CSGO SDK.vcxproj.filters
│   ├── DllMain.cpp
│   ├── Features
│   │   ├── Game
│   │   │   ├── Prediction.cpp
│   │   │   ├── Prediction.hpp
│   │   │   ├── SetupBones.cpp
│   │   │   ├── SetupBones.hpp
│   │   │   ├── SimulationContext.cpp
│   │   │   └── SimulationContext.hpp
│   │   ├── Miscellaneous
│   │   │   ├── AutoBuy.cpp
│   │   │   ├── AutoBuy.hpp
│   │   │   ├── BulletBeamTracer.cpp
│   │   │   ├── BulletBeamTracer.hpp
│   │   │   ├── GameEvent.cpp
│   │   │   ├── GameEvent.hpp
│   │   │   ├── KitParser.cpp
│   │   │   ├── KitParser.hpp
│   │   │   ├── Miscellaneous.cpp
│   │   │   ├── Miscellaneous.hpp
│   │   │   ├── Movement.cpp
│   │   │   ├── Movement.hpp
│   │   │   ├── SkinChanger.cpp
│   │   │   ├── SkinChanger.hpp
│   │   │   ├── VisibilityOptimization.cpp
│   │   │   ├── VisibilityOptimization.hpp
│   │   │   ├── WeatherController.cpp
│   │   │   └── WeatherController.hpp
│   │   ├── Rage
│   │   │   ├── AnimationSystem.cpp
│   │   │   ├── AnimationSystem.hpp
│   │   │   ├── AntiAim.cpp
│   │   │   ├── AntiAim.hpp
│   │   │   ├── Autowall.cpp
│   │   │   ├── Autowall.h
│   │   │   ├── ExtendedBactrack.cpp
│   │   │   ├── ExtendedBactrack.hpp
│   │   │   ├── FakeLag.cpp
│   │   │   ├── FakeLag.hpp
│   │   │   ├── KnifeBot.cpp
│   │   │   ├── KnifeBot.hpp
│   │   │   ├── LagCompensation.cpp
│   │   │   ├── LagCompensation.hpp
│   │   │   ├── Ragebot.cpp
│   │   │   ├── Ragebot.hpp
│   │   │   ├── Resolver.cpp
│   │   │   ├── Resolver.hpp
│   │   │   ├── ShotInformation.cpp
│   │   │   ├── ShotInformation.hpp
│   │   │   ├── TickbaseShift.cpp
│   │   │   ├── TickbaseShift.hpp
│   │   │   ├── ZeusBot.cpp
│   │   │   └── ZeusBot.hpp
│   │   └── Visuals
│   │       ├── CChams.cpp
│   │       ├── CChams.hpp
│   │       ├── ESP.cpp
│   │       ├── ESP.hpp
│   │       ├── EventLogger.cpp
│   │       ├── EventLogger.hpp
│   │       ├── ExtendedEsp.cpp
│   │       ├── ExtendedEsp.hpp
│   │       ├── Glow.cpp
│   │       ├── Glow.hpp
│   │       ├── GrenadePrediction.cpp
│   │       ├── GrenadePrediction.hpp
│   │       ├── Hitmarker.cpp
│   │       └── Hitmarker.hpp
│   ├── Hooking
│   │   ├── Hooked.hpp
│   │   ├── Hooker.hpp
│   │   └── Hooks
│   │       ├── BeginFrame.cpp
│   │       ├── CreateMove.cpp
│   │       ├── DispatchUserMessage.cpp
│   │       ├── DoPostScreenEffects.cpp
│   │       ├── DrawModel.cpp
│   │       ├── EmitSound.cpp
│   │       ├── FrameStageNotify.cpp
│   │       ├── GetScreenAspectRatio.cpp
│   │       ├── InterpolateServerEntities.cpp
│   │       ├── IsBoxVisible.cpp
│   │       ├── IsConnected.cpp
│   │       ├── IsPlayingDemo.cpp
│   │       ├── ListLeavesInBox.cpp
│   │       ├── LockCursor.cpp
│   │       ├── OnSoundStarted.cpp
│   │       ├── OverrideView.cpp
│   │       ├── PacketStart.cpp
│   │       ├── PaintTraverse.cpp
│   │       ├── PlayerHooks.cpp
│   │       ├── Present.cpp
│   │       ├── RecvProxyHooks.cpp
│   │       ├── RenderView.cpp
│   │       ├── Reset.cpp
│   │       ├── RetrieveMessage.cpp
│   │       ├── RunCommand.cpp
│   │       ├── SendNetMsg.cpp
│   │       └── SetReservationCookie.cpp
│   ├── Libraries
│   │   ├── json.h
│   │   └── minhook-master
│   │       ├── README.md
│   │       ├── build
│   │       │   ├── MinGW
│   │       │   │   ├── Makefile
│   │       │   │   └── make.bat
│   │       │   ├── VC10
│   │       │   │   ├── MinHook.vcxproj
│   │       │   │   ├── MinHookVC10.sln
│   │       │   │   ├── libMinHook.vcxproj
│   │       │   │   └── libMinHook.vcxproj.filters
│   │       │   ├── VC11
│   │       │   │   ├── MinHook.vcxproj
│   │       │   │   ├── MinHookVC11.sln
│   │       │   │   ├── libMinHook.vcxproj
│   │       │   │   └── libMinHook.vcxproj.filters
│   │       │   ├── VC12
│   │       │   │   ├── MinHook.vcxproj
│   │       │   │   ├── MinHookVC12.sln
│   │       │   │   ├── libMinHook.vcxproj
│   │       │   │   └── libMinHook.vcxproj.filters
│   │       │   ├── VC14
│   │       │   │   ├── MinHook.vcxproj
│   │       │   │   ├── MinHookVC14.sln
│   │       │   │   ├── libMinHook.vcxproj
│   │       │   │   └── libMinHook.vcxproj.filters
│   │       │   ├── VC15
│   │       │   │   ├── MinHook.vcxproj
│   │       │   │   ├── MinHookVC15.sln
│   │       │   │   ├── libMinHook.vcxproj
│   │       │   │   └── libMinHook.vcxproj.filters
│   │       │   └── VC9
│   │       │       ├── MinHook.vcproj
│   │       │       ├── MinHookVC9.sln
│   │       │       └── libMinHook.vcproj
│   │       ├── dll_resources
│   │       │   ├── MinHook.def
│   │       │   └── MinHook.rc
│   │       ├── include
│   │       │   └── MinHook.h
│   │       └── src
│   │           ├── buffer.c
│   │           ├── buffer.h
│   │           ├── hde
│   │           │   ├── hde32.c
│   │           │   ├── hde32.h
│   │           │   ├── hde64.c
│   │           │   ├── hde64.h
│   │           │   ├── pstdint.h
│   │           │   ├── table32.h
│   │           │   └── table64.h
│   │           ├── hook.c
│   │           ├── trampoline.c
│   │           └── trampoline.h
│   ├── Menu
│   │   ├── Elements.cpp
│   │   ├── Elements.h
│   │   ├── Framework
│   │   │   ├── Button
│   │   │   │   ├── Button.cpp
│   │   │   │   └── Button.h
│   │   │   ├── Checkbox
│   │   │   │   ├── Checkbox.cpp
│   │   │   │   └── Checkbox.h
│   │   │   ├── ColorPicker
│   │   │   │   ├── ColorPicker.cpp
│   │   │   │   └── ColorPicker.h
│   │   │   ├── Dropdown
│   │   │   │   ├── Dropdown.cpp
│   │   │   │   └── Dropdown.h
│   │   │   ├── Form
│   │   │   │   ├── Form.cpp
│   │   │   │   └── Form.h
│   │   │   ├── GUI.cpp
│   │   │   ├── GUI.h
│   │   │   ├── Group
│   │   │   │   ├── Group.cpp
│   │   │   │   └── Group.h
│   │   │   ├── Hotkey
│   │   │   │   ├── Hotkey.cpp
│   │   │   │   └── Hotkey.h
│   │   │   ├── Label
│   │   │   │   ├── Label.cpp
│   │   │   │   └── Label.h
│   │   │   ├── Listbox
│   │   │   │   ├── Listbox.cpp
│   │   │   │   └── Listbox.h
│   │   │   ├── MultiDropdown
│   │   │   │   ├── MultiDropdown.cpp
│   │   │   │   └── MultiDropdown.h
│   │   │   ├── Slider
│   │   │   │   ├── Slider.cpp
│   │   │   │   └── Slider.h
│   │   │   └── Textbox
│   │   │       ├── Textbox.cpp
│   │   │       └── Textbox.h
│   │   └── Helpers
│   │       ├── Easing.h
│   │       ├── InputHelper.cpp
│   │       └── InputHelper.h
│   ├── Renderer
│   │   ├── Render.cpp
│   │   ├── Render.hpp
│   │   ├── Textures
│   │   │   ├── titlebar.h
│   │   │   └── weaponicons.h
│   │   └── Wrapper
│   │       ├── font
│   │       │   └── font.h
│   │       └── sprite
│   │           ├── sprite.cpp
│   │           └── sprite.h
│   ├── SDK
│   │   ├── CColor.hpp
│   │   ├── CVariables.cpp
│   │   ├── CVariables.hpp
│   │   ├── Classes
│   │   │   ├── CCSGO_HudDeathNotice.cpp
│   │   │   ├── CCSGO_HudDeathNotice.hpp
│   │   │   ├── CClientState.cpp
│   │   │   ├── CClientState.hpp
│   │   │   ├── CPlayerResource.cpp
│   │   │   ├── CPlayerResource.hpp
│   │   │   ├── CStudioRender.hpp
│   │   │   ├── CUserCmd.cpp
│   │   │   ├── CUserCmd.hpp
│   │   │   ├── DataMap.hpp
│   │   │   ├── Exploits.hpp
│   │   │   ├── GlowOutlineEffect.hpp
│   │   │   ├── IAppSystem.hpp
│   │   │   ├── IBaseClientDll.cpp
│   │   │   ├── IBaseClientDll.hpp
│   │   │   ├── ICenterPrint.hpp
│   │   │   ├── IClientEntity.hpp
│   │   │   ├── IClientEntityList.cpp
│   │   │   ├── IClientEntityList.hpp
│   │   │   ├── IClientLeafSystem.hpp
│   │   │   ├── IConVar.cpp
│   │   │   ├── IConVar.hpp
│   │   │   ├── IEngineSound.hpp
│   │   │   ├── IEngineTrace.cpp
│   │   │   ├── IEngineTrace.hpp
│   │   │   ├── IGameEventManager.hpp
│   │   │   ├── IGameMovement.cpp
│   │   │   ├── IGameMovement.hpp
│   │   │   ├── IInput.cpp
│   │   │   ├── IInput.hpp
│   │   │   ├── IInputSystem.cpp
│   │   │   ├── IInputSystem.hpp
│   │   │   ├── ILocalize.hpp
│   │   │   ├── IMaterialSystem.hpp
│   │   │   ├── IMemAlloc.cpp
│   │   │   ├── IMemAlloc.hpp
│   │   │   ├── IMoveHelper.cpp
│   │   │   ├── IMoveHelper.hpp
│   │   │   ├── INetChannel.hpp
│   │   │   ├── INetMessage.hpp
│   │   │   ├── INetworkStringTable.h
│   │   │   ├── IPanel.cpp
│   │   │   ├── IPanel.hpp
│   │   │   ├── IPhysics.hpp
│   │   │   ├── IPrediction.cpp
│   │   │   ├── IPrediction.hpp
│   │   │   ├── ISteamClient.hpp
│   │   │   ├── IStudioRender.hpp
│   │   │   ├── ISurface.cpp
│   │   │   ├── ISurface.hpp
│   │   │   ├── IVDebugOverlay.hpp
│   │   │   ├── IVEngineClient.cpp
│   │   │   ├── IVEngineClient.hpp
│   │   │   ├── IVModelInfo.hpp
│   │   │   ├── IVModelRender.hpp
│   │   │   ├── IVRenderView.hpp
│   │   │   ├── IViewRender.hpp
│   │   │   ├── IViewRenderBeams.hpp
│   │   │   ├── Player.cpp
│   │   │   ├── Player.hpp
│   │   │   ├── PlayerAnimState.cpp
│   │   │   ├── PlayerAnimState.hpp
│   │   │   ├── PropManager.cpp
│   │   │   ├── PropManager.hpp
│   │   │   ├── WeaponInfo.hpp
│   │   │   ├── entity.cpp
│   │   │   ├── entity.hpp
│   │   │   ├── weapon.cpp
│   │   │   └── weapon.hpp
│   │   ├── Definitions.hpp
│   │   ├── Displacement.cpp
│   │   ├── Displacement.hpp
│   │   ├── Includes.hpp
│   │   ├── RayTracer.cpp
│   │   ├── RayTracer.h
│   │   ├── Utils
│   │   │   ├── PatternScan.cpp
│   │   │   ├── PatternScan.hpp
│   │   │   ├── Print.cpp
│   │   │   ├── Print.hpp
│   │   │   ├── auto.hpp
│   │   │   ├── os.hpp
│   │   │   ├── singleton.hpp
│   │   │   ├── vcall.hpp
│   │   │   ├── vmt_swap.cpp
│   │   │   └── vmt_swap.hpp
│   │   ├── Valve
│   │   │   ├── CBaseHandle.hpp
│   │   │   ├── Matrix.cpp
│   │   │   ├── Matrix.hpp
│   │   │   ├── UtlBuffer.cpp
│   │   │   ├── UtlBuffer.hpp
│   │   │   ├── UtlMap.hpp
│   │   │   ├── UtlMemory.hpp
│   │   │   ├── UtlVector.hpp
│   │   │   ├── characterset.cpp
│   │   │   ├── characterset.hpp
│   │   │   ├── platform.cpp
│   │   │   ├── platform.hpp
│   │   │   ├── qangle.cpp
│   │   │   ├── qangle.hpp
│   │   │   ├── recv_swap.hpp
│   │   │   ├── vector.cpp
│   │   │   ├── vector.hpp
│   │   │   ├── vector2d.cpp
│   │   │   ├── vector2d.hpp
│   │   │   ├── vector4d.cpp
│   │   │   └── vector4d.hpp
│   │   ├── core.cpp
│   │   ├── core.hpp
│   │   ├── sdk.cpp
│   │   └── sdk.hpp
│   ├── Utils
│   │   ├── Config.cpp
│   │   ├── Config.hpp
│   │   ├── CrashHandler.cpp
│   │   ├── CrashHandler.hpp
│   │   ├── FnvHash.hpp
│   │   ├── InputSys.cpp
│   │   ├── InputSys.hpp
│   │   ├── LogSystem.cpp
│   │   ├── LogSystem.hpp
│   │   ├── Math.cpp
│   │   ├── Math.h
│   │   ├── Threading
│   │   │   ├── atomic_lock.cpp
│   │   │   ├── atomic_lock.h
│   │   │   ├── mutex.cpp
│   │   │   ├── mutex.h
│   │   │   ├── packed_heap.cpp
│   │   │   ├── packed_heap.h
│   │   │   ├── semaphores.cpp
│   │   │   ├── semaphores.h
│   │   │   ├── shared_mutex.cpp
│   │   │   ├── shared_mutex.h
│   │   │   ├── threading.cpp
│   │   │   └── threading.h
│   │   ├── XorStr.hpp
│   │   ├── base64.h
│   │   ├── defs.hpp
│   │   ├── lazy_importer.hpp
│   │   └── syscall.hpp
│   ├── source.cpp
│   └── source.hpp
└── README.md

```

`AutismWare.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32825.248
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AutismWare", "CSGO SDK\CSGO SDK.vcxproj", "{A437D8C7-EFDA-444A-B941-5CEFCD40C2F6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Stable|x86 = Stable|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A437D8C7-EFDA-444A-B941-5CEFCD40C2F6}.Stable|x86.ActiveCfg = stable|Win32
		{A437D8C7-EFDA-444A-B941-5CEFCD40C2F6}.Stable|x86.Build.0 = stable|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0D2803B3-545A-424B-B0AA-02D73A29E682}
	EndGlobalSection
EndGlobal

```

`CSGO SDK/CSGO SDK.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="stable|Win32">
      <Configuration>stable</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{A437D8C7-EFDA-444A-B941-5CEFCD40C2F6}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>CounterStrikeGlobalOffensive</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
    <ProjectName>AutismWare</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='stable|Win32'">
    <PlatformToolset>v141</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <PlatformToolset>v141</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='stable|Win32'">
    <IncludePath>$(ProjectDir)Libraries;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(ProjectDir)Libraries\Freetype\include;D:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)Libraries;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(ProjectDir)Libraries\cryptopp\Win32\Output\Release;$(ProjectDir)Libraries\Freetype;$(NETFXKitsDir)Lib\um\x86;D:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
    <TargetExt>.dll</TargetExt>
    <IntDir>$(SolutionDir)$(Configuration)\Intermediate\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IncludePath>$(ProjectDir)Libraries;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(ProjectDir)Libraries\Freetype\include;D:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>$(ProjectDir)Libraries;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(ProjectDir)Libraries\cryptopp\Win32\Output\Release;$(ProjectDir)Libraries\Freetype;$(NETFXKitsDir)Lib\um\x86;D:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
    <TargetExt>.dll</TargetExt>
    <IntDir>$(SolutionDir)$(Configuration)\Intermediate\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='stable|Win32'">
    <ClCompile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>USE_XOR;_CRT_SECURE_NO_WARNINGS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <Optimization>Custom</Optimization>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel>Precise</FloatingPointModel>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <DisableLanguageExtensions>false</DisableLanguageExtensions>
      <MinimalRebuild>false</MinimalRebuild>
      <DebugInformationFormat>None</DebugInformationFormat>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <StringPooling>
      </StringPooling>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <AdditionalIncludeDirectories>$(DXSDK_DIR)LIB\x86</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>USE_XOR;_CRT_SECURE_NO_WARNINGS;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <Optimization>Custom</Optimization>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel>Precise</FloatingPointModel>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <DisableLanguageExtensions>false</DisableLanguageExtensions>
      <MinimalRebuild>false</MinimalRebuild>
      <DebugInformationFormat>None</DebugInformationFormat>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <StringPooling>
      </StringPooling>
      <WholeProgramOptimization>true</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Features\Miscellaneous\WeatherController.cpp" />
    <ClCompile Include="Features\Rage\AnimationSystem.cpp" />
    <ClCompile Include="Features\Rage\AntiAim.cpp" />
    <ClCompile Include="Features\Miscellaneous\AutoBuy.cpp" />
    <ClCompile Include="Features\Rage\Autowall.cpp" />
    <ClCompile Include="Features\Rage\Resolver.cpp" />
    <ClCompile Include="Features\Rage\ZeusBot.cpp" />
    <ClCompile Include="Hooking\Hooks\BeginFrame.cpp" />
    <ClCompile Include="Features\Miscellaneous\BulletBeamTracer.cpp" />
    <ClCompile Include="Features\Visuals\CChams.cpp" />
    <ClCompile Include="Hooking\Hooks\RetrieveMessage.cpp" />
    <ClCompile Include="Renderer\Wrapper\sprite\sprite.cpp" />
    <ClCompile Include="SDK\Classes\CClientState.cpp" />
    <ClCompile Include="SDK\Classes\CCSGO_HudDeathNotice.cpp" />
    <ClCompile Include="SDK\Classes\IInputSystem.cpp" />
    <ClCompile Include="SDK\Valve\characterset.cpp" />
    <ClCompile Include="Utils\CrashHandler.cpp" />
    <ClCompile Include="Hooking\Hooks\DispatchUserMessage.cpp" />
    <ClCompile Include="Hooking\Hooks\IsBoxVisible.cpp" />
    <ClCompile Include="Hooking\Hooks\IsConnected.cpp" />
    <ClCompile Include="Hooking\Hooks\IsPlayingDemo.cpp" />
    <ClCompile Include="Utils\LogSystem.cpp" />
    <ClCompile Include="Menu\Elements.cpp" />
    <ClCompile Include="Menu\Framework\Button\Button.cpp" />
    <ClCompile Include="Menu\Framework\Checkbox\Checkbox.cpp" />
    <ClCompile Include="Menu\Framework\ColorPicker\ColorPicker.cpp" />
    <ClCompile Include="Menu\Framework\Dropdown\Dropdown.cpp" />
    <ClCompile Include="Menu\Framework\Form\Form.cpp" />
    <ClCompile Include="Menu\Framework\Group\Group.cpp" />
    <ClCompile Include="Menu\Framework\GUI.cpp" />
    <ClCompile Include="Menu\Framework\Hotkey\Hotkey.cpp" />
    <ClCompile Include="Menu\Framework\Label\Label.cpp" />
    <ClCompile Include="Menu\Framework\Listbox\Listbox.cpp" />
    <ClCompile Include="Menu\Framework\MultiDropdown\MultiDropdown.cpp" />
    <ClCompile Include="Menu\Framework\Slider\Slider.cpp" />
    <ClCompile Include="Menu\Framework\Textbox\Textbox.cpp" />
    <ClCompile Include="Menu\Helpers\InputHelper.cpp" />
    <ClCompile Include="Hooking\Hooks\OnSoundStarted.cpp" />
    <ClCompile Include="Utils\Config.cpp" />
    <ClCompile Include="SDK\core.cpp" />
    <ClCompile Include="SDK\Classes\CPlayerResource.cpp" />
    <ClCompile Include="Hooking\Hooks\CreateMove.cpp" />
    <ClCompile Include="SDK\Classes\CUserCmd.cpp" />
    <ClCompile Include="SDK\CVariables.cpp" />
    <ClCompile Include="SDK\Displacement.cpp" />
    <ClCompile Include="Hooking\Hooks\DoPostScreenEffects.cpp" />
    <ClCompile Include="Hooking\Hooks\DrawModel.cpp" />
    <ClCompile Include="Hooking\Hooks\EmitSound.cpp" />
    <ClCompile Include="SDK\Classes\entity.cpp" />
    <ClCompile Include="Features\Visuals\ESP.cpp" />
    <ClCompile Include="Features\Visuals\EventLogger.cpp" />
    <ClCompile Include="Features\Rage\ExtendedBactrack.cpp" />
    <ClCompile Include="Features\Visuals\ExtendedEsp.cpp" />
    <ClCompile Include="Features\Rage\FakeLag.cpp" />
    <ClCompile Include="Hooking\Hooks\FrameStageNotify.cpp" />
    <ClCompile Include="Features\Miscellaneous\GameEvent.cpp" />
    <ClCompile Include="Hooking\Hooks\GetScreenAspectRatio.cpp" />
    <ClCompile Include="Features\Visuals\Glow.cpp" />
    <ClCompile Include="Features\Visuals\GrenadePrediction.cpp" />
    <ClCompile Include="Features\Visuals\Hitmarker.cpp" />
    <ClCompile Include="SDK\Classes\IBaseClientDll.cpp" />
    <ClCompile Include="SDK\Classes\IClientEntityList.cpp" />
    <ClCompile Include="SDK\Classes\IConVar.cpp" />
    <ClCompile Include="SDK\Classes\IEngineTrace.cpp" />
    <ClCompile Include="SDK\Classes\IGameMovement.cpp" />
    <ClCompile Include="SDK\Classes\IInput.cpp" />
    <ClCompile Include="SDK\Classes\IMemAlloc.cpp" />
    <ClCompile Include="SDK\Classes\IMoveHelper.cpp" />
    <ClCompile Include="Utils\InputSys.cpp" />
    <ClCompile Include="Hooking\Hooks\InterpolateServerEntities.cpp" />
    <ClCompile Include="SDK\Classes\IPanel.cpp" />
    <ClCompile Include="SDK\Classes\IPrediction.cpp" />
    <ClCompile Include="SDK\Classes\ISurface.cpp" />
    <ClCompile Include="SDK\Classes\IVEngineClient.cpp" />
    <ClCompile Include="Features\Miscellaneous\KitParser.cpp" />
    <ClCompile Include="Features\Rage\KnifeBot.cpp" />
    <ClCompile Include="Features\Rage\LagCompensation.cpp" />
    <ClCompile Include="Hooking\Hooks\ListLeavesInBox.cpp" />
    <ClCompile Include="Hooking\Hooks\LockCursor.cpp" />
    <ClCompile Include="DllMain.cpp" />
    <ClCompile Include="Utils\Math.cpp" />
    <ClCompile Include="SDK\Valve\Matrix.cpp" />
    <ClCompile Include="Libraries\minhook-master\src\buffer.c" />
    <ClCompile Include="Libraries\minhook-master\src\hde\hde32.c" />
    <ClCompile Include="Libraries\minhook-master\src\hde\hde64.c" />
    <ClCompile Include="Libraries\minhook-master\src\hook.c" />
    <ClCompile Include="Libraries\minhook-master\src\trampoline.c" />
    <ClCompile Include="Features\Miscellaneous\Miscellaneous.cpp" />
    <ClCompile Include="Features\Miscellaneous\Movement.cpp" />
    <ClCompile Include="Hooking\Hooks\OverrideView.cpp" />
    <ClCompile Include="Hooking\Hooks\PacketStart.cpp" />
    <ClCompile Include="Hooking\Hooks\PaintTraverse.cpp" />
    <ClCompile Include="SDK\Valve\platform.cpp" />
    <ClCompile Include="SDK\Classes\Player.cpp" />
    <ClCompile Include="SDK\Classes\PlayerAnimState.cpp" />
    <ClCompile Include="Hooking\Hooks\PlayerHooks.cpp" />
    <ClCompile Include="Features\Game\Prediction.cpp" />
    <ClCompile Include="Hooking\Hooks\Present.cpp" />
    <ClCompile Include="SDK\Classes\PropManager.cpp" />
    <ClCompile Include="SDK\Valve\qangle.cpp" />
    <ClCompile Include="Features\Rage\Ragebot.cpp" />
    <ClCompile Include="SDK\RayTracer.cpp" />
    <ClCompile Include="Hooking\Hooks\RecvProxyHooks.cpp" />
    <ClCompile Include="Renderer\Render.cpp" />
    <ClCompile Include="Hooking\Hooks\RenderView.cpp" />
    <ClCompile Include="Hooking\Hooks\Reset.cpp" />
    <ClCompile Include="Features\Rage\ShotInformation.cpp" />
    <ClCompile Include="Hooking\Hooks\RunCommand.cpp" />
    <ClCompile Include="SDK\Utils\PatternScan.cpp" />
    <ClCompile Include="SDK\sdk.cpp" />
    <ClCompile Include="Hooking\Hooks\SendNetMsg.cpp" />
    <ClCompile Include="Hooking\Hooks\SetReservationCookie.cpp" />
    <ClCompile Include="Features\Game\SetupBones.cpp" />
    <ClCompile Include="Features\Game\SimulationContext.cpp" />
    <ClCompile Include="Features\Miscellaneous\SkinChanger.cpp" />
    <ClCompile Include="source.cpp" />
    <ClCompile Include="SDK\Utils\Print.cpp" />
    <ClCompile Include="Features\Rage\TickbaseShift.cpp" />
    <ClCompile Include="Utils\Threading\atomic_lock.cpp" />
    <ClCompile Include="Utils\Threading\mutex.cpp" />
    <ClCompile Include="Utils\Threading\packed_heap.cpp" />
    <ClCompile Include="Utils\Threading\semaphores.cpp" />
    <ClCompile Include="Utils\Threading\shared_mutex.cpp" />
    <ClCompile Include="Utils\Threading\threading.cpp" />
    <ClCompile Include="SDK\Valve\UtlBuffer.cpp" />
    <ClCompile Include="SDK\Valve\vector.cpp" />
    <ClCompile Include="SDK\Valve\vector2d.cpp" />
    <ClCompile Include="SDK\Valve\vector4d.cpp" />
    <ClCompile Include="Features\Miscellaneous\VisibilityOptimization.cpp" />
    <ClCompile Include="SDK\Utils\vmt_swap.cpp" />
    <ClCompile Include="SDK\Classes\weapon.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Features\Game\SimulationContext.hpp" />
    <ClInclude Include="Features\Miscellaneous\WeatherController.hpp" />
    <ClInclude Include="Features\Rage\AnimationSystem.hpp" />
    <ClInclude Include="Features\Rage\AntiAim.hpp" />
    <ClInclude Include="Features\Rage\Resolver.hpp" />
    <ClInclude Include="Features\Rage\ZeusBot.hpp" />
    <ClInclude Include="Renderer\Textures\weaponicons.h" />
    <ClInclude Include="Renderer\Wrapper\font\font.h" />
    <ClInclude Include="Renderer\Wrapper\sprite\sprite.h" />
    <ClInclude Include="SDK\Classes\IInputSystem.hpp" />
    <ClInclude Include="SDK\Classes\INetworkStringTable.h" />
    <ClInclude Include="SDK\Utils\auto.hpp" />
    <ClInclude Include="Features\Miscellaneous\AutoBuy.hpp" />
    <ClInclude Include="Features\Rage\Autowall.h" />
    <ClInclude Include="Features\Miscellaneous\BulletBeamTracer.hpp" />
    <ClInclude Include="SDK\Valve\CBaseHandle.hpp" />
    <ClInclude Include="Features\Visuals\CChams.hpp" />
    <ClInclude Include="SDK\Classes\CClientState.hpp" />
    <ClInclude Include="SDK\Classes\CCSGO_HudDeathNotice.hpp" />
    <ClInclude Include="SDK\Valve\characterset.hpp" />
    <ClInclude Include="SDK\CColor.hpp" />
    <ClInclude Include="Utils\Config.hpp" />
    <ClInclude Include="SDK\core.hpp" />
    <ClInclude Include="SDK\Classes\CPlayerResource.hpp" />
    <ClInclude Include="Utils\CrashHandler.hpp" />
    <ClInclude Include="SDK\Classes\CStudioRender.hpp" />
    <ClInclude Include="SDK\Classes\CUserCmd.hpp" />
    <ClInclude Include="SDK\CVariables.hpp" />
    <ClInclude Include="SDK\Classes\DataMap.hpp" />
    <ClInclude Include="SDK\Definitions.hpp" />
    <ClInclude Include="Utils\defs.hpp" />
    <ClInclude Include="SDK\Displacement.hpp" />
    <ClInclude Include="SDK\Classes\entity.hpp" />
    <ClInclude Include="Features\Visuals\ESP.hpp" />
    <ClInclude Include="Features\Visuals\EventLogger.hpp" />
    <ClInclude Include="SDK\Classes\Exploits.hpp" />
    <ClInclude Include="Features\Rage\ExtendedBactrack.hpp" />
    <ClInclude Include="Features\Visuals\ExtendedEsp.hpp" />
    <ClInclude Include="Features\Rage\FakeLag.hpp" />
    <ClInclude Include="Utils\FnvHash.hpp" />
    <ClInclude Include="Libraries\freetype\freetype\config\ftconfig.h" />
    <ClInclude Include="Libraries\freetype\freetype\config\ftheader.h" />
    <ClInclude Include="Libraries\freetype\freetype\config\ftmodule.h" />
    <ClInclude Include="Libraries\freetype\freetype\config\ftoption.h" />
    <ClInclude Include="Libraries\freetype\freetype\config\ftstdlib.h" />
    <ClInclude Include="Libraries\freetype\freetype\freetype.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftadvanc.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftbbox.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftbdf.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftbitmap.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftbzip2.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftcache.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftchapters.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftcid.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftdriver.h" />
    <ClInclude Include="Libraries\freetype\freetype\fterrdef.h" />
    <ClInclude Include="Libraries\freetype\freetype\fterrors.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftfntfmt.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftgasp.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftglyph.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftgxval.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftgzip.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftimage.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftincrem.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftlcdfil.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftlist.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftlzw.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftmac.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftmm.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftmodapi.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftmoderr.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftotval.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftoutln.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftparams.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftpfr.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftrender.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftsizes.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftsnames.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftstroke.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftsynth.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftsystem.h" />
    <ClInclude Include="Libraries\freetype\freetype\fttrigon.h" />
    <ClInclude Include="Libraries\freetype\freetype\fttypes.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftwinfnt.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\autohint.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\cffotypes.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\cfftypes.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftcalc.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftdebug.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftdrv.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftgloadr.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\fthash.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftmemory.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftobjs.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftpic.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftpsprop.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftrfork.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftserv.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftstream.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\fttrace.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftvalid.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\internal.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\psaux.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\pshints.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svbdf.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svcfftl.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svcid.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svfntfmt.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svgldict.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svgxval.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svkern.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svmetric.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svmm.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svotval.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svpfr.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svpostnm.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svprop.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svpscmap.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svpsinfo.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svsfnt.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svttcmap.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svtteng.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svttglyf.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svwinfnt.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\sfnt.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\t1types.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\tttypes.h" />
    <ClInclude Include="Libraries\freetype\freetype\t1tables.h" />
    <ClInclude Include="Libraries\freetype\freetype\ttnameid.h" />
    <ClInclude Include="Libraries\freetype\freetype\tttables.h" />
    <ClInclude Include="Libraries\freetype\freetype\tttags.h" />
    <ClInclude Include="Libraries\freetype\ft2build.h" />
    <ClInclude Include="Features\Miscellaneous\GameEvent.hpp" />
    <ClInclude Include="Features\Visuals\Glow.hpp" />
    <ClInclude Include="SDK\Classes\GlowOutlineEffect.hpp" />
    <ClInclude Include="Features\Visuals\GrenadePrediction.hpp" />
    <ClInclude Include="Features\Visuals\Hitmarker.hpp" />
    <ClInclude Include="Hooking\Hooked.hpp" />
    <ClInclude Include="Hooking\Hooker.hpp" />
    <ClInclude Include="SDK\Includes.hpp" />
    <ClInclude Include="SDK\Classes\IAppSystem.hpp" />
    <ClInclude Include="SDK\Classes\IBaseClientDll.hpp" />
    <ClInclude Include="SDK\Classes\ICenterPrint.hpp" />
    <ClInclude Include="SDK\Classes\IClientEntity.hpp" />
    <ClInclude Include="SDK\Classes\IClientEntityList.hpp" />
    <ClInclude Include="SDK\Classes\IClientLeafSystem.hpp" />
    <ClInclude Include="SDK\Classes\IConVar.hpp" />
    <ClInclude Include="SDK\Classes\IEngineSound.hpp" />
    <ClInclude Include="SDK\Classes\IEngineTrace.hpp" />
    <ClInclude Include="SDK\Classes\IGameEventManager.hpp" />
    <ClInclude Include="SDK\Classes\IGameMovement.hpp" />
    <ClInclude Include="SDK\Classes\IInput.hpp" />
    <ClInclude Include="SDK\Classes\ILocalize.hpp" />
    <ClInclude Include="SDK\Classes\IMaterialSystem.hpp" />
    <ClInclude Include="SDK\Classes\IMemAlloc.hpp" />
    <ClInclude Include="SDK\Classes\IMoveHelper.hpp" />
    <ClInclude Include="SDK\Classes\INetChannel.hpp" />
    <ClInclude Include="SDK\Classes\INetMessage.hpp" />
    <ClInclude Include="Utils\InputSys.hpp" />
    <ClInclude Include="SDK\Classes\IPanel.hpp" />
    <ClInclude Include="SDK\Classes\IPhysics.hpp" />
    <ClInclude Include="SDK\Classes\IPrediction.hpp" />
    <ClInclude Include="SDK\Classes\ISteamClient.hpp" />
    <ClInclude Include="SDK\Classes\IStudioRender.hpp" />
    <ClInclude Include="SDK\Classes\ISurface.hpp" />
    <ClInclude Include="SDK\Classes\IVDebugOverlay.hpp" />
    <ClInclude Include="SDK\Classes\IVEngineClient.hpp" />
    <ClInclude Include="SDK\Classes\IViewRender.hpp" />
    <ClInclude Include="SDK\Classes\IViewRenderBeams.hpp" />
    <ClInclude Include="SDK\Classes\IVModelInfo.hpp" />
    <ClInclude Include="SDK\Classes\IVModelRender.hpp" />
    <ClInclude Include="SDK\Classes\IVRenderView.hpp" />
    <ClInclude Include="Libraries\json.h" />
    <ClInclude Include="Features\Miscellaneous\KitParser.hpp" />
    <ClInclude Include="Features\Rage\KnifeBot.hpp" />
    <ClInclude Include="Features\Rage\LagCompensation.hpp" />
    <ClInclude Include="Utils\lazy_importer.hpp" />
    <ClInclude Include="Utils\LogSystem.hpp" />
    <ClInclude Include="Utils\Math.h" />
    <ClInclude Include="SDK\Valve\Matrix.hpp" />
    <ClInclude Include="Menu\Elements.h" />
    <ClInclude Include="Menu\Framework\Button\Button.h" />
    <ClInclude Include="Menu\Framework\Checkbox\Checkbox.h" />
    <ClInclude Include="Menu\Framework\ColorPicker\ColorPicker.h" />
    <ClInclude Include="Menu\Framework\Dropdown\Dropdown.h" />
    <ClInclude Include="Menu\Framework\Form\Form.h" />
    <ClInclude Include="Menu\Framework\Group\Group.h" />
    <ClInclude Include="Menu\Framework\GUI.h" />
    <ClInclude Include="Menu\Framework\Hotkey\Hotkey.h" />
    <ClInclude Include="Menu\Framework\Label\Label.h" />
    <ClInclude Include="Menu\Framework\Listbox\Listbox.h" />
    <ClInclude Include="Menu\Framework\MultiDropdown\MultiDropdown.h" />
    <ClInclude Include="Menu\Framework\Slider\Slider.h" />
    <ClInclude Include="Menu\Framework\Textbox\Textbox.h" />
    <ClInclude Include="Menu\Helpers\Easing.h" />
    <ClInclude Include="Menu\Helpers\InputHelper.h" />
    <ClInclude Include="Libraries\minhook-master\include\MinHook.h" />
    <ClInclude Include="Libraries\minhook-master\src\buffer.h" />
    <ClInclude Include="Libraries\minhook-master\src\hde\hde32.h" />
    <ClInclude Include="Libraries\minhook-master\src\hde\hde64.h" />
    <ClInclude Include="Libraries\minhook-master\src\hde\pstdint.h" />
    <ClInclude Include="Libraries\minhook-master\src\hde\table32.h" />
    <ClInclude Include="Libraries\minhook-master\src\hde\table64.h" />
    <ClInclude Include="Libraries\minhook-master\src\trampoline.h" />
    <ClInclude Include="Features\Miscellaneous\Miscellaneous.hpp" />
    <ClInclude Include="Features\Miscellaneous\Movement.hpp" />
    <ClInclude Include="SDK\Valve\platform.hpp" />
    <ClInclude Include="SDK\Classes\Player.hpp" />
    <ClInclude Include="SDK\Classes\PlayerAnimState.hpp" />
    <ClInclude Include="Features\Game\Prediction.hpp" />
    <ClInclude Include="SDK\Classes\PropManager.hpp" />
    <ClInclude Include="SDK\Valve\qangle.hpp" />
    <ClInclude Include="SDK\Utils\PatternScan.hpp" />
    <ClInclude Include="Features\Rage\Ragebot.hpp" />
    <ClInclude Include="SDK\RayTracer.h" />
    <ClInclude Include="SDK\Valve\recv_swap.hpp" />
    <ClInclude Include="Renderer\Render.hpp" />
    <ClInclude Include="Renderer\Textures\titlebar.h" />
    <ClInclude Include="Features\Rage\ShotInformation.hpp" />
    <ClInclude Include="Features\Game\SetupBones.hpp" />
    <ClInclude Include="SDK\Utils\singleton.hpp" />
    <ClInclude Include="SDK\Utils\Print.hpp" />
    <ClInclude Include="Features\Miscellaneous\SkinChanger.hpp" />
    <ClInclude Include="Utils\Threading\packed_heap.h" />
    <ClInclude Include="Utils\syscall.hpp" />
    <ClInclude Include="Features\Rage\TickbaseShift.hpp" />
    <ClInclude Include="Utils\Threading\atomic_lock.h" />
    <ClInclude Include="Utils\base64.h" />
    <ClInclude Include="Utils\Threading\mutex.h" />
    <ClInclude Include="Utils\Threading\semaphores.h" />
    <ClInclude Include="Utils\Threading\shared_mutex.h" />
    <ClInclude Include="Utils\Threading\threading.h" />
    <ClInclude Include="SDK\Valve\UtlBuffer.hpp" />
    <ClInclude Include="SDK\Valve\UtlMap.hpp" />
    <ClInclude Include="SDK\Valve\UtlMemory.hpp" />
    <ClInclude Include="SDK\Valve\UtlVector.hpp" />
    <ClInclude Include="SDK\Utils\vcall.hpp" />
    <ClInclude Include="SDK\Valve\vector.hpp" />
    <ClInclude Include="SDK\Valve\vector2d.hpp" />
    <ClInclude Include="SDK\Valve\vector4d.hpp" />
    <ClInclude Include="Features\Miscellaneous\VisibilityOptimization.hpp" />
    <ClInclude Include="SDK\Utils\vmt_swap.hpp" />
    <ClInclude Include="SDK\Utils\os.hpp" />
    <ClInclude Include="SDK\sdk.hpp" />
    <ClInclude Include="source.hpp" />
    <ClInclude Include="SDK\Classes\weapon.hpp" />
    <ClInclude Include="SDK\Classes\WeaponInfo.hpp" />
    <ClInclude Include="Utils\XorStr.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CSGO SDK/CSGO SDK.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="DllMain.cpp">
      <Filter>Entrypoint</Filter>
    </ClCompile>
    <ClCompile Include="source.cpp">
      <Filter>Starting</Filter>
    </ClCompile>
    <ClCompile Include="Menu\Framework\Button\Button.cpp" />
    <ClCompile Include="Menu\Framework\Checkbox\Checkbox.cpp" />
    <ClCompile Include="Menu\Framework\ColorPicker\ColorPicker.cpp" />
    <ClCompile Include="Menu\Framework\Dropdown\Dropdown.cpp" />
    <ClCompile Include="Menu\Framework\Form\Form.cpp" />
    <ClCompile Include="Menu\Framework\Group\Group.cpp" />
    <ClCompile Include="Menu\Framework\Hotkey\Hotkey.cpp" />
    <ClCompile Include="Menu\Framework\Label\Label.cpp" />
    <ClCompile Include="Menu\Framework\Listbox\Listbox.cpp" />
    <ClCompile Include="Menu\Framework\MultiDropdown\MultiDropdown.cpp" />
    <ClCompile Include="Menu\Framework\Slider\Slider.cpp" />
    <ClCompile Include="Menu\Framework\GUI.cpp" />
    <ClCompile Include="Menu\Elements.cpp" />
    <ClCompile Include="Menu\Helpers\InputHelper.cpp" />
    <ClCompile Include="Menu\Framework\Textbox\Textbox.cpp" />
    <ClCompile Include="Libraries\minhook-master\src\buffer.c" />
    <ClCompile Include="Libraries\minhook-master\src\hde\hde32.c" />
    <ClCompile Include="Libraries\minhook-master\src\hde\hde64.c" />
    <ClCompile Include="Libraries\minhook-master\src\hook.c" />
    <ClCompile Include="Libraries\minhook-master\src\trampoline.c" />
    <ClCompile Include="Features\Rage\AntiAim.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Rage\Autowall.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Miscellaneous\AutoBuy.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Miscellaneous\BulletBeamTracer.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Visuals\CChams.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Rage\AnimationSystem.cpp">
      <Filter>Features\Engine</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\BeginFrame.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\CreateMove.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\DispatchUserMessage.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\DoPostScreenEffects.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\EmitSound.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\DrawModel.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\FrameStageNotify.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\GetScreenAspectRatio.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\InterpolateServerEntities.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\IsBoxVisible.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\IsConnected.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\IsPlayingDemo.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\ListLeavesInBox.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\LockCursor.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\OnSoundStarted.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\OverrideView.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\PacketStart.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\PaintTraverse.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\PlayerHooks.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\SendNetMsg.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\SetReservationCookie.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\RunCommand.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\RenderView.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\Reset.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\Present.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\CClientState.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Valve\characterset.cpp">
      <Filter>SDK\Classes</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\CPlayerResource.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\CUserCmd.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\entity.cpp">
      <Filter>SDK\Entity</Filter>
    </ClCompile>
    <ClCompile Include="Features\Miscellaneous\GameEvent.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\IBaseClientDll.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\IClientEntityList.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\IConVar.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\IEngineTrace.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\IGameMovement.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\IInput.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\IMemAlloc.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\IMoveHelper.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\IPanel.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\IPrediction.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\ISurface.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\IVEngineClient.cpp">
      <Filter>SDK\Interfaces</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\weapon.cpp">
      <Filter>SDK\Entity</Filter>
    </ClCompile>
    <ClCompile Include="Features\Rage\FakeLag.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Rage\KnifeBot.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Rage\LagCompensation.cpp">
      <Filter>Features\Engine</Filter>
    </ClCompile>
    <ClCompile Include="Features\Rage\Ragebot.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Utils\Config.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="SDK\core.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="SDK\sdk.cpp">
      <Filter>SDK</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Displacement.cpp">
      <Filter>License</Filter>
    </ClCompile>
    <ClCompile Include="Features\Visuals\ESP.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Visuals\Glow.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Visuals\GrenadePrediction.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Visuals\Hitmarker.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Miscellaneous\Miscellaneous.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Miscellaneous\Movement.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Valve\vector.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Valve\vector2d.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Valve\vector4d.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="Features\Miscellaneous\SkinChanger.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Rage\TickbaseShift.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\CCSGO_HudDeathNotice.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Utils\CrashHandler.cpp">
      <Filter>Utils</Filter>
    </ClCompile>
    <ClCompile Include="Features\Visuals\EventLogger.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Visuals\ExtendedEsp.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Rage\ExtendedBactrack.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\Player.cpp">
      <Filter>SDK\Entity</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\PlayerAnimState.cpp">
      <Filter>SDK\Entity</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Valve\UtlBuffer.cpp">
      <Filter>SDK\Classes</Filter>
    </ClCompile>
    <ClCompile Include="Features\Game\Prediction.cpp">
      <Filter>Features\Engine</Filter>
    </ClCompile>
    <ClCompile Include="Features\Game\SetupBones.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Game\SimulationContext.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Utils\PatternScan.cpp">
      <Filter>Utils</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Utils\Print.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Utils\vmt_swap.cpp">
      <Filter>Utils</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Valve\qangle.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Valve\Matrix.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="SDK\CVariables.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Classes\PropManager.cpp">
      <Filter>SDK\Entity</Filter>
    </ClCompile>
    <ClCompile Include="Utils\InputSys.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Features\Miscellaneous\KitParser.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="SDK\Valve\platform.cpp">
      <Filter>SDK\Classes</Filter>
    </ClCompile>
    <ClCompile Include="Utils\LogSystem.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="SDK\RayTracer.cpp">
      <Filter>Features</Filter>
    </ClCompile>
    <ClCompile Include="Hooking\Hooks\RecvProxyHooks.cpp">
      <Filter>Hooks</Filter>
    </ClCompile>
    <ClCompile Include="Features\Miscellaneous\VisibilityOptimization.cpp">
      <Filter>Features\Engine</Filter>
    </ClCompile>
    <ClCompile Include="Renderer\Render.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="Renderer\Wrapper\sprite\sprite.cpp" />
    <ClCompile Include="Features\Rage\ZeusBot.cpp" />
    <ClCompile Include="Hooking\Hooks\RetrieveMessage.cpp" />
    <ClCompile Include="Features\Miscellaneous\WeatherController.cpp" />
    <ClCompile Include="Utils\Threading\packed_heap.cpp" />
    <ClCompile Include="Utils\Threading\atomic_lock.cpp">
      <Filter>Threading</Filter>
    </ClCompile>
    <ClCompile Include="Utils\Threading\semaphores.cpp">
      <Filter>Threading</Filter>
    </ClCompile>
    <ClCompile Include="Utils\Threading\mutex.cpp">
      <Filter>Threading</Filter>
    </ClCompile>
    <ClCompile Include="Utils\Threading\threading.cpp">
      <Filter>Threading</Filter>
    </ClCompile>
    <ClCompile Include="Utils\Threading\shared_mutex.cpp">
      <Filter>Threading</Filter>
    </ClCompile>
    <ClCompile Include="Features\Rage\ShotInformation.cpp">
      <Filter>Features\Engine</Filter>
    </ClCompile>
    <ClCompile Include="Features\Rage\Resolver.cpp" />
    <ClCompile Include="SDK\Classes\IInputSystem.cpp" />
    <ClCompile Include="Utils\Math.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="source.hpp">
      <Filter>Starting</Filter>
    </ClInclude>
    <ClInclude Include="Renderer\Textures\titlebar.h" />
    <ClInclude Include="Menu\Framework\Button\Button.h" />
    <ClInclude Include="Menu\Framework\Checkbox\Checkbox.h" />
    <ClInclude Include="Menu\Framework\ColorPicker\ColorPicker.h" />
    <ClInclude Include="Menu\Framework\Dropdown\Dropdown.h" />
    <ClInclude Include="Menu\Framework\Form\Form.h" />
    <ClInclude Include="Menu\Framework\Group\Group.h" />
    <ClInclude Include="Menu\Framework\Hotkey\Hotkey.h" />
    <ClInclude Include="Menu\Framework\Label\Label.h" />
    <ClInclude Include="Menu\Framework\Listbox\Listbox.h" />
    <ClInclude Include="Menu\Framework\MultiDropdown\MultiDropdown.h" />
    <ClInclude Include="Menu\Framework\Slider\Slider.h" />
    <ClInclude Include="Menu\Framework\GUI.h" />
    <ClInclude Include="Menu\Helpers\Easing.h" />
    <ClInclude Include="Menu\Elements.h" />
    <ClInclude Include="Menu\Helpers\InputHelper.h" />
    <ClInclude Include="Utils\base64.h" />
    <ClInclude Include="Menu\Framework\Textbox\Textbox.h" />
    <ClInclude Include="Libraries\freetype\freetype\config\ftconfig.h" />
    <ClInclude Include="Libraries\freetype\freetype\config\ftheader.h" />
    <ClInclude Include="Libraries\freetype\freetype\config\ftmodule.h" />
    <ClInclude Include="Libraries\freetype\freetype\config\ftoption.h" />
    <ClInclude Include="Libraries\freetype\freetype\config\ftstdlib.h" />
    <ClInclude Include="Libraries\freetype\freetype\freetype.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftadvanc.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftbbox.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftbdf.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftbitmap.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftbzip2.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftcache.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftchapters.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftcid.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftdriver.h" />
    <ClInclude Include="Libraries\freetype\freetype\fterrdef.h" />
    <ClInclude Include="Libraries\freetype\freetype\fterrors.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftfntfmt.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftgasp.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftglyph.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftgxval.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftgzip.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftimage.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftincrem.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftlcdfil.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftlist.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftlzw.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftmac.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftmm.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftmodapi.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftmoderr.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftotval.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftoutln.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftparams.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftpfr.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftrender.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftsizes.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftsnames.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftstroke.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftsynth.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftsystem.h" />
    <ClInclude Include="Libraries\freetype\freetype\fttrigon.h" />
    <ClInclude Include="Libraries\freetype\freetype\fttypes.h" />
    <ClInclude Include="Libraries\freetype\freetype\ftwinfnt.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\autohint.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\cffotypes.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\cfftypes.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftcalc.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftdebug.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftdrv.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftgloadr.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\fthash.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftmemory.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftobjs.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftpic.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftpsprop.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftrfork.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftserv.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftstream.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\fttrace.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\ftvalid.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\internal.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\psaux.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\pshints.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svbdf.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svcfftl.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svcid.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svfntfmt.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svgldict.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svgxval.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svkern.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svmetric.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svmm.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svotval.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svpfr.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svpostnm.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svprop.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svpscmap.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svpsinfo.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svsfnt.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svttcmap.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svtteng.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svttglyf.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\services\svwinfnt.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\sfnt.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\t1types.h" />
    <ClInclude Include="Libraries\freetype\freetype\internal\tttypes.h" />
    <ClInclude Include="Libraries\freetype\freetype\t1tables.h" />
    <ClInclude Include="Libraries\freetype\freetype\ttnameid.h" />
    <ClInclude Include="Libraries\freetype\freetype\tttables.h" />
    <ClInclude Include="Libraries\freetype\freetype\tttags.h" />
    <ClInclude Include="Libraries\freetype\ft2build.h" />
    <ClInclude Include="Libraries\minhook-master\include\MinHook.h" />
    <ClInclude Include="Libraries\minhook-master\src\buffer.h" />
    <ClInclude Include="Libraries\minhook-master\src\hde\hde32.h" />
    <ClInclude Include="Libraries\minhook-master\src\hde\hde64.h" />
    <ClInclude Include="Libraries\minhook-master\src\hde\pstdint.h" />
    <ClInclude Include="Libraries\minhook-master\src\hde\table32.h" />
    <ClInclude Include="Libraries\minhook-master\src\hde\table64.h" />
    <ClInclude Include="Libraries\minhook-master\src\trampoline.h" />
    <ClInclude Include="Features\Rage\AntiAim.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Rage\Autowall.h">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Miscellaneous\AutoBuy.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Miscellaneous\BulletBeamTracer.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\CChams.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Rage\AnimationSystem.hpp">
      <Filter>Features\Engine</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\CClientState.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\CBaseHandle.hpp">
      <Filter>SDK\Classes</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\characterset.hpp">
      <Filter>SDK\Classes</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\CPlayerResource.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\CStudioRender.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\CUserCmd.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\entity.hpp">
      <Filter>SDK\Entity</Filter>
    </ClInclude>
    <ClInclude Include="Features\Miscellaneous\GameEvent.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IAppSystem.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IBaseClientDll.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\ICenterPrint.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IClientEntity.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IClientEntityList.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IClientLeafSystem.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IConVar.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IEngineSound.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IEngineTrace.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IGameEventManager.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IGameMovement.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IInput.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\ILocalize.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IMaterialSystem.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IMemAlloc.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IMoveHelper.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\INetChannel.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\INetMessage.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IPanel.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IPhysics.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IPrediction.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\ISteamClient.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IStudioRender.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\ISurface.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IVDebugOverlay.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IVEngineClient.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IViewRender.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IViewRenderBeams.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IVModelInfo.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IVModelRender.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IVRenderView.hpp">
      <Filter>SDK\Interfaces</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\weapon.hpp">
      <Filter>SDK\Entity</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\WeaponInfo.hpp">
      <Filter>SDK\Entity</Filter>
    </ClInclude>
    <ClInclude Include="Features\Rage\FakeLag.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Rage\KnifeBot.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Rage\LagCompensation.hpp">
      <Filter>Features\Engine</Filter>
    </ClInclude>
    <ClInclude Include="Features\Rage\Ragebot.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Config.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="SDK\core.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="SDK\sdk.hpp">
      <Filter>SDK</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\DataMap.hpp">
      <Filter>SDK\Classes</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Displacement.hpp">
      <Filter>License</Filter>
    </ClInclude>
    <ClInclude Include="Utils\defs.hpp">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Definitions.hpp">
      <Filter>SDK\Other Data</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ESP.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\Glow.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\GrenadePrediction.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\Hitmarker.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Hooking\Hooked.hpp">
      <Filter>Hooks</Filter>
    </ClInclude>
    <ClInclude Include="Hooking\Hooker.hpp">
      <Filter>SDK\Minhook</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\GlowOutlineEffect.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Miscellaneous\Miscellaneous.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Miscellaneous\Movement.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\vector.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\vector2d.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\vector4d.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="Features\Miscellaneous\SkinChanger.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Rage\TickbaseShift.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\Exploits.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\CCSGO_HudDeathNotice.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Utils\CrashHandler.hpp">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="SDK\CColor.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\EventLogger.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Visuals\ExtendedEsp.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Rage\ExtendedBactrack.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\Player.hpp">
      <Filter>SDK\Entity</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\PlayerAnimState.hpp">
      <Filter>SDK\Entity</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\UtlBuffer.hpp">
      <Filter>SDK\Classes</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\UtlMap.hpp">
      <Filter>SDK\Classes</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\UtlMemory.hpp">
      <Filter>SDK\Classes</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\UtlVector.hpp">
      <Filter>SDK\Classes</Filter>
    </ClInclude>
    <ClInclude Include="Features\Game\Prediction.hpp">
      <Filter>Features\Engine</Filter>
    </ClInclude>
    <ClInclude Include="Features\Game\SetupBones.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Features\Game\SimulationContext.hpp" />
    <ClInclude Include="SDK\Utils\PatternScan.hpp">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Utils\vcall.hpp">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Utils\Print.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Utils\vmt_swap.hpp">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Utils\singleton.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Utils\auto.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\qangle.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\Matrix.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="SDK\CVariables.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="Libraries\json.h">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="Utils\FnvHash.hpp">
      <Filter>Utils\FnvHash</Filter>
    </ClInclude>
    <ClInclude Include="Utils\XorStr.hpp">
      <Filter>License</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Utils\os.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\PropManager.hpp">
      <Filter>SDK\Entity</Filter>
    </ClInclude>
    <ClInclude Include="Utils\InputSys.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="Utils\syscall.hpp">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Classes\IInputSystem.hpp" />
    <ClInclude Include="Utils\Math.h">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="Features\Miscellaneous\KitParser.hpp">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\platform.hpp">
      <Filter>SDK\Classes</Filter>
    </ClInclude>
    <ClInclude Include="Utils\LogSystem.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="SDK\RayTracer.h">
      <Filter>Features</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Valve\recv_swap.hpp">
      <Filter>SDK\Classes</Filter>
    </ClInclude>
    <ClInclude Include="Utils\lazy_importer.hpp">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Features\Miscellaneous\VisibilityOptimization.hpp">
      <Filter>Features\Engine</Filter>
    </ClInclude>
    <ClInclude Include="Renderer\Render.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="Renderer\Wrapper\font\font.h" />
    <ClInclude Include="Renderer\Wrapper\sprite\sprite.h" />
    <ClInclude Include="Features\Rage\ZeusBot.hpp" />
    <ClInclude Include="Features\Miscellaneous\WeatherController.hpp" />
    <ClInclude Include="Utils\Threading\packed_heap.h" />
    <ClInclude Include="Utils\Threading\atomic_lock.h">
      <Filter>Threading</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Threading\semaphores.h">
      <Filter>Threading</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Threading\mutex.h">
      <Filter>Threading</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Threading\threading.h">
      <Filter>Threading</Filter>
    </ClInclude>
    <ClInclude Include="Utils\Threading\shared_mutex.h">
      <Filter>Threading</Filter>
    </ClInclude>
    <ClInclude Include="SDK\Includes.hpp">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="Renderer\Textures\weaponicons.h" />
    <ClInclude Include="Features\Rage\ShotInformation.hpp">
      <Filter>Features\Engine</Filter>
    </ClInclude>
    <ClInclude Include="Features\Rage\Resolver.hpp" />
    <ClInclude Include="SDK\Classes\INetworkStringTable.h" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Entrypoint">
      <UniqueIdentifier>{052df92e-4463-4083-89e7-ee5239f9c062}</UniqueIdentifier>
    </Filter>
    <Filter Include="Threading">
      <UniqueIdentifier>{fc930db6-6e95-4ab2-832d-7ecc30d491e5}</UniqueIdentifier>
    </Filter>
    <Filter Include="SDK">
      <UniqueIdentifier>{d722c2cc-0e96-4a47-9858-33485562f430}</UniqueIdentifier>
    </Filter>
    <Filter Include="SDK\Minhook">
      <UniqueIdentifier>{a303cf48-2b01-4180-b036-7b131e663531}</UniqueIdentifier>
    </Filter>
    <Filter Include="SDK\Entity">
      <UniqueIdentifier>{cc3e1d40-3649-4317-a241-4b24edc0afff}</UniqueIdentifier>
    </Filter>
    <Filter Include="SDK\Classes">
      <UniqueIdentifier>{2c0d8425-76a6-4680-808d-1a0f87d5b177}</UniqueIdentifier>
    </Filter>
    <Filter Include="SDK\Interfaces">
      <UniqueIdentifier>{1567dadf-fb50-4ef2-8fc0-7f0d44b3e474}</UniqueIdentifier>
    </Filter>
    <Filter Include="Misc">
      <UniqueIdentifier>{d3d8577d-2628-4f4e-9ca0-4911e39accd8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features">
      <UniqueIdentifier>{1643c623-4794-4867-b12d-c1272a9a3cb4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Protobuf">
      <UniqueIdentifier>{788ad0b6-59ab-493e-ae97-4e7ebd3c8ea4}</UniqueIdentifier>
    </Filter>
    <Filter Include="SDK\Other Data">
      <UniqueIdentifier>{beccda33-7e9b-4700-a3a0-5c8b9703713c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Starting">
      <UniqueIdentifier>{3dcceb96-8e5a-48cd-93c6-afaf4e0e47d1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Utils">
      <UniqueIdentifier>{0773445f-adf6-41a2-b21e-871439699c29}</UniqueIdentifier>
    </Filter>
    <Filter Include="Utils\FnvHash">
      <UniqueIdentifier>{1a1be8ad-12e6-4079-b9aa-3c632acc9647}</UniqueIdentifier>
    </Filter>
    <Filter Include="Secure">
      <UniqueIdentifier>{5f4e6112-216d-42ad-9aad-a2ea5f451d0c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Features\Engine">
      <UniqueIdentifier>{0a8ab0ab-e1fb-4c9e-b65b-38b284ed491e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Menu">
      <UniqueIdentifier>{e5e18fcc-6b0c-4797-80f2-e0add32e7a02}</UniqueIdentifier>
    </Filter>
    <Filter Include="Menu\ImGui">
      <UniqueIdentifier>{a2e80f61-f3f8-4150-be7a-61de1c1fa2f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="License">
      <UniqueIdentifier>{9b652d1a-4f10-4d23-ac0d-b6609e65744b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Hooks">
      <UniqueIdentifier>{37e10c39-2606-4f55-955f-f25d426f3b21}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`CSGO SDK/DllMain.cpp`:

```cpp
#include "source.hpp"
#include "Utils/InputSys.hpp"
#include "Utils/defs.hpp"

#pragma disable(warning:4099)


#include "Utils/Threading/threading.h"
#include "Utils/Threading/shared_mutex.h"
#include "SDK/displacement.hpp"
#include "SDK/CVariables.hpp"
#include "Utils/lazy_importer.hpp"
#include "Utils/CrashHandler.hpp"
#include "Libraries/minhook-master/include/MinHook.h"
#include <thread>

#include "Features/Rage/TickbaseShift.hpp"

#include <iomanip> 
#include "Utils/syscall.hpp"

static Semaphore dispatchSem;
static SharedMutex smtx;

using ThreadIDFn = int(_cdecl*)();

ThreadIDFn AllocateThreadID;
ThreadIDFn FreeThreadID;

int AllocateThreadIDWrapper() {
	return AllocateThreadID();
}

int FreeThreadIDWrapper() {
	return FreeThreadID();
}

template<typename T, T& Fn>
static void AllThreadsStub(void*) {
	dispatchSem.Post();
	smtx.rlock();
	smtx.runlock();
	Fn();
}


// TODO: Build this into the threading library
template<typename T, T& Fn>
static void DispatchToAllThreads(void* data) {
	smtx.wlock();

	for (size_t i = 0; i < Threading::numThreads; i++)
		Threading::QueueJobRef(AllThreadsStub<T, Fn>, data);

	for (size_t i = 0; i < Threading::numThreads; i++)
		dispatchSem.Wait();

	smtx.wunlock();

	Threading::FinishQueue(false);
}

struct DllArguments {
	HMODULE hModule;
	LPVOID lpReserved;
};

namespace duxe::security {
	uintptr_t* rel32(uintptr_t ptr) {
		auto offset = *(uintptr_t*)(ptr + 0x1);
		return (uintptr_t*)(ptr + 5 + offset);
	}

	void bypass_mmap_detection(void* address, uint32_t region_size) {
		const auto client_dll = (uint32_t)GetModuleHandleA(XorStr("client.dll"));

		const auto valloc_call = client_dll + 0x90DC60;

		using add_allocation_to_list_t = int(__thiscall*)(
			uint32_t list, LPVOID alloc_base, SIZE_T alloc_size, DWORD alloc_type, DWORD alloc_protect, LPVOID ret_alloc_base, DWORD last_error, int return_address, int a8);

		auto add_allocation_to_list = (add_allocation_to_list_t)(rel32(Memory::Scan(XorStr("gameoverlayrenderer.dll"), XorStr("E8 ? ? ? ? 53 FF 15 ? ? ? ? 8B C7"))));

		const auto list = *(uint32_t*)(Memory::Scan(XorStr("gameoverlayrenderer.dll"), XorStr("56 B9 ? ? ? ? E8 ? ? ? ? 84 C0 74 1C")) + 2);

		add_allocation_to_list(list, address, region_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE, address, 0, valloc_call, 0);
	}
}

DWORD WINAPI Entry(DllArguments* pArgs) {
	g_Vars.globals.user_info = *(CVariables::GLOBAL::cheat_header_t*)pArgs->hModule;
	g_Vars.globals.c_login = reinterpret_cast<const char*>(pArgs->hModule);
	g_Vars.globals.hModule = pArgs->hModule;

	auto tier0 = GetModuleHandleA(XorStr("tier0.dll"));

	AllocateThreadID = (ThreadIDFn)GetProcAddress(tier0, XorStr("AllocateThreadID"));
	FreeThreadID = (ThreadIDFn)GetProcAddress(tier0, XorStr("FreeThreadID"));

	Threading::InitThreads();

	DispatchToAllThreads<decltype(AllocateThreadIDWrapper), AllocateThreadIDWrapper>(nullptr);

	// b1g fart.
	static bool bDownloaded = false;
	if (!bDownloaded) {
		// XDDXD
		g_Vars.menu.key.key = VK_INSERT;
		// xd v2 :D
		g_Vars.rage.key.cond = 2;
		bDownloaded = true;
	}

	if (Interfaces::Create(pArgs->lpReserved)) {
		Interfaces::m_pInputSystem->EnableInput(true);

		for (auto& child : g_Vars.m_children) {
			child->Save();

			auto json = child->GetJson();
			g_Vars.m_json_default_cfg[child->GetName()] = (json);
		}
	}
	return FALSE;
}

LONG WINAPI CrashHandlerWrapper(struct _EXCEPTION_POINTERS* exception) {
	auto ret = ICrashHandler::Get()->OnCrashProgramm(exception);
	return ret;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) {
	if (dwReason == DLL_PROCESS_ATTACH) {
		DllArguments* args = new DllArguments();
		args->hModule = hModule;
		args->lpReserved = lpReserved;

		SetUnhandledExceptionFilter(CrashHandlerWrapper);
		//AddVectoredExceptionHandler( 1, CrashHandlerWrapper );

		HANDLE thread;

		syscall(NtCreateThreadEx)(&thread, THREAD_ALL_ACCESS, nullptr, current_process,
			nullptr, args, THREAD_CREATE_FLAGS_CREATE_SUSPENDED | THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER, NULL, NULL, NULL, nullptr);
		CONTEXT context;
		context.ContextFlags = CONTEXT_FULL;
		syscall(NtGetContextThread)(thread, &context);
		context.Eax = reinterpret_cast<uint32_t>(&Entry);
		syscall(NtSetContextThread)(thread, &context);
		syscall(NtResumeThread)(thread, nullptr);

		return TRUE;
	}

	return FALSE;
}
```

`CSGO SDK/Features/Game/Prediction.cpp`:

```cpp
#include "Prediction.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "../../source.hpp"
#include "../../SDK/Valve/CBaseHandle.hpp"
#include "../../SDK/displacement.hpp"
#include "../Rage/TickbaseShift.hpp"
#include "../../Hooking/Hooked.hpp"
#include <deque>

namespace Engine
{
	// C_BasePlayer::PhysicsSimulate & CPrediction::RunCommand rebuild
	void Prediction::Begin(Encrypted_t<CUserCmd> _cmd, bool* send_packet, int command_number) {
		predictionData->m_pCmd = _cmd;
		predictionData->m_RestoreData.is_filled = false;
		predictionData->m_pSendPacket = send_packet;

		if (!predictionData->m_pCmd.IsValid())
			return;

		predictionData->m_pPlayer = C_CSPlayer::GetLocalPlayer();

		if (!predictionData->m_pPlayer || predictionData->m_pPlayer->IsDead())
			return;

		predictionData->m_pWeapon = (C_WeaponCSBaseGun*)predictionData->m_pPlayer->m_hActiveWeapon().Get();

		if (!predictionData->m_pWeapon)
			return;

		predictionData->m_pWeaponInfo = predictionData->m_pWeapon->GetCSWeaponData();

		if (!predictionData->m_pWeaponInfo.IsValid())
			return;

		m_bInPrediction = true;

		Engine::Prediction::Instance()->RunGamePrediction();

		// correct tickbase.
		if (!m_pLastCmd || m_pLastCmd->hasbeenpredicted)
			m_iSeqDiff = command_number - predictionData->m_pPlayer->m_nTickBase();

		int nTickBaseBackup = predictionData->m_pPlayer->m_nTickBase();

		predictionData->m_nTickBase = MAX(predictionData->m_pPlayer->m_nTickBase(), command_number - m_iSeqDiff);

		m_pLastCmd = predictionData->m_pCmd.Xor();

		predictionData->m_fFlags = predictionData->m_pPlayer->m_fFlags();
		predictionData->m_vecVelocity = predictionData->m_pPlayer->m_vecVelocity();

		predictionData->m_flCurrentTime = Interfaces::m_pGlobalVars->curtime;
		predictionData->m_flFrameTime = Interfaces::m_pGlobalVars->frametime;

		if (Engine::Displacement.Function.m_MD5PseudoRandom) {
			predictionData->m_pCmd->random_seed = ((uint32_t(__thiscall*)(uint32_t))Displacement.Function.m_MD5PseudoRandom)(predictionData->m_pCmd->command_number) & 0x7fffffff;
		}

		bool bEnginePaused = *(bool*)(uintptr_t(Interfaces::m_pPrediction.Xor()) + 10);

		// StartCommand rebuild
		predictionData->m_pPlayer->SetCurrentCommand(predictionData->m_pCmd.Xor());
		C_BaseEntity::SetPredictionRandomSeed(predictionData->m_pCmd.Xor());
		C_BaseEntity::SetPredictionPlayer(predictionData->m_pPlayer);

		*reinterpret_cast<CUserCmd**>(uint32_t(predictionData->m_pPlayer) + 0x3314) = predictionData->m_pCmd.Xor(); // m_pCurrentCommand
		*reinterpret_cast<CUserCmd**>(uint32_t(predictionData->m_pPlayer) + 0x326C) = predictionData->m_pCmd.Xor(); // unk01

		Interfaces::m_pGlobalVars->curtime = TICKS_TO_TIME(predictionData->m_pPlayer->m_nTickBase());
		Interfaces::m_pGlobalVars->frametime = Interfaces::m_pGlobalVars->interval_per_tick;

		Interfaces::m_pGameMovement->StartTrackPredictionErrors(predictionData->m_pPlayer);

		// Setup input.
		Interfaces::m_pPrediction->SetupMove(predictionData->m_pPlayer, predictionData->m_pCmd.Xor(), Interfaces::m_pMoveHelper.Xor(), &predictionData->m_MoveData);

		predictionData->m_RestoreData.m_MoveData = predictionData->m_MoveData;
		predictionData->m_RestoreData.is_filled = true;
		predictionData->m_RestoreData.Setup(predictionData->m_pPlayer);

		predictionData->m_bFirstTimePrediction = *(bool*)(uintptr_t(Interfaces::m_pPrediction.Xor()) + 24);
		predictionData->m_bInPrediction = *(bool*)(uintptr_t(Interfaces::m_pPrediction.Xor()) + 8);

		*(bool*)(uintptr_t(Interfaces::m_pPrediction.Xor()) + 8) = true;
		*(bool*)(uintptr_t(Interfaces::m_pPrediction.Xor()) + 24) = false;

		Interfaces::m_pMoveHelper->SetHost(predictionData->m_pPlayer);

		Interfaces::m_pGameMovement->ProcessMovement(predictionData->m_pPlayer, &predictionData->m_MoveData);

		Interfaces::m_pPrediction->FinishMove(predictionData->m_pPlayer, predictionData->m_pCmd.Xor(), &predictionData->m_MoveData);

		predictionData->m_nTickBase = nTickBaseBackup;

		*(bool*)(uintptr_t(Interfaces::m_pPrediction.Xor()) + 24) = predictionData->m_bFirstTimePrediction;
		*(bool*)(uintptr_t(Interfaces::m_pPrediction.Xor()) + 8) = predictionData->m_bInPrediction;

		predictionData->m_pWeapon->UpdateAccuracyPenalty();

		m_flSpread = predictionData->m_pWeapon->GetSpread();
		m_flInaccuracy = predictionData->m_pWeapon->GetInaccuracy();
		m_flWeaponRange = predictionData->m_pWeaponInfo->m_flWeaponRange;
	}

	void Prediction::Repredict() {
		Engine::Prediction::Instance()->RunGamePrediction();

		predictionData->m_RestoreData.Apply(predictionData->m_pPlayer);

		// set move data members that getting copied from CUserCmd
		// rebuilded from CPrediction::SetupMove
		predictionData->m_MoveData = predictionData->m_RestoreData.m_MoveData;
		predictionData->m_MoveData.m_flForwardMove = predictionData->m_pCmd->forwardmove;
		predictionData->m_MoveData.m_flSideMove = predictionData->m_pCmd->sidemove;
		predictionData->m_MoveData.m_flUpMove = predictionData->m_pCmd->upmove;
		predictionData->m_MoveData.m_nButtons = predictionData->m_pCmd->buttons;
		predictionData->m_MoveData.m_vecOldAngles.y = predictionData->m_pCmd->viewangles.pitch;
		predictionData->m_MoveData.m_vecOldAngles.z = predictionData->m_pCmd->viewangles.yaw;
		predictionData->m_MoveData.m_outStepHeight = predictionData->m_pCmd->viewangles.roll;
		predictionData->m_MoveData.m_vecViewAngles.pitch = predictionData->m_pCmd->viewangles.pitch;
		predictionData->m_MoveData.m_vecViewAngles.yaw = predictionData->m_pCmd->viewangles.yaw;
		predictionData->m_MoveData.m_vecViewAngles.roll = predictionData->m_pCmd->viewangles.roll;
		predictionData->m_MoveData.m_nImpulseCommand = predictionData->m_pCmd->impulse;

		*(bool*)(uintptr_t(Interfaces::m_pPrediction.Xor()) + 8) = true;
		*(bool*)(uintptr_t(Interfaces::m_pPrediction.Xor()) + 24) = false;

		Interfaces::m_pMoveHelper->SetHost(predictionData->m_pPlayer);

		Interfaces::m_pGameMovement->ProcessMovement(predictionData->m_pPlayer, &predictionData->m_MoveData);

		Interfaces::m_pPrediction->FinishMove(predictionData->m_pPlayer, predictionData->m_pCmd.Xor(), &predictionData->m_MoveData);

		Interfaces::m_pMoveHelper->ProcessImpacts();

		*(bool*)(uintptr_t(Interfaces::m_pPrediction.Xor()) + 24) = predictionData->m_bFirstTimePrediction;
		*(bool*)(uintptr_t(Interfaces::m_pPrediction.Xor()) + 8) = predictionData->m_bInPrediction;

		predictionData->m_pWeapon->UpdateAccuracyPenalty();

		m_flSpread = predictionData->m_pWeapon->GetSpread();
		m_flInaccuracy = predictionData->m_pWeapon->GetInaccuracy();
		m_flWeaponRange = predictionData->m_pWeaponInfo->m_flWeaponRange;
	}

	void Prediction::PostEntityThink(C_CSPlayer* player) {
		static auto PostThinkVPhysics = reinterpret_cast<bool(__thiscall*)(C_BaseEntity*)>(Memory::Scan("client.dll", "55 8B EC 83 E4 F8 81 EC ? ? ? ? 53 8B D9 56 57 83 BB ? ? ? ? ? 75 50 8B 0D"));
		static auto SimulatePlayerSimulatedEntities = reinterpret_cast<void(__thiscall*)(C_BaseEntity*)>(Memory::Scan("client.dll", "56 8B F1 57 8B BE ? ? ? ? 83 EF 01 78 72 90 8B 86"));

		if (player && !player->IsDead()) {
			using UpdateCollisionBoundsFn = void(__thiscall*)(void*);
			Memory::VCall<UpdateCollisionBoundsFn>(player, 329)(player);

			if (player->m_fFlags() & FL_ONGROUND)
				*reinterpret_cast<uintptr_t*>(uintptr_t(player) + 0x3004) = 0;

			if (*reinterpret_cast<int*>(uintptr_t(player) + 0x28AC) == -1) {
				using SetSequenceFn = void(__thiscall*)(void*, int);
				Memory::VCall<SetSequenceFn>(player, 213)(player, 0);
			}

			using StudioFrameAdvanceFn = void(__thiscall*)(void*);
			Memory::VCall<StudioFrameAdvanceFn>(player, 214)(player);

			PostThinkVPhysics(player);
		}
		SimulatePlayerSimulatedEntities(player);
	}

	void Prediction::End() {
		if (!predictionData->m_pCmd.IsValid() || !predictionData->m_pPlayer || !predictionData->m_pWeapon)
			return;

		Interfaces::m_pGlobalVars->curtime = predictionData->m_flCurrentTime;
		Interfaces::m_pGlobalVars->frametime = predictionData->m_flFrameTime;

		//CPrediction::RunPostThink rebuild
		PostEntityThink(predictionData->m_pPlayer);

		Interfaces::m_pGameMovement->FinishTrackPredictionErrors(predictionData->m_pPlayer);

		auto& correct = predictionData->m_CorrectionData.emplace_front();
		correct.command_nr = predictionData->m_pCmd->command_number;
		correct.tickbase = predictionData->m_pPlayer->m_nTickBase();
		correct.tickbase_shift = 0;
		correct.chokedcommands = Interfaces::m_pClientState->m_nChokedCommands() + 1;
		correct.tickcount = Interfaces::m_pGlobalVars->tickcount;

		auto& out = predictionData->m_OutgoingCommands.emplace_back();
		out.is_outgoing = *predictionData->m_pSendPacket != false;
		out.command_nr = predictionData->m_pCmd->command_number;
		out.is_used = false;
		out.prev_command_nr = 0;

		if (*predictionData->m_pSendPacket) {
			predictionData->m_ChokedNr.clear();
		}
		else {
			predictionData->m_ChokedNr.push_back(predictionData->m_pCmd->command_number);
		}

		while (predictionData->m_CorrectionData.size() > int(2.0f / Interfaces::m_pGlobalVars->interval_per_tick)) {
			predictionData->m_CorrectionData.pop_back();
		}

		Interfaces::m_pMoveHelper->SetHost(nullptr);

		// Finish command
		predictionData->m_pPlayer->SetCurrentCommand(nullptr);
		C_BaseEntity::SetPredictionRandomSeed(nullptr);
		C_BaseEntity::SetPredictionPlayer(nullptr);

		Interfaces::m_pGameMovement->Reset();

		m_bInPrediction = false;
	}

	void Prediction::Invalidate() {
		predictionData->m_pCmd = nullptr;
		predictionData->m_pPlayer = nullptr;
		predictionData->m_pWeapon = nullptr;
		predictionData->m_pSendPacket = nullptr;
		predictionData->m_OutgoingCommands.clear();

		predictionData->m_RestoreData.Reset();
		predictionData->m_RestoreData.is_filled = false;
	}

	void Prediction::RunGamePrediction() {
		// force game to repredict data
		//if( g_Vars.globals.LastVelocityModifier < 1.0f ) {
		//	// https://github.com/pmrowla/hl2sdk-csgo/blob/49e950f3eb820d88825f75e40f56b3e64790920a/game/client/prediction.cpp#L1533
		//	*( uint8_t* )( uintptr_t( Interfaces::m_pPrediction.Xor( ) ) + 0x24 ) = 1; // m_bPreviousAckHadErrors 
		//	*( uint32_t* )( uintptr_t( Interfaces::m_pPrediction.Xor( ) ) + 0x1C ) = 0; // m_nCommandsPredicted 
		//}

		if (Interfaces::m_pClientState->m_nDeltaTick() > 0) {
			Interfaces::m_pPrediction->Update(Interfaces::m_pClientState->m_nDeltaTick(), Interfaces::m_pClientState->m_nDeltaTick() > 0,
				Interfaces::m_pClientState->m_nLastCommandAck(),
				Interfaces::m_pClientState->m_nLastOutgoingCommand() + Interfaces::m_pClientState->m_nChokedCommands());
		}
	}

	int Prediction::GetFlags() {
		return predictionData->m_fFlags;
	}

	Vector Prediction::GetVelocity() {
		return predictionData->m_vecVelocity;
	}

	Encrypted_t<CUserCmd> Prediction::GetCmd() {
		return predictionData->m_pCmd;
	}

	float Prediction::GetFrametime() {
		return predictionData->m_flFrameTime;
	}

	float Prediction::GetCurtime() {
		return predictionData->m_flCurrentTime;
	}

	float Prediction::GetSpread() {
		return m_flSpread;
	}

	float Prediction::GetInaccuracy() {
		return m_flInaccuracy;
	}

	float Prediction::GetWeaponRange() {
		return m_flWeaponRange;
	}

	// Netvar compression fix
	void Prediction::OnFrameStageNotify(ClientFrameStage_t stage) {
		if (stage != FRAME_NET_UPDATE_POSTDATAUPDATE_START)
			return;

		auto local = C_CSPlayer::GetLocalPlayer();

		if (!local)
			return;

		auto slot = local->m_nTickBase();
		auto data = &predictionData->m_Data[slot % 150];

		if (!data)
			return;

		if (data->m_nTickbase != slot)
			return;

		if (!m_bGetNetvarCompressionData)
			return;

		auto GetDelta = [](const QAngle& a, const QAngle& b) {
			auto delta = a - b;
			return std::sqrt(delta.x * delta.x + delta.y * delta.y + delta.z * delta.z);
		};

		if (GetDelta(local->m_aimPunchAngle(), data->m_aimPunchAngle) < 0.03125f) {
			local->m_aimPunchAngle() = data->m_aimPunchAngle;
		}

		if (GetDelta(local->m_aimPunchAngleVel(), data->m_aimPunchAngleVel) < 0.03125f) {
			local->m_aimPunchAngleVel() = data->m_aimPunchAngleVel;
		}

		if (local->m_vecViewOffset().Distance(data->m_vecViewOffset) < 0.03125f) {
			local->m_vecViewOffset() = data->m_vecViewOffset;
		}

		//if( fabs( local->m_flVelocityModifier( ) - data->m_flVelocityModifier ) < 0.03125f ) {
		//	local->m_flVelocityModifier( ) = data->m_flVelocityModifier;
		//}
	}

	void Prediction::OnRunCommand(C_CSPlayer* player, CUserCmd* cmd) {
		if (!player)
			return;

		auto local = C_CSPlayer::GetLocalPlayer();

		if (!local || local != player || !predictionData.IsValid())
			return;

		if (cmd->hasbeenpredicted) {
			for (auto& data : predictionData->m_Data) {
				data.m_nTickbase--;
			}

			return;
		}
	}

	bool Prediction::ShouldSimulate(int command_number) {
		return true;
	}

	void Prediction::PacketCorrection(uintptr_t cl_state) {

		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local || local->IsDead()) {
			predictionData->m_CorrectionData.clear();
			return;
		}

		// Did we get any messages this tick (i.e., did we call PreEntityPacketReceived)?
		if (*(int*)(uintptr_t(cl_state) + 0x164) == *(int*)(uintptr_t(cl_state) + 0x16C)) {
			auto ack_cmd = *(int*)(uintptr_t(cl_state) + 0x4D2C);
			auto correct = std::find_if(predictionData->m_CorrectionData.begin(), predictionData->m_CorrectionData.end(), [ack_cmd](const CorrectionData& a) {
				return a.command_nr == ack_cmd;
				});

			if (correct != predictionData->m_CorrectionData.begin() && correct != predictionData->m_CorrectionData.end()) {
				//if( g_Vars.globals.LastVelocityModifier > ( local->m_flVelocityModifier( ) + ( TIME_TO_TICKS( Interfaces::m_pClientState->m_nChokedCommands( ) ) * 0.4f ) ) ) {
				//	auto weapon = ( C_WeaponCSBaseGun* )local->m_hActiveWeapon( ).Get( );
				//	if( !weapon || ( weapon && weapon->m_iItemDefinitionIndex( ) != WEAPON_REVOLVER && weapon->GetCSWeaponData( )->m_iWeaponType != WEAPONTYPE_GRENADE ) ) {
				//		for( auto nr : predictionData->m_ChokedNr ) {
				//			auto cmd = &Interfaces::m_pInput->m_pCommands[ nr % 150 ];
				//			auto verified = &Interfaces::m_pInput->m_pVerifiedCommands[ nr % 150 ];
				//
				//			if( cmd->buttons & ( IN_ATTACK2 | IN_ATTACK ) ) {
				//				cmd->buttons &= ~IN_ATTACK;
				//				verified->m_cmd = *cmd;
				//				verified->m_crc = cmd->GetChecksum( );
				//			}
				//		}
				//	}
				//}
				//
				//g_Vars.globals.LastVelocityModifier = local->m_flVelocityModifier( );
			}
		}
	}

	void Prediction::KeepCommunication(bool* bSendPacket, int command_number) {
		auto local = C_CSPlayer::GetLocalPlayer();
		auto net_channel = Interfaces::m_pEngine->GetNetChannelInfo();
		if (!net_channel) {
			g_Vars.globals.cmds.clear();
			return;
		}
		// only if moving
		if (!bSendPacket && local->m_vecVelocity().Length() > 0.1)
		{
			if (net_channel->m_nChokedPackets > 0 && !(net_channel->m_nChokedPackets % 4))
			{
				auto backup_choke = net_channel->m_nChokedPackets;
				net_channel->m_nChokedPackets = 0;

				net_channel->SendDatagram();
				--net_channel->m_nOutSequenceNr;

				net_channel->m_nChokedPackets = backup_choke;
			}
		}
	}

	void Prediction::StoreNetvarCompression(CUserCmd* cmd)
	{
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local)
			return;

		// collect data for netvar compression fix
		auto slot = cmd->command_number;
		auto data = &predictionData->m_Data[slot % 150];

		data->m_nCommandNumber = cmd->command_number;
		data->m_aimPunchAngle = local->m_aimPunchAngle();
		data->m_aimPunchAngleVel = local->m_aimPunchAngleVel();
		data->m_vecViewOffset = local->m_vecViewOffset();
		//data->m_flVelocityModifier = local->m_flVelocityModifier( );
		m_bGetNetvarCompressionData = true;
	}

	void Prediction::RestoreNetvarCompression(CUserCmd* cmd)
	{
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local)
			return;

		// restore data for netvar compression fix
		auto slot = cmd->command_number;
		auto data = predictionData->m_Data[slot % 150];
		if (m_bGetNetvarCompressionData) {
			cmd->command_number = data.m_nCommandNumber;
			local->m_aimPunchAngle() = data.m_aimPunchAngle;
			local->m_aimPunchAngleVel() = data.m_aimPunchAngleVel;
			local->m_vecViewOffset() = data.m_vecViewOffset;
			//local->m_flVelocityModifier( ) = data.m_flVelocityModifier;

			m_bGetNetvarCompressionData = false;
		}
	}

	static PredictionData _xoreddata;
	Prediction::Prediction() : predictionData(&_xoreddata) {
	}

	Prediction::~Prediction() {
	}

	void RestoreData::Setup(C_CSPlayer* player) {
		this->m_aimPunchAngle = player->m_aimPunchAngle();
		this->m_aimPunchAngleVel = player->m_aimPunchAngleVel();
		this->m_viewPunchAngle = player->m_viewPunchAngle();

		this->m_vecViewOffset = player->m_vecViewOffset();
		this->m_vecBaseVelocity = player->m_vecBaseVelocity();
		this->m_vecVelocity = player->m_vecVelocity();
		this->m_vecOrigin = player->m_vecOrigin();

		this->m_flFallVelocity = player->m_flFallVelocity();
		//this->m_flVelocityModifier = player->m_flVelocityModifier( );
		this->m_flDuckAmount = player->m_flDuckAmount();
		this->m_flDuckSpeed = player->m_flDuckSpeed();

		static int playerSurfaceFrictionOffset = Memory::FindInDataMap(player->GetPredDescMap(), XorStr("m_surfaceFriction"));
		float playerSurfaceFriction = *(float*)(uintptr_t(player) + playerSurfaceFrictionOffset);

		this->m_surfaceFriction = playerSurfaceFriction;

		static int hGroundEntity = Memory::FindInDataMap(player->GetPredDescMap(), XorStr("m_hGroundEntity"));
		int playerhGroundEntity = *(int*)(uintptr_t(player) + hGroundEntity);

		this->m_hGroundEntity = playerhGroundEntity;
		this->m_nMoveType = player->m_MoveType();
		this->m_nFlags = player->m_fFlags();
		//this->m_nTickBase = player->m_nTickBase( );

		auto weapon = (C_WeaponCSBaseGun*)player->m_hActiveWeapon().Get();
		if (weapon) {
			static int fAccuracyPenalty = Memory::FindInDataMap(player->GetPredDescMap(), XorStr("m_fAccuracyPenalty"));
			float playerfAccuracyPenalty = *(float*)(uintptr_t(player) + fAccuracyPenalty);

			this->m_fAccuracyPenalty = playerfAccuracyPenalty;
			this->m_flRecoilIndex = weapon->m_flRecoilIndex();
		}

		this->is_filled = true;
	}

	void RestoreData::Apply(C_CSPlayer* player) {
		if (!this->is_filled)
			return;

		player->m_aimPunchAngle() = this->m_aimPunchAngle;
		player->m_aimPunchAngleVel() = this->m_aimPunchAngleVel;
		player->m_viewPunchAngle() = this->m_viewPunchAngle;

		player->m_vecViewOffset() = this->m_vecViewOffset;
		player->m_vecBaseVelocity() = this->m_vecBaseVelocity;
		player->m_vecVelocity() = this->m_vecVelocity;
		player->m_vecOrigin() = this->m_vecOrigin;

		player->m_flFallVelocity() = this->m_flFallVelocity;
		//player->m_flVelocityModifier( ) = this->m_flVelocityModifier;
		player->m_flDuckAmount() = this->m_flDuckAmount;
		player->m_flDuckSpeed() = this->m_flDuckSpeed;

		static int playerSurfaceFrictionOffset = Memory::FindInDataMap(player->GetPredDescMap(), XorStr("m_surfaceFriction"));
		float playerSurfaceFriction = *(float*)(uintptr_t(player) + playerSurfaceFrictionOffset);
		*(float*)(uintptr_t(player) + playerSurfaceFrictionOffset) = this->m_surfaceFriction;

		static int hGroundEntity = Memory::FindInDataMap(player->GetPredDescMap(), XorStr("m_hGroundEntity"));
		*(int*)(uintptr_t(player) + hGroundEntity) = this->m_hGroundEntity;

		player->m_MoveType() = this->m_nMoveType;
		player->m_fFlags() = this->m_nFlags;
		//player->m_nTickBase( ) = this->m_nTickBase;

		auto weapon = (C_WeaponCSBaseGun*)player->m_hActiveWeapon().Get();
		if (weapon) {
			static int fAccuracyPenalty = Memory::FindInDataMap(player->GetPredDescMap(), XorStr("m_fAccuracyPenalty"));

			*(float*)(uintptr_t(player) + fAccuracyPenalty) = this->m_fAccuracyPenalty;
			weapon->m_flRecoilIndex() = this->m_flRecoilIndex;
		}
	}
}
```

`CSGO SDK/Features/Game/Prediction.hpp`:

```hpp
#pragma once

#include "../../SDK/sdk.hpp"
#include <deque>

class C_CSPlayer;

namespace Engine {
	struct RestoreData {
		void Reset() {
			m_aimPunchAngle.Set();
			m_aimPunchAngleVel.Set();
			m_viewPunchAngle.Set();

			m_vecViewOffset.Set();
			m_vecBaseVelocity.Set();
			m_vecVelocity.Set();
			m_vecOrigin.Set();

			m_flFallVelocity = 0.0f;
			m_flVelocityModifier = 0.0f;
			m_flDuckAmount = 0.0f;
			m_flDuckSpeed = 0.0f;
			m_surfaceFriction = 0.0f;

			m_fAccuracyPenalty = 0.0f;
			m_flRecoilIndex = 0.f;

			m_hGroundEntity = 0;
			m_nMoveType = 0;
			m_nFlags = 0;
			m_nTickBase = 0;
		}

		void Setup(C_CSPlayer* player);

		void Apply(C_CSPlayer* player);

		CMoveData m_MoveData;

		QAngle m_aimPunchAngle = { };
		QAngle m_aimPunchAngleVel = { };
		QAngle m_viewPunchAngle = { };

		Vector m_vecViewOffset = { };
		Vector m_vecBaseVelocity = { };
		Vector m_vecVelocity = { };
		Vector m_vecOrigin = { };

		float m_flFallVelocity = 0.0f;
		float m_flVelocityModifier = 0.0f;
		float m_flDuckAmount = 0.0f;
		float m_flDuckSpeed = 0.0f;
		float m_surfaceFriction = 0.0f;

		float m_fAccuracyPenalty = 0.0f;
		float m_flRecoilIndex = 0;

		int m_hGroundEntity = 0;
		int m_nMoveType = 0;
		int m_nFlags = 0;
		int m_nTickBase = 0;

		bool is_filled = false;
	};

	struct PlayerData {
		int m_nTickbase = 0;
		int m_nCommandNumber = 0;
		QAngle m_aimPunchAngle = { };
		QAngle m_aimPunchAngleVel = { };
		Vector m_vecViewOffset = { };
		float m_flVelocityModifier = 0.f;
	};

	struct LastPredData {
		QAngle m_aimPunchAngle = { };
		QAngle m_aimPunchAngleVel = { };
		Vector m_vecBaseVelocity = { };
		Vector m_vecViewOffset = { };
		Vector m_vecOrigin = { };
		float m_flFallVelocity = 0.0f;
		float m_flDuckAmount = 0.0f;
		float m_flDuckSpeed = 0.0f;
		float m_flVelocityModifier = 0.0f;
		int m_nTickBase = 0;
	};

	struct CorrectionData {
		int command_nr;
		int tickbase;
		int tickbase_shift;
		int tickcount;
		int chokedcommands;
	};

	struct OutgoingData {
		int command_nr;
		int prev_command_nr;

		bool is_outgoing;
		bool is_used;
	};

	struct PredictionData {
		Encrypted_t<CUserCmd> m_pCmd = nullptr;
		bool* m_pSendPacket = nullptr;

		C_CSPlayer* m_pPlayer = nullptr;
		C_WeaponCSBaseGun* m_pWeapon = nullptr;
		Encrypted_t<CCSWeaponInfo> m_pWeaponInfo = nullptr;

		int m_nTickBase = 0;
		int m_fFlags = 0;
		Vector m_vecVelocity{ };

		bool m_bInPrediction = false;
		bool m_bFirstTimePrediction = false;

		float m_flCurrentTime = 0.0f;
		float m_flFrameTime = 0.0f;

		CMoveData m_MoveData = { };
		RestoreData m_RestoreData;

		PlayerData m_Data[150] = { };

		std::deque<CorrectionData> m_CorrectionData;
		std::vector<OutgoingData> m_OutgoingCommands;
		std::vector<int> m_ChokedNr;

		bool m_bInitDatamap = false;
		int m_Offset_nImpulse;
		int m_Offset_nButtons;
		int m_Offset_afButtonLast;
		int m_Offset_afButtonPressed;
		int m_Offset_afButtonReleased;
		int m_Offset_afButtonForced;
	};

	class Prediction : public Core::Singleton<Prediction> {
	public:
		void Begin(Encrypted_t<CUserCmd> cmd, bool* send_packet, int command_number);
		void Repredict();
		void End();
		void Invalidate();
		void RunGamePrediction();

		int GetFlags();
		Vector GetVelocity();

		Encrypted_t<CUserCmd> GetCmd();

		float GetFrametime();
		float GetCurtime();
		float GetSpread();
		float GetInaccuracy();
		float GetWeaponRange();

		void OnFrameStageNotify(ClientFrameStage_t stage);
		void OnRunCommand(C_CSPlayer* player, CUserCmd* cmd);

		void PostEntityThink(C_CSPlayer* player);

		bool ShouldSimulate(int command_number);
		void PacketCorrection(uintptr_t cl_state);
		void KeepCommunication(bool* bSendPacket, int command_number);


		void StoreNetvarCompression(CUserCmd* cmd);
		void RestoreNetvarCompression(CUserCmd* cmd);

		bool InPrediction() {
			return m_bInPrediction;
		}

	private:
		Prediction();
		~Prediction();

		LastPredData m_LastPredictedData;
		CUserCmd* m_pLastCmd;

		friend class Core::Singleton<Prediction>;
		Encrypted_t<PredictionData> predictionData;
		bool m_bInPrediction = false;

		int m_iSeqDiff = 0;

		float m_flSpread = 0.f;
		float m_flInaccuracy = 0.f;
		float m_flWeaponRange = 0.f;

		bool m_bFixSendDataGram = false;
		bool m_bNeedStoreNetvarsForFixingNetvarCompresion = false;
		bool m_bGetNetvarCompressionData = false;
	};
}
```

`CSGO SDK/Features/Game/SetupBones.cpp`:

```cpp
#include "SetupBones.hpp"

#include "../../SDK/Displacement.hpp"
#include "../../Hooking/Hooked.hpp"
#include "../../SDK/Classes/weapon.hpp"

#include "../../SDK/Valve/CBaseHandle.hpp"

// ......
inline CHandle<C_BaseEntity> m_hRagdoll(C_CSPlayer* entity) {
	return *(CHandle<C_BaseEntity>*)((int32_t)entity + Engine::Displacement.DT_CSPlayer.m_hRagdoll);
}

BoneSetup g_BoneSetup;

bool BoneSetup::SetupBonesRebuild(C_CSPlayer* entity, matrix3x4_t* pBoneMatrix, int nBoneCount, int boneMask, float time, int flags) {
	if (*(int*)(uintptr_t(entity) + Engine::Displacement.DT_BaseViewModel.m_nSequence) == -1) {
		return false;
	}

	if (boneMask == -1) {
		boneMask = entity->m_iPrevBoneMask();
	}

	boneMask = boneMask | 0x80000;

	// If we're setting up LOD N, we have set up all lower LODs also
	// because lower LODs always use subsets of the bones of higher LODs.
	int nLOD = 0;
	int nMask = BONE_USED_BY_VERTEX_LOD0;
	for (; nLOD < MAX_NUM_LODS; ++nLOD, nMask <<= 1) {
		if (boneMask & nMask)
			break;
	}
	for (; nLOD < MAX_NUM_LODS; ++nLOD, nMask <<= 1) {
		boneMask |= nMask;
	}

	auto model_bone_counter = **(unsigned long**)(Engine::Displacement.C_BaseAnimating.InvalidateBoneCache + 0x000A);

	CBoneAccessor backup_bone_accessor = entity->m_BoneAccessor();
	CBoneAccessor* bone_accessor = &entity->m_BoneAccessor();
	if (!bone_accessor)
		return false;

	if (entity->m_iMostRecentModelBoneCounter() != model_bone_counter || (flags & BoneSetupFlags::ForceInvalidateBoneCache)) {
		if (FLT_MAX >= entity->m_flLastBoneSetupTime() || time < entity->m_flLastBoneSetupTime()) {
			bone_accessor->m_ReadableBones = 0;
			bone_accessor->m_WritableBones = 0;
			entity->m_flLastBoneSetupTime() = (time);
		}

		entity->m_iPrevBoneMask() = entity->m_iAccumulatedBoneMask();
		entity->m_iAccumulatedBoneMask() = 0;

		auto hdr = entity->m_pStudioHdr();
		if (hdr) { // profiler stuff
			((CStudioHdrEx*)hdr)->m_nPerfAnimatedBones = 0;
			((CStudioHdrEx*)hdr)->m_nPerfUsedBones = 0;
			((CStudioHdrEx*)hdr)->m_nPerfAnimationLayers = 0;
		}
	}

	// Keep track of everything asked for over the entire frame
	// But not those things asked for during bone setup
	entity->m_iAccumulatedBoneMask() |= boneMask;

	// fix enemy poses getting raped when going out of pvs
	entity->m_iOcclusionFramecount() = 0;
	entity->m_iOcclusionFlags() = 0;

	// Make sure that we know that we've already calculated some bone stuff this time around.
	entity->m_iMostRecentModelBoneCounter() = model_bone_counter;

	bool bReturnCustomMatrix = (flags & BoneSetupFlags::UseCustomOutput) && pBoneMatrix;
	CStudioHdr* hdr = entity->m_pStudioHdr();
	if (!hdr) {
		return false;
	}

	// Setup our transform based on render angles and origin.
	Vector origin = (flags & BoneSetupFlags::UseInterpolatedOrigin) ? entity->GetAbsOrigin() : entity->m_vecOrigin();
	QAngle angles = entity->GetAbsAngles();

	alignas(16) matrix3x4_t parentTransform;
	parentTransform.AngleMatrix(angles, origin);

	boneMask |= entity->m_iPrevBoneMask();

	if (bReturnCustomMatrix) {
		bone_accessor->m_pBones = pBoneMatrix;
	}

	// Allow access to the bones we're setting up so we don't get asserts in here.
	int oldReadableBones = bone_accessor->GetReadableBones();
	int oldWritableBones = bone_accessor->GetWritableBones();
	int newWritableBones = oldReadableBones | boneMask;
	bone_accessor->SetWritableBones(newWritableBones);
	bone_accessor->SetReadableBones(newWritableBones);

	if (!(hdr->_m_pStudioHdr->flags & 0x00000010)) {
		C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer();

		entity->m_fEffects() |= EF_NOINTERP;

		entity->m_iEFlags() |= EFL_SETTING_UP_BONES;

		entity->m_pIk() = nullptr;
		entity->m_EntClientFlags |= 2; // ENTCLIENTFLAGS_DONTUSEIK

		alignas(16) Vector pos[128];
		alignas(16) Quaternion q[128];
		uint8_t computed[0x100];

		entity->StandardBlendingRules(hdr, pos, q, time, boneMask);

		std::memset(computed, 0, 0x100);
		entity->BuildTransformations(hdr, pos, q, parentTransform, boneMask, computed);

		entity->m_iEFlags() &= ~EFL_SETTING_UP_BONES;

		// entity->ControlMouth( hdr );

		if (!bReturnCustomMatrix /*&& !bSkipAnimFrame*/) {
			memcpy(entity->m_vecBonePos(), &pos[0], sizeof(Vector) * hdr->_m_pStudioHdr->numbones);
			memcpy(entity->m_quatBoneRot(), &q[0], sizeof(Quaternion) * hdr->_m_pStudioHdr->numbones);
		}
	}
	else {
		parentTransform = bone_accessor->m_pBones[0];
	}

	if ( /*boneMask & BONE_USED_BY_ATTACHMENT*/ flags & BoneSetupFlags::AttachmentHelper) {
		using AttachmentHelperFn = void(__thiscall*)(C_BaseEntity*, CStudioHdr*);
		((AttachmentHelperFn)Engine::Displacement.Function.m_AttachmentHelper)(entity, hdr);
	}

	// don't override bone cache if we're just generating a standalone matrix
	if (bReturnCustomMatrix) {
		*bone_accessor = backup_bone_accessor;

		return true;
	}

	return true;
}

bool BoneSetup::BuildBones(C_CSPlayer* entity, int mask, int flags) {
	// no need to restore this
	entity->m_bIsJiggleBonesEnabled() = false;

	// setup bones :-)
	return SetupBonesRebuild(entity, nullptr, -1, mask, Interfaces::m_pGlobalVars->curtime, flags);
}
```

`CSGO SDK/Features/Game/SetupBones.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"
#include "../../SDK/Classes/Player.hpp"

enum BoneSetupFlags {
	None = 0,
	UseInterpolatedOrigin = (1 << 0),
	UseCustomOutput = (1 << 1),
	ForceInvalidateBoneCache = (1 << 2),
	AttachmentHelper = (1 << 3),
};

class BoneSetup {
public:
	bool SetupBonesRebuild(C_CSPlayer* entity, matrix3x4_t* pBoneMatrix, int nBoneCount, int boneMask, float time, int flags);
	bool BuildBones(C_CSPlayer* entity, int boneMask, int flags);
};

extern BoneSetup g_BoneSetup;
```

`CSGO SDK/Features/Game/SimulationContext.cpp`:

```cpp
#include "../../source.hpp"
#include "SimulationContext.hpp"
#include "../../SDK/Displacement.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Classes/weapon.hpp"

static CTraceFilterWorldOnly world_filter;

inline void VectorMA(const Vector& start, float scale, const Vector& direction, Vector& dest) {
	dest.x = start.x + scale * direction.x;
	dest.y = start.y + scale * direction.y;
	dest.z = start.z + scale * direction.z;
}

void SimulationContext::TracePlayerBBox(const Vector& start, const Vector& end, unsigned int fMask, CGameTrace& pm) {
	Ray_t ray;
	ray.Init(start, end, pMins, pMaxs);
	Interfaces::m_pEngineTrace->TraceRay(ray, fMask, filter, &pm);
}

void SimulationContext::InitSimulationContext(C_CSPlayer* player) {
	static auto sv_maxspeed = Interfaces::m_pCvar->FindVar(XorStr("sv_maxspeed"));
	static auto sv_stepsize = Interfaces::m_pCvar->FindVar(XorStr("sv_stepsize"));

	//	 wihspeedClamped *= CS_PLAYER_SPEED_DUCK_MODIFIER;
	this->walking = false;
	this->m_vecOrigin = player->m_vecOrigin();
	this->m_vecVelocity = player->m_vecVelocity();
	this->simulationTicks = player->m_nTickBase();
	this->trace = CGameTrace{ };
	this->gravity = g_Vars.sv_gravity->GetFloat() * Interfaces::m_pGlobalVars->interval_per_tick * 0.5f;
	this->sv_jump_impulse = (g_Vars.sv_jump_impulse)->GetFloat();
	this->stepsize = sv_stepsize->GetFloat();
	this->pMins = player->m_Collision()->m_vecMins;
	this->pMaxs = player->m_Collision()->m_vecMaxs;
	this->player = player;
	this->filter = &world_filter;
	this->flags = player->m_fFlags() & 1 | player->m_fFlags() & 0xF8 | 2 * (((unsigned int)player->m_fFlags() >> 1) & 1);

	//static auto get_max_speed_idx = *( int* ) ( Memory::Scan( XorStr( "client.dll" ), XorStr( "8B 80 ?? ?? ?? ?? FF D0 8B 47 08" ) ) + 2 ) / 4;

	//get_max_speed_idx
	float maxSpeed = Memory::VCall< float(__thiscall*)(void*) >(player, 274)(player);

	this->flMaxSpeed = std::fminf(maxSpeed, sv_maxspeed->GetFloat());
}

void SimulationContext::ExtrapolatePlayer(float yaw) {
	static auto g_GameRules = *(uintptr_t**)(Engine::Displacement.Data.m_GameRules);
	if (!g_GameRules || *(bool*)(*(uintptr_t*)g_GameRules + 0x20) || (this->flags & (1 << 6)))
		return;

	CUserCmd cmd;
	cmd.viewangles.y = yaw;
	if (*(int*)(uintptr_t(this->player) + Engine::Displacement.DT_CSPlayer.m_iMoveState))
		cmd.forwardmove = 450.0f;

	if (this->flags & FL_DUCKING) {
		cmd.buttons |= IN_DUCK;
	}

	if (*(bool*)(uintptr_t(this->player) + Engine::Displacement.DT_CSPlayer.m_bIsWalking)) {
		cmd.buttons |= IN_SPEED;
	}

	if ((this->flags & 5) == 5)
		cmd.buttons |= IN_JUMP;

	RebuildGameMovement(&cmd);
}

void SimulationContext::TryPlayerMove() {
	auto ClipVelocity = [](Vector& in, Vector& normal, Vector& out, float overbounce) {
		auto  angle = normal[2];

		// Determine how far along plane to slide based on incoming direction.
		auto backoff = DotProduct(in, normal) * overbounce;

		for (int i = 0; i < 3; i++) {
			auto change = normal[i] * backoff;
			out[i] = in[i] - change;
		}

		// iterate once to make sure we aren't still moving through the plane
		float adjust = DotProduct(out, normal);
		if (adjust < 0.0f) {
			out -= (normal * adjust);
		}
	};

#define MAX_CLIP_PLANES 5 

	int			bumpcount;
	Vector		dir;
	float		d;
	int			numplanes;
	Vector		planes[MAX_CLIP_PLANES];
	Vector		primal_velocity, original_velocity;
	Vector      new_velocity;
	int			i, j;
	CGameTrace	pm;
	Vector		end;
	float		time_left, allFraction;
	int			blocked;

	blocked = 0;           // Assume not blocked
	numplanes = 0;           //  and not sliding along any planes

	original_velocity = this->m_vecVelocity;  // Store original velocity
	primal_velocity = this->m_vecVelocity;

	allFraction = 0;
	time_left = Interfaces::m_pGlobalVars->interval_per_tick;   // Total time for this movement operation.

	new_velocity.Init();

	for (bumpcount = 0; bumpcount < 4; bumpcount++) {
		if (this->m_vecVelocity.Length() == 0.0)
			break;

		// Assume we can move all the way from the current origin to the
		//  end point.

		VectorMA(this->m_vecOrigin, time_left, this->m_vecVelocity, end);

		TracePlayerBBox(this->m_vecOrigin, end, MASK_PLAYERSOLID, pm);
		if (pm.fraction > 0.0f && pm.fraction < 0.0001f) {
			pm.fraction = 0.0f;
		}

		allFraction += pm.fraction;

		// If we started in a solid object, or we were in solid space
		//  the whole way, zero out our velocity and return that we
		//  are blocked by floor and wall.
		if (pm.allsolid) {
			// entity is trapped in another solid
			this->m_vecVelocity.Set();
			return;
		}

		// If we moved some portion of the total distance, then
		//  copy the end position into the pmove.origin and 
		//  zero the plane counter.
		if (pm.fraction > 0) {
			if (pm.fraction == 1) {
				// There's a precision issue with terrain tracing that can cause a swept box to successfully trace
				// when the end position is stuck in the triangle.  Re-run the test with an uswept box to catch that
				// case until the bug is fixed.
				// If we detect getting stuck, don't allow the movement
				CGameTrace stuck;
				TracePlayerBBox(pm.endpos, pm.endpos, MASK_PLAYERSOLID, stuck);
				if (stuck.startsolid || stuck.fraction != 1.0f) {
					//Msg( XorStr( "Player will become stuck!!!\n" ) );
					this->m_vecVelocity.Set();
					break;
				}
			}

			// actually covered some distance
			this->m_vecOrigin = pm.endpos;
			original_velocity = this->m_vecVelocity;
			numplanes = 0;
		}

		// If we covered the entire distance, we are done
		//  and can return.
		if (pm.fraction == 1) {
			break;		// moved the entire distance
		}

		// Reduce amount of m_flFrameTime left by total time left * fraction
		//  that we covered.
		time_left -= time_left * pm.fraction;

		// Did we run out of planes to clip against?
		if (numplanes >= MAX_CLIP_PLANES) {
			// this shouldn't really happen
			//  Stop our movement if so.
			this->m_vecVelocity.Set();
			//Con_DPrintf(XorStr( "Too many planes 4\n" ));

			break;
		}

		// Set up next clipping plane
		planes[numplanes] = pm.plane.normal;
		numplanes++;

		// modify original_velocity so it parallels all of the clip planes
		//

		// reflect player velocity 
		// Only give this a try for first impact plane because you can get yourself stuck in an acute corner by jumping in place
		//  and pressing forward and nobody was really using this bounce/reflection feature anyway...
		if (numplanes == 1 &&
			player->m_MoveType() == MOVETYPE_WALK &&
			!(this->flags & FL_ONGROUND)) {
			for (i = 0; i < numplanes; i++) {
				if (planes[i][2] > 0.7f) {
					// floor or slope
					ClipVelocity(original_velocity, planes[i], new_velocity, 1.0f);
					original_velocity = new_velocity;
				}
				else {
					ClipVelocity(
						original_velocity,
						planes[i],
						new_velocity,
						1.0f);
				}
			}

			this->m_vecVelocity = new_velocity;
			original_velocity = new_velocity;
		}
		else {
			for (i = 0; i < numplanes; i++) {
				ClipVelocity(original_velocity, planes[i], this->m_vecVelocity, 1);

				for (j = 0; j < numplanes; j++) {
					if (j != i) {
						// Are we now moving against this plane?
						if (this->m_vecVelocity.Dot(planes[j]) < 0.f)
							break;	// not ok
					}
				}

				if (j == numplanes)  // DidnXorStr( 't have to clip, so we' )re ok
					break;
			}

			// Did we go all the way through plane set
			if (i == numplanes) {
				if (numplanes != 2) {
					this->m_vecVelocity.Set();
					break;
				}

				dir = planes[0].Cross(planes[1]);
				dir.Normalize();
				d = dir.Dot(this->m_vecVelocity);
				this->m_vecVelocity = dir * d;
			}

			//
			// if original velocity is against the original velocity, stop dead
			// to avoid tiny occilations in sloping corners
			//
			d = this->m_vecVelocity.Dot(primal_velocity);
			if (d <= 0.f) {
				//Con_DPrintf(XorStr( "Back\n" ));
				this->m_vecVelocity.Set();
				break;
			}
		}
	}

	if (allFraction == 0.f) {
		this->m_vecVelocity.Set();
	}
}

void SimulationContext::RebuildGameMovement(CUserCmd* ucmd) {

#define CS_PLAYER_SPEED_WALK_MODIFIER 0.52f
#define CS_PLAYER_SPEED_DUCK_MODIFIER 0.34f

	static auto sv_enablebunnyhopping = Interfaces::m_pCvar->FindVar(XorStr("sv_enablebunnyhopping"));
	static auto sv_walkable_normal = Interfaces::m_pCvar->FindVar(XorStr("sv_enablebunnyhopping"));

	this->buttons = ucmd->buttons;
	if (!this->walking) {
		this->walking = 1;
		if (ucmd->buttons & IN_SPEED) {
			auto v7 = this->flMaxSpeed * 0.52f;
			if (v7 + 25.0f > this->m_vecVelocity.Length())
				this->flMaxSpeed = v7;
		}
	}

	// StartGravity
	this->m_vecVelocity.z -= this->gravity;

	// CheckJumpButton
	if (ucmd->buttons & IN_JUMP && this->flags & FL_ONGROUND) {
		this->flags &= ~FL_ONGROUND;

		if (!sv_enablebunnyhopping->GetBool()) {
			auto v9 = this->flMaxSpeed * 1.1f;
			if (v9 > 0.0f) {
				auto v10 = this->m_vecVelocity.Length();
				if (v10 > v9) {
					auto v11 = v9 / v10;
					this->m_vecVelocity *= v11;
				}
			}
		}

		auto v12 = this->sv_jump_impulse;
		if (!(this->flags & FL_DUCKING))
			v12 += this->m_vecVelocity.z;
		this->m_vecVelocity.z = v12;
		this->m_vecVelocity.z = v12 - this->gravity;
	}

	// CheckParameters
	float  spd = (ucmd->forwardmove * ucmd->forwardmove) +
		(ucmd->sidemove * ucmd->sidemove) +
		(ucmd->upmove * ucmd->upmove);

	auto move = Vector2D(ucmd->forwardmove, ucmd->sidemove);
	if ((spd != 0.0) && (spd > flMaxSpeed * flMaxSpeed)) {
		float fRatio = flMaxSpeed / sqrt(spd);
		move *= fRatio;
	}

	if (this->flags & FL_ONGROUND && (this->flags & FL_DUCKING)) {
		float frac = 0.33333333f;
		move *= frac;
	}

	if (this->flags & FL_ONGROUND) {
		this->flMaxSpeed *= player->m_flVelocityModifier();

		this->m_vecVelocity.z = 0.0f;
		// Friction
		{
			static auto sv_stopspeed = Interfaces::m_pCvar->FindVar(XorStr("sv_stopspeed"));
			static auto sv_friction = Interfaces::m_pCvar->FindVar(XorStr("sv_friction"));

			auto speed = this->m_vecVelocity.Length2D();
			if (speed <= 0.1f) {
				this->m_vecVelocity.x = 0.0f;
				this->m_vecVelocity.y = 0.0f;
				this->m_vecVelocity.z = 0.0f;
			}
			else {
				auto control = std::fmaxf(sv_stopspeed->GetFloat(), speed);
				auto friction = sv_friction->GetFloat();
				auto drop = (control * friction) * Interfaces::m_pGlobalVars->interval_per_tick;

				auto newspeed = std::fmaxf(speed - drop, 0.0f);
				if (newspeed != speed) {
					newspeed = newspeed / speed;
					this->m_vecVelocity *= newspeed;
				}
			}
		}

		// WalkMove
		{

			auto bOnGround = this->flags & FL_ONGROUND;

			Vector right;
			auto forward = ucmd->viewangles.ToVectors(&right);

			if (forward.z != 0.0f) {
				forward.z = 0.0f;
				forward.Normalize();
			}

			if (right.z != 0.0f) {
				right.z = 0.0f;
				right.Normalize();
			}

			auto wishdir = forward * move.x + right * move.y;
			auto wishspeed = wishdir.Normalize();

			if (wishspeed > this->flMaxSpeed)
				wishspeed = this->flMaxSpeed;

			// accelerate
			this->m_vecVelocity.z = 0.0f;
			{
				static auto sv_accelerate_use_weapon_speed = Interfaces::m_pCvar->FindVar(XorStr("sv_accelerate_use_weapon_speed"));

				// See if we are changing direction a bit
				float currentspeed = this->m_vecVelocity.Dot(wishdir);

				// Reduce wishspeed by the amount of veer.
				float addspeed = wishspeed - currentspeed;

				if (addspeed > 0.0f) {
					// soufiw rebuild

					bool ducked = true;

					if (!(this->buttons & IN_DUCK)) {
						if ( /*!player->m_bDucking( ) && */!(player->m_fFlags() & FL_DUCKING))
							ducked = false;
					}
					bool in_speed = true;
					if (!(buttons & IN_SPEED) || ducked)
						in_speed = false;

					float clampedSpeed = fmaxf(currentspeed, 0.0f);
					float wishspeedClamped = fmaxf(wishspeed, 250.0f);

					C_CSPlayer* Player = player;

					bool InZoom = false;

					float FinalSpeed = 0.0f;

					bool v60 = false;
					auto weapon = (C_WeaponCSBaseGun*)player->m_hActiveWeapon().Get();
					if (sv_accelerate_use_weapon_speed->GetBool() && weapon) {
						auto weaponData = weapon->GetCSWeaponData();
						float maxSpeed = (weapon->m_weaponMode() == 0) ? weaponData->m_flMaxSpeed : weaponData->m_flMaxSpeed2;
						int unknown2 = *(int*)((uintptr_t)weaponData.Xor() + 456); // some zoom shit btw

						if (weapon->m_zoomLevel() <= 0 || unknown2 <= 1) {
							InZoom = false;
						}
						else {
							InZoom = maxSpeed * CS_PLAYER_SPEED_WALK_MODIFIER < 110.0f;
						}

						float maxSpeedNorm = maxSpeed * 0.004f; // 0.004 = 1.0 / 250.0
						float maxSpeedClamped = fminf(maxSpeedNorm, 1.0f);
						if (!ducked && !in_speed || InZoom)
							wishspeedClamped *= maxSpeedClamped;

						FinalSpeed = maxSpeedClamped * wishspeedClamped;
					}
					else {
						FinalSpeed = wishspeedClamped;
					}

					if (ducked) {
						if (!InZoom)
							wishspeedClamped *= CS_PLAYER_SPEED_DUCK_MODIFIER;
						FinalSpeed *= CS_PLAYER_SPEED_DUCK_MODIFIER;
					}

					if (in_speed) {
						if (!player->m_bHasHeavyArmor() /*&& !player->m_hCarriedHostage( ).Get( ) */ && !InZoom)
							wishspeedClamped *= CS_PLAYER_SPEED_WALK_MODIFIER;
						FinalSpeed *= CS_PLAYER_SPEED_WALK_MODIFIER;
					}

					auto accel = g_Vars.sv_accelerate->GetFloat();
					float v27 = ((Interfaces::m_pGlobalVars->interval_per_tick * accel) * wishspeedClamped);
					if (v60 && clampedSpeed > (FinalSpeed - v27)) {
						float v28 = 1.0f - (fmaxf(clampedSpeed - (FinalSpeed - v27), 0.0f) / fmaxf(FinalSpeed - (FinalSpeed - v27), 0.0f));
						if (v28 >= 0.0f) {
							accel = fminf(v28, 1.0f) * accel;
						}
						else {
							accel = 0.0f * accel;
						}
					}

					float v30 = 0.0f;
					if (in_speed && clampedSpeed > (FinalSpeed - 5.0f)) {
						float v29 = fmaxf(clampedSpeed - (FinalSpeed - 5.0f), 0.0f) / fmaxf(FinalSpeed - (FinalSpeed - 5.0f), 0.0f);
						if ((1.0f - v29) >= 0.0f)
							v30 = fminf(1.0f - v29, 1.0f) * accel;
						else
							v30 = 0.0f * accel;
					}
					else {
						v30 = accel;
					}

					float v31 = fminf(((Interfaces::m_pGlobalVars->interval_per_tick * v30) * wishspeedClamped), addspeed);
					addspeed = v31;

					this->m_vecVelocity += wishdir * v31;
				}
			}
			this->m_vecVelocity.z = 0.0f;

			auto speed = m_vecVelocity.Length();
			if (speed > this->flMaxSpeed) {
				m_vecVelocity = m_vecVelocity.Normalized() * this->flMaxSpeed;
			}

			// m_vecVelocity += m_vecBaseVelocity;

			// first try just moving to the destination	
			Vector dest;
			dest[0] = this->m_vecOrigin[0] + this->m_vecVelocity[0] * Interfaces::m_pGlobalVars->interval_per_tick;
			dest[1] = this->m_vecOrigin[1] + this->m_vecVelocity[1] * Interfaces::m_pGlobalVars->interval_per_tick;
			dest[2] = this->m_vecOrigin[2];

			// first try moving directly to the next spot
			TracePlayerBBox(this->m_vecOrigin, dest, MASK_PLAYERSOLID, this->trace);

			if (this->trace.fraction == 1.0f) {
				// StayOnGround
				this->m_vecOrigin = this->trace.endpos;

				CGameTrace tr;
				Vector start(this->m_vecOrigin);
				Vector end(this->m_vecOrigin);
				start.z += 2.0f;
				end.z -= this->stepsize;

				// See how far up we can go without getting stuck
				TracePlayerBBox(this->m_vecOrigin, start, MASK_PLAYERSOLID, tr);
				start = tr.endpos;

				// using trace.startsolid is unreliable here, it doesn't get set when
				// tracing bounding box vs. terrain

				// Now trace down from a known safe position
				TracePlayerBBox(start, end, MASK_PLAYERSOLID, tr);
				if (tr.fraction > 0.0f && tr.fraction < 1.0f && !tr.startsolid && tr.plane.normal.z >= sv_walkable_normal->GetFloat()) {
					float flDelta = std::fabsf(this->m_vecOrigin.z - tr.endpos.z);
					if (flDelta > 0.015625f) {
						this->m_vecOrigin = tr.endpos;
					}
				}
			}
			else if (bOnGround) {
				// Try sliding forward both on ground and up 16 pixels
				//  take the move that goes farthest
				auto vecPos = this->m_vecOrigin;
				auto vecVel = this->m_vecVelocity;

				// Slide move down.
				TryPlayerMove();

				auto vecDownPos = this->m_vecOrigin;
				auto vecDownVel = this->m_vecVelocity;

				// Reset original values.
				this->m_vecOrigin = vecPos;
				this->m_vecVelocity = vecVel;

				// Move up a stair height.
				Vector vecEndPos;
				vecEndPos = this->m_vecOrigin;
				vecEndPos.z += this->stepsize + 0.03125f;

				CGameTrace trace;
				TracePlayerBBox(this->m_vecOrigin, vecEndPos, MASK_PLAYERSOLID, trace);
				if (!trace.startsolid && !trace.allsolid) {
					this->m_vecOrigin = trace.endpos;
				}

				// Slide move up.
				TryPlayerMove();

				vecEndPos = this->m_vecOrigin;
				vecEndPos.z -= this->stepsize + 0.03125f;

				TracePlayerBBox(this->m_vecOrigin, vecEndPos, MASK_PLAYERSOLID, trace);
				if (!trace.startsolid && !trace.allsolid) {
					this->m_vecOrigin = trace.endpos;
				}

				// If we are not on the ground any more then use the original movement attempt.
				if (trace.plane.normal[2] < sv_walkable_normal->GetFloat()) {
					this->m_vecOrigin = vecDownPos;
					this->m_vecVelocity = vecDownVel;
				}
				else {
					// If the trace ended up in empty space, copy the end over to the origin.
					if (!trace.startsolid && !trace.allsolid) {
						this->m_vecOrigin = trace.endpos;
					}

					Vector vecUpPos;
					vecUpPos = this->m_vecOrigin;

					// decide which one went farther
					float flDownDist = (vecDownPos.x - vecPos.x) * (vecDownPos.x - vecPos.x) + (vecDownPos.y - vecPos.y) * (vecDownPos.y - vecPos.y);
					float flUpDist = (vecUpPos.x - vecPos.x) * (vecUpPos.x - vecPos.x) + (vecUpPos.y - vecPos.y) * (vecUpPos.y - vecPos.y);
					if (flDownDist > flUpDist) {
						this->m_vecOrigin = vecDownPos;
						this->m_vecVelocity = vecDownVel;
					}
					else {
						// copy z value from slide move
						this->m_vecVelocity.z = vecDownVel.z;
					}
				}

				CGameTrace tr;
				Vector start(this->m_vecOrigin);
				Vector end(this->m_vecOrigin);
				start.z += 2.0f;
				end.z -= this->stepsize;

				// See how far up we can go without getting stuck
				TracePlayerBBox(this->m_vecOrigin, start, MASK_PLAYERSOLID, tr);
				start = tr.endpos;

				// using trace.startsolid is unreliable here, it doesn't get set when
				// tracing bounding box vs. terrain

				// Now trace down from a known safe position
				TracePlayerBBox(start, end, MASK_PLAYERSOLID, tr);
				if (tr.fraction > 0.0f && tr.fraction < 1.0f && !tr.startsolid && tr.plane.normal.z >= sv_walkable_normal->GetFloat()) {
					float flDelta = std::fabsf(this->m_vecOrigin.z - tr.endpos.z);
					if (flDelta > 0.015625f) {
						this->m_vecOrigin = tr.endpos;
					}
				}
			}
		}
	}
	else {
		// AirMove
		Vector right;
		auto forward = ucmd->viewangles.ToVectors(&right);

		right.z = 0.0f;
		forward.z = 0.0f;
		forward.Normalize();
		right.Normalize();

		auto wishdir = forward * move.x + right * move.y;
		auto wishspeed = wishdir.Normalize();

		static auto sv_air_max_wishspeed = Interfaces::m_pCvar->FindVar(XorStr("sv_air_max_wishspeed"));
		if (wishspeed > sv_air_max_wishspeed->GetFloat())
			wishspeed = sv_air_max_wishspeed->GetFloat();

		auto currentspeed = this->m_vecVelocity.Dot(wishdir);
		auto addspeed = wishspeed - currentspeed;
		if (addspeed > 0.0) {
			auto v169 = (g_Vars.sv_airaccelerate)->GetFloat() * wishspeed;
			auto v170 = std::fminf(addspeed, v169 * Interfaces::m_pGlobalVars->interval_per_tick);
			this->m_vecVelocity += wishdir * v170;
		}

		TryPlayerMove();
	}

	CGameTrace trace;
	TracePlayerBBox(this->m_vecOrigin, this->m_vecOrigin - Vector(0.0f, 0.0f, 2.0f), MASK_PLAYERSOLID, trace);
	if (trace.DidHit() && trace.plane.normal.z >= sv_walkable_normal->GetFloat())
		this->flags |= 1u;
	else
		this->flags &= 0xFEu;

	if (this->flags & 1)
		this->m_vecVelocity.z = 0.0f;
	else
		this->m_vecVelocity.z -= this->gravity;

	++this->simulationTicks;
}

```

`CSGO SDK/Features/Game/SimulationContext.hpp`:

```hpp
#pragma once

#include "../../SDK/sdk.hpp"

struct SimulationContext {
	bool  walking;
	int buttons;
	int meme1;
	float Origin;
	Vector m_vecOrigin;
	Vector pMins, pMaxs;
	float someFloat;
	Vector m_vecVelocity;
	int simulationTicks;
	int flags;
	CGameTrace trace;
	float gravity;
	float sv_jump_impulse;
	float stepsize;
	float flMaxSpeed;
	ITraceFilter* filter;
	C_CSPlayer* player;

	void TracePlayerBBox(const Vector& start, const Vector& end, unsigned int fMask, CGameTrace& pm);
	void InitSimulationContext(C_CSPlayer* player);
	void ExtrapolatePlayer(float yaw);
	void TryPlayerMove();
	void RebuildGameMovement(CUserCmd* ucmd);
};
```

`CSGO SDK/Features/Miscellaneous/AutoBuy.cpp`:

```cpp
#include "AutoBuy.hpp"
#include "../../source.hpp"
#include "../../SDK/Classes/player.hpp"
#include "../../SDK/Classes/weapon.hpp"

class CAutoBuy : public IAutoBuy {
public:
	void Main() override;
private:
	void Buy(const char* name);
};

Encrypted_t<IAutoBuy> IAutoBuy::Get() {
	static CAutoBuy instance;
	return &instance;
}

void CAutoBuy::Main() {
	if (!g_Vars.misc.autobuy_enabled)
		return;

	C_CSPlayer* LocalPlayer = C_CSPlayer::GetLocalPlayer();

	if (!LocalPlayer)
		return;

	int iTeam = LocalPlayer->m_iTeamNum();

	if (g_Vars.misc.autobuy_first_weapon > 0) {
		switch (g_Vars.misc.autobuy_first_weapon) {
		case 1: // scar20 / g3sg1
		{
			if (iTeam == TEAM_TT) {
				Buy(XorStr("buy g3sg1"));
			}
			else if (iTeam == TEAM_CT) {
				Buy(XorStr("buy scar20"));
			}

			break;
		}
		case 2: // ssg08 
			Buy(XorStr("buy ssg08")); break;
		case 3: // awp
			Buy(XorStr("buy awp")); break;
		default:
			break;
		}
	}

	if (g_Vars.misc.autobuy_second_weapon > 0) {
		switch (g_Vars.misc.autobuy_second_weapon) {
		case 1: // elite
			Buy(XorStr("buy elite")); break;
		case 2: // deagle / revolver
			Buy(XorStr("buy deagle")); break;
		default:
			break;
		}
	}

	if (g_Vars.misc.autobuy_armor) {
		Buy(XorStr("buy vest"));
		Buy(XorStr("buy vesthelm"));
	}

	if (g_Vars.misc.autobuy_hegrenade)
		Buy(XorStr("buy hegrenade"));
	if (g_Vars.misc.autobuy_molotovgrenade) {
		if (iTeam == TEAM_TT)
			Buy(XorStr("buy molotov"));
		else if (iTeam == TEAM_CT)
			Buy(XorStr("buy incgrenade"));
	}
	if (g_Vars.misc.autobuy_smokegreanade)
		Buy(XorStr("buy smokegrenade"));

	if (g_Vars.misc.autobuy_flashbang)
		Buy(XorStr("buy flashbang"));

	if (g_Vars.misc.autobuy_zeus)
		Buy(XorStr("buy taser"));

	if (g_Vars.misc.autobuy_defusekit)
		Buy(XorStr("buy defuser"));

	if (g_Vars.misc.autobuy_decoy)
		Buy(XorStr("buy decoy"));
}

void CAutoBuy::Buy(const char* name) {
	Interfaces::m_pEngine->ClientCmd(name);
}

```

`CSGO SDK/Features/Miscellaneous/AutoBuy.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

class __declspec(novtable) IAutoBuy : public NonCopyable {
public:
	static Encrypted_t<IAutoBuy> Get();
	virtual void Main() = NULL;
protected:
	IAutoBuy() {

	}
	virtual ~IAutoBuy() {

	}
};

```

`CSGO SDK/Features/Miscellaneous/BulletBeamTracer.cpp`:

```cpp
#include "BulletBeamTracer.hpp"
#include "../../source.hpp"
#include "../../SDK/CVariables.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../Rage/ShotInformation.hpp"

class CBulletBeamTracer : public IBulletBeamTracer {
public:
	void Main() override;
	void PushBeamInfo(BulletImpactInfo beam_info) override;
private:
	void DrawBeam();
	std::vector<BulletImpactInfo> bulletImpactInfo;
};

Encrypted_t<IBulletBeamTracer> IBulletBeamTracer::Get() {
	static CBulletBeamTracer instance;
	return &instance;
}

void CBulletBeamTracer::Main() {
	DrawBeam();
}

void CBulletBeamTracer::PushBeamInfo(BulletImpactInfo beam_info) {
	bulletImpactInfo.emplace_back(beam_info);
}

const unsigned short INVALID_STRING_INDEX = (unsigned short)-1;
bool PrecacheModel(const char* szModelName)
{
	INetworkStringTable* m_pModelPrecacheTable = Interfaces::g_pClientStringTableContainer->FindTable("modelprecache");

	if (m_pModelPrecacheTable)
	{
		Interfaces::m_pModelInfo->FindOrLoadModel(szModelName);
		int idx = m_pModelPrecacheTable->AddString(false, szModelName);
		if (idx == INVALID_STRING_INDEX)
			return false;
	}
	return true;
}

void CBulletBeamTracer::DrawBeam() {
	C_CSPlayer* LocalPlayer = C_CSPlayer::GetLocalPlayer();
	if (!LocalPlayer || LocalPlayer->IsDead())
		return;

	float time = Interfaces::m_pGlobalVars->curtime;
	bool       is_final_impact;

	for (size_t i{ }; i < bulletImpactInfo.size() && !bulletImpactInfo.empty(); ++i) {
		auto& tr = bulletImpactInfo[i];

		if (tr.m_nIndex == LocalPlayer->EntIndex()) {
			// is this the final impact?
			// last impact in the vector, it's the final impact.
			if (i == (bulletImpactInfo.size() - 1))
				is_final_impact = true;

			// the current impact's tickbase is different than the next, it's the final impact.
			else if ((i + 1) < bulletImpactInfo.size() && tr.m_nTickbase != bulletImpactInfo.operator[ ](i + 1).m_nTickbase)
				is_final_impact = true;

			else
				is_final_impact = false;

			if (!is_final_impact) {
				bulletImpactInfo.erase(bulletImpactInfo.begin() + i);
			}
		}

		float delta = time - tr.m_flExpTime;
		if (delta > 1.0f)
			bulletImpactInfo.erase(bulletImpactInfo.begin() + i);
	}

	if (!bulletImpactInfo.empty()) {
		for (auto& it : bulletImpactInfo) {
			float delta = time - it.m_flExpTime;
			Color col = it.m_nIndex == LocalPlayer->EntIndex() ? Color::HSBtoRGB(delta, 1.0f, 1.0f) : Color(255, 15, 46);
			col.SetAlpha(1.0f - delta * 255);
			Vector2D w2s_start, w2s_end;
			bool a = WorldToScreen(it.m_vecStartPos, w2s_start);
			bool b = WorldToScreen(it.m_vecHitPos, w2s_end);

			switch (g_Vars.esp.beam_type) {
			case 0:
				if (a && b)
					Render::Engine::Line(w2s_start, w2s_end, col);
				break;
			case 1:
				if (!PrecacheModel(XorStr("materials/sprites/laserbeam.vmt"))) {
					break;
				}

				BeamInfo_t beam_info;

				beam_info.m_nType = 0;
				beam_info.m_pszModelName = XorStr("materials/sprites/laserbeam.vmt");
				beam_info.m_nModelIndex = Interfaces::m_pModelInfo->GetModelIndex(XorStr("materials/sprites/laserbeam.vmt"));
				beam_info.m_flHaloScale = 0.0f;
				beam_info.m_flLife = 0.09f; //0.09
				beam_info.m_flWidth = .6f;
				beam_info.m_flEndWidth = .75f;
				beam_info.m_flFadeLength = 3.0f;
				beam_info.m_flAmplitude = 0.f;
				beam_info.m_flBrightness = (col.a() - 255.f) * 0.8f;
				beam_info.m_flSpeed = 1.f;
				beam_info.m_nStartFrame = 1;
				beam_info.m_flFrameRate = 60;
				beam_info.m_flRed = col.r();
				beam_info.m_flGreen = col.g();
				beam_info.m_flBlue = col.b();
				beam_info.m_nSegments = 4;
				beam_info.m_bRenderable = true;
				beam_info.m_nFlags = 0;

				beam_info.m_vecStart = it.m_vecStartPos;
				beam_info.m_vecEnd = it.m_vecHitPos;

				Beam_t* beam = Interfaces::m_pRenderBeams->CreateBeamPoints(beam_info);

				if (beam) {
					Interfaces::m_pRenderBeams->DrawBeam(beam);
				}

				break;
			}
		}
	}
}

```

`CSGO SDK/Features/Miscellaneous/BulletBeamTracer.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

class __declspec(novtable) IBulletBeamTracer : public NonCopyable {
public:
	struct BulletImpactInfo
	{
		float m_flExpTime;
		Vector m_vecStartPos;
		Vector m_vecHitPos;
		Color m_cColor;
		int m_nIndex;
		int m_nTickbase;
		bool ignore[64];
	};

	static Encrypted_t<IBulletBeamTracer> Get();
	virtual void Main() = NULL;
	virtual void PushBeamInfo(BulletImpactInfo beam_info) = NULL;
protected:
	IBulletBeamTracer() { };
	virtual ~IBulletBeamTracer() { };
};

```

`CSGO SDK/Features/Miscellaneous/GameEvent.cpp`:

```cpp
#include "GameEvent.hpp"
#include "../Visuals/EventLogger.hpp"
#include "../../source.hpp"
#include "../../Utils/FnvHash.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../Rage/LagCompensation.hpp"
#include <sstream>
#include "BulletBeamTracer.hpp"
#include "../Visuals/Hitmarker.hpp"
#include "AutoBuy.hpp"
#include "../../SDK/core.hpp"
#include "../Visuals/ESP.hpp"
#include "../Visuals/CChams.hpp"
#include "../Rage/ShotInformation.hpp"
#pragma comment(lib,"Winmm.lib")
#include "../Rage/TickbaseShift.hpp"

#include <fstream>


#define ADD_GAMEEVENT(n)  Interfaces::m_pGameEvent->AddListener(this, XorStr(#n), false)

class C_GameEvent : public GameEvent {
public: // GameEvent interface
	virtual void Register();
	virtual void Shutdown();

	C_GameEvent() { };
	virtual ~C_GameEvent() { };
public: // IGameEventListener
	virtual void FireGameEvent(IGameEvent* event);
	virtual int  GetEventDebugID(void);
};

Encrypted_t<GameEvent> GameEvent::Get() {
	static C_GameEvent instance;
	return &instance;
}

void C_GameEvent::Register() {
	ADD_GAMEEVENT(player_hurt);
	ADD_GAMEEVENT(bullet_impact);
	ADD_GAMEEVENT(weapon_fire);
	ADD_GAMEEVENT(bomb_planted);
	ADD_GAMEEVENT(player_death);
	ADD_GAMEEVENT(round_start);
	ADD_GAMEEVENT(item_purchase);
	ADD_GAMEEVENT(bomb_begindefuse);
	ADD_GAMEEVENT(bomb_abortdefuse);
	ADD_GAMEEVENT(bomb_pickup);
	ADD_GAMEEVENT(bomb_beginplant);
	ADD_GAMEEVENT(bomb_abortplant);
	ADD_GAMEEVENT(item_pickup);
	ADD_GAMEEVENT(round_mvp);
	ADD_GAMEEVENT(grenade_thrown);
	ADD_GAMEEVENT(buytime_ended);
	ADD_GAMEEVENT(round_end);
	ADD_GAMEEVENT(game_newmap);
	ADD_GAMEEVENT(bomb_beep);
	ADD_GAMEEVENT(bomb_defused);
	ADD_GAMEEVENT(bomb_exploded);
}

void C_GameEvent::Shutdown() {
	Interfaces::m_pGameEvent->RemoveListener(this);
}

void C_GameEvent::FireGameEvent(IGameEvent* pEvent) {
	if (!pEvent)
		return;

	C_CSPlayer* LocalPlayer = C_CSPlayer::GetLocalPlayer();
	if (!LocalPlayer || !Interfaces::m_pEngine->IsInGame())
		return;

	auto event_hash = hash_32_fnv1a_const(pEvent->GetName());
	auto event_string = std::string(pEvent->GetName());

	Engine::C_ShotInformation::Get()->EventCallback(pEvent, event_hash);
	g_Vars.globals.m_bLocalPlayerHarmedThisTick = false;

	auto HitgroupToString = [](int hitgroup) -> std::string {
		switch (hitgroup) {
		case Hitgroup_Generic:
			return XorStr("generic");
		case Hitgroup_Head:
			return XorStr("head");
		case Hitgroup_Chest:
			return XorStr("chest");
		case Hitgroup_Stomach:
			return XorStr("stomach");
		case Hitgroup_LeftArm:
			return XorStr("left arm");
		case Hitgroup_RightArm:
			return XorStr("right arm");
		case Hitgroup_LeftLeg:
			return XorStr("left leg");
		case Hitgroup_RightLeg:
			return XorStr("right leg");
		case Hitgroup_Neck:
			return XorStr("neck");
		}
		return XorStr("generic");
	};

	static auto sv_showimpacts_time = Interfaces::m_pCvar->FindVar(XorStr("sv_showimpacts_time"));

	// Force constexpr hash computing 
	switch (event_hash) {
	case hash_32_fnv1a_const("game_newmap"):
	{
		Engine::LagCompensation::Get()->ClearLagData();
		g_Vars.globals.m_bNewMap = true;
		g_Vars.globals.BobmActivityIndex = -1;
	}
	case hash_32_fnv1a_const("bullet_impact"):
	{
		auto ent = (C_CSPlayer*)Interfaces::m_pEntList->GetClientEntity(Interfaces::m_pEngine->GetPlayerForUserID(pEvent->GetInt(XorStr("userid"))));

		bool bCameFromLocal = LocalPlayer && ent && LocalPlayer == ent;
		bool bCameFromEnemy = LocalPlayer && ent && ent->m_iTeamNum() != LocalPlayer->m_iTeamNum();
		if (LocalPlayer && !LocalPlayer->IsDead()) {

			float x = pEvent->GetFloat(XorStr("x")), y = pEvent->GetFloat(XorStr("y")), z = pEvent->GetFloat(XorStr("z"));
			if (g_Vars.esp.beam_enabled) {
				if (bCameFromLocal) {
					IBulletBeamTracer::Get()->PushBeamInfo({ Interfaces::m_pGlobalVars->curtime, LocalPlayer->GetEyePosition(), Vector(x, y, z), Color(), ent->EntIndex(), LocalPlayer->m_nTickBase() });
				}
				else if (bCameFromEnemy) {
					if (!ent->IsDormant())
						IBulletBeamTracer::Get()->PushBeamInfo({ Interfaces::m_pGlobalVars->curtime, ent->GetEyePosition(), Vector(x, y, z), Color(), ent->EntIndex(), -1 });
				}
			}

			if (bCameFromLocal) {
				int color[4] = { g_Vars.esp.server_impacts.r * 255, g_Vars.esp.server_impacts.g * 255, g_Vars.esp.server_impacts.b * 255, g_Vars.esp.server_impacts.a * 255 };

				if (g_Vars.misc.server_impacts_spoof) // draw server impact
					Interfaces::m_pDebugOverlay->AddBoxOverlay(Vector(x, y, z), Vector(-2, -2, -2), Vector(2, 2, 2), QAngle(0, 0, 0), color[0], color[1], color[2], color[3],
						sv_showimpacts_time->GetFloat());
			}
		}

		break;
	}
	case hash_32_fnv1a_const("round_end"):
	{
		g_Vars.globals.BobmActivityIndex = -1;
		//IRoundFireBulletsStore::Get( )->EventCallBack( pEvent, 1, nullptr );
		break;
	}
	case hash_32_fnv1a_const("round_freeze_end"):
	{
		g_Vars.globals.BobmActivityIndex = -1;
		g_Vars.globals.IsRoundFreeze = false;
		break;
	}
	case hash_32_fnv1a_const("round_prestart"):
	{
		g_Vars.globals.BobmActivityIndex = -1;
		g_Vars.globals.IsRoundFreeze = true;
		break;
	}
	case hash_32_fnv1a_const("bomb_beep"):
	{
		break;
	}
	case hash_32_fnv1a_const("bomb_defused"):
	{
		g_Vars.globals.BobmActivityIndex = -1;
		g_Vars.globals.bBombActive = false;
		break;
	}
	case hash_32_fnv1a_const("bomb_exploded"):
	{
		g_Vars.globals.BobmActivityIndex = -1;
		g_Vars.globals.bBombActive = false;
		break;
	}
	case hash_32_fnv1a_const("player_hurt"):
	{
		auto enemy = pEvent->GetInt(XorStr("userid"));
		auto attacker = pEvent->GetInt(XorStr("attacker"));
		auto remaining_health = pEvent->GetString(XorStr("health"));
		auto dmg_to_health = pEvent->GetInt(XorStr("dmg_health"));
		auto hitgroup = pEvent->GetInt(XorStr("hitgroup"));

		auto enemy_index = Interfaces::m_pEngine->GetPlayerForUserID(enemy);
		auto attacker_index = Interfaces::m_pEngine->GetPlayerForUserID(attacker);
		auto pEnemy = C_CSPlayer::GetPlayerByIndex(enemy_index);
		auto pAttacker = C_CSPlayer::GetPlayerByIndex(attacker_index);

		player_info_t attacker_info;
		player_info_t enemy_info;

		if (pEnemy && pAttacker && Interfaces::m_pEngine->GetPlayerInfo(attacker_index, &attacker_info) && Interfaces::m_pEngine->GetPlayerInfo(enemy_index, &enemy_info)) {
			auto local = reinterpret_cast<C_CSPlayer*>(Interfaces::m_pEntList->GetClientEntity(Interfaces::m_pEngine->GetLocalPlayer()));
			auto entity = reinterpret_cast<C_CSPlayer*>(Interfaces::m_pEntList->GetClientEntity(Interfaces::m_pEngine->GetPlayerForUserID(pEvent->GetInt(XorStr("userid")))));

			if (!entity || !local)
				return;

			if (attacker_index != Interfaces::m_pEngine->GetLocalPlayer()) {
				if (enemy_index == local->EntIndex()) {
					if (g_Vars.esp.event_harm) {
						std::stringstream msg;

						msg << XorStr("Harmed by ") << attacker_info.szName << XorStr(" for ") << dmg_to_health << XorStr(" in ") << HitgroupToString(hitgroup).data();

						ILoggerEvent::Get()->PushEvent(msg.str(), FloatColor(255, 128, 128), true, XorStr(""));
					}

					g_Vars.globals.m_bLocalPlayerHarmedThisTick = true;
				}
			}
			else {
				if (g_Vars.esp.event_dmg) {
					std::stringstream msg;

					msg << XorStr("Hit ") << enemy_info.szName << XorStr(" in the ") << HitgroupToString(hitgroup).data() << XorStr(" for ") << dmg_to_health << " damage (" << remaining_health << " health remaining)";

					ILoggerEvent::Get()->PushEvent(msg.str(), FloatColor(75, 255, 75), true, XorStr(""));
				}

				if (g_Vars.misc.hitsound) {
					if (g_Vars.misc.hitsound_type && !g_Vars.globals.m_hitsounds.empty()) {
						// DIRECTORY XD!!!
						int idx = g_Vars.misc.hitsound_custom;
						if (idx >= g_Vars.globals.m_hitsounds.size())
							idx = g_Vars.globals.m_hitsounds.size() - 1;
						else if (idx < 0)
							idx = 0;

						std::string curfile = g_Vars.globals.m_hitsounds[idx];
						if (!curfile.empty()) {
							std::string dir = GetDocumentsDirectory().append(XorStr("\\ams\\")).append(curfile);

							auto ReadWavFileIntoMemory = [&](std::string fname, BYTE** pb, DWORD* fsize) {
								std::ifstream f(fname, std::ios::binary);

								f.seekg(0, std::ios::end);
								int lim = f.tellg();
								*fsize = lim;

								*pb = new BYTE[lim];
								f.seekg(0, std::ios::beg);

								f.read((char*)*pb, lim);

								f.close();
							};

							DWORD dwFileSize;
							BYTE* pFileBytes;
							ReadWavFileIntoMemory(dir.data(), &pFileBytes, &dwFileSize);

							// danke anarh1st47, ich liebe dich
							// dieses code snippet hat mir so sehr geholfen https://i.imgur.com/ybWTY2o.png
							// thanks anarh1st47, you are the greatest
							// loveeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
							// kochamy anarh1st47
							auto modify_volume = [&](BYTE* bytes) {
								int offset = 0;
								for (int i = 0; i < dwFileSize / 2; i++) {
									if (bytes[i] == 'd' && bytes[i + 1] == 'a'
										&& bytes[i + 2] == 't' && bytes[i + 3] == 'a')
									{
										offset = i;
										break;
									}
								}

								if (!offset)
									return;

								BYTE* pDataOffset = (bytes + offset);
								DWORD dwNumSampleBytes = *(DWORD*)(pDataOffset + 4);
								DWORD dwNumSamples = dwNumSampleBytes / 2;

								SHORT* pSample = (SHORT*)(pDataOffset + 8);
								for (DWORD dwIndex = 0; dwIndex < dwNumSamples; dwIndex++)
								{
									SHORT shSample = *pSample;
									shSample = (SHORT)(shSample * (g_Vars.misc.hitsound_volume / 100.f));
									*pSample = shSample;
									pSample++;
									if (((BYTE*)pSample) >= (bytes + dwFileSize - 1))
										break;
								}
							};

							if (pFileBytes) {
								modify_volume(pFileBytes);
								PlaySoundA((LPCSTR)pFileBytes, NULL, SND_MEMORY | SND_ASYNC);
							}
						}
					}
					else {
						Interfaces::m_pSurface->PlaySound_(XorStr("buttons\\arena_switch_press_02.wav"));
					}
				}

				Hitmarkers::m_nLastDamageData = { hitgroup == Hitgroup_Head ? Color(255, 0, 00) : Color(255, 255, 255), dmg_to_health };
				Hitmarkers::AddScreenHitmarker(hitgroup == Hitgroup_Head ? Color(0, 150, 255) : Color(255, 255, 255));
			}
		}
		break;
	}
	case hash_32_fnv1a_const("item_purchase"):
	{
		if (!g_Vars.esp.event_buy)
			return;

		auto userid = pEvent->GetInt(XorStr("userid"));

		if (!userid)
			return;

		int index = Interfaces::m_pEngine->GetPlayerForUserID(userid);

		player_info_t info;

		auto player = C_CSPlayer::GetPlayerByIndex(index);
		auto local = C_CSPlayer::GetLocalPlayer();

		if (!player || !local || player->IsTeammate(local))
			return;

		if (!Interfaces::m_pEngine->GetPlayerInfo(index, &info))
			return;


		if (pEvent->GetString(XorStr("weapon")) == "weapon_unknown")
			return;

		std::stringstream msg;
		msg << info.szName;
		msg << XorStr(" bought ") << pEvent->GetString(XorStr("weapon")) << XorStr(" (");
		msg << std::string(XorStr("$")).append(std::to_string(player->m_iAccount())).data() << XorStr(" remaining)");


		ILoggerEvent::Get()->PushEvent(msg.str(), FloatColor(255, 255, 255), true);

		break;
	}
	case hash_32_fnv1a_const("bomb_begindefuse"):
	{
		if (!g_Vars.esp.event_bomb)
			return;

		auto userid = pEvent->GetInt(XorStr("userid"));

		if (!userid)
			return;

		int index = Interfaces::m_pEngine->GetPlayerForUserID(userid);

		if (index == Interfaces::m_pEngine->GetLocalPlayer())
			return;

		player_info_t info;

		if (!Interfaces::m_pEngine->GetPlayerInfo(index, &info))
			return;

		bool has_defuse = pEvent->GetBool(XorStr("haskit"));

		std::stringstream msg;
		msg << info.szName;

		if (has_defuse)
			msg << XorStr(" has started defusing the bomb with a kit");
		else
			msg << XorStr(" has started defusing the bomb without a kit");



		ILoggerEvent::Get()->PushEvent(msg.str(), FloatColor(255, 255, 255), true);

		g_Vars.globals.BobmActivityIndex = index;
		break;
	}
	case hash_32_fnv1a_const("bomb_abortdefuse"):
	{
		if (!g_Vars.esp.event_bomb)
			return;

		auto userid = pEvent->GetInt(XorStr("userid"));

		if (!userid)
			return;

		int index = Interfaces::m_pEngine->GetPlayerForUserID(userid);

		if (index == Interfaces::m_pEngine->GetLocalPlayer())
			return;

		player_info_t info;

		if (!Interfaces::m_pEngine->GetPlayerInfo(index, &info))
			return;

		std::stringstream msg;
		msg << info.szName;
		msg << " has stopped defusing the bomb";


		ILoggerEvent::Get()->PushEvent(msg.str(), FloatColor(255, 255, 255));

		g_Vars.globals.BobmActivityIndex = -1;
		break;
	}
	case hash_32_fnv1a_const("bomb_pickup"):
	{
		if (!g_Vars.esp.event_bomb)
			return;

		auto userid = pEvent->GetInt(XorStr("userid"));

		if (!userid)
			return;

		int index = Interfaces::m_pEngine->GetPlayerForUserID(userid);

		if (index == Interfaces::m_pEngine->GetLocalPlayer())
			return;

		player_info_t info;

		if (!Interfaces::m_pEngine->GetPlayerInfo(index, &info))
			return;

		std::stringstream msg;
		msg << info.szName;
		msg << " has picked the bomb";


		ILoggerEvent::Get()->PushEvent(msg.str(), FloatColor(255, 255, 255), true);

		break;
	}
	case hash_32_fnv1a_const("bomb_beginplant"):
	{
		if (!g_Vars.esp.event_bomb)
			return;

		auto userid = pEvent->GetInt(XorStr("userid"));

		if (!userid)
			return;

		int index = Interfaces::m_pEngine->GetPlayerForUserID(userid);

		if (index == Interfaces::m_pEngine->GetLocalPlayer())
			return;

		player_info_t info;

		if (!Interfaces::m_pEngine->GetPlayerInfo(index, &info))
			return;

		std::stringstream msg;

		msg << info.szName;
		msg << " has started planting the bomb";

		ILoggerEvent::Get()->PushEvent(msg.str(), FloatColor(255, 255, 255), true);

		g_Vars.globals.BobmActivityIndex = index;
		break;
	}
	case hash_32_fnv1a_const("bomb_abortplant"):
	{
		if (!g_Vars.esp.event_bomb)
			return;

		auto userid = pEvent->GetInt(XorStr("userid"));

		if (!userid)
			return;

		int index = Interfaces::m_pEngine->GetPlayerForUserID(userid);

		if (index == Interfaces::m_pEngine->GetLocalPlayer())
			return;

		player_info_t info;

		if (!Interfaces::m_pEngine->GetPlayerInfo(index, &info))
			return;

		std::stringstream msg;
		msg << info.szName;
		msg << " has stopped planting the bomb";

		ILoggerEvent::Get()->PushEvent(msg.str(), FloatColor(255, 255, 255), true);

		g_Vars.globals.BobmActivityIndex = -1;
		break;
	}
	case hash_32_fnv1a_const("bomb_planted"):
	{
		g_Vars.globals.bBombActive = true;
		break;
	}
	case hash_32_fnv1a_const("round_start"):
	{
		g_Vars.globals.Fakewalking = g_Vars.misc.fakeduck_bind.enabled = false;

		for (int i = 0; i < Interfaces::g_pDeathNotices->m_vecDeathNotices.Count(); i++) {
			auto cur = &Interfaces::g_pDeathNotices->m_vecDeathNotices[i];
			if (!cur) {
				continue;
			}

			cur->m_flStartTime = 0.f;
		}

		IAutoBuy::Get()->Main();

		for (size_t i = 1; i <= 64; i++) {
			IEsp::Get()->SetAlpha(i);

			auto player = (C_CSPlayer*)Interfaces::m_pEntList->GetClientEntity(i);
			if (!player || player == C_CSPlayer::GetLocalPlayer() || player->IsTeammate(C_CSPlayer::GetLocalPlayer()))
				continue;



			// hacky fix for dormant esp at start of round, i guess.
			// haven't tested this.
			player->m_iHealth() = 100;
		}

		g_Vars.globals.bBombActive = false;
		g_Vars.globals.BobmActivityIndex = -1;
		break;
	}
	case hash_32_fnv1a_const("player_death"):
	{
		int iUserID = Interfaces::m_pEngine->GetPlayerForUserID(pEvent->GetInt(XorStr("userid")));
		int iAttacker = Interfaces::m_pEngine->GetPlayerForUserID(pEvent->GetInt(XorStr("attacker")));
		auto iEnemyIndex = Interfaces::m_pEngine->GetPlayerForUserID(iUserID);

		C_CSPlayer* pAttacker = (C_CSPlayer*)Interfaces::m_pEntList->GetClientEntity(iAttacker);
		if (pAttacker) {
			if (iAttacker == Interfaces::m_pEngine->GetLocalPlayer() && iUserID != Interfaces::m_pEngine->GetLocalPlayer()) {
				Hitmarkers::AddScreenHitmarker(Color(255, 0, 0));
			}
		}

		IEsp::Get()->SetAlpha(iEnemyIndex);
		break;
	}
	}
}

int C_GameEvent::GetEventDebugID(void) {
	return 42;
}

```

`CSGO SDK/Features/Miscellaneous/GameEvent.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

class __declspec(novtable) GameEvent : public IGameEventListener, public NonCopyable
{
public:
	static Encrypted_t<GameEvent>  Get();

	virtual void Register() = 0;
	virtual void Shutdown() = 0;

protected:
	GameEvent() { };
	virtual ~GameEvent() { };
};

```

`CSGO SDK/Features/Miscellaneous/KitParser.cpp`:

```cpp
#include "KitParser.hpp"
#include "../../SDK/sdk.hpp"
#include <algorithm>
#include "../../source.hpp"
#include "../../SDK/Valve/UtlMap.hpp"
#include "../../SDK/CVariables.hpp"

std::vector< paint_kit > all_skins;
std::vector< item_skins > weapon_skins;
std::vector< paint_kit > skin_kits; // knife skins
std::vector< paint_kit > glove_kits;

struct StickerData_t {
	char viewmodel_geometry[128];
	char viewmodel_material[128];
	Vector worldmodel_decal_pos;
	Vector worldmodel_decal_end;
	char worldmodel_decal_bone[32];
};

struct WeaponPaintableMaterial_t {
	char Name[128];
	char OrigMat[128];
	char FolderName[128];
	int ViewmodelDim;
	int WorldDim;
	float WeaponLength;
	float UVScale;
	bool BaseTextureOverride;
	bool MirrorPattern;
};

// We need these for overriding viewmodels and icons
std::map< size_t, Item_t > k_weapon_info = {
	{ WEAPON_KNIFE_CT, { ("models/weapons/v_knife_default_ct.mdl"), ("knife_default_ct") } },
	{ WEAPON_KNIFE_BAYONET, { ("models/weapons/v_knife_bayonet.mdl"), ("bayonet") } },
	{ WEAPON_KNIFE_BOWIE, { ("models/weapons/v_knife_survival_bowie.mdl"), ("knife_survival_bowie") } },
	{ WEAPON_KNIFE_BUTTERFLY, { ("models/weapons/v_knife_butterfly.mdl"), ("knife_butterfly") } },
	{ WEAPON_KNIFE_FALCHION, { ("models/weapons/v_knife_falchion_advanced.mdl"), ("knife_falchion") } },
	{ WEAPON_KNIFE_FLIP, { ("models/weapons/v_knife_flip.mdl"), ("knife_flip") } },
	{ WEAPON_KNIFE_GUT, { ("models/weapons/v_knife_gut.mdl"), ("knife_gut") } },
	{ WEAPON_KNIFE_HUNTSMAN, {  ("models/weapons/v_knife_tactical.mdl"), ("knife_tactical") } },
	{ WEAPON_KNIFE_KARAMBIT, {  ("models/weapons/v_knife_karam.mdl"), ("knife_karambit") } },
	{ WEAPON_KNIFE_M9_BAYONET, {  ("models/weapons/v_knife_m9_bay.mdl"), ("knife_m9_bayonet") } },
	{ WEAPON_KNIFE_SHADOW_DAGGERS, { ("models/weapons/w_knife_push.mdl"), ("knife_push") } }
};

std::vector< WeaponName_t > k_knife_names = {
		{ 0, ("Default") },
		{ 1, ("Bayonet") },
		{ 2, ("Bowie") },
		{ 3, ("Butterfly") },
		{ 4, ("Falchion") },
		{ 5, ("Flip") },
		{ 6, ("Gut") },
		{ 7, ("Huntsman") },
		{ 8, ("Karambit") },
		{ 8, ("M9 Bayonet") },
		{ 9, ("Shadow daggers") },
};


std::vector< WeaponName_t > k_glove_names = {
	{ 0, ("Default") },


};
class CCStrike15ItemSchema;
class CCStrike15ItemSystem;
class AssetInfo;
class IEconTool;
union attribute_data_union_t { bool bValue;  int iValue;  float fValue;  Vector* vValue;  void* szValue; };
struct static_attrib_t // Get a CEconItemAttributeDefinition* with m_Attributes[static_attrib_t.id] 
{
	uint16_t id;  attribute_data_union_t value;  bool force_gc_to_generate;
};

class CCStrike15ItemDefinition
{
public:
	virtual uint16_t GetDefinitionIndex() const = 0;
	virtual const char* GetPrefabName() const = 0;
	virtual const char* GetItemBaseName() const = 0;
	virtual const char* GetItemTypeName() const = 0;
	virtual const char* GetItemDesc() const = 0;
	virtual const char* GetInventoryImage() const = 0;
	virtual const char* GetBasePlayerDisplayModel() const = 0;
	virtual const char* GetWorldDisplayModel() const = 0;
	virtual const char* GetExtraWearableModel() const = 0;
	virtual int GetLoadoutSlot() const = 0;
	virtual KeyValues* GetRawDefinition() const = 0;
	virtual int GetHeroID() const = 0;
	virtual int GetRarity() const = 0;
	virtual CUtlVector<int>* GetItemSets() const = 0;
	virtual int GetBundleItemCount() const = 0;
	virtual void* GetBundleItem(int) const = 0;
	virtual bool IsBaseItem() const = 0;
	virtual bool IsPublicItem() const = 0;
	virtual bool IsBundle() const = 0;
	virtual bool IsPackBundle() const = 0;
	virtual bool IsPackItem() const = 0;
	virtual void* BInitVisualBlockFromKV(KeyValues*, void*, void*) = 0;
	virtual void* BInitFromKV(KeyValues*, void*, void*) = 0;
	virtual void* BInitFromTestItemKVs(int, KeyValues*, void*) = 0;
	virtual void* GeneratePrecacheModelStrings(bool, void*) const = 0;
	virtual void* GeneratePrecacheSoundStrings(void*) const = 0;
	virtual void* GeneratePrecacheEffectStrings(void*) const = 0;
	virtual void* CopyPolymorphic(const CCStrike15ItemDefinition*) = 0;
	virtual int GetItemTypeID() const = 0;
	virtual bool IsDefaultSlotItem() const = 0;
	virtual bool IsPreviewableInStore() const = 0;
	virtual int GetBundleItemPaintKitID(int) const = 0;
	virtual const char* GetWorldDroppedModel() const = 0;
	virtual const char* GetHolsteredModel() const = 0;
	virtual const char* GetZoomInSound() const = 0;
	virtual const char* GetZoomOutSound() const = 0;
	virtual const char* GetIconDisplayModel() const = 0;
	virtual const char* GetBuyMenuDisplayModel() const = 0;
	virtual const char* GetPedestalDisplayModel() const = 0;
	virtual const char* GetMagazineModel() const = 0;
	virtual const char* GetScopeLensMaskModel() const = 0;
	virtual const char* GetUidModel() const = 0;
	virtual const char* GetStatTrakModelByType(unsigned int) const = 0;
	virtual int GetNumSupportedStickerSlots() const = 0;
	virtual const char* GetStickerSlotModelBySlotIndex(unsigned int) const = 0;
	virtual void* GetStickerSlotWorldProjectionStartBySlotIndex(unsigned int) const = 0;
	virtual void* GetStickerSlotWorldProjectionEndBySlotIndex(unsigned int) const = 0;
	virtual void* GetStickerWorldModelBoneParentNameBySlotIndex(unsigned int) const = 0;
	virtual void* GetStickerSlotMaterialBySlotIndex(unsigned int) const = 0;
	virtual const char* GetIconDefaultImage() const = 0;
	virtual void* GetParticleFile() const = 0;
	virtual void* GetParticleSnapshotFile() const = 0;
	virtual bool IsRecent() const = 0;
	virtual bool IsContentStreamable() const = 0;
	virtual void* IgnoreInCollectionView() const = 0;
	virtual void* GeneratePrecacheModelStrings(bool, void*) = 0;

public:
	KeyValues* kv;
	uint16_t id;
	CUtlVector<uint16_t> associated_items;

private:
	int32_t pad0[2];

public:
	uint8_t min_ilevel;
	uint8_t max_ilevel;
	uint8_t item_rarity;
	uint8_t item_quality;
	uint8_t forced_item_quality;
	uint8_t default_drop_quality;
	uint8_t default_drop_quantity;
	CUtlVector<static_attrib_t> attributes;
	uint8_t popularity_seed;
	KeyValues* portraits;
	char* item_name;
	bool propername;
	char* item_type_name;
	int type_id; // crc32( item_type_name )
	char* item_description;
	int expiration_date;
	int creation_date;
	char* model_inventory;
	char* image_inventory;
	CUtlVector<const char*> image_inventory_overlay;
	int image_inventory_pos_x;
	int image_inventory_pos_y;
	int image_inventory_size_w;
	int image_inventory_size_h;
	char* model_player;

private:
	bool pad1;

public:
	bool hide_bodygroups_deployed_only;
	char* model_world;
	char* model_dropped;
	char* model_holstered;
	char* extra_wearable;

private:
	int32_t pad2[20];

public:
	CUtlVector<StickerData_t> stickers;
	char* icon_default_image;
	bool attach_to_hands;
	bool attach_to_hands_vm_only;
	bool flip_viewmodel;
	bool act_as_wearable;
	CUtlVector<int> item_sets;
	AssetInfo* visuals;

public:
	bool allow_purchase_standalone;
	char* brass_eject_model;
	char* zoom_in_sound;
	char* zoom_out_sound;

	IEconTool* tool;

private:
	int32_t pad4[3];

public:
	int sound_material;
	bool disable_style_selector;

private:
	int32_t pad5[8];

public:
	char* particle_file;
	char* particle_snapshot;
	char* loot_list_name;

private:
	int32_t pad6[5];

public:
	CUtlVector<WeaponPaintableMaterial_t> paint_data;

	struct {
		QAngle* camera_angles;
		Vector* camera_offset;
		float camera_fov;
		void* lights[4];

	private:
		int32_t pad0;
	} *inventory_image_data;

	char* item_class;
	char* item_logname;
	char* item_iconname;
	char* name;
	bool hidden;
	bool show_in_armory;
	bool baseitem;
	bool default_slot_item;
	bool import;
	bool one_per_account_cdkey;

private:
	int32_t pad7;

public:
	char* armory_desc;
	CCStrike15ItemDefinition* armory_remapdef;
	CCStrike15ItemDefinition* store_remapdef;
	char* armory_remap;
	char* store_remap;
	char* class_token_id;
	char* slot_token_id;
	int drop_type;
	int holiday_restriction;
	int subtype;

private:
	int32_t pad8[4];

public:
	CUtlMap<unsigned int, const char*, unsigned short> alternate_icons;

private:
	int32_t pad9[9];

public:
	bool not_developer;
	bool ignore_in_collection_view;

	// This is where CCStrike15ItemDefinition begins
	int item_sub_position;
	int item_gear_slot;
	int item_gear_slot_position;
	int anim_slot;
	char* model_player_per_class[4];
	int class_usage[4];

private:
	int32_t pad10[2];
};

template < typename Key, typename Value >
struct Node_t {
	int previous_id;    //0x0000
	int next_id;        //0x0004
	void* _unknown_ptr; //0x0008
	int _unknown;       //0x000C
	Key key;            //0x0010
	Value value;        //0x0014
};

template < typename Key, typename Value >
struct Head_t {
	Node_t< Key, Value >* memory; //0x0000
	int allocation_count;         //0x0004
	int grow_size;                //0x0008
	int start_element;            //0x000C
	int next_available;           //0x0010
	int _unknown;                 //0x0014
	int last_element;             //0x0018
};                              //Size=0x001C

// could use CUtlString but this is just easier and CUtlString isn't needed anywhere else
struct String_t {
	char* buffer;  //0x0000
	int capacity;  //0x0004
	int grow_size; //0x0008
	int length;    //0x000C
};               //Size=0x0010

struct CPaintKit {
	int id; //0x0000

	String_t name;            //0x0004
	String_t description;     //0x0014
	String_t item_name;       //0x0024
	String_t material_name;   //0x0034
	String_t image_inventory; //0x0044

	char pad_0x0054[0x8C]; //0x0054
};                       //Size=0x00E0

struct AlternateIconData_t {
private:
	int32_t pad0;

public:
	String_t icon_path;
	String_t icon_path_large;

private:
	String_t pad1[2];
};

struct item_list_entry_t {
	int item;
	int paintkit;

private:
	int32_t pad0[5];
};

class CEconItemSetDefinition {
public:
	virtual ~CEconItemSetDefinition() { };

	char* key_name;
	char* name;
	char* unlocalized_name;
	char* set_description;
	CUtlVector< item_list_entry_t > items;
	int store_bundle;
	bool is_collection;
	bool is_hidden_set;
	CUtlVector< int > attributes;
};

auto initialize_kits() -> void {
	const auto V_UCS2ToUTF8 = reinterpret_cast<int(*)(const wchar_t* ucs2, char* utf8, int len)>(GetProcAddress(GetModuleHandleA(XorStr("vstdlib.dll")), XorStr("V_UCS2ToUTF8")));
	const auto t = FIELD_OFFSET(CCStrike15ItemDefinition, model_player);

	// Search the relative calls

	// call    ItemSystem
	// push    dword ptr [esi+0Ch]
	// lea     ecx, [eax+4]
	// call    CEconItemSchema::GetPaintKitDefinition

	const auto sig_address = Memory::Scan(XorStr("client.dll"), XorStr("E8 ? ? ? ? FF 76 0C 8D 48 04 E8"));

	// Skip the opcode, read rel32 address
	const auto item_system_offset = *reinterpret_cast<std::int32_t*>(sig_address + 1);

	// Add the offset to the end of the instruction
	const auto item_system_fn = reinterpret_cast<CCStrike15ItemSystem * (*)()>(sig_address + 5 + item_system_offset);

	// Skip VTable, first member variable of ItemSystem is ItemSchema
	const auto item_schema = reinterpret_cast<CCStrike15ItemSchema*>(std::uintptr_t(item_system_fn()) + sizeof(void*));

	// Dump paint kits
	{
		// Skip the instructions between, skip the opcode, read rel32 address
		const auto get_paint_kit_definition_offset = *reinterpret_cast<std::int32_t*>(sig_address + 11 + 1);

		// Add the offset to the end of the instruction
		const auto get_paint_kit_definition_fn = reinterpret_cast<CPaintKit * (__thiscall*)(CCStrike15ItemSchema*, int)>(sig_address + 11 + 5 + get_paint_kit_definition_offset);

		// The last offset is start_element, we need that

		// push    ebp
		// mov     ebp, esp
		// sub     esp, 0Ch
		// mov     eax, [ecx+298h]

		// Skip instructions, skip opcode, read offset
		const auto start_element_offset = *reinterpret_cast<std::intptr_t*>(std::uintptr_t(get_paint_kit_definition_fn) + 8 + 2);

		// Calculate head base from start_element's offset ( 0x28C )
		const auto head_offset = start_element_offset - 12;

		// 0x220 offset, so difference is 0x6C
		const auto icons_offset = head_offset - 0x6C;

		const auto items_offset = head_offset - 0x194;

		const auto items_head = reinterpret_cast<Head_t< int, CCStrike15ItemDefinition* >*>(std::uintptr_t(item_schema) + items_offset);

		std::map< uint16_t, item_cstrike > items;

		// currently 72 items
		for (auto i = 0; i <= items_head->last_element; ++i) {
			const auto node = items_head->memory[i];
			const auto item = node.value;
			if (!item || !item->name)
				continue;

			if (!item->model_player)
				continue;

			if (item->item_sub_position >= LOADOUT_POSITION_MELEE && item->item_sub_position <= LOADOUT_POSITION_HEAVY5 || item->item_sub_position == LOADOUT_POSITION_SPACER4) {
				if (node.key == GLOVE_T_SIDE
					|| node.key == GLOVE_CT_SIDE
					|| node.key == 42
					|| node.key == 59
					|| node.key == 74
					|| item->item_sub_position == LOADOUT_POSITION_C4) {
					continue;
				}

				item_cstrike def;
				def.group = item->item_sub_position;
				def.name = item->name;
				def.glove = item->item_sub_position == LOADOUT_POSITION_SPACER4;
				def.knife = item->item_sub_position == LOADOUT_POSITION_MELEE;
				def.display_name = item->item_name;
				def.model_name = item->model_player;
				items[node.key] = def;
			}
		}

		const auto icons_head = reinterpret_cast<Head_t< int, AlternateIconData_t >*>(std::uintptr_t(item_schema) + *(int*)(Memory::Scan(XorStr("client.dll"), XorStr("8D 9A ?? ?? ?? ?? 89 45 9C")) + 2) + 4);

		const auto map_head = reinterpret_cast<Head_t< int, CPaintKit* >*>(std::uintptr_t(item_schema) + head_offset);

		skin_kits.reserve(map_head->allocation_count);

		for (auto i = 0; i <= map_head->last_element; ++i) {
			const auto paint_kit = map_head->memory[i].value;

			if (paint_kit->id == 9001)
				continue;

			const auto wide_name = Interfaces::m_pLocalize->Find(paint_kit->item_name.buffer + 1);
			char name[256];
			V_UCS2ToUTF8(wide_name, name, sizeof(name));

			all_skins.push_back({ paint_kit->id, name, paint_kit->name.buffer });

			if (paint_kit->id < 10000) {
				skin_kits.push_back({ paint_kit->id, name, paint_kit->name.buffer });
			}
			else {
				glove_kits.push_back({ paint_kit->id, name, paint_kit->name.buffer });
			}
		}

		const auto collections = reinterpret_cast<Head_t< int, CEconItemSetDefinition >*>(std::uintptr_t(item_schema) + *(int*)(Memory::Scan(XorStr("client.dll"), XorStr("74 43 8B 81 ?? ?? ?? ?? 89 45 FC")) + 4));

		for (auto i = 0; i <= collections->last_element; ++i) {
			const auto& collect = collections->memory[i].value;
			if (collect.items.m_Size <= 0)
				continue;

			for (int i = 0; i < collect.items.m_Size; ++i) {
				const auto& entry = collect.items.m_Memory.m_pMemory[i];
				if (items.count(entry.item) < 1 || items[entry.item].knife)
					continue;

				if (entry.item == WEAPON_KNIFE_CT)
					continue;

				// FIXME: find makes skin parsing so fucking slow
				auto skin_it = std::find(skin_kits.begin(), skin_kits.end(), (entry.paintkit));
				if (skin_it == skin_kits.end())
					continue;

				auto tmp = *skin_it;

				auto new_item = std::find(weapon_skins.begin(), weapon_skins.end(), (entry.item));
				if (new_item == weapon_skins.end()) {
					new_item = weapon_skins.insert(weapon_skins.end(), item_skins{ });
				}

				new_item->m_kits.push_back(tmp);
				new_item->display_name = items[entry.item].display_name;
				new_item->name = items[entry.item].name;
				new_item->id = entry.item;
				new_item->glove = items[entry.item].glove;
				new_item->knife = items[entry.item].knife;

				switch (items[entry.item].group) {
				case LOADOUT_POSITION_SECONDARY0:
				case LOADOUT_POSITION_SECONDARY1:
				case LOADOUT_POSITION_SECONDARY2:
				case LOADOUT_POSITION_SECONDARY3:
					new_item->group = WEAPONGROUP_PISTOL;
					break;

				case LOADOUT_POSITION_SECONDARY4:
				case LOADOUT_POSITION_SECONDARY5:
					new_item->group = WEAPONGROUP_HEAVYPISTOL;
					break;

				case LOADOUT_POSITION_SMG0:
				case LOADOUT_POSITION_SMG1:
				case LOADOUT_POSITION_SMG2:
				case LOADOUT_POSITION_SMG3:
				case LOADOUT_POSITION_SMG4:
				case LOADOUT_POSITION_SMG5:
					new_item->group = WEAPONGROUP_SUBMACHINE;
					break;

				case LOADOUT_POSITION_RIFLE0:
				case LOADOUT_POSITION_RIFLE1:
				case LOADOUT_POSITION_RIFLE3:
					new_item->group = WEAPONGROUP_RIFLE;
					break;

				case LOADOUT_POSITION_RIFLE2:
				case LOADOUT_POSITION_RIFLE4:
					new_item->group = WEAPONGROUP_SNIPER;
					break;

				case LOADOUT_POSITION_RIFLE5:
					new_item->group = WEAPONGROUP_AUTOSNIPER;
					break;

				case LOADOUT_POSITION_HEAVY0:
				case LOADOUT_POSITION_HEAVY1:
				case LOADOUT_POSITION_HEAVY2:
					new_item->group = WEAPONGROUP_SHOTGUN;
					break;

				case LOADOUT_POSITION_HEAVY3:
				case LOADOUT_POSITION_HEAVY4:
				case LOADOUT_POSITION_HEAVY5:
					new_item->group = WEAPONGROUP_HEAVY;
					break;

				default:
					new_item->group = -1;
					break;
				}
			}
		}

		std::sort(weapon_skins.begin(), weapon_skins.end(), [](const item_skins& a, const item_skins& b) {
			return a.display_name < b.display_name;
			});

		for (auto& info : items) {
			if (info.first == GLOVE_T_SIDE || info.first == GLOVE_CT_SIDE) {
				continue;
			}

			auto name = items[size_t(info.first)].name;

			auto new_item = std::find(weapon_skins.begin(), weapon_skins.end(), info.first);
			if (new_item == weapon_skins.end()) {
				new_item = weapon_skins.insert(weapon_skins.end(), item_skins{ });
			}

			if (items[size_t(info.first)].glove || items[size_t(info.first)].knife) {
				for (int i = 0; i < icons_head->last_element; ++i) {
					const auto& icon = icons_head->memory[i].value;

					auto end = icon.icon_path.buffer + icon.icon_path.length - 7;
					if (*(end + 1) != 'l') // _light
						continue;

					auto _weapon = strstr(icon.icon_path.buffer, name.data());
					if (!_weapon)
						continue;

					std::string skin_str = std::string(_weapon + name.size() + 1, end);

					if (!items[size_t(info.first)].glove) {
						auto skin_it = std::find_if(skin_kits.begin(), skin_kits.end(), [skin_str](const paint_kit& a) {
							return strcmp(skin_str.c_str(), a.item_name.data()) == 0;
							});

						if (skin_it == skin_kits.end())
							continue;

						new_item->m_kits.push_back(*skin_it);
					}
					else {
						auto skin_it = std::find_if(glove_kits.begin(), glove_kits.end(), [skin_str](const paint_kit& a) {
							return strcmp(skin_str.c_str(), a.item_name.data()) == 0;
							});

						if (skin_it == glove_kits.end())
							continue;

						new_item->m_kits.push_back(*skin_it);
						glove_kits.erase(skin_it);
					}
				}
			}

			new_item->display_name = items[size_t(info.first)].display_name;
			new_item->name = name;
			new_item->glove = items[size_t(info.first)].glove;
			new_item->knife = items[size_t(info.first)].knife;
			new_item->model_name = items[size_t(info.first)].model_name;
			new_item->id = info.first;

			const auto wide_name = Interfaces::m_pLocalize->Find(new_item->display_name.c_str());
			char buffer[256];
			V_UCS2ToUTF8(wide_name, buffer, sizeof(buffer));

			new_item->display_name = buffer;

			if (items[size_t(info.first)].glove || items[size_t(info.first)].knife) {
				if (new_item->glove) {
					k_glove_names.push_back(WeaponName_t(new_item->id, new_item->display_name.c_str()));
					k_weapon_info[new_item->id].icon = nullptr;
				}
				else {
					const char* meme = new_item->name.data();
					auto weapon_ptr = strstr(meme, XorStr("weapon_"));
					if (weapon_ptr)
						meme = weapon_ptr + sizeof(("weapon_")) - 1;

					k_knife_names.push_back(WeaponName_t(new_item->id, new_item->display_name.c_str()));
					k_weapon_info[new_item->id].icon = meme;
				}

				k_weapon_info[new_item->id].model = new_item->model_name.c_str();
			}
		}

		for (auto& value : weapon_skins) {
			std::sort(value.m_kits.begin(), value.m_kits.end());
		}

		// copy array contents
		if (!skin_kits.empty()) {
			std::sort(skin_kits.begin(), skin_kits.end());
			for (auto i = 0; i < skin_kits.size(); ++i) {
				g_Vars.globals.m_vecPaintKits.emplace_back(skin_kits[i].name);
			}
		}
	}

}

```

`CSGO SDK/Features/Miscellaneous/KitParser.hpp`:

```hpp
#pragma once
#include <vector>
#include <map>

#include "../../SDK/CVariables.hpp"

enum LoadoutSlot {
	LOADOUT_POSITION_MELEE,
	LOADOUT_POSITION_C4,
	LOADOUT_POSITION_SECONDARY0,
	LOADOUT_POSITION_SECONDARY1,
	LOADOUT_POSITION_SECONDARY2,
	LOADOUT_POSITION_SECONDARY3,
	LOADOUT_POSITION_SECONDARY4,
	LOADOUT_POSITION_SECONDARY5,
	LOADOUT_POSITION_SMG0,
	LOADOUT_POSITION_SMG1,
	LOADOUT_POSITION_SMG2,
	LOADOUT_POSITION_SMG3,
	LOADOUT_POSITION_SMG4,
	LOADOUT_POSITION_SMG5,
	LOADOUT_POSITION_RIFLE0,
	LOADOUT_POSITION_RIFLE1,
	LOADOUT_POSITION_RIFLE2,
	LOADOUT_POSITION_RIFLE3,
	LOADOUT_POSITION_RIFLE4,
	LOADOUT_POSITION_RIFLE5,
	LOADOUT_POSITION_HEAVY0,
	LOADOUT_POSITION_HEAVY1,
	LOADOUT_POSITION_HEAVY2,
	LOADOUT_POSITION_HEAVY3,
	LOADOUT_POSITION_HEAVY4,
	LOADOUT_POSITION_HEAVY5,
	LOADOUT_POSITION_GRENADE0,
	LOADOUT_POSITION_GRENADE1,
	LOADOUT_POSITION_GRENADE2,
	LOADOUT_POSITION_GRENADE3,
	LOADOUT_POSITION_GRENADE4,
	LOADOUT_POSITION_GRENADE5,
	LOADOUT_POSITION_EQUIPMENT0,
	LOADOUT_POSITION_EQUIPMENT1,
	LOADOUT_POSITION_EQUIPMENT2,
	LOADOUT_POSITION_EQUIPMENT3,
	LOADOUT_POSITION_EQUIPMENT4,
	LOADOUT_POSITION_EQUIPMENT5,
	LOADOUT_POSITION_SPACER1,
	LOADOUT_POSITION_SPACER2,
	LOADOUT_POSITION_SPACER3,
	LOADOUT_POSITION_SPACER4,
	LOADOUT_POSITION_SPACER5,
	LOADOUT_POSITION_SPACER6,
	LOADOUT_POSITION_MISC0,
	LOADOUT_POSITION_MISC1,
	LOADOUT_POSITION_MISC2,
	LOADOUT_POSITION_MISC3,
	LOADOUT_POSITION_MISC4,
	LOADOUT_POSITION_MISC5,
	LOADOUT_POSITION_MISC6,
	LOADOUT_POSITION_MISC7,
	LOADOUT_POSITION_MISC8,
	LOADOUT_POSITION_MISC9,
	LOADOUT_POSITION_SPACER7,
	LOADOUT_POSITION_FLAIR0,
};

struct item_cstrike {
	bool glove = false;
	bool knife = false;
	int group;
	std::string_view name;
	std::string display_name;
	std::string model_name;
};

// Stupid MSVC requires separate constexpr constructors for any initialization
struct Item_t {
	Item_t() { }

	constexpr Item_t(const char* model, const char* icon = nullptr) :
		model(model),
		icon(icon) {
	}

	const char* model;
	const char* icon;
};

enum WeaponGroup_t {
	WEAPONGROUP_PISTOL,
	WEAPONGROUP_HEAVYPISTOL,
	WEAPONGROUP_RIFLE,
	WEAPONGROUP_SNIPER,
	WEAPONGROUP_AUTOSNIPER,
	WEAPONGROUP_SUBMACHINE,
	WEAPONGROUP_HEAVY,
	WEAPONGROUP_SHOTGUN,
	WEAPONGROUP_MAX
};

struct paint_kit {
	int id;
	std::string name;
	std::string_view item_name;

	auto operator<(const paint_kit& other) const -> bool {
		return name < other.name;
	}

	auto operator==(int _id) const -> bool {
		return id == _id;
	}
};

struct item_skins {
	int id;
	int group;
	std::vector< paint_kit > m_kits;
	std::string_view name;
	std::string display_name;
	std::string model_name;
	bool glove;
	bool knife;

	item_skins() {
		paint_kit default_kit;
		default_kit.id = 0;
		default_kit.item_name = ("#PaintKit_Default");
		default_kit.name = XorStr("-");
		m_kits.push_back(default_kit);
	}

	auto
		operator==(int _id) const -> bool {
		return id == _id;
	}
};

extern std::vector< paint_kit > all_skins;
extern std::vector< paint_kit > skin_kits;
extern std::vector< item_skins > weapon_skins;
extern std::vector< WeaponName_t > k_knife_names;
extern std::vector< WeaponName_t > k_glove_names;
extern std::map< size_t, Item_t > k_weapon_info;
extern auto initialize_kits() -> void;

```

`CSGO SDK/Features/Miscellaneous/Miscellaneous.cpp`:

```cpp
#include "Miscellaneous.hpp"
#include "../../SDK/displacement.hpp"

#include "../../Source.hpp"
#include "../../SDK/Classes/player.hpp"
#include "../Game/Prediction.hpp"

namespace Interfaces
{
	inline float rgb_to_srgb(float flLinearValue) {
		return flLinearValue;
		// float x = Math::Clamp( flLinearValue, 0.0f, 1.0f );
		// return ( x <= 0.0031308f ) ? ( x * 12.92f ) : ( 1.055f * powf( x, ( 1.0f / 2.4f ) ) ) - 0.055f;
	}

	class C_Miscellaneous : public Miscellaneous {
	public:
		static Miscellaneous* Get();
		virtual void Main();

		C_Miscellaneous() { };
		virtual ~C_Miscellaneous() {
		}

	private:
		const char* skynames[16] = {
			"Default",
			"cs_baggage_skybox_",
			"cs_tibet",
			"embassy",
			"italy",
			"jungle",
			"nukeblank",
			"office",
			"sky_csgo_cloudy01",
			"sky_csgo_night02",
			"sky_csgo_night02b",
			"sky_dust",
			"sky_venice",
			"vertigo",
			"vietnam",
			"sky_descent"
		};

		// wall modulation stuff
		FloatColor walls = FloatColor(1.0f, 1.0f, 1.0f, 1.0f);
		FloatColor props = FloatColor(1.0f, 1.0f, 1.0f, 1.0f);
		FloatColor skybox = FloatColor(1.0f, 1.0f, 1.0f, 1.0f);

		// clantag
		int clantag_step = 0;

		virtual void ModulateWorld();
		virtual void ClantagChanger();
		virtual void ViewModelChanger();
		virtual void SkyboxChanger();
	};

	C_Miscellaneous g_Misc;
	Miscellaneous* C_Miscellaneous::Get() {
		return &g_Misc;
	}

	void C_Miscellaneous::Main() {
		ModulateWorld();
		SkyboxChanger();

		if (!g_Vars.globals.HackIsReady)
			return;

		ClantagChanger();
		ViewModelChanger();
	}

	void C_Miscellaneous::ModulateWorld() {
		if (!g_Vars.globals.HackIsReady) {
			walls = FloatColor(1.0f, 1.0f, 1.0f, 1.0f);
			props = FloatColor(1.0f, 1.0f, 1.0f, 1.0f);
			skybox = FloatColor(1.0f, 1.0f, 1.0f, 1.0f);
			return;
		}

		if (!C_CSPlayer::GetLocalPlayer())
			return;

		static auto w = FloatColor(1.0f, 1.0f, 1.0f, 1.0f);
		static auto p = FloatColor(0.9f, 0.9f, 0.9f, 1.0f);
		static auto s = FloatColor(1.0f, 1.0f, 1.0f, 1.0f);;

		if (g_Vars.esp.night_mode) {
			float power = g_Vars.esp.world_adjustement_value / 100.f;
			float power_props = g_Vars.esp.prop_adjustement_value / 100.f;

			w = FloatColor(power, power, power, 1.f);
			p = FloatColor(power_props, power_props, power_props, std::clamp<float>((g_Vars.esp.transparent_props + 0.1f) / 100.f, 0.f, 1.f));
		}
		else {
			w = FloatColor(1.0f, 1.0f, 1.0f, 1.0f);
			p = FloatColor(1.0f, 1.0f, 1.0f, 1.0f);
			//s = FloatColor( 1.0f, 1.0f, 1.0f, 1.0f );
		}

		if (g_Vars.esp.skybox) {
			s = g_Vars.esp.skybox_modulation;
		}
		else {
			s = FloatColor(1.0f, 1.0f, 1.0f, 1.0f);
		}

		if (walls != w || props != p || skybox != s) {
			walls = w;
			props = p;
			skybox = s;

			auto invalid_material = Interfaces::m_pMatSystem->InvalidMaterial();
			for (auto i = Interfaces::m_pMatSystem->FirstMaterial();
				i != invalid_material;
				i = Interfaces::m_pMatSystem->NextMaterial(i)) {
				auto material = Interfaces::m_pMatSystem->GetMaterial(i);

				if (!material || material->IsErrorMaterial())
					continue;

				FloatColor color = walls;
				auto group = material->GetTextureGroupName();

				if (!material->GetName())
					continue;

				if (*group == 'W') { // world textures
					if (group[4] != 'd')
						continue;
					color = walls;
				}
				else if (*group == 'S') { // staticprops & skybox
					auto thirdCharacter = group[3];
					if (thirdCharacter == 'B') {
						color = skybox;
					}
					else if (thirdCharacter == 't' && group[6] == 'P') {
						color = props;
					}
					else {
						continue;
					}
				}
				else {
					continue;
				}

				color.r = rgb_to_srgb(color.r);
				color.g = rgb_to_srgb(color.g);
				color.b = rgb_to_srgb(color.b);

				material->AlphaModulate(color.a);
				material->ColorModulate(color.r, color.g, color.b);
			}
		}
	}

	void C_Miscellaneous::ClantagChanger() {
		static bool run_once = false;
		static auto fnClantagChanged = (int(__fastcall*)(const char*, const char*)) Engine::Displacement.Function.m_uClanTagChange;
		static auto g_GameRules = *(uintptr_t**)(Engine::Displacement.Data.m_GameRules);

		if (!g_Vars.misc.clantag_changer) {
			if (run_once) {
				fnClantagChanged(XorStr(""), XorStr(""));
				run_once = false;
			}

			return;
		}

		if (!Interfaces::m_pPrediction->GetUnpredictedGlobals()) {
			if (run_once) {
				fnClantagChanged(XorStr(""), XorStr(""));
				run_once = false;
			}

			return;
		}

		run_once = true;

		std::string szClanTag;

		if (*(bool*)(*(uintptr_t*)g_GameRules + 0x20)) { // freeze period.
			szClanTag = (XorStr("AutismWare"));
			fnClantagChanged(szClanTag.data(), szClanTag.data());
			return;
		}

		auto netchannel = Encrypted_t<INetChannelInfo>(Interfaces::m_pEngine->GetNetChannelInfo());

		static int iPrevFrame = 0;
		static bool bReset = false;

		// fix high ping tag delay.
		float delay = netchannel->GetLatency(FLOW_INCOMING);

		int iCurFrame = (((int)(Interfaces::m_pPrediction->GetUnpredictedGlobals()->curtime + TIME_TO_TICKS(delay)) % 14)) * 2;

		if (iPrevFrame != iCurFrame) {
			switch (iCurFrame % 14) {
			case 0: {  szClanTag = (XorStr("")); break; }
			case 1: {  szClanTag = (XorStr("")); break; }
			case 2: {  szClanTag = (XorStr("Au")); break; }
			case 3: {  szClanTag = (XorStr("Au")); break; }
			case 4: {  szClanTag = (XorStr("Aut")); break; }
			case 5: {  szClanTag = (XorStr("Aut")); break; }
			case 6: {  szClanTag = (XorStr("Auti")); break; }
			case 7: {  szClanTag = (XorStr("Auti")); break; }
			case 8: {  szClanTag = (XorStr("Autis")); break; }
			case 9: {  szClanTag = (XorStr("Autis")); break; }
			case 10: { szClanTag = (XorStr("Autism")); break; }
			case 11: { szClanTag = (XorStr("Autism")); break; }
			case 12: { szClanTag = (XorStr("Autism\n")); break; }
			case 13: { szClanTag = (XorStr("Autism\n")); break; }
			}

			// set our clantag
			fnClantagChanged(szClanTag.data(), szClanTag.data());

			// set current/last frame.
			iPrevFrame = iCurFrame;
		}
	}

	void C_Miscellaneous::ViewModelChanger() {
		g_Vars.viewmodel_fov->SetValue(g_Vars.misc.viewmodel_fov);
	}

	void C_Miscellaneous::SkyboxChanger() {
		static int iOldSky = 0;

		if (!g_Vars.globals.HackIsReady) {
			iOldSky = 0;
			return;
		}

		static auto fnLoadNamedSkys = (void(__fastcall*)(const char*))Engine::Displacement.Function.m_uLoadNamedSkys;
		static ConVar* default_skyname = Interfaces::m_pCvar->FindVar(XorStr("sv_skyname"));
		if (default_skyname) {
			if (iOldSky != g_Vars.esp.sky_changer) {
				const char* sky_name = g_Vars.esp.sky_changer != 0 ? skynames[g_Vars.esp.sky_changer] : default_skyname->GetString();
				fnLoadNamedSkys(sky_name);
				iOldSky = g_Vars.esp.sky_changer;
			}
		}
	}

	Miscellaneous* Miscellaneous::Get() {
		static C_Miscellaneous instance;
		return &instance;
	}
}

```

`CSGO SDK/Features/Miscellaneous/Miscellaneous.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

namespace Interfaces
{
	class __declspec(novtable) Miscellaneous : public NonCopyable {
	public:
		static Miscellaneous* Get();
		virtual void Main() = NULL;

	protected:
		Miscellaneous() { };
		virtual ~Miscellaneous() {
		}
	};
}

```

`CSGO SDK/Features/Miscellaneous/Movement.cpp`:

```cpp
#include "../../source.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "Movement.hpp"
#include "../../Utils/Math.h"
#include "../Rage/AntiAim.hpp"
#include "../../SDK/Valve/CBaseHandle.hpp"
#include "../../Utils/InputSys.hpp"
#include "../Rage/FakeLag.hpp"
#include "../Rage/Ragebot.hpp"
#include "../Rage/Zeusbot.hpp"
#include "../Rage/AntiAim.hpp"
#include "../Rage/KnifeBot.hpp"
#include "../Game/Prediction.hpp"
#include "../../SDK/Displacement.hpp"
#include "../Game/SetupBones.hpp"
#include "../../Utils/Threading/threading.h"
#include "../Rage/TickbaseShift.hpp"
#include "../Visuals/EventLogger.hpp"
#include "../Rage/Ragebot.hpp"

// todo: move this
C_AnimationLayer FakeAnimLayers[13];

extern Vector AutoPeekPos;

extern matrix3x4_t HeadBone;

void SimulateMovement(C_SimulationData& data) {
	if (!(data.m_iFlags & FL_ONGROUND)) {
		data.m_vecVeloctity.z -= (Interfaces::m_pGlobalVars->interval_per_tick * g_Vars.sv_gravity->GetFloat() * 0.5f);
	}
	else if (data.m_bJumped) {
		data.m_bJumped = false;
		data.m_vecVeloctity.z = g_Vars.sv_jump_impulse->GetFloat();
		data.m_iFlags &= ~FL_ONGROUND;
	}

	// can't step up onto very steep slopes
	static const float MIN_STEP_NORMAL = 0.7f;

	if (!data.m_vecVeloctity.IsZero()) {
		auto collidable = data.m_player->GetCollideable();
		const Vector mins = collidable->OBBMins();
		const Vector max = collidable->OBBMaxs();

		const Vector src = data.m_vecOrigin;
		Vector end = src + (data.m_vecVeloctity * Interfaces::m_pGlobalVars->interval_per_tick);

		Ray_t ray;
		ray.Init(src, end, mins, max);

		CGameTrace trace;
		CTraceFilter filter;
		filter.pSkip = data.m_player;

		Interfaces::m_pEngineTrace->TraceRay(ray, MASK_SOLID, &filter, &trace);

		// CGameMovement::TryPlayerMove
		if (trace.fraction != 1.f) {
			// BUGFIXME: is it should be 4? ( not 2 )
			for (int i = 0; i < 2; i++) {
				// decompose velocity into plane
				data.m_vecVeloctity -= trace.plane.normal * data.m_vecVeloctity.Dot(trace.plane.normal);

				const float dot = data.m_vecVeloctity.Dot(trace.plane.normal);
				if (dot < 0.f) { // moving against plane
					data.m_vecVeloctity.x -= dot * trace.plane.normal.x;
					data.m_vecVeloctity.y -= dot * trace.plane.normal.y;
					data.m_vecVeloctity.z -= dot * trace.plane.normal.z;
				}

				end = trace.endpos + (data.m_vecVeloctity * (Interfaces::m_pGlobalVars->interval_per_tick * (1.f - trace.fraction)));

				ray.Init(trace.endpos, end, mins, max);
				Interfaces::m_pEngineTrace->TraceRay(ray, MASK_SOLID, &filter, &trace);
				if (trace.fraction == 1.f)
					break;
			}
		}

		data.m_vecOrigin = trace.endpos;
		end = trace.endpos;
		end.z -= 2.f;

		ray.Init(data.m_vecOrigin, end, mins, max);
		Interfaces::m_pEngineTrace->TraceRay(ray, MASK_SOLID, &filter, &trace);

		data.m_iFlags &= ~FL_ONGROUND;

		if (trace.DidHit() && trace.plane.normal.z >= MIN_STEP_NORMAL) {
			data.m_iFlags |= FL_ONGROUND;
		}

		if (data.m_iFlags & FL_ONGROUND)
			data.m_vecVeloctity.z = 0.0f;
		else
			data.m_vecVeloctity.z -= Interfaces::m_pGlobalVars->interval_per_tick * g_Vars.sv_gravity->GetFloat() * 0.5f;
	}
}

void ExtrapolatePlayer(C_SimulationData& data, int simulationTicks, const Vector& wishvel, float wishspeed, float maxSpeed) {
	for (int i = 0; i < simulationTicks; ++i) {
		SimulateMovement(data);

		if (data.m_vecVeloctity.IsZero())
			break;

		auto Accelerate = [&data](const Vector& wishdir, float wishspeed, float maxSpeed) {
			float addspeed, accelspeed, currentspeed;

			// See if we are changing direction a bit
			currentspeed = data.m_vecVeloctity.Dot(wishdir);

			// Reduce wishspeed by the amount of veer.
			addspeed = wishspeed - currentspeed;

			// If not going to add any speed, done.
			if (addspeed <= 0)
				return;

			// Determine amount of accleration.
			static int playerSurfaceFrictionOffset = SDK::Memory::FindInDataMap(data.m_player->GetPredDescMap(), XorStr("m_surfaceFriction"));
			float playerSurfaceFriction = *(float*)(uintptr_t(data.m_player) + playerSurfaceFrictionOffset);
			accelspeed = g_Vars.sv_accelerate->GetFloat() * Interfaces::m_pGlobalVars->interval_per_tick * maxSpeed * playerSurfaceFriction;

			// Cap at addspeed
			if (accelspeed > addspeed)
				accelspeed = addspeed;

			// Adjust velocity.
			for (int i = 0; i < 3; i++) {
				data.m_vecVeloctity[i] += accelspeed * wishdir[i];
			}

			float len = data.m_vecVeloctity.Length2D();
			if (len > ((data.m_iFlags & FL_ONGROUND) ? (maxSpeed) : 320.0f)) {
				float z = data.m_vecVeloctity.z;
				data.m_vecVeloctity.z = 0.0f;
				data.m_vecVeloctity = data.m_vecVeloctity.Normalized() * ((data.m_iFlags & FL_ONGROUND) ? (maxSpeed) : 320.0f);
				data.m_vecVeloctity.z = z;
			}
		};

		Accelerate(wishvel, wishspeed, maxSpeed);
	}
}

void RotateMovement(Encrypted_t<CUserCmd> cmd, QAngle wish_angle, QAngle old_angles) {
	// aimware movement fix, reversed by ph4ge/senator for gucci
	if (old_angles.x != wish_angle.x || old_angles.y != wish_angle.y || old_angles.z != wish_angle.z) {
		Vector wish_forward, wish_right, wish_up, cmd_forward, cmd_right, cmd_up;

		auto viewangles = old_angles;
		auto movedata = Vector(cmd->forwardmove, cmd->sidemove, cmd->upmove);
		viewangles.Normalize();

		if (viewangles.z != 0.f) {
			auto pLocal = C_CSPlayer::GetLocalPlayer();

			if (pLocal && !(pLocal->m_fFlags() & FL_ONGROUND))
				movedata.y = 0.f;
		}

		wish_forward = wish_angle.ToVectors(&wish_right, &wish_up);
		cmd_forward = viewangles.ToVectors(&cmd_right, &cmd_up);

		auto v8 = sqrt(wish_forward.x * wish_forward.x + wish_forward.y * wish_forward.y), v10 = sqrt(wish_right.x * wish_right.x + wish_right.y * wish_right.y), v12 = sqrt(wish_up.z * wish_up.z);

		Vector wish_forward_norm(1.0f / v8 * wish_forward.x, 1.0f / v8 * wish_forward.y, 0.f),
			wish_right_norm(1.0f / v10 * wish_right.x, 1.0f / v10 * wish_right.y, 0.f),
			wish_up_norm(0.f, 0.f, 1.0f / v12 * wish_up.z);

		auto v14 = sqrt(cmd_forward.x * cmd_forward.x + cmd_forward.y * cmd_forward.y), v16 = sqrt(cmd_right.x * cmd_right.x + cmd_right.y * cmd_right.y), v18 = sqrt(cmd_up.z * cmd_up.z);

		Vector cmd_forward_norm(1.0f / v14 * cmd_forward.x, 1.0f / v14 * cmd_forward.y, 1.0f / v14 * 0.0f),
			cmd_right_norm(1.0f / v16 * cmd_right.x, 1.0f / v16 * cmd_right.y, 1.0f / v16 * 0.0f),
			cmd_up_norm(0.f, 0.f, 1.0f / v18 * cmd_up.z);

		auto v22 = wish_forward_norm.x * movedata.x, v26 = wish_forward_norm.y * movedata.x, v28 = wish_forward_norm.z * movedata.x, v24 = wish_right_norm.x * movedata.y, v23 = wish_right_norm.y * movedata.y, v25 = wish_right_norm.z * movedata.y, v30 = wish_up_norm.x * movedata.z, v27 = wish_up_norm.z * movedata.z, v29 = wish_up_norm.y * movedata.z;

		cmd->forwardmove = cmd_forward_norm.x * v24 + cmd_forward_norm.y * v23 + cmd_forward_norm.z * v25 + (cmd_forward_norm.x * v22 + cmd_forward_norm.y * v26 + cmd_forward_norm.z * v28) + (cmd_forward_norm.y * v30 + cmd_forward_norm.x * v29 + cmd_forward_norm.z * v27);
		cmd->sidemove = cmd_right_norm.x * v24 + cmd_right_norm.y * v23 + cmd_right_norm.z * v25 + (cmd_right_norm.x * v22 + cmd_right_norm.y * v26 + cmd_right_norm.z * v28) + (cmd_right_norm.x * v29 + cmd_right_norm.y * v30 + cmd_right_norm.z * v27);
		cmd->upmove = cmd_up_norm.x * v23 + cmd_up_norm.y * v24 + cmd_up_norm.z * v25 + (cmd_up_norm.x * v26 + cmd_up_norm.y * v22 + cmd_up_norm.z * v28) + (cmd_up_norm.x * v30 + cmd_up_norm.y * v29 + cmd_up_norm.z * v27);

		/*
		cmd->forwardmove = Math::Clamp( cmd->forwardmove, -g_Vars.cl_forwardspeed->GetFloat( ), g_Vars.cl_forwardspeed->GetFloat( ) );
		cmd->sidemove = Math::Clamp( cmd->sidemove, -g_Vars.cl_sidespeed->GetFloat( ), g_Vars.cl_sidespeed->GetFloat( ) );
		cmd->upmove = Math::Clamp( cmd->upmove, -g_Vars.cl_upspeed->GetFloat( ), g_Vars.cl_upspeed->GetFloat( ) );*/
	}
}

namespace Interfaces
{
	struct MovementData {
		Encrypted_t<CUserCmd> m_pCmd = nullptr;
		C_CSPlayer* m_pLocal = nullptr;
		bool* m_pSendPacket = nullptr;
		bool* m_pFinalPacket = nullptr;

		uintptr_t* m_pCLMoveReturn = nullptr;

		bool m_bInRecursion = false;
		int m_iRecursionTicks = 0;

		QAngle m_angRenderViewangles{ };
		QAngle m_angPreviousAngles{ };
		QAngle m_angMovementAngle{ };
		float m_flOldYaw = 0.0f;
		float m_flJumpFall = 0.0f;

		int nBhops = 0;
		int m_fPrePredFlags = 0;

		C_AnimationLayer* ANIMATION_LAYER_MOVEMENT_LAND_OR_CLIMB;
		C_AnimationLayer* ANIMATION_LAYER_MOVEMENT_JUMP_OR_FALL;

		int   m_bStopPlayer = 0;
		bool  m_bMinimalSpeed = false;
		bool  m_bFastStop = false;
		bool  m_bStoppedTick = false;
		bool  m_bFakeducking = false;
		bool  m_bStopOk = false;
		bool  jumped_last_tick = false;
		bool  should_fake_jump = false;

		float m_flLowerBodyUpdateTime = 0.0f;

		int m_iLatency = 0;
	};

	static MovementData _move_data;

	class C_Movement : public Movement {
	public:
		virtual void PrePrediction(Encrypted_t<CUserCmd> cmd, C_CSPlayer* pLocal, bool* pSendPacket, bool* bFinalPacket, uintptr_t* cl_move);
		virtual void InPrediction();
		virtual void PostPrediction();
		virtual void InstantStop(CUserCmd* cmd = nullptr);
		virtual void ThirdPerson();

		virtual float GetLBYUpdateTime() {
			return  m_movement_data->m_flLowerBodyUpdateTime;
		}

		virtual int GetButtons() {
			return m_movement_data->m_pCmd->buttons;
		}

		virtual QAngle& GetMovementAngle() {
			return m_movement_data->m_angMovementAngle;
		}

		virtual bool StopPlayer() {
			if (m_movement_data->m_bStoppedTick) {
				return false;
			}

			return AutoStopInternal();
		}

		virtual void StopPlayerAtMinimalSpeed() {
			m_movement_data->m_bMinimalSpeed = true;
		}

		virtual void AutoStop(int ticks = 1);
		virtual bool GetStopState();
		virtual bool CreateMoveRecursion();

		C_Movement() : m_movement_data(&_move_data) { ; };
		virtual ~C_Movement() { };

	private:
		Encrypted_t<MovementData> m_movement_data;

		void MoveExploit();
		bool AutoStopInternal();
		bool AdjustVelocity();
		void AutoJump();
		void AutoStrafe();
		void SlowWalk(Encrypted_t<CUserCmd> cmd);
	};

	Movement* Movement::Get() {
		static C_Movement movement;
		return &movement;
	}

	void C_Movement::PrePrediction(Encrypted_t<CUserCmd> cmd, C_CSPlayer* pLocal, bool* pSendPacket, bool* bFinalPacket, uintptr_t* cl_move) {
		m_movement_data->m_pCmd = cmd;
		m_movement_data->m_pLocal = pLocal;
		m_movement_data->m_pSendPacket = pSendPacket;
		m_movement_data->m_pFinalPacket = bFinalPacket;
		m_movement_data->m_angRenderViewangles = m_movement_data->m_pCmd->viewangles;

		m_movement_data->m_pCLMoveReturn = cl_move;
		m_movement_data->m_bStopOk = false;
		m_movement_data->m_bStoppedTick = false;

		// static int autostop_ticks = 0;

		if (!pLocal || pLocal->IsDead())
			return;

		{
			float delta = std::fabsf(Interfaces::m_pEngine->GetNetChannelInfo()->GetLatency(FLOW_OUTGOING) - Interfaces::m_pEngine->GetNetChannelInfo()->GetAvgLatency(FLOW_OUTGOING));
			m_movement_data->m_iLatency = TIME_TO_TICKS(delta) + 1 - **(int**)Engine::Displacement.Data.m_uHostFrameTicks;
		}

		m_movement_data->m_angMovementAngle = m_movement_data->m_pCmd->viewangles;
		m_movement_data->m_fPrePredFlags = m_movement_data->m_pLocal->m_fFlags();

		if (g_Vars.misc.fastduck)
			m_movement_data->m_pCmd->buttons |= IN_BULLRUSH;

		if (g_Vars.misc.duckjump) {
			if (m_movement_data->m_pCmd->buttons & IN_JUMP) {
				if (!(m_movement_data->m_pLocal->m_fFlags() & FL_ONGROUND))
					m_movement_data->m_pCmd->buttons |= IN_DUCK;
			}
		}

		if (g_Vars.misc.minijump && !((m_movement_data->m_pCmd->buttons & IN_DUCK))) {
			if (!(m_movement_data->m_pCmd->buttons & IN_JUMP) || (m_movement_data->m_pLocal->m_fFlags() & FL_ONGROUND) || m_movement_data->m_pLocal->m_vecVelocity().z >= -140.0f)
				m_movement_data->m_pCmd->buttons &= ~IN_DUCK;
			else
				m_movement_data->m_pCmd->buttons |= IN_DUCK;
		}

		g_Vars.globals.Fakewalking = false;

		if (g_Vars.misc.autojump)
			AutoJump();

		if (g_Vars.misc.autostrafer)
			AutoStrafe();

		bool instant_stop = (g_Vars.misc.instant_stop && g_Vars.misc.instant_stop_key.enabled);
		if (instant_stop || (g_Vars.misc.quickstop && !g_Vars.globals.WasShootingInPeek && m_movement_data->m_pLocal->m_fFlags() & FL_ONGROUND && !(m_movement_data->m_pCmd->buttons & IN_JUMP) && m_movement_data->m_pLocal->m_vecVelocity().Length() >= 1.2f)) {
			if (instant_stop || (!(m_movement_data->m_pCmd->buttons & IN_JUMP) && m_movement_data->m_pCmd->forwardmove == m_movement_data->m_pCmd->sidemove && m_movement_data->m_pCmd->sidemove == 0.0f)) {
				m_movement_data->m_bStopPlayer = 1;
				m_movement_data->m_bMinimalSpeed = false;
			}
		}

		bool peek = true;
		if (g_Vars.misc.autopeek && g_Vars.globals.WasShootingInPeek && !AutoPeekPos.IsZero()) {
			cmd->buttons &= ~IN_JUMP;

			auto delta = AutoPeekPos - m_movement_data->m_pLocal->GetAbsOrigin();
			m_movement_data->m_angMovementAngle = delta.ToEulerAngles();

			peek = false;

			m_movement_data->m_pCmd->forwardmove = g_Vars.cl_forwardspeed->GetFloat();
			m_movement_data->m_pCmd->sidemove = 0.0f;

			if (delta.Length2D() <= std::fmaxf(11.f, m_movement_data->m_pLocal->m_vecVelocity().Length2D() * Interfaces::m_pGlobalVars->interval_per_tick)) {
				float maxSpeed = m_movement_data->m_pLocal->GetMaxSpeed();
				static int playerSurfaceFrictionOffset = SDK::Memory::FindInDataMap(m_movement_data->m_pLocal->GetPredDescMap(), XorStr("m_surfaceFriction"));
				float playerSurfaceFriction = *(float*)(uintptr_t(m_movement_data->m_pLocal) + playerSurfaceFrictionOffset);
				float max_accelspeed = g_Vars.sv_accelerate->GetFloat() * Interfaces::m_pGlobalVars->interval_per_tick * maxSpeed * playerSurfaceFriction;

				m_movement_data->m_bStopPlayer = int(m_movement_data->m_pLocal->m_vecVelocity().Length2D() / max_accelspeed) - 1;
				m_movement_data->m_bMinimalSpeed = false;

				peek = true;
				g_Vars.globals.WasShootingInPeek = false;
			}
		}
		else {
			g_Vars.globals.WasShootingInPeek = false;
		}

		if (peek) {
			if (m_movement_data->m_bStopPlayer && AdjustVelocity()) {
				m_movement_data->m_bStoppedTick = true;
			}
		}

		if (!m_movement_data->m_bStoppedTick) {
			C_WeaponCSBaseGun* Weapon = (C_WeaponCSBaseGun*)m_movement_data->m_pLocal->m_hActiveWeapon().Get();
			if (Weapon) {
				auto weaponInfo = Weapon->GetCSWeaponData();
				if (g_Vars.misc.slow_walk && g_Vars.misc.slow_walk_bind.enabled) {
					if (Weapon && weaponInfo.IsValid())
						SlowWalk(cmd);
				}
				else if (g_Vars.misc.accurate_walk && m_movement_data->m_pCmd->buttons & IN_SPEED) {
					if (Weapon && weaponInfo.IsValid())
						SlowWalk(cmd);
				}
			}
		}

		m_movement_data->m_bStopPlayer--;
		m_movement_data->m_bMinimalSpeed = false;
		if (m_movement_data->m_bStopPlayer < 0)
			m_movement_data->m_bStopPlayer = 0;

		m_movement_data->m_pCmd->viewangles.Normalize();

		RotateMovement(m_movement_data->m_pCmd, m_movement_data->m_angMovementAngle, m_movement_data->m_pCmd->viewangles);
	}

	void C_Movement::InPrediction() {
		if (!m_movement_data->m_pLocal || m_movement_data->m_pLocal->IsDead() || !m_movement_data->m_pSendPacket)
			return;

		if (g_Vars.misc.edgejump && g_Vars.misc.edgejump_bind.enabled &&
			Engine::Prediction::Instance().GetFlags() & FL_ONGROUND && !(m_movement_data->m_pLocal->m_fFlags() & FL_ONGROUND)) {
			m_movement_data->m_pCmd->buttons |= IN_JUMP;
		}

		auto animState = m_movement_data->m_pLocal->m_PlayerAnimState();
		if (!animState)
			return;

		m_movement_data->m_pLocal->SetAbsAngles(QAngle(0.f, animState->m_flAbsRotation, 0.f));
		m_movement_data->m_pLocal->InvalidateBoneCache();

		const float PitchPosBackup = *(float*)(uintptr_t(m_movement_data->m_pLocal) + Engine::Displacement.DT_BaseAnimating.m_flPoseParameter + 48);

		*(float*)(uintptr_t(m_movement_data->m_pLocal) + Engine::Displacement.DT_BaseAnimating.m_flPoseParameter + 48) = 0.5f;

		g_BoneSetup.BuildBones(m_movement_data->m_pLocal, BONE_USED_BY_ANYTHING, BoneSetupFlags::None);

		g_Vars.globals.m_vecFixedEyePosition = m_movement_data->m_pLocal->GetEyePosition();

		*(float*)(uintptr_t(m_movement_data->m_pLocal) + Engine::Displacement.DT_BaseAnimating.m_flPoseParameter + 48) = PitchPosBackup;

		bool bDontFakelag = g_Vars.misc.move_exploit_key.enabled && g_Vars.misc.move_exploit && g_Vars.globals.bMoveExploiting;

		MoveExploit();

		if (g_Vars.fakelag.enabled) {
			if (!bDontFakelag)
				Interfaces::FakeLag::Get()->Main(m_movement_data->m_pSendPacket, m_movement_data->m_pCmd);
		}

		g_Vars.globals.bInRagebot = Interfaces::Ragebot::Get()->Run(m_movement_data->m_pCmd, m_movement_data->m_pLocal, m_movement_data->m_pSendPacket);


		// don't lag when shooting, this way events are instant
		if (!bDontFakelag)
			if (g_Vars.globals.m_bOldShot) {
				*m_movement_data->m_pSendPacket = true;
			}

		Interfaces::AntiAimbot::Get()->Main(m_movement_data->m_pSendPacket, m_movement_data->m_pFinalPacket, m_movement_data->m_pCmd, g_Vars.globals.bInRagebot);

		g_Vars.globals.m_StoredAngle = m_movement_data->m_pCmd->viewangles;

		Interfaces::KnifeBot::Get()->Main(m_movement_data->m_pCmd, m_movement_data->m_pSendPacket);
		Interfaces::ZeusBot::Get()->Main(m_movement_data->m_pCmd, m_movement_data->m_pSendPacket);
		g_Vars.globals.m_bInCreateMove = false;
	}

	void C_Movement::PostPrediction() {
		if (!m_movement_data->m_pLocal)
			return;

		if (!m_movement_data->m_pCmd.IsValid())
			return;

		//	m_movement_data->m_pCmd->forwardmove = Math::Clamp( m_movement_data->m_pCmd->forwardmove, -g_Vars.cl_forwardspeed->GetFloat( ), g_Vars.cl_forwardspeed->GetFloat( ) );
		//	m_movement_data->m_pCmd->sidemove = Math::Clamp( m_movement_data->m_pCmd->sidemove, -g_Vars.cl_sidespeed->GetFloat( ), g_Vars.cl_sidespeed->GetFloat( ) );
		//	m_movement_data->m_pCmd->upmove = Math::Clamp( m_movement_data->m_pCmd->upmove, -g_Vars.cl_upspeed->GetFloat( ), g_Vars.cl_upspeed->GetFloat( ) );
		m_movement_data->m_pCmd->viewangles.Normalize();
		m_movement_data->m_pCmd->viewangles.Clamp();

		float delta_x = std::remainderf(m_movement_data->m_pCmd->viewangles.x - m_movement_data->m_angPreviousAngles.x, 360.0f);
		float delta_y = std::remainderf(m_movement_data->m_pCmd->viewangles.y - m_movement_data->m_angPreviousAngles.y, 360.0f);

		if (delta_x != 0.0f) {
			float mouse_y = -((delta_x / g_Vars.m_pitch->GetFloat()) / g_Vars.sensitivity->GetFloat());
			short mousedy;
			if (mouse_y <= 32767.0f) {
				if (mouse_y >= -32768.0f) {
					if (mouse_y >= 1.0f || mouse_y < 0.0f) {
						if (mouse_y <= -1.0f || mouse_y > 0.0f)
							mousedy = static_cast<short>(mouse_y);
						else
							mousedy = -1;
					}
					else {
						mousedy = 1;
					}
				}
				else {
					mousedy = 0x8000u;
				}
			}
			else {
				mousedy = 0x7FFF;
			}

			m_movement_data->m_pCmd->mousedy = mousedy;
		}

		if (delta_y != 0.0f) {
			float mouse_x = -((delta_y / g_Vars.m_yaw->GetFloat()) / g_Vars.sensitivity->GetFloat());
			short mousedx;
			if (mouse_x <= 32767.0f) {
				if (mouse_x >= -32768.0f) {
					if (mouse_x >= 1.0f || mouse_x < 0.0f) {
						if (mouse_x <= -1.0f || mouse_x > 0.0f)
							mousedx = static_cast<short>(mouse_x);
						else
							mousedx = -1;
					}
					else {
						mousedx = 1;
					}
				}
				else {
					mousedx = 0x8000u;
				}
			}
			else {
				mousedx = 0x7FFF;
			}

			m_movement_data->m_pCmd->mousedx = mousedx;
		}

		RotateMovement(m_movement_data->m_pCmd, m_movement_data->m_angRenderViewangles, m_movement_data->m_pCmd->viewangles);

		m_movement_data->m_angPreviousAngles = m_movement_data->m_pCmd->viewangles;
	}

	bool C_Movement::AdjustVelocity() {


		bool m_between_shots = true;
		bool m_force_accuracy = false;

		auto pLocal = C_CSPlayer::GetLocalPlayer();
		C_WeaponCSBaseGun* Weapon = (C_WeaponCSBaseGun*)m_movement_data->m_pLocal->m_hActiveWeapon().Get();
		auto weaponInfo = Weapon->GetCSWeaponData();
		auto m_weapon_id = Weapon->m_iItemDefinitionIndex();
		bool not_auto = m_weapon_id == WEAPON_REVOLVER || m_weapon_id == WEAPON_AWP || m_weapon_id == WEAPON_SSG08 || m_weapon_id == WEAPON_ZEUS || weaponInfo->m_iWeaponType == WEAPONTYPE_SHOTGUN;


		if (g_Vars.globals.Fakewalking)
			return true;

		if ((!m_between_shots && !pLocal->CanShoot()) || (not_auto && !pLocal->CanShoot()))
			return false;

		if (!(pLocal->m_fFlags() & FL_ONGROUND) || (pLocal->m_fFlags() & IN_JUMP))
			return false;

		if ((pLocal->m_fFlags() & FL_ONGROUND))
			InstantStop();

		return false;


		QAngle angle;
		Math::VectorAngles(pLocal->m_vecVelocity(), angle);

		float speed = pLocal->m_vecVelocity().Length();

		angle.y = m_movement_data->m_pCmd->viewangles.y - angle.y;

		Vector direction;
		Math::AngleVectors(angle, &direction);

		Vector stop = direction * -speed;
		if ((pLocal->m_fFlags() & FL_ONGROUND)) {
			if (g_Vars.globals.m_speed > 10.f) {
				m_movement_data->m_pCmd->forwardmove = stop.x;
				m_movement_data->m_pCmd->sidemove = stop.y * 5;
			}
			else {
				m_movement_data->m_pCmd->forwardmove = 0.f;
				m_movement_data->m_pCmd->sidemove = 0.f;
			}
		}

		/*

		float percentage = 0.22;


		if (not_auto || !m_between_shots) {

			QAngle angle;
			Math::VectorAngles(pLocal->m_vecVelocity(), angle);

			float speed = pLocal->m_vecVelocity().Length2D();

			angle.y = m_movement_data->m_pCmd->viewangles.y - angle.y;

			Vector direction;
			Math::AngleVectors(angle, &direction);

			Vector stop = direction * -speed;

			if (g_Vars.globals.m_speed > 0.1f) {
				m_movement_data->m_pCmd->forwardmove = stop.x;
				m_movement_data->m_pCmd->sidemove = stop.y;
			}
			else {
				m_movement_data->m_pCmd->forwardmove = 0.f;
				m_movement_data->m_pCmd->sidemove = 0.f;
			}

			return true;
		}


		float v4 = percentage * (pLocal->m_bIsScoped() ? weaponInfo->m_flMaxSpeed2 : weaponInfo->m_flMaxSpeed);

		if (g_Vars.globals.m_vecUnpredictedVel.Length() < v4) {

			float squirt2 = std::sqrtf((m_movement_data->m_pCmd->forwardmove * m_movement_data->m_pCmd->forwardmove) + (m_movement_data->m_pCmd->sidemove * m_movement_data->m_pCmd->sidemove));

			float cock1 = m_movement_data->m_pCmd->forwardmove / squirt2;
			float cock2 = m_movement_data->m_pCmd->sidemove / squirt2;

			auto Velocity = pLocal->m_vecVelocity().Length();

			if (v4 + 1.0 <= Velocity) {
				m_movement_data->m_pCmd->forwardmove = 0;
				m_movement_data->m_pCmd->sidemove = 0;
			}
			else {
				m_movement_data->m_pCmd->forwardmove = cock1 * v4;
				m_movement_data->m_pCmd->sidemove = cock2 * v4;
			}
		}
		else
		{
			QAngle angle;
			Math::VectorAngles(pLocal->m_vecVelocity(), angle);

			float speed = pLocal->m_vecVelocity().Length();

			angle.y = m_movement_data->m_pCmd->viewangles.y - angle.y;

			Vector direction;
			Math::AngleVectors(angle, &direction);

			Vector stop = direction * -speed;

			m_movement_data->m_pCmd->forwardmove = stop.x;
			m_movement_data->m_pCmd->sidemove = stop.y;

			// onetap
			if (m_force_accuracy)
				return false;
		}

		return true;*/
	}

	void C_Movement::InstantStop(CUserCmd* cmd) {
		float maxSpeed = m_movement_data->m_pLocal->GetMaxSpeed();
		Vector velocity = m_movement_data->m_pLocal->m_vecVelocity();
		velocity.z = 0.0f;

		CUserCmd* ucmd = cmd ? cmd : m_movement_data->m_pCmd.Xor();

		float speed = velocity.Length2D();


		auto pLocal = C_CSPlayer::GetLocalPlayer();
		C_WeaponCSBaseGun* Weapon = (C_WeaponCSBaseGun*)m_movement_data->m_pLocal->m_hActiveWeapon().Get();
		auto weaponInfo = Weapon->GetCSWeaponData();
		auto m_weapon_id = Weapon->m_iItemDefinitionIndex();
		bool not_auto = m_weapon_id == WEAPON_REVOLVER || m_weapon_id == WEAPON_AWP || m_weapon_id == WEAPON_SSG08 || m_weapon_id == WEAPON_ZEUS || weaponInfo->m_iWeaponType == WEAPONTYPE_SHOTGUN;


		static int playerSurfaceFrictionOffset = SDK::Memory::FindInDataMap(m_movement_data->m_pLocal->GetPredDescMap(), XorStr("m_surfaceFriction"));
		float playerSurfaceFriction = *(float*)(uintptr_t(m_movement_data->m_pLocal) + playerSurfaceFrictionOffset);
		float max_accelspeed = g_Vars.sv_accelerate->GetFloat() * Interfaces::m_pGlobalVars->interval_per_tick * maxSpeed * playerSurfaceFriction;

		float shit_stopithinkmb = -1.f;

		if (!not_auto && !g_Vars.globals.Fakewalking) {
			if (speed < maxSpeed * 0.29)
				return;
		}
		else if (velocity.Length() < 10.f)
			return;



		if (speed - max_accelspeed <= -1.f) {
			m_movement_data->m_bStopPlayer = 0;
			ucmd->forwardmove = speed / max_accelspeed;
		}
		else {
			ucmd->forwardmove = g_Vars.cl_forwardspeed->GetFloat();
		}

		ucmd->sidemove = 0.0f;

		QAngle move_dir = m_movement_data->m_angMovementAngle;

		float direction = atan2(velocity.y, velocity.x);
		move_dir.yaw = std::remainderf(ToDegrees(direction) + 180.0f, 360.0f);
		RotateMovement(ucmd, move_dir, ucmd->viewangles);

	}

	bool C_Movement::AutoStopInternal() {
		return false;
	}

	void C_Movement::AutoJump() {
		if (m_movement_data->m_pLocal->m_MoveType() == MOVETYPE_LADDER || m_movement_data->m_pLocal->m_MoveType() == MOVETYPE_NOCLIP)
			return;

		if (g_Vars.rage.enabled) {
			if (!(m_movement_data->m_pLocal->m_fFlags() & FL_ONGROUND)) {
				m_movement_data->m_pCmd->buttons &= ~IN_JUMP;
			}
			return;
		}

		if (!m_movement_data->jumped_last_tick && m_movement_data->should_fake_jump) {
			m_movement_data->should_fake_jump = false;
			m_movement_data->m_pCmd->buttons |= IN_JUMP;
		}
		else if (m_movement_data->m_pCmd->buttons & IN_JUMP) {
			if (m_movement_data->m_pLocal->m_fFlags() & FL_ONGROUND) {
				m_movement_data->jumped_last_tick = true;
				m_movement_data->should_fake_jump = true;
			}
			else {
				m_movement_data->m_pCmd->buttons &= ~IN_JUMP;
				m_movement_data->jumped_last_tick = false;
			}
		}
		else {
			m_movement_data->jumped_last_tick = false;
			m_movement_data->should_fake_jump = false;
		}
	}

	void C_Movement::AutoStrafe() {
		if ((m_movement_data->m_pLocal->m_fFlags() & FL_ONGROUND) && !(m_movement_data->m_pCmd->buttons & IN_JUMP))
			return;

		if (m_movement_data->m_pLocal->m_MoveType() != MOVETYPE_WALK || m_movement_data->m_pLocal->m_MoveType() == MOVETYPE_NOCLIP || m_movement_data->m_pLocal->m_MoveType() == MOVETYPE_LADDER)
			return;

		if (g_Vars.misc.slow_walk && g_Vars.misc.slow_walk_bind.enabled)
			return;

		static auto side = 1.0f;
		side = -side;

		auto velocity = m_movement_data->m_pLocal->m_vecVelocity();
		velocity.z = 0.0f;

		auto speed = velocity.Length2D();
		auto ideal_strafe = Math::Clamp(ToDegrees(atan(15.f / speed)), 0.0f, 90.0f);

		if (g_Vars.misc.autostrafer_wasd && (m_movement_data->m_pCmd->forwardmove != 0.0f || m_movement_data->m_pCmd->sidemove != 0.0f)) {
			// took this idea from exon, thank u !!!!
			enum EDirections {
				FORWARDS = 0,
				BACKWARDS = 180,
				LEFT = 90,
				RIGHT = -90,
				BACK_LEFT = 135,
				BACK_RIGHT = -135
			};

			float wish_dir{ };

			// get our key presses.
			bool holding_w = m_movement_data->m_pCmd->buttons & IN_FORWARD;
			bool holding_a = m_movement_data->m_pCmd->buttons & IN_MOVELEFT;
			bool holding_s = m_movement_data->m_pCmd->buttons & IN_BACK;
			bool holding_d = m_movement_data->m_pCmd->buttons & IN_MOVERIGHT;

			// move in the appropriate direction.
			if (holding_w) {
				//	forward left
				if (holding_a) {
					wish_dir += (EDirections::LEFT / 2);
				}
				//	forward right
				else if (holding_d) {
					wish_dir += (EDirections::RIGHT / 2);
				}
				//	forward
				else {
					wish_dir += EDirections::FORWARDS;
				}
			}
			else if (holding_s) {
				//	back left
				if (holding_a) {
					wish_dir += EDirections::BACK_LEFT;
				}
				//	back right
				else if (holding_d) {
					wish_dir += EDirections::BACK_RIGHT;
				}
				//	back
				else {
					wish_dir += EDirections::BACKWARDS;
				}

				// cancel out any forwardmove values.
				m_movement_data->m_pCmd->forwardmove = 0.f;
			}
			else if (holding_a) {
				//	left
				wish_dir += EDirections::LEFT;
			}
			else if (holding_d) {
				//	right
				wish_dir += EDirections::RIGHT;
			}

			m_movement_data->m_angMovementAngle.yaw += std::remainderf(wish_dir, 360.f);

			m_movement_data->m_pCmd->sidemove = 0.f;
		}

		// cancel out any forwardmove values.
		m_movement_data->m_pCmd->forwardmove = 0.f;

		auto yaw_delta = std::remainderf(m_movement_data->m_angMovementAngle.yaw - m_movement_data->m_flOldYaw, 360.0f);
		auto abs_angle_delta = abs(yaw_delta);
		m_movement_data->m_flOldYaw = m_movement_data->m_angMovementAngle.yaw;

		if (abs_angle_delta <= ideal_strafe || abs_angle_delta >= 30.0f) {
			auto velocity_direction = velocity.ToEulerAngles();
			auto velocity_delta = std::remainderf(m_movement_data->m_angMovementAngle.yaw - velocity_direction.yaw, 360.0f);
			if (velocity_delta <= ideal_strafe || speed <= 15.0f) {
				if (-(ideal_strafe) <= velocity_delta || speed <= 15.0f) {
					m_movement_data->m_angMovementAngle.yaw += side * ideal_strafe;
					m_movement_data->m_pCmd->sidemove = 450 * side;
				}
				else {
					m_movement_data->m_angMovementAngle.yaw = velocity_direction.yaw - ideal_strafe;
					m_movement_data->m_pCmd->sidemove = 450;
				}
			}
			else {
				m_movement_data->m_angMovementAngle.yaw = velocity_direction.yaw + ideal_strafe;
				m_movement_data->m_pCmd->sidemove = -450;
			}
		}
		else if (yaw_delta > 0.0f) {
			m_movement_data->m_pCmd->sidemove = -450;
		}
		else if (yaw_delta < 0.0f) {
			m_movement_data->m_pCmd->sidemove = 450;
		}

		m_movement_data->m_angMovementAngle.Normalize();
	}

	void C_Movement::SlowWalk(Encrypted_t<CUserCmd> cmd) 
	{
		Vector velocity{ m_movement_data->m_pLocal->m_vecVelocity() };
		int    ticks{ }, max{ 14 };

		auto pLocal = C_CSPlayer::GetLocalPlayer();

		if (!pLocal || pLocal->IsDead())
			return;

		if (!(g_Vars.misc.slow_walk && g_Vars.misc.slow_walk_bind.enabled))
			return;

		static auto sv_friction = Interfaces::m_pCvar->FindVar(XorStr("sv_friction"));
		static auto sv_stopspeed = Interfaces::m_pCvar->FindVar(XorStr("sv_stopspeed"));
		static int playerSurfaceFrictionOffset = SDK::Memory::FindInDataMap(m_movement_data->m_pLocal->GetPredDescMap(), XorStr("m_surfaceFriction"));
		float playerSurfaceFriction = *(float*)(uintptr_t(m_movement_data->m_pLocal) + playerSurfaceFrictionOffset);

		// calculate friction.
		float friction = sv_friction->GetFloat() * playerSurfaceFriction;

		int m_max_lag = (pLocal->m_fFlags() & FL_ONGROUND) ? 14 : 13;

		for (; ticks < m_max_lag; ++ticks) {
			// calculate speed.
			float speed = velocity.Length();

			// if too slow return.
			if (speed <= 0.1f)
				break;

			// bleed off some speed, but if we have less than the bleed, threshold, bleed the threshold amount.
			float control = std::max(speed, sv_stopspeed->GetFloat());

			// calculate the drop amount.
			float drop = control * friction * Interfaces::m_pGlobalVars->interval_per_tick;

			// scale the velocity.
			float newspeed = std::max(0.f, speed - drop);

			if (newspeed != speed) {
				// determine proportion of old speed we are using.
				newspeed /= speed;

				// adjust velocity according to proportion.
				velocity *= newspeed;
			}
		}

		// zero forwardmove and sidemove.
		if (ticks > ((max - 1) - Interfaces::m_pClientState->m_nChokedCommands()) || !Interfaces::m_pClientState->m_nChokedCommands()) {
			cmd->forwardmove = cmd->sidemove = 0.f;
		}
	}

	void C_Movement::ThirdPerson() {
		if (!m_movement_data->m_pLocal)
			return;

		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local || local != m_movement_data->m_pLocal)
			return;

		// for whatever reason overrideview also gets called from the main menu.
		if (!Interfaces::m_pEngine->IsInGame())
			return;

		// check if we have a local player and he is alive.
		bool alive = !local->IsDead();

		static bool bThirdPerson = false;

		if (alive) {
			C_WeaponCSBaseGun* Weapon = (C_WeaponCSBaseGun*)m_movement_data->m_pLocal->m_hActiveWeapon().Get();

			if (!Weapon)
				return;

			auto weaponInfo = Weapon->GetCSWeaponData();
			if (!weaponInfo.IsValid())
				return;

			if (weaponInfo->m_iWeaponType == WEAPONTYPE_GRENADE && g_Vars.misc.third_person_on_grenade) {
				Interfaces::m_pInput->CAM_ToFirstPerson();
				Interfaces::m_pInput->m_fCameraInThirdPerson = false;
				return;
			}
		}

		// camera should be in thirdperson.
		if (g_Vars.misc.third_person && g_Vars.misc.third_person_bind.enabled) {

			// if alive and not in thirdperson already switch to thirdperson.
			if (alive && !Interfaces::m_pInput->CAM_IsThirdPerson()) {
				Interfaces::m_pInput->CAM_ToThirdPerson();
			}
			// fix the dogshit spectate bug.
			if (!alive)
			{
				g_Vars.misc.third_person_bind.enabled = false;
				Interfaces::m_pInput->m_fCameraInThirdPerson = false;
			}
			// if dead and spectating in thirdperson switch to firstperson.
			else if (m_movement_data->m_pLocal->m_iObserverMode() == 4) {

				// if in thirdperson, switch to firstperson.
				// we need to disable thirdperson to spectate properly.
				if (Interfaces::m_pInput->CAM_IsThirdPerson()) {
					Interfaces::m_pInput->CAM_ToFirstPerson();
				}

				m_movement_data->m_pLocal->m_iObserverMode() = 5;
			}
		}
		// camera should be in firstperson.
		else {
			Interfaces::m_pInput->CAM_ToFirstPerson();
		}

		// if after all of this we are still in thirdperson.
		if (Interfaces::m_pInput->CAM_IsThirdPerson()) {
			// get camera angles.
			QAngle offset;
			Interfaces::m_pEngine->GetViewAngles(offset);

			// get our viewangle's forward directional vector.
			Vector forward;
			Math::AngleVectors(offset, forward);

			offset.z = g_Vars.misc.third_person_dist;

			Vector offsetd = m_movement_data->m_pLocal->m_vecViewOffset();

			// start pos.
			Vector origin = m_movement_data->m_pLocal->GetAbsOrigin() + offsetd;

			// setup trace filter and trace.
			CTraceFilterWorldAndPropsOnly filter;
			CGameTrace tr;

			Interfaces::m_pEngineTrace->TraceRay(
				Ray_t(origin, origin - (forward * offset.z), { -16.f, -16.f, -16.f }, { 16.f, 16.f, 16.f }),
				MASK_NPCWORLDSTATIC,
				(ITraceFilter*)&filter,
				&tr
			);

			// adapt distance to travel time.
			Math::Clamp(tr.fraction, 0.f, 1.f);
			offset.z *= tr.fraction;

			// override camera angles.
			Interfaces::m_pInput->m_vecCameraOffset = { offset.x, offset.y, offset.z };

			m_movement_data->m_pLocal->UpdateVisibilityAllEntities();
		}
	}

	void C_Movement::AutoStop(int ticks) {
		m_movement_data->m_bStopPlayer = ticks;
	}

	bool C_Movement::GetStopState() {
		return m_movement_data->m_bStopOk;
	}

	bool C_Movement::CreateMoveRecursion() {
		if (!m_movement_data->m_bInRecursion || m_movement_data->m_iRecursionTicks <= 0) {
			m_movement_data->m_bInRecursion = false;
			m_movement_data->m_iRecursionTicks = 0;
			return false;
		}

		m_movement_data->m_iRecursionTicks--;
		return true;
	}

	void C_Movement::MoveExploit() {
		static bool bDisallow = false;
		static bool bSaveOrigin = true;

		if (!g_Vars.misc.move_exploit) {
			g_Vars.globals.vecExploitOrigin.Init();
			bDisallow = false;
			bSaveOrigin = true;
			g_Vars.globals.bMoveExploiting = false;
			return;
		}

		if (!g_Vars.misc.move_exploit_key.enabled) {
			g_Vars.globals.vecExploitOrigin.Init();
			bDisallow = false;
			bSaveOrigin = true;
			g_Vars.globals.bMoveExploiting = false;
			return;
		}

		if (m_movement_data->m_pLocal->m_vecVelocity().Length2D() < m_movement_data->m_pLocal->GetMaxSpeed() - 20.f) {
			g_Vars.globals.vecExploitOrigin.Init();
			g_Vars.globals.bMoveExploiting = false;
			bSaveOrigin = true;
			return;
		}

		if (Interfaces::m_pClientState->m_nChokedCommands() < 100) {
			if (!bDisallow) {
				*m_movement_data->m_pSendPacket = false;
				g_Vars.globals.bMoveExploiting = true;
			}

			if (bSaveOrigin) {
				g_Vars.globals.vecExploitOrigin = m_movement_data->m_pLocal->GetEyePosition() + (m_movement_data->m_pLocal->m_vecVelocity() * 100 * Interfaces::m_pGlobalVars->interval_per_tick);
				bSaveOrigin = false;
			}
		}
		else {
			bSaveOrigin = true;
			g_Vars.globals.bMoveExploiting = false;
		}
	}
}
```

`CSGO SDK/Features/Miscellaneous/Movement.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

class CCSGOPlayerAnimState;

class C_SimulationData {
public:
	Vector m_vecVeloctity;
	Vector m_vecOrigin;

	int m_iFlags;

	bool m_bJumped;

	C_CSPlayer* m_player;
};

extern void RotateMovement(Encrypted_t<CUserCmd> cmd, QAngle wish_angle, QAngle old_angles);
extern void SimulateMovement(C_SimulationData& data);
extern void ExtrapolatePlayer(C_SimulationData& data, int ticks, const Vector& wishvel, float wishspeed, float maxSpeed);

class C_AnimationLayer;
namespace Interfaces
{
	class __declspec(novtable) Movement : public NonCopyable {
	public:
		static Movement* Get();
		virtual void PrePrediction(Encrypted_t<CUserCmd> cmd, C_CSPlayer* pLocal, bool* pSendPacket, bool* bFinalPacket, uintptr_t* cl_move) = 0;
		virtual void InPrediction() = 0;
		virtual void PostPrediction() = 0;
		virtual void ThirdPerson() = 0;
		virtual float GetLBYUpdateTime() = 0;
		virtual int GetButtons() = 0;
		virtual QAngle& GetMovementAngle() = 0;
		virtual bool StopPlayer() = 0;
		virtual bool GetStopState() = 0;
		virtual void StopPlayerAtMinimalSpeed() = 0;
		virtual bool CreateMoveRecursion() = 0;
		virtual void AutoStop(int ticks = 1) = 0;
		virtual void InstantStop(CUserCmd* cmd = nullptr) = 0;
		virtual bool AdjustVelocity() = 0;
		virtual void MoveExploit() = 0;
	protected:
		Movement() { };
		virtual ~Movement() { };
	};
}

```

`CSGO SDK/Features/Miscellaneous/SkinChanger.cpp`:

```cpp
#include "SkinChanger.hpp"
#include "../../SDK/CVariables.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "../../SDK/Classes/player.hpp"
#include "../../SDK/Valve/CBaseHandle.hpp"
#include "KitParser.hpp"
#include "../../SDK/Classes/PropManager.hpp"
#include <algorithm>
#include <memory.h>
#include "../../SDK/Valve/recv_swap.hpp"
#include "../../Utils/FnvHash.hpp"
#include "../../SDK/displacement.hpp"

static auto is_knife(const int i) -> bool {
	return (i >= WEAPON_KNIFE_BAYONET && i < GLOVE_STUDDED_BLOODHOUND) || i == WEAPON_KNIFE_T || i == WEAPON_KNIFE_CT;
}

static CHandle< C_BaseCombatWeapon > glove_handle{ };

class CSkinChanger : public ISkinChanger {
public:
	void Create() override;
	void Destroy() override;
	void OnNetworkUpdate(bool start = true) override;
private:
	void PostDataUpdateStart(C_CSPlayer* local);
	void EraseOverrideIfExistsByIndex(const int definition_index);
	void ApplyConfigOnAttributableItem(C_BaseAttributableItem* item, CVariables::skin_changer_data* config, const unsigned xuid_low);
	void GloveChanger(C_CSPlayer* local);
	static void SequenceProxyFn(CRecvProxyData* proxy_data_const, void* entity, void* output);
	void DoSequenceRemapping(CRecvProxyData* data, C_BaseViewModel* entity);
	int GetNewAnimation(const uint32_t model, const int sequence, C_BaseViewModel* viewModel);
	CVariables::skin_changer_data* GetDataFromIndex(int idx);
	void ForceItemUpdate(C_CSPlayer* local);
	void UpdateHud();

	std::unordered_map< std::string_view, std::string_view > m_icon_overrides;
	RecvPropHook::Shared m_sequence_hook = nullptr;

	float lastSkinUpdate = 0.0f;
	float lastGloveUpdate = 0.0f;
};

ISkinChanger* ISkinChanger::Get() {
	static CSkinChanger instance;
	return &instance;
}

void CSkinChanger::Create() {
	auto& pPropManager = Engine::PropManager::Instance();

	RecvProp* prop = nullptr;
	pPropManager->GetProp(XorStr("DT_BaseViewModel"), XorStr("m_nSequence"), &prop);
	m_sequence_hook = std::make_shared<RecvPropHook>(prop, &SequenceProxyFn);
}

void CSkinChanger::Destroy() {
	m_sequence_hook->Unhook();
	m_sequence_hook.reset();
}

void CSkinChanger::OnNetworkUpdate(bool start) {
	auto& global = g_Vars.m_global_skin_changer;

	auto local = C_CSPlayer::GetLocalPlayer();
	if (!local)
		return;

	if (!start) {
		if (global.m_update_skins && !global.m_update_gloves) {
			float meme = Interfaces::m_pGlobalVars->realtime - lastSkinUpdate;
			if (!local->IsDead() && meme >= 0.65f) {
				lastSkinUpdate = Interfaces::m_pGlobalVars->realtime - 0.125f;
			}
			else if (meme >= 0.2f) {
				ForceItemUpdate(local);
				global.m_update_skins = false;
				lastSkinUpdate = Interfaces::m_pGlobalVars->realtime;
			}
		}

		if ((!global.m_active || !global.m_glove_changer) || global.m_update_gloves) {
			auto glove = glove_handle.Get();
			if (glove) {
				auto networkable = glove->GetClientNetworkable();
				if (networkable) {
					networkable->SetDestroyedOnRecreateEntities();
					networkable->Release();
				}

				glove_handle.Set(nullptr);
			}

			const auto glove_config = GetDataFromIndex(global.m_gloves_idx);
			if ((global.m_update_gloves && Interfaces::m_pGlobalVars->realtime - lastGloveUpdate >= 0.5f) || (glove_config && !glove_config->m_enabled && glove_config->m_executed)) {
				//Interfaces::m_pClientState->m_nDeltaTick( ) = -1;
				if (global.m_update_gloves)
					lastGloveUpdate = Interfaces::m_pGlobalVars->realtime;

				global.m_update_gloves = false;

				if (glove_config)
					glove_config->m_executed = false;
			}
		}
		else if (local && global.m_glove_changer) {
			GloveChanger(local);
		}
		return;
	}

	if (!global.m_active)
		return;

	PostDataUpdateStart(local);
}

void CSkinChanger::PostDataUpdateStart(C_CSPlayer* local) {
	if (!local)
		return;

	const auto local_index = local->EntIndex();

	player_info_t player_info;
	if (!Interfaces::m_pEngine->GetPlayerInfo(local_index, &player_info))
		return;

	auto& global = g_Vars.m_global_skin_changer;

	// Handle weapon configs
	{
		auto weapons = local->m_hMyWeapons();
		for (int i = 0; i < 48; ++i) {
			auto weapon = (C_BaseAttributableItem*)weapons[i].Get();
			if (!weapon)
				continue;

			auto& definition_index = weapon->m_Item().m_iItemDefinitionIndex();

			auto idx = is_knife(definition_index) ? global.m_knife_idx : definition_index;
			const auto active_conf = GetDataFromIndex(idx);
			if (active_conf) {
				if ((!active_conf->m_enabled || !global.m_active) && active_conf->m_executed)
					global.m_update_skins = true;

				ApplyConfigOnAttributableItem(weapon, active_conf, player_info.xuid_low);
			}
			else {
				EraseOverrideIfExistsByIndex(definition_index);
			}
		}
	}
	const auto view_model = (C_BaseViewModel*)local->m_hViewModel().Get();
	if (!view_model)
		return;

	const auto view_model_weapon = (C_BaseAttributableItem*)view_model->m_hWeapon().Get();
	if (!view_model_weapon)
		return;

	auto idx = view_model_weapon->m_Item().m_iItemDefinitionIndex();
	if (k_weapon_info.count(idx) > 0) {
		const auto override_info = k_weapon_info.at(idx);
		const auto override_model_index = Interfaces::m_pModelInfo->GetModelIndex(override_info.model);
		view_model->m_nModelIndex() = override_model_index;

		const auto world_model = view_model_weapon->m_hWeaponWorldModel().Get();
		if (world_model)
			world_model->m_nModelIndex() = override_model_index + 1;
	}
}

void CSkinChanger::EraseOverrideIfExistsByIndex(const int definition_index) {
	if (k_weapon_info.count(definition_index) <= 0)
		return;

	// We have info about the item not needed to be overridden
	const auto& original_item = k_weapon_info.at(definition_index);
	auto& icon_override_map = m_icon_overrides;

	if (!original_item.icon)
		return;

	const auto override_entry = icon_override_map.find(original_item.icon);

	// We are overriding its icon when not needed
	if (override_entry != end(icon_override_map))
		icon_override_map.erase(override_entry); // Remove the leftover override
}

void CSkinChanger::ApplyConfigOnAttributableItem(C_BaseAttributableItem* attribute, CVariables::skin_changer_data* config, const unsigned xuid_low) {
	if (!attribute)
		return;

	auto& item = attribute->m_Item();
	auto& global = g_Vars.m_global_skin_changer;

	// Force fallback values to be used.
	item.m_iItemIDHigh() = -1;

	// Set the owner of the weapon to our lower XUID. (fixes StatTrak)
	item.m_iAccountID() = xuid_low;

	item.m_nFallbackPaintKit() = config->m_filter_paint_kits ? config->m_paint_kit : skin_kits[config->m_paint_kit_no_filter].id;

	item.m_nFallbackSeed() = int(config->m_seed);

	item.m_iEntityQuality() = 0;

	if (int(config->m_stat_trak)) {
		item.m_nFallbackStatTrak() = int(config->m_stat_trak);

		item.m_iEntityQuality() = 9;
	}

	item.m_flFallbackWear() = config->m_wear;

	auto& definition_index = item.m_iItemDefinitionIndex();

	auto& icon_override_map = m_icon_overrides;

	bool knife = is_knife(definition_index);

	int definition_override = 0;

	if (knife) {
		definition_override = global.m_knife_idx;

		item.m_iEntityQuality() = 3;
	}
	else if (config->m_definition_index >= GLOVE_STUDDED_BLOODHOUND && config->m_definition_index <= GLOVE_SPECIALIST)
		definition_override = global.m_gloves_idx;

	if (definition_override && definition_override != definition_index) // We need to override defindex
	{
		// We have info about what we gonna override it to
		if (k_weapon_info.count(definition_override) > 0) {
			const auto replacement_item = &k_weapon_info.at(definition_override);

			const auto old_definition_index = definition_index;

			item.m_iItemDefinitionIndex() = definition_override;

			// Set the weapon model index -- required for paint kits to work on replacement items after the 29/11/2016 update.
			auto idx = Interfaces::m_pModelInfo->GetModelIndex(replacement_item->model);
			attribute->SetModelIndex(idx);

			auto networkable = attribute->GetClientNetworkable();
			if (networkable) {
				networkable->PreDataUpdate(0);
			}

			// We didn't override 0, but some actual weapon, that we have data for
			if (old_definition_index) {
				if (k_weapon_info.count(old_definition_index) > 0) {
					const auto original_item = &k_weapon_info.at(old_definition_index);
					if (original_item->icon && replacement_item->icon)
						icon_override_map[original_item->icon] = replacement_item->icon;
				}
			}
		}
	}
	else {
		EraseOverrideIfExistsByIndex(definition_index);
	}

	config->m_executed = false;
}

void CSkinChanger::GloveChanger(C_CSPlayer* local) {
	if (!local)
		return;

	return;

	const auto local_index = local->EntIndex();

	player_info_t player_info;
	if (!Interfaces::m_pEngine->GetPlayerInfo(local_index, &player_info))
		return;

	auto& global = g_Vars.m_global_skin_changer;

	// Handle glove config
	{
		const auto wearables = local->m_hMyWearables();

		const auto glove_config = GetDataFromIndex(global.m_gloves_idx);

		if (!glove_config || global.m_gloves_idx == 0 || !wearables) {
			return;
		}

		auto glove = (C_BaseAttributableItem*)wearables[0].Get();

		if (!glove) {
			// Try to get our last created glove
			const auto our_glove = (C_BaseAttributableItem*)glove_handle.Get();
			if (our_glove) // Our glove still exists
			{
				wearables[0] = glove_handle;
				glove = our_glove;
			}
		}

		if (local->IsDead()) {
			// We are dead but we have a glove, destroy it
			if (glove) {
				auto networkable = glove->GetClientNetworkable();
				if (networkable) {
					networkable->SetDestroyedOnRecreateEntities();
					networkable->Release();
				}
			}

			return;
		}

		// We don't have a glove, but we should
		bool just_created = false;

		if (!glove) {
			auto get_wearable_create_fn = []() -> CreateClientClassFn {
				auto clazz = Interfaces::m_pClient->GetAllClasses();
				//	while( clazz->m_ClassID != CEconWearable )
				//		clazz = clazz->m_pNext;

				return (CreateClientClassFn)clazz->m_pCreateFn;
			};

			static auto create_wearable_fn = get_wearable_create_fn();

			const auto entry = Interfaces::m_pEntList->GetHighestEntityIndex() + 1;
			const auto serial = rand() % 0x1000;
			create_wearable_fn(entry, serial);

			glove = static_cast<C_BaseAttributableItem*>(Interfaces::m_pEntList->GetClientEntity(entry));

			if (!glove)
				return;

			Vector new_pos = Vector{ 10000.0f, 10000.0f, 10000.f };
			glove->SetAbsOrigin(new_pos);

			wearables[0] = CBaseHandle(entry | (serial << 16));

			// Let's store it in case we somehow lose it.
			glove_handle = wearables[0];

			just_created = true;
		}

		glove_config->m_executed = true;
		if (glove) {
			// Thanks, Beakers
			*(int*)((uintptr_t)glove + 0x64) = -1;
			// *( int* ) ( ( uintptr_t ) local + 0xA20 ) = 1; // remove default arms in 3th person mode dword_15268230 = (int)"m_nBody";
			ApplyConfigOnAttributableItem(glove, glove_config, player_info.xuid_low);
		}
	}
}

void CSkinChanger::SequenceProxyFn(CRecvProxyData* proxy_data_const, void* entity, void* output) {
	auto skins = (CSkinChanger*)Get();
	if (skins && skins->m_sequence_hook) {
		auto original_fn = skins->m_sequence_hook->GetOriginalFunction();

		// Remove the constness from the proxy data allowing us to make changes.
		const auto proxy_data = const_cast<CRecvProxyData*>(proxy_data_const);

		const auto view_model = static_cast<C_BaseViewModel*>(entity);

		skins->DoSequenceRemapping(proxy_data, view_model);

		// Call the original function with our edited data.
		original_fn(proxy_data_const, entity, output);
	}
}

void CSkinChanger::DoSequenceRemapping(CRecvProxyData* data, C_BaseViewModel* entity) {
	auto local = C_CSPlayer::GetLocalPlayer();
	if (!local || local->IsDead())
		return;

	const auto owner = entity->m_hOwner().Get();
	if (owner != local)
		return;

	const auto view_model_weapon = entity->m_hWeapon().Get();
	if (!view_model_weapon)
		return;

	auto idx = view_model_weapon->m_Item().m_iItemDefinitionIndex();
	if (k_weapon_info.count(idx) <= 0)
		return;

	const auto weapon_info = &k_weapon_info.at(idx);

	if (weapon_info) {
		const auto override_model = weapon_info->model;

		auto& sequence = data->m_Value.m_Int;
		sequence = GetNewAnimation(hash_32_fnv1a_const(override_model), sequence, entity);
	}
}

int CSkinChanger::GetNewAnimation(const uint32_t model, const int sequence, C_BaseViewModel* viewModel) {

	// This only fixes if the original knife was a default knife.
	// The best would be having a function that converts original knife's sequence
	// into some generic enum, then another function that generates a sequence
	// from the sequences of the new knife. I won't write that.
	enum ESequence {
		SEQUENCE_DEFAULT_DRAW = 0,
		SEQUENCE_DEFAULT_IDLE1 = 1,
		SEQUENCE_DEFAULT_IDLE2 = 2,
		SEQUENCE_DEFAULT_LIGHT_MISS1 = 3,
		SEQUENCE_DEFAULT_LIGHT_MISS2 = 4,
		SEQUENCE_DEFAULT_HEAVY_MISS1 = 9,
		SEQUENCE_DEFAULT_HEAVY_HIT1 = 10,
		SEQUENCE_DEFAULT_HEAVY_BACKSTAB = 11,
		SEQUENCE_DEFAULT_LOOKAT01 = 12,

		SEQUENCE_BUTTERFLY_DRAW = 0,
		SEQUENCE_BUTTERFLY_DRAW2 = 1,
		SEQUENCE_BUTTERFLY_LOOKAT01 = 13,
		SEQUENCE_BUTTERFLY_LOOKAT03 = 15,

		SEQUENCE_FALCHION_IDLE1 = 1,
		SEQUENCE_FALCHION_HEAVY_MISS1 = 8,
		SEQUENCE_FALCHION_HEAVY_MISS1_NOFLIP = 9,
		SEQUENCE_FALCHION_LOOKAT01 = 12,
		SEQUENCE_FALCHION_LOOKAT02 = 13,

		SEQUENCE_DAGGERS_IDLE1 = 1,
		SEQUENCE_DAGGERS_LIGHT_MISS1 = 2,
		SEQUENCE_DAGGERS_LIGHT_MISS5 = 6,
		SEQUENCE_DAGGERS_HEAVY_MISS2 = 11,
		SEQUENCE_DAGGERS_HEAVY_MISS1 = 12,

		SEQUENCE_BOWIE_IDLE1 = 1,
	};

	auto random_sequence = [](const int low, const int high) -> int {
		return rand() % (high - low + 1) + low;
	};

	// Hashes for best performance.
	switch (model) {
	case hash_32_fnv1a_const(("models/weapons/v_knife_butterfly.mdl")):
	{
		switch (sequence) {
		case SEQUENCE_DEFAULT_DRAW:
			return random_sequence(SEQUENCE_BUTTERFLY_DRAW, SEQUENCE_BUTTERFLY_DRAW2);
		case SEQUENCE_DEFAULT_LOOKAT01:
			return random_sequence(SEQUENCE_BUTTERFLY_LOOKAT01, SEQUENCE_BUTTERFLY_LOOKAT03);
		default:
			return sequence + 1;
		}
	}
	case hash_32_fnv1a_const(("models/weapons/v_knife_falchion_advanced.mdl")):
	{
		switch (sequence) {
		case SEQUENCE_DEFAULT_IDLE2:
			return SEQUENCE_FALCHION_IDLE1;
		case SEQUENCE_DEFAULT_HEAVY_MISS1:
			return random_sequence(SEQUENCE_FALCHION_HEAVY_MISS1, SEQUENCE_FALCHION_HEAVY_MISS1_NOFLIP);
		case SEQUENCE_DEFAULT_LOOKAT01:
			return random_sequence(SEQUENCE_FALCHION_LOOKAT01, SEQUENCE_FALCHION_LOOKAT02);
		case SEQUENCE_DEFAULT_DRAW:
		case SEQUENCE_DEFAULT_IDLE1:
			return sequence;
		default:
			return sequence - 1;
		}
	}
	case hash_32_fnv1a_const(("models/weapons/v_knife_push.mdl")):
	{
		switch (sequence) {
		case SEQUENCE_DEFAULT_IDLE2:
			return SEQUENCE_DAGGERS_IDLE1;
		case SEQUENCE_DEFAULT_LIGHT_MISS1:
		case SEQUENCE_DEFAULT_LIGHT_MISS2:
			return random_sequence(SEQUENCE_DAGGERS_LIGHT_MISS1, SEQUENCE_DAGGERS_LIGHT_MISS5);
		case SEQUENCE_DEFAULT_HEAVY_MISS1:
			return random_sequence(SEQUENCE_DAGGERS_HEAVY_MISS2, SEQUENCE_DAGGERS_HEAVY_MISS1);
		case SEQUENCE_DEFAULT_HEAVY_HIT1:
		case SEQUENCE_DEFAULT_HEAVY_BACKSTAB:
		case SEQUENCE_DEFAULT_LOOKAT01:
			return sequence + 3;
		case SEQUENCE_DEFAULT_DRAW:
		case SEQUENCE_DEFAULT_IDLE1:
			return sequence;
		default:
			return sequence + 2;
		}
	}
	case hash_32_fnv1a_const(("models/weapons/v_knife_survival_bowie.mdl")):
	{
		switch (sequence) {
		case SEQUENCE_DEFAULT_DRAW:
		case SEQUENCE_DEFAULT_IDLE1:
			return sequence;
		case SEQUENCE_DEFAULT_IDLE2:
			return SEQUENCE_BOWIE_IDLE1;
		default:
			return sequence - 1;
		}
	}
	case hash_32_fnv1a_const(("models/weapons/v_knife_ursus.mdl")):
	case hash_32_fnv1a_const(("models/weapons/v_knife_skeleton.mdl")):
	case hash_32_fnv1a_const(("models/weapons/v_knife_outdoor.mdl")):
	case hash_32_fnv1a_const(("models/weapons/v_knife_canis.mdl")):
	case hash_32_fnv1a_const(("models/weapons/v_knife_cord.mdl")):
	{
		switch (sequence) {
		case SEQUENCE_DEFAULT_DRAW:
			return random_sequence(SEQUENCE_BUTTERFLY_DRAW, SEQUENCE_BUTTERFLY_DRAW2);
		case SEQUENCE_DEFAULT_LOOKAT01:
			return random_sequence(SEQUENCE_BUTTERFLY_LOOKAT01, 14);
		default:
			return sequence + 1;
		}
	}
	case hash_32_fnv1a_const(("models/weapons/v_knife_stiletto.mdl")):
	{
		switch (sequence) {
		case SEQUENCE_DEFAULT_LOOKAT01:
			return random_sequence(12, 13);
		}
	}
	case hash_32_fnv1a_const(("models/weapons/v_knife_widowmaker.mdl")):
	{
		switch (sequence) {
		case SEQUENCE_DEFAULT_LOOKAT01:
			return random_sequence(14, 15);
		}
	}

	default:
		return sequence;
	}
}

CVariables::skin_changer_data* CSkinChanger::GetDataFromIndex(int idx) {
	auto& skin_data = g_Vars.m_skin_changer;
	for (size_t i = 0; i < skin_data.Size(); ++i) {
		auto skin = skin_data[i];
		if (skin->m_definition_index == idx)
			return skin;
	}
	return nullptr;
}

void CSkinChanger::ForceItemUpdate(C_CSPlayer* local) {
	if (!local || local->IsDead())
		return;

	auto ForceUpdate = [](C_BaseCombatWeapon* item) {
		C_EconItemView* view = &item->m_Item();

		if (!view)
			return;

		if (!item->GetClientNetworkable())
			return;

		auto clearRefCountedVector = [](CUtlVector< IRefCounted* >& vec) {
			for (int i = 0; i < vec.m_Size; ++i) {
				auto& elem = vec.m_Memory.m_pMemory[i];
				if (elem) {
					elem->unreference();
					elem = nullptr;
				}
			}
			vec.m_Size = 0;
		};

		auto clearCustomMaterials = [](CUtlVector< IRefCounted* >& vec) {
			for (int i = 0; i < vec.m_Size; ++i) {
				auto& element = vec.m_Memory.m_pMemory[i];
				// actually makes no sense
				*(int*)(((uintptr_t)element) + 0x10) = 0;
				*(int*)(((uintptr_t)element) + 0x18) = 0;
				*(int*)(((uintptr_t)element) + 0x20) = 0;
				*(int*)(((uintptr_t)element) + 0x24) = 0;
				vec.m_Memory.m_pMemory[i] = nullptr;
			}

			vec.m_Size = 0;
		};

		item->m_bCustomMaterialInitialized() = false;
		clearCustomMaterials(item->m_CustomMaterials());
		clearCustomMaterials(view->m_CustomMaterials());
		clearRefCountedVector(view->m_VisualsDataProcessors());

		item->GetClientNetworkable()->PostDataUpdate(0);
		item->GetClientNetworkable()->OnDataChanged(0);
	};

	auto& global = g_Vars.m_global_skin_changer;
	auto weapons = local->m_hMyWeapons();
	for (size_t i = 0; i < 48; ++i) {
		auto weapon_handle = weapons[i];
		if (!weapon_handle.IsValid())
			break;

		auto weapon = (C_BaseCombatWeapon*)weapon_handle.Get();
		if (!weapon)
			continue;

		auto definition_index = weapon->m_Item().m_iItemDefinitionIndex();
		if (const auto active_conf = GetDataFromIndex(is_knife(definition_index) ? global.m_knife_idx : definition_index)) {
			UpdateHud();
			ForceUpdate(weapon);
		}
	}
}

void CSkinChanger::UpdateHud() {
	/*if( Engine::Displacement.Function.m_uClearHudWeaponIcon ) {
		static auto clear_hud_weapon_icon_fn =
			reinterpret_cast< std::int32_t( __thiscall* )( void*, std::int32_t ) >( ( Engine::Displacement.Function.m_uClearHudWeaponIcon ) );
		auto element = FindHudElement<std::uintptr_t*>( ( XorStr( "CCSGO_HudWeaponSelection" ) ) );

		if( element && clear_hud_weapon_icon_fn ) {
			auto hud_weapons = reinterpret_cast< hud_weapons_t* >( std::uintptr_t( element ) - 0xA0 );
			if( hud_weapons == nullptr )
				return;

			if( !*hud_weapons->get_weapon_count( ) )
				return;

			for( std::int32_t i = 0; i < *hud_weapons->get_weapon_count( ) - 1; i++ )
				i = clear_hud_weapon_icon_fn( hud_weapons, i );
		}
	}*/

}

```

`CSGO SDK/Features/Miscellaneous/SkinChanger.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

class __declspec(novtable) ISkinChanger : public NonCopyable {
public:
	static ISkinChanger* Get();
	virtual void Create() = NULL;
	virtual void Destroy() = NULL;
	virtual void OnNetworkUpdate(bool start = true) = NULL;
protected:
	ISkinChanger() { };
	virtual ~ISkinChanger() { };
};

```

`CSGO SDK/Features/Miscellaneous/VisibilityOptimization.cpp`:

```cpp
#include "VisibilityOptimization.hpp"
#include "../../source.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../Renderer/Render.hpp"

// TODO: move this to qangle
float AngleDistance(QAngle& angles, const Vector& start, const Vector& end) {
	auto direction = end - start;
	direction.Normalize();

	auto forward = angles.ToVectors();
	auto dot = forward.Dot(direction);

	return ToDegrees(std::acos(dot));
}

namespace Engine
{
	class C_VisibilityOptimization : public VisibilityOptimization {
	public:
		C_VisibilityOptimization() { }
		virtual ~C_VisibilityOptimization() { }

		virtual void Update(CViewSetup* view); // call on overrideview
	};

	VisibilityOptimization* VisibilityOptimization::Get() {
		static C_VisibilityOptimization instance;
		return &instance;
	}

	void C_VisibilityOptimization::Update(CViewSetup* view) {
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local)
			return;

		auto display = Render::GetScreenSize();
		auto ratio = display.x / display.y;
		auto screen_fov = ToDegrees(atanf((ratio) * (0.75f) * tan(ToRadians(view->fov * 0.5f))));

		for (int i = 1; i <= Interfaces::m_pGlobalVars->maxClients; ++i) {
			auto player = C_CSPlayer::GetPlayerByIndex(i);
			if (player == local)
				continue;

			if (!player || player->IsDormant() || player->IsDead())
				continue;

			Vector min, max;
			if (!player->ComputeHitboxSurroundingBox(min, max))
				continue;

			Vector points[] =
			{
			   Vector(min.x, min.y, min.z),
			   Vector(min.x, max.y, min.z),
			   Vector(max.x, max.y, min.z),
			   Vector(max.x, min.y, min.z),
			   Vector(max.x, max.y, max.z),
			   Vector(min.x, max.y, max.z),
			   Vector(min.x, min.y, max.z),
			   Vector(max.x, min.y, max.z)
			};

			float min_fov = std::numeric_limits<float>::max();
			for (int i = 0; i < 8; ++i) {
				float fov = AngleDistance(view->angles, view->origin, points[i]);
				if (min_fov > fov)
					min_fov = fov;
			}

			player->m_bShouldDraw() = min_fov <= screen_fov;
		}
	}
}

```

`CSGO SDK/Features/Miscellaneous/VisibilityOptimization.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

namespace Engine
{
	class __declspec(novtable) VisibilityOptimization : public NonCopyable {
	public:
		static VisibilityOptimization* Get();
		virtual void Update(CViewSetup* view) = 0; // call on overrideview
	};

}
```

`CSGO SDK/Features/Miscellaneous/WeatherController.cpp`:

```cpp
#include "WeatherController.hpp"
#include "../../source.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../Renderer/Render.hpp"

namespace Engine
{
	class C_WeatherController : public WeatherController {
	public:
		C_WeatherController() { }
		virtual ~C_WeatherController() { }

		virtual void ResetWeather();
		virtual void UpdateWeather(); // call on overrideview
	};

	WeatherController* WeatherController::Get() {
		static C_WeatherController instance;
		return &instance;
	}

	void C_WeatherController::ResetWeather() {
		if (!g_Vars.globals.bCreatedRain) {
			return;
		}


		for (int i = 0; i <= Interfaces::m_pEntList->GetHighestEntityIndex(); i++) {
			C_BaseEntity* pEntity = (C_BaseEntity*)Interfaces::m_pEntList->GetClientEntity(i);
			if (!pEntity)
				continue;

			const ClientClass* pClientClass = pEntity->GetClientClass();
			if (!pClientClass)
				continue;

			if (pClientClass->m_ClassID == ClassId_t::CPrecipitation) {
				if (pEntity->GetClientNetworkable())
					pEntity->GetClientNetworkable()->Release();
			}
		}
	}

	void C_WeatherController::UpdateWeather() {
		if (!g_Vars.esp.weather) {
			return;
		}

		if (g_Vars.globals.bCreatedRain) {
			return;
		}

		static ClientClass* pPrecipitation = nullptr;
		if (!pPrecipitation) {
			for (auto pClientClass = Interfaces::m_pClient->GetAllClasses(); pClientClass && !pPrecipitation; pClientClass = pClientClass->m_pNext) {
				if (pClientClass->m_ClassID == ClassId_t::CPrecipitation) {
					pPrecipitation = pClientClass;
				}
			}
		}

		if (pPrecipitation && pPrecipitation->m_pCreateFn) {
			IClientNetworkable* pRainNetworkable = ((IClientNetworkable * (*)(int, int))pPrecipitation->m_pCreateFn)(MAX_EDICTS - 1, 0);
			if (!pRainNetworkable) {
				return;
			}

			IClientUnknown* pRainUnknown = ((IClientRenderable*)pRainNetworkable)->GetIClientUnknown();
			if (!pRainUnknown) {
				return;
			}

			C_BaseEntity* pRainEnt = pRainUnknown->GetBaseEntity();
			if (!pRainEnt) {
				return;
			}

			if (!pRainEnt->GetClientNetworkable()) {
				return;
			}

			pRainNetworkable->PreDataUpdate(0);
			pRainNetworkable->OnPreDataChanged(0);

			// null da callbacks
			if (g_Vars.r_RainRadius->fnChangeCallback.m_Size != 0)
				g_Vars.r_RainRadius->fnChangeCallback.m_Size = 0;

			// limit the render distance of da rain
			if (g_Vars.r_RainRadius->GetFloat() != 1000.f)
				g_Vars.r_RainRadius->SetValueFloat(1000.f);

			// only PRECIPITATION_TYPE_RAIN and PRECIPITATION_TYPE_SNOW work..?
			pRainEnt->m_nPrecipType() = PrecipitationType_t::PRECIPITATION_TYPE_SNOW;
			pRainEnt->OBBMins() = Vector(-32768.0f, -32768.0f, -32768.0f);
			pRainEnt->OBBMaxs() = Vector(32768.0f, 32768.0f, 32768.0f);

			pRainEnt->GetClientNetworkable()->OnDataChanged(0);
			pRainEnt->GetClientNetworkable()->PostDataUpdate(0);

			g_Vars.globals.bCreatedRain = true;
		}
	}
}
```

`CSGO SDK/Features/Miscellaneous/WeatherController.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

namespace Engine {
	class __declspec(novtable) WeatherController : public NonCopyable {
	public:
		static WeatherController* Get();
		virtual void ResetWeather() = 0;
		virtual void UpdateWeather() = 0;
	};
}
```

`CSGO SDK/Features/Rage/AnimationSystem.cpp`:

```cpp
#include "AnimationSystem.hpp"
#include "../../SDK/displacement.hpp"
#include "../../Utils/Math.h"
#include "../Game/SetupBones.hpp"
#include "../../Utils/Threading/threading.h"
#include "LagCompensation.hpp"
#include "Resolver.hpp"

#define MT_SETUP_BONES

namespace Engine
{
	struct SimulationRestore {
		int m_fFlags;
		float m_flDuckAmount;
		float m_flFeetCycle;
		float m_flFeetYawRate;
		QAngle m_angEyeAngles;
		Vector m_vecOrigin;

		void Setup(C_CSPlayer* player) {
			m_fFlags = player->m_fFlags();
			m_flDuckAmount = player->m_flDuckAmount();
			m_vecOrigin = player->m_vecOrigin();
			m_angEyeAngles = player->m_angEyeAngles();

			auto animState = player->m_PlayerAnimState();
			m_flFeetCycle = animState->m_flFeetCycle;
			m_flFeetYawRate = animState->m_flFeetYawRate;
		}

		void Apply(C_CSPlayer* player) const {
			player->m_fFlags() = m_fFlags;
			player->m_flDuckAmount() = m_flDuckAmount;
			player->m_vecOrigin() = m_vecOrigin;
			player->m_angEyeAngles() = m_angEyeAngles;

			auto animState = player->m_PlayerAnimState();
			animState->m_flFeetCycle = m_flFeetCycle;
			animState->m_flFeetYawRate = m_flFeetYawRate;
		}
	};

	struct AnimationBackup {

		CCSGOPlayerAnimState anim_state;
		C_AnimationLayer layers[13];
		float pose_params[19];

		AnimationBackup() {

		}

		void Apply(C_CSPlayer* player) const;
		void Setup(C_CSPlayer* player);
	};

	void AnimationBackup::Apply(C_CSPlayer* player) const {
		*player->m_PlayerAnimState() = this->anim_state;
		std::memcpy(player->m_AnimOverlay().m_Memory.m_pMemory, layers, sizeof(layers));
		std::memcpy(player->m_flPoseParameter(), pose_params, sizeof(pose_params));
	}

	void AnimationBackup::Setup(C_CSPlayer* player) {
		this->anim_state = *player->m_PlayerAnimState();
		std::memcpy(layers, player->m_AnimOverlay().m_Memory.m_pMemory, sizeof(layers));
		std::memcpy(pose_params, player->m_flPoseParameter(), sizeof(pose_params));
	}

	inline void FixBonesRotations(C_CSPlayer* player, matrix3x4_t* bones) {
		// copypasted from supremacy/fatality, no difference imo
		// also seen that in aimware multipoints, but was lazy to paste, kek
		auto studio_hdr = player->m_pStudioHdr();
		if (studio_hdr) {
			auto hdr = *(studiohdr_t**)studio_hdr;
			if (hdr) {
				auto hitboxSet = hdr->pHitboxSet(player->m_nHitboxSet());
				for (int i = 0; i < hitboxSet->numhitboxes; i++) {
					auto hitbox = hitboxSet->pHitbox(i);
					if (hitbox->m_angAngles.IsZero())
						continue;

					matrix3x4_t hitboxTransform;
					hitboxTransform.AngleMatrix(hitbox->m_angAngles);
					bones[hitbox->bone] = bones[hitbox->bone].ConcatTransforms(hitboxTransform);
				}
			}
		}
	}

	class C_AnimationSystem : public AnimationSystem {
	public:
		virtual void CollectData();
		virtual void Update();

		virtual C_AnimationData* GetAnimationData(int index) {
			if (m_AnimatedEntities.count(index) < 1)
				return nullptr;

			return &m_AnimatedEntities[index];
		}

		std::map<int, C_AnimationData> m_AnimatedEntities = { };

		C_AnimationSystem() { };
		virtual ~C_AnimationSystem() { };
	};

	Encrypted_t<AnimationSystem> AnimationSystem::Get() {
		static C_AnimationSystem instance;
		return &instance;
	}

	void C_AnimationSystem::CollectData() {
		if (!Interfaces::m_pEngine->IsInGame() || !Interfaces::m_pEngine->GetNetChannelInfo()) {
			this->m_AnimatedEntities.clear();
			return;
		}

		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local || !g_Vars.globals.HackIsReady)
			return;

		for (int i = 1; i <= Interfaces::m_pGlobalVars->maxClients; ++i) {
			auto player = C_CSPlayer::GetPlayerByIndex(i);
			if (!player || player == local)
				continue;

			player_info_t player_info;
			if (!Interfaces::m_pEngine->GetPlayerInfo(player->m_entIndex, &player_info)) {
				continue;
			}

			this->m_AnimatedEntities[i].Collect(player);
		}
	}

	void C_AnimationSystem::Update() {
		if (!Interfaces::m_pEngine->IsInGame() || !Interfaces::m_pEngine->GetNetChannelInfo()) {
			this->m_AnimatedEntities.clear();
			return;
		}

		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local || !g_Vars.globals.HackIsReady)
			return;

		for (auto& [key, value] : this->m_AnimatedEntities) {
			auto entity = C_CSPlayer::GetPlayerByIndex(key);
			if (!entity)
				continue;

			auto curtime = Interfaces::m_pGlobalVars->curtime;
			auto frametime = Interfaces::m_pGlobalVars->frametime;

			Interfaces::m_pGlobalVars->curtime = entity->m_flOldSimulationTime() + Interfaces::m_pGlobalVars->interval_per_tick;
			Interfaces::m_pGlobalVars->frametime = Interfaces::m_pGlobalVars->interval_per_tick;

			if (value.m_bUpdated)
				value.Update();

			Interfaces::m_pGlobalVars->curtime = curtime;
			Interfaces::m_pGlobalVars->frametime = frametime;

			value.m_bUpdated = false;
		}

	}

	void C_AnimationData::Update() {
		if (!this->player || this->m_AnimationRecord.size() < 1)
			return;

		C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer();
		if (!pLocal)
			return;

		auto pAnimationRecord = Encrypted_t<Engine::C_AnimationRecord>(&this->m_AnimationRecord.front());
		Encrypted_t<Engine::C_AnimationRecord> pPreviousAnimationRecord(nullptr);
		if (this->m_AnimationRecord.size() > 1) {
			pPreviousAnimationRecord = &this->m_AnimationRecord.at(1);
		}

		this->player->m_vecVelocity() = pAnimationRecord->m_vecAnimationVelocity;

		auto weapon = (C_BaseAttributableItem*)player->m_hActiveWeapon().Get();
		auto weaponWorldModel = weapon ? (C_CSPlayer*)(weapon)->m_hWeaponWorldModel().Get() : nullptr;

		auto animState = player->m_PlayerAnimState();
		if (!animState)
			return;

		// simulate animations
		SimulateAnimations(pAnimationRecord, pPreviousAnimationRecord);

		// update layers
		std::memcpy(player->m_AnimOverlay().Base(), pAnimationRecord->m_serverAnimOverlays, 13 * sizeof(C_AnimationLayer));

		// generate aimbot matrix
		g_BoneSetup.SetupBonesRebuild(player, m_Bones, 128, BONE_USED_BY_ANYTHING & ~BONE_USED_BY_BONE_MERGE, player->m_flSimulationTime(), BoneSetupFlags::UseCustomOutput);

		// generate visual matrix
		g_BoneSetup.SetupBonesRebuild(player, nullptr, 128, 0x7FF00, player->m_flSimulationTime(), BoneSetupFlags::ForceInvalidateBoneCache | BoneSetupFlags::AttachmentHelper);

		this->m_vecSimulationData.clear();
	}

	void C_AnimationData::Collect(C_CSPlayer* player) {
		if (player->IsDead())
			player = nullptr;

		auto pThis = Encrypted_t<C_AnimationData>(this);

		if (pThis->player != player) {
			pThis->m_flSpawnTime = 0.0f;
			pThis->m_flSimulationTime = 0.0f;
			pThis->m_flOldSimulationTime = 0.0f;
			pThis->m_iCurrentTickCount = 0;
			pThis->m_iOldTickCount = 0;
			pThis->m_iTicksAfterDormancy = 0;
			pThis->m_vecSimulationData.clear();
			pThis->m_AnimationRecord.clear();
			pThis->m_bIsDormant = pThis->m_bBonesCalculated = false;
			pThis->player = player;
			pThis->m_bIsAlive = false;
		}

		if (!player)
			return;

		pThis->m_bIsAlive = true;
		pThis->m_flOldSimulationTime = pThis->m_flSimulationTime;
		pThis->m_flSimulationTime = pThis->player->m_flSimulationTime();

		if (pThis->m_flSimulationTime == 0.0f || pThis->player->IsDormant()) {
			pThis->m_bIsDormant = true;
			Engine::g_ResolverData[player->EntIndex()].m_bWentDormant = true;
			Engine::g_ResolverData[player->EntIndex()].m_sMoveData.m_flSimulationTime = 0.f;
			Engine::g_ResolverData[player->EntIndex()].m_vecSavedOrigin = pThis->m_vecOrigin;
			return;
		}

		if (pThis->m_flOldSimulationTime == pThis->m_flSimulationTime) {
			return;
		}

		if (pThis->m_bIsDormant) {
			pThis->m_iTicksAfterDormancy = 0;
			pThis->m_AnimationRecord.clear();

			Engine::g_ResolverData[player->EntIndex()].m_sMoveData.m_flSimulationTime = 0.f;
			Engine::g_ResolverData[player->EntIndex()].m_bWentDormant = true;
		}

		pThis->ent_index = player->m_entIndex;

		pThis->m_bUpdated = true;
		pThis->m_bIsDormant = false;

		pThis->m_iOldTickCount = pThis->m_iCurrentTickCount;
		pThis->m_iCurrentTickCount = Interfaces::m_pGlobalVars->tickcount;

		if (pThis->m_flSpawnTime != pThis->player->m_flSpawnTime()) {
			auto animState = pThis->player->m_PlayerAnimState();
			if (animState) {
				animState->m_Player = pThis->player;
				animState->Reset();
			}

			pThis->m_flSpawnTime = pThis->player->m_flSpawnTime();
		}

		int nTickRate = int(1.0f / Interfaces::m_pGlobalVars->interval_per_tick);

		while (pThis->m_AnimationRecord.size() > 256) {
			pThis->m_AnimationRecord.pop_back();
		}

		pThis->m_iTicksAfterDormancy++;

		Encrypted_t<C_AnimationRecord> previous_record = nullptr;
		Encrypted_t<C_AnimationRecord> penultimate_record = nullptr;

		if (pThis->m_AnimationRecord.size() > 0) {
			previous_record = &pThis->m_AnimationRecord.front();
			if (pThis->m_AnimationRecord.size() > 1) {
				penultimate_record = &pThis->m_AnimationRecord.at(1);
			}
		}

		auto record = &pThis->m_AnimationRecord.emplace_front();

		pThis->m_vecOrigin = pThis->player->m_vecOrigin();

		record->m_vecOrigin = pThis->player->m_vecOrigin();
		record->m_angEyeAngles = pThis->player->m_angEyeAngles();
		record->m_flSimulationTime = pThis->m_flSimulationTime;
		record->m_flLowerBodyYawTarget = pThis->player->m_flLowerBodyYawTarget();

		auto weapon = (C_WeaponCSBaseGun*)(player->m_hActiveWeapon().Get());

		if (weapon) {
			auto weaponWorldModel = (C_CSPlayer*)((C_BaseAttributableItem*)weapon)->m_hWeaponWorldModel().Get();

			for (int i = 0; i < player->m_AnimOverlay().Count(); ++i) {
				player->m_AnimOverlay().Element(i).m_pOwner = player;
				player->m_AnimOverlay().Element(i).m_pStudioHdr = player->m_pStudioHdr();

				if (weaponWorldModel) {
					if (player->m_AnimOverlay().Element(i).m_nSequence < 2 || player->m_AnimOverlay().Element(i).m_flWeight <= 0.0f)
						continue;

					using UpdateDispatchLayer = void(__thiscall*)(void*, C_AnimationLayer*, CStudioHdr*, int);
					Memory::VCall< UpdateDispatchLayer >(player, 241)(player, &player->m_AnimOverlay().Element(i),
						weaponWorldModel->m_pStudioHdr(), player->m_AnimOverlay().Element(i).m_nSequence);
				}
			}
		}

		std::memcpy(record->m_serverAnimOverlays, pThis->player->m_AnimOverlay().Base(), sizeof(record->m_serverAnimOverlays));

		record->m_flFeetCycle = record->m_serverAnimOverlays[6].m_flCycle;
		record->m_flFeetYawRate = record->m_serverAnimOverlays[6].m_flWeight;

		record->m_fFlags = player->m_fFlags();
		record->m_flDuckAmount = player->m_flDuckAmount();

		record->m_bIsShooting = false;
		record->m_flShotTime = 0.0f;
		record->m_bFakeWalking = false;
		record->m_bFakeFlicking = false;

		if (previous_record.IsValid()) {
			record->m_flChokeTime = pThis->m_flSimulationTime - pThis->m_flOldSimulationTime;
			record->m_iChokeTicks = TIME_TO_TICKS(record->m_flChokeTime);
		}
		else {
			record->m_flChokeTime = Interfaces::m_pGlobalVars->interval_per_tick;
			record->m_iChokeTicks = 1;
		}

		if (!previous_record.IsValid()) {
			record->m_bIsInvalid = true;
			record->m_vecVelocity.Init();
			record->m_bIsShooting = false;
			record->m_bTeleportDistance = false;

			//auto animstate = player->m_PlayerAnimState( );
			//if( animstate )
			//	animstate->m_flAbsRotation = record->m_angEyeAngles.yaw;

			return;
		}
		/*auto flPreviousSimulationTime = previous_record->m_flSimulationTime;
		auto nTickcountDelta = pThis->m_iCurrentTickCount - pThis->m_iOldTickCount;
		auto nSimTicksDelta = record->m_iChokeTicks;
		auto nChokedTicksUnk = nSimTicksDelta;
		auto bShiftedTickbase = false;

		if (pThis->m_flOldSimulationTime > pThis->m_flSimulationTime) {
			record->m_bShiftingTickbase = true;
			record->m_iChokeTicks = nTickcountDelta;
			record->m_flChokeTime = TICKS_TO_TIME(record->m_iChokeTicks);
			flPreviousSimulationTime = record->m_flSimulationTime - record->m_flChokeTime;
			nChokedTicksUnk = nTickcountDelta;
			bShiftedTickbase = true;
		}

		if (bShiftedTickbase || abs(nSimTicksDelta - nTickcountDelta) <= 2) {
			if (nChokedTicksUnk) {
				if (nChokedTicksUnk != 1) {
					pThis->m_iTicksUnknown = 0;
				}
				else {
					pThis->m_iTicksUnknown++;
				}
			}
			else {
				record->m_iChokeTicks = 1;
				record->m_flChokeTime = Interfaces::m_pGlobalVars->interval_per_tick;

				flPreviousSimulationTime = record->m_flSimulationTime - Interfaces::m_pGlobalVars->interval_per_tick;

				pThis->m_iTicksUnknown++;
			}
		}
		*/

		if (weapon) {
			record->m_flShotTime = weapon->m_fLastShotTime();
			record->m_bIsShooting = TIME_TO_TICKS(weapon->m_fLastShotTime()) >= TIME_TO_TICKS(record->m_flSimulationTime) - 1;
		}

		record->m_bIsInvalid = false;

		// fix velocity
		// https://github.com/VSES/SourceEngine2007/blob/master/se2007/game/client/c_baseplayer.cpp#L659
		if (record->m_iChokeTicks > 0 && record->m_iChokeTicks <= 16 && pThis->m_AnimationRecord.size() >= 2) {
			record->m_vecVelocity = (record->m_vecOrigin - previous_record->m_vecOrigin) * (1.f / record->m_flChokeTime);
		}

		// fix CGameMovement::FinishGravity
		if (!(player->m_fFlags() & FL_ONGROUND))
			record->m_vecVelocity.z -= TICKS_TO_TIME(g_Vars.sv_gravity->GetFloat());
		else
			record->m_vecVelocity.z = 0.0f;

		record->m_vecAnimationVelocity = record->m_vecVelocity;

		if (record->m_bFakeWalking) {
			record->m_vecAnimationVelocity.Init();
		}

		// delta in time..
		float time = record->m_flSimulationTime - previous_record->m_flSimulationTime;

		if (!record->m_bFakeWalking) {
			// fix the velocity till the moment of animation.
			Vector velo = record->m_vecVelocity - previous_record->m_vecVelocity;

			// accel per tick.
			Vector accel = (velo / time) * Interfaces::m_pGlobalVars->interval_per_tick;

			// set the anim velocity to the previous velocity.
			// and predict one tick ahead.
			record->m_vecAnimationVelocity = previous_record->m_vecVelocity + accel;
		}

		record->m_bTeleportDistance = record->m_vecOrigin.DistanceSquared(previous_record->m_vecOrigin) > 4096.0f;

		C_SimulationInfo& data = pThis->m_vecSimulationData.emplace_back();
		data.m_flTime = previous_record->m_flSimulationTime + Interfaces::m_pGlobalVars->interval_per_tick;

		float duck_delta = (record->m_flDuckAmount - previous_record->m_flDuckAmount) / record->m_flChokeTime;

		data.m_flDuckAmount = previous_record->m_flDuckAmount + duck_delta;
		data.m_flLowerBodyYawTarget = record->m_flLowerBodyYawTarget;
		data.m_vecOrigin = record->m_vecOrigin;
		data.m_vecVelocity = record->m_vecAnimationVelocity;
		data.bOnGround = record->m_fFlags & FL_ONGROUND;

		// lets check if they are choking ticks.
		if (record->m_iChokeTicks > 1) {
			// TODO: calculate jump time
			// calculate landing time
			float flLandTime = 0.0f;
			bool bJumped = false;
			bool bLandedOnServer = false;
			if (record->m_serverAnimOverlays[4].m_flCycle < 0.5f && (!(record->m_fFlags & FL_ONGROUND) || !(previous_record->m_fFlags & FL_ONGROUND))) {
				// note - VIO (violations btw);
				// well i guess when llama wrote v3, he was drunk or sum cuz this is incorrect. -> cuz he changed this in v4.
				// and alpha didn't realize this but i did, so its fine.
				// improper way to do this -> flLandTime = record->m_flSimulationTime - float( record->m_serverAnimOverlays[ 4 ].m_flPlaybackRate * record->m_serverAnimOverlays[ 4 ].m_flCycle );
				// we need to divide instead of multiply.
				flLandTime = record->m_flSimulationTime - float(record->m_serverAnimOverlays[4].m_flPlaybackRate / record->m_serverAnimOverlays[4].m_flCycle);
				bLandedOnServer = flLandTime >= previous_record->m_flSimulationTime;
			}

			bool bOnGround = record->m_fFlags & FL_ONGROUND;
			// jump_fall fix
			if (bLandedOnServer && !bJumped) {
				if (flLandTime <= data.m_flTime) {
					bJumped = true;
					bOnGround = true;
				}
				else {
					bOnGround = previous_record->m_fFlags & FL_ONGROUND;
				}
			}

			/* ot v4 */
			if ((record->m_fFlags & FL_ONGROUND)
				&& (previous_record->m_fFlags & FL_ONGROUND)) {
				if (player->m_AnimOverlay()[6].m_flPlaybackRate == 0.f)
					record->m_vecAnimationVelocity = {};
				else {
					if (record->m_serverAnimOverlays[11].m_nSequence == previous_record->m_serverAnimOverlays[11].m_nSequence) {
						if (record->m_serverAnimOverlays[11].m_flWeight > 0.f && record->m_serverAnimOverlays[11].m_flWeight < 1.f) {
							const auto speed_2d = record->m_vecAnimationVelocity.Length2D();
							C_WeaponCSBaseGun* weapon = (C_WeaponCSBaseGun*)player->m_hActiveWeapon().Get();

							float max_speed = weapon ? weapon->GetMaxSpeed() : 260.f;

							if (weapon) {
								if (speed_2d) {
									const auto reversed_val = (1.f - record->m_serverAnimOverlays[11].m_flWeight) * 0.35f;

									if (reversed_val > 0.f && reversed_val < 1.f) {
										const auto speed_as_portion_of_run_top_speed = ((reversed_val + 0.55f) * max_speed) / speed_2d;
										if (speed_as_portion_of_run_top_speed) {
											record->m_vecAnimationVelocity.x *= speed_as_portion_of_run_top_speed;
											record->m_vecAnimationVelocity.y *= speed_as_portion_of_run_top_speed;
										}
									}
								}
							}
						}
					}
				}
			}

			data.bOnGround = bOnGround;

			// detect fakewalking players
			if (record->m_vecVelocity.Length() > 0.1f
				&& record->m_iChokeTicks >= 13
				&& record->m_serverAnimOverlays[6].m_flWeight == 0.0f
				&& record->m_serverAnimOverlays[6].m_flPlaybackRate < 0.0001f
				&& record->m_serverAnimOverlays[12].m_flWeight > 0.0f
				&& (record->m_fFlags & FL_ONGROUND))
				record->m_bFakeWalking = true;

			if (record->m_vecVelocity.Length() > 0.1f && record->m_fFlags & FL_ONGROUND && record->m_serverAnimOverlays[6].m_flWeight == 0.0f && record->m_vecVelocity.Length() < 100.f)
				record->m_bFakeWalking = true;

			if (record->m_bFakeWalking)
				record->m_vecAnimationVelocity = record->m_vecVelocity = { 0.f, 0.f, 0.f };

			// detect fake flicking players
			if (record->m_vecVelocity.Length() < 18.f
				&& record->m_serverAnimOverlays[6].m_flWeight != 1.0f
				&& record->m_serverAnimOverlays[6].m_flWeight != 0.0f
				&& record->m_serverAnimOverlays[6].m_flWeight != previous_record->m_serverAnimOverlays[6].m_flWeight
				&& (record->m_fFlags & FL_ONGROUND))
				record->m_bFakeFlicking = true;

			if (record->m_bFakeFlicking)
				record->m_vecAnimationVelocity = record->m_vecVelocity = { 0.f, 0.f, 0.f };

		}
	}

	void C_AnimationData::SimulateAnimations(Encrypted_t<Engine::C_AnimationRecord> current, Encrypted_t<Engine::C_AnimationRecord> previous) {
		auto UpdateAnimations = [&](C_CSPlayer* player, float flTime) {
			auto curtime = Interfaces::m_pGlobalVars->curtime;
			auto frametime = Interfaces::m_pGlobalVars->frametime;

			// force to use correct abs origin and velocity ( no CalcAbsolutePosition and CalcAbsoluteVelocity calls )
			player->m_iEFlags() &= ~(EFL_DIRTY_ABSTRANSFORM | EFL_DIRTY_ABSVELOCITY);

			int ticks = TIME_TO_TICKS(flTime);

			// calculate animations based on ticks aka server frames instead of render frames
			Interfaces::m_pGlobalVars->curtime = flTime;
			Interfaces::m_pGlobalVars->frametime = Interfaces::m_pGlobalVars->interval_per_tick;

			auto animstate = player->m_PlayerAnimState();
			if (animstate && animstate->m_nLastFrame >= Interfaces::m_pGlobalVars->framecount)
				animstate->m_nLastFrame = Interfaces::m_pGlobalVars->framecount - 1;

			for (int i = 0; i < player->m_AnimOverlay().Count(); ++i) {
				player->m_AnimOverlay().Base()[i].m_pOwner = player;
				player->m_AnimOverlay().Base()[i].m_pStudioHdr = player->m_pStudioHdr();
			}

			static auto& EnableInvalidateBoneCache = **reinterpret_cast<bool**>(Memory::Scan(XorStr("client.dll"), XorStr("C6 05 ? ? ? ? ? 89 47 70")) + 2);

			// make sure we keep track of the original invalidation state
			const auto oldInvalidationState = EnableInvalidateBoneCache;

			// is player bot?
			auto IsPlayerBot = [&]() -> bool {
				player_info_t info;
				if (Interfaces::m_pEngine->GetPlayerInfo(player->EntIndex(), &info))
					return info.fakeplayer;

				return false;
			};	

			auto local = C_CSPlayer::GetLocalPlayer();

			// show teammate lby / enemy lby when spectating
			if ((player->IsTeammate(player) || local->IsDead()) && !IsPlayerBot())
				player->m_angEyeAngles().y = player->m_flLowerBodyYawTarget();

			// attempt to resolve the player	
			if (!player->IsTeammate(C_CSPlayer::GetLocalPlayer()) && !IsPlayerBot()) {

				g_Resolver.ResolveYaw(player, current.Xor());

				g_Resolver.MatchShot(player, current.Xor(), previous.Xor());

				// predict lby updates
				g_Resolver.PredictBodyUpdates(player, current.Xor(), previous.Xor());

				bool bValid = previous.Xor();

				// we're sure that we resolved the player.
				if (bValid) {
					current.Xor()->m_bResolved = current.Xor()->m_iResolverMode == EResolverModes::RESOLVE_NONE || current.Xor()->m_iResolverMode == EResolverModes::RESOLVE_LBY_UPDATE ||
						current.Xor()->m_iResolverMode == EResolverModes::RESOLVE_LBY || current.Xor()->m_iResolverMode == EResolverModes::RESOLVE_WALK;
				}
			}

			player->UpdateClientSideAnimationEx();

			// we don't want to enable cache invalidation by accident
			EnableInvalidateBoneCache = oldInvalidationState;

			Interfaces::m_pGlobalVars->curtime = curtime;
			Interfaces::m_pGlobalVars->frametime = frametime;
		};

		SimulationRestore SimulationRecordBackup;
		SimulationRecordBackup.Setup(player);

		auto animState = player->m_PlayerAnimState();

		if (previous.IsValid()) {
			if (previous->m_bIsInvalid && current->m_fFlags & FL_ONGROUND) {
				animState->m_bOnGround = true;
				animState->m_bHitground = false;
			}

			animState->m_flFeetCycle = previous->m_flFeetCycle;
			animState->m_flFeetYawRate = previous->m_flFeetYawRate;
			*(float*)(uintptr_t(animState) + 0x180) = previous->m_serverAnimOverlays[12].m_flWeight;

			std::memcpy(player->m_AnimOverlay().Base(), previous->m_serverAnimOverlays, sizeof(previous->m_serverAnimOverlays));
		}
		else {
			animState->m_flFeetCycle = current->m_flFeetCycle;
			animState->m_flFeetYawRate = current->m_flFeetYawRate;
			*(float*)(uintptr_t(animState) + 0x180) = current->m_serverAnimOverlays[12].m_flWeight;
		}

		if (current->m_iChokeTicks > 1) {
			for (auto it = this->m_vecSimulationData.begin(); it < this->m_vecSimulationData.end(); it++) {
				m_bForceVelocity = true;
				const auto& simData = *it;
				if (simData.bOnGround) {
					player->m_fFlags() |= FL_ONGROUND;
				}
				else {
					player->m_fFlags() &= ~FL_ONGROUND;
				}

				player->m_vecOrigin() = simData.m_vecOrigin;
				player->m_flDuckAmount() = simData.m_flDuckAmount;
				player->m_vecVelocity() = simData.m_vecVelocity;
				player->SetAbsVelocity(simData.m_vecVelocity);
				player->SetAbsOrigin(simData.m_vecOrigin);
				player->m_flLowerBodyYawTarget() = simData.m_flLowerBodyYawTarget;

				UpdateAnimations(player, player->m_flOldSimulationTime() + Interfaces::m_pGlobalVars->interval_per_tick);

				m_bForceVelocity = false;
			}
		}
		else {
			m_bForceVelocity = true;
			this->player->SetAbsVelocity(current->m_vecAnimationVelocity);
			this->player->SetAbsOrigin(current->m_vecOrigin);
			this->player->m_flLowerBodyYawTarget() = current->m_flLowerBodyYawTarget;

			UpdateAnimations(player, player->m_flOldSimulationTime() + Interfaces::m_pGlobalVars->interval_per_tick);

			m_bForceVelocity = false;
		}

		SimulationRecordBackup.Apply(player);
		player->InvalidatePhysicsRecursive(8);
	}
}
```

`CSGO SDK/Features/Rage/AnimationSystem.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

#include "../../SDK/Classes/Weapon.hpp"
#include "../../SDK/Classes/Player.hpp"

#include <map>
#include <deque>


namespace Engine
{
	class C_SideAnimation {
	public:
		alignas(16) matrix3x4_t m_Bones[128]{ };
		float m_flAbsRotation;

		void Update(C_CSPlayer* player) {
			if (!player)
				return;

			auto animState = player->m_PlayerAnimState();
			if (animState)
				m_flAbsRotation = animState->m_flAbsRotation;
		}
	};

	class C_SimulationInfo {
	public:
		bool bOnGround = false;
		float m_flTime = 0.f;
		float m_flDuckAmount = 0.f;
		float m_flLowerBodyYawTarget = 0.f;
		Vector m_vecOrigin{ };
		Vector m_vecVelocity{ };
		QAngle m_angEyeAngles{ };
	};

	class C_AnimationRecord {
	public:
		bool m_bIsInvalid;
		bool m_bIsShooting;
		bool m_bTeleportDistance;
		bool m_bShiftingTickbase;
		bool m_bResolved;

		bool m_bNoFakeAngles;
		bool m_bFakeWalking;
		bool m_bFakeFlicking;

		Vector m_vecOrigin;
		Vector m_vecVelocity;
		Vector m_vecAnimationVelocity;
		QAngle m_angEyeAngles;
		QAngle m_angPrevEyeAngles;
		QAngle m_angLastFlick;

		int m_fFlags;
		int m_iChokeTicks;

		float m_flChokeTime;
		float m_flSimulationTime;
		float m_flShotTime;
		float m_flDuckAmount;
		float m_flDelta;
		float m_flLowerBodyYawTarget;
		float m_flAbsRotation;

		float m_flFeetYawRate;
		float m_flFeetCycle;

		int m_iResolverMode;
		std::string m_resolver_mode;
		C_AnimationLayer m_serverAnimOverlays[13];
		C_CSPlayer* m_pPlayer;
	};

	class C_AnimationData {
	public:
		void Update();
		void Collect(C_CSPlayer* player);

		void SimulateAnimations(Encrypted_t<Engine::C_AnimationRecord> current, Encrypted_t<Engine::C_AnimationRecord> previous);

		C_CSPlayer* player;
		int ent_index;

		float m_flSpawnTime;
		float m_flSimulationTime;
		float m_flOldSimulationTime;

		Vector m_vecOrigin;

		bool m_bIsDormant = false;
		bool m_bBonesCalculated = false;
		bool m_bUpdated = false;
		bool m_bForceVelocity = false;
		bool m_bDidForceVelocity = false;

		bool m_bResolved = false;
		bool m_bIsAlive = false;
		bool m_bInvertedSide = false;
		bool m_bForceFake = false;
		float m_flLastScannedYaw = 0.0f;

		int m_iCurrentTickCount = 0;
		int m_iOldTickCount = 0;
		int m_iTicksAfterDormancy = 0;
		int m_iTicksUnknown = 0;
		int m_iLastLowDeltaTick = 0;

		Vector m_vecOldVelocity;

		std::deque<C_AnimationRecord> m_AnimationRecord;
		std::vector<C_SimulationInfo> m_vecSimulationData;

		alignas(16) matrix3x4_t m_Bones[128]{ };
		float m_flAbsRotation;
	};

	class __declspec(novtable) AnimationSystem : public NonCopyable {
	public:
		static Encrypted_t<AnimationSystem> Get();

		virtual void CollectData() = 0;
		virtual void Update() = 0;
		virtual C_AnimationData* GetAnimationData(int index) = 0;

	protected:
		AnimationSystem() { };
		virtual ~AnimationSystem() { };
	};
}

```

`CSGO SDK/Features/Rage/AntiAim.cpp`:

```cpp
#include "AntiAim.hpp"
#include "../../SDK/CVariables.hpp"
#include "../Miscellaneous/Movement.hpp"
#include "../../source.hpp"
#include "../../Utils/InputSys.hpp"
#include "../../SDK/Classes/player.hpp"
#include "../../SDK/Valve/CBaseHandle.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "LagCompensation.hpp"
#include "Autowall.h"
#include "../Game/SimulationContext.hpp"
#include "../../SDK/displacement.hpp"
#include "../../Renderer/Render.hpp"
#include "../Visuals/ESP.hpp"
#include <random>

namespace Interfaces
{
	class C_AntiAimbot : public AntiAimbot {
	public:
		void UpdateJitter();
		void Main(bool* bSendPacket, bool* bFinalPacket, Encrypted_t<CUserCmd> cmd, bool ragebot) override;
	private:
		virtual float GetAntiAimX(Encrypted_t<CVariables::ANTIAIM_STATE> settings, Encrypted_t<CUserCmd> cmd);
		virtual float GetAntiAimY(Encrypted_t<CVariables::ANTIAIM_STATE> settings, Encrypted_t<CUserCmd> cmd);

		virtual void Distort(Encrypted_t<CUserCmd> cmd);

		enum class Directions : int {
			YAW_RIGHT = -1,
			YAW_BACK,
			YAW_LEFT,
			YAW_NONE,
		};
		virtual Directions HandleDirection(Encrypted_t<CUserCmd> cmd);

		virtual bool IsEnabled(Encrypted_t<CUserCmd> cmd, Encrypted_t<CVariables::ANTIAIM_STATE> settings);

		bool m_bNegate = false;
		float m_flLowerBodyUpdateTime = 0.f;

		bool   m_jitter_update = false;
		float  m_auto;
		float  m_auto_dist;
		float  m_auto_last;
		float  m_view;
		float  m_auto_time;
	};

	bool C_AntiAimbot::IsEnabled(Encrypted_t<CUserCmd> cmd, Encrypted_t<CVariables::ANTIAIM_STATE> settings) {
		C_CSPlayer* LocalPlayer = C_CSPlayer::GetLocalPlayer();
		if (!LocalPlayer || LocalPlayer->IsDead())
			return false;

		if (g_Vars.globals.IsRoundFreeze)
			return false;

		if (!(g_Vars.antiaim.bomb_activity && g_Vars.globals.BobmActivityIndex == LocalPlayer->EntIndex()) || !g_Vars.antiaim.bomb_activity)
			if ((cmd->buttons & IN_USE) && (LocalPlayer->m_bIsDefusing()))
				return false;

		if (LocalPlayer->m_MoveType() == MOVETYPE_NOCLIP)
			return false;

		static auto g_GameRules = *(uintptr_t**)(Engine::Displacement.Data.m_GameRules);
		if (g_GameRules && *(bool*)(*(uintptr_t*)g_GameRules + 0x20) || (LocalPlayer->m_fFlags() & (1 << 6)))
			return false;

		C_WeaponCSBaseGun* Weapon = (C_WeaponCSBaseGun*)LocalPlayer->m_hActiveWeapon().Get();


		if (cmd->buttons & IN_USE)
			return false;

		if (!Weapon)
			return false;

		auto WeaponInfo = Weapon->GetCSWeaponData();
		if (!WeaponInfo.IsValid())
			return false;

		if (WeaponInfo->m_iWeaponType == WEAPONTYPE_GRENADE) {
			if (!Weapon->m_bPinPulled() || (cmd->buttons & (IN_ATTACK | IN_ATTACK2))) {
				float throwTime = Weapon->m_fThrowTime();
				if (throwTime > 0.f)
					return false;
			}
		}
		else {
			if ((WeaponInfo->m_iWeaponType == WEAPONTYPE_KNIFE && cmd->buttons & (IN_ATTACK | IN_ATTACK2)) || cmd->buttons & IN_ATTACK) {
				if (LocalPlayer->CanShoot())
					return false;
			}
		}

		if (LocalPlayer->m_MoveType() == MOVETYPE_LADDER)
			return false;

		return true;
	}

	Encrypted_t<AntiAimbot> AntiAimbot::Get() {
		static C_AntiAimbot instance;
		return &instance;
	}


	std::random_device random;
	std::mt19937 generator(random());

	void C_AntiAimbot::UpdateJitter() {

		const auto jitterSpeed = 1 + Interfaces::m_pClientState->m_nChokedCommands();
		static int lastTick = 0;
		static auto returnValue = 0.f;
		C_CSPlayer* LocalPlayer = C_CSPlayer::GetLocalPlayer();

		if (lastTick + jitterSpeed < LocalPlayer->m_nTickBase() || lastTick > LocalPlayer->m_nTickBase()) {
			lastTick = LocalPlayer->m_nTickBase();
			m_jitter_update = !m_jitter_update;
		}
	}


	void C_AntiAimbot::Main(bool* bSendPacket, bool* bFinalPacket, Encrypted_t<CUserCmd> cmd, bool ragebot) {
		C_CSPlayer* LocalPlayer = C_CSPlayer::GetLocalPlayer();

		if (!LocalPlayer || LocalPlayer->IsDead())
			return;

		auto animState = LocalPlayer->m_PlayerAnimState();
		if (!animState)
			return;

		if (!g_Vars.antiaim.enabled)
			return;

		Encrypted_t<CVariables::ANTIAIM_STATE> settings(&g_Vars.antiaim_stand);

		C_WeaponCSBaseGun* Weapon = (C_WeaponCSBaseGun*)LocalPlayer->m_hActiveWeapon().Get();

		if (!Weapon)
			return;

		auto WeaponInfo = Weapon->GetCSWeaponData();
		if (!WeaponInfo.IsValid())
			return;

		if (!IsEnabled(cmd, settings))
			return;

		if (LocalPlayer->m_MoveType() == MOVETYPE_LADDER) {
			auto eye_pos = LocalPlayer->GetEyePosition();

			CTraceFilterWorldAndPropsOnly filter;
			CGameTrace tr;
			Ray_t ray;
			float angle = 0.0f;
			while (true) {
				float cosa, sina;
				DirectX::XMScalarSinCos(&cosa, &sina, angle);

				Vector pos;
				pos.x = (cosa * 32.0f) + eye_pos.x;
				pos.y = (sina * 32.0f) + eye_pos.y;
				pos.z = eye_pos.z;

				ray.Init(eye_pos, pos,
					Vector(-1.0f, -1.0f, -4.0f),
					Vector(1.0f, 1.0f, 4.0f));
				Interfaces::m_pEngineTrace->TraceRay(ray, MASK_SOLID, &filter, &tr);
				if (tr.fraction < 1.0f)
					break;

				angle += DirectX::XM_PIDIV2;
				if (angle >= DirectX::XM_2PI) {
					return;
				}
			}

			float v23 = atan2(tr.plane.normal.x, std::fabsf(tr.plane.normal.y));
			float v24 = RAD2DEG(v23) + 90.0f;
			cmd->viewangles.pitch = 89.0f;
			if (v24 <= 180.0f) {
				if (v24 < -180.0f) {
					v24 = v24 + 360.0f;
				}
				cmd->viewangles.yaw = v24;
			}
			else {
				cmd->viewangles.yaw = v24 - 360.0f;
			}

			if (cmd->buttons & IN_BACK) {
				cmd->buttons |= IN_FORWARD;
				cmd->buttons &= ~IN_BACK;
			}
			else  if (cmd->buttons & IN_FORWARD) {
				cmd->buttons |= IN_BACK;
				cmd->buttons &= ~IN_FORWARD;
			}

			return;
		}

		bool move = LocalPlayer->m_vecVelocity().Length2D() > 0.1f; //&& !g_Vars.globals.Fakewalking;

		// save view, depending if locked or not.
		if ((g_Vars.antiaim.freestand_lock && move) || !g_Vars.antiaim.freestand_lock)
			m_view = cmd->viewangles.y;

		UpdateJitter();
		cmd->viewangles.x = GetAntiAimX(settings, cmd);
		float flYaw = GetAntiAimY(settings, cmd);

		// https://github.com/VSES/SourceEngine2007/blob/master/se2007/engine/cl_main.cpp#L1877-L1881
		if (!*bSendPacket || !*bFinalPacket) {
			cmd->viewangles.y = flYaw;
			Distort(cmd);
		}
		else {
			std::uniform_int_distribution random(-90, 90);

			static int negative = false;

			switch (settings->fake_yaw) {

				// default
			case 1:
				cmd->viewangles.y = Math::AngleNormalize(flYaw + 180 + random(generator));
				break;

				// flicker
			case 2:
				negative ? flYaw = Math::AngleNormalize(flYaw + 90 + std::fmod(Interfaces::m_pGlobalVars->curtime * 360.f, 180.f)) : cmd->viewangles.y = Math::AngleNormalize(flYaw + 90 + std::fmod(Interfaces::m_pGlobalVars->curtime * 360.f, 180.f));
				if (flYaw == 1.f)
					negative ? flYaw + std::fmod(Interfaces::m_pGlobalVars->curtime * 360.f, 0.f) : flYaw + std::fmod(Interfaces::m_pGlobalVars->curtime * 360.f, 0.f);
				negative = !negative;
				break;
			
			default:
				break;
			}
		}

		static int negative = false;
		auto bSwap = std::fabs(Interfaces::m_pGlobalVars->curtime - g_Vars.globals.m_flBodyPred) > 1.1 - (Interfaces::m_pGlobalVars->interval_per_tick * 5);
		if (!Interfaces::m_pClientState->m_nChokedCommands()
			&& Interfaces::m_pGlobalVars->curtime >= g_Vars.globals.m_flBodyPred
			&& (LocalPlayer->m_fFlags() & FL_ONGROUND) && !move) {
			// lby.
			switch (settings->yaw) {
			case 1: // twist
				cmd->viewangles.y += negative ? g_Vars.antiaim.break_lby : -g_Vars.antiaim.break_lby;
				negative = !negative;
				break;

			case 2: // static		
				cmd->viewangles.y += g_Vars.antiaim.break_lby;
				break;

			case 3: // break logic
				cmd->viewangles.y += 110.f;
				negative ? cmd->viewangles.y += 110.f : cmd->viewangles.y -= 130.f;
				negative = !negative;
				break;

			default:
				break;
			}
		}
	}

	float C_AntiAimbot::GetAntiAimX(Encrypted_t<CVariables::ANTIAIM_STATE> settings, Encrypted_t<CUserCmd> cmd) {
		switch (settings->pitch) {
		case 0:
			return cmd->viewangles.x;
		case 1: // down
			return 89.f;
		case 2: // up 
			return -89.f;
		case 3: // zero
			return 0.f;
		default:
			break;
		}
	}

	float C_AntiAimbot::GetAntiAimY(Encrypted_t<CVariables::ANTIAIM_STATE> settings, Encrypted_t<CUserCmd> cmd) {
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local || local->IsDead())
			return FLT_MAX;

		float flViewAnlge = cmd->viewangles.y;
		float flRetValue = flViewAnlge + 180.f;
		bool bUsingManualAA = g_Vars.globals.manual_aa != -1;

		// lets do our real yaw.'
		switch (settings->base_yaw) {
		case 0: flRetValue = cmd->viewangles.y;
			break;
		case 1: // backwards.
			flRetValue = flViewAnlge + 180.f;
			break;
		case 2: // 180z
			flRetValue = (flViewAnlge - 180.f / 2.f);
			flRetValue += std::fmod(Interfaces::m_pGlobalVars->curtime * (3.5 * 20.f), 180.f);
			break;
		case 3:
			flRetValue = flViewAnlge + 180.f;
			if (settings->jitter_mode == 0)
				flRetValue += RandomFloat(-g_Vars.antiaim.random_jitter / 2, g_Vars.antiaim.random_jitter / 2);
			else
				flRetValue += m_jitter_update ? -g_Vars.antiaim.random_jitter / 2 : g_Vars.antiaim.random_jitter / 2;
			break;
		default:
			break;
		}

		if (g_Vars.antiaim.freestand) {
			const C_AntiAimbot::Directions Direction = HandleDirection(cmd);
			switch (Direction) {
			case Directions::YAW_BACK:
				switch (settings->base_yaw) {
				case 1: // backwards.
					flRetValue = flViewAnlge + 180.f;
					break;
				case 2: // 180z
					flRetValue = (flViewAnlge - 180.f / 2.f);
					flRetValue += std::fmod(Interfaces::m_pGlobalVars->curtime * (3.5 * 20.f), 180.f);
					break;
				case 3:
					flRetValue = flViewAnlge + 180.f;
					if (settings->jitter_mode == 0)
						flRetValue += RandomFloat(-g_Vars.antiaim.random_jitter / 2 * 1.15, g_Vars.antiaim.random_jitter / 2 * 1.15);
					else
						flRetValue += m_jitter_update ? -g_Vars.antiaim.random_jitter / 2 * 1.15 : g_Vars.antiaim.random_jitter / 2 * 1.15;
					break;
				default:
					break;
				}
				break;
			case Directions::YAW_LEFT:
				switch (settings->base_yaw) {
				case 1: // backwards.
					flRetValue = flViewAnlge + 90.f;
					break;
				case 2: // 180z
					flRetValue = (flViewAnlge + 90.f / 2.f);
					flRetValue += std::fmod(Interfaces::m_pGlobalVars->curtime * (3.5 * 20.f), 90.f);
					break;
				case 3:
					flRetValue = flViewAnlge + 90.f;
					if (settings->jitter_mode == 0)
						flRetValue += RandomFloat(-g_Vars.antiaim.random_jitter / 2, g_Vars.antiaim.random_jitter / 2);
					else
						flRetValue += m_jitter_update ? -g_Vars.antiaim.random_jitter / 2 : g_Vars.antiaim.random_jitter / 2;
					break;
				default:
					break;
				}
				break;
			case Directions::YAW_RIGHT:
				// right yaw.
				switch (settings->base_yaw) {
				case 1: // backwards.
					flRetValue = flViewAnlge - 90.f;
					break;
				case 2: // 180z
					flRetValue = (flViewAnlge - 90.f / 2.f);
					flRetValue += std::fmod(Interfaces::m_pGlobalVars->curtime * (3.5 * 20.f), -90.f);
					break;
				case 3:
					flRetValue = flViewAnlge - 90.f;
					if (settings->jitter_mode == 0)
						flRetValue += RandomFloat(-g_Vars.antiaim.random_jitter / 2, g_Vars.antiaim.random_jitter / 2);
					else
						flRetValue += m_jitter_update ? -g_Vars.antiaim.random_jitter / 2 : g_Vars.antiaim.random_jitter / 2;
					break;
				default:
					break;
				}
				break;
			case Directions::YAW_NONE:
				switch (settings->base_yaw) {
				case 1: // backwards.
					flRetValue = flViewAnlge + 180.f;
					break;
				case 2: // 180z
					flRetValue = (flViewAnlge - 180.f / 2.f);
					flRetValue += std::fmod(Interfaces::m_pGlobalVars->curtime * (3.5 * 20.f), 180.f);
					break;
				case 3:
					flRetValue = flViewAnlge + 180.f;
					if (settings->jitter_mode == 0)
						flRetValue += RandomFloat(-g_Vars.antiaim.random_jitter / 2 * 1.15, g_Vars.antiaim.random_jitter / 2 * 1.15);
					else
						flRetValue += m_jitter_update ? -g_Vars.antiaim.random_jitter / 2 * 1.15 : g_Vars.antiaim.random_jitter / 2 * 1.15;
					break;
				default:
					break;
				}
				break;
			}
		}

		if (settings->base_yaw > 0)
			flRetValue += g_Vars.antiaim.yaw_addition;

		if (bUsingManualAA) {
			switch (g_Vars.globals.manual_aa) {
			case 0:
				flRetValue = flViewAnlge + 90.f;
				break;
			case 1:
				flRetValue = flViewAnlge + 180.f;
				break;
			case 2:
				flRetValue = flViewAnlge - 90.f;
				break;
			}
		}


		return flRetValue;
	}

	void C_AntiAimbot::Distort(Encrypted_t<CUserCmd> cmd) {
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local || local->IsDead())
			return;

		if (!g_Vars.antiaim.distort)
			return;

		bool bDoDistort = true;

		if (g_Vars.antiaim.distort_disable_fakewalk && g_Vars.misc.slow_walk && g_Vars.misc.slow_walk_bind.enabled)
			bDoDistort = false;

		if (g_Vars.antiaim.distort_disable_air && !FL_ONGROUND)
			bDoDistort = false;

		static float flLastMoveTime = FLT_MAX;
		static float flLastMoveYaw = FLT_MAX;
		static bool bGenerate = true;
		static float flGenerated = 0.f;

		if (!(g_Vars.misc.slow_walk && g_Vars.misc.slow_walk_bind.enabled) && local->m_vecVelocity().Length() > 0.1f && g_Vars.globals.m_bGround) {
			flLastMoveTime = Interfaces::m_pGlobalVars->realtime;
			flLastMoveYaw = local->m_flLowerBodyYawTarget();

			if (g_Vars.antiaim.distort_disable_run)
				bDoDistort = false;
		}

		if (g_Vars.globals.manual_aa != -1 && !g_Vars.antiaim.distort_manual_aa)
			bDoDistort = false;

		if (flLastMoveTime == FLT_MAX)
			return;

		if (flLastMoveYaw == FLT_MAX)
			return;

		if (!bDoDistort) {
			bGenerate = true;
		}

		if (!g_Vars.antiaim.distort_spin) {
			if (bDoDistort) {

				if (true) {
					float flDistortion = std::sin((Interfaces::m_pGlobalVars->realtime * (g_Vars.antiaim.distort_speed * 2)) * 0.5f + 0.5f);

					cmd->viewangles.y += g_Vars.antiaim.distort_range * flDistortion;
					return;
				}

				if (bGenerate) {
					float flNormalised = std::remainderf(g_Vars.antiaim.distort_range, 180.f);

					flGenerated = RandomFloat(-flNormalised, flNormalised);
					bGenerate = false;
				}

				float flDelta = fabs(flLastMoveYaw - local->m_flLowerBodyYawTarget());
				cmd->viewangles.y += flDelta + flGenerated;
			}
		}
		else {
			bool bUsingManualAA = g_Vars.globals.manual_aa != -1;
			if (bUsingManualAA && g_Vars.antiaim.distort_manual_aa)
				return;

			if (bDoDistort) {
				if (true)
					cmd->viewangles.y += std::fmod(Interfaces::m_pGlobalVars->realtime * (g_Vars.antiaim.distort_speed * 2) * 100, 360.f);
			}
		}
	}

	C_AntiAimbot::Directions C_AntiAimbot::HandleDirection(Encrypted_t<CUserCmd> cmd) {
		const auto pLocal = C_CSPlayer::GetLocalPlayer();
		if (!pLocal)
			return Directions::YAW_NONE;

		// best target.
		struct AutoTarget_t { float fov; C_CSPlayer* player; };
		AutoTarget_t target{ 180.f + 1.f, nullptr };

		// iterate players, for closest distance.
		for (int i{ 1 }; i <= Interfaces::m_pGlobalVars->maxClients; ++i) {
			auto player = C_CSPlayer::GetPlayerByIndex(i);
			if (!player || player->IsDead())
				continue;

			if (player->IsDormant())
				continue;

			bool is_team = player->IsTeammate(pLocal);
			if (is_team)
				continue;

			auto lag_data = Engine::LagCompensation::Get()->GetLagData(player->m_entIndex);
			if (!lag_data.IsValid())
				continue;

			// get best target based on fov.
			Vector origin = player->m_vecOrigin();

			auto AngleDistance = [&](QAngle& angles, const Vector& start, const Vector& end) -> float {
				auto direction = end - start;
				auto aimAngles = direction.ToEulerAngles();
				auto delta = aimAngles - angles;
				delta.Normalize();

				return sqrtf(delta.x * delta.x + delta.y * delta.y);
			};

			float fov = AngleDistance(cmd->viewangles, g_Vars.globals.m_vecFixedEyePosition, origin);

			if (fov < target.fov) {
				target.fov = fov;
				target.player = player;
			}
		}

		// get best player.
		const auto player = target.player;
		if (!player)
			return Directions::YAW_NONE;

		Vector& bestOrigin = player->m_vecOrigin();

		// calculate direction from bestOrigin to our origin
		const auto yaw = Math::CalcAngle(bestOrigin, pLocal->m_vecOrigin());

		Vector forward, right, up;
		Math::AngleVectors(yaw, forward, right, up);

		Vector vecStart = pLocal->GetEyePosition();
		Vector vecEnd = vecStart + forward * 100.0f;

		Ray_t rightRay(vecStart + right * 35.0f, vecEnd + right * 35.0f), leftRay(vecStart - right * 35.0f, vecEnd - right * 35.0f);

		// setup trace filter
		CTraceFilter filter{ };
		filter.pSkip = pLocal;

		CGameTrace tr{ };

		m_pEngineTrace->TraceRay(rightRay, MASK_SOLID, &filter, &tr);
		float rightLength = (tr.endpos - tr.startpos).Length();

		m_pEngineTrace->TraceRay(leftRay, MASK_SOLID, &filter, &tr);
		float leftLength = (tr.endpos - tr.startpos).Length();

		static auto leftTicks = 0;
		static auto rightTicks = 0;
		static auto backTicks = 0;

		if (rightLength - leftLength > 20.0f)
			leftTicks++;
		else
			leftTicks = 0;

		if (leftLength - rightLength > 20.0f)
			rightTicks++;
		else
			rightTicks = 0;

		if (fabs(rightLength - leftLength) <= 20.0f)
			backTicks++;
		else
			backTicks = 0;

		Directions direction = Directions::YAW_NONE;

		if (rightTicks > 2) {
			direction = Directions::YAW_RIGHT;
		}
		else {
			if (leftTicks > 2) {
				direction = Directions::YAW_LEFT;
			}
			else {
				if (backTicks > 2)
					direction = Directions::YAW_BACK;
			}
		}

		return direction;
	}
}
```

`CSGO SDK/Features/Rage/AntiAim.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

namespace Interfaces
{

	class __declspec(novtable) AntiAimbot : public NonCopyable {
	public:
		static Encrypted_t<AntiAimbot> Get();
		virtual void Main(bool* bSendPacket, bool* bFinalPacket, Encrypted_t<CUserCmd> cmd, bool ragebot) = 0;
	protected:
		AntiAimbot() { };
		virtual ~AntiAimbot() { };
	};
}
```

`CSGO SDK/Features/Rage/Autowall.cpp`:

```cpp
#include "Autowall.h"
#include "../../SDK/Displacement.hpp"
#include "../../SDK/Classes/player.hpp"
#include "../../SDK/Classes/weapon.hpp"

// IsBreakableEntity
// https://github.com/ValveSoftware/source-sdk-2013/blob/master/sp/src/game/shared/obstacle_pushaway.cpp
bool Autowall::IsBreakable(C_BaseEntity* pEntity) {
	if (!pEntity || pEntity->m_entIndex == 0 || !pEntity->GetCollideable())
		return false;

	static uintptr_t uTakeDamage = *(uintptr_t*)((uintptr_t)Engine::Displacement.Function.m_uIsBreakable + 38);
	const uintptr_t uTakeDamageBackup = *(uint8_t*)((uintptr_t)pEntity + uTakeDamage);

	const ClientClass* pClientClass = pEntity->GetClientClass();
	if (pClientClass) {
		const char* name = pClientClass->m_pNetworkName;

		// CBreakableSurface, CBaseDoor, ...
		if (name[1] != 'F'
			|| name[4] != 'c'
			|| name[5] != 'B'
			|| name[9] != 'h') {
			*(uint8_t*)((uintptr_t)pEntity + uTakeDamage) = 2; /*DAMAGE_YES*/
		}
	}

	using fnIsBreakable = bool(__thiscall*)(C_BaseEntity*);
	const bool bResult = ((fnIsBreakable)Engine::Displacement.Function.m_uIsBreakable)(pEntity);
	*(uint8_t*)((uintptr_t)pEntity + uTakeDamage) = uTakeDamageBackup;

	return bResult;
}

bool Autowall::IsArmored(C_CSPlayer* player, int nHitgroup) {
	const bool bHasHelmet = player->m_bHasHelmet();
	const bool bHasHeavyArmor = player->m_bHasHeavyArmor();
	const float flArmorValue = player->m_ArmorValue();

	if (flArmorValue > 0) {
		switch (nHitgroup) {
		case Hitgroup_Chest:
		case Hitgroup_Stomach:
		case Hitgroup_LeftArm:
		case Hitgroup_RightArm:
			return true;
			break;
		case Hitgroup_Head:
			return bHasHelmet || bHasHeavyArmor;
			break;
		default:
			return bHasHeavyArmor;
			break;
		}
	}

	return false;
}

// references CCSPlayer::TraceAttack and CCSPlayer::OnTakeDamage
float Autowall::ScaleDamage(C_CSPlayer* player, float flDamage, float flArmorRatio, int nHitgroup) {
	if (!player)
		return -1.f;

	C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer();

	if (!pLocal)
		return -1.f;

	C_WeaponCSBaseGun* pWeapon = (C_WeaponCSBaseGun*)pLocal->m_hActiveWeapon().Get();

	if (!pWeapon)
		return -1.f;

	const int nTeamNum = player->m_iTeamNum();
	float flHeadDamageScale = nTeamNum == TEAM_CT ? g_Vars.mp_damage_scale_ct_head->GetFloat() : g_Vars.mp_damage_scale_t_head->GetFloat();
	const float flBodyDamageScale = nTeamNum == TEAM_CT ? g_Vars.mp_damage_scale_ct_body->GetFloat() : g_Vars.mp_damage_scale_t_body->GetFloat();

	const bool bIsArmored = IsArmored(player, nHitgroup);
	const bool bHasHeavyArmor = player->m_bHasHeavyArmor();
	const bool bIsZeus = pWeapon->m_iItemDefinitionIndex() == WEAPON_ZEUS;

	const float flArmorValue = static_cast<float>(player->m_ArmorValue());

	if (bHasHeavyArmor)
		flHeadDamageScale /= 2.f;

	if (!bIsZeus) {
		switch (nHitgroup) {
		case Hitgroup_Head:
			flDamage = (flDamage * 4.f) * flHeadDamageScale;
			break;
		case Hitgroup_Stomach:
			flDamage = (flDamage * 1.25f) * flBodyDamageScale;
			break;
		case Hitgroup_LeftLeg:
		case Hitgroup_RightLeg:
			flDamage = (flDamage * 0.75f) * flBodyDamageScale;
			break;
		default:
			break;
		}
	}

	// enemy have armor
	if (bIsArmored) {
		float flArmorScale = 1.f;
		float flArmorBonusRatio = 0.5f;
		float flArmorRatioCalculated = flArmorRatio * 0.5f;
		float fDamageToHealth = 0.f;

		if (bHasHeavyArmor) {
			flArmorRatioCalculated = flArmorRatio * 0.25f;
			flArmorBonusRatio = 0.33f;

			flArmorScale = 0.33f;

			fDamageToHealth = (flDamage * flArmorRatioCalculated) * 0.85f;
		}
		else {
			fDamageToHealth = flDamage * flArmorRatioCalculated;
		}

		float fDamageToArmor = (flDamage - fDamageToHealth) * (flArmorScale * flArmorBonusRatio);

		// Does this use more armor than we have?
		if (fDamageToArmor > flArmorValue)
			fDamageToHealth = flDamage - (flArmorValue / flArmorBonusRatio);

		flDamage = fDamageToHealth;
	}

	return std::floor(flDamage);
}

void Autowall::TraceLine(const Vector& start, const Vector& end, uint32_t mask, ITraceFilter* ignore, CGameTrace* ptr) {
	Ray_t ray;
	ray.Init(start, end);
	Interfaces::m_pEngineTrace->TraceRay(ray, mask, ignore, ptr);
}

__forceinline float DistanceToRay(const Vector& vecPosition, const Vector& vecRayStart, const Vector& vecRayEnd, float* flAlong = NULL, Vector* vecPointOnRay = NULL) {
	Vector vecTo = vecPosition - vecRayStart;
	Vector vecDir = vecRayEnd - vecRayStart;
	float flLength = vecDir.Normalize();

	float flRangeAlong = DotProduct(vecDir, vecTo);
	if (flAlong) {
		*flAlong = flRangeAlong;
	}

	float flRange;  

	if (flRangeAlong < 0.0f) {
		// off start point
		flRange = -vecTo.Length();

		if (vecPointOnRay) {
			*vecPointOnRay = vecRayStart;
		}
	}
	else if (flRangeAlong > flLength) {
		// off end point
		flRange = -(vecPosition - vecRayEnd).Length();

		if (vecPointOnRay) {
			*vecPointOnRay = vecRayEnd;
		}
	}
	else { // within ray bounds
		Vector vecOnRay = vecRayStart + vecDir * flRangeAlong;
		flRange = (vecPosition - vecOnRay).Length();

		if (vecPointOnRay) {
			*vecPointOnRay = vecOnRay;
		}
	}

	return flRange;
}


void Autowall::ClipTraceToPlayer(const Vector vecAbsStart, const Vector& vecAbsEnd, uint32_t iMask, ITraceFilter* pFilter, CGameTrace* pGameTrace, Encrypted_t<Autowall::C_FireBulletData> pData) {
	constexpr float flMaxRange = 60.0f, flMinRange = 0.0f;

	ICollideable* pCollideble = pData->m_TargetPlayer->GetCollideable();

	if (!pCollideble)
		return;

	// get bounding box
	const Vector vecObbMins = pCollideble->OBBMins();
	const Vector vecObbMaxs = pCollideble->OBBMaxs();
	const Vector vecObbCenter = (vecObbMaxs + vecObbMins) / 2.f;

	// calculate world space center
	const Vector vecPosition = vecObbCenter + pData->m_TargetPlayer->GetAbsOrigin();

	Ray_t Ray;
	Ray.Init(vecAbsStart, vecAbsEnd);

	// calculate distance to ray
	const float flRange = DistanceToRay(vecPosition, vecAbsStart, vecAbsEnd);

	if (flRange < 0.0f || flRange > 60.0f)
		return;

	CGameTrace playerTrace;
	Interfaces::m_pEngineTrace->ClipRayToEntity(Ray, iMask, pData->m_TargetPlayer, &playerTrace);
	if (pData->m_EnterTrace.fraction > playerTrace.fraction)
		pData->m_EnterTrace = playerTrace;
}

void Autowall::ClipTraceToPlayers(const Vector& vecAbsStart, const Vector& vecAbsEnd, uint32_t iMask, ITraceFilter* pFilter, CGameTrace* pGameTrace, float flMaxRange, float flMinRange) {
	float flSmallestFraction = pGameTrace->fraction;

	Vector vecDelta(vecAbsEnd - vecAbsStart);
	const float flDelta = vecDelta.Normalize();

	Ray_t Ray;
	Ray.Init(vecAbsStart, vecAbsEnd);

	for (int i = 0; i <= Interfaces::m_pGlobalVars->maxClients; ++i) {
		C_CSPlayer* pPlayer = C_CSPlayer::GetPlayerByIndex(i);
		if (!pPlayer || pPlayer->IsDormant() || pPlayer->IsDead())
			continue;

		if (pFilter && !pFilter->ShouldHitEntity(pPlayer, iMask))
			continue;

		ICollideable* pCollideble = pPlayer->GetCollideable();
		if (!pCollideble)
			continue;

		// get bounding box
		const Vector vecObbMins = pCollideble->OBBMins();
		const Vector vecObbMaxs = pCollideble->OBBMaxs();
		const Vector vecObbCenter = (vecObbMaxs + vecObbMins) / 2.f;

		// calculate world space center
		const Vector vecPosition = vecObbCenter + pPlayer->GetAbsOrigin();

		// calculate distance to ray
		const float flRange = DistanceToRay(vecPosition, vecAbsStart, vecAbsEnd);

		if (flRange < flMinRange || flRange > flMaxRange)
			return;

		CGameTrace playerTrace;
		Interfaces::m_pEngineTrace->ClipRayToEntity(Ray, iMask, pPlayer, &playerTrace);
		if (playerTrace.fraction < flSmallestFraction) {
			// we shortened the ray - save off the trace
			*pGameTrace = playerTrace;
			flSmallestFraction = playerTrace.fraction;
		}
	}
}

bool Autowall::TraceToExit(CGameTrace* pEnterTrace, Vector vecStartPos, Vector vecDirection, CGameTrace* pExitTrace) {
	constexpr float flMaxDistance = 90.f, flStepSize = 4.f;
	float flCurrentDistance = 0.f;

	int iFirstContents = 0;

	bool bIsWindow = 0;
	auto v23 = 0;

	do {
		// Add extra distance to our ray
		flCurrentDistance += flStepSize;

		// Multiply the direction vector to the distance so we go outwards, add our position to it.
		Vector vecEnd = vecStartPos + (vecDirection * flCurrentDistance);

		if (!iFirstContents)
			iFirstContents = Interfaces::m_pEngineTrace->GetPointContents(vecEnd, MASK_SHOT_PLAYER);

		int iPointContents = Interfaces::m_pEngineTrace->GetPointContents(vecEnd, MASK_SHOT_PLAYER);

		if (!(iPointContents & MASK_SHOT_HULL) || ((iPointContents & CONTENTS_HITBOX) && iPointContents != iFirstContents)) {
			//Let's setup our end position by deducting the direction by the extra added distance
			Vector vecStart = vecEnd - (vecDirection * flStepSize);

			// this gets a bit more complicated and expensive when we have to deal with displacements
			TraceLine(vecEnd, vecStart, MASK_SHOT_PLAYER, nullptr, pExitTrace);

			// note - dex; this is some new stuff added sometime around late 2017 ( 10.31.2017 update? ).
			//if ( g_Vars.sv_clip_penetration_traces_to_players->GetInt( ) )
			//	ClipTraceToPlayers( vecEnd, vecStart, MASK_SHOT_PLAYER, nullptr, pExitTrace, -60.f, -1.f );

			// we hit an ent's hitbox, do another trace.
			if (pExitTrace->startsolid && pExitTrace->surface.flags & SURF_HITBOX) {
				uint32_t filter_[4] = { *reinterpret_cast<uint32_t*> (Engine::Displacement.Function.m_TraceFilterSimple), uint32_t(C_CSPlayer::GetLocalPlayer()), 0, 0 };
				filter_[1] = reinterpret_cast<uint32_t>(pExitTrace->hit_entity);

				// do another trace, but skip the player to get the actual exit surface 
				TraceLine(vecStartPos, vecStart, MASK_SHOT_HULL, reinterpret_cast<CTraceFilter*>(filter_), pExitTrace);

				if (pExitTrace->DidHit() && !pExitTrace->startsolid) {
					vecEnd = pExitTrace->endpos;
					return true;
				}

				continue;
			}

			//Can we hit? Is the wall solid?
			if (pExitTrace->DidHit() && !pExitTrace->startsolid) {
				if (IsBreakable((C_BaseEntity*)pEnterTrace->hit_entity) && IsBreakable((C_BaseEntity*)pExitTrace->hit_entity))
					return true;

				if (pEnterTrace->surface.flags & SURF_NODRAW ||
					(!(pExitTrace->surface.flags & SURF_NODRAW) && pExitTrace->plane.normal.Dot(vecDirection) <= 1.f)) {
					const float flMultAmount = pExitTrace->fraction * 4.f;

					// get the real end pos
					vecStart -= vecDirection * flMultAmount;
					return true;
				}

				continue;
			}

			if (!pExitTrace->DidHit() || pExitTrace->startsolid) {
				if (pEnterTrace->DidHitNonWorldEntity() && IsBreakable((C_BaseEntity*)pEnterTrace->hit_entity)) {
					// if we hit a breakable, make the assumption that we broke it if we can't find an exit (hopefully..)
					// fake the end pos
					pExitTrace = pEnterTrace;
					pExitTrace->endpos = vecStartPos + vecDirection;
					return true;
				}
			}
		}
		// max pen distance is 90 units.
	} while (flCurrentDistance <= flMaxDistance);

	return false;
}

bool Autowall::HandleBulletPenetration(Encrypted_t<C_FireBulletData> data) {
	int iEnterMaterial = data->m_EnterSurfaceData->game.material;
	const int nPenetrationSystem = g_Vars.sv_penetration_type->GetInt();

	bool bContentsGrate = data->m_EnterTrace.contents & CONTENTS_GRATE;
	bool bNoDrawSurf = (data->m_EnterTrace.surface.flags & (SURF_NODRAW)); // this is valve code :D!

	// check if bullet can penetrarte another entity
	if (data->m_iPenetrationCount == 0 &&
		!bContentsGrate &&
		!bNoDrawSurf &&
		iEnterMaterial != CHAR_TEX_GRATE &&
		iEnterMaterial != CHAR_TEX_GLASS)
		return true; // no, stop

	// if we hit a grate with iPenetration == 0, stop on the next thing we hit
	if (data->m_WeaponData->m_flPenetration <= 0.f || data->m_iPenetrationCount == 0)
		return true;

	// find exact penetration exit
	CGameTrace ExitTrace = { };
	if (!TraceToExit(&data->m_EnterTrace, data->m_EnterTrace.endpos, data->m_vecDirection, &ExitTrace)) {
		// ended in solid
		if ((Interfaces::m_pEngineTrace->GetPointContents(data->m_EnterTrace.endpos, MASK_SHOT_HULL) & MASK_SHOT_HULL) == 0)
			return true;
	}

	const surfacedata_t* pExitSurfaceData = Interfaces::m_pPhysSurface->GetSurfaceData(ExitTrace.surface.surfaceProps);

	if (!pExitSurfaceData)
		return true;

	const float flEnterPenetrationModifier = data->m_EnterSurfaceData->game.flPenetrationModifier;
	const float flExitPenetrationModifier = pExitSurfaceData->game.flPenetrationModifier;
	const float flExitDamageModifier = pExitSurfaceData->game.flDamageModifier;

	const int iExitMaterial = pExitSurfaceData->game.material;

	float flDamageModifier = 0.f;
	float flPenetrationModifier = 0.f;

	// percent of total damage lost automatically on impacting a surface
	flDamageModifier = 0.16f;
	flPenetrationModifier = (flEnterPenetrationModifier + flExitPenetrationModifier) * 0.5f;

	// new penetration method
	if (nPenetrationSystem == 1) {
		// percent of total damage lost automatically on impacting a surface
		flDamageModifier = 0.16f;
		flPenetrationModifier = (flEnterPenetrationModifier + flExitPenetrationModifier) * 0.5f;

		if (bContentsGrate || bNoDrawSurf || iEnterMaterial == CHAR_TEX_GLASS || iEnterMaterial == CHAR_TEX_GRATE) {

			if (iEnterMaterial == CHAR_TEX_GLASS || iEnterMaterial == CHAR_TEX_GRATE) {
				flPenetrationModifier = 3.f;
				flDamageModifier = 0.05f;
			}
			else {
				flPenetrationModifier = 1.f;
			}
		}
		// for some weird reason some community servers have ff_damage_reduction_bullets > 0 but ff_damage_bullet_penetration == 0
		// so yeah, no shooting through teammates :)
		else if (iEnterMaterial == CHAR_TEX_FLESH && (data->m_Player->IsTeammate((C_CSPlayer*)(data->m_EnterTrace.hit_entity))) &&
			g_Vars.ff_damage_reduction_bullets->GetFloat() >= 0.f) {
			//Look's like you aren't shooting through your teammate today
			if (g_Vars.ff_damage_bullet_penetration->GetFloat() == 0.f)
				return true;

			//Let's shoot through teammates and get kicked for teamdmg! Whatever, atleast we did damage to the enemy. I call that a win.
			flPenetrationModifier = g_Vars.ff_damage_bullet_penetration->GetFloat();
			flDamageModifier = 0.16f;
		}

		// if enter & exit point is wood we assume this is 
		// a hollow crate and give a penetration bonus
		if (iEnterMaterial == iExitMaterial) {
			if (iExitMaterial == CHAR_TEX_WOOD || iExitMaterial == CHAR_TEX_CARDBOARD)
				flPenetrationModifier = 3.f;
			else if (iExitMaterial == CHAR_TEX_PLASTIC)
				flPenetrationModifier = 2.f;
		}

		// calculate damage  
		const float flTraceDistance = (ExitTrace.endpos - data->m_EnterTrace.endpos).Length();
		const float flPenetrationMod = fmaxf(1.0 / flPenetrationModifier, 0.0f);
		const float flTotalLostDamage = (fmaxf(3.f / data->m_WeaponData->m_flPenetration, 0.f) *
			(flPenetrationMod * 3.f) + (data->m_flCurrentDamage * flDamageModifier)) +
			(((flTraceDistance * flTraceDistance) * flPenetrationMod) / 24);

		const float flClampedLostDamage = fmaxf(flTotalLostDamage, 0.f);

		if (flClampedLostDamage > data->m_flCurrentDamage)
			return true;

		// reduce damage power each time we hit something other than a grate
		if (flClampedLostDamage > 0.0f)
			data->m_flCurrentDamage -= flClampedLostDamage;

		// do we still have enough damage to deal?
		if (data->m_flCurrentDamage < 3.0f)
			return true;

		// penetration was successful
		// setup new start end parameters for successive trace
		data->m_vecStart = ExitTrace.endpos;
		--data->m_iPenetrationCount;
		return false;
	}
	else {
		// since some railings in de_inferno are CONTENTS_GRATE but CHAR_TEX_CONCRETE, we'll trust the
		// CONTENTS_GRATE and use a high damage modifier.
		if (bContentsGrate || bNoDrawSurf) {
			// If we're a concrete grate (TOOLS/TOOLSINVISIBLE texture) allow more penetrating power.
			flPenetrationModifier = 1.0f;
			flDamageModifier = 0.99f;
		}
		else {
			if (flExitPenetrationModifier < flPenetrationModifier) {
				flPenetrationModifier = flExitPenetrationModifier;
			}
			if (flExitDamageModifier < flDamageModifier) {
				flDamageModifier = flExitDamageModifier;
			}
		}

		// if enter & exit point is wood or metal we assume this is 
		// a hollow crate or barrel and give a penetration bonus
		if (iEnterMaterial == iExitMaterial) {
			if (iExitMaterial == CHAR_TEX_WOOD ||
				iExitMaterial == CHAR_TEX_METAL) {
				flPenetrationModifier *= 2;
			}
		}

		float flTraceDistance = (ExitTrace.endpos - data->m_EnterTrace.endpos).Length();

		// check if bullet has enough power to penetrate this distance for this material
		if (flTraceDistance > (data->m_WeaponData->m_flPenetration * flPenetrationModifier))
			return true; // bullet hasn't enough power to penetrate this distance

		// reduce damage power each time we hit something other than a grate
		data->m_flCurrentDamage *= flDamageModifier;

		// penetration was successful
		// setup new start end parameters for successive trace
		data->m_vecStart = ExitTrace.endpos;
		--data->m_iPenetrationCount;
		return false;
	}
}

float Autowall::FireBullets(Encrypted_t<C_FireBulletData> data) {
	constexpr float rayExtension = 40.f;

	//This gets set in FX_Firebullets to 4 as a pass-through value.
	//CS:GO has a maximum of 4 surfaces a bullet can pass-through before it 100% stops.
	//Excerpt from Valve: https://steamcommunity.com/sharedfiles/filedetails/?id=275573090
	//"The total number of surfaces any bullet can penetrate in a single flight is capped at 4." -CS:GO Official

	if (!data->m_Weapon) {
		data->m_Weapon = (C_WeaponCSBaseGun*)(data->m_Player->m_hActiveWeapon().Get());
		if (data->m_Weapon) {
			data->m_WeaponData = data->m_Weapon->GetCSWeaponData().Xor();
		}
	}

	data->m_flTraceLength = 0.f;
	data->m_flCurrentDamage = static_cast<float>(data->m_WeaponData->m_iWeaponDamage);

	CTraceFilter TraceFilter;
	TraceFilter.pSkip = data->m_Player;

	if (!data->m_Filter)
		data->m_Filter = &TraceFilter;

	data->m_flMaxLength = data->m_WeaponData->m_flWeaponRange;

	g_Vars.globals.m_InHBP = true;

	while (data->m_flCurrentDamage >= 3.f) {
		// calculate max bullet range
		data->m_flMaxLength -= data->m_flTraceLength;

		// create end point of bullet
		Vector vecEnd = data->m_vecStart + data->m_vecDirection * data->m_flMaxLength;

		TraceLine(data->m_vecStart, vecEnd, MASK_SHOT_PLAYER, &TraceFilter, &data->m_EnterTrace);

		// create extended end point
		Vector vecEndExtended = vecEnd + data->m_vecDirection * rayExtension;

		// NOTICE: can remove valve`s hack aka bounding box fix
		// Check for player hitboxes extending outside their collision bounds
		if (data->m_TargetPlayer) {
			// clip trace to one player
			ClipTraceToPlayer(data->m_vecStart, vecEndExtended, MASK_SHOT_PLAYER, data->m_Filter, &data->m_EnterTrace, data);
		}
		else {
			ClipTraceToPlayers(data->m_vecStart, vecEndExtended, MASK_SHOT_PLAYER, data->m_Filter, &data->m_EnterTrace);
		}

		if (data->m_EnterTrace.fraction == 1.f)
			break;  // we didn't hit anything, stop tracing shoot

		//calculate the damage based on the distance the bullet traveled.
		data->m_flTraceLength += data->m_EnterTrace.fraction * data->m_flMaxLength;

		//Let's make our damage drops off the further away the bullet is.
		if (!data->m_bShouldIgnoreDistance)
			data->m_flCurrentDamage *= powf(data->m_WeaponData->m_flRangeModifier, data->m_flTraceLength * 0.002f);

		C_CSPlayer* pHittedPlayer = ToCSPlayer((C_BasePlayer*)data->m_EnterTrace.hit_entity);

		const int nHitGroup = data->m_EnterTrace.hitgroup;
		const bool bHitgroupIsValid = data->m_Weapon->m_iItemDefinitionIndex() == WEAPON_ZEUS ? (nHitGroup >= Hitgroup_Generic && nHitGroup < Hitgroup_Neck) : (nHitGroup >= Hitgroup_Generic && nHitGroup < Hitgroup_Neck);
		const bool bTargetIsValid = !data->m_TargetPlayer || (pHittedPlayer != nullptr && pHittedPlayer->m_entIndex == data->m_TargetPlayer->m_entIndex);
		if (pHittedPlayer != nullptr) {
			if (bTargetIsValid && bHitgroupIsValid && pHittedPlayer->IsPlayer() && pHittedPlayer->m_entIndex <= Interfaces::m_pGlobalVars->maxClients && pHittedPlayer->m_entIndex > 0) {
				data->m_flCurrentDamage = ScaleDamage(pHittedPlayer, data->m_flCurrentDamage, data->m_WeaponData->m_flArmorRatio, data->m_Weapon->m_iItemDefinitionIndex() == WEAPON_ZEUS ? Hitgroup_Generic : nHitGroup);
				data->m_iHitgroup = nHitGroup;


				g_Vars.globals.m_InHBP = false;
				return data->m_flCurrentDamage;
			}
		}

		bool bCanPenetrate = data->m_bPenetration;
		if (!data->m_bPenetration)
			bCanPenetrate = data->m_EnterTrace.contents & CONTENTS_WINDOW;

		if (!bCanPenetrate)
			break;

		data->m_EnterSurfaceData = Interfaces::m_pPhysSurface->GetSurfaceData(data->m_EnterTrace.surface.surfaceProps);

		if (!data->m_EnterSurfaceData)
			break;

		// check if we reach penetration distance, no more penetrations after that
		// or if our modifier is super low, just stop the bullet
		if ((data->m_flTraceLength > 3000.f && data->m_WeaponData->m_flPenetration > 0.f) ||
			data->m_EnterSurfaceData->game.flPenetrationModifier < 0.1f) {
			data->m_iPenetrationCount = 0;
			break;
		}

		bool bIsBulletStopped = HandleBulletPenetration(data);

		if (bIsBulletStopped)
			break;
	}

	g_Vars.globals.m_InHBP = false;
	return -1.f;
}

```

`CSGO SDK/Features/Rage/Autowall.h`:

```h
#pragma once
#include "../../source.hpp"

namespace Autowall
{
	class C_FireBulletData {
	public:
		Vector m_vecStart = Vector(0, 0, 0);
		Vector m_vecDirection = Vector(0, 0, 0);
		Vector m_vecPos = Vector(0, 0, 0);

		CGameTrace m_EnterTrace;

		int m_iPenetrationCount = 4;
		int m_iHitgroup = -1;

		float m_flTraceLength;
		float m_flCurrentDamage;

		// input data

		// distance to point
		float m_flMaxLength = 0.0f;
		float m_flPenetrationDistance = 0.0f;

		// should penetrate walls? 
		bool m_bPenetration = false;

		bool m_bShouldDrawImpacts = false;
		FloatColor m_colImpacts;

		bool m_bShouldIgnoreDistance = false;

		CTraceFilter* m_bTraceFilter = nullptr;
		ITraceFilter* m_Filter = nullptr; // TODO: implement
		C_CSPlayer* m_Player = nullptr; // attacker
		C_CSPlayer* m_TargetPlayer = nullptr;  // autowall target ( could be nullptr if just trace attack )
		C_WeaponCSBaseGun* m_Weapon = nullptr; // attacker weapon
		CCSWeaponInfo* m_WeaponData = nullptr;

		surfacedata_t* m_EnterSurfaceData;
	};

	bool IsBreakable(C_BaseEntity* entity);
	bool IsArmored(C_CSPlayer* player, int hitgroup);
	float ScaleDamage(C_CSPlayer* player, float damage, float armor_ratio, int hitgroup);
	void TraceLine(const Vector& start, const Vector& end, uint32_t mask, ITraceFilter* ignore, CGameTrace* ptr);
	void ClipTraceToPlayers(const Vector& vecAbsStart, const Vector& vecAbsEnd, uint32_t mask, ITraceFilter* filter, CGameTrace* tr, float flMaxRange = 60.0f, float flMinRange = 0.0f);
	void ClipTraceToPlayer(const Vector vecAbsStart, const Vector& vecAbsEnd, uint32_t mask, ITraceFilter* filter, CGameTrace* tr, Encrypted_t<Autowall::C_FireBulletData> data);
	bool TraceToExit(CGameTrace* enter_trace, Vector start, Vector direction, CGameTrace* exit_trace);
	bool HandleBulletPenetration(Encrypted_t<C_FireBulletData> data);
	float FireBullets(Encrypted_t<C_FireBulletData> data);
}
```

`CSGO SDK/Features/Rage/ExtendedBactrack.cpp`:

```cpp
#include "ExtendedBactrack.hpp"
#include "../../source.hpp"
#include "LagCompensation.hpp"
#include <algorithm>

class ExtendedBacktrack : public IExtendenBacktrack {
public:
	void SetSuitableInSequence(INetChannel* channel) override;
	float CalculatePing(INetChannel* channel) override;
	void FlipState(INetChannel* channel) override;
private:
	bool m_bIsFlipedState{ };
};

IExtendenBacktrack* IExtendenBacktrack::Get() {
	static ExtendedBacktrack instance;
	return &instance;
}

void ExtendedBacktrack::SetSuitableInSequence(INetChannel* channel) {
	if (m_bIsFlipedState) {
		m_bIsFlipedState = false;
		return;
	}

	const auto spike = TIME_TO_TICKS(CalculatePing(channel));
	if (channel->m_nInSequenceNr > spike)
		channel->m_nInSequenceNr -= spike;
}

float ExtendedBacktrack::CalculatePing(INetChannel* channel) {
	auto wanted_ping = 0.f;

	if (g_Vars.misc.extended_backtrack)
		wanted_ping = 200.f / 1000.f;
	//else if ( g_Vars.rage.enabled )
	   //wanted_ping = 200.f / 1000.f - Engine::LagCompensation::Get( )->GetLerp( );
	else
		return 0.f;

	return std::max(0.f, wanted_ping - channel->GetLatency(FLOW_OUTGOING));
}

void ExtendedBacktrack::FlipState(INetChannel* channel) {
	static auto last_reliable_state = -1;

	if (channel->m_nInReliableState != last_reliable_state)
		m_bIsFlipedState = true;

	last_reliable_state = channel->m_nInReliableState;
}

```

`CSGO SDK/Features/Rage/ExtendedBactrack.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

class __declspec(novtable) IExtendenBacktrack : public NonCopyable {
public:
	static IExtendenBacktrack* Get();
	virtual void SetSuitableInSequence(INetChannel* channel) = NULL;
	virtual float CalculatePing(INetChannel* channel) = NULL;
	virtual void FlipState(INetChannel* channel) = NULL;

protected:
	IExtendenBacktrack() {

	}
	virtual ~IExtendenBacktrack() {

	}
};
```

`CSGO SDK/Features/Rage/FakeLag.cpp`:

```cpp
#include "FakeLag.hpp"
#include "../../SDK/CVariables.hpp"

#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Classes/Weapon.hpp"
#include "Autowall.h"

#include "../../Utils/InputSys.hpp"
#include "LagCompensation.hpp"
#include "../Game/Prediction.hpp"

#include "../../source.hpp"

#include "../../SDK/Displacement.hpp"
#include "../Miscellaneous/Movement.hpp"

#include "../Game/SetupBones.hpp"
#include "../Game/SimulationContext.hpp"

#include "AnimationSystem.hpp"
#include "TickbaseShift.hpp"

extern int OutgoingTickcount;

namespace Interfaces
{
	struct FakelagData {
		int m_iChoke, m_iMaxChoke;
		int m_iWillChoke = 0;
		int m_iLatency = 0;

		bool m_bAlternative = false;
	};

	static FakelagData _fakelag_data;

	class C_FakeLag : public FakeLag {
	public:
		C_FakeLag() : fakelagData(&_fakelag_data) {

		}

		virtual void Main(bool* bSendPacket, Encrypted_t<CUserCmd> cmd);
		virtual int GetFakelagChoke() const {
			return fakelagData.Xor()->m_iWillChoke;
		}

		virtual int GetMaxFakelagChoke() const {
			return fakelagData.Xor()->m_iMaxChoke;
		}

		virtual bool IsPeeking(Encrypted_t<CUserCmd> cmd);

	private:
		__forceinline bool AlternativeChoke(bool* bSendPacket);
		bool VelocityChange(Encrypted_t<CUserCmd> cmd);
		bool BreakLagComp(int trigger_limit);
		bool AlternativeCondition(Encrypted_t<CUserCmd> cmd, bool* bSendPacket);
		bool MainCondition(Encrypted_t<CUserCmd> cmd, bool* bSendPacket);

		Encrypted_t<FakelagData> fakelagData;
	};

	Encrypted_t<FakeLag> FakeLag::Get() {
		static C_FakeLag instance;
		return &instance;
	}

	void C_FakeLag::Main(bool* bSendPacket, Encrypted_t<CUserCmd> cmd) {
		fakelagData->m_iWillChoke = 0;
		fakelagData->m_iMaxChoke = 0;

		C_CSPlayer* LocalPlayer = C_CSPlayer::GetLocalPlayer();
		if (!LocalPlayer || LocalPlayer->IsDead()) {
			return;
		}

		if (!(*bSendPacket)) {
			return;
		}

		if (!g_Vars.fakelag.enabled)
			return;

		auto g_GameRules = *(uintptr_t**)(Engine::Displacement.Data.m_GameRules);
		if (*(bool*)(*(uintptr_t*)g_GameRules + 0x20))
			return;

		if (LocalPlayer->m_fFlags() & 0x40)
			return;

		auto weapon = reinterpret_cast<C_WeaponCSBaseGun*>(LocalPlayer->m_hActiveWeapon().Get());
		if (!weapon)
			return;

		auto pWeaponData = weapon->GetCSWeaponData();
		if (!pWeaponData.Xor() || !pWeaponData.IsValid())
			return;

		if (pWeaponData->m_iWeaponType == WEAPONTYPE_GRENADE) {
			if (!weapon->m_bPinPulled() || (cmd->buttons & (IN_ATTACK | IN_ATTACK2))) {
				float throwTime = weapon->m_fThrowTime();
				if (throwTime > 0.f) {
					*bSendPacket = true;
					return;
				}
			}
		}
		else {
			if (cmd->buttons & IN_ATTACK)
			{
				//if( !g_TickbaseController.bInRapidFire ) {
				if (LocalPlayer->CanShoot()) {
					if (!g_Vars.globals.Fakewalking) {
						*bSendPacket = false;
						return;
					}
				}
				//}
			}
		}

		if (g_Vars.fakelag.iLagLimit <= 0)
			return;


		auto net_channel = Encrypted_t<INetChannel>(Interfaces::m_pEngine->GetNetChannelInfo());
		if (!net_channel.IsValid())
			return;

		fakelagData->m_iMaxChoke = 0;
		if (!AlternativeCondition(cmd, bSendPacket) && !MainCondition(cmd, bSendPacket)) {
			return;
		}

		if (fakelagData->m_iMaxChoke < 1)
			return;

		RandomSeed(cmd->command_number);

		// skeet.cc
		int variance = 0;
		if (g_Vars.fakelag.variance > 0.f && !g_Vars.globals.Fakewalking) {
			variance = int(float(g_Vars.fakelag.variance * 0.01f) * float(fakelagData->m_iMaxChoke));
		}

		auto apply_variance = [this](int variance, int fakelag_amount) {
			if (variance > 0 && fakelag_amount > 0) {
				auto max = Math::Clamp(variance, 0, (fakelagData->m_iMaxChoke) - fakelag_amount);
				auto min = Math::Clamp(-variance, -fakelag_amount, 0);
				fakelag_amount += RandomInt(min, max);
				if (fakelag_amount == g_Vars.globals.LastChokedCommands) {
					if (fakelag_amount >= (fakelagData->m_iMaxChoke) || fakelag_amount > 2 && !RandomInt(0, 1)) {
						--fakelag_amount;
					}
					else {
						++fakelag_amount;
					}
				}
			}

			return fakelag_amount;
		};

		

		auto apply_choketype = [&](int fakelag_amount) {

			float extrapolated_speed = LocalPlayer->m_vecVelocity().Length() * Interfaces::m_pGlobalVars->interval_per_tick;

			if (g_Vars.misc.slow_walk && g_Vars.misc.slow_walk_bind.enabled)
				return 14;

			switch (g_Vars.fakelag.choke_type) {
			case 0: // max
				break;
			case 1: // dyn
				fakelag_amount = std::min< int >(static_cast<int>(std::ceilf(64 / extrapolated_speed)), static_cast<int>(fakelag_amount));
				fakelag_amount = std::clamp(fakelag_amount, 2, fakelagData->m_iMaxChoke);
				break;
			case 2: // fluc
				if (cmd->tick_count % 40 < 20) {
					fakelag_amount = fakelag_amount;
				}
				else {
					fakelag_amount = 2;
				}
				break;
			}
			
			return fakelag_amount;
		};

		if (**(int**)Engine::Displacement.Data.m_uHostFrameTicks > 1)
			fakelagData->m_iMaxChoke += **(int**)Engine::Displacement.Data.m_uHostFrameTicks - 1;

		fakelagData->m_iMaxChoke = Math::Clamp(fakelagData->m_iMaxChoke, 0, g_Vars.fakelag.iLagLimit);

		auto fakelag_amount = fakelagData->m_iMaxChoke;
		fakelag_amount = apply_variance(variance, fakelag_amount);
		fakelag_amount = apply_choketype(fakelag_amount);
		*bSendPacket = Interfaces::m_pClientState->m_nChokedCommands() > fakelag_amount;

		if (Interfaces::m_pClientState->m_nChokedCommands() > 16)
			*bSendPacket = true;

		fakelagData->m_iWillChoke = fakelag_amount - Interfaces::m_pClientState->m_nChokedCommands();

		auto diff_too_large = abs(Interfaces::m_pGlobalVars->tickcount - OutgoingTickcount) > fakelagData->m_iMaxChoke;
		if (Interfaces::m_pClientState->m_nChokedCommands() > 0 && diff_too_large) {
			*bSendPacket = true;
			fakelagData->m_bAlternative = false;
			fakelagData->m_iWillChoke = 0;
			return;
		}
	}

	int FindPeekTarget(bool dormant_peek) {
		static auto LastPeekTime = 0;
		static auto LastPeekTarget = 0;
		static auto InPeek = false;

		if (LastPeekTime == Interfaces::m_pGlobalVars->tickcount) {
			if (dormant_peek || InPeek)
				return LastPeekTarget;
			return 0;
		}

		InPeek = false;

		auto local = C_CSPlayer::GetLocalPlayer();

		if (!local || local->IsDead())
			return 0;

		bool any_alive_players = false;
		Engine::C_AnimationData* players[64];
		int player_count = 0;
		for (int i = 1; i <= Interfaces::m_pGlobalVars->maxClients; ++i) {
			if (i > 63)
				break;

			auto target = Engine::AnimationSystem::Get()->GetAnimationData(i);
			if (!target)
				continue;

			// todo: check for round count
			auto player = C_CSPlayer::GetPlayerByIndex(i);
			if (!player || player->IsTeammate(local))
				continue;

			if (target->m_bIsAlive)
				any_alive_players = true;

			if (!player->IsDormant())
				InPeek = true;

			players[player_count] = target;
			player_count++;
		}

		if (!player_count) {
			LastPeekTime = Interfaces::m_pGlobalVars->tickcount;
			LastPeekTarget = 0;
			return 0;
		}

		auto eye_pos = local->m_vecOrigin() + Vector(0.0f, 0.0f, 64.0f);

		auto best_target = 0;
		auto best_fov = 9999.0f;
		for (int i = 0; i < player_count; ++i) {
			auto animation = players[i];
			auto player = C_CSPlayer::GetPlayerByIndex(animation->ent_index);
			if (!player)
				continue;

			if (InPeek && player->IsDormant() || any_alive_players && !animation->m_bIsAlive)
				continue;

			auto origin = player->m_vecOrigin();
			if (player->IsDormant()) {
				origin = animation->m_vecOrigin;
			}

			origin.z += 64.0f;

			Ray_t ray;
			ray.Init(eye_pos, origin);

			CTraceFilter filter;
			filter.pSkip = local;

			CGameTrace tr;
			Interfaces::m_pEngineTrace->TraceRay(ray, 0x4600400B, &filter, &tr);
			if (tr.fraction >= 0.99f || tr.hit_entity == player) {
				LastPeekTime = Interfaces::m_pGlobalVars->tickcount;
				LastPeekTarget = player->m_entIndex;
				return player->m_entIndex;
			}

			QAngle viewangles;
			Interfaces::m_pEngine->GetViewAngles(viewangles);

			auto delta = origin - eye_pos;
			auto angles = delta.ToEulerAngles();
			auto view_delta = angles - viewangles;
			view_delta.Normalize();

			auto fov = std::sqrtf(view_delta.x * view_delta.x + view_delta.y * view_delta.y);

			if (fov >= best_fov)
				continue;

			best_fov = fov;
			best_target = player->m_entIndex;
		}

		LastPeekTime = Interfaces::m_pGlobalVars->tickcount;
		LastPeekTarget = best_target;
		if (dormant_peek || InPeek)
			return best_target;

		return 0;
	}

	bool C_FakeLag::IsPeeking(Encrypted_t<CUserCmd> cmd) {
		C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
		if (!local || local->IsDead())
			return false;

		auto pWeapon = reinterpret_cast<C_WeaponCSBaseGun*>(local->m_hActiveWeapon().Get());
		if (!pWeapon)
			return false;

		auto target = FindPeekTarget(true);
		if (!target)
			return false;

		auto player = C_CSPlayer::GetPlayerByIndex(target);
		if (!player)
			return false;

		auto enemy_weapon = reinterpret_cast<C_WeaponCSBaseGun*>(player->m_hActiveWeapon().Get());
		if (!enemy_weapon)
			return false;

		auto weapon_data = enemy_weapon->GetCSWeaponData();
		auto enemy_eye_pos = player->GetEyePosition();

		auto eye_pos = local->GetEyePosition();
		auto peek_add = local->m_vecVelocity() * TICKS_TO_TIME(14);
		auto second_scan = eye_pos;
		if (local->m_Collision()->m_vecMaxs.x > peek_add.Length2D()) {
			auto peek_direction = local->m_vecVelocity().Normalized();
			second_scan += peek_direction * local->m_Collision()->m_vecMaxs.x;
		}
		else {
			second_scan += peek_add;
		}

		Autowall::C_FireBulletData data;

		data.m_bPenetration = true;
		data.m_vecStart = eye_pos;

		data.m_Player = local;
		data.m_TargetPlayer = player;
		data.m_WeaponData = pWeapon->GetCSWeaponData().Xor();
		data.m_Weapon = pWeapon;

		data.m_vecDirection = (enemy_eye_pos - eye_pos).Normalized();
		data.m_flPenetrationDistance = data.m_vecDirection.Normalize();
		float damage = Autowall::FireBullets(&data);

		data = Autowall::C_FireBulletData{ };
		data.m_bPenetration = true;
		data.m_vecStart = second_scan;

		data.m_Player = local;
		data.m_TargetPlayer = player;
		data.m_WeaponData = pWeapon->GetCSWeaponData().Xor();
		data.m_Weapon = pWeapon;

		data.m_vecDirection = (enemy_eye_pos - second_scan).Normalized();
		data.m_flPenetrationDistance = data.m_vecDirection.Normalize();

		float damage2 = Autowall::FireBullets(&data);

		if (damage >= 1.0f)
			return false;

		if (damage2 >= 1.0f)
			return true;

		return false;
	}

	bool C_FakeLag::AlternativeChoke(bool* bSendPacket) {
		fakelagData->m_iMaxChoke = (int)g_Vars.fakelag.alternative_choke;

		if (**(int**)Engine::Displacement.Data.m_uHostFrameTicks > 1)
			fakelagData->m_iMaxChoke += **(int**)Engine::Displacement.Data.m_uHostFrameTicks - 1;

		fakelagData->m_iMaxChoke = Math::Clamp(fakelagData->m_iMaxChoke, 0, g_Vars.fakelag.iLagLimit);

		*bSendPacket = Interfaces::m_pClientState->m_nChokedCommands() >= fakelagData->m_iMaxChoke;
		fakelagData->m_iWillChoke = fakelagData->m_iMaxChoke - Interfaces::m_pClientState->m_nChokedCommands();

		if (*bSendPacket) {
			fakelagData->m_bAlternative = false;
			return true;
		}

		return false;
	}

	bool C_FakeLag::VelocityChange(Encrypted_t<CUserCmd> cmd) {
		C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
		if (!local || local->IsDead())
			return false;

		static auto init_velocity = false;
		static auto previous_velocity = Vector{ };
		if (local->m_vecVelocity().Length() < 5.0f) {
			init_velocity = false;
			return false;
		}

		if (!init_velocity) {
			init_velocity = true;
		}

		auto move_dir = RAD2DEG(std::atan2f(previous_velocity.y, previous_velocity.x));
		auto current_move_dir = RAD2DEG(std::atan2f(local->m_vecVelocity().y, local->m_vecVelocity().x));
		auto delta = std::remainderf(current_move_dir - move_dir, 360.0f);
		if (std::fabsf(delta) >= 30.0f) {
			previous_velocity = local->m_vecVelocity();
			return true;
		}

		return false;
	}

	bool C_FakeLag::BreakLagComp(int trigger_limit) {
		C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
		if (!local || local->IsDead())
			return false;

		//if( !g_Vars.fakelag.break_lag_compensation )
		//	return false;

		auto speed = local->m_vecVelocity().LengthSquared();
		if (speed < 5.0f)
			return false;

		auto choke = trigger_limit - Interfaces::m_pClientState->m_nChokedCommands();
		if (choke < 1)
			return false;

		auto simulated_origin = local->m_vecOrigin();
		auto move_per_tick = local->m_vecVelocity() * Interfaces::m_pGlobalVars->interval_per_tick;
		for (int i = 0; i < choke; ++i) {
			simulated_origin += move_per_tick;

			auto distance = g_Vars.globals.m_vecNetworkedOrigin.DistanceSquared(simulated_origin);
			if (distance > 4096.0f)
				return true;
		}

		return false;
	}

	bool C_FakeLag::AlternativeCondition(Encrypted_t<CUserCmd> cmd, bool* bSendPacket) {
		C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
		if (!local || local->IsDead() || (int)g_Vars.fakelag.alternative_choke <= 0) {
			fakelagData->m_bAlternative = false;
			return false;
		}

		fakelagData->m_iMaxChoke = 0;

		//if( g_Vars.fakelag.break_lag_compensation && BreakLagComp((int)g_Vars.fakelag.choke)) {
		//	auto distance = local->m_vecOrigin( ).DistanceSquared( g_Vars.globals.m_vecNetworkedOrigin );
		//	if( distance > 4096.0f )
		//		return true;
		//}

		bool LbyUpdate = Interfaces::m_pGlobalVars->curtime + 0.3 == g_Vars.globals.m_flBodyPred;
		bool move = local->m_vecVelocity().Length2D() > 0.1f;
		bool air = !(local->m_fFlags() & FL_ONGROUND);

		if (!fakelagData->m_bAlternative) {
			if (g_Vars.fakelag.trigger_duck && local->m_flDuckAmount() > 0.0f && g_Vars.globals.m_flPreviousDuckAmount > local->m_flDuckAmount()) {
				fakelagData->m_bAlternative = true;
			}
			else if (g_Vars.fakelag.trigger_reloading && local->IsReloading()) {
				fakelagData->m_bAlternative = true;
			}
			else if (g_Vars.fakelag.lby_update && !move && !air && LbyUpdate) {
				fakelagData->m_bAlternative = true;
			}
			else if (g_Vars.fakelag.break_lag_compensation && BreakLagComp((int)g_Vars.fakelag.alternative_choke)) {
				fakelagData->m_bAlternative = true;
			}
			else if (g_Vars.fakelag.trigger_on_peek && Interfaces::FakeLag::Get()->IsPeeking(cmd)) {
				fakelagData->m_bAlternative = true;
			}

			if (fakelagData->m_bAlternative && Interfaces::m_pClientState->m_nChokedCommands() > 0) {
				*bSendPacket = true;
				return true;
			}
		}

		if (fakelagData->m_bAlternative) {
			fakelagData->m_iMaxChoke = (int)g_Vars.fakelag.alternative_choke;
		}

		return fakelagData->m_bAlternative;
	}

	bool C_FakeLag::MainCondition(Encrypted_t<CUserCmd> cmd, bool* bSendPacket) {
		C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
		if (!local || local->IsDead() || (int)g_Vars.fakelag.choke < 1)
			return false;

		auto animState = local->m_PlayerAnimState();
		auto velocity = Math::GetSmoothedVelocity(Interfaces::m_pGlobalVars->interval_per_tick * 2000.0f, local->m_vecVelocity(), animState->m_vecVelocity);

		bool LbyUpdate = Interfaces::m_pGlobalVars->curtime + 0.3 == g_Vars.globals.m_flBodyPred;
		bool moving = velocity.Length() >= 1.2f;
		bool air = !(local->m_fFlags() & FL_ONGROUND);

		// off
		if (!moving && false)
			return false;
		// in air
		else if (air && !g_Vars.fakelag.when_air)
			return false;
		// moving
		else if (moving && !g_Vars.fakelag.when_moving)
			return false;

		if (g_Vars.misc.slow_walk && g_Vars.misc.slow_walk_bind.enabled)
			fakelagData->m_iMaxChoke = 14;
		else
			fakelagData->m_iMaxChoke = !moving ? 1 : (int)g_Vars.fakelag.choke;

		// addition to event delay fix to insure there is no onshot when standing still
		if (local->m_vecVelocity().Length() <= 0.1 && cmd->buttons & IN_ATTACK || local->m_flNextAttack() == Interfaces::m_pGlobalVars->curtime)
			fakelagData->m_iMaxChoke = 2;

		return true;
	}
}

```

`CSGO SDK/Features/Rage/FakeLag.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

namespace Interfaces
{
	class __declspec(novtable) FakeLag : public NonCopyable {
	public:
		static Encrypted_t<FakeLag> Get();
		virtual void Main(bool* bSendPacket, Encrypted_t<CUserCmd> cmd) = 0;
		virtual int GetFakelagChoke() const = 0;
		virtual int GetMaxFakelagChoke() const = 0;
		virtual bool IsPeeking(Encrypted_t<CUserCmd> cmd) = 0;
	protected:
		FakeLag() { };
		virtual ~FakeLag() {
		}
	};
}

```

`CSGO SDK/Features/Rage/KnifeBot.cpp`:

```cpp
#include "KnifeBot.hpp"
#include "../../SDK/Classes/player.hpp"
#include "../../source.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "LagCompensation.hpp"
#include "TickbaseShift.hpp"

// aimware knifebot
namespace Interfaces
{
	struct KnifeBotData {
		C_CSPlayer* m_pCurrentTarget = nullptr;
		C_CSPlayer* m_pLocalPlayer = nullptr;
		C_WeaponCSBaseGun* m_pLocalWeapon = nullptr;
		Encrypted_t<CCSWeaponInfo> m_pWeaponInfo = nullptr;
		Encrypted_t<CUserCmd> m_pCmd = nullptr;
		Vector m_vecEyePos;
	};

	KnifeBotData _knife_bot_data;

	class CKnifeBot : public KnifeBot {
	public:
		CKnifeBot() : knifeBotData(&_knife_bot_data) { }

		void Main(Encrypted_t<CUserCmd> pCmd, bool* sendPacket) override;
	private:
		int GetMinimalHp();
		bool TargetEntity(C_CSPlayer* pPlayer, bool* sendPacket);
		int DeterminateHitType(bool stabType, Vector eyeDelta);

		Encrypted_t<KnifeBotData> knifeBotData;
	};

	KnifeBot* KnifeBot::Get() {
		static CKnifeBot instance;
		return &instance;
	}

	void CKnifeBot::Main(Encrypted_t<CUserCmd> pCmd, bool* sendPacket) {
		if (!Interfaces::m_pEngine->IsInGame() || !g_Vars.misc.knife_bot)
			return;

		knifeBotData->m_pLocalPlayer = C_CSPlayer::GetLocalPlayer();

		if (!knifeBotData->m_pLocalPlayer || knifeBotData->m_pLocalPlayer->IsDead())
			return;

		knifeBotData->m_pLocalWeapon = (C_WeaponCSBaseGun*)knifeBotData->m_pLocalPlayer->m_hActiveWeapon().Get();

		if (!knifeBotData->m_pLocalWeapon || !knifeBotData->m_pLocalWeapon->IsWeapon())
			return;

		knifeBotData->m_pWeaponInfo = knifeBotData->m_pLocalWeapon->GetCSWeaponData();

		if (!knifeBotData->m_pWeaponInfo.IsValid() || !(knifeBotData->m_pWeaponInfo->m_iWeaponType == WEAPONTYPE_KNIFE))
			return;

		knifeBotData->m_pCmd = pCmd;

		if (knifeBotData->m_pLocalPlayer->m_flNextAttack() > Interfaces::m_pGlobalVars->curtime || knifeBotData->m_pLocalWeapon->m_flNextPrimaryAttack() > Interfaces::m_pGlobalVars->curtime)
			return;

		if (knifeBotData->m_pLocalWeapon->m_iItemDefinitionIndex() == WEAPON_ZEUS)
			return;

		knifeBotData->m_vecEyePos = knifeBotData->m_pLocalPlayer->GetEyePosition();

		for (int i = 1; i <= Interfaces::m_pGlobalVars->maxClients; i++) {
			C_CSPlayer* Target = (C_CSPlayer*)Interfaces::m_pEntList->GetClientEntity(i);
			if (!Target
				|| Target->IsDead()
				|| Target->IsDormant()
				|| !Target->IsPlayer()
				|| Target->m_iTeamNum() == knifeBotData->m_pLocalPlayer->m_iTeamNum()
				|| Target->m_bGunGameImmunity())
				continue;

			auto lag_data = Engine::LagCompensation::Get()->GetLagData(Target->m_entIndex);
			if (!lag_data.IsValid() || lag_data->m_History.empty())
				continue;

			Engine::C_LagRecord* previousRecord = nullptr;
			Engine::C_LagRecord backup;
			backup.Setup(Target);
			for (auto& record : lag_data->m_History) {
				if (!(Engine::LagCompensation::Get()->IsRecordOutOfBounds(record, 0.2f))
					|| record.m_bSkipDueToResolver
					|| !record.m_bIsValid) {
					continue;
				}

				if (!previousRecord
					|| previousRecord->m_vecOrigin != record.m_vecOrigin
					|| previousRecord->m_flEyeYaw != record.m_flEyeYaw
					|| previousRecord->m_angAngles.yaw != record.m_angAngles.yaw
					|| previousRecord->m_vecMaxs != record.m_vecMaxs
					|| previousRecord->m_vecMins != record.m_vecMins) {
					previousRecord = &record;

					record.Apply(Target);
					if (TargetEntity(Target, sendPacket)) {
						knifeBotData->m_pCmd->tick_count = TIME_TO_TICKS(record.m_flSimulationTime + g_Vars.globals.m_lerp);
						break;
					}
				}
			}

			backup.Apply(Target);
		}
	}

	int CKnifeBot::GetMinimalHp() {
		if (Interfaces::m_pGlobalVars->curtime > (knifeBotData->m_pLocalWeapon->m_flNextPrimaryAttack() + 0.4f))
			return 34;

		return 21;
	}

	bool CKnifeBot::TargetEntity(C_CSPlayer* pPlayer, bool* sendPacket) {
		knifeBotData->m_pCurrentTarget = pPlayer;

		Vector vecOrigin = pPlayer->m_vecOrigin();

		Vector vecOBBMins = pPlayer->m_Collision()->m_vecMins;
		Vector vecOBBMaxs = pPlayer->m_Collision()->m_vecMaxs;

		Vector vecMins = vecOBBMins + vecOrigin;
		Vector vecMaxs = vecOBBMaxs + vecOrigin;

		Vector vecEyePos = pPlayer->GetEyePosition();

		Vector vecPos = Math::Clamp(vecMins, vecEyePos, vecMaxs);
		Vector vecDelta = vecPos - knifeBotData->m_vecEyePos;
		vecDelta.Normalize();

		int attackType = DeterminateHitType(0, vecDelta);
		if (attackType) {
			if (g_Vars.misc.knife_bot_type == 1) {
				if (attackType == 2 && knifeBotData->m_pCurrentTarget->m_iHealth() <= 76) {
				first_attack:
					knifeBotData->m_pCmd->viewangles = vecDelta.ToEulerAngles();
					knifeBotData->m_pCmd->buttons |= IN_ATTACK;

					*sendPacket = true;

					return true;
				}
			}
			else if (g_Vars.misc.knife_bot_type == 2) {
				if (knifeBotData->m_pCurrentTarget->m_iHealth() > 46) {
					goto first_attack;
				}
			}
			else {
				int hp = attackType == 2 ? 76 : GetMinimalHp();
				if (hp >= knifeBotData->m_pCurrentTarget->m_iHealth())
					goto first_attack;
			}
		}

		if (!DeterminateHitType(1, vecDelta))
			return false;

		knifeBotData->m_pCmd->viewangles = vecDelta.ToEulerAngles();
		knifeBotData->m_pCmd->buttons |= IN_ATTACK2;

		*sendPacket = true;

		return true;
	}

	int CKnifeBot::DeterminateHitType(bool stabType, Vector eyeDelta) {
		float minDistance = stabType ? 32.0f : 48.0f;

		Vector vecEyePos = knifeBotData->m_vecEyePos;
		Vector vecEnd = vecEyePos + (eyeDelta * minDistance);
		Vector vecOrigin = knifeBotData->m_pCurrentTarget->m_vecOrigin();

		CTraceFilter filter;
		filter.pSkip = knifeBotData->m_pLocalPlayer;

		Ray_t ray;
		ray.Init(vecEyePos, vecEnd, Vector(-16.0f, -16.0f, -18.0f), Vector(16.0f, 16.0f, 18.0f));
		CGameTrace tr;
		Interfaces::m_pEngineTrace->TraceRay(ray, 0x200400B, &filter, &tr);

		if (!tr.hit_entity)
			return 0;

		if (knifeBotData->m_pCurrentTarget) {
			if (tr.hit_entity != knifeBotData->m_pCurrentTarget)
				return 0;
		}
		else { // guess this only for trigger bot
			C_CSPlayer* ent = ToCSPlayer(tr.hit_entity->GetBaseEntity());

			if (!ent || ent->IsDead() || ent->IsDormant())
				return 0;

			if (ent->m_iTeamNum() == knifeBotData->m_pLocalPlayer->m_iTeamNum())
				return 0;
		}

		QAngle angles = tr.hit_entity->GetAbsAngles();
		float cos_pitch = cos(DEG2RAD(angles.x));
		float sin_yaw, cos_yaw;
		DirectX::XMScalarSinCos(&sin_yaw, &cos_yaw, DEG2RAD(angles.yaw));

		Vector delta = vecOrigin - vecEyePos;
		return (((cos_yaw * cos_pitch * delta.x) + (sin_yaw * cos_pitch * delta.y)) >= 0.475f) + 1;
	}
}

```

`CSGO SDK/Features/Rage/KnifeBot.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

namespace Interfaces
{
	class __declspec(novtable) KnifeBot : public NonCopyable {
	public:
		static KnifeBot* Get();
		virtual void Main(Encrypted_t<CUserCmd> pCmd, bool* sendPacket) = NULL;
	protected:
		KnifeBot() {

		}
		virtual ~KnifeBot() {

		}
	};
}

```

`CSGO SDK/Features/Rage/LagCompensation.cpp`:

```cpp
#include "LagCompensation.hpp"
#include "../../source.hpp"
#include "../../SDK/Classes/player.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "../../SDK/sdk.hpp"
#include "../../SDK/Valve/CBaseHandle.hpp"

#include "../../SDK/CVariables.hpp"
#include "../../SDK/Displacement.hpp"
#include "../../SDK/core.hpp"
#include "../../Utils/FnvHash.hpp"

#include "../Visuals/EventLogger.hpp"

#include "Autowall.h"
#include "../Miscellaneous/Movement.hpp"

#include "../Game/SetupBones.hpp"
#include "../../Utils/Threading/Threading.h"
#include "../../Utils/Threading/shared_mutex.h"

#include "../../Utils/InputSys.hpp"

#include "../Rage/FakeLag.hpp"

#include "../../Hooking/Hooked.hpp"

#include "AnimationSystem.hpp"
#include "TickbaseShift.hpp"

#include <sstream>

#define MT_SETUP_BONES

namespace Engine
{
	struct LagCompData {
		std::map< int, Engine::C_EntityLagData > m_PlayerHistory;

		float m_flLerpTime, m_flOutLatency, m_flServerLatency;
		bool m_GetEvents = false;
	};

	static LagCompData _lagcomp_data;

	class C_LagCompensation : public Engine::LagCompensation {
	public:
		virtual void Update();
		virtual bool IsRecordOutOfBounds(const Engine::C_LagRecord& record, float target_time = 0.2f, int tickbase_shift = -1, bool bDeadTimeCheck = true) const;

		virtual Encrypted_t<C_EntityLagData> GetLagData(int entindex) {
			C_EntityLagData* data = nullptr;
			if (lagData->m_PlayerHistory.count(entindex) > 0)
				data = &lagData->m_PlayerHistory.at(entindex);
			return Encrypted_t<C_EntityLagData>(data);
		}

		virtual float GetLerp() const {
			return std::max(g_Vars.cl_interp->GetFloat(), g_Vars.cl_interp_ratio->GetFloat() / g_Vars.cl_updaterate->GetFloat());
		}

		virtual void ClearLagData() {
			lagData->m_PlayerHistory.clear();
		}

		C_LagCompensation() : lagData(&_lagcomp_data) { };
		virtual ~C_LagCompensation() { };
	private:
		virtual void SetupLerpTime();
		Encrypted_t<LagCompData> lagData;
	};

	C_LagCompensation g_LagComp;
	Engine::LagCompensation* Engine::LagCompensation::Get() {
		return &g_LagComp;
	}

	Engine::C_EntityLagData::C_EntityLagData() {
		;
	}

	void C_LagCompensation::Update() {
		if (!Interfaces::m_pEngine->IsInGame() || !Interfaces::m_pEngine->GetNetChannelInfo()) {
			lagData->m_PlayerHistory.clear();
			return;
		}

		auto updateReason = 0;

		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local || !g_Vars.globals.HackIsReady)
			return;

		SetupLerpTime();

		for (int i = 1; i <= Interfaces::m_pGlobalVars->maxClients; ++i) {
			auto player = C_CSPlayer::GetPlayerByIndex(i);
			if (!player || player == local || !player->IsPlayer())
				continue;

			player_info_t player_info;
			if (!Interfaces::m_pEngine->GetPlayerInfo(player->m_entIndex, &player_info)) {
				continue;
			}

			if (!player->GetClientRenderable())
				continue;

			if (Hooked::player_hooks.count(player->m_entIndex) < 1)
				continue;

			auto lag_data = Encrypted_t<C_EntityLagData>(&lagData->m_PlayerHistory[player->m_entIndex]);
			lag_data->UpdateRecordData(lag_data, player, player_info, updateReason);
		}
	}

	bool C_LagCompensation::IsRecordOutOfBounds(const Engine::C_LagRecord& record, float flTargetTime, int nTickbaseShiftTicks, bool bDeadTimeCheck) const {
		Encrypted_t<INetChannel> pNetChannel = Encrypted_t<INetChannel>(Interfaces::m_pEngine->GetNetChannelInfo());
		if (!pNetChannel.IsValid())
			return true;

		C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer();
		if (!pLocal)
			return true;

		// use prediction curtime for this.
		float curtime = TICKS_TO_TIME(pLocal->m_nTickBase());

		// correct is the amount of time we have to correct game time,
		float correct = g_Vars.globals.m_lerp + pNetChannel->GetLatency(FLOW_OUTGOING);

		// stupid fake latency goes into the incoming latency.
		float in = pNetChannel->GetLatency(FLOW_INCOMING);
		correct += in;

		// check bounds [ 0, sv_maxunlag ]
		std::clamp(correct, 0.f, 1.f);

		// calculate difference between tick sent by player and our latency based tick.
		// ensure this record isn't too old.
		return std::abs(correct - (curtime - record.m_flSimulationTime)) < (0.2f - Interfaces::m_pGlobalVars->interval_per_tick);
	}

	void C_LagCompensation::SetupLerpTime() {
		float updaterate = g_Vars.cl_updaterate->GetFloat();

		float minupdaterate = g_Vars.sv_minupdaterate->GetFloat();
		float maxupdaterate = g_Vars.sv_maxupdaterate->GetFloat();

		float min_interp = g_Vars.sv_client_min_interp_ratio->GetFloat();
		float max_interp = g_Vars.sv_client_max_interp_ratio->GetFloat();

		float flLerpAmount = g_Vars.cl_interp->GetFloat();
		float flLerpRatio = g_Vars.cl_interp_ratio->GetFloat();
		flLerpRatio = Math::Clamp(flLerpRatio, min_interp, max_interp);
		
		if (flLerpRatio == 0.0f)
			flLerpRatio = 1.0f;

		float updateRate = Math::Clamp(updaterate, minupdaterate, maxupdaterate);
		lagData->m_flLerpTime = std::fmaxf(flLerpAmount, flLerpRatio / updateRate);

		auto netchannel = Encrypted_t<INetChannel>(Interfaces::m_pEngine->GetNetChannelInfo());
		lagData->m_flOutLatency = netchannel->GetLatency(FLOW_OUTGOING);
		lagData->m_flServerLatency = netchannel->GetLatency(FLOW_INCOMING);
	}

	void Engine::C_EntityLagData::UpdateRecordData(Encrypted_t< C_EntityLagData > pThis, C_CSPlayer* player, const player_info_t& info, int updateType) {
		auto local = C_CSPlayer::GetLocalPlayer();
		auto team_check = g_Vars.rage.enabled && !g_Vars.rage.team_check && player->IsTeammate(C_CSPlayer::GetLocalPlayer());
		if (player->IsDead() || team_check) {
			pThis->m_History.clear();
			pThis->m_flLastUpdateTime = 0.0f;
			pThis->m_flLastScanTime = 0.0f;
			return;
		}

		// no need to store insane amount of data
		while (pThis->m_History.size() > int(1.0f / Interfaces::m_pGlobalVars->interval_per_tick)) {
			pThis->m_History.pop_back();
		}

		if (player->IsDormant()) {
			pThis->m_flLastUpdateTime = 0.0f;
			if (pThis->m_History.size() > 0 && pThis->m_History.front().m_bTeleportDistance) {
				pThis->m_History.clear();
			}

			return;
		}

		if (info.userId != pThis->m_iUserID) {
			pThis->Clear();
			pThis->m_iUserID = info.userId;
		}

		// did player update?
		float simTime = player->m_flSimulationTime();
		if (pThis->m_flLastUpdateTime >= simTime) {
			return;
		}

		if (player->m_flOldSimulationTime() > simTime) {
			return;
		}

		auto anim_data = AnimationSystem::Get()->GetAnimationData(player->m_entIndex);
		if (!anim_data)
			return;

		if (anim_data->m_AnimationRecord.empty())
			return;

		auto anim_record = &anim_data->m_AnimationRecord.front();
		if (anim_record->m_bShiftingTickbase)
			return;

		pThis->m_flLastUpdateTime = simTime;


		// add new record and get reference to newly added record.
		auto record = Encrypted_t<C_LagRecord>(&pThis->m_History.emplace_front());

		record->Setup(player);
		record->m_flRealTime = Interfaces::m_pEngine->GetLastTimeStamp();
		record->m_flServerLatency = Engine::LagCompensation::Get()->m_flServerLatency;
		record->m_flDuckAmount = anim_record->m_flDuckAmount;
		record->m_flEyeYaw = anim_record->m_angEyeAngles.yaw;
		record->m_flEyePitch = anim_record->m_angEyeAngles.pitch;
		record->m_bIsShoting = anim_record->m_bIsShooting;
		record->m_bIsValid = !anim_record->m_bIsInvalid;
		record->m_bBonesCalculated = anim_data->m_bBonesCalculated;
		record->m_flAnimationVelocity = player->m_PlayerAnimState()->m_velocity;
		record->m_bTeleportDistance = anim_record->m_bTeleportDistance;
		record->m_flAbsRotation = player->m_PlayerAnimState()->m_flAbsRotation;
		record->m_iLaggedTicks = TIME_TO_TICKS(player->m_flSimulationTime() - player->m_flOldSimulationTime());
		record->m_bResolved = anim_record->m_bResolved;
		record->m_iResolverMode = anim_record->m_iResolverMode;

		std::memcpy(record->m_BoneMatrix, anim_data->m_Bones, player->m_CachedBoneData().Count() * sizeof(matrix3x4_t));
	}

	void Engine::C_EntityLagData::Clear() {
		this->m_History.clear();
		m_iUserID = -1;
		m_flLastScanTime = 0.0f;
		m_flLastUpdateTime = 0.0f;
	}

	float C_LagRecord::GetAbsYaw() {
		return this->m_angAngles.yaw;
	}

	matrix3x4_t* C_LagRecord::GetBoneMatrix() {
		if (!this->m_bBonesCalculated)
			return this->m_BoneMatrix;

		return this->m_BoneMatrix;
	}

	void Engine::C_LagRecord::Setup(C_CSPlayer* player) {
		auto collidable = player->m_Collision();
		this->m_vecMins = collidable->m_vecMins;
		this->m_vecMaxs = collidable->m_vecMaxs;

		this->m_vecOrigin = player->GetAbsOrigin();
		this->m_angAngles = player->GetAbsAngles();

		this->m_vecVelocity = player->m_vecVelocity();
		this->m_flSimulationTime = player->m_flSimulationTime();

		this->m_iFlags = player->m_fFlags();

		std::memcpy(this->m_BoneMatrix, player->m_CachedBoneData().Base(),
			player->m_CachedBoneData().Count() * sizeof(matrix3x4_t));

		this->player = player;
	}

	void Engine::C_LagRecord::Apply(C_CSPlayer* player) {
		auto collidable = player->m_Collision();
		collidable->SetCollisionBounds(this->m_vecMins, this->m_vecMaxs);

		player->m_flSimulationTime() = this->m_flSimulationTime;

		QAngle absAngles = this->m_angAngles;
		absAngles.yaw = this->GetAbsYaw();

		player->m_fFlags() = this->m_iFlags;

		player->SetAbsAngles(absAngles);
		player->SetAbsOrigin(this->m_vecOrigin);

		matrix3x4_t* matrix = GetBoneMatrix();

		if (matrix) {
			std::memcpy(player->m_CachedBoneData().Base(), matrix,
				player->m_CachedBoneData().Count() * sizeof(matrix3x4_t));

			// force bone cache
			player->m_iMostRecentModelBoneCounter() = *(int*)Engine::Displacement.Data.m_uModelBoneCounter;
			player->m_BoneAccessor().m_ReadableBones = player->m_BoneAccessor().m_WritableBones = 0xFFFFFFFF;
			player->m_flLastBoneSetupTime() = FLT_MAX;
		}
	}

	void C_BaseLagRecord::Setup(C_CSPlayer* player) {
		auto collidable = player->m_Collision();
		this->m_vecMins = collidable->m_vecMins;
		this->m_vecMaxs = collidable->m_vecMaxs;

		this->m_flSimulationTime = player->m_flSimulationTime();

		this->m_angAngles = player->GetAbsAngles();
		this->m_vecOrigin = player->GetAbsOrigin();

		if (player->m_PlayerAnimState() != nullptr)
			this->m_flAbsRotation = player->m_PlayerAnimState()->m_flAbsRotation;

		std::memcpy(this->m_BoneMatrix, player->m_CachedBoneData().Base(),
			player->m_CachedBoneData().Count() * sizeof(matrix3x4_t));

		this->player = player;
	}

	void C_BaseLagRecord::Apply(C_CSPlayer* player) {
		auto collidable = player->m_Collision();
		collidable->SetCollisionBounds(this->m_vecMins, this->m_vecMaxs);

		player->m_flSimulationTime() = this->m_flSimulationTime;

		player->SetAbsAngles(this->m_angAngles);
		player->SetAbsOrigin(this->m_vecOrigin);

		if (player->m_PlayerAnimState() != nullptr)
			player->m_PlayerAnimState()->m_flAbsRotation = this->m_flAbsRotation;

		std::memcpy(player->m_CachedBoneData().Base(), this->m_BoneMatrix,
			player->m_CachedBoneData().Count() * sizeof(matrix3x4_t));

		// force bone cache
		player->m_iMostRecentModelBoneCounter() = *(int*)Engine::Displacement.Data.m_uModelBoneCounter;
		player->m_BoneAccessor().m_ReadableBones = player->m_BoneAccessor().m_WritableBones = 0xFFFFFFFF;
		player->m_flLastBoneSetupTime() = FLT_MAX;
	}
}

```

`CSGO SDK/Features/Rage/LagCompensation.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

#include "../../SDK/Classes/weapon.hpp"
#include "../../SDK/Classes/Player.hpp"

#include <map>
#include <deque>
#include "AnimationSystem.hpp"

namespace Engine
{
	// base lag record, generally used for backup and restore
	class C_BaseLagRecord {
	public:
		C_CSPlayer* player = nullptr;
		Vector m_vecMins, m_vecMaxs;
		Vector m_vecOrigin;
		QAngle m_angAngles;
		float m_flAbsRotation;

		float m_flSimulationTime;

		alignas(16) matrix3x4_t m_BoneMatrix[128];

		void Setup(C_CSPlayer* player);
		void Apply(C_CSPlayer* player);
	};

	// full lag record, will be stored in lag compensation history
	class C_LagRecord : public C_BaseLagRecord {
	public:
		float m_flServerLatency;
		float m_flRealTime;
		float m_flLastShotTime;
		float m_flEyeYaw;
		float m_flEyePitch;
		float m_flAnimationVelocity;

		bool m_bIsShoting;
		bool m_bIsValid;
		bool m_bBonesCalculated;
		bool m_bResolved;
		bool m_bIsWalking;
		bool m_bIsRunning;
		bool m_bIsSideways;
		float m_flAbsRotation;

		int m_iFlags;
		int m_iLaggedTicks = 0;
		int m_iResolverMode;

		float m_flInterpolateTime = 0.f;

		// for sorting
		Vector m_vecVelocity;
		float m_flDuckAmount;

		bool m_bSkipDueToResolver = false; // skip record in hitscan
		bool m_bTeleportDistance = false; // teleport distance was broken

		float GetAbsYaw();
		matrix3x4_t* GetBoneMatrix();
		void Setup(C_CSPlayer* player);
		void Apply(C_CSPlayer* player);
	};

	class C_EntityLagData {
	public:
		C_EntityLagData();

		static void UpdateRecordData(Encrypted_t< C_EntityLagData > pThis, C_CSPlayer* player, const player_info_t& info, int updateType);

		void Clear();

		std::deque<Engine::C_LagRecord> m_History = {};
		int m_iUserID = -1;

		float m_flLastUpdateTime = 0.0f;
		float m_flRate = 0.0f;

		int m_iMissedShots;
		int m_iMissedShotsLBY;
		int m_iMissedShotsLastmove;
		int m_iMissedShotsFreestand;
		int m_iMissedShotsBrute;
		int m_iMissedShotsAir;
		int m_iMissedShotsDistort;
		bool m_bHitLastMove = false;
		std::deque< float > m_flLastMoveYaw;

		bool m_bGotAbsYaw = false;
		bool m_bGotAbsYawShot = false;
		bool m_bNotResolveIfShooting = false;
		bool m_bRateCheck = false;
		float m_flAbsYawHandled = 0.f;

		// ragebot scan data
		float m_flLastSpread, m_flLastInaccuracy;
		float m_flLastScanTime;
		Vector m_vecLastScanPos;

		// autowall resolver stuff
		float m_flEdges[4];
		float m_flDirection;
	};

	class __declspec(novtable) LagCompensation : public NonCopyable {
	public:
		static LagCompensation* Get();

		virtual void Update() = 0;
		virtual bool IsRecordOutOfBounds(const Engine::C_LagRecord& record, float target_time = 0.2f, int tickbase_shift = -1, bool tick_count_check = true) const = 0;;
		virtual float GetLerp() const = 0;

		virtual Encrypted_t<C_EntityLagData> GetLagData(int entindex) = 0;

		virtual void ClearLagData() = 0;

		float m_flOutLatency;
		float m_flServerLatency;
	protected:
		LagCompensation() { };
		virtual ~LagCompensation() { };
	};
}

```

`CSGO SDK/Features/Rage/Ragebot.cpp`:

```cpp
#include "../../source.hpp"

#include "Ragebot.hpp"
#include "LagCompensation.hpp"
#include "../Miscellaneous/Movement.hpp"
#include "../Game/Prediction.hpp"
#include "Autowall.h"
#include "Fakelag.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "../../SDK/Valve/CBaseHandle.hpp"
#include "../../Utils/InputSys.hpp"
#include "../../Renderer/Render.hpp"
#include "../../Utils/Threading/threading.h"
#include <algorithm>
#include <atomic>
#include <thread>
#include "../../SDK/RayTracer.h"
#include "../../SDK/Displacement.hpp"
#include "ShotInformation.hpp"
#include "../Visuals/EventLogger.hpp"
#include "ShotInformation.hpp"
#include "TickbaseShift.hpp"
#include "../Game/SimulationContext.hpp"
#include "../Visuals/ESP.hpp"
#include "Resolver.hpp"
#include "../Visuals/CChams.hpp"

#include <sstream>

extern int LastShotTime;

// TODO: 
// Refactoring
// Rework exploits

enum OverrideConditions {
	OnShot,
	Running,
	Walking,
	InAir,
	Standing,
	Backward,
	Sideways,
	InDuck,
	DoubleTap,
};

typedef __declspec(align(16)) union {
	float f[4];
	__m128 v;
} m128;

auto round_to_multiple = [&](int in, int multiple) {
	const auto ratio = static_cast<double>(in) / multiple;
	const auto iratio = std::lround(ratio);
	return static_cast<int>(iratio * multiple);
};


__forceinline __m128 sqrt_ps(const __m128 squared) {
	return _mm_sqrt_ps(squared);
}

struct BoundingBox {
	Vector min, max;
	int idx;

	BoundingBox(void) { };
	BoundingBox(const Vector& min, const Vector& max, int idx) :
		min(min), max(max), idx(idx) {
	};
};

struct CapsuleHitbox {
	CapsuleHitbox() = default;
	CapsuleHitbox(const Vector& mins, const Vector& maxs, const float radius, int idx)
		: m_mins(mins), m_maxs(maxs), m_radius(radius), m_idx(idx) {
	}

	Vector m_mins;
	Vector m_maxs;
	float m_radius;
	int m_idx;
};

#define SMALL_NUM   0.00000001 // anything that avoids division overflow
#define dot(u,v)   ((u).x * (v).x + (u).y * (v).y + (u).z * (v).z)
#define norm(v)    sqrt(dot(v,v))  // norm = length of  vector

int convert_hitbox_to_hitgroup(int hitbox) {
	switch (hitbox) {
	case HITBOX_HEAD:
	case HITBOX_NECK:
	case HITBOX_LOWER_NECK:
		return Hitgroup_Head;
	case HITBOX_UPPER_CHEST:
	case HITBOX_CHEST:
	case HITBOX_LOWER_CHEST:
	case HITBOX_LEFT_UPPER_ARM:
	case HITBOX_RIGHT_UPPER_ARM:
		return Hitgroup_Chest;
	case HITBOX_PELVIS:
	case HITBOX_LEFT_THIGH:
	case HITBOX_RIGHT_THIGH:
	case HITBOX_STOMACH:
		return Hitgroup_Stomach;
	case HITBOX_LEFT_CALF:
	case HITBOX_LEFT_FOOT:
		return Hitgroup_LeftLeg;
	case HITBOX_RIGHT_CALF:
	case HITBOX_RIGHT_FOOT:
		return Hitgroup_RightLeg;
	case HITBOX_LEFT_FOREARM:
	case HITBOX_LEFT_HAND:
		return Hitgroup_LeftArm;
	case HITBOX_RIGHT_FOREARM:
	case HITBOX_RIGHT_HAND:
		return Hitgroup_RightArm;
	default:
		return Hitgroup_Stomach;
	}
}

void get_edge(Vector& end, const Vector& start, float range, C_CSPlayer* player) {
	Ray_t ray;
	if (range > 0.0f)
		ray.Init(start, end, Vector(-range, -range, -range), Vector(range, range, range));
	else
		ray.Init(start, end);

	CTraceFilter filter;
	filter.pSkip = player;

	CGameTrace trace;
	Interfaces::m_pEngineTrace->TraceRay(ray, 0x46004003u, &filter, &trace);
	if (trace.fraction <= 0.99f) {
		end = start + ((end - start) * trace.fraction);
	}
};

namespace Interfaces
{
	bool EyeCompare(const Vector& a, const Vector& b) {
		auto round_eye = [](const Vector& vec) {
			return Vector(
				std::roundf(vec.x * 1000.0f) / 1000.0f,
				std::roundf(vec.y * 1000.0f) / 1000.0f,
				std::roundf(vec.z * 1000.0f) / 1000.0f
			);
		};

		return round_eye(a) == round_eye(b);
	};

	struct C_AimTarget;
	struct C_AimPoint;

	struct C_AimPoint {
		Vector position;

		float damage = 0.0f;
		float hitchance = 0.0f;
		float pointscale = 0.0f;

		int healthRatio = 0;
		int hitboxIndex = 0;
		int hitgroup = 0;

		bool center = false;
		bool penetrated = false;
		bool isLethal = false;
		bool isHead = false;
		bool isBody = false;
		bool is_should_baim = false;
		bool is_should_headaim = false;

		C_AimTarget* target = nullptr;
		Engine::C_LagRecord* record = nullptr;
		Engine::C_AnimationRecord* animrecord = nullptr;
	};

	struct C_AimTarget {
		std::vector<C_AimPoint> points;
		std::vector<BoundingBox> obb;
		std::vector<CapsuleHitbox> capsules;
		Engine::C_BaseLagRecord backup;
		Engine::C_LagRecord* record = nullptr;
		Engine::C_AnimationRecord* animrecord = nullptr;
		C_CSPlayer* player = nullptr;
		bool overrideHitscan = false;
		bool preferHead = false;
		bool preferBody = false;
		bool hasLethal = false;
		bool onlyHead = false;
		bool hasCenter = false;
	};

	struct C_PointsArray {
		C_AimPoint* points = nullptr;
		int pointsCount = 0;
	};

	struct C_HitchanceData {
		Vector direction;
		Vector end;
		bool hit = false;
		bool damageIsAccurate = false;
	};

	struct C_HitchanceArray {
		C_AimPoint* point;
		C_HitchanceData* data;
		int dataCount;
	};

	// hitchance

	struct RagebotData {
		// spread cone
		float m_flSpread;
		float m_flInaccuracy;

		Encrypted_t<CUserCmd> m_pCmd = nullptr;
		C_CSPlayer* m_pLocal = nullptr;
		C_WeaponCSBaseGun* m_pWeapon = nullptr;
		Encrypted_t<CCSWeaponInfo>  m_pWeaponInfo = nullptr;
		bool* m_pSendPacket = nullptr;
		C_CSPlayer* m_pLastTarget = nullptr;

		std::vector<C_AimTarget> m_targets;
		std::vector<C_AimPoint> m_aim_points;
		std::vector<C_AimTarget> m_aim_data;

		C_AimTarget* m_pBestTarget;


		Vector m_vecEyePos;

		// last entity iterated in list
		int m_nIterativeTarget = 0;

		// failed hitchance this tick
		bool m_bFailedHitchance = false;

		// no need to autoscope
		bool m_bNoNeededScope = false;

		bool m_bResetCmd = false;
		bool m_bRePredict = false;
		int m_RestoreZoomLevel = INT_MAX;

		bool m_bPredictedScope = false;

		int m_iChokedCommands = -1;
		int m_iDelay = 0;

		bool m_bDelayedHeadAim = false;

		CVariables::RAGE* rbot = nullptr;

		// delay shot
		Vector m_PeekingPosition;
		float m_flLastPeekTime;

		bool m_bDebugGetDamage = false;

		bool m_bEarlyStop = false;

		// hitchance
		static std::vector<std::tuple<float, float, float>> precomputed_seeds;
	};

	static RagebotData _rage_data;

	class C_Ragebot : public Ragebot {
	public:
		// only sanity checks, etc.
		virtual bool Run(Encrypted_t<CUserCmd> cmd, C_CSPlayer* local, bool* sendPacket);

		virtual bool GetBoxOption(mstudiobbox_t* hitbox, mstudiohitboxset_t* hitboxSet, float& ps, bool override_hitscan) {
			if (!hitbox)
				return false;

			if (!hitboxSet)
				return false;

			// sloppy as shit, i know
			if (g_Vars.rage.hitbox_override_bind.enabled)
			{
				if (hitboxSet->pHitbox(HITBOX_PELVIS) == hitbox) {
					ps = m_rage_data->rbot->body_point_scale;
					return m_rage_data->rbot->hitboxes_ovr_pelvis;
				}

				if (hitboxSet->pHitbox(HITBOX_RIGHT_FOOT) == hitbox || hitboxSet->pHitbox(HITBOX_LEFT_FOOT) == hitbox) {
					ps = m_rage_data->rbot->point_scale;
					return m_rage_data->rbot->hitboxes_ovr_feets;
				}

				switch (hitbox->group) {
				case Hitgroup_Head:

					if (override_hitscan)
						return false;

					ps = m_rage_data->rbot->point_scale;

					return (m_rage_data->rbot->hitboxes_ovr_head);
					break;
				case Hitgroup_Neck: // just neck

					if (override_hitscan)
						return false;

					ps = m_rage_data->rbot->point_scale;
					return  (m_rage_data->rbot->hitboxes_ovr_neck);
					break;
				case Hitgroup_Chest:

					ps = m_rage_data->rbot->point_scale;
					return m_rage_data->rbot->hitboxes_ovr_chest;
					break;
				case Hitgroup_Stomach:
					ps = m_rage_data->rbot->body_point_scale;
					return m_rage_data->rbot->hitboxes_ovr_stomach;
					break;
				case Hitgroup_RightLeg:
				case Hitgroup_LeftLeg:
					if (hitboxSet->pHitbox(HITBOX_RIGHT_FOOT) != hitbox && hitboxSet->pHitbox(HITBOX_LEFT_FOOT) != hitbox) {
						ps = m_rage_data->rbot->point_scale;
						return m_rage_data->rbot->hitboxes_ovr_legs;
					}
					break;
				case Hitgroup_RightArm:
				case Hitgroup_LeftArm:
					ps = m_rage_data->rbot->point_scale;
					return m_rage_data->rbot->hitboxes_ovr_arms;
					break;
				default:
					return false;
					break;
				}
			}
			else
			{
				if (hitboxSet->pHitbox(HITBOX_PELVIS) == hitbox) {
					ps = m_rage_data->rbot->body_point_scale;
					return m_rage_data->rbot->hitboxes_pelvis;
				}

				if (hitboxSet->pHitbox(HITBOX_RIGHT_FOOT) == hitbox || hitboxSet->pHitbox(HITBOX_LEFT_FOOT) == hitbox) {
					ps = m_rage_data->rbot->point_scale;
					return m_rage_data->rbot->hitboxes_feets;
				}

				switch (hitbox->group) {
				case Hitgroup_Head:

					if (override_hitscan)
						return false;

					ps = m_rage_data->rbot->point_scale;

					return (m_rage_data->rbot->hitboxes_head);
					break;
				case Hitgroup_Neck: // just neck

					if (override_hitscan)
						return false;

					ps = m_rage_data->rbot->point_scale;
					return  (m_rage_data->rbot->hitboxes_neck);
					break;
				case Hitgroup_Chest:

					ps = m_rage_data->rbot->point_scale;
					return m_rage_data->rbot->hitboxes_chest;
					break;
				case Hitgroup_Stomach:
					ps = m_rage_data->rbot->body_point_scale;
					return m_rage_data->rbot->hitboxes_stomach;
					break;
				case Hitgroup_RightLeg:
				case Hitgroup_LeftLeg:
					if (hitboxSet->pHitbox(HITBOX_RIGHT_FOOT) != hitbox && hitboxSet->pHitbox(HITBOX_LEFT_FOOT) != hitbox) {
						ps = m_rage_data->rbot->point_scale;
						return m_rage_data->rbot->hitboxes_legs;
					}
					break;
				case Hitgroup_RightArm:
				case Hitgroup_LeftArm:
					ps = m_rage_data->rbot->point_scale;
					return m_rage_data->rbot->hitboxes_arms;
					break;
				default:
					return false;
					break;
				}
			}
		};

		// should override condition
		virtual bool OverrideHitscan(C_CSPlayer* player, Engine::C_LagRecord* record);

		// return true if rage enabled
		virtual bool SetupRageOptions();

		virtual void Multipoint(C_CSPlayer* player, Engine::C_LagRecord* record, int side, std::vector<std::pair<Vector, bool>>& points, mstudiobbox_t* hitbox, mstudiohitboxset_t* hitboxSet, float& ps, int hitboxIndex);
	public:
		C_Ragebot() : m_rage_data(&_rage_data) { };
		virtual ~C_Ragebot() { };

	private:
		// run aimbot itself
		virtual bool RunInternal();

		// aim at point
		virtual bool AimAtPoint(C_AimPoint* bestPoint);

		// get theoretical hit chance
		virtual bool Hitchance(C_AimPoint* point, const Vector& start, float chance);

		__forceinline bool IsPointAccurate(C_AimPoint* point, const Vector& start);

		virtual void AddPoint(C_CSPlayer* player, Engine::C_LagRecord* record, int side, std::vector<std::pair<Vector, bool>>& points, const Vector& point, mstudiobbox_t* hitbox, mstudiohitboxset_t* hitboxSet, bool isMultipoint);

		virtual std::pair<bool, C_AimPoint> RunHitscan();

		void ScanPoint(C_AimPoint* pPoint);

		// sort records, choose best and calculate damage
		// return true if target is valid
		__forceinline int GeneratePoints(C_CSPlayer* player, std::vector<C_AimTarget>& aim_targets, std::vector<C_AimPoint>& aim_points);
		virtual Engine::C_LagRecord* GetBestLagRecord(C_CSPlayer* player, Engine::C_BaseLagRecord* backup);

		virtual bool IsRecordValid(C_CSPlayer* player, Engine::C_LagRecord* record);

		__forceinline bool SetupTargets();

		__forceinline void SelectBestTarget();

		Encrypted_t<RagebotData> m_rage_data;
	};

	bool C_Ragebot::Run(Encrypted_t<CUserCmd> cmd, C_CSPlayer* local, bool* sendPacket) {
		if (!g_Vars.rage.enabled || !g_Vars.rage.key.enabled)
			return false;

		if (!g_Vars.globals.RandomInit) {
			return false;
		}

		auto weapon = (C_WeaponCSBaseGun*)local->m_hActiveWeapon().Get();
		if (!weapon) {
			return false;
		}

		auto weaponInfo = weapon->GetCSWeaponData();
		if (!weaponInfo.IsValid()) {
			return false;
		}

		// run aim on zeus
		if (weapon->m_iItemDefinitionIndex() != WEAPON_ZEUS
			&& (weaponInfo->m_iWeaponType == WEAPONTYPE_KNIFE || weaponInfo->m_iWeaponType == WEAPONTYPE_GRENADE || weaponInfo->m_iWeaponType == WEAPONTYPE_C4))
			return false;

		if (!SetupRageOptions())
			return false;

		if (!local || local->IsDead()) {
			m_rage_data->m_pLastTarget = nullptr;
			m_rage_data->m_bFailedHitchance = false;
			return false;
		}

		m_rage_data->m_pLocal = local;
		m_rage_data->m_pWeapon = weapon;
		m_rage_data->m_pWeaponInfo = weaponInfo;
		m_rage_data->m_pSendPacket = sendPacket;
		m_rage_data->m_pCmd = cmd;
		m_rage_data->m_bEarlyStop = false;
		g_Vars.globals.OverridingMinDmg = m_rage_data->rbot->min_damage_override && g_Vars.rage.key_dmg_override.enabled;


		if (weapon->m_iItemDefinitionIndex() == WEAPON_REVOLVER) {
			if (!(m_rage_data->m_pCmd->buttons & IN_RELOAD) && weapon->m_iClip1()) {
				static float cockTime = 0.f;
				float curtime = local->m_nTickBase() * Interfaces::m_pGlobalVars->interval_per_tick;
				m_rage_data->m_pCmd->buttons &= ~IN_ATTACK2;
				if (m_rage_data->m_pLocal->CanShoot(true)) {
					if (cockTime <= curtime) {
						if (weapon->m_flNextSecondaryAttack() <= curtime)
							cockTime = curtime + 0.234375f;
						else
							m_rage_data->m_pCmd->buttons |= IN_ATTACK2;
					}
					else
						m_rage_data->m_pCmd->buttons |= IN_ATTACK;
				}
				else {
					cockTime = curtime + 0.234375f;
					m_rage_data->m_pCmd->buttons &= ~IN_ATTACK;
				}
			}
		}
		else if (!this->m_rage_data->m_pLocal->CanShoot()) {
			if (!m_rage_data->m_pWeaponInfo->m_bFullAuto)
				m_rage_data->m_pCmd->buttons &= ~IN_ATTACK;

			if (Interfaces::m_pGlobalVars->curtime < m_rage_data->m_pLocal->m_flNextAttack()
				|| m_rage_data->m_pWeapon->m_iClip1() < 1)
				return false;
		}

		if (m_rage_data->m_pLastTarget != nullptr && m_rage_data->m_pLastTarget->IsDead()) {
			m_rage_data->m_pLastTarget = nullptr;
		}

		bool ret = RunInternal();

		return ret;
	}

	bool C_Ragebot::SetupRageOptions() {
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local || local->IsDead())
			return false;

		auto weapon = (C_WeaponCSBaseGun*)local->m_hActiveWeapon().Get();
		if (!weapon)
			return false;

		auto weaponInfo = weapon->GetCSWeaponData();
		if (!weaponInfo.IsValid())
			return false;

		m_rage_data->m_pWeapon = weapon;
		m_rage_data->m_pWeaponInfo = weaponInfo;

		auto id = weapon->m_iItemDefinitionIndex();
		if (id == WEAPON_ZEUS)
			return false;

		switch (weaponInfo->m_iWeaponType) {
		case WEAPONTYPE_PISTOL:
			if (id == WEAPON_DEAGLE || id == WEAPON_REVOLVER)
				m_rage_data->rbot = &g_Vars.rage_heavypistols;
			else
				m_rage_data->rbot = &g_Vars.rage_pistols;
			break;
		case WEAPONTYPE_SUBMACHINEGUN:
			m_rage_data->rbot = &g_Vars.rage_smgs;
			break;
		case WEAPONTYPE_RIFLE:
			m_rage_data->rbot = &g_Vars.rage_rifles;
			break;
		case WEAPONTYPE_SHOTGUN:
			m_rage_data->rbot = &g_Vars.rage_shotguns;
			break;
		case WEAPONTYPE_SNIPER_RIFLE:
			if (id == WEAPON_G3SG1 || id == WEAPON_SCAR20)
				m_rage_data->rbot = &g_Vars.rage_autosnipers;
			else
				m_rage_data->rbot = (id == WEAPON_AWP) ? &g_Vars.rage_awp : &g_Vars.rage_scout;
			break;
		case WEAPONTYPE_MACHINEGUN:
			m_rage_data->rbot = &g_Vars.rage_heavys;
			break;
		default:
			m_rage_data->rbot = &g_Vars.rage_default;
			break;
		}

		if (!m_rage_data->rbot)
			return false;

		if (!m_rage_data->rbot->active) {
			m_rage_data->rbot = &g_Vars.rage_default;
		}

		return m_rage_data->rbot->active;
	}

	bool C_Ragebot::RunInternal() {
		auto cmd_backup = *m_rage_data->m_pCmd.Xor();

		//m_rage_data->m_bResetCmd = true;
		m_rage_data->m_bRePredict = false;
		m_rage_data->m_bPredictedScope = false;
		m_rage_data->m_bNoNeededScope = true;

		m_rage_data->m_flSpread = m_rage_data->m_pWeapon->GetSpread();
		m_rage_data->m_flInaccuracy = m_rage_data->m_pWeapon->GetInaccuracy();

		//ILoggerEvent::Get( )->PushEvent( std::to_string( m_rage_data->m_flInaccuracy ), FloatColor::White, true, "debug" );

		auto success = RunHitscan();
		//if( success.first ) {
		//	m_rage_data->m_bResetCmd = false;
		//}

		const bool bOnLand = !(Engine::Prediction::Instance().GetFlags() & FL_ONGROUND) && m_rage_data->m_pLocal->m_fFlags() & FL_ONGROUND;

		// if failed at hitchancing or aimbot good
		float feet = 0.f;
		if ((m_rage_data->m_pWeapon->m_iItemDefinitionIndex() == WEAPON_SCAR20 || m_rage_data->m_pWeapon->m_iItemDefinitionIndex() == WEAPON_G3SG1) && success.second.target && success.second.target->player) {
			auto dist = (m_rage_data->m_pLocal->m_vecOrigin().Distance(success.second.target->player->m_vecOrigin()));
			auto meters = dist * 0.0254f;
			feet = round_to_multiple(meters * 3.281f, 5);
		}

		bool htcFailed = m_rage_data->m_bFailedHitchance;
		if (m_rage_data->m_bFailedHitchance) {



			m_rage_data->m_bFailedHitchance = false;

			m_rage_data->m_bNoNeededScope = false;
		}


		if (feet > 0.f) {
			if (feet <= 60.f) {
				m_rage_data->m_bNoNeededScope = true;
			}
			else {
				m_rage_data->m_bNoNeededScope = false;
			}

			if (g_Vars.misc.fakeduck && g_Vars.misc.fakeduck_bind.enabled)
				m_rage_data->m_bNoNeededScope = false;
		}

		if (m_rage_data->rbot->autoscope &&
			m_rage_data->m_pWeaponInfo->m_iWeaponType == WEAPONTYPE_SNIPER_RIFLE &&
			m_rage_data->m_pWeapon->m_zoomLevel() <= 0 &&
			m_rage_data->m_pLocal->m_fFlags() & FL_ONGROUND &&
			!m_rage_data->m_bNoNeededScope) {
			m_rage_data->m_pCmd->buttons |= IN_ATTACK2;
			m_rage_data->m_pCmd->buttons &= ~IN_ATTACK;
			m_rage_data->m_pWeapon->m_zoomLevel() = 1;
			m_rage_data->m_bPredictedScope = true;
			m_rage_data->m_bRePredict = true;
			//m_rage_data->m_bResetCmd = false;
		}

		auto correction = m_rage_data->m_pLocal->m_aimPunchAngle() * g_Vars.weapon_recoil_scale->GetFloat();

		if (m_rage_data->m_pCmd->buttons & IN_ATTACK) {

			m_rage_data->m_pCmd->viewangles -= correction;
			m_rage_data->m_pCmd->viewangles.Normalize();
		}

		if (m_rage_data->m_bResetCmd) {
			*m_rage_data->m_pCmd.Xor() = cmd_backup;
		}
		else {
			if (m_rage_data->m_bRePredict)
				Engine::Prediction::Instance()->Repredict();
		}

		return success.first;
	}

	void C_Ragebot::AddPoint(C_CSPlayer* player, Engine::C_LagRecord* record, int side, std::vector<std::pair<Vector, bool>>& points, const Vector& point, mstudiobbox_t* hitbox, mstudiohitboxset_t* hitboxSet, bool isMultipoint) {
		auto pointTransformed = point;
		if (!hitbox)
			return;

		if (!hitboxSet)
			return;

		points.push_back(std::make_pair(pointTransformed, isMultipoint));
	}

	static int ClipRayToHitbox(const Ray_t& ray, mstudiobbox_t* hitbox, matrix3x4_t& matrix, CGameTrace& trace)
	{
		static auto fn = Memory::Scan(XorStr("client.dll"), XorStr("55 8B EC 83 E4 F8 F3 0F 10 42"));

		if (!fn || !hitbox)
			return -1;

		trace.fraction = 1.0f;
		trace.startsolid = false;

		return reinterpret_cast <int(__fastcall*)(const Ray_t&, mstudiobbox_t*, matrix3x4_t&, CGameTrace&)> (fn)(ray, hitbox, matrix, trace);
	}

	bool C_Ragebot::Hitchance(C_AimPoint* pPoint, const Vector& vecStart, float flChance) {
		if (flChance <= 0.0f)
			return true;

		if (!pPoint)
			return false;

		if ((m_rage_data->m_pWeapon->m_iItemDefinitionIndex() == WEAPON_SSG08 || m_rage_data->m_pWeapon->m_iItemDefinitionIndex() == WEAPON_REVOLVER) && !(m_rage_data->m_pLocal->m_fFlags() & FL_ONGROUND)) {
			if ((m_rage_data->m_flInaccuracy < 0.009f)) {
				pPoint->hitchance = 75.f;
				return true;
			}
		}

		// performance optimization.
		if ((g_Vars.globals.m_vecFixedEyePosition - pPoint->position).Length() > m_rage_data->m_pWeaponInfo->m_flWeaponRange + 256)
			return false;

		Vector forward = pPoint->position - vecStart;
		forward.Normalize();

		Vector right, up;
		forward.GetVectors(right, up);

		auto pRenderable = pPoint->target->player->GetClientRenderable();
		if (!pRenderable)
			return false;

		auto pModel = pRenderable->GetModel();
		if (!pModel)
			return false;

		auto pHdr = Interfaces::m_pModelInfo->GetStudiomodel(pModel);
		if (!pHdr)
			return false;

		auto pHitboxSet = pHdr->pHitboxSet(pPoint->target->player->m_nHitboxSet());

		if (!pHitboxSet)
			return false;

		auto pHitbox = pHitboxSet->pHitbox(pPoint->hitboxIndex);

		if (!pHitbox)
			return false;

		matrix3x4_t* pMatrix = pPoint->record->GetBoneMatrix();
		if (!pMatrix)
			return false;

		const auto maxTraces = 128;
		auto hits = 0;
		CGameTrace tr;
		for (int i = 0; i < maxTraces; ++i) {
			float flRand1 = g_Vars.globals.SpreadRandom[i].flRand1;
			float flRandPi1 = g_Vars.globals.SpreadRandom[i].flRandPi1;
			float flRand2 = g_Vars.globals.SpreadRandom[i].flRand2;
			float flRandPi2 = g_Vars.globals.SpreadRandom[i].flRandPi2;

			float m_flRecoilIndex = m_rage_data->m_pWeapon->m_flRecoilIndex();
			if (m_rage_data->m_pWeapon->m_iItemDefinitionIndex() == WEAPON_REVOLVER) {
				flRand1 = 1.0f - flRand1 * flRand1;
				flRand2 = 1.0f - flRand2 * flRand2;
			}
			else if (m_rage_data->m_pWeapon->m_iItemDefinitionIndex() == WEAPON_NEGEV && m_flRecoilIndex < 3.f) {
				for (int x = 3; x > m_flRecoilIndex; --x) {
					flRand1 *= flRand1;
					flRand2 *= flRand2;
				}

				flRand1 = 1.f - flRand1;
				flRand2 = 1.f - flRand2;
			}

			float flRandInaccuracy = flRand1 * m_rage_data->m_flInaccuracy;
			float flRandSpread = flRand2 * m_rage_data->m_flSpread;

			float flRandPi1Cos, flRandPi1Sin;
			DirectX::XMScalarSinCos(&flRandPi1Sin, &flRandPi1Cos, flRandPi1);

			float flRandPi2Cos, flRandPi2Sin;
			DirectX::XMScalarSinCos(&flRandPi2Sin, &flRandPi2Cos, flRandPi2);

			float spread_x = flRandPi1Cos * flRandInaccuracy + flRandPi2Cos * flRandSpread;
			float spread_y = flRandPi1Sin * flRandInaccuracy + flRandPi2Sin * flRandSpread;

			Vector direction;
			direction.x = forward.x + (spread_x * right.x) + (spread_y * up.x);
			direction.y = forward.y + (spread_x * right.y) + (spread_y * up.y);
			direction.z = forward.z + (spread_x * right.z) + (spread_y * up.z);

			Vector end = vecStart + direction * m_rage_data->m_pWeaponInfo->m_flWeaponRange;

			CGameTrace trace;
			Ray_t ray;
			ray.Init(m_rage_data->m_vecEyePos, end);

			auto bHit = ClipRayToHitbox(ray, pHitbox, pMatrix[pHitbox->bone], trace) >= 0;
			if (bHit) {
				hits++;
			}

			// abort if we can no longer reach hitchance.
			if (static_cast<float>(hits + maxTraces - i) / static_cast<float>(maxTraces) < flChance) {
				pPoint->hitchance = 0.f;
				return false;
			}
		}

		float hc{ };
		if (hits) {
			hc = static_cast<float>(hits) / static_cast<float>(maxTraces);
		}
		else {
			hc = 0.f;
		}

		pPoint->hitchance = hc * 100.f;

		return hc >= flChance;
	}

	bool C_Ragebot::IsPointAccurate(C_AimPoint* point, const Vector& start) {
		if (!m_rage_data->m_pLocal->CanShoot())
			return false;
		

		C_WeaponCSBaseGun* Weapon = (C_WeaponCSBaseGun*)m_rage_data->m_pLocal->m_hActiveWeapon().Get();
		auto weaponInfo = Weapon->GetCSWeaponData();
		auto m_weapon_id = Weapon->m_iItemDefinitionIndex();
		bool not_auto = m_weapon_id == WEAPON_REVOLVER || m_weapon_id == WEAPON_AWP || m_weapon_id == WEAPON_SSG08 || m_weapon_id == WEAPON_ZEUS || weaponInfo->m_iWeaponType == WEAPONTYPE_SHOTGUN;



		float percentage = 0.40;
		float v4 = percentage * (m_rage_data->m_pLocal->m_bIsScoped() ? weaponInfo->m_flMaxSpeed2 : weaponInfo->m_flMaxSpeed);


		if (!(g_Vars.globals.m_vecUnpredictedVel.Length() < v4))
			return false;

		if (m_rage_data->m_pLocal->m_flDuckAmount() > 0.f && g_Vars.globals.m_flPreviousDuckAmount > m_rage_data->m_pLocal->m_flDuckAmount())
			return false;

		auto dist = (m_rage_data->m_pLocal->m_vecOrigin().Distance(point->target->player->m_vecOrigin()));
		auto meters = dist * 0.0254f;
		float flDistanceInFeet = round_to_multiple(meters * 3.281f, 5);

		int iHealth = point->target->player->m_iHealth();
		bool bOnLand = !(Engine::Prediction::Instance().GetFlags() & FL_ONGROUND) && m_rage_data->m_pLocal->m_fFlags() & FL_ONGROUND;

		if (bOnLand)
			return false;

		auto ShouldHitchance = [&]() {
			// nospread enabled
			if (m_rage_data->m_flSpread == 0.0f || m_rage_data->m_flInaccuracy == 0.0f)
				return false;

			const auto weapon_id = m_rage_data->m_pWeapon->m_iItemDefinitionIndex();
			const auto crouched = m_rage_data->m_pLocal->m_fFlags() & FL_DUCKING;
			const auto sniper = m_rage_data->m_pWeaponInfo->m_iWeaponType == WEAPONTYPE_SNIPER_RIFLE;
			const auto round_acc = [](const float accuracy) { return roundf(accuracy * 1000.f) / 1000.f; };

			float rounded_acc = round_acc(m_rage_data->m_flInaccuracy);
			float maxSpeed = m_rage_data->m_pLocal->GetMaxSpeed();

			// no need for hitchance, if we can't increase it anyway.
			if (crouched) {
				if (rounded_acc == round_acc(sniper ? m_rage_data->m_pWeaponInfo->m_flInaccuracyCrouchAlt : m_rage_data->m_pWeaponInfo->m_flInaccuracyCrouch)) {
					return false;
				}
			}
			else {
				if (m_rage_data->m_pLocal->m_fFlags() & FL_ONGROUND && !bOnLand) {

					if (rounded_acc == round_acc(sniper ? m_rage_data->m_pWeaponInfo->m_flInaccuracyStandAlt : m_rage_data->m_pWeaponInfo->m_flInaccuracyStand)) {
						return false;
					}
				}
			}

			return true;
		};

		float hitchance = m_rage_data->rbot->hitchance;

		if (!ShouldHitchance())
			point->hitchance = 100.f;

		// we can hitchance them & check if accry boost is valid.
		if (hitchance > 0.0f && ShouldHitchance()) {
			// we cannot hitchance the player or no valid acrry boost then we failed hitchance.
			if (!Hitchance(point, start, hitchance * 0.01f)) {
				m_rage_data->m_bFailedHitchance = true;
				return false;
			}
		}

		m_rage_data->m_bFailedHitchance = false;
		return true;
	}

	void C_Ragebot::Multipoint(C_CSPlayer* player, Engine::C_LagRecord* record, int side, std::vector<std::pair<Vector, bool>>& points, mstudiobbox_t* hitbox, mstudiohitboxset_t* hitboxSet, float& pointScale, int hitboxIndex) {
		auto boneMatrix = record->GetBoneMatrix();

		if (!hitbox || !boneMatrix)
			return;

		if (!hitboxSet)
			return;

		Vector center = (hitbox->bbmax + hitbox->bbmin) * 0.5f;
		Vector centerTrans = center.Transform(boneMatrix[hitbox->bone]);

		// the center of feet ain't optimal, we are adding a better point later.
		AddPoint(player, record, side, points,
			centerTrans,
			hitbox, hitboxSet, false
		);

		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local || local->IsDead())
			return;

		bool using_dynamic{ false };

		if (hitboxIndex == HITBOX_STOMACH || hitboxIndex == HITBOX_PELVIS)
			using_dynamic = m_rage_data->rbot->body_point_scale <= 0;
		else
			using_dynamic = m_rage_data->rbot->point_scale <= 0;

		if (using_dynamic && m_rage_data->m_pWeapon && hitbox->m_flRadius > 0.0f) {
			pointScale = 0.91f; // we can go high here because the new multipoint is perfect

			float spreadCone = m_rage_data->m_flSpread + m_rage_data->m_flInaccuracy;
			float dist = centerTrans.Distance(m_rage_data->m_vecEyePos);

			dist /= sinf(DEG2RAD(90.0f - RAD2DEG(spreadCone)));

			spreadCone = sinf(spreadCone);

			float radiusScaled = (hitbox->m_flRadius - (dist * spreadCone));
			if (radiusScaled < 0.0f) {
				radiusScaled *= -1.f;
			}

			float ps = pointScale;
			pointScale = (radiusScaled / hitbox->m_flRadius);
			pointScale = Math::Clamp(pointScale, 0.0f, ps);
		}

		/*
		if( pointScale <= 0.0f )
			return;*/

		if (hitbox->m_flRadius <= 0.0f) {
			if (hitboxIndex == HITBOX_RIGHT_FOOT || hitboxIndex == HITBOX_LEFT_FOOT) {
				float d1 = (hitbox->bbmin.z - center.z) * 0.425f;

				if (hitboxIndex == HITBOX_LEFT_FOOT)
					d1 *= -1.f;

				// optimal point for feet
				AddPoint(player, record, side, points,
					Vector(center.x, center.y, center.z + d1).Transform(boneMatrix[hitbox->bone]),
					hitbox, hitboxSet, true
				);

				if (m_rage_data->rbot->mp_hitboxes_feets) {
					// toe
					AddPoint(player, record, side, points,
						Vector(((hitbox->bbmax.x - center.x) * pointScale) + center.x, center.y, center.z).Transform(boneMatrix[hitbox->bone]),
						hitbox, hitboxSet, true
					);

					// heel
					AddPoint(player, record, side, points,
						Vector(((hitbox->bbmin.x - center.x) * pointScale) + center.x, center.y, center.z).Transform(boneMatrix[hitbox->bone]),
						hitbox, hitboxSet, true
					);
				}
			}
		}
		else {
			float r = hitbox->m_flRadius * pointScale;

			if (hitboxIndex == HITBOX_HEAD && !m_rage_data->m_bDelayedHeadAim) {

				// always adding these (they suck)
				Vector right{ hitbox->bbmax.x, hitbox->bbmax.y, hitbox->bbmax.z + (hitbox->m_flRadius * 0.5f) };
				AddPoint(player, record, side, points,
					right.Transform(boneMatrix[hitbox->bone]),
					hitbox, hitboxSet, true
				);

				Vector left{ hitbox->bbmax.x, hitbox->bbmax.y, hitbox->bbmax.z - (hitbox->m_flRadius * 0.5f) };
				AddPoint(player, record, side, points,
					left.Transform(boneMatrix[hitbox->bone]),
					hitbox, hitboxSet, true
				);

				//Interfaces::m_pDebugOverlay->AddTextOverlay( front.Transform( boneMatrix[ hitbox->bone ] ), Interfaces::m_pGlobalVars->interval_per_tick * 2, "front" );

				if (m_rage_data->rbot->mp_hitboxes_head) {
					constexpr float rotation = 0.70710678f;

					// ok, this looks ghetto as shit but we have to clamp these to not have these be off too much
					pointScale = std::clamp<float>(pointScale, 0.1f, 0.95f);
					r = hitbox->m_flRadius * pointScale;

					// top/back 45 deg.
					// this is the best spot to shoot at (when peeking, when RESOLVED XD!)
					AddPoint(player, record, side, points,
						Vector(hitbox->bbmax.x + (rotation * r), hitbox->bbmax.y + (-rotation * r), hitbox->bbmax.z).Transform(boneMatrix[hitbox->bone]),
						hitbox, hitboxSet, true
					);

					//Interfaces::m_pDebugOverlay->AddTextOverlay( Vector( hitbox->bbmax.x + ( rotation * r ), hitbox->bbmax.y + ( -rotation * r ), hitbox->bbmax.z ).Transform( boneMatrix[ hitbox->bone ] ), Interfaces::m_pGlobalVars->interval_per_tick * 2, "front" );
				}
			}

			else if (hitboxIndex == HITBOX_STOMACH || hitboxIndex == HITBOX_PELVIS) {
				if (m_rage_data->rbot->mp_hitboxes_stomach) {
					Vector back{ center.x, hitbox->bbmax.y - r, center.z };
					AddPoint(player, record, side, points,
						back.Transform(boneMatrix[hitbox->bone]),
						hitbox, hitboxSet, true
					);

					Vector right{ hitbox->bbmax.x, hitbox->bbmax.y, hitbox->bbmax.z + (hitbox->m_flRadius * 0.5f) };
					AddPoint(player, record, side, points,
						right.Transform(boneMatrix[hitbox->bone]),
						hitbox, hitboxSet, true
					);

					Vector left{ hitbox->bbmax.x, hitbox->bbmax.y, hitbox->bbmax.z - (hitbox->m_flRadius * 0.5f) };
					AddPoint(player, record, side, points,
						left.Transform(boneMatrix[hitbox->bone]),
						hitbox, hitboxSet, true
					);
				}
			}

			else if (hitboxIndex == HITBOX_LOWER_CHEST || hitboxIndex == HITBOX_CHEST || hitboxIndex == HITBOX_UPPER_CHEST) {
				if (m_rage_data->rbot->mp_hitboxes_chest) {
					Vector back{ center.x, hitbox->bbmax.y - r, center.z };
					AddPoint(player, record, side, points,
						back.Transform(boneMatrix[hitbox->bone]),
						hitbox, hitboxSet, true
					);
				}
			}
			else if (hitboxIndex == HITBOX_RIGHT_THIGH || hitboxIndex == HITBOX_LEFT_THIGH) {
				if (m_rage_data->rbot->mp_hitboxes_legs) {

					Vector half_bottom{ hitbox->bbmax.x - (hitbox->m_flRadius * 0.5f), hitbox->bbmax.y, hitbox->bbmax.z };
					AddPoint(player, record, side, points,
						half_bottom.Transform(boneMatrix[hitbox->bone]),
						hitbox, hitboxSet, true
					);
				}
			}
		}
	}

	bool IsBadReadPtrAlt(void* p)
	{
		MEMORY_BASIC_INFORMATION mbi = { 0 };
		if (::VirtualQuery(p, &mbi, sizeof(mbi)))
		{
			DWORD mask = (PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY);
			bool b = !(mbi.Protect & mask);
			// check the page is not a guard page
			if (mbi.Protect & (PAGE_GUARD | PAGE_NOACCESS)) b = true;

			return b;
		}
		return true;
	}

	bool C_Ragebot::SetupTargets() {
		m_rage_data->m_targets.clear();
		m_rage_data->m_aim_points.clear();
		m_rage_data->m_aim_data.clear();
		m_rage_data->m_pBestTarget = nullptr;

		for (int idx = 1; idx <= Interfaces::m_pGlobalVars->maxClients; ++idx) {
			auto player = C_CSPlayer::GetPlayerByIndex(idx);
			if (!player || player == m_rage_data->m_pLocal || player->IsDead() || player->m_bGunGameImmunity() || player->IsTeammate(m_rage_data->m_pLocal))
				continue;

			if (!player->IsDormant())
				GeneratePoints(player, m_rage_data->m_targets, m_rage_data->m_aim_points);
		}

		if (m_rage_data->m_targets.empty())
			return false;

		if (m_rage_data->m_aim_points.empty()) {

			for (auto& target : m_rage_data->m_targets)
				target.backup.Apply(target.player);

			return false;
		}



		for (auto& target : m_rage_data->m_targets) {
			std::vector<C_AimPoint> tempPoints;

			if (!target.player || target.player == (void*)0xDDDDDDDD || IsBadReadPtrAlt(target.player)) {
				m_rage_data->m_targets.clear();
				m_rage_data->m_aim_points.clear();
				return false;
			}
			for (auto& point : m_rage_data->m_aim_points) {
				if (!point.target || !point.target->player || point.target->player == (void*)0xDDDDDDDD || IsBadReadPtrAlt(point.target->player) || !target.player) {
					m_rage_data->m_targets.clear();
					m_rage_data->m_aim_points.clear();
					return false;
				}
				if (point.target->player->EntIndex() == target.player->EntIndex())
					tempPoints.emplace_back(point);
			}

			if (!tempPoints.empty()) {
				target.record->Apply(target.player);

				// scan all valid points
				for (size_t i = 0u; i < tempPoints.size(); ++i)
					ScanPoint(&tempPoints.at(i));

				target.backup.Apply(target.player);

				std::vector<C_AimPoint> finalPoints;

				if (!finalPoints.empty())
					finalPoints.clear();

				int hp = target.player->m_iHealth();

				for (auto& p : tempPoints) {
					if (p.damage > 1.0f) {
						if (!p.isHead) {
							if (p.damage >= hp) {
								p.isLethal = true;
								target.hasLethal = true;
							}

							target.onlyHead = false;
						}

						if (p.center) {
							target.hasCenter = true;
						}

						// is this point valid? fuck yeah, let's push back
						finalPoints.push_back(p);
						continue;
					}
				}

				// don't even bother adding an entry if there are no valid aimpoints
				if (!finalPoints.empty()) {
					target.points = finalPoints;

					// add a valid entry
					m_rage_data->m_aim_data.emplace_back(target);
				}
			}
		}

		m_rage_data->m_aim_points.clear();

		if (m_rage_data->m_aim_data.empty()) {
			for (auto& target : m_rage_data->m_targets)
				target.backup.Apply(target.player);

			return false;
		}

		SelectBestTarget();

		if (m_rage_data->m_pBestTarget && !m_rage_data->m_aim_points.empty())
			return true;

		// backup targets
		for (auto& target : m_rage_data->m_targets)
			target.backup.Apply(target.player);

		return false;
	}

	void C_Ragebot::SelectBestTarget()
	{
		if (m_rage_data->m_aim_data.empty())
			return;

		auto CheckTargets = [&](C_AimTarget* a, C_AimTarget* b) -> bool {
			if (!a || !b)
				goto fuck_yeah;

			if (m_rage_data->m_pLastTarget != nullptr && !m_rage_data->m_pLastTarget->IsDead() && a->player->EntIndex() == m_rage_data->m_pLastTarget->EntIndex())
				return true;

			switch (m_rage_data->rbot->target_selection) {
			case SELECT_HIGHEST_DAMAGE: {
				float damageFirstTarget, damageSecondTarget;

				for (auto& p : a->points)
					damageFirstTarget += p.damage;

				for (auto& p : b->points)
					damageSecondTarget += p.damage;

				return damageFirstTarget > damageSecondTarget;
				break;
			}
			case SELECT_FOV: {
				float fovToFirstTarget, fovToSecondTarget;

				auto first = a->player->WorldSpaceCenter();
				auto second = b->player->WorldSpaceCenter();

				fovToFirstTarget = Math::GetFov(m_rage_data->m_pCmd->viewangles, m_rage_data->m_vecEyePos, first);
				fovToSecondTarget = Math::GetFov(m_rage_data->m_pCmd->viewangles, m_rage_data->m_vecEyePos, second);

				return fovToFirstTarget < fovToSecondTarget;
				break;
			}
			case SELECT_LOWEST_HP:
				return a->player->m_iHealth() <= b->player->m_iHealth(); break;
			case SELECT_LOWEST_DISTANCE:
				return a->player->m_vecOrigin().Distance(m_rage_data->m_pLocal->m_vecOrigin()) <= b->player->m_vecOrigin().Distance(m_rage_data->m_pLocal->m_vecOrigin()); break;
			case SELECT_LOWEST_PING:
				return (*Interfaces::m_pPlayerResource.Xor())->GetPlayerPing(a->player->EntIndex()) <= (*Interfaces::m_pPlayerResource.Xor())->GetPlayerPing(b->player->EntIndex());
				break;
			}
		fuck_yeah:
			// this might not make sense to you, but it actually does.
			return (a != nullptr || (a != nullptr && b != nullptr && a == b)) ? true : false;
		};

		for (auto& data : m_rage_data->m_aim_data) {
			// this should never happen, just to be extra safe.
			if (data.points.empty())
				continue;

			if (!m_rage_data->m_pBestTarget) {
				m_rage_data->m_pBestTarget = &data;
				m_rage_data->m_aim_points = data.points;

				// we only have one entry (target)? let's skip target selection..
				if (m_rage_data->m_aim_data.size() == 1)
					break;
				else
					continue;
			}

			if (m_rage_data->m_pLastTarget != nullptr && !m_rage_data->m_pLastTarget->IsDead() && data.player->m_entIndex != m_rage_data->m_pLastTarget->m_entIndex && m_rage_data->m_pLastTarget->m_entIndex <= 64) {
				continue;
			}

			if (CheckTargets(&data, m_rage_data->m_pBestTarget)) {
				m_rage_data->m_pBestTarget = &data;
				m_rage_data->m_aim_points = data.points;
				continue;
			}
		}

	}

	std::pair<bool, C_AimPoint> C_Ragebot::RunHitscan() {
		m_rage_data->m_vecEyePos = g_Vars.globals.m_vecFixedEyePosition;


		if (!SetupTargets())
			return { false, C_AimPoint() };


		//for( auto& p : m_rage_data->m_aim_points ) {
		//	Interfaces::m_pDebugOverlay->AddBoxOverlay( p.position, Vector( -0.7, -0.7, -0.7 ), Vector( 0.7, 0.7, 0.7 ), QAngle( ), 0, 255, 255, 255, Interfaces::m_pGlobalVars->interval_per_tick * 2 );
		//}




		C_AimPoint* bestPoint = nullptr;
		for (auto& p : m_rage_data->m_aim_points) {
			if (p.damage < 1.f)
				continue;

			// if we got no bestPoint yet, we should always take the first point
			if (!bestPoint) {
				bestPoint = &p;
				continue;
			}

			// get vars.
			int iHealth = p.target->player->m_iHealth();
			float flMaxBodyDamage = Autowall::ScaleDamage(p.target->player, m_rage_data->m_pWeaponInfo->m_iWeaponDamage, m_rage_data->m_pWeaponInfo->m_flArmorRatio, Hitgroup_Stomach);
			float flMaxHeadDamage = Autowall::ScaleDamage(p.target->player, m_rage_data->m_pWeaponInfo->m_iWeaponDamage, m_rage_data->m_pWeaponInfo->m_flArmorRatio, Hitgroup_Head);

			if (p.isLethal) {
				// don't shoot at head if we can shoot body and kill enemy
				if (p.isHead) {
					continue; // go to next point
				}

				// we always want this point, due to it being either choosen by bShouldBaim or p.is_should_baim
				if (bestPoint->isHead || (int)p.damage >= int(bestPoint->damage))
					bestPoint = &p;

				// if this damage is lethal, we actually want to break.
				if (bestPoint->damage >= iHealth) {
					break;
				}

				// let's continue searching for a better point instead of possibly overriding the current one later on.
				continue;
			}
			else {
				// if damage to body higher than hp, prioritize body or safe points
				if (int(flMaxBodyDamage) >= iHealth) {
					// don't shoot at head if we can shoot body and kill enemy
					if (!p.isBody) {
						continue; // go to next point
					}

					// possibly good body point?
					if ((!bestPoint->center && p.target->hasCenter) || (!p.target->hasCenter && (int)p.damage >= (int)bestPoint->damage))
						bestPoint = &p;

					// basically, if this is lethal, we take it.
					if (bestPoint->damage >= iHealth) {
						break;
					}
				}
				// if damage to the head is higher than hp, prioritize head or safe points
				else if (int(flMaxHeadDamage) >= iHealth) {
					// don't shoot at body if we can shoot head and kill enemy
					if (!p.isHead) {
						continue; // go to next point
					}

					// possibly good head point?
					if ((!bestPoint->center && p.target->hasCenter) || (!p.target->hasCenter && (int)p.damage >= (int)bestPoint->damage))
						bestPoint = &p;

					// basically, if this is lethal, we take it.
					if (bestPoint->damage >= iHealth) {
						break;
					}
				}

			}

			auto bestTarget = bestPoint->target;
			if (bestTarget->preferBody) {
				if (bestPoint->isBody != p.isBody) {
					bestPoint = bestPoint->isBody ? bestPoint : &p;
					continue;
				}
			}
			else {
				if (bestTarget->preferHead) {
					if (bestPoint->isHead != p.isHead) {
						bestPoint = bestPoint->isHead ? bestPoint : &p;
						continue;
					}
				}
			}


			if (bestPoint->hitboxIndex == p.hitboxIndex) {
				if (p.hitchance >= bestPoint->hitchance) {
					if (int(floor(p.damage)) >= int(floor(bestPoint->damage))) {
						bestPoint = &p;
					}
				}
			}

		}


		int hp = std::clamp(bestPoint->target->player->m_iHealth(), 0, 100);

		bool lethal = bestPoint->damage >= hp;
		bool lethalx2 = (bestPoint->damage * 2) >= hp;

		float mindmg = (m_rage_data->rbot->min_damage_visible > 100 ? hp + (m_rage_data->rbot->min_damage_visible - 100) : m_rage_data->rbot->min_damage_visible);
		if (m_rage_data->rbot->min_damage_override && g_Vars.rage.key_dmg_override.enabled) {
			mindmg = m_rage_data->rbot->min_damage_override_amount > 100 ? hp + (m_rage_data->rbot->min_damage_override_amount - 100) : m_rage_data->rbot->min_damage_override_amount;
		}

		if (hp < mindmg)
			mindmg = hp;

		if (mindmg < 100 && !lethalx2 && !lethal)
			mindmg = std::ceil((mindmg / 100.f) * hp);
		else if (mindmg == 100)
			mindmg = hp;

		bool result = false;
		if (bestPoint && (bestPoint->damage >= mindmg || bestPoint->damage >= hp)) {


			if (m_rage_data->m_pLocal->m_fFlags() & FL_ONGROUND) {
				if (m_rage_data->rbot->autostop_check && !g_Vars.globals.bMoveExploiting) {
					if (!g_Vars.globals.Fakewalking) {
						Interfaces::Movement::Get()->AdjustVelocity();
					}
				}
			}


			if (IsPointAccurate(bestPoint, m_rage_data->m_vecEyePos)) {
				bool bDidDelayHeadShot = m_rage_data->m_bDelayedHeadAim;
				m_rage_data->m_bDelayedHeadAim = false;
				g_Vars.globals.m_bDelayingShot[bestPoint->target->record->player->EntIndex()] = false;

				if (AimAtPoint(bestPoint)) {
					if (m_rage_data->m_pCmd->buttons & IN_ATTACK) {

						Encrypted_t<Engine::C_EntityLagData> m_lag_data = Engine::LagCompensation::Get()->GetLagData(bestPoint->target->player->m_entIndex);
						auto targedt = TIME_TO_TICKS(bestPoint->target->record->m_flSimulationTime + g_Vars.globals.m_lerp);

						m_rage_data->m_pCmd->tick_count = targedt;

						//printf( "tickcount %i\n", m_rage_data->m_pCmd->tick_count );

						if (m_lag_data.IsValid()) {
							std::stringstream msg;

							auto FixedStrLength = [](std::string str) -> std::string {
								if ((int)str[0] > 255)
									return XorStr("");

								if (str.size() < 15)
									return str;

								std::string result;
								for (size_t i = 0; i < 15u; i++)
									result.push_back(str.at(i));
								return result;
							};

							auto TranslateHitbox = [](int hitbox) -> std::string {
								std::string result = { };
								switch (hitbox) {
								case HITBOX_HEAD:
									result = XorStr("head"); break;
								case HITBOX_NECK:
								case HITBOX_LOWER_NECK:
									result = XorStr("neck"); break;
								case HITBOX_CHEST:
								case HITBOX_LOWER_CHEST:
								case HITBOX_UPPER_CHEST:
									result = XorStr("chest"); break;
								case HITBOX_RIGHT_FOOT:
								case HITBOX_RIGHT_CALF:
								case HITBOX_RIGHT_THIGH:
								case HITBOX_LEFT_FOOT:
								case HITBOX_LEFT_CALF:
								case HITBOX_LEFT_THIGH:
									result = XorStr("leg"); break;
								case HITBOX_LEFT_FOREARM:
								case HITBOX_LEFT_HAND:
								case HITBOX_LEFT_UPPER_ARM:
								case HITBOX_RIGHT_FOREARM:
								case HITBOX_RIGHT_HAND:
								case HITBOX_RIGHT_UPPER_ARM:
									result = XorStr("arm"); break;
								case HITBOX_STOMACH:
								case HITBOX_PELVIS: // there is no pelvis hitgroup
									result = XorStr("stomach"); break;
								default:
									result = XorStr("-");
								}

								return result;
							};


							player_info_t info;
							if (Interfaces::m_pEngine->GetPlayerInfo(bestPoint->target->player->EntIndex(), &info)) {
								//int ping = 0;

								auto netchannel = Encrypted_t<INetChannelInfo>(Interfaces::m_pEngine->GetNetChannelInfo());

								int backtrackedticks = Interfaces::m_pGlobalVars->tickcount - TIME_TO_TICKS(bestPoint->target->record->m_flSimulationTime);
								
								if (backtrackedticks < 0)
									backtrackedticks = 0;

								std::string resolvermode;
								int resolver_mode = bestPoint->target->record->m_iResolverMode;

								switch (resolver_mode) 
								{
								case 0: resolvermode = XorStr("no fake"); break;
								case 1: resolvermode = XorStr("moving"); break;
								case 2: resolvermode = XorStr("freestand"); break;
								case 3: resolvermode = XorStr("last move"); break;
								case 4: resolvermode = XorStr("brute"); break;
								case 5: resolvermode = XorStr("air"); break;
								case 6: resolvermode = XorStr("flick"); break;
								case 7: resolvermode = XorStr("lby"); break;

								default:
									break;
								}

								msg << XorStr("Fired shot at ");
								msg << FixedStrLength(info.szName).data();
								msg << XorStr("'s ") << TranslateHitbox(bestPoint->hitboxIndex).c_str() << XorStr("(") << int(bestPoint->pointscale * 100.f) << XorStr("%%%%)") << XorStr(" for ");
								msg << int(bestPoint->damage) << " damage | ";

								msg << XorStr("res: ") << resolvermode << XorStr(" | ");
								msg << XorStr("bt: ") << backtrackedticks << XorStr(" | ");
								msg << XorStr("hc: ") << int(bestPoint->hitchance);

								if (g_Vars.misc.log_ping && netchannel.IsValid()) {
									int ms = (std::max(0, (int)std::round(netchannel->GetLatency(FLOW_OUTGOING) * 1000.f)) + std::max(0, (int)std::round(netchannel->GetLatency(FLOW_INCOMING) * 1000.f)));
									msg << XorStr(" | ping: ") << ms;
								}

								ILoggerEvent::Get()->PushEvent(msg.str(), FloatColor(255, 255, 255), true);
							}

						}

						m_rage_data->m_pLastTarget = m_rage_data->m_pBestTarget->player;

						Engine::C_ShotInformation::Get()->CreateSnapshot(bestPoint->target->player, m_rage_data->m_vecEyePos, bestPoint->position, bestPoint->target->record, bestPoint->target->record->m_iResolverMode, bestPoint->hitgroup, bestPoint->hitboxIndex, int(bestPoint->damage));


						if (g_Vars.esp.hitmatrix)
							IChams::Get()->AddHitmatrix(bestPoint->target->player, bestPoint->target->record->GetBoneMatrix());

						if (g_Vars.esp.draw_hitboxes) {
							auto matrix = bestPoint->target->record->GetBoneMatrix();

							auto hdr = Interfaces::m_pModelInfo->GetStudiomodel(bestPoint->target->player->GetModel());
							if (hdr) {
								auto hitboxSet = hdr->pHitboxSet(bestPoint->target->player->m_nHitboxSet());
								if (hitboxSet) {
									for (int i = 0; i < hitboxSet->numhitboxes; ++i) {
										auto hitbox = hitboxSet->pHitbox(i);
										if (hitbox->m_flRadius <= 0.f)
											continue;

										auto min = hitbox->bbmin.Transform(matrix[hitbox->bone]);
										auto max = hitbox->bbmax.Transform(matrix[hitbox->bone]);

										Interfaces::m_pDebugOverlay->AddCapsuleOverlay(min, max, hitbox->m_flRadius, g_Vars.esp.hitboxes_color.r * 255, g_Vars.esp.hitboxes_color.g * 255, g_Vars.esp.hitboxes_color.b * 255, g_Vars.esp.hitboxes_color.a * 255,
											Interfaces::m_pCvar->FindVar(XorStr("sv_showlagcompensation_duration"))->GetFloat());
									}
								}
							}
						}

						result = true;
					}
				}
			}
		}

		for (auto& target : m_rage_data->m_targets) {
			target.backup.Apply(target.player);
		}

		return { result, *bestPoint };
	}

	bool C_Ragebot::OverrideHitscan(C_CSPlayer* player, Engine::C_LagRecord* record) {
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local)
			return false;

		if (m_rage_data->rbot->prefer_body_disable_resolved) {
			if (record->m_bResolved)
				return false;
		}

		return true;
	}

	void C_Ragebot::ScanPoint(C_AimPoint* pPoint) {
		if (!pPoint || !pPoint->target || !pPoint->target->player)
			return;

		// no do
		if (pPoint->hitboxIndex == HITBOX_HEAD && m_rage_data->m_bDelayedHeadAim) {
			return;
		}

		Autowall::C_FireBulletData fireData;
		fireData.m_bPenetration = this->m_rage_data->rbot->autowall;

		auto dir = pPoint->position - this->m_rage_data->m_vecEyePos;
		dir.Normalize();


		fireData.m_vecStart = this->m_rage_data->m_vecEyePos;
		fireData.m_vecDirection = dir;
		fireData.m_iHitgroup = convert_hitbox_to_hitgroup(pPoint->hitboxIndex);
		fireData.m_Player = this->m_rage_data->m_pLocal;
		fireData.m_TargetPlayer = pPoint->target->player;
		fireData.m_WeaponData = this->m_rage_data->m_pWeaponInfo.Xor();
		fireData.m_Weapon = this->m_rage_data->m_pWeapon;

		pPoint->damage = Autowall::FireBullets(&fireData);
		pPoint->penetrated = fireData.m_iPenetrationCount < 4;

		int hp = std::clamp(pPoint->target->player->m_iHealth(), 0, 100);

		bool lethal = pPoint->damage >= hp;
		bool lethalx2 = (pPoint->damage * 2) >= hp;

		float mindmg = (m_rage_data->rbot->min_damage_visible > 100 ? hp + (m_rage_data->rbot->min_damage_visible - 100) : m_rage_data->rbot->min_damage_visible);
		if (m_rage_data->rbot->min_damage_override && g_Vars.rage.key_dmg_override.enabled) {
			mindmg = m_rage_data->rbot->min_damage_override_amount > 100 ? hp + (m_rage_data->rbot->min_damage_override_amount - 100) : m_rage_data->rbot->min_damage_override_amount;
		}

		if (hp < mindmg)
			mindmg = hp;

		if (mindmg < 100 && !lethalx2 && !lethal)
			mindmg = std::ceil((mindmg / 100.f) * hp);
		else if (mindmg == 100)
			mindmg = hp;


		// we did not hit head
		if ((pPoint->hitboxIndex) == HITBOX_HEAD && fireData.m_iHitgroup != Hitgroup_Head) {
			pPoint->damage = 0.f;
			return;
		}

		bool done{ false };

		bool body = !(pPoint->hitboxIndex == HITBOX_HEAD);

		if (pPoint->damage >= hp && body)
			done = true;
		else if (pPoint->damage * 2 >= hp && body)
			done = true;
		else if (pPoint->damage >= mindmg)
			done = true;




		if (done) {
			pPoint->hitgroup = fireData.m_EnterTrace.hitgroup;
			pPoint->healthRatio = int(float(pPoint->target->player->m_iHealth()) / pPoint->damage) + 1;

			auto hitboxSet = (*(studiohdr_t**)pPoint->target->player->m_pStudioHdr())->pHitboxSet(pPoint->target->player->m_nHitboxSet());
			auto hitbox = hitboxSet->pHitbox(pPoint->hitboxIndex);

			pPoint->isHead = pPoint->hitboxIndex == HITBOX_HEAD;
			body = pPoint->hitboxIndex == HITBOX_CHEST || pPoint->hitboxIndex == HITBOX_LOWER_CHEST || pPoint->hitboxIndex == HITBOX_PELVIS || pPoint->hitboxIndex == HITBOX_STOMACH;
			pPoint->isBody = body;

		}
		else {
			pPoint->healthRatio = 100;
			pPoint->hitchance = 0.0f;
			pPoint->damage = 0.f;
		}
	}

	int C_Ragebot::GeneratePoints(C_CSPlayer* player, std::vector<C_AimTarget>& aim_targets, std::vector<C_AimPoint>& aim_points) {
		auto lagData = Engine::LagCompensation::Get()->GetLagData(player->m_entIndex);
		if (!lagData.IsValid() || lagData->m_History.empty())
			return 0;

		player_info_t info;
		if (!Interfaces::m_pEngine->GetPlayerInfo(player->m_entIndex, &info))
			return 0;

		auto animState = player->m_PlayerAnimState();

		if (!animState)
			return 0;

		auto renderable = player->GetClientRenderable();
		if (!renderable)
			return 0;

		auto model = renderable->GetModel();
		if (!model)
			return 0;

		auto hdr = Interfaces::m_pModelInfo->GetStudiomodel(model);
		if (!hdr)
			return 0;

		Engine::C_BaseLagRecord backup;
		backup.Setup(player);

		auto record = GetBestLagRecord(player, &backup);
		if (!record || !IsRecordValid(player, record)) {
			backup.Apply(player);
			return 0;
		}

		backup.Apply(player);

		auto hitboxSet = hdr->pHitboxSet(player->m_nHitboxSet());

		if (!hitboxSet)
			return 0;

		auto& aim_target = aim_targets.emplace_back();
		aim_target.player = player;
		aim_target.record = record;
		aim_target.backup = backup;
		aim_target.preferBody = m_rage_data->rbot->prefer_body;

		aim_target.preferHead = int(g_Vars.mp_damage_headshot_only->GetInt()) == 1 ||
			int(record->m_iResolverMode == 0) || int(record->m_iResolverMode == 1) || int(record->m_iResolverMode == 6) || int(record->m_iResolverMode == 7);

		auto addedPoints = 0;
		for (int i = 0; i < HITBOX_MAX; i++) {
			auto hitbox = hitboxSet->pHitbox(i);
			float ps = 0.0f;

			// neck bro this is shit hitbox
			bool neck = i == HITBOX_NECK
				|| i == HITBOX_LOWER_NECK;

			// all limbs
			bool limb = i >= 12 && i <= 19;

			// skip loop if running or neck
			if (neck)
				continue;



			if (!GetBoxOption(hitbox, hitboxSet, ps, aim_target.overrideHitscan))
				continue;

			ps *= 0.01f;
			std::vector<std::pair<Vector, bool>> points;

			Multipoint(player, record, 0, points, hitbox, hitboxSet, ps, i);

			if (!points.size())
				continue;

			for (const auto& point : points) {
				C_AimPoint& p = aim_points.emplace_back();

				p.position = point.first;
				p.center = !point.second;
				p.target = &aim_target;
				p.record = record;
				p.hitboxIndex = i;

				if (point.second)
					p.pointscale = ps;
				else
					p.pointscale = 0.f;

				++addedPoints;
			}
		}

		return addedPoints;
	}

	Engine::C_LagRecord* C_Ragebot::GetBestLagRecord(C_CSPlayer* player, Engine::C_BaseLagRecord* backup) {
		auto lagData = Engine::LagCompensation::Get()->GetLagData(player->m_entIndex);
		if (!lagData.IsValid() || lagData->m_History.empty() || player->IsDormant())
			return nullptr;

		auto& record = lagData->m_History.front();
		if (!record.m_bIsValid) {
			return nullptr;
		}

		int recordsCount = 0;
		Engine::C_LagRecord* arrRecords[64] = { nullptr };

		for (auto it = lagData->m_History.begin(); it != lagData->m_History.end(); ++it) {
			if (it->m_bSkipDueToResolver) {
				continue;
			}

			if (!it->m_bIsValid || !IsRecordValid(player, &*it)) {
				continue;
			}

			arrRecords[recordsCount] = &*it;
			recordsCount++;


			if (recordsCount + 1 >= 64)
				break;
		}

		if (recordsCount <= 1) {
			return &record;
		}

		Engine::C_LagRecord* pBestRecord = nullptr;

		// iterate all valid records
		for (int i = 0; i < recordsCount; i++) {
			// get current record
			Engine::C_LagRecord* currentRecord = arrRecords[i];

			// if best record null, set best record to current record
			if (!pBestRecord) {
				pBestRecord = currentRecord;
				continue; // go to next record
			}

			if (pBestRecord->m_bResolved != currentRecord->m_bResolved) {
				if (!pBestRecord->m_bResolved) {
					pBestRecord = currentRecord;
					continue;
				}
			}
		}

		if (!pBestRecord) {
			return &record;
		}

		return pBestRecord;
	}

	bool C_Ragebot::IsRecordValid(C_CSPlayer* player, Engine::C_LagRecord* record) {
		return (Engine::LagCompensation::Get()->IsRecordOutOfBounds(*record, 0.2f));
	}

	bool C_Ragebot::AimAtPoint(C_AimPoint* bestPoint) {
		C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer();
		if (!pLocal && !pLocal->IsDead())
			return false;

		C_WeaponCSBaseGun* pWeapon = (C_WeaponCSBaseGun*)pLocal->m_hActiveWeapon().Get();
		if (!pWeapon)
			return false;

		m_rage_data->m_pCmd->buttons &= ~IN_USE;

		// todo: aimstep
		Vector delta = bestPoint->position - m_rage_data->m_vecEyePos;
		delta.Normalize();

		QAngle aimAngles = delta.ToEulerAngles();
		aimAngles.Normalize();

		if (!g_Vars.rage.silent_aim)
			Interfaces::m_pEngine->SetViewAngles(aimAngles);

		m_rage_data->m_pCmd->viewangles = aimAngles;
		m_rage_data->m_pCmd->viewangles.Normalize();

		g_Vars.globals.CorrectShootPosition = true;
		g_Vars.globals.AimPoint = bestPoint->position;
		g_Vars.globals.ShootPosition = m_rage_data->m_vecEyePos;

		m_rage_data->m_iChokedCommands = -1;
		m_rage_data->m_bFailedHitchance = false;

		if (g_Vars.rage.auto_fire) {
			//	if( !g_Vars.globals.Fakewalking )
			*m_rage_data->m_pSendPacket = true;

			m_rage_data->m_pCmd->buttons |= IN_ATTACK;

			g_Vars.globals.m_bAimbotShot = true;
		}

		return true;
	}

	static C_Ragebot instance;
	Encrypted_t<Ragebot> Interfaces::Ragebot::Get() {
		return &instance;
	}
}
```

`CSGO SDK/Features/Rage/Ragebot.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

#define DOUBLE_TAP_CHARGE 14
#define BREAK_LC_CHARGE 14
#define BREAK_LC_CHARGE_HIDE_SHOTS 14
#define HIDE_SHOTS_CHARGE 8

namespace Engine
{
	class C_LagRecord;
}

namespace Interfaces
{
	class __declspec(novtable) Ragebot : public NonCopyable {
	public:
		enum SelectTarget_e : int {
			SELECT_HIGHEST_DAMAGE = 0,
			SELECT_FOV,
			SELECT_LOWEST_HP,
			SELECT_LOWEST_DISTANCE,
			SELECT_LOWEST_PING,
		};

		static Encrypted_t<Ragebot> Get();
		virtual bool Run(Encrypted_t<CUserCmd> cmd, C_CSPlayer* local, bool* sendPacket) = 0;
		virtual bool GetBoxOption(mstudiobbox_t* hitbox, mstudiohitboxset_t* hitboxSet, float& ps, bool override_hitscan) = 0;
		virtual void Multipoint(C_CSPlayer* player, Engine::C_LagRecord* record, int side, std::vector<std::pair<Vector, bool>>& points, mstudiobbox_t* hitbox, mstudiohitboxset_t* hitboxSet, float& ps, int hitboxIndex) = 0;
		virtual bool OverrideHitscan(C_CSPlayer* player, Engine::C_LagRecord* record) = 0;
		virtual bool SetupRageOptions() = 0;
	protected:
		Ragebot() { };
		virtual ~Ragebot() { };
	};
}

```

`CSGO SDK/Features/Rage/Resolver.cpp`:

```cpp
#include "Resolver.hpp"
#include "../../SDK/CVariables.hpp"
#include "../Visuals/CChams.hpp"
#include "../Rage/AntiAim.hpp"
#include "../Rage/Ragebot.hpp"
#include "../Rage/Autowall.h"
#include "../Visuals/EventLogger.hpp"
#include "../../SDK/RayTracer.h"

namespace Engine {
	CResolver g_Resolver;
	CResolverData g_ResolverData[65];

	// resolver ported from supremacy autismware (p100).

	int last_ticks[65];
	int CResolver::GetChokedPackets(C_CSPlayer* player)
	{
		// make sure they have no fake for at least 2 ticks in a row.
		float lastsim = player->m_flSimulationTime() - Interfaces::m_pGlobalVars->interval_per_tick;
		float lastoldsim = player->m_flOldSimulationTime() - Interfaces::m_pGlobalVars->interval_per_tick;

		auto oldticks = TIME_TO_TICKS(lastsim - lastoldsim);

		auto ticks = TIME_TO_TICKS(player->m_flSimulationTime() - player->m_flOldSimulationTime());
		if (ticks == 0 && oldticks == 0 && last_ticks[player->EntIndex()] > 0) {
			return last_ticks[player->EntIndex()] - 1;
		}
		else {
			last_ticks[player->EntIndex()] = ticks;
			return ticks;
		}
	}

	void CResolver::ResolveYaw(C_CSPlayer* player, C_AnimationRecord* record)
	{
		bool fake = GetChokedPackets(player) > 1;
		float speed = record->m_vecAnimationVelocity.Length();

		// impossible to have a fake without >= 2 choked packets
		if (!fake) {
			record->m_iResolverMode = EResolverModes::RESOLVE_NONE;
			record->m_resolver_mode = XorStr("");
		}
		else
		{
			if ((record->m_fFlags & FL_ONGROUND) && speed > 0.1f && !record->m_bFakeWalking && !record->m_bFakeFlicking)
				ResolveWalk(player, record);

			else if ((record->m_fFlags & FL_ONGROUND) && (speed <= 0.1f || record->m_bFakeWalking || record->m_bFakeFlicking))
				ResolveStand(player, record);

			else
				ResolveAir(player, record);
		}

		// write potentially resolved angles.
		player->m_angEyeAngles().y = Math::AngleNormalize(record->m_angEyeAngles.y);
	}

	void CResolver::MatchShot(C_CSPlayer* player, C_AnimationRecord* record, C_AnimationRecord* previous)
	{
		auto pLocal = C_CSPlayer::GetLocalPlayer();
		if (!pLocal)
			return;

		auto anim_data = AnimationSystem::Get()->GetAnimationData(player->m_entIndex);

		if (anim_data->m_AnimationRecord.size() < 3)
			return;

		auto weapon = (C_WeaponCSBaseGun*)(player->m_hActiveWeapon().Get());
		if (!weapon)
			return;

		if (player->IsDormant())
			return;

		Vector angAway;
		auto m_vecOrigin = player->m_vecOrigin();
		Math::VectorAngles(pLocal->m_vecOrigin() - m_vecOrigin, angAway);

		if (record->m_iChokeTicks > 1)
		{
			C_AnimationRecord previous2 = anim_data->m_AnimationRecord.at(2);

			if (previous->m_bIsShooting)
				record->m_angEyeAngles.x = previous2.m_angEyeAngles.x;

			if (record->m_bIsShooting)
				record->m_angEyeAngles.x = previous->m_angEyeAngles.x;
		}
		// they have to be looking at us to shoot
		else if (record->m_bIsShooting)
			record->m_angEyeAngles.y = angAway.y;
	}

	bool CResolver::ShouldUseFreestand(C_CSPlayer* player, C_AnimationRecord* record) // allows freestanding if not in open
	{
		auto pLocal = C_CSPlayer::GetLocalPlayer();
		if (!pLocal)
			return false;

		if (!player || player->IsDead())
			return false;

		if (player->IsDormant())
			return false;

		// don't resolve if no fake
		bool fake = GetChokedPackets(player) > 1;
		if (!fake)
			return false;

		// externs
		Vector src3D, dst3D, forward, right, up, src, dst;
		float back_two, right_two, left_two;
		CGameTrace tr;
		CTraceFilterSimple filter;

		// get predicted away angle for the player.
		Vector angAway;
		auto m_vecOrigin = player->m_vecOrigin();
		Math::VectorAngles(pLocal->m_vecOrigin() - m_vecOrigin, angAway);

		// angle vectors
		Math::AngleVectors(QAngle(0, angAway.y, 0), forward, right, up);

		// filtering
		filter.SetPassEntity(player);
		src3D = player->GetEyePosition();
		dst3D = src3D + (forward * 100);

		// back engine tracers
		Interfaces::m_pEngineTrace->TraceRay(Ray_t(src3D, dst3D), MASK_SHOT_BRUSHONLY | MASK_OPAQUE_AND_NPCS, &filter, &tr);
		back_two = (tr.endpos - tr.startpos).Length();

		// right engine tracers
		Interfaces::m_pEngineTrace->TraceRay(Ray_t(src3D + right * 35, dst3D + right * 35), MASK_SHOT_BRUSHONLY | MASK_OPAQUE_AND_NPCS, &filter, &tr);
		right_two = (tr.endpos - tr.startpos).Length();

		// left engine tracers
		Interfaces::m_pEngineTrace->TraceRay(Ray_t(src3D - right * 35, dst3D - right * 35), MASK_SHOT_BRUSHONLY | MASK_OPAQUE_AND_NPCS, &filter, &tr);
		left_two = (tr.endpos - tr.startpos).Length();

		// pick side
		if (left_two > right_two) {
			this->bFacingleft = true;
			this->bFacingright = false;
			return true;
		}
		else if (right_two > left_two) {
			this->bFacingright = true;
			this->bFacingleft = false;
			return true;
		}
		else
			return false;
	}

	void CResolver::Freestand(C_CSPlayer* player, C_AnimationRecord* record)
	{
		auto pLocal = C_CSPlayer::GetLocalPlayer();
		if (!pLocal)
			return;

		// don't resolve if no fake
		bool fake = GetChokedPackets(player) > 1;
		if (!fake)
			return;

		// constants
		constexpr float STEP{ 4.f };
		constexpr float RANGE{ 32.f };

		auto lag_data = LagCompensation::Get()->GetLagData(player->m_entIndex);
		if (!lag_data.IsValid())
			return;

		// best target.
		Vector enemypos = player->GetEyePosition();
		// get best origin based on target.
		auto m_vecOrigin = player->m_vecOrigin();

		// get predicted away angle for the player.
		Vector angAway;
		Math::VectorAngles(pLocal->m_vecOrigin() - m_vecOrigin, angAway);

		// construct vector of angles to test.
		std::vector< AdaptiveAngle > angles{ };
		angles.emplace_back(angAway.y + 180.f);
		angles.emplace_back(angAway.y + 90.f);
		angles.emplace_back(angAway.y - 90.f);

		// start the trace at the your shoot pos.
		Vector start = g_Vars.globals.m_vecFixedEyePosition;

		// see if we got any valid result.
		// if this is false the path was not obstructed with anything.
		bool valid{ false };
		// iterate vector of angles.

		for (auto it = angles.begin(); it != angles.end(); ++it) {
			// compute the 'rough' estimation of where our head will be.
			Vector end{ enemypos.x + std::cos(DEG2RAD(it->m_yaw)) * RANGE,
				enemypos.y + std::sin(DEG2RAD(it->m_yaw)) * RANGE,
				enemypos.z };

			// draw a line for debugging purposes.
			//g_csgo.m_debug_overlay->AddLineOverlay( start, end, 255, 0, 0, true, 0.1f );

			// compute the direction.
			Vector dir = end - start;
			float len = dir.Normalize();

			// should never happen.

			if (len <= 0.f)
				continue;

			// step thru the total distance, 4 units per step.
			for (float i{ 0.f }; i < len; i += STEP) {
				// get the current step position.
				Vector point = start + (dir * i);

				// get the contents at this point.
				int contents = Interfaces::m_pEngineTrace->GetPointContents(point, MASK_SHOT_HULL);

				// contains nothing that can stop a bullet.
				if (!(contents & MASK_SHOT_HULL))
					continue;

				float mult = 1.f;

				// over 65% of the total length.
				if (i > (len * 0.65f))

					mult = 1.25f;

				// over 75% of the total length.
				if (i > (len * 0.75f))

					mult = 1.5f;

				// over 90% of the total length.
				if (i > (len * 0.9f))
					mult = 2.f;

				// append 'penetrated distance'.
				it->m_dist += (STEP * mult);

				// mark that we found anything.
				valid = true;

			}
		}

		if (!valid) {
			record->m_angEyeAngles.y = angAway.y + 190.f;
			return;

		}

		// put the most distance at the front of the container.

		std::sort(angles.begin(), angles.end(),

			[](const AdaptiveAngle& a, const AdaptiveAngle& b) {

				return a.m_dist > b.m_dist;

			});

		// the best angle should be at the front now.
		AdaptiveAngle* best = &angles.front();

		// set angles.
		if (lag_data->m_iMissedShotsFreestand < 1)
			record->m_angEyeAngles.y = best->m_yaw;
		else if (this->bFacingright && lag_data->m_iMissedShotsFreestand < 2)
			record->m_angEyeAngles.y = best->m_yaw + 90.f;
		else if (this->bFacingleft && lag_data->m_iMissedShotsFreestand < 2)
			record->m_angEyeAngles.y = best->m_yaw - 90.f;
		else if (lag_data->m_iMissedShotsFreestand == 2 || lag_data->m_iMissedShotsFreestand == 4)
			record->m_angEyeAngles.y = best->m_yaw + 180.f;
		else
			record->m_angEyeAngles.y = best->m_yaw;
		return;
	}

	void CResolver::ResolveStand(C_CSPlayer* player, C_AnimationRecord* record)
	{
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local)
			return;

		// get resolver data.
		auto& lasttick = g_ResolverData[player->EntIndex() - 1];
		auto& data = g_ResolverData[player->EntIndex()];
		float speed = record->m_vecAnimationVelocity.Length();

		// get records.
		auto anim_data = AnimationSystem::Get()->GetAnimationData(player->m_entIndex);

		// get last move time.
		float delta = player->m_flAnimationTime() - g_ResolverData[player->EntIndex()].m_sMoveData.m_flAnimTime;

		// get predicted away angle for the player.
		Vector angAway;
		Math::VectorAngles(local->m_vecOrigin() - player->m_vecOrigin(), angAway);

		// get lag data.
		Encrypted_t<C_EntityLagData> pLagData = LagCompensation::Get()->GetLagData(player->EntIndex());
		if (!pLagData.IsValid()) {
			return;
		}

		// we have a valid moving record.
		if (g_ResolverData[player->EntIndex()].m_sMoveData.m_flSimulationTime > 0.f) {
			Vector delta = g_ResolverData[player->EntIndex()].m_sMoveData.m_vecOrigin - record->m_vecOrigin;

			// check if moving record is close.
			if (delta.Length() <= 128.f && !record->m_bFakeFlicking && !record->m_bFakeWalking) {
				// indicate that we are using the moving lby.
				data.m_bCollectedValidMoveData = true;
			}
		}

		// expire last move after 0.75 secs if not in open.
		if (data.m_bCollectedValidMoveData && pLagData->m_iMissedShotsLastmove < 1 && (delta < 0.75f || !ShouldUseFreestand(player, record)))
		{
			record->m_iResolverMode = EResolverModes::RESOLVE_LAST_LBY;
			record->m_resolver_mode = XorStr("LAST MOVE");
			record->m_angEyeAngles.y = player->m_angEyeAngles().y = data.m_sMoveData.m_flLowerBodyYawTarget;
		}
		else
		{
			if (ShouldUseFreestand(player, record)) // if freestand would be useful.
			{
				record->m_iResolverMode = EResolverModes::RESOLVE_FREESTAND;
				record->m_resolver_mode = XorStr("FREESTAND");
				Freestand(player, record);
				return;
			}
			else
			{
				record->m_iResolverMode = EResolverModes::RESOLVE_BRUTEFORCE;
				record->m_resolver_mode = XorStr("BRUTE");
				switch (pLagData->m_iMissedShotsBrute % 3) {

				case 0:
					record->m_angEyeAngles.y = angAway.y + 180.f;
					break;

				case 1:
					record->m_angEyeAngles.y = angAway.y - 135.f;
					break;

				case 2:
					record->m_angEyeAngles.y = angAway.y + 135.f;
					break;

				default:
					break;
				}
			}
		}
	}

	void CResolver::PredictBodyUpdates(C_CSPlayer* player, C_AnimationRecord* record, C_AnimationRecord* prev)
	{
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local)
			return;

		// get lag data about this player
		Encrypted_t<C_EntityLagData> pLagData = LagCompensation::Get()->GetLagData(player->m_entIndex);
		if (!pLagData.IsValid()) {
			g_ResolverData[player->EntIndex()].m_bPredictingUpdates = false;
			return;
		}

		// nah
		if (local->IsDead()) {
			g_ResolverData[player->EntIndex()].m_bPredictingUpdates = false;
			g_ResolverData[player->EntIndex()].m_bCollectedValidMoveData = false;
		}

		// get records.
		auto anim_data = AnimationSystem::Get()->GetAnimationData(player->m_entIndex);

		if (anim_data->m_AnimationRecord.size() < 2)
			return;

		// check if the player is walking or fake flicking
		if (record->m_vecVelocity.Length() >= 0.1f || record->m_bFakeFlicking) {
			g_ResolverData[player->EntIndex()].m_bPredictingUpdates = false;
			return;
		}

		C_AnimationLayer* current_layer = &record->m_serverAnimOverlays[3];
		C_AnimationLayer* previous_layer = &prev->m_serverAnimOverlays[3];

		// not breaking lby
		if (current_layer->m_flCycle > 0.987f && previous_layer->m_flCycle > 0.987f && current_layer->m_flWeight < 0.01f && previous_layer->m_flWeight < 0.01f && !(player->GetSequenceActivity(current_layer->m_nSequence) == 979))
		{
			record->m_iResolverMode = EResolverModes::RESOLVE_LBY;
			record->m_resolver_mode = XorStr("LBY");
			g_ResolverData[player->EntIndex()].m_bPredictingUpdates = false;
			record->m_angEyeAngles.y = player->m_angEyeAngles().y = record->m_flLowerBodyYawTarget;
			return;
		}
		// cycle check to make sure we dont miss delayed (> 1.1) break timers.
		else if (current_layer->m_flCycle == 0.f && (abs(record->m_flLowerBodyYawTarget - prev->m_flLowerBodyYawTarget) > 1.f || player->m_flAnimationTime() >= g_ResolverData[player->EntIndex()].m_flNextBodyUpdate))
		{
			record->m_iResolverMode = EResolverModes::RESOLVE_LBY_UPDATE;
			record->m_resolver_mode = XorStr("LBY UPDATE");
			g_ResolverData[player->EntIndex()].m_bPredictingUpdates = true;
			g_ResolverData[player->EntIndex()].m_flNextBodyUpdate = player->m_flAnimationTime() + 1.1f;
			record->m_angEyeAngles.y = record->m_angLastFlick.y = player->m_angEyeAngles().y = record->m_flLowerBodyYawTarget;
		}
	}

	void CResolver::ResolveWalk(C_CSPlayer* player, C_AnimationRecord* record)
	{
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local)
			return;

		// apply lby to eyeangles.
		record->m_iResolverMode = EResolverModes::RESOLVE_WALK;
		record->m_resolver_mode = XorStr("MOVING");
		record->m_angEyeAngles.y = player->m_angEyeAngles().y = record->m_flLowerBodyYawTarget;
		g_ResolverData[player->EntIndex()].m_bPredictingUpdates = false;
		g_ResolverData[player->EntIndex()].m_flNextBodyUpdate = player->m_flAnimationTime() + 0.22f;

		// get lag data.
		Encrypted_t<C_EntityLagData> pLagData = LagCompensation::Get()->GetLagData(player->EntIndex());
		if (pLagData.IsValid()) {
			// predict the next time if they stop moving.
			pLagData->m_iMissedShotsLBY = 0;
			pLagData->m_iMissedShotsLastmove = 0;
			pLagData->m_iMissedShotsFreestand = 0;
			pLagData->m_iMissedShotsBrute = 0;
			pLagData->m_iMissedShotsAir = 0;
			pLagData->m_iMissedShotsDistort = 0;
			pLagData->m_iMissedShots = 0;
		}

		// store the data about the moving player, we need to because it contains crucial info
		// that we will have to later on use in our resolver.
		g_ResolverData[player->EntIndex()].m_sMoveData.m_flAnimTime = player->m_flAnimationTime();
		g_ResolverData[player->EntIndex()].m_sMoveData.m_vecOrigin = record->m_vecOrigin;
		g_ResolverData[player->EntIndex()].m_sMoveData.m_flLowerBodyYawTarget = record->m_flLowerBodyYawTarget;
		g_ResolverData[player->EntIndex()].m_sMoveData.m_flSimulationTime = record->m_flSimulationTime;
		g_ResolverData[player->EntIndex()].m_bCollectedValidMoveData = true;
	}

	void CResolver::ResolveAir(C_CSPlayer* player, C_AnimationRecord* record)
	{
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local)
			return;

		auto& data = g_ResolverData[player->EntIndex()];

		Encrypted_t<C_EntityLagData> pLagData = LagCompensation::Get()->GetLagData(player->EntIndex());
		if (!pLagData.IsValid()) {
			return;
		}

		// get predicted away angle for the player.
		Vector angAway;
		Math::VectorAngles(local->m_vecOrigin() - player->m_vecOrigin(), angAway);

		// they have barely any speed. 
		if (record->m_vecAnimationVelocity.Length2D() < 25.f)
		{
			// invoke our stand resolver.
			ResolveStand(player, record);
			return;
		}

		record->m_iResolverMode = RESOLVE_AIR;
		record->m_resolver_mode = XorStr("AIR");

		if (pLagData->m_iMissedShotsAir < 1)
			record->m_angEyeAngles.y = player->m_angEyeAngles().y = record->m_flLowerBodyYawTarget;
		else
			record->m_angEyeAngles.y = player->m_angEyeAngles().y = angAway.y + 180.f;
	}
}
```

`CSGO SDK/Features/Rage/Resolver.hpp`:

```hpp
#pragma once
#include "LagCompensation.hpp"
#include <vector>
#include <deque>

namespace Engine {
	// taken from supremacy
	enum EResolverModes : size_t {
		RESOLVE_NONE = 0,
		RESOLVE_WALK,
		RESOLVE_FREESTAND,
		RESOLVE_LAST_LBY,
		RESOLVE_BRUTEFORCE,
		RESOLVE_AIR,
		RESOLVE_LBY_UPDATE,
		RESOLVE_LBY,
	};

	struct CResolverData {
		struct LastMoveData_t {
			float m_flLowerBodyYawTarget;
			float m_flSimulationTime;
			float m_flAnimTime;
			Vector m_vecOrigin;
		};

		bool m_bCollectedValidMoveData;
		bool m_bWentDormant;
		bool m_bPredictingUpdates;

		Vector m_vecSavedOrigin;
		LastMoveData_t m_sMoveData;

		float m_flBestYaw;
		float m_flBestDistance;

		float m_flNextBodyUpdate;
		float m_flFakeFlickUpdate;
		float m_flFinalResolverYaw;
		float m_flOldLowerBodyYawTarget;
		bool  m_bCollectedFreestandData;
		int m_iMissedShots = 0;
		int m_iMissedShotsLBY = 0;

	};

	class CResolver {
	private:
		void ResolveWalk(C_CSPlayer* player, C_AnimationRecord* record);
		void ResolveStand(C_CSPlayer* player, C_AnimationRecord* record);
		void ResolveAir(C_CSPlayer* player, C_AnimationRecord* record);
		bool ShouldUseFreestand(C_CSPlayer* player, C_AnimationRecord* record);
		void Freestand(C_CSPlayer* player, C_AnimationRecord* record);
		int  GetChokedPackets(C_CSPlayer* player);
		bool bFacingright;
		bool bFacingleft;
	public:
		void ResolveYaw(C_CSPlayer* player, C_AnimationRecord* record);
		void PredictBodyUpdates(C_CSPlayer* player, C_AnimationRecord* record, C_AnimationRecord* prev);
		void MatchShot(C_CSPlayer* player, C_AnimationRecord* record, C_AnimationRecord* prev);
	public:

		// freestanding.
		class AdaptiveAngle {
		public:
			float m_yaw;
			float m_dist;

		public:
			// ctor.
			__forceinline AdaptiveAngle() :
				m_yaw{ },
				m_dist{ }
			{ };

			__forceinline AdaptiveAngle(float yaw, float penalty = 0.f) {
				// set yaw.
				m_yaw = Math::AngleNormalize(yaw);

				// init distance.
				m_dist = 0.f;

				// remove penalty.
				m_dist -= penalty;
			}
		};
	};

	extern CResolver g_Resolver;
	extern CResolverData g_ResolverData[65];
}
```

`CSGO SDK/Features/Rage/ShotInformation.cpp`:

```cpp
#include "ShotInformation.hpp"
#include "../Visuals/EventLogger.hpp"
#include <sstream>
#include "Autowall.h"
#include "Resolver.hpp"

namespace Engine
{
	struct C_TraceData {
		bool is_resolver_issue;
		bool is_correct;
	};

	bool CanHitPlayer(C_LagRecord* pRecord, int iSide, const Vector& vecEyePos, const Vector& vecEnd, int iHitboxIndex) {
		auto hdr = *(studiohdr_t**)pRecord->player->m_pStudioHdr();
		if (!hdr)
			return false;

		auto pHitboxSet = hdr->pHitboxSet(pRecord->player->m_nHitboxSet());

		if (!pHitboxSet)
			return false;

		auto pHitbox = pHitboxSet->pHitbox(iHitboxIndex);

		if (!pHitbox)
			return false;

		bool bIsCapsule = pHitbox->m_flRadius != -1.0f;
		bool bHitIntersection = false;

		CGameTrace tr;

		//Interfaces::m_pDebugOverlay->AddLineOverlay( eyePos, end, 255, 0, 0, false, 5.f );

		matrix3x4_t* pBone = pRecord->GetBoneMatrix();

		Vector vecMin = pHitbox->bbmin.Transform(pBone[pHitbox->bone]);
		Vector vecMax = pHitbox->bbmax.Transform(pBone[pHitbox->bone]);

		bHitIntersection = bIsCapsule ?
			Math::IntersectSegmentToSegment(vecEyePos, vecEnd, vecMin, vecMax, pHitbox->m_flRadius) : Math::IntersectionBoundingBox(vecEyePos, vecEnd, vecMin, vecMax);//( tr.hit_entity == pRecord->player && ( tr.hitgroup >= Hitgroup_Head && tr.hitgroup <= Hitgroup_RightLeg ) || tr.hitgroup == Hitgroup_Gear );

		return bHitIntersection;
	};

	void TraceMatrix(const Vector& vecStart, const Vector& vecEnd, C_LagRecord* pRecord, C_CSPlayer* Player,
		std::vector<C_TraceData>& TracesData, int iSide, bool bDidHit, int iHitboxIndex) {
		auto& TraceData = TracesData.emplace_back();

		pRecord->Apply(Player);

		TraceData.is_resolver_issue = CanHitPlayer(pRecord, iSide, vecStart, vecEnd, iHitboxIndex);
		TraceData.is_correct = TraceData.is_resolver_issue == bDidHit;
	}

	Encrypted_t<C_ShotInformation> C_ShotInformation::Get() {
		static C_ShotInformation instance;
		return &instance;
	}

	void C_ShotInformation::Start() {
		auto netchannel = Encrypted_t<INetChannel>(Interfaces::m_pEngine->GetNetChannelInfo());
		if (!netchannel.IsValid()) {
			return;
		}

		ProcessEvents();

		auto latency = netchannel->GetAvgLatency(FLOW_OUTGOING) * 1000.f;

		const auto pLocal = C_CSPlayer::GetLocalPlayer();
		auto it = this->m_Shapshots.begin();
		while (it != this->m_Shapshots.end()) {
			it++;
		}
	}

	void C_ShotInformation::ProcessEvents() {
		auto TranslateHitbox = [](int hitbox) -> std::string {
			std::string result = { };
			switch (hitbox) {
			case HITBOX_HEAD:
				result = XorStr("head"); break;
			case HITBOX_NECK:
			case HITBOX_LOWER_NECK:
				result = XorStr("neck"); break;
			case HITBOX_CHEST:
			case HITBOX_LOWER_CHEST:
			case HITBOX_UPPER_CHEST:
				result = XorStr("chest"); break;
			case HITBOX_RIGHT_FOOT:
			case HITBOX_RIGHT_CALF:
			case HITBOX_RIGHT_THIGH:
			case HITBOX_LEFT_FOOT:
			case HITBOX_LEFT_CALF:
			case HITBOX_LEFT_THIGH:
				result = XorStr("leg"); break;
			case HITBOX_LEFT_FOREARM:
			case HITBOX_LEFT_HAND:
			case HITBOX_LEFT_UPPER_ARM:
			case HITBOX_RIGHT_FOREARM:
			case HITBOX_RIGHT_HAND:
			case HITBOX_RIGHT_UPPER_ARM:
				result = XorStr("arm"); break;
			case HITBOX_STOMACH:
			case HITBOX_PELVIS:
				result = XorStr("stomach"); break;
			default:
				result = XorStr("-");
			}

			return result;
		};

		auto FixedStrLength = [](std::string str) -> std::string {
			if ((int)str[0] > 255)
				return XorStr("");

			if (str.size() < 15)
				return str;

			std::string result;
			for (size_t i = 0; i < 15u; i++)
				result.push_back(str.at(i));
			return result;
		};

		if (!this->m_GetEvents) {
			return;
		}

		this->m_GetEvents = false;

		if (this->m_Shapshots.empty()) {
			this->m_Weaponfire.clear();
			return;
		}

		if (this->m_Weaponfire.empty()) {
			return;
		}

		try {
			auto it = this->m_Weaponfire.begin();
			while (it != this->m_Weaponfire.end()) {
				if (this->m_Shapshots.empty() || this->m_Weaponfire.empty()) {
					this->m_Weaponfire.clear();
					break;
				}

				auto snapshot = it->snapshot;

				if (!(&it->snapshot) || !&(*it->snapshot)) {
					it = this->m_Weaponfire.erase(it);
					continue;
				}

				if (snapshot == this->m_Shapshots.end()) {
					it = this->m_Weaponfire.erase(it);
					continue;
				}

				auto player = snapshot->player;
				if (!player) {
					this->m_Shapshots.erase(it->snapshot);
					it = this->m_Weaponfire.erase(it);
					continue;
				}

				if (player != C_CSPlayer::GetPlayerByIndex(it->snapshot->playerIdx)) {
					this->m_Shapshots.erase(it->snapshot);
					it = this->m_Weaponfire.erase(it);
					continue;
				}

				auto anim_data = AnimationSystem::Get()->GetAnimationData(player->m_entIndex);
				if (!anim_data) {
					this->m_Shapshots.erase(it->snapshot);
					it = this->m_Weaponfire.erase(it);
					continue;
				}

				if (it->impacts.empty()) {
					this->m_Shapshots.erase(it->snapshot);
					it = this->m_Weaponfire.erase(it);
					continue;
				}

				auto& lag_data = Engine::LagCompensation::Get()->GetLagData(player->m_entIndex);
				if (player->IsDead()) {
					this->m_Shapshots.erase(it->snapshot);
					it = this->m_Weaponfire.erase(it);
					continue;
				}

				auto did_hit = it->damage.size() > 0;

				// last reseived impact
				auto last_impact = it->impacts.back();

				C_BaseLagRecord backup;
				backup.Setup(player);

				std::vector<C_TraceData> trace_data;
				TraceMatrix(it->snapshot->eye_pos, last_impact, &it->snapshot->resolve_record, player, trace_data, 0, did_hit, it->snapshot->Hitbox);

				backup.Apply(player);

				g_Vars.globals.m_iFiredShots++;

				if (!did_hit) {
					auto aimpoint_distance = it->snapshot->eye_pos.Distance(it->snapshot->AimPoint) - 32.f;
					auto impact_distance = it->snapshot->eye_pos.Distance(last_impact);
					float aimpoint_lenght = it->snapshot->AimPoint.Length();
					float impact_lenght = last_impact.Length();
					C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
					auto td = &trace_data[0];

					auto AddMissLog = [&](std::string reason) -> void {
						std::stringstream msg;
						player_info_t info;
						if (Interfaces::m_pEngine->GetPlayerInfo(it->snapshot->playerIdx, &info)) {

							msg << XorStr("Missed shot due to ") << reason.data();

							ILoggerEvent::Get()->PushEvent(msg.str(), FloatColor(255, 255, 25, 255), true);

						}
					};

					if (td->is_resolver_issue) {

						if (it->snapshot->ResolverType == EResolverModes::RESOLVE_LBY_UPDATE)
							++lag_data->m_iMissedShotsLBY;
						else if (it->snapshot->ResolverType == EResolverModes::RESOLVE_LAST_LBY)
							++lag_data->m_iMissedShotsLastmove;
						else if (it->snapshot->ResolverType == EResolverModes::RESOLVE_FREESTAND)
							++lag_data->m_iMissedShotsFreestand;
						else if (it->snapshot->ResolverType == EResolverModes::RESOLVE_BRUTEFORCE)
							++lag_data->m_iMissedShotsBrute;
						else if (it->snapshot->ResolverType == EResolverModes::RESOLVE_AIR)
							++lag_data->m_iMissedShotsAir;
						else
							++lag_data->m_iMissedShots;

						if (g_Vars.esp.event_resolver) {
							AddMissLog(XorStr("resolver"));
						}
					}
					else if (aimpoint_distance > impact_distance) { // occulusion issue
						if (g_Vars.esp.event_resolver) {
							AddMissLog(XorStr("occlusion"));
						}
					}
					else if (local->IsDead()) { // dead before shot registers
						if (g_Vars.esp.event_resolver) {
							AddMissLog(XorStr("dead"));
						}
					}
					else if (player->IsDead()) {
						if (g_Vars.esp.event_resolver) {
							AddMissLog(XorStr("enemy dead"));
						}
					}
					else { // spread issue
						if (g_Vars.esp.event_resolver) {
							AddMissLog(XorStr("spread"));
						}
					}
				}
				else {

					//	ILoggerEvent::Get()->PushEvent("i cry", FloatColor(255, 128, 128), true);

					bool shoud_break = false;
					auto best_damage = it->damage.end();
					auto dmg = it->damage.begin();
					while (dmg != it->damage.end()) {
						shoud_break = true;
						if (best_damage == it->damage.end()
							|| dmg->damage > best_damage->damage) {
							best_damage = dmg;
						}

						dmg++;
					}


					if (it->snapshot->Hitgroup != best_damage->hitgroup) {

					}
					else {

					}
				}

				this->m_Shapshots.erase(it->snapshot);
				it = this->m_Weaponfire.erase(it);
			}
		}
		catch (const std::exception&) {
			return;
		}
	}

	void C_ShotInformation::EventCallback(IGameEvent* gameEvent, uint32_t hash) {
		if (this->m_Shapshots.empty()) {
			return;
		}
		auto net_channel = Encrypted_t<INetChannel>(Interfaces::m_pEngine->GetNetChannelInfo());
		if (!net_channel.IsValid()) {
			this->m_Shapshots.clear();
			return;
		}

		C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
		if (!local || local->IsDead()) {
			this->m_Shapshots.clear();
			return;
		}

		C_WeaponCSBaseGun* weapon = (C_WeaponCSBaseGun*)(local->m_hActiveWeapon().Get());
		if (!weapon) {
			this->m_Shapshots.clear();
			return;
		}

		auto weapon_data = weapon->GetCSWeaponData();
		if (!weapon_data.IsValid()) {
			this->m_Shapshots.clear();
			return;
		}

		auto it = this->m_Shapshots.begin();
		while (it != this->m_Shapshots.end()) {
			// unhandled snapshots
			if (std::fabsf(it->time - Interfaces::m_pGlobalVars->realtime) >= 2.5f) {
				it = this->m_Shapshots.erase(it);
			}
			else {
				it++;
			}
		}

		auto snapshot = this->m_Shapshots.end();

		switch (hash) {
		case hash_32_fnv1a_const("player_hurt"):
		{
			if (this->m_Weaponfire.empty() || Interfaces::m_pEngine->GetPlayerForUserID(gameEvent->GetInt(XorStr("attacker"))) != local->EntIndex())
				return;

			// TODO: check if need backtrack
			auto target = C_CSPlayer::GetPlayerByIndex(Interfaces::m_pEngine->GetPlayerForUserID(gameEvent->GetInt(XorStr("userid"))));
			if (!target || target == local || local->IsTeammate(target) || target->IsDormant())
				return;

			auto& player_damage = this->m_Weaponfire.back().damage.emplace_back();
			player_damage.playerIdx = target->m_entIndex;
			player_damage.player = target;
			player_damage.damage = gameEvent->GetInt(XorStr("dmg_health"));
			player_damage.hitgroup = gameEvent->GetInt(XorStr("hitgroup"));
			break;
		}
		case hash_32_fnv1a_const("bullet_impact"):
		{
			if (this->m_Weaponfire.empty() || Interfaces::m_pEngine->GetPlayerForUserID(gameEvent->GetInt(XorStr("userid"))) != local->EntIndex())
				return;

			this->m_Weaponfire.back().impacts.emplace_back(gameEvent->GetFloat(XorStr("x")), gameEvent->GetFloat(XorStr("y")), gameEvent->GetFloat(XorStr("z")));
			break;
		}
		case hash_32_fnv1a_const("weapon_fire"):
		{
			if (Interfaces::m_pEngine->GetPlayerForUserID(gameEvent->GetInt(XorStr("userid"))) != local->EntIndex())
				return;

			int nElement = this->m_Weaponfire.size() / weapon_data->m_iBullets;

			// will get iBullets weapon_fire events
			if (nElement != this->m_Shapshots.size()) {
				snapshot = this->m_Shapshots.begin() + nElement;
				auto& fire = this->m_Weaponfire.emplace_back();
				fire.snapshot = snapshot;
			}
			break;
		}
		case hash_32_fnv1a_const("player_death"):
		{


			break;
		}
		case hash_32_fnv1a_const("round_start"):
		{
			for (int i = 1; i < Interfaces::m_pGlobalVars->maxClients; ++i) {

				auto lagData = Engine::LagCompensation::Get()->GetLagData(i);
				if (lagData.IsValid()) {
					Engine::g_ResolverData[i].m_sMoveData.m_flSimulationTime = 0.f;
					lagData->m_iMissedShots = 0;
					lagData->m_iMissedShotsLBY = 0;
					lagData->m_iMissedShotsLastmove = 0;
					lagData->m_iMissedShotsFreestand = 0;
					lagData->m_iMissedShotsBrute = 0;
					lagData->m_iMissedShotsAir = 0;
					lagData->m_iMissedShotsDistort = 0;
					g_Vars.globals.m_iFiredShots = 0;
				}
			}

			break;
		}
		}

		this->m_GetEvents = true;
	}

	void C_ShotInformation::CreateSnapshot(C_CSPlayer* player, const Vector& shootPosition, const Vector& aimPoint, Engine::C_LagRecord* record, int resolverSide, int hitgroup, int hitbox, int nDamage, bool doubleTap) {
		auto& snapshot = this->m_Shapshots.emplace_back();

		snapshot.playerIdx = player->m_entIndex;
		snapshot.player = player;
		snapshot.resolve_record = *record;
		snapshot.eye_pos = shootPosition;
		snapshot.time = Interfaces::m_pGlobalVars->realtime;
		snapshot.correctSequence = false;
		snapshot.correctEyePos = false;
		snapshot.Hitbox = hitbox;
		snapshot.doubleTap = doubleTap;
		snapshot.ResolverType = resolverSide;

		snapshot.AimPoint = aimPoint;
		snapshot.Hitgroup = hitgroup;
		snapshot.m_nSelectedDamage = nDamage;

		auto data = AnimationSystem::Get()->GetAnimationData(player->m_entIndex);
		if (data) {
			data->m_flLastScannedYaw = record->m_flEyeYaw;
		}
	}

	void C_ShotInformation::CorrectSnapshots(bool is_sending_packet) {
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local)
			return;

		auto netchannel = Encrypted_t<INetChannel>(Interfaces::m_pEngine->GetNetChannelInfo());
		if (!netchannel.IsValid())
			return;

		for (auto& snapshot : this->m_Shapshots) {
			if (is_sending_packet && !snapshot.correctSequence) {
				snapshot.outSequence = Interfaces::m_pClientState->m_nLastOutgoingCommand() + Interfaces::m_pClientState->m_nChokedCommands() + 1;
				snapshot.correctSequence = true;
			}
		}
	}
}


```

`CSGO SDK/Features/Rage/ShotInformation.hpp`:

```hpp
#pragma once
#include "LagCompensation.hpp"
#include <vector>
#include <deque>

namespace Engine
{
	struct ShotSnapshot {
		int playerIdx;
		int outSequence;
		bool correctEyePos;
		bool correctSequence;
		C_CSPlayer* player;
		Engine::C_LagRecord resolve_record;
		Vector eye_pos;
		float time;
		bool doubleTap;

		// onepaste
		Vector AimPoint;

		int Hitgroup;
		int Hitbox;
		int ResolverType;

		int m_nSelectedDamage;
	};

	struct PlayerHurt_t {
		int damage;
		int hitgroup;
		C_CSPlayer* player;
		int playerIdx;
	};

	struct WeaponFire_t {
		std::vector< Vector > impacts;
		std::vector< PlayerHurt_t > damage;
		std::deque< ShotSnapshot >::iterator snapshot;
		bool didDraw = false;
	};

	class C_ShotInformation {
	public:
		static Encrypted_t<C_ShotInformation> Get();

		void Start();
		void ProcessEvents();

		void EventCallback(IGameEvent* gameEvent, uint32_t hash);
		void CreateSnapshot(C_CSPlayer* player, const Vector& shootPosition, const Vector& aimPoint, Engine::C_LagRecord* record, int resolverSide, int hitgroup, int hitbox, int nDamage, bool doubleTap = false);
		void CorrectSnapshots(bool is_sending_packet);

		std::deque< ShotSnapshot > m_Shapshots;
		std::vector< WeaponFire_t > m_Weaponfire;

		bool m_GetEvents = false;
	};
}
```

`CSGO SDK/Features/Rage/TickbaseShift.cpp`:

```cpp
#include "TickbaseShift.hpp"
#include "../../source.hpp"
#include "../../SDK/Classes/player.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "../Miscellaneous/Movement.hpp"
#include "../Game/Prediction.hpp"
#include "../../Libraries/minhook-master/include/MinHook.h"
#include "../../Hooking/Hooked.hpp"
#include "../../SDK/Displacement.hpp"

void* g_pLocal = nullptr;
TickbaseSystem g_TickbaseController;

TickbaseShift_t::TickbaseShift_t(int _cmdnum, int _tickbase) :
	cmdnum(_cmdnum), tickbase(_tickbase)
{
	;
}

#define OFFSET_LASTOUTGOING 0x4CAC
#define OFFSET_CHOKED 0x4CB0
#define OFFSET_TICKBASE 0x3404

bool TickbaseSystem::IsTickcountValid(int nTick) {
	return nTick >= (Interfaces::m_pGlobalVars->tickcount + int(1 / Interfaces::m_pGlobalVars->interval_per_tick) + g_Vars.sv_max_usercmd_future_ticks->GetInt());
}

void WriteUsercmdD(bf_write* buf, CUserCmd* incmd, CUserCmd* outcmd) {
	__asm
	{
		mov     ecx, buf
		mov     edx, incmd
		push    outcmd
		call    Engine::Displacement.Function.m_WriteUsercmd
		add     esp, 4
	}
}

bool Hooked::WriteUsercmdDeltaToBuffer(void* ECX, void* EDX, int nSlot, void* buffer, int o_from, int o_to, bool isnewcommand) {

	if (g_TickbaseController.iCommandsToShift <= 0)
		return oWriteUsercmdDeltaToBuffer;

	if (o_from != -1)
		return true;

	o_from = -1;

	int m_nTickbase = g_TickbaseController.iCommandsToShift;
	g_TickbaseController.iCommandsToShift = 0;

	int* m_pnNewCmds = (int*)((uintptr_t)buffer - 0x2C);
	int* m_pnBackupCmds = (int*)((uintptr_t)buffer - 0x30);

	*m_pnBackupCmds = 0;

	int m_nNewCmds = *m_pnNewCmds;
	int m_nNextCmd = Interfaces::m_pClientState->m_nChokedCommands() + Interfaces::m_pClientState->m_nLastOutgoingCommand() + 1;
	int m_nTotalNewCmds = std::min(m_nNewCmds + abs(m_nTickbase), 16);

	*m_pnNewCmds = m_nTotalNewCmds;

	for (o_to = m_nNextCmd - m_nNewCmds + 1; o_to <= m_nNextCmd; o_to++) {
		if (!oWriteUsercmdDeltaToBuffer)
			return false;

		o_from = o_to;
	}

	CUserCmd* m_pCmd = Interfaces::m_pInput->GetUserCmd(nSlot, o_from);
	if (!m_pCmd)
		return true;

	CUserCmd m_ToCmd = *m_pCmd, m_FromCmd = *m_pCmd;
	m_ToCmd.command_number++;
	m_ToCmd.tick_count += 3 * (int)std::round(1.f / Interfaces::m_pGlobalVars->interval_per_tick);

	for (int i = m_nNewCmds; i <= m_nTotalNewCmds; i++) {
		WriteUsercmdD((bf_write*)buffer, &m_ToCmd, &m_FromCmd);
		m_FromCmd = m_ToCmd;

		m_ToCmd.command_number++;
		m_ToCmd.tick_count++;
	}

	//g_TickbaseController.m_shift_data.m_current_shift = m_nTickbase;
	return true;
}

void InvokeRunSimulation(void* this_, float curtime, int cmdnum, CUserCmd* cmd, size_t local) {
	__asm {
		push local
		push cmd
		push cmdnum

		movss xmm2, curtime
		mov ecx, this_

		call Hooked::RunSimulationDetor.m_pOldFunction
	}
}

void TickbaseSystem::OnRunSimulation(void* this_, int iCommandNumber, CUserCmd* pCmd, size_t local) {
	g_pLocal = (void*)local;

	float curtime;
	__asm
	{
		movss curtime, xmm2
	}

	for (int i = 0; i < (int)g_iTickbaseShifts.size(); i++)
	{
		if ((g_iTickbaseShifts[i].cmdnum < iCommandNumber - s_iNetBackup) ||
			(g_iTickbaseShifts[i].cmdnum > iCommandNumber + s_iNetBackup))
		{
			g_iTickbaseShifts.erase(g_iTickbaseShifts.begin() + i);
			i--;
		}
	}

	int tickbase = -1;
	for (size_t i = 0; i < g_iTickbaseShifts.size(); i++)
	{

		//TO:DO this is completely wrong. needs redone.
		const auto& elem = g_iTickbaseShifts[i];

		if (elem.cmdnum == iCommandNumber)
		{
			tickbase = elem.tickbase;
			break;
		}
	}

	if (tickbase != -1 && local)
	{
		*(int*)(local + OFFSET_TICKBASE) = tickbase;
		curtime = tickbase * s_flTickInterval;
	}
	InvokeRunSimulation(this_, curtime, iCommandNumber, pCmd, local);
}

void TickbaseSystem::OnPredictionUpdate(void* prediction, void*, int startframe, bool validframe, int incoming_acknowledged, int outgoing_command) {
	typedef void(__thiscall* PredictionUpdateFn_t)(void*, int, bool, int, int);
	PredictionUpdateFn_t fn = (PredictionUpdateFn_t)Hooked::PredictionUpdateDetor.m_pOldFunction;
	fn(prediction, startframe, validframe, incoming_acknowledged, outgoing_command);

	if (s_bInMove && g_pLocal) {
		*(int*)((size_t)g_pLocal + OFFSET_TICKBASE) = s_iMoveTickBase;
	}

	if (g_pLocal) {
		for (size_t i = 0; i < g_iTickbaseShifts.size(); i++) {
			const auto& elem = g_iTickbaseShifts[i];

			if (elem.cmdnum == (outgoing_command + 1)) {
				*(int*)((size_t)g_pLocal + OFFSET_TICKBASE) = elem.tickbase;
				break;
			}
		}
	}
}

```

`CSGO SDK/Features/Rage/TickbaseShift.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

struct TickbaseShift_t {
	TickbaseShift_t() = delete;
	TickbaseShift_t(int _cmdnum, int _tickbase);
	~TickbaseShift_t() = default;

	int cmdnum, tickbase;
};

class TickbaseSystem {
public:
	size_t s_nSpeed = 14;

	size_t s_nTickRate = 64;
	float s_flTickInterval = 1.f / (float)s_nTickRate;

	// an unreplicated convar: sv_clockcorrection_msecs
	float s_flClockCorrectionSeconds = 30.f / 1000.f;

	int s_iClockCorrectionTicks = (int)(s_flClockCorrectionSeconds * s_flTickInterval + 0.5f);
	int s_iNetBackup = 64;

	bool s_bFreshFrame = false;
	bool s_bAckedBuild = true;

	bool m_bSupressRecharge = false;

	float s_flTimeRequired = 0.4f;
	size_t s_nTicksRequired = (int)(s_flTimeRequired / s_flTickInterval + 0.5f);
	size_t s_nTicksDelay = 32u;

	bool s_bInMove = false;
	int s_iMoveTickBase = 0;
	size_t s_nTicksSinceUse = 0u;
	size_t s_nTicksSinceStarted = 0u;

	int s_iServerIdealTick = 0;
	bool s_bBuilding = false;

	int iCommandsToShift = 0;

	size_t s_nExtraProcessingTicks = 0;
	std::vector<TickbaseShift_t> g_iTickbaseShifts;

	bool IsTickcountValid(int nTick);
	void OnRunSimulation(void* this_, int iCommandNumber, CUserCmd* pCmd, size_t local);
	void OnPredictionUpdate(void* prediction, void*, int startframe, bool validframe, int incoming_acknowledged, int outgoing_command);
};

extern TickbaseSystem g_TickbaseController;
```

`CSGO SDK/Features/Rage/ZeusBot.cpp`:

```cpp
#include "ZeusBot.hpp"
#include "../../SDK/Classes/player.hpp"
#include "../../source.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "LagCompensation.hpp"
#include "TickbaseShift.hpp"
#include "Autowall.h"
#include "Ragebot.hpp"
#include "ShotInformation.hpp"
#include "../Visuals/CChams.hpp"

// onetap zeusbot
namespace Interfaces {
	struct ZeusBotData {
		C_CSPlayer* m_pCurrentTarget = nullptr;
		C_CSPlayer* m_pLocalPlayer = nullptr;
		C_WeaponCSBaseGun* m_pLocalWeapon = nullptr;
		Encrypted_t<CCSWeaponInfo> m_pWeaponInfo = nullptr;
		Encrypted_t<CUserCmd> m_pCmd = nullptr;
		Vector m_vecEyePos;
	};

	ZeusBotData _zeus_bot_data;

	class CZeusBot : public ZeusBot {
	public:
		CZeusBot() : zeusBotData(&_zeus_bot_data) { }

		void Main(Encrypted_t<CUserCmd> pCmd, bool* sendPacket) override;
	private:
		bool TargetEntity(C_CSPlayer* pPlayer, bool* sendPacket, Engine::C_LagRecord* record);

		Encrypted_t<ZeusBotData> zeusBotData;
	};

	ZeusBot* ZeusBot::Get() {
		static CZeusBot instance;
		return &instance;
	}

	void CZeusBot::Main(Encrypted_t<CUserCmd> pCmd, bool* sendPacket) {
		if (!Interfaces::m_pEngine->IsInGame() || !g_Vars.rage.enabled || !g_Vars.misc.zeus_bot)
			return;

		zeusBotData->m_pLocalPlayer = C_CSPlayer::GetLocalPlayer();
		if (!zeusBotData->m_pLocalPlayer || zeusBotData->m_pLocalPlayer->IsDead())
			return;

		zeusBotData->m_pLocalWeapon = (C_WeaponCSBaseGun*)zeusBotData->m_pLocalPlayer->m_hActiveWeapon().Get();
		if (!zeusBotData->m_pLocalWeapon || !zeusBotData->m_pLocalWeapon->IsWeapon())
			return;

		zeusBotData->m_pWeaponInfo = zeusBotData->m_pLocalWeapon->GetCSWeaponData();
		if (!zeusBotData->m_pWeaponInfo.IsValid())
			return;

		zeusBotData->m_pCmd = pCmd;
		if (zeusBotData->m_pLocalPlayer->m_flNextAttack() > Interfaces::m_pGlobalVars->curtime || zeusBotData->m_pLocalWeapon->m_flNextPrimaryAttack() > Interfaces::m_pGlobalVars->curtime)
			return;

		if (zeusBotData->m_pLocalWeapon->m_iItemDefinitionIndex() != WEAPON_ZEUS)
			return;

		zeusBotData->m_vecEyePos = zeusBotData->m_pLocalPlayer->GetEyePosition();
		for (int i = 1; i <= Interfaces::m_pGlobalVars->maxClients; i++) {
			C_CSPlayer* Target = (C_CSPlayer*)Interfaces::m_pEntList->GetClientEntity(i);
			if (!Target
				|| Target->IsDead()
				|| Target->IsDormant()
				|| !Target->IsPlayer()
				|| Target->m_iTeamNum() == zeusBotData->m_pLocalPlayer->m_iTeamNum()
				|| Target->m_bGunGameImmunity())
				continue;

			auto lag_data = Engine::LagCompensation::Get()->GetLagData(Target->m_entIndex);
			if (!lag_data.IsValid() || lag_data->m_History.empty())
				continue;

			Engine::C_LagRecord* previousRecord = nullptr;
			Engine::C_LagRecord backup;
			backup.Setup(Target);
			for (auto& record : lag_data->m_History) {
				if (!(Engine::LagCompensation::Get()->IsRecordOutOfBounds(record, 0.2f))
					|| record.m_bSkipDueToResolver
					|| !record.m_bIsValid) {
					continue;
				}

				if (!previousRecord
					|| previousRecord->m_vecOrigin != record.m_vecOrigin
					|| previousRecord->m_flEyeYaw != record.m_flEyeYaw
					|| previousRecord->m_angAngles.yaw != record.m_angAngles.yaw
					|| previousRecord->m_vecMaxs != record.m_vecMaxs
					|| previousRecord->m_vecMins != record.m_vecMins) {
					previousRecord = &record;

					record.Apply(Target);
					if (TargetEntity(Target, sendPacket, &record)) {
						zeusBotData->m_pCmd->tick_count = TIME_TO_TICKS(record.m_flSimulationTime + g_Vars.globals.m_lerp);
						break;
					}
				}
			}

			backup.Apply(Target);
		}
	}

	bool CZeusBot::TargetEntity(C_CSPlayer* pPlayer, bool* sendPacket, Engine::C_LagRecord* record) {
		if (!record)
			return false;

		zeusBotData->m_pCurrentTarget = pPlayer;

		//g_Vars.misc.zeus_bot_hitchance
		auto hdr = *(studiohdr_t**)(pPlayer->m_pStudioHdr());
		if (hdr) {
			auto hitboxSet = hdr->pHitboxSet(pPlayer->m_nHitboxSet());
			if (hitboxSet) {
				auto pStomach = hitboxSet->pHitbox(HITBOX_STOMACH);
				auto vecHitboxPos = (pStomach->bbmax + pStomach->bbmin) * 0.5f;
				vecHitboxPos = vecHitboxPos.Transform(pPlayer->m_CachedBoneData().Base()[pStomach->bone]);

				// run awall
				Autowall::C_FireBulletData fireData;

				Vector vecDirection = vecHitboxPos - zeusBotData->m_vecEyePos;
				vecDirection.Normalize();

				fireData.m_bPenetration = false;
				fireData.m_vecStart = zeusBotData->m_vecEyePos;
				fireData.m_vecDirection = vecDirection;
				fireData.m_iHitgroup = Hitgroup_Stomach;
				fireData.m_Player = zeusBotData->m_pLocalPlayer;
				fireData.m_TargetPlayer = pPlayer;
				fireData.m_WeaponData = zeusBotData->m_pWeaponInfo.Xor();
				fireData.m_Weapon = zeusBotData->m_pLocalWeapon;
				fireData.m_iPenetrationCount = 0;

				// note - alpha; 
				// ghetto, shit, but good enough for zeusbot;
				// have fun doing ragebot hitchance with this implementation
				const bool bIsAccurate = !(zeusBotData->m_pLocalWeapon->GetInaccuracy() >= ((100.0f - g_Vars.misc.zeus_bot_hitchance) * 0.65f * 0.01125f));
				const float flDamage = Autowall::FireBullets(&fireData);
				if (flDamage >= 105.f && bIsAccurate) {
					Engine::C_ShotInformation::Get()->CreateSnapshot(pPlayer, zeusBotData->m_vecEyePos, vecHitboxPos, record, g_Vars.globals.m_iResolverSide[pPlayer->m_entIndex], Hitgroup_Stomach, HITBOX_STOMACH, int(flDamage));
					if (g_Vars.esp.esp_enable && g_Vars.esp.hitmatrix)
						IChams::Get()->AddHitmatrix(pPlayer, record->GetBoneMatrix());

					zeusBotData->m_pCmd->viewangles = vecDirection.ToEulerAngles();
					zeusBotData->m_pCmd->buttons |= IN_ATTACK;

					//if( !g_TickbaseController.bInRapidFire )
					//	*sendPacket = true;

					return true;
				}
			}
		}

		return false;
	}
}
```

`CSGO SDK/Features/Rage/ZeusBot.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

namespace Interfaces
{
	class __declspec(novtable) ZeusBot : public NonCopyable {
	public:
		static ZeusBot* Get();
		virtual void Main(Encrypted_t<CUserCmd> pCmd, bool* sendPacket) = NULL;
	protected:
		ZeusBot() {

		}
		virtual ~ZeusBot() {

		}
	};
}

```

`CSGO SDK/Features/Visuals/CChams.cpp`:

```cpp
#include "CChams.hpp"
#include "../../source.hpp"
#include <fstream>
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Classes/IMaterialSystem.hpp"
#include "../../SDK/CVariables.hpp"
#include "../Rage/LagCompensation.hpp"
#include "../Game/SetupBones.hpp"
#include "../../Hooking/hooked.hpp"
#include "../../SDK/displacement.hpp"
#include "../Rage/ShotInformation.hpp"
#include "../Game/Prediction.hpp"

extern C_AnimationLayer FakeAnimLayers[13];

#pragma optimize( "", off )

namespace Interfaces
{
	enum ChamsMaterials {
		MATERIAL_OFF = 0,
		MATERIAL_FLAT = 1,
		MATERIAL_REGULAR,
		MATERIAL_GLOW,
		MATERIAL_OUTLINE,
		MATERIAL_SHINY,
	};

	struct C_HitMatrixEntry {
		int ent_index;
		ModelRenderInfo_t info;
		DrawModelState_t state;
		matrix3x4_t pBoneToWorld[128] = { };
		float time;
		matrix3x4_t model_to_world;
	};

	class CChams : public IChams {
	public:
		void OnDrawModel(void* ECX, IMatRenderContext* MatRenderContext, DrawModelState_t& DrawModelState, ModelRenderInfo_t& RenderInfo, matrix3x4_t* pBoneToWorld) override;
		void DrawModel(void* ECX, IMatRenderContext* MatRenderContext, DrawModelState_t& DrawModelState, ModelRenderInfo_t& RenderInfo, matrix3x4_t* pBoneToWorld) override;
		bool GetBacktrackMatrix(C_CSPlayer* player, matrix3x4_t* out);
		void OnPostScreenEffects() override;
		bool IsVisibleScan(C_CSPlayer* player);	  virtual void AddHitmatrix(C_CSPlayer* player, matrix3x4_t* bones);

		CChams();
		~CChams();

		virtual bool CreateMaterials() {
			if (m_bInit)
				return true;

			m_matRegular = Interfaces::m_pMatSystem->FindMaterial(("debug/debugambientcube"), nullptr);
			m_matFlat = Interfaces::m_pMatSystem->FindMaterial(("debug/debugdrawflat"), nullptr);
			m_matGlow = Interfaces::m_pMatSystem->FindMaterial(("dev/glow_armsrace"), nullptr);

			std::ofstream("csgo\\materials\\pdr_shine.vmt") << R"#("VertexLitGeneric"
			{
					"$basetexture" "vgui/white_additive"
					"$ignorez"      "0"
					"$phong"        "1"
					"$BasemapAlphaPhongMask"        "1"
					"$phongexponent" "15"
					"$normalmapalphaenvmask" "1"
					"$envmap"       "env_cubemap"
					"$envmaptint"   "[0.6 0.6 0.6]"
					"$phongboost"   "[0.6 0.6 0.6]"
					"phongfresnelranges"   "[0.5 0.5 1.0]"
					"$nofog"        "1"
					"$model"        "1"
					"$nocull"       "0"
					"$selfillum"    "1"
					"$halflambert"  "1"
					"$znearer"      "0"
					"$flat"         "1"
			}
			)#";

			m_matShiny = Interfaces::m_pMatSystem->FindMaterial(XorStr("pdr_shine"), TEXTURE_GROUP_MODEL);

			if (!m_matRegular || m_matRegular == nullptr || m_matRegular->IsErrorMaterial())
				return false;

			if (!m_matFlat || m_matFlat == nullptr || m_matFlat->IsErrorMaterial())
				return false;

			if (!m_matGlow || m_matGlow == nullptr || m_matGlow->IsErrorMaterial())
				return false;

			if (!m_matShiny || m_matShiny == nullptr || m_matShiny->IsErrorMaterial())
				return false;

			m_bInit = true;
			return true;
		}

	private:
		void OverrideMaterial(bool ignoreZ, int type, const FloatColor& rgba, float glow_mod = 0, bool wf = false, const FloatColor& pearlescence_clr = { }, float pearlescence = 1.f, float shine = 1.f);

		bool m_bInit = false;
		IMaterial* m_matFlat = nullptr;
		IMaterial* m_matRegular = nullptr;
		IMaterial* m_matGlow = nullptr;
		IMaterial* m_matShiny = nullptr;

		std::vector<C_HitMatrixEntry> m_Hitmatrix;
	};

	Encrypted_t<IChams> IChams::Get() {
		static CChams instance;
		return &instance;
	}

	CChams::CChams() {

	}

	CChams::~CChams() {

	}

	void CChams::OnPostScreenEffects() {
		auto pLocal = C_CSPlayer::GetLocalPlayer();

		if (!g_Vars.globals.HackIsReady || !Interfaces::m_pEngine->IsConnected() || !Interfaces::m_pEngine->IsInGame() || !pLocal) {
			m_Hitmatrix.clear();
			return;
		}

		if (m_Hitmatrix.empty())
			return;

		if (!Interfaces::m_pStudioRender.IsValid())
			return;

		auto ctx = Interfaces::m_pMatSystem->GetRenderContext();

		if (!ctx)
			return;

		auto DrawModelRebuild = [&](C_HitMatrixEntry it) -> void {
			if (!g_Vars.r_drawmodelstatsoverlay)
				return;

			DrawModelResults_t results;
			DrawModelInfo_t info;
			ColorMeshInfo_t* pColorMeshes = NULL;
			info.m_bStaticLighting = false;
			info.m_pStudioHdr = it.state.m_pStudioHdr;
			info.m_pHardwareData = it.state.m_pStudioHWData;
			info.m_Skin = it.info.skin;
			info.m_Body = it.info.body;
			info.m_HitboxSet = it.info.hitboxset;
			info.m_pClientEntity = (IClientRenderable*)it.state.m_pRenderable;
			info.m_Lod = it.state.m_lod;
			info.m_pColorMeshes = pColorMeshes;

			bool bShadowDepth = (it.info.flags & STUDIO_SHADOWDEPTHTEXTURE) != 0;

			// Don't do decals if shadow depth mapping...
			info.m_Decals = bShadowDepth ? STUDIORENDER_DECAL_INVALID : it.state.m_decals;

			// Sets up flexes
			float* pFlexWeights = NULL;
			float* pFlexDelayedWeights = NULL;

			int overlayVal = g_Vars.r_drawmodelstatsoverlay->GetInt();
			int drawFlags = it.state.m_drawFlags;

			if (bShadowDepth) {
				drawFlags |= STUDIORENDER_DRAW_OPAQUE_ONLY;
				drawFlags |= STUDIORENDER_SHADOWDEPTHTEXTURE;
			}

			if (overlayVal && !bShadowDepth) {
				drawFlags |= STUDIORENDER_DRAW_GET_PERF_STATS;
			}

			Interfaces::m_pStudioRender->DrawModel(&results, &info, it.pBoneToWorld, pFlexWeights, pFlexDelayedWeights, it.info.origin, drawFlags);
			Interfaces::m_pStudioRender->m_pForcedMaterial = nullptr;
			Interfaces::m_pStudioRender->m_nForcedMaterialType = 0;
		};

		auto it = m_Hitmatrix.begin();
		while (it != m_Hitmatrix.end()) {
			if (!(&it->state) || !it->state.m_pModelToWorld || !it->state.m_pRenderable || !it->state.m_pStudioHdr || !it->state.m_pStudioHWData ||
				!it->info.pRenderable || !it->info.pModelToWorld || !it->info.pModel) {
				++it;
				continue;
			}

			auto alpha = 1.0f;
			auto delta = Interfaces::m_pGlobalVars->realtime - it->time;
			if (delta > 0.0f) {
				alpha -= delta;
				if (delta > 1.0f) {
					it = m_Hitmatrix.erase(it);
					continue;
				}
			}

			auto color = g_Vars.esp.hitmatrix_color;
			color.a *= alpha;

			OverrideMaterial(true, 4, color);

			DrawModelRebuild(*it);

			if (g_Vars.esp.chams_hitmatrix_outline) {
				OverrideMaterial(true, MATERIAL_GLOW, g_Vars.esp.chams_hitmatrix_outline_color, g_Vars.esp.chams_hitmatrix_outline_value);
				DrawModelRebuild(*it);
			}

			++it;
		}
	}

	void CChams::AddHitmatrix(C_CSPlayer* player, matrix3x4_t* bones) {
		if (!player || !bones)
			return;

		auto& hit = m_Hitmatrix.emplace_back();

		std::memcpy(hit.pBoneToWorld, bones, player->m_CachedBoneData().Count() * sizeof(matrix3x4_t));
		hit.time = Interfaces::m_pGlobalVars->realtime + g_Vars.esp.hitmatrix_time;

		static int m_nSkin = SDK::Memory::FindInDataMap(player->GetPredDescMap(), XorStr("m_nSkin"));
		static int m_nBody = SDK::Memory::FindInDataMap(player->GetPredDescMap(), XorStr("m_nBody"));

		hit.info.origin = player->GetAbsOrigin();
		hit.info.angles = player->GetAbsAngles();

		auto renderable = player->GetClientRenderable();

		if (!renderable)
			return;

		auto model = player->GetModel();

		if (!model)
			return;

		auto hdr = *(studiohdr_t**)(player->m_pStudioHdr());

		if (!hdr)
			return;

		hit.state.m_pStudioHdr = hdr;
		hit.state.m_pStudioHWData = Interfaces::m_pMDLCache->GetHardwareData(model->studio);
		hit.state.m_pRenderable = renderable;
		hit.state.m_drawFlags = 0;

		hit.info.pRenderable = renderable;
		hit.info.pModel = model;
		hit.info.pLightingOffset = nullptr;
		hit.info.pLightingOrigin = nullptr;
		hit.info.hitboxset = player->m_nHitboxSet();
		hit.info.skin = *(int*)(uintptr_t(player) + m_nSkin);
		hit.info.body = *(int*)(uintptr_t(player) + m_nBody);
		hit.info.entity_index = player->m_entIndex;
		hit.info.instance = Memory::VCall<ModelInstanceHandle_t(__thiscall*)(void*) >(renderable, 30u)(renderable);
		hit.info.flags = 0x1;

		hit.info.pModelToWorld = &hit.model_to_world;
		hit.state.m_pModelToWorld = &hit.model_to_world;

		hit.model_to_world.AngleMatrix(hit.info.angles, hit.info.origin);
	}

	void CChams::OverrideMaterial(bool ignoreZ, int type, const FloatColor& rgba, float glow_mod, bool wf, const FloatColor& pearlescence_clr, float pearlescence, float shine) {
		IMaterial* material = nullptr;

		switch (type) {
		case MATERIAL_OFF: break;
		case MATERIAL_FLAT:
			material = m_matFlat; break;
		case MATERIAL_REGULAR:
			material = m_matRegular; break;
		case MATERIAL_GLOW:
		case MATERIAL_OUTLINE:
			material = m_matGlow; break;
		case MATERIAL_SHINY:
			material = m_matShiny; break;
		}

		if (!material) {
			Interfaces::m_pStudioRender->m_pForcedMaterial = nullptr;
			Interfaces::m_pStudioRender->m_nForcedMaterialType = 0;
			return;
		}

		// apparently we have to do this, otherwise SetMaterialVarFlag can cause crashes (I crashed once here when loading a different cfg)
		material->IncrementReferenceCount();

		material->SetMaterialVarFlag(MATERIAL_VAR_IGNOREZ, ignoreZ);
		material->SetMaterialVarFlag(MATERIAL_VAR_WIREFRAME, wf);

		if (type == MATERIAL_GLOW) {
			auto tint = material->FindVar(XorStr("$envmaptint"), nullptr);
			if (tint)
				tint->SetVecValue(rgba.r,
					rgba.g,
					rgba.b);

			auto alpha = material->FindVar(XorStr("$alpha"), nullptr);
			if (alpha)
				alpha->SetFloatValue(rgba.a);

			auto envmap = material->FindVar(XorStr("$envmapfresnelminmaxexp"), nullptr);
			if (envmap)
				envmap->SetVecValue(0.f, 1.f, glow_mod);
		}
		else if (type == MATERIAL_OUTLINE) {
			auto tint = material->FindVar(XorStr("$envmaptint"), nullptr);
			if (tint)
				tint->SetVecValue(rgba.r,
					rgba.g,
					rgba.b);

			auto alpha = material->FindVar(XorStr("$alpha"), nullptr);
			if (alpha)
				alpha->SetFloatValue(rgba.a);

			auto envmap = material->FindVar(XorStr("$envmapfresnelminmaxexp"), nullptr);
			if (envmap)
				envmap->SetVecValue(0.f, 1.f, 8.0f);
		}
		else if (type == MATERIAL_SHINY) {
			material->AlphaModulate(rgba.a);
			material->ColorModulate(rgba.r, rgba.g, rgba.b);

			auto tint = material->FindVar(XorStr("$envmaptint"), nullptr);
			if (tint)
				tint->SetVecValue(pearlescence_clr.r * (pearlescence / 100.f),
					pearlescence_clr.g * (pearlescence / 100.f),
					pearlescence_clr.b * (pearlescence / 100.f));

			auto envmap = material->FindVar(XorStr("$phongboost"), nullptr);
			if (envmap)
				envmap->SetVecValue(shine / 100.f, shine / 100.f, shine / 100.f);
		}
		else {
			material->AlphaModulate(
				rgba.a);

			material->ColorModulate(
				rgba.r,
				rgba.g,
				rgba.b);
		}

		Interfaces::m_pStudioRender->m_pForcedMaterial = material;
		Interfaces::m_pStudioRender->m_nForcedMaterialType = 0;
	}

	void CChams::DrawModel(void* ECX, IMatRenderContext* MatRenderContext, DrawModelState_t& DrawModelState, ModelRenderInfo_t& RenderInfo, matrix3x4_t* pBoneToWorld) {
		if (!Interfaces::m_pStudioRender.IsValid())
			goto end;

		if (!CreateMaterials())
			goto end;

		//if( !g_Vars.esp.chams_enabled )
		//	goto end_func;

		C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
		if (!local || !Interfaces::m_pEngine->IsInGame())
			goto end;

		static float pulse_alpha = 0.f;
		static bool change_alpha = false;

		if (pulse_alpha <= 0.f)
			change_alpha = true;
		else if (pulse_alpha >= 255.f)
			change_alpha = false;

		pulse_alpha = change_alpha ? pulse_alpha + 0.05f : pulse_alpha - 0.05f;

		// STUDIO_SHADOWDEPTHTEXTURE(used for shadows)
		if (RenderInfo.flags & 0x40000000
			|| !RenderInfo.pRenderable
			|| !RenderInfo.pRenderable->GetIClientUnknown()) {
			goto end;
		}

		// already have forced material ( glow outline ) 
		if (g_Vars.globals.m_bInPostScreenEffects
			|| !pBoneToWorld
			|| !RenderInfo.pModel
			//|| RenderInfo.flags == 0x40100001 
			) {
			goto end;
		}

		auto entity = (C_CSPlayer*)(RenderInfo.pRenderable->GetIClientUnknown()->GetBaseEntity());
		if (!entity)
			goto end;

		auto client_class = entity->GetClientClass();
		if (!client_class)
			goto end;

		if (!client_class->m_ClassID)
			goto end;

		if (client_class->m_ClassID == ClassId_t::CBaseAnimating) {
			if (g_Vars.esp.remove_sleeves && strstr(DrawModelState.m_pStudioHdr->szName, XorStr("sleeve")) != nullptr)
				return;
		}

		auto InvalidateMaterial = [&]() -> void {
			Interfaces::m_pStudioRender->m_pForcedMaterial = nullptr;
			Interfaces::m_pStudioRender->m_nForcedMaterialType = 0;
		};

		if (g_Vars.esp.chams_attachments) {
			if (client_class->m_ClassID == ClassId_t::CBaseWeaponWorldModel || client_class->m_ClassID == ClassId_t::CBreakableProp) {
				if (!entity)
					goto end;

				// ???
				if (entity->m_nModelIndex() >= 67000000)
					goto end;

				if (client_class->m_ClassID == ClassId_t::CBreakableProp) {
					if (!entity->moveparent().IsValid())
						goto end;
				}

				if (client_class->m_ClassID == ClassId_t::CBaseWeaponWorldModel) {
					if (!entity->m_hCombatWeaponParent().IsValid())
						goto end;
				}

				C_BaseEntity* owner = nullptr;
				if (client_class->m_ClassID == ClassId_t::CBaseWeaponWorldModel)
					owner = (C_CSPlayer*)(((C_CSPlayer*)entity->m_hCombatWeaponParent().Get())->m_hOwnerEntity().Get());
				else
					owner = (C_CSPlayer*)entity->moveparent().Get();

				if (owner) {
					if (g_Vars.esp.chams_attachments) {
						if (owner->EntIndex() != local->EntIndex())
							goto end;
					}
				}

				int material = g_Vars.esp.attachments_chams_mat;

				OverrideMaterial(false, material, g_Vars.esp.attachments_chams_color, 0.f);
				Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);

				if (g_Vars.esp.chams_attachments_outline) {
					OverrideMaterial(true, MATERIAL_GLOW, g_Vars.esp.chams_attachments_outline_color, std::clamp<float>((100.0f - g_Vars.esp.chams_attachments_outline_value) * 0.2f, 1.f, 20.f), g_Vars.esp.chams_attachments_outline_wireframe);
					Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);
				}

				InvalidateMaterial();
				return;
			}
		}

		if (client_class->m_ClassID == ClassId_t::CPredictedViewModel) {
			if (!g_Vars.esp.chams_weapon)
				goto end;

			int material = g_Vars.esp.weapon_chams_mat;

			OverrideMaterial(false, material, g_Vars.esp.weapon_chams_color, 0.f);
			Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);

			if (g_Vars.esp.chams_weapon_outline) {
				OverrideMaterial(true, MATERIAL_GLOW, g_Vars.esp.chams_weapon_outline_color, std::clamp<float>((100.0f - g_Vars.esp.chams_weapon_outline_value) * 0.2f, 1.f, 20.f), g_Vars.esp.chams_weapon_outline_wireframe);
				Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);
			}

			InvalidateMaterial();
			return;
		}
		else if (client_class->m_ClassID == ClassId_t::CBaseAnimating) {
			if (!g_Vars.esp.chams_hands)
				goto end;

			int material = g_Vars.esp.hands_chams_mat;


			OverrideMaterial(false, material, g_Vars.esp.hands_chams_color, 0.f);
			Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);

			if (g_Vars.esp.chams_hands_outline) {
				OverrideMaterial(true, MATERIAL_GLOW, g_Vars.esp.chams_hands_outline_color, std::clamp<float>((100.0f - g_Vars.esp.chams_hands_outline_value) * 0.2f, 1.f, 20.f), g_Vars.esp.chams_hands_outline_wireframe);
				Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);
			}

			InvalidateMaterial();
			return;
		}
		else if (entity && entity->IsPlayer() && !entity->IsDormant() && !entity->IsDead() && entity->m_entIndex >= 1 && entity->m_entIndex <= Interfaces::m_pGlobalVars->maxClients || entity->GetClientClass()->m_ClassID == ClassId_t::CCSRagdoll) {
			bool is_local_player = false, is_enemy = false, is_teammate = false;
			if (entity->EntIndex() == local->EntIndex())
				is_local_player = true;
			else if (entity->m_iTeamNum() != local->m_iTeamNum())
				is_enemy = true;
			else
				is_teammate = true;

			if (entity == local) {
				if (g_Vars.esp.blur_in_scoped && Interfaces::m_pInput->CAM_IsThirdPerson()) {
					if (local && !local->IsDead() && local->m_bIsScoped()) {
						Interfaces::m_pRenderView->SetBlend(g_Vars.esp.blur_in_scoped_value / 100.f);
					}
				}
			}

			bool ragdoll = entity->GetClientClass()->m_ClassID == ClassId_t::CCSRagdoll;

			auto vis = is_teammate ? g_Vars.esp.team_chams_color_vis : g_Vars.esp.enemy_chams_color_vis;
			auto xqz = is_teammate ? g_Vars.esp.team_chams_color_xqz : g_Vars.esp.enemy_chams_color_xqz;
			bool should_xqz = is_teammate ? g_Vars.esp.team_chams_xqz : g_Vars.esp.enemy_chams_xqz;
			bool should_vis = is_teammate ? g_Vars.esp.team_chams_vis : g_Vars.esp.enemy_chams_vis;
			if (is_local_player) {
				//set local player ghost chams
				static auto g_GameRules = *(uintptr_t**)(Engine::Displacement.Data.m_GameRules);
				bool invalid = g_GameRules && *(bool*)(*(uintptr_t*)g_GameRules + 0x20) || (entity->m_fFlags() & (1 << 6));

				//set local player chams
				if (g_Vars.esp.chams_local) {
					OverrideMaterial(false, g_Vars.esp.chams_local_mat, g_Vars.esp.chams_local_color, 0.f, false,
						g_Vars.esp.chams_local_pearlescence_color, g_Vars.esp.chams_local_pearlescence, g_Vars.esp.chams_local_shine);

					Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);

					if (g_Vars.esp.chams_local_outline) {
						OverrideMaterial(false, MATERIAL_GLOW, g_Vars.esp.chams_local_outline_color,
							std::clamp<float>((100.0f - g_Vars.esp.chams_local_outline_value) * 0.2f, 1.f, 20.f), g_Vars.esp.chams_local_outline_wireframe);

						Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);
					}
				}
				else {
					OverrideMaterial(false, 0, vis);
					Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);
				}

				InvalidateMaterial();
				return;
			}
			else if (is_enemy) {
				auto data = Engine::LagCompensation::Get()->GetLagData(entity->m_entIndex);
				if (data.IsValid() && local) {
					if (g_Vars.esp.chams_history && entity->m_vecVelocity().Length() > 0.1 && !local->IsDead()) {
						// start from begin
						matrix3x4_t out[128];
						if (CChams::GetBacktrackMatrix(entity, out)) {
							OverrideMaterial(true, g_Vars.esp.chams_history_mat, g_Vars.esp.chams_history_color);
							Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, out);

							if (g_Vars.esp.chams_history_outline) {
								OverrideMaterial(true, MATERIAL_GLOW, g_Vars.esp.chams_history_outline_color, std::clamp<float>((100.0f - g_Vars.esp.chams_history_outline_value) * 0.2f, 1.f, 20.f));
								Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, out);
							}

							InvalidateMaterial();
						}
					}
				}
				//set enemy chams
				if (g_Vars.esp.chams_enemy) {
					if (!ragdoll) {
						int material = g_Vars.esp.enemy_chams_mat;

						if (should_xqz) {
							OverrideMaterial(true, material, xqz, 0.f, false,
								g_Vars.esp.chams_enemy_pearlescence_color, g_Vars.esp.chams_enemy_pearlescence, g_Vars.esp.chams_enemy_shine);
							Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);

							InvalidateMaterial();
						}

						if (should_vis) {
							OverrideMaterial(false, material, vis, 0.f, false,
								g_Vars.esp.chams_enemy_pearlescence_color, g_Vars.esp.chams_enemy_pearlescence, g_Vars.esp.chams_enemy_shine);
							Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);

							InvalidateMaterial();
						}

						if (g_Vars.esp.chams_enemy_outline) {
							OverrideMaterial(true, MATERIAL_GLOW, g_Vars.esp.chams_enemy_outline_color,
								std::clamp<float>((100.0f - g_Vars.esp.chams_enemy_outline_value) * 0.2f, 1.f, 20.f), g_Vars.esp.chams_enemy_outline_wireframe);

							Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);

							InvalidateMaterial();
						}
					}
				}
				else {
					if (!ragdoll) {
						InvalidateMaterial();
						Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);
					}
				}

				InvalidateMaterial();
				return;
			}
			else if (is_teammate) {

				if (g_Vars.esp.chams_teammate) {
					if (!ragdoll) {
						int material = g_Vars.esp.team_chams_mat;

						if (should_xqz) {
							OverrideMaterial(true, material, xqz, 0.f, false,
								g_Vars.esp.chams_team_pearlescence_color, g_Vars.esp.chams_team_pearlescence, g_Vars.esp.chams_team_shine);
							Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);

							InvalidateMaterial();
						}

						if (should_vis) {
							OverrideMaterial(false, material, vis, 0.f, false,
								g_Vars.esp.chams_team_pearlescence_color, g_Vars.esp.chams_team_pearlescence, g_Vars.esp.chams_team_shine);
							Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);

							InvalidateMaterial();
						}

						if (g_Vars.esp.chams_teammate_outline) {
							OverrideMaterial(true, MATERIAL_GLOW, g_Vars.esp.chams_teammate_outline_color,
								std::clamp<float>((100.0f - g_Vars.esp.chams_teammate_outline_value) * 0.2f, 1.f, 20.f), g_Vars.esp.chams_teammate_outline_wireframe);

							Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);

							InvalidateMaterial();
						}
					}
				}
				else {
					if (!ragdoll) {
						InvalidateMaterial();
						Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);
					}
				}

				InvalidateMaterial();
				return;
			}
		}
	end:
		local = C_CSPlayer::GetLocalPlayer();

		if (!Interfaces::m_pEngine->IsInGame() || !Interfaces::m_pEngine->IsConnected() || !local)
			return;
		else {
			Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);
			return;
		}

	end_func:
		Hooked::oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pBoneToWorld);
		return;

	}

	void CChams::OnDrawModel(void* ECX, IMatRenderContext* MatRenderContext, DrawModelState_t& DrawModelState, ModelRenderInfo_t& RenderInfo, matrix3x4_t* pBoneToWorld) {

	}

	bool CChams::GetBacktrackMatrix(C_CSPlayer* entity, matrix3x4_t* out) {
		if (!entity)
			return false;

		auto data = Engine::LagCompensation::Get()->GetLagData(entity->m_entIndex);
		if (data.IsValid()) {
			// start from begin
			for (auto it = data->m_History.begin(); it != data->m_History.end(); ++it) {
				if (it->player != entity)
					break;

				std::pair< Engine::C_LagRecord*, Engine::C_LagRecord* > last;
				if (Engine::LagCompensation::Get()->IsRecordOutOfBounds(*it, 0.2f, -1, false) && it + 1 != data->m_History.end() && !Engine::LagCompensation::Get()->IsRecordOutOfBounds(*(it + 1), 0.2f, -1, false))
					last = std::make_pair(&*(it + 1), &*it);

				if (!last.first || !last.second)
					continue;

				if (!Interfaces::m_pPrediction->GetUnpredictedGlobals())
					continue;

				const auto& FirstInvalid = last.first;
				const auto& LastInvalid = last.second;

				if (!LastInvalid || !FirstInvalid)
					continue;

				if (LastInvalid->m_flSimulationTime - FirstInvalid->m_flSimulationTime > 0.5f)
					continue;

				//		if( ( FirstInvalid->m_vecOrigin - entity->m_vecOrigin( ) ).Length( ) < 0.1f )
				//			return false;

				const auto NextOrigin = LastInvalid->m_vecOrigin;
				const auto curtime = Interfaces::m_pPrediction->GetUnpredictedGlobals()->curtime;

				auto flDelta = 1.f - (curtime - LastInvalid->m_flInterpolateTime) / (LastInvalid->m_flSimulationTime - FirstInvalid->m_flSimulationTime);
				if (flDelta < 0.f || flDelta > 1.f)
					LastInvalid->m_flInterpolateTime = curtime;

				flDelta = 1.f - (curtime - LastInvalid->m_flInterpolateTime) / (LastInvalid->m_flSimulationTime - FirstInvalid->m_flSimulationTime);

				const auto lerp = Math::Interpolate(NextOrigin, FirstInvalid->m_vecOrigin, std::clamp(flDelta, 0.f, 1.f));

				matrix3x4_t ret[128];
				memcpy(ret, FirstInvalid->m_BoneMatrix, sizeof(matrix3x4_t[128]));

				for (size_t i{ }; i < 128; ++i) {
					const auto matrix_delta = Math::MatrixGetOrigin(FirstInvalid->m_BoneMatrix[i]) - FirstInvalid->m_vecOrigin;
					Math::MatrixSetOrigin(matrix_delta + lerp, ret[i]);
				}

				memcpy(out, ret, sizeof(matrix3x4_t[128]));
				return true;
			}
		}
	}
}

#pragma optimize( "", on )
```

`CSGO SDK/Features/Visuals/CChams.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

namespace Interfaces
{

	class __declspec(novtable) IChams : public NonCopyable {
	public:
		static Encrypted_t<IChams> Get();
		virtual void OnDrawModel(void* ECX, IMatRenderContext* MatRenderContext, DrawModelState_t& DrawModelState, ModelRenderInfo_t& RenderInfo, matrix3x4_t* pCustomBoneToWorld) = 0;
		virtual void DrawModel(void* ECX, IMatRenderContext* MatRenderContext, DrawModelState_t& DrawModelState, ModelRenderInfo_t& RenderInfo, matrix3x4_t* pCustomBoneToWorld) = 0;
		virtual bool CreateMaterials() = 0;
		virtual void OnPostScreenEffects() = 0;
		virtual void AddHitmatrix(C_CSPlayer* player, matrix3x4_t* bones) = 0;
	protected:
		IChams() { };
		virtual ~IChams() { };
	};

}

```

`CSGO SDK/Features/Visuals/ESP.cpp`:

```cpp
#include "Esp.hpp"
#include "../../SDK/Classes/entity.hpp"
#include "../../SDK/Classes/player.hpp"
#include "../../SDK/CVariables.hpp"
#include "../../source.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "../../SDK/Valve/CBaseHandle.hpp"
#include "../../Renderer/Render.hpp"
#include "../Rage/Autowall.h"
#include "Hitmarker.hpp"
#include "../../SDK/Classes/PropManager.hpp"
#include "../Rage/LagCompensation.hpp"
#include "EventLogger.hpp"
#include "../../Utils/InputSys.hpp"
#include "../Rage/Ragebot.hpp"
#include <minwindef.h>
#include "../../Utils/Math.h"
#include "../../SDK/RayTracer.h"
#include "../../SDK/displacement.hpp"
#include "CChams.hpp"
#include "../Rage/TickbaseShift.hpp"
#include "ExtendedEsp.hpp"
#include <sstream>
#include <ctime>
#include <windows.h>

//#include "../Rage/AnimationSystem.hpp"

#include "../Miscellaneous/Movement.hpp"

#include <iomanip>

extern Vector AutoPeekPos;

struct BBox_t {
	int x, y, w, h;
};

class CEsp : public IEsp {
public:
	void PenetrateCrosshair(Vector2D center);
	void DrawAntiAimIndicator() override;
	void DrawZeusDistance();
	void Main() override;
	void SetAlpha(int idx) override;
	float GetAlpha(int idx) override;
	void AddSkeletonMatrix(C_CSPlayer* player, matrix3x4_t* bones) override;
private:
	struct IndicatorsInfo_t {
		IndicatorsInfo_t() {

		}

		IndicatorsInfo_t(const char* m_szName,
			int m_iPrioirity,
			bool m_bLoading,
			float m_flLoading,
			FloatColor m_Color) {
			this->m_szName = m_szName;
			this->m_iPrioirity = m_iPrioirity;
			this->m_bLoading = m_bLoading;
			this->m_flLoading = m_flLoading;
			this->m_Color = m_Color;
		}

		const char* m_szName = "";
		int m_iPrioirity = -1;
		bool m_bLoading = false;
		float m_flLoading = 0.f;
		FloatColor m_Color = FloatColor(0, 0, 0, 255);
	};

	std::vector< IndicatorsInfo_t > m_vecTextIndicators;

	struct EspData_t {
		C_CSPlayer* player;
		bool bEnemy;
		Vector2D head_pos;
		Vector2D feet_pos;
		Vector origin;
		BBox_t bbox;
		player_info_t info;
	};

	EspData_t m_Data;
	C_CSPlayer* m_LocalPlayer = nullptr;
	C_CSPlayer* m_LocalObserved = nullptr;

	int storedTick = 0;
	int crouchedTicks[65];
	float m_flAlpha[65];

	float lastTime = 0.0f;
	int oldframecount = 0;
	int curfps = 0;

	bool m_bAlphaFix[65];
	bool Begin(C_CSPlayer* player);
	bool ValidPlayer(C_CSPlayer* player);
	void AmmoBar(C_CSPlayer* player, BBox_t bbox);
	void RenderNades(C_WeaponCSBaseGun* nade);
	void DrawBox(BBox_t bbox, const FloatColor& clr, C_CSPlayer* player);
	void DrawHealthBar(C_CSPlayer* player, BBox_t bbox);
	void DrawInfo(C_CSPlayer* player, BBox_t bbox, player_info_t player_info);
	void DrawBottomInfo(C_CSPlayer* player, BBox_t bbox, player_info_t player_info);
	void DrawName(C_CSPlayer* player, BBox_t bbox, player_info_t player_info);
	void DrawSkeleton(C_CSPlayer* player);
	void DrawHitSkeleton();
	bool GetBBox(C_BaseEntity* player, Vector2D screen_points[], BBox_t& outRect);
	void Offscreen();
	void OverlayInfo();
	void Indicators();
	void BloomEffect();
	bool IsFakeDucking(C_CSPlayer* player) {
		if (!player)
			return false;

		float duckamount = player->m_flDuckAmount();
		if (!duckamount) {
			crouchedTicks[player->EntIndex()] = 0;
			return false;
		}

		float duckspeed = player->m_flDuckSpeed();
		if (!duckspeed) {
			crouchedTicks[player->EntIndex()] = 0;
			return false;
		}

		if (storedTick != Interfaces::m_pGlobalVars->tickcount) {
			crouchedTicks[player->EntIndex()]++;
			storedTick = Interfaces::m_pGlobalVars->tickcount;
		}

		if (int(duckspeed) == 8 && duckamount <= 0.9f && duckamount > 0.01
			&& (player->m_fFlags() & FL_ONGROUND) && (crouchedTicks[player->EntIndex()] >= 5))
			return true;
		else
			return false;
	};

	C_Window m_KeyBinds = { Vector2D(g_Vars.esp.keybind_window_x, g_Vars.esp.keybind_window_y), Vector2D(180, 10), 0 };
	C_Window m_SpecList = { Vector2D(g_Vars.esp.spec_window_x, g_Vars.esp.spec_window_y), Vector2D(180, 10), 1 };

	void SpectatorList(bool window = false);
	void Keybinds();

	struct C_HitMatrixEntry {
		float m_flTime = 0.0f;
		float m_flAlpha = 0.0f;

		C_CSPlayer* m_pEntity = nullptr;
		matrix3x4_t pBoneToWorld[128] = { };
	};

	std::vector<C_HitMatrixEntry> m_Hitmatrix;
};

void CEsp::AddSkeletonMatrix(C_CSPlayer* player, matrix3x4_t* bones) {
	if (!player || !bones)
		return;

	C_HitMatrixEntry info;

	info.m_flTime = Interfaces::m_pGlobalVars->realtime + g_Vars.esp.hitskeleton_time;
	info.m_flAlpha = 1.f;
	info.m_pEntity = player;
	std::memcpy(info.pBoneToWorld, bones, player->m_CachedBoneData().Count() * sizeof(matrix3x4_t));

	m_Hitmatrix.push_back(info);
}

void CEsp::BloomEffect() {
	static bool props = false;

	static ConVar* r_modelAmbientMin = Interfaces::m_pCvar->FindVar(XorStr("r_modelAmbientMin"));

	for (int i = 0; i < Interfaces::m_pEntList->GetHighestEntityIndex(); i++) {
		C_BaseEntity* pEntity = (C_BaseEntity*)Interfaces::m_pEntList->GetClientEntity(i);

		if (!pEntity)
			continue;

		if (pEntity->GetClientClass()->m_ClassID == 69) {
			auto pToneMap = (CEnvTonemapContorller*)pEntity;
			if (pToneMap) {
				*pToneMap->m_bUseCustomAutoExposureMin() = true;
				*pToneMap->m_bUseCustomAutoExposureMax() = true;

				*pToneMap->m_flCustomAutoExposureMin() = 0.2f;
				*pToneMap->m_flCustomAutoExposureMax() = 0.2f;
				*pToneMap->m_flCustomBloomScale() = 10.1f;

				r_modelAmbientMin->SetValue(g_Vars.esp.model_brightness);
			}
		}

		if (pEntity->GetClientClass()->m_ClassID == CPrecipitation) {
			auto pToneMap = pEntity;
			if (pToneMap) {

			}
		}
	}
}

void DrawWatermark() {

	if (!g_Vars.misc.watermark)
		return;

	bool connected = Interfaces::m_pEngine->IsInGame();
	std::string text;

	SYSTEMTIME lt;
	GetLocalTime(&lt);

	// ez convert to 12 hour format
	if (lt.wHour > 12)
		lt.wHour -= 12;
	if (lt.wHour == 0)
		lt.wHour = 12;

	std::string hour = std::to_string(lt.wHour);
	std::string wMin = std::to_string(lt.wMinute);
	std::string wSec = std::to_string(lt.wSecond);

	// add 0 padding to minutes and seconds
	size_t n_zeros = 2;
	auto min = std::string(n_zeros - std::min(n_zeros, wMin.length()), '0') + wMin;
	auto sec = std::string(n_zeros - std::min(n_zeros, wSec.length()), '0') + wSec;

	player_info_t info;
	Interfaces::m_pEngine->GetPlayerInfo(Interfaces::m_pEngine->GetLocalPlayer(), &info);

	if (connected) {
		auto netchannel = Encrypted_t<INetChannelInfo>(Interfaces::m_pEngine->GetNetChannelInfo());
		if (!netchannel.IsValid())
			return;
		int ms = (std::max(0, (int)std::round(netchannel->GetLatency(FLOW_OUTGOING) * 1000.f)) + std::max(0, (int)std::round(netchannel->GetLatency(FLOW_INCOMING) * 1000.f)));

		text = XorStr("Autism | ");
		text += info.szName;
		text += XorStr(" | ");
		text += XorStr(g_Vars.globals.server_adress);
		text += XorStr(" | ");
		text += std::to_string(ms);
		text += XorStr(" ms | ");
		text += hour; text += XorStr(":"); text += min; text += XorStr(":"); text += sec;
	}
	else {
		text = XorStr("Autism | ");
		text += hour; text += XorStr(":"); text += min; text += XorStr(":"); text += sec;
	}

	Render::Engine::FontSize_t size = Render::Engine::watermark.size(text);

	Vector2D screen = Render::GetScreenSize();

	// background.
	Render::Engine::RectFilled(screen.x - size.m_width - 20, 10, size.m_width + 10, size.m_height + 4, Color(0, 0, 0, 210));
	Render::Engine::RectFilled(screen.x - size.m_width - 20, 10, size.m_width + 10, size.m_height - 11, g_Vars.menu.ascent.ToRegularColor());

	// text.
	Render::Engine::watermark.string(screen.x - 15, 13, { 255, 255, 255, 220 }, text, Render::Engine::ALIGN_RIGHT);
}

bool CEsp::Begin(C_CSPlayer* player) {
	m_Data.player = player;
	m_LocalObserved = (C_CSPlayer*)m_LocalPlayer->m_hObserverTarget().Get();

	player_info_t player_info;
	if (!Interfaces::m_pEngine->GetPlayerInfo(player->EntIndex(), &player_info))
		return false;

	m_Data.info = player_info;

	Vector2D points[8];
	return GetBBox(player, points, m_Data.bbox);
}

bool CEsp::ValidPlayer(C_CSPlayer* player) {
	if (!player)
		return false;

	int idx = player->EntIndex();

	if (player->IsDead()) {
		m_flAlpha[idx] = 0.f;
		return false;
	}

	static auto g_GameRules = *(uintptr_t**)(Engine::Displacement.Data.m_GameRules);
	if (*(bool*)(*(uintptr_t*)g_GameRules + 0x20)) {
		if (player->IsDormant()) {
			m_flAlpha[idx] = 0.f;
		}
		return false;
	}
	if (player->IsDormant()) {
		if (m_flAlpha[idx] < 0.6f) {
			m_flAlpha[idx] -= (1.0f / 1.0f) * Interfaces::m_pGlobalVars->frametime;
			m_flAlpha[idx] = std::clamp(m_flAlpha[idx], 0.f, 0.6f);
		}
		else {
			m_flAlpha[idx] -= (1.0f / 20.f) * Interfaces::m_pGlobalVars->frametime;
		}
	}
	else {
		m_flAlpha[idx] += (1.0f / 0.2f) * Interfaces::m_pGlobalVars->frametime;
		m_flAlpha[idx] = std::clamp(m_flAlpha[idx], 0.f, 1.f);
	}

	return (m_flAlpha[idx] > 0.f);
}

int fps() {
	static float m_Framerate = 0.f;

	// Move rolling average
	m_Framerate = 0.9 * m_Framerate + (1.0 - 0.9) * Interfaces::m_pGlobalVars->absoluteframetime;

	if (m_Framerate <= 0.0f)
		m_Framerate = 1.0f;

	return (int)(1.0f / m_Framerate);
}

void CEsp::Indicators() {

	if (auto pLocal = C_CSPlayer::GetLocalPlayer(); pLocal) {

		struct Indicator_t { Color color; std::string text; };
		std::vector< Indicator_t > indicators{ };

		Color ff15c27b{ 124, 195, 13, 255 };
		Color ff0000ff{ 255,0,0,255 };

		if (g_Vars.antiaim.draw_angles)
		{
			const auto& pos = pLocal->GetAbsOrigin();
			Vector2D tmp;

			if (WorldToScreen(pos, tmp))
			{
				Vector2D draw_tmp;
				const Vector real_pos(45.f * std::cos(DEG2RAD(g_Vars.globals.FakeAngle.y)) + pos.x, 45.f * sin(DEG2RAD(g_Vars.globals.FakeAngle.y)) + pos.y, pos.z);

				if (WorldToScreen(real_pos, draw_tmp))
				{
					Render::Engine::Line(tmp.x, tmp.y, draw_tmp.x, draw_tmp.y, { 0, 255, 0, 255 });
					Render::Engine::esp.string(draw_tmp.x, draw_tmp.y, { 0, 255, 0, 255 }, "FAKE", Render::Engine::ALIGN_LEFT);
				}

				const Vector fake_pos(45.f * cos(DEG2RAD(g_Vars.globals.RegularAngles.y)) + pos.x, 45.f * sin(DEG2RAD(g_Vars.globals.RegularAngles.y)) + pos.y, pos.z);

				if (WorldToScreen(fake_pos, draw_tmp))
				{
					Render::Engine::Line(tmp.x, tmp.y, draw_tmp.x, draw_tmp.y, { 255, 0, 0, 255 });
					Render::Engine::esp.string(draw_tmp.x, draw_tmp.y, { 255, 0, 0, 255 }, "REAL", Render::Engine::ALIGN_LEFT);
				}

				float lby = pLocal->m_flLowerBodyYawTarget();
				const Vector lby_pos(45.f * cos(DEG2RAD(lby)) + pos.x, 45.f * sin(DEG2RAD(lby)) + pos.y, pos.z);
				if (WorldToScreen(lby_pos, draw_tmp))
				{
					Render::Engine::Line(tmp.x, tmp.y, draw_tmp.x, draw_tmp.y, { 255, 255, 255, 255 });
					Render::Engine::esp.string(draw_tmp.x, draw_tmp.y, { 255, 255, 255, 255 }, "LBY", Render::Engine::ALIGN_LEFT);
				}
			}
		}

		// LC
		if (!(pLocal->m_fFlags() & FL_ONGROUND) && g_Vars.esp.indicator_breaklc) {
			Indicator_t ind{ };
			ind.color = g_Vars.globals.bBrokeLC ? ff15c27b : ff0000ff;
			ind.text = ("LC");

			indicators.push_back(ind);
		}

		// get the absolute change between current lby and animated angle.
		float change = std::abs(Math::AngleNormalize(g_Vars.globals.m_flBody - g_Vars.globals.RegularAngles.y));

		if (g_Vars.esp.indicator_lby) {
			Indicator_t ind{ };
			ind.color = change > 35.f ? ff15c27b : ff0000ff;
			ind.text = ("LBY");
			indicators.push_back(ind);
		}

		if (g_Vars.rage.key_dmg_override.enabled && g_Vars.globals.OverridingMinDmg && g_Vars.esp.indicator_dmg) {
			Indicator_t ind{ };
			ind.color = Color(201, 201, 201, 255);
			ind.text = ("DMG");
			indicators.push_back(ind);
		}

		if (indicators.empty())
			return;

		// iterate and draw indicators.
		for (size_t i{ }; i < indicators.size(); ++i) {
			auto& indicator = indicators[i];

			Render::Engine::indi.string(12, Render::GetScreenSize().y - 64 - (30 * i), indicator.color, indicator.text);
		}

	}
}

void CEsp::SpectatorList(bool window) {

	std::vector< std::string > spectators{ "" };
	int h = Render::Engine::esp.m_size.m_height;
	C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer();

	for (int i{ 1 }; i <= Interfaces::m_pGlobalVars->maxClients; ++i) {
		C_CSPlayer* player = (C_CSPlayer*)Interfaces::m_pEntList->GetClientEntity(i);
		if (!player)
			continue;

		if (player == pLocal)
			continue;

		if (player->IsDormant())
			continue;

		if (player->m_iHealth() > 0)
			continue;

		if (player->m_hObserverTarget() != pLocal)
			continue;

		player_info_t info;
		if (!Interfaces::m_pEngine->GetPlayerInfo(i, &info))
			continue;

		auto specplayer = player->m_hObserverTarget() == pLocal;
		if (!specplayer)
			continue;

		spectators.push_back(std::string(info.szName).substr(0, 24));
	}

	size_t total_size = spectators.size() * (h - 1);

	for (size_t i{ }; i < spectators.size(); ++i) {
		const std::string& name = spectators[i];

		Render::Engine::esp.string(Render::GetScreenSize().x - 5, (i * 14) - 10, { 255, 255, 255, 179 }, name, Render::Engine::ALIGN_RIGHT);
	}
}

void CEsp::Keybinds() {
	std::vector<
		std::pair<std::string, int>
	> vecNames;

	this->m_KeyBinds.Drag();

	Vector2D pos = { g_Vars.esp.keybind_window_x, g_Vars.esp.keybind_window_y };

	this->m_KeyBinds.size.y = 20.0f;

	auto AddBind = [this, &vecNames](const char* name, KeyBind_t& bind) {
		if (!bind.enabled)
			return;

		if (!vecNames.empty())
			this->m_KeyBinds.size.y += 13.0f;

		vecNames.push_back(std::pair<std::string, int>(std::string(name), bind.cond));
	};

	if (g_Vars.rage.enabled) {
		AddBind(XorStr("Damage override"), g_Vars.rage.key_dmg_override);
		AddBind(XorStr("Hitbox override"), g_Vars.rage.hitbox_override_bind);
	}

	if (g_Vars.misc.edgejump) {
		AddBind(XorStr("Edge jump"), g_Vars.misc.edgejump_bind);
	}

	if (g_Vars.misc.autopeek) {
		AddBind(XorStr("Auto peek"), g_Vars.misc.autopeek_bind);
	}

	if (g_Vars.misc.slow_walk) {
		AddBind(XorStr("Fake walk"), g_Vars.misc.slow_walk_bind);
	}

	if (g_Vars.misc.move_exploit) {
		AddBind(XorStr("Exploit walk"), g_Vars.misc.move_exploit_key);
	}

	float gaySize = this->m_KeyBinds.size.y;

	static float alpha = 0.f;
	bool condition = ((vecNames.empty() && g_Vars.globals.menuOpen) || !vecNames.empty());
	float multiplier = static_cast<float>((1.0f / 0.05f) * Interfaces::m_pGlobalVars->frametime);
	if (condition) {
		alpha += multiplier * (1.0f - alpha);
	}
	else {
		if (alpha > 0.01f)
			alpha += multiplier * (0.0f - alpha);
		else
			alpha = 0.0f;
	}

	alpha = std::clamp(alpha, 0.f, 1.0f);

	if (alpha <= 0.f)
		return;

	Color main = Color(39, 41, 54, 150 * alpha);
	Color accent = g_Vars.menu.ascent.ToRegularColor();
	accent.RGBA[3] *= alpha;

	this->m_KeyBinds.size.y = 20.0f;

	// header
	Render::Engine::RectFilled(pos, this->m_KeyBinds.size, Color(39, 41, 54, 220 * alpha));

	// line splitting
	Render::Engine::Line(pos + Vector2D(0, this->m_KeyBinds.size.y), pos + this->m_KeyBinds.size, accent);
	Render::Engine::Line(pos + Vector2D(0, this->m_KeyBinds.size.y + 1), pos + Vector2D(this->m_KeyBinds.size.x, this->m_KeyBinds.size.y + 1), accent);

	this->m_KeyBinds.size.y = gaySize;

	// the actual window
	Render::Engine::RectFilled(pos + Vector2D(0, 20 + 2), Vector2D(this->m_KeyBinds.size.x, this->m_KeyBinds.size.y - 1), main);

	auto hold_size = Render::Engine::esp.size(XorStr("[holding]"));
	auto toggle_size = Render::Engine::esp.size(XorStr("[toggled]"));
	auto always_size = Render::Engine::esp.size(XorStr("[always]"));

	if (!vecNames.empty()) {
		float offset = 14.0f;
		for (auto name : vecNames) {
			// hotkey name
			Render::Engine::esp.string(pos.x + 5, pos.y + 9 + offset, Color::White().OverrideAlpha(255 * alpha), name.first.c_str(), Render::Engine::ALIGN_LEFT);

			// hotkey type
			Render::Engine::esp.string(pos.x + this->m_KeyBinds.size.x - 5, pos.y + 9 + offset, Color::White().OverrideAlpha(255 * alpha),
				name.second == KeyBindType::HOLD ? XorStr("[holding]") : name.second == KeyBindType::TOGGLE ? XorStr("[toggled]") : XorStr("[always]"), Render::Engine::ALIGN_RIGHT);

			// add offset
			offset += 14.0f;
		}
	}

	// title
	auto size = Render::Engine::esp.size(XorStr("Keybinds"));
	Render::Engine::esp.string(pos.x + (this->m_KeyBinds.size.x * 0.5) - 2, pos.y + (size.m_height * 0.5) - 4, Color::White().OverrideAlpha(255 * alpha), XorStr("Keybinds"), Render::Engine::ALIGN_CENTER);
}

// lol
bool IsAimingAtPlayerThroughPenetrableWall(C_CSPlayer* local, C_WeaponCSBaseGun* pWeapon) {
	auto weaponInfo = pWeapon->GetCSWeaponData();
	if (!weaponInfo.IsValid())
		return -1.0f;

	QAngle view_angles;
	Interfaces::m_pEngine->GetViewAngles(view_angles);

	Autowall::C_FireBulletData data;

	data.m_Player = local;
	data.m_TargetPlayer = nullptr;
	data.m_bPenetration = true;
	data.m_vecStart = local->GetEyePosition();
	data.m_vecDirection = view_angles.ToVectors();
	data.m_flMaxLength = data.m_vecDirection.Normalize();
	data.m_WeaponData = weaponInfo.Xor();
	data.m_flCurrentDamage = static_cast<float>(weaponInfo->m_iWeaponDamage);

	return Autowall::FireBullets(&data) >= 1.f;
}

float GetPenetrationDamage(C_CSPlayer* local, C_WeaponCSBaseGun* pWeapon) {
	auto weaponInfo = pWeapon->GetCSWeaponData();
	if (!weaponInfo.IsValid())
		return -1.0f;

	Autowall::C_FireBulletData data;

	data.m_iPenetrationCount = 4;
	data.m_Player = local;
	data.m_TargetPlayer = nullptr;

	QAngle view_angles;
	Interfaces::m_pEngine->GetViewAngles(view_angles);
	data.m_vecStart = local->GetEyePosition();
	data.m_vecDirection = view_angles.ToVectors();
	data.m_flMaxLength = data.m_vecDirection.Normalize();
	data.m_WeaponData = weaponInfo.Xor();
	data.m_flTraceLength = 0.0f;

	data.m_flCurrentDamage = static_cast<float>(weaponInfo->m_iWeaponDamage);

	CTraceFilter filter;
	filter.pSkip = local;

	Vector end = data.m_vecStart + data.m_vecDirection * weaponInfo->m_flWeaponRange;

	Autowall::TraceLine(data.m_vecStart, end, MASK_SHOT_HULL | CONTENTS_HITBOX, &filter, &data.m_EnterTrace);
	Autowall::ClipTraceToPlayers(data.m_vecStart, end + data.m_vecDirection * 40.0f, MASK_SHOT_HULL | CONTENTS_HITBOX, &filter, &data.m_EnterTrace);
	if (data.m_EnterTrace.fraction == 1.f)
		return -1.0f;

	data.m_flTraceLength += data.m_flMaxLength * data.m_EnterTrace.fraction;
	if (data.m_flMaxLength != 0.0f && data.m_flTraceLength >= data.m_flMaxLength)
		return data.m_flCurrentDamage;

	data.m_flCurrentDamage *= powf(weaponInfo->m_flRangeModifier, data.m_flTraceLength * 0.002f);
	data.m_EnterSurfaceData = Interfaces::m_pPhysSurface->GetSurfaceData(data.m_EnterTrace.surface.surfaceProps);

	C_BasePlayer* hit_player = static_cast<C_BasePlayer*>(data.m_EnterTrace.hit_entity);
	bool can_do_damage = (data.m_EnterTrace.hitgroup >= Hitgroup_Head && data.m_EnterTrace.hitgroup <= Hitgroup_Gear);
	bool hit_target = !data.m_TargetPlayer || hit_player == data.m_TargetPlayer;
	if (can_do_damage && hit_player && hit_player->EntIndex() <= Interfaces::m_pGlobalVars->maxClients && hit_player->EntIndex() > 0 && hit_target) {
		if (pWeapon && pWeapon->m_iItemDefinitionIndex() == WEAPON_ZEUS)
			return (data.m_flCurrentDamage * 0.9f);

		if (pWeapon->m_iItemDefinitionIndex() == WEAPON_ZEUS) {
			data.m_EnterTrace.hitgroup = Hitgroup_Generic;
		}

		data.m_flCurrentDamage = Autowall::ScaleDamage((C_CSPlayer*)hit_player, data.m_flCurrentDamage, weaponInfo->m_flArmorRatio, data.m_EnterTrace.hitgroup);
		return data.m_flCurrentDamage;
	};

	if (data.m_flTraceLength > 3000.0f && weaponInfo->m_flPenetration > 0.f || 0.1f > data.m_EnterSurfaceData->game.flPenetrationModifier)
		return -1.0f;

	if (Autowall::HandleBulletPenetration(&data))
		return -1.0f;

	return data.m_flCurrentDamage;
};

void CEsp::PenetrateCrosshair(Vector2D center) {
	C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
	if (!local || local->IsDead())
		return;

	C_WeaponCSBaseGun* pWeapon = (C_WeaponCSBaseGun*)local->m_hActiveWeapon().Get();
	if (!pWeapon)
		return;

	if (!pWeapon->GetCSWeaponData().IsValid())
		return;

	auto type = pWeapon->GetCSWeaponData().Xor()->m_iWeaponType;

	if (type == WEAPONTYPE_KNIFE || type == WEAPONTYPE_C4 || type == WEAPONTYPE_GRENADE)
		return;

	// fps enhancer
	g_Vars.globals.m_nPenetrationDmg = (int)GetPenetrationDamage(local, pWeapon);
	g_Vars.globals.m_bAimAtEnemyThruWallOrVisibleLoool = IsAimingAtPlayerThroughPenetrableWall(local, pWeapon);
	Color color = g_Vars.globals.m_bAimAtEnemyThruWallOrVisibleLoool ? (Color(0, 30, 225, 210)) : (g_Vars.globals.m_nPenetrationDmg >= 1 ? Color(0, 255, 0, 210) : Color(255, 0, 0, 210));

	if (g_Vars.esp.autowall_crosshair) {
		Render::Engine::RectFilled(center - 1, { 3, 3 }, Color(0, 0, 0, 125));
		Render::Engine::RectFilled(Vector2D(center.x, center.y - 1), Vector2D(1, 3), color);
		Render::Engine::RectFilled(Vector2D(center.x - 1, center.y), Vector2D(3, 1), color);
	}
}

void CEsp::DrawAntiAimIndicator() {
	if (!g_Vars.antiaim.manual || !Interfaces::m_pEngine->IsInGame())
		return;

	C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
	if (!local || local->IsDead())
		return;

	//if( g_Vars.globals.manual_aa == -1 )
	//	return;

	bool bLeft = false, bRight = false, bBack = false;
	switch (g_Vars.globals.manual_aa) {
	case 0:
		bLeft = true;
		bRight = false;
		bBack = false;
		break;
	case 1:
		bLeft = false;
		bRight = false;
		bBack = true;
		break;
	case 2:
		bLeft = false;
		bRight = true;
		bBack = false;
		break;
	}

	Color color = g_Vars.antiaim.manual_color.ToRegularColor();

	float alpha = floor(sin(Interfaces::m_pGlobalVars->realtime * 4) * (color.RGBA[3] / 2 - 1) + color.RGBA[3] / 2);

	color.RGBA[3] = alpha;

	// Polygon points aka arrows
	auto ScreenSize = Render::GetScreenSize();
	int x = ScreenSize.x / 2;
	int y = ScreenSize.y / 2;

	if (bLeft) {
		Render::Engine::RectFilled(x - 50, y - 10, 1, 21, color);
		Render::Engine::RectFilled(x - 51, y - 10 + 1, 1, 19, color);
		Render::Engine::RectFilled(x - 52, y - 10 + 2, 1, 17, color);
		Render::Engine::RectFilled(x - 53, y - 10 + 3, 1, 15, color);
		Render::Engine::RectFilled(x - 54, y - 10 + 4, 1, 13, color);
		Render::Engine::RectFilled(x - 55, y - 10 + 5, 1, 11, color);
		Render::Engine::RectFilled(x - 56, y - 10 + 6, 1, 9, color);
		Render::Engine::RectFilled(x - 57, y - 10 + 7, 1, 7, color);
		Render::Engine::RectFilled(x - 58, y - 10 + 8, 1, 5, color);
		Render::Engine::RectFilled(x - 59, y - 10 + 9, 1, 3, color);
		Render::Engine::RectFilled(x - 60, y - 10 + 10, 1, 1, color);
	}
	else {
		Render::Engine::RectFilled(x - 50, y - 10, 1, 21, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 51, y - 10 + 1, 1, 19, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 52, y - 10 + 2, 1, 17, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 53, y - 10 + 3, 1, 15, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 54, y - 10 + 4, 1, 13, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 55, y - 10 + 5, 1, 11, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 56, y - 10 + 6, 1, 9, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 57, y - 10 + 7, 1, 7, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 58, y - 10 + 8, 1, 5, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 59, y - 10 + 9, 1, 3, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 60, y - 10 + 10, 1, 1, { 0, 0, 0, 125 });
	}

	if (bRight) {
		Render::Engine::RectFilled(x + 50, y - 10, 1, 21, color);
		Render::Engine::RectFilled(x + 51, y - 10 + 1, 1, 19, color);
		Render::Engine::RectFilled(x + 52, y - 10 + 2, 1, 17, color);
		Render::Engine::RectFilled(x + 53, y - 10 + 3, 1, 15, color);
		Render::Engine::RectFilled(x + 54, y - 10 + 4, 1, 13, color);
		Render::Engine::RectFilled(x + 55, y - 10 + 5, 1, 11, color);
		Render::Engine::RectFilled(x + 56, y - 10 + 6, 1, 9, color);
		Render::Engine::RectFilled(x + 57, y - 10 + 7, 1, 7, color);
		Render::Engine::RectFilled(x + 58, y - 10 + 8, 1, 5, color);
		Render::Engine::RectFilled(x + 59, y - 10 + 9, 1, 3, color);
		Render::Engine::RectFilled(x + 60, y - 10 + 10, 1, 1, color);
	}
	else {
		Render::Engine::RectFilled(x + 50, y - 10, 1, 21, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x + 51, y - 10 + 1, 1, 19, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x + 52, y - 10 + 2, 1, 17, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x + 53, y - 10 + 3, 1, 15, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x + 54, y - 10 + 4, 1, 13, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x + 55, y - 10 + 5, 1, 11, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x + 56, y - 10 + 6, 1, 9, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x + 57, y - 10 + 7, 1, 7, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x + 58, y - 10 + 8, 1, 5, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x + 59, y - 10 + 9, 1, 3, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x + 60, y - 10 + 10, 1, 1, { 0, 0, 0, 125 });
	}
	if (bBack) {
		Render::Engine::RectFilled(x - 10, y + 50, 21, 1, color);
		Render::Engine::RectFilled(x - 10 + 1, y + 51, 19, 1, color);
		Render::Engine::RectFilled(x - 10 + 2, y + 52, 17, 1, color);
		Render::Engine::RectFilled(x - 10 + 3, y + 53, 15, 1, color);
		Render::Engine::RectFilled(x - 10 + 4, y + 54, 13, 1, color);
		Render::Engine::RectFilled(x - 10 + 5, y + 55, 11, 1, color);
		Render::Engine::RectFilled(x - 10 + 6, y + 56, 9, 1, color);
		Render::Engine::RectFilled(x - 10 + 7, y + 57, 7, 1, color);
		Render::Engine::RectFilled(x - 10 + 8, y + 58, 5, 1, color);
		Render::Engine::RectFilled(x - 10 + 9, y + 59, 3, 1, color);
		Render::Engine::RectFilled(x - 10 + 10, y + 60, 1, 1, color);
	}
	else {
		Render::Engine::RectFilled(x - 10, y + 50, 21, 1, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 10 + 1, y + 51, 19, 1, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 10 + 2, y + 52, 17, 1, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 10 + 3, y + 53, 15, 1, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 10 + 4, y + 54, 13, 1, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 10 + 5, y + 55, 11, 1, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 10 + 6, y + 56, 9, 1, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 10 + 7, y + 57, 7, 1, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 10 + 8, y + 58, 5, 1, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 10 + 9, y + 59, 3, 1, { 0, 0, 0, 125 });
		Render::Engine::RectFilled(x - 10 + 10, y + 60, 1, 1, { 0, 0, 0, 125 });
	}
}

void CEsp::DrawZeusDistance() {
	if (!g_Vars.esp.zeus_distance)
		return;

	C_CSPlayer* pLocalPlayer = C_CSPlayer::GetLocalPlayer();

	if (!pLocalPlayer || pLocalPlayer->IsDead())
		return;

	C_WeaponCSBaseGun* pWeapon = (C_WeaponCSBaseGun*)pLocalPlayer->m_hActiveWeapon().Get();

	if (!pWeapon)
		return;

	auto pWeaponInfo = pWeapon->GetCSWeaponData();
	if (!pWeaponInfo.IsValid())
		return;

	if (!(pWeapon->m_iItemDefinitionIndex() == WEAPON_ZEUS))
		return;

	auto collision = pLocalPlayer->m_Collision();
	Vector eyePos = pLocalPlayer->GetAbsOrigin() + (collision->m_vecMins + collision->m_vecMaxs) * 0.5f;

	float flBestDistance = FLT_MAX;
	C_CSPlayer* pBestPlayer = nullptr;

	for (int i = 1; i <= Interfaces::m_pGlobalVars->maxClients; i++) {

		C_CSPlayer* player = (C_CSPlayer*)(Interfaces::m_pEntList->GetClientEntity(i));

		if (!player || player->IsDead() || player->IsDormant())
			continue;

		float Dist = pLocalPlayer->m_vecOrigin().Distance(player->m_vecOrigin());

		if (Dist < flBestDistance) {
			flBestDistance = Dist;
			pBestPlayer = player;
		}
	}

	auto GetZeusRange = [&](C_CSPlayer* player) -> float {
		const float RangeModifier = 0.00490000006f, MaxDamage = 500.f;
		return (log(player->m_iHealth() / MaxDamage) / log(RangeModifier)) / 0.002f;
	};

	float flRange = 0.f;
	if (pBestPlayer) {
		flRange = GetZeusRange(pBestPlayer);
	}

	const int accuracy = 360;
	const float step = DirectX::XM_2PI / accuracy;
	for (float a = 0.0f; a < DirectX::XM_2PI; a += step) {
		float a_c, a_s, as_c, as_s;
		DirectX::XMScalarSinCos(&a_s, &a_c, a);
		DirectX::XMScalarSinCos(&as_s, &as_c, a + step);

		Vector startPos = Vector(a_c * flRange + eyePos.x, a_s * flRange + eyePos.y, eyePos.z);
		Vector endPos = Vector(as_c * flRange + eyePos.x, as_s * flRange + eyePos.y, eyePos.z);

		Ray_t ray;
		CGameTrace tr;
		CTraceFilter filter = CTraceFilter();
		filter.pSkip = pLocalPlayer;

		ray.Init(eyePos, startPos);
		Interfaces::m_pEngineTrace->TraceRay(ray, MASK_SOLID, &filter, &tr);

		auto frac_1 = tr.fraction;
		Vector2D start2d;
		if (!WorldToScreen(tr.endpos, start2d))
			continue;

		ray.Init(eyePos, endPos);
		Interfaces::m_pEngineTrace->TraceRay(ray, MASK_SOLID, &filter, &tr);

		Vector2D end2d;

		if (!WorldToScreen(tr.endpos, end2d))
			continue;

		Render::Engine::Line(start2d, end2d, g_Vars.esp.zeus_distance_color.ToRegularColor());
	}
}

void CEsp::Main() {
	DrawWatermark();

	if (g_Vars.esp.keybind_window_enabled)
		Keybinds();

	if (g_Vars.esp.spec_window_enabled)
		SpectatorList(true);

	m_LocalPlayer = C_CSPlayer::GetLocalPlayer();
	if (!g_Vars.globals.HackIsReady || !m_LocalPlayer || !Interfaces::m_pEngine->IsInGame())
		return;

	if (g_Vars.esp.remove_scope && g_Vars.esp.remove_scope_type == 0 && (m_LocalPlayer && m_LocalPlayer->m_hActiveWeapon().Get() && ((C_WeaponCSBaseGun*)m_LocalPlayer->m_hActiveWeapon().Get())->GetCSWeaponData().IsValid() && ((C_WeaponCSBaseGun*)m_LocalPlayer->m_hActiveWeapon().Get())->GetCSWeaponData()->m_iWeaponType == WEAPONTYPE_SNIPER_RIFLE && m_LocalPlayer->m_bIsScoped())) {
		Interfaces::m_pSurface->DrawSetColor(Color(0, 0, 0, 255));
		Vector2D center = Render::GetScreenSize();
		Interfaces::m_pSurface->DrawLine(center.x / 2, 0, center.x / 2, center.y);
		Interfaces::m_pSurface->DrawLine(0, center.y / 2, center.x, center.y / 2);

	}

	if (!m_LocalPlayer->IsDead())
		Indicators();

	// draw the damage at the latest pos we hit an enemy at
	if (g_Vars.esp.visualize_damage && Hitmarkers::m_vecWorldHitmarkers.size()) {
		Hitmarkers::Hitmarkers_t& info = Hitmarkers::m_vecWorldHitmarkers.back();
		Vector2D vecPos;
		if (WorldToScreen(Vector(info.m_flPosX, info.m_flPosY, info.m_flPosZ), vecPos)) {
			auto vecTextSize = Render::Engine::esp.size(std::to_string(Hitmarkers::m_nLastDamageData.second));

			Vector2D vecRenderPos = vecPos - Vector2D(vecTextSize.m_width / 2, 8 + vecTextSize.m_height);
			Render::Engine::esp.string(vecRenderPos.x, vecRenderPos.y, Hitmarkers::m_nLastDamageData.first.OverrideAlpha(220 * info.m_flAlpha),
				std::to_string(Hitmarkers::m_nLastDamageData.second));
		}
	}

	if (!g_Vars.esp.esp_enable)
		return;

	OverlayInfo();

	static float auto_peek_radius = 0.f;
	bool condition = g_Vars.misc.autopeek && g_Vars.misc.autopeek_visualise && !AutoPeekPos.IsZero() && g_Vars.misc.autopeek_bind.enabled;
	float multiplier = static_cast<float>((1.0f / 0.05f) * Interfaces::m_pGlobalVars->frametime);
	if (condition) {
		auto_peek_radius += multiplier * (1.0f - auto_peek_radius);
	}
	else {
		// makes the animation end faster
		// if we dont do dis ther is like a 1.f radius circle for like 1 second
		if (auto_peek_radius > 0.01f)
			auto_peek_radius += multiplier * (0.0f - auto_peek_radius);
		else
			auto_peek_radius = 0.0f;
	}

	auto_peek_radius = std::clamp(auto_peek_radius, 0.f, 1.0f);

	// fixes the fadeout disappearing rlly fast
	static Vector last_autopeek_pos = AutoPeekPos;
	if (!AutoPeekPos.IsZero()) {
		last_autopeek_pos = AutoPeekPos;
	}

	if (auto_peek_radius > 0.f) {
		//* 0.4f
		Render::Engine::WorldCircle(AutoPeekPos.IsZero() ? last_autopeek_pos : AutoPeekPos, 15.f * auto_peek_radius,
			g_Vars.misc.autopeek_color.ToRegularColor(), g_Vars.misc.autopeek_color.ToRegularColor().OverrideAlpha(g_Vars.misc.autopeek_color.ToRegularColor().a() * 0.4f, true));
	}

	if (!g_Vars.globals.vecExploitOrigin.IsZero() && g_Vars.globals.bMoveExploiting) {
		g_Vars.globals.vecExploitOrigin.z = m_LocalPlayer->GetAbsOrigin().z;
		Render::Engine::WorldCircle(g_Vars.globals.vecExploitOrigin, 5.f, Color(0, 255, 0, 100), Color(0, 255, 0, 50));

		Vector2D origin;
		Vector2D origin2;
		if (WorldToScreen(m_LocalPlayer->GetAbsOrigin(), origin)) {
			if (WorldToScreen(g_Vars.globals.vecExploitOrigin, origin2)) {
				Render::Engine::Line(origin, origin2, Color(255, 255, 255, 255));
			}
		}
	}

	DrawZeusDistance();

	Vector2D points[8];
	Vector2D center;


	//if( g_Vars.esp.hitskeleton )
	//	DrawHitSkeleton( );

	for (int i = 0; i <= Interfaces::m_pEntList->GetHighestEntityIndex(); ++i) {
		auto entity = (C_BaseEntity*)Interfaces::m_pEntList->GetClientEntity(i);

		if (!entity)
			continue;

		if (!entity->GetClientClass() /*|| !entity->GetClientClass( )->m_ClassID*/)
			continue;

		if (g_Vars.esp.nades) {
			if (entity->GetClientClass()->m_ClassID == CInferno) {
				C_Inferno* pInferno = reinterpret_cast<C_Inferno*>(entity);
				C_CSPlayer* player = (C_CSPlayer*)entity->m_hOwnerEntity().Get();

				if (player) {
					FloatColor color = FloatColor(1.f, 0.f, 0.f, 0.8f);

					if (player->m_iTeamNum() == m_LocalPlayer->m_iTeamNum() && player->EntIndex() != m_LocalPlayer->EntIndex()) {
						if (g_Vars.mp_friendlyfire && g_Vars.mp_friendlyfire->GetInt() == 0) {
							color = FloatColor(0, 0, 0, 0);
						}
					}

					const Vector origin = pInferno->GetAbsOrigin();
					Vector2D screen_origin = Vector2D();

					if (WorldToScreen(origin, screen_origin)) {
						struct s {
							Vector2D a, b, c;
						};
						std::vector<int> excluded_ents;
						std::vector<s> valid_molotovs;

						const auto spawn_time = pInferno->m_flSpawnTime();
						const auto time = ((spawn_time + C_Inferno::GetExpiryTime()) - Interfaces::m_pGlobalVars->curtime);

						if (time > 0.05f) {
							static const auto size = Vector2D(70.f, 4.f);

							auto new_pos = Vector2D(screen_origin.x - size.x * 0.5, screen_origin.y - size.y * 0.5);

							Vector min, max;
							entity->GetClientRenderable()->GetRenderBounds(min, max);

							auto radius = (max - min).Length2D() * 0.5f;
							Vector boundOrigin = Vector((min.x + max.x) * 0.5f, (min.y + max.y) * 0.5f, min.z + 5) + origin;
							const int accuracy = 25;
							const float step = DirectX::XM_2PI / accuracy;
							for (float a = 0.0f; a < DirectX::XM_2PI; a += step) {
								float a_c, a_s, as_c, as_s;
								DirectX::XMScalarSinCos(&a_s, &a_c, a);
								DirectX::XMScalarSinCos(&as_s, &as_c, a + step);

								Vector startPos = Vector(a_c * radius + boundOrigin.x, a_s * radius + boundOrigin.y, boundOrigin.z);
								Vector endPos = Vector(as_c * radius + boundOrigin.x, as_s * radius + boundOrigin.y, boundOrigin.z);

								Vector2D start2d, end2d, boundorigin2d;
								if (!WorldToScreen(startPos, start2d) || !WorldToScreen(endPos, end2d) || !WorldToScreen(boundOrigin, boundorigin2d)) {
									excluded_ents.push_back(i);
									continue;
								}

								s n;
								n.a = start2d;
								n.b = end2d;
								n.c = boundorigin2d;
								valid_molotovs.push_back(n);
							}

							if (!excluded_ents.empty()) {
								for (int v = 0; v < excluded_ents.size(); ++v) {
									auto bbrr = excluded_ents[v];
									if (bbrr == i)
										continue;

									if (!valid_molotovs.empty())
										for (int m = 0; m < valid_molotovs.size(); ++m) {
											auto ba = valid_molotovs[m];
											Render::Engine::FilledTriangle(ba.c, ba.a, ba.b, color.ToRegularColor().OverrideAlpha(45));
											Render::Engine::Line(ba.a, ba.b, color.ToRegularColor().OverrideAlpha(220));
										}
								}
							}
							else {
								if (!valid_molotovs.empty())
									for (int m = 0; m < valid_molotovs.size(); ++m) {
										auto ba = valid_molotovs[m];
										Render::Engine::FilledTriangle(ba.c, ba.a, ba.b, color.ToRegularColor().OverrideAlpha(45));
										Render::Engine::Line(ba.a, ba.b, color.ToRegularColor().OverrideAlpha(220));
									}
							}

							char buf[128] = { };
							sprintf(buf, XorStr("FIRE : %.2fs"), time);
							Render::Engine::RectFilled(Vector2D(new_pos.x - 2, new_pos.y - 15),
								Vector2D(Render::Engine::segoe.size(buf).m_width + 4, Render::Engine::segoe.size(buf).m_height), Color(0, 0, 0, 200));

							Render::Engine::segoe.string(new_pos.x + (Render::Engine::segoe.size(buf).m_width * 0.5f), new_pos.y - 15, Color(255, 0, 0, 220), buf, Render::Engine::ALIGN_CENTER);
						}
						else {
							if (!valid_molotovs.empty())
								valid_molotovs.erase(valid_molotovs.begin() + i);

							if (!excluded_ents.empty())
								excluded_ents.erase(excluded_ents.begin() + i);
						}
					}
				}
			}

			C_SmokeGrenadeProjectile* pSmokeEffect = reinterpret_cast<C_SmokeGrenadeProjectile*>(entity);
			if (pSmokeEffect->GetClientClass()->m_ClassID == CSmokeGrenadeProjectile) {
				const Vector origin = pSmokeEffect->GetAbsOrigin();
				Vector2D screen_origin = Vector2D();

				if (WorldToScreen(origin, screen_origin)) {
					struct s {
						Vector2D a, b;
					};
					std::vector<int> excluded_ents;
					std::vector<s> valid_smokes;
					const auto spawn_time = TICKS_TO_TIME(pSmokeEffect->m_nSmokeEffectTickBegin());
					const auto time = (spawn_time + C_SmokeGrenadeProjectile::GetExpiryTime()) - Interfaces::m_pGlobalVars->curtime;

					static const auto size = Vector2D(70.f, 4.f);

					auto new_pos = Vector2D(screen_origin.x - size.x * 0.5, screen_origin.y - size.y * 0.5);
					if (time > 0.05f) {
						auto radius = 120.f;

						const int accuracy = 25;
						const float step = DirectX::XM_2PI / accuracy;
						for (float a = 0.0f; a < DirectX::XM_2PI; a += step) {
							float a_c, a_s, as_c, as_s;
							DirectX::XMScalarSinCos(&a_s, &a_c, a);
							DirectX::XMScalarSinCos(&as_s, &as_c, a + step);

							Vector startPos = Vector(a_c * radius + origin.x, a_s * radius + origin.y, origin.z + 5);
							Vector endPos = Vector(as_c * radius + origin.x, as_s * radius + origin.y, origin.z + 5);

							Vector2D start2d, end2d;
							if (!WorldToScreen(startPos, start2d) || !WorldToScreen(endPos, end2d)) {
								excluded_ents.push_back(i);
								continue;
							}

							s n;
							n.a = start2d;
							n.b = end2d;
							valid_smokes.push_back(n);
						}

						if (!excluded_ents.empty()) {
							for (int v = 0; v < excluded_ents.size(); ++v) {
								auto bbrr = excluded_ents[v];
								if (bbrr == i)
									continue;

								if (!valid_smokes.empty())
									for (int m = 0; m < valid_smokes.size(); ++m) {
										auto ba = valid_smokes[m];
										Render::Engine::FilledTriangle(screen_origin, ba.a, ba.b, Color(220, 220, 220, 25));
										Render::Engine::Line(ba.a, ba.b, Color(220, 220, 220, 220));
									}
							}
						}
						else {
							if (!valid_smokes.empty())
								for (int m = 0; m < valid_smokes.size(); ++m) {
									auto ba = valid_smokes[m];
									Render::Engine::FilledTriangle(screen_origin, ba.a, ba.b, Color(220, 220, 220, 25));
									Render::Engine::Line(ba.a, ba.b, Color(220, 220, 220, 220));
								}
						}

						char buf[128] = { };
						sprintf(buf, XorStr("SMOKE : %.2fs"), time);
						Render::Engine::RectFilled(Vector2D(new_pos.x - 2, new_pos.y - 15),
							Vector2D(Render::Engine::segoe.size(buf).m_width + 4, Render::Engine::segoe.size(buf).m_height), Color(0, 0, 0, 200));

						Render::Engine::segoe.string(new_pos.x + (Render::Engine::segoe.size(buf).m_width * 0.5f), new_pos.y - 15, Color(0, 230, 255, 180), buf, Render::Engine::ALIGN_CENTER);
					}
					else {
						if (!valid_smokes.empty())
							valid_smokes.erase(valid_smokes.begin() + i);

						if (!excluded_ents.empty())
							excluded_ents.erase(excluded_ents.begin() + i);
					}
				}
			}
		}

		auto player = ToCSPlayer(entity);

		if (ValidPlayer(player) && i <= 64) {
			g_Vars.globals.m_vecTextInfo[i].clear();

			if (Begin(player)) {
				auto local = C_CSPlayer::GetLocalPlayer();
				bool enemy = player->m_iTeamNum() != local->m_iTeamNum();
				bool team = player->m_iTeamNum() == local->m_iTeamNum() && player != local;
				
				if (enemy && g_Vars.esp.skeleton || team && g_Vars.esp.skeleton_team)
					DrawSkeleton(player);

				if (enemy && g_Vars.esp.box)
					DrawBox(m_Data.bbox, g_Vars.esp.box_color, player);

				if (enemy && g_Vars.esp.health || team && g_Vars.esp.health_team)
					DrawHealthBar(player, m_Data.bbox);

				if (enemy)
					DrawInfo(player, m_Data.bbox, m_Data.info);

				if (enemy && g_Vars.esp.draw_name || team && g_Vars.esp.draw_name_team)
					DrawName(player, m_Data.bbox, m_Data.info);

				if (enemy && g_Vars.esp.draw_ammo_bar || enemy && g_Vars.esp.draw_lby_bar || team && g_Vars.esp.draw_ammo_bar_team)
					AmmoBar(player, m_Data.bbox);

				DrawBottomInfo(player, m_Data.bbox, m_Data.info);
			}
		}

		auto rgb_to_int = [](int red, int green, int blue) -> int {
			int r;
			int g;
			int b;

			r = red & 0xFF;
			g = green & 0xFF;
			b = blue & 0xFF;
			return (r << 16 | g << 8 | b);
		};

		if (entity->GetClientClass()->m_ClassID == CFogController) {
			static DWORD dwFogEnable = Engine::Displacement.DT_FogController.m_fog_enable;
			*(byte*)((uintptr_t)entity + dwFogEnable) = g_Vars.esp.fog_effect;

			g_Vars.r_3dsky->SetValue(int(!g_Vars.esp.fog_effect));

			*(bool*)(uintptr_t(entity) + 0xA1D) = g_Vars.esp.fog_effect;
			*(float*)(uintptr_t(entity) + 0x9F8) = 0;
			*(float*)(uintptr_t(entity) + 0x9FC) = g_Vars.esp.fog_distance;
			*(float*)(uintptr_t(entity) + 0xA04) = g_Vars.esp.fog_density / 100.f;
			*(float*)(uintptr_t(entity) + 0xA24) = g_Vars.esp.fog_hdr_scale / 100.f;
			*(int*)(uintptr_t(entity) + 0x9E8) = rgb_to_int((int)(g_Vars.esp.fog_color.b * 255.f), (int)(g_Vars.esp.fog_color.g * 255.f), (int)(g_Vars.esp.fog_color.r * 255.f));
			*(int*)(uintptr_t(entity) + 0x9EC) = rgb_to_int((int)(g_Vars.esp.fog_color.b * 255.f), (int)(g_Vars.esp.fog_color.g * 255.f), (int)(g_Vars.esp.fog_color.r * 255.f));


			continue;
		}

		RenderNades((C_WeaponCSBaseGun*)entity);

		float distance{ };
		distance = !m_LocalPlayer->IsDead() ? m_LocalPlayer->GetAbsOrigin().Distance(entity->m_vecOrigin()) : 0.f;

		float initial_alpha = 255.f;
		const auto clamped_distance = std::clamp<float>(distance - 300.f, 0.f, 510.f);
		initial_alpha = 255.f - (clamped_distance * 0.5f);
		initial_alpha *= 0.70588235294;

		if (!_strcmpi(entity->GetClientClass()->m_pNetworkName, (XorStr("CPlantedC4")))) {
			auto bomb_entity = (C_PlantedC4*)entity;

			static ConVar* mp_c4timer = Interfaces::m_pCvar->FindVar(XorStr("mp_c4timer"));
			static bool bomb_planted_tick_begin = false;
			static float bomb_time_tick_begin = 0.f;

			if (g_Vars.esp.draw_c4_bar && g_Vars.globals.bBombActive) {
				Vector origin = bomb_entity->GetAbsOrigin();
				Vector2D screen_origin = Vector2D();

				if (!bomb_planted_tick_begin) {
					bomb_time_tick_begin = Interfaces::m_pGlobalVars->curtime;
					bomb_planted_tick_begin = true;
				}

				float timer_bomb = 0.f;
				if (bomb_entity->m_flC4Blow() - Interfaces::m_pGlobalVars->curtime > 0.f)
					timer_bomb = bomb_entity->m_flC4Blow() - Interfaces::m_pGlobalVars->curtime;
				else
					timer_bomb = 0.f;

				if (timer_bomb > 0.f) {
					const auto spawn_time = TIME_TO_TICKS(bomb_time_tick_begin);
					const auto factor = timer_bomb / mp_c4timer->GetFloat();

					char subs[64] = { };
					sprintf(subs, XorStr("%.1fs"), timer_bomb);

					char buf[64] = { };
					sprintf(buf, XorStr("C4 - %s"), subs);

					if (factor > 0.f) {
						Math::Clamp(factor, 0.f, 1.0f);

						Vector2D center = Render::GetScreenSize();

						static float flBombTickTime = Interfaces::m_pGlobalVars->realtime;
						static float flRedBombAlpha = 1.f;
						if (g_Vars.globals.bBombTicked) {
							flRedBombAlpha = 1.f;
							flBombTickTime = Interfaces::m_pGlobalVars->realtime;
							g_Vars.globals.bBombTicked = false;
						}

						float flBeepDelta = fabs(Interfaces::m_pGlobalVars->realtime - flBombTickTime);
						bool bRenderRedBomb = (flBeepDelta <= 0.1f && flBeepDelta > 0.f) || g_Vars.globals.bBombTicked;
						if (!bRenderRedBomb) {
							flRedBombAlpha -= (1.0f / 0.1f) * Interfaces::m_pGlobalVars->frametime;
						}

						flRedBombAlpha = std::clamp<float>(flRedBombAlpha, 0.f, 1.f);

						static const auto size_icon = Vector2D(Render::Engine::cs_large.size(XorStr("q")).m_width + 2, 4.f);
						static const auto size = Vector2D(Render::Engine::indi.size(buf).m_width + 2, 4.f);
						Render::Engine::cs_large.string(((center.x * 0.5f) - Render::Engine::indi.size(std::string(" - ") + subs).m_width) + 30, center.y * 0.15f + 2,
							Color::White().OverrideAlpha(180 - (180 * flRedBombAlpha)), XorStr("q"), Render::Engine::ALIGN_LEFT);

						//if( bRenderRedBomb )
						Render::Engine::cs_large.string(((center.x * 0.5f) - Render::Engine::indi.size(std::string(" - ") + subs).m_width) + 30, center.y * 0.15f + 2,
							Color::Red().OverrideAlpha(255 * flRedBombAlpha), XorStr("q"), Render::Engine::ALIGN_LEFT);

						Render::Engine::indi.string((center.x * 0.5f) + size_icon.x, center.y * 0.15f, Color::White().OverrideAlpha(180 - (180 * flRedBombAlpha)), std::string(buf).substr(2), Render::Engine::ALIGN_CENTER);

						//if( bRenderRedBomb )
						Render::Engine::indi.string((center.x * 0.5f) + size_icon.x, center.y * 0.15f, Color::Red().OverrideAlpha(255 * flRedBombAlpha), std::string(buf).substr(2), Render::Engine::ALIGN_CENTER);
					}

					if (WorldToScreen(origin, screen_origin)) {
						static const auto size = Vector2D(Render::Engine::segoe.size(buf).m_width + 2, 4.f);

						auto new_pos = Vector2D(screen_origin.x - size.x * 0.5, screen_origin.y - size.y * 0.5);

						if (factor > 0.f) {
							Math::Clamp(factor, 0.f, 1.0f);
							Render::Engine::RectFilled(new_pos, size, FloatColor(0.f, 0.f, 0.f, 0.58f).ToRegularColor());
							Render::Engine::RectFilled(Vector2D(new_pos.x + 1, new_pos.y + 1), Vector2D((size.x - 1) * factor, size.y - 2), g_Vars.esp.c4_color.ToRegularColor().OverrideAlpha(255 * 0.87f));

							Render::Engine::segoe.string(new_pos.x + (size.x * 0.5f), new_pos.y - 9, g_Vars.esp.c4_color.ToRegularColor().OverrideAlpha(180 * 0.87f), buf, Render::Engine::ALIGN_CENTER);
						}
					}
				}
			}
		}

		if (g_Vars.esp.draw_c4_bar) {
			if (entity->m_hOwnerEntity() == -1 &&
				entity->GetClientClass()->m_ClassID == CC4) {

				Vector2D out;
				if (WorldToScreen(entity->GetAbsOrigin(), out)) {
					Render::Engine::segoe.string(out.x + 2, out.y, g_Vars.esp.c4_color.ToRegularColor().OverrideAlpha(180 * 0.87f), XorStr("C4"));
				}
			}
		}

		if ((g_Vars.esp.dropped_weapons || g_Vars.esp.dropped_weapons_ammo) && initial_alpha && !m_LocalPlayer->IsDead()) {
			if (!entity->IsWeapon() || entity->m_hOwnerEntity() != -1 ||
				entity->GetClientClass()->m_ClassID == CC4 ||
				entity->GetClientClass()->m_ClassID == CPlantedC4)
				continue;

			auto weapon = reinterpret_cast<C_WeaponCSBaseGun*>(entity);
			if (!weapon)
				continue;

			Vector2D out;
			if (!WorldToScreen(weapon->GetAbsOrigin(), out))
				continue;

			auto weapondata = weapon->GetCSWeaponData();
			if (!weapondata.IsValid())
				continue;

			if (!weapon->m_iItemDefinitionIndex())
				continue;

			std::wstring localized = Interfaces::m_pLocalize->Find(weapondata->m_szHudName);
			std::string name{ localized.begin(), localized.end() };
			std::transform(name.begin(), name.end(), name.begin(), ::toupper);

			if (name.empty())
				continue;

			if (g_Vars.esp.dropped_weapons) {
				Render::Engine::segoe.string(out.x + 2, out.y, g_Vars.esp.dropped_weapons_color.ToRegularColor().OverrideAlpha(static_cast<int>(initial_alpha)), name);
			}

			if (g_Vars.esp.dropped_weapons_ammo) {
				auto clip = weapon->m_iClip1();
				if (clip > 0) {
					const auto TextSize = Render::Engine::segoe.size(name);

					const auto MaxClip = weapondata->m_iMaxClip;
					auto Width = TextSize.m_width;

					Width *= clip;
					Width /= MaxClip;

					Render::Engine::RectFilled(Vector2D(out.x, out.y) + Vector2D(1, 9), Vector2D(TextSize.m_width + 1, 4),
						FloatColor(0.f, 0.f, 0.f, (initial_alpha / 255.f) * 0.58f).ToRegularColor());


					Render::Engine::RectFilled(Vector2D(out.x, out.y) + Vector2D(2, 10), Vector2D(Width - 1, 2),
						g_Vars.esp.dropped_weapons_color.ToRegularColor().OverrideAlpha(static_cast<int>(initial_alpha)));

					if (clip <= static_cast<int>(MaxClip * 0.75)) {
						Render::Engine::pixel_reg.string(out.x + Width, out.y + 8, Color::White().OverrideAlpha(static_cast<int>(initial_alpha)), std::to_string(clip));
					}
				}
			}
		}
	}
}

void CEsp::SetAlpha(int idx) {
	m_bAlphaFix[idx] = true;
}

float CEsp::GetAlpha(int idx) {
	return m_flAlpha[idx];
}

#include "../Rage/Resolver.hpp"
void CEsp::AmmoBar(C_CSPlayer* player, BBox_t bbox) {
	if (!player)
		return;

	C_WeaponCSBaseGun* pWeapon = (C_WeaponCSBaseGun*)player->m_hActiveWeapon().Get();

	if (!pWeapon)
		return;

	auto pWeaponData = pWeapon->GetCSWeaponData();
	if (!pWeaponData.IsValid())
		return;

	auto local = C_CSPlayer::GetLocalPlayer();
	bool enemy = player->m_iTeamNum() != local->m_iTeamNum();

	if (!enemy)
	{
		int index = 0;

		if (g_Vars.esp.draw_ammo_bar_team) {
			auto animLayer = player->m_AnimOverlay().Element(1);
			if (animLayer.m_pOwner && pWeaponData->m_iWeaponType != WEAPONTYPE_GRENADE && pWeaponData->m_iWeaponType != WEAPONTYPE_KNIFE && pWeaponData->m_iWeaponType != WEAPONTYPE_C4) {
				index += 6;

				auto activity = player->GetSequenceActivity(animLayer.m_nSequence);

				int current = pWeapon->m_iClip1();
				int max = pWeaponData->m_iMaxClip;
				bool reloading = activity == 967 && animLayer.m_flWeight != 0.f;
				int reload_percentage = reloading ? std::ceil(100 * animLayer.m_flCycle) : 100;
				float scale;

				// check for reload.
				if (reloading)
					scale = animLayer.m_flCycle;

				// not reloading.
				// make the division of 2 ints produce a float instead of another int.
				else
					scale = max != -1 ? (float)current / max : 1.f;

				// relative to bar.
				int bar = (int)std::round((bbox.w - 2) * scale);

				// draw.
				Render::Engine::RectFilled(bbox.x, bbox.y + bbox.h + 2, bbox.w, 4, Color(0, 0, 0, 180 * this->m_flAlpha[player->EntIndex()]));

				Color clr = g_Vars.esp.ammo_color.ToRegularColor();
				clr.RGBA[3] *= this->m_flAlpha[player->EntIndex()];

				Render::Engine::Rect(bbox.x + 1, bbox.y + bbox.h + 3, bar, 2, clr);

				// less then a 5th of the bullets left.
				if (current < max || reloading) {
					Render::Engine::pixel_reg.string(bbox.x + bar, bbox.y + bbox.h, Color(255, 255, 255, 180 * this->m_flAlpha[player->EntIndex()]), std::to_string(reloading ? reload_percentage : current).append(reloading ? XorStr("%") : XorStr("")), Render::Engine::ALIGN_CENTER);
				}
			}
		}
	}
	else
	{
		int index = 0;

		if (g_Vars.esp.draw_ammo_bar) {
			auto animLayer = player->m_AnimOverlay().Element(1);
			if (animLayer.m_pOwner && pWeaponData->m_iWeaponType != WEAPONTYPE_GRENADE && pWeaponData->m_iWeaponType != WEAPONTYPE_KNIFE && pWeaponData->m_iWeaponType != WEAPONTYPE_C4) {
				index += 6;

				auto activity = player->GetSequenceActivity(animLayer.m_nSequence);

				int current = pWeapon->m_iClip1();
				int max = pWeaponData->m_iMaxClip;
				bool reloading = activity == 967 && animLayer.m_flWeight != 0.f;
				int reload_percentage = reloading ? std::ceil(100 * animLayer.m_flCycle) : 100;
				float scale;

				// check for reload.
				if (reloading)
					scale = animLayer.m_flCycle;

				// not reloading.
				// make the division of 2 ints produce a float instead of another int.
				else
					scale = max != -1 ? (float)current / max : 1.f;

				// relative to bar.
				int bar = (int)std::round((bbox.w - 2) * scale);

				// draw.
				Render::Engine::RectFilled(bbox.x, bbox.y + bbox.h + 2, bbox.w, 4, Color(0, 0, 0, 180 * this->m_flAlpha[player->EntIndex()]));

				Color clr = g_Vars.esp.ammo_color.ToRegularColor();
				clr.RGBA[3] *= this->m_flAlpha[player->EntIndex()];

				Render::Engine::Rect(bbox.x + 1, bbox.y + bbox.h + 3, bar, 2, clr);

				// less then a 5th of the bullets left.
				if (current < max || reloading) {
					Render::Engine::pixel_reg.string(bbox.x + bar, bbox.y + bbox.h, Color(255, 255, 255, 180 * this->m_flAlpha[player->EntIndex()]), std::to_string(reloading ? reload_percentage : current).append(reloading ? XorStr("%") : XorStr("")), Render::Engine::ALIGN_CENTER);
				}
			}
		}

		if (g_Vars.esp.draw_lby_bar && !local->IsDead() && Engine::g_ResolverData[player->EntIndex()].m_bPredictingUpdates) {
			int current = pWeapon->m_iClip1();
			int max = pWeaponData->m_iMaxClip;
			float scale;

			float flUpdateTime = Engine::g_ResolverData[player->EntIndex()].m_flNextBodyUpdate - player->m_flAnimationTime();

			// check for pred.
			scale = (1.1f - flUpdateTime) / 1.1f;

			// relative to bar.
			int bar = std::clamp((int)std::round((bbox.w - 2) * scale), 0, bbox.w - 2);

			// draw.
			Render::Engine::RectFilled(bbox.x, bbox.y + bbox.h + 2 + index, bbox.w, 4, Color(0, 0, 0, 180 * this->m_flAlpha[player->EntIndex()]));

			Color clr = g_Vars.esp.lby_color.ToRegularColor();
			clr.RGBA[3] *= this->m_flAlpha[player->EntIndex()];

			Render::Engine::Rect(bbox.x + 1, bbox.y + bbox.h + 3 + index, bar, 2, clr);
		}
	}
}

void CEsp::RenderNades(C_WeaponCSBaseGun* nade) {
	if (!g_Vars.esp.nades)
		return;

	const model_t* model = nade->GetModel();
	if (!model)
		return;

	studiohdr_t* hdr = Interfaces::m_pModelInfo->GetStudiomodel(model);
	if (!hdr)
		return;

	int item_definition = 0;
	bool dont_render = false;
	C_SmokeGrenadeProjectile* pSmokeEffect = nullptr;
	C_Inferno* pMolotov = nullptr;
	Color Nadecolor;
	std::string Name = hdr->szName;
	switch (nade->GetClientClass()->m_ClassID) {
	case ClassId_t::CBaseCSGrenadeProjectile:
		if (Name[16] == 's') {
			Name = XorStr("FLASH");
			item_definition = WEAPON_FLASHBANG;
		}
		else {
			Name = XorStr("FRAG");
			item_definition = WEAPON_HEGRENADE;
		}
		break;
	case ClassId_t::CSmokeGrenadeProjectile:
		Name = XorStr("SMOKE");
		item_definition = WEAPON_SMOKE;
		pSmokeEffect = reinterpret_cast<C_SmokeGrenadeProjectile*>(nade);
		if (pSmokeEffect) {
			const auto spawn_time = TICKS_TO_TIME(pSmokeEffect->m_nSmokeEffectTickBegin());
			const auto time = (spawn_time + C_SmokeGrenadeProjectile::GetExpiryTime()) - Interfaces::m_pGlobalVars->curtime;
			const auto factor = ((spawn_time + C_SmokeGrenadeProjectile::GetExpiryTime()) - Interfaces::m_pGlobalVars->curtime) / C_SmokeGrenadeProjectile::GetExpiryTime();

			if (factor > 0.0f)
				dont_render = true;
		}
		else {
			dont_render = false;
		}
		break;
	case ClassId_t::CMolotovProjectile:
		Name = XorStr("FIRE");
		// bich
		if (nade && (nade->m_hOwnerEntity().Get()) && ((C_CSPlayer*)(nade->m_hOwnerEntity().Get()))) {
			item_definition = ((C_CSPlayer*)(nade->m_hOwnerEntity().Get()))->m_iTeamNum() == TEAM_CT ? WEAPON_FIREBOMB : WEAPON_MOLOTOV;
		}
		pMolotov = reinterpret_cast<C_Inferno*>(nade);
		if (pMolotov) {
			const auto spawn_time = pMolotov->m_flSpawnTime();
			const auto time = ((spawn_time + C_Inferno::GetExpiryTime()) - Interfaces::m_pGlobalVars->curtime);

			if (time <= 0.05f)
				dont_render = true;
		}
		else {
			dont_render = false;
		}
		break;
	case ClassId_t::CDecoyProjectile:
		Name = XorStr("DECOY");
		item_definition = WEAPON_DECOY;
		break;
	default:
		return;
	}

	Vector2D points_transformed[8];
	BBox_t size;

	if (!GetBBox(nade, points_transformed, size) || dont_render)
		return;

	Render::Engine::segoe.string(size.x, size.y - 2, Color(255, 255, 255, 220), Name.c_str(), Render::Engine::ALIGN_CENTER);
}

void CEsp::DrawBox(BBox_t bbox, const FloatColor& clr, C_CSPlayer* player) {
	if (!player)
		return;

	auto color = clr;
	color.a *= (m_flAlpha[player->EntIndex()]);

	FloatColor outline = FloatColor(0.0f, 0.0f, 0.0f, color.a * 0.68f);
	//if( g_Vars.esp.box_type == 0 ) {
	Render::Engine::Rect(bbox.x - 1, bbox.y - 1, bbox.w + 2, bbox.h + 2, Color(0, 0, 0, 180 * m_flAlpha[player->EntIndex()]));
	Render::Engine::Rect(bbox.x + 1, bbox.y + 1, bbox.w - 2, bbox.h - 2, Color(0, 0, 0, 180 * m_flAlpha[player->EntIndex()]));
	Render::Engine::Rect(bbox.x, bbox.y, bbox.w, bbox.h, color.ToRegularColor());
	//}
}

void CEsp::DrawHealthBar(C_CSPlayer* player, BBox_t bbox) {
	int y = bbox.y + 1;
	int h = bbox.h - 2;

	// retarded servers that go above 100 hp..
	int hp = std::min(100, player->m_iHealth());

	// calculate hp bar color.
	int r = std::min((510 * (100 - hp)) / 100, 255);
	int g = std::min((510 * hp) / 100, 255);

	// get hp bar height.
	int fill = (int)std::round(hp * h / 100.f);

	// render background.
	Render::Engine::RectFilled(bbox.x - 6, y - 1, 4, h + 2, Color(10, 10, 10, 180 * GetAlpha(player->EntIndex())));

	bool enemy = player->m_iTeamNum() != m_LocalPlayer->m_iTeamNum();

	// render actual bar.
	if (enemy)
		Render::Engine::Rect(bbox.x - 5, y + h - fill, 2, fill, g_Vars.esp.health_override ? g_Vars.esp.health_color.ToRegularColor().OverrideAlpha(210 * GetAlpha(player->EntIndex()), true)
			: Color(r, g, 0, 210 * GetAlpha(player->EntIndex())));
	else
		Render::Engine::Rect(bbox.x - 5, y + h - fill, 2, fill, g_Vars.esp.health_override_team ? g_Vars.esp.health_color_team.ToRegularColor().OverrideAlpha(210 * GetAlpha(player->EntIndex()), true)
			: Color(r, g, 0, 210 * GetAlpha(player->EntIndex())));

	// if hp is below max, draw a string.
	if (hp < 100)
		Render::Engine::pixel_reg.string(bbox.x - 5, y + (h - fill) - 5, Color(255, 255, 255, 200 * GetAlpha(player->EntIndex())), std::to_string(hp), Render::Engine::ALIGN_CENTER);
}

void CEsp::DrawInfo(C_CSPlayer* player, BBox_t bbox, player_info_t player_info) {
	auto animState = player->m_PlayerAnimState();
	if (!animState)
		return;

	auto color = FloatColor(0, 150, 255, (int)(180 * m_flAlpha[player->EntIndex()]));
	color.a *= m_flAlpha[player->EntIndex()];

	auto anim_data = Engine::AnimationSystem::Get()->GetAnimationData(player->m_entIndex);
	auto lag_data = Engine::LagCompensation::Get()->GetLagData(player->m_entIndex);


	if (player->m_bIsScoped() && g_Vars.esp.draw_scoped)
		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(0, 150, 255, (int)(180 * m_flAlpha[player->EntIndex()])), XorStr("ZOOM"));

	if (g_Vars.esp.draw_money)
		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(133, 198, 22, (int)(180 * m_flAlpha[player->EntIndex()])), XorStr("$") + std::to_string(player->m_iAccount()));

	if (g_Vars.esp.draw_armor && player->m_ArmorValue() > 0) {
		std::string name = player->m_bHasHelmet() ? XorStr("HK") : XorStr("K");
		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(255, 255, 255, (int)(180 * m_flAlpha[player->EntIndex()])), name.c_str());
	}

	if (g_Vars.esp.draw_defusing && player->m_bHasDefuser()) {
		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(105, 218, 204, (int)(180 * m_flAlpha[player->EntIndex()])), XorStr("KIT"));
	}

	if (g_Vars.esp.draw_flashed && player->m_flFlashDuration() > 1.f)
		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(255, 216, 0, (int)(180 * m_flAlpha[player->EntIndex()])), XorStr("FLASH"));

	if (g_Vars.esp.draw_defusing && player->m_bIsDefusing()) {
		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(235, 82, 82, (int)(180 * m_flAlpha[player->EntIndex()])), XorStr("DEF"));
	}

	if (player->m_bIsDefusing()) {
		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(235, 82, 82, (int)(180 * m_flAlpha[player->EntIndex()])), XorStr("DEF"));
	}



	int ping = round((*Interfaces::m_pPlayerResource.Xor())->GetPlayerPing(player->EntIndex()));



	if (ping > 50)
	{

		float ping_percent = std::clamp(ping, 0, 750) / 750.f;

		Color ping_flag(255, 255 - ((ping_percent) * 255), 255 - ((ping_percent) * 255));


		ping_flag.RGBA[3] = (int)(180 * m_flAlpha[player->EntIndex()]);

		FloatColor Ping_Flag_Last = FloatColor(ping_flag.RGBA[0], ping_flag.RGBA[1], ping_flag.RGBA[2], ping_flag.RGBA[3]);
		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(Ping_Flag_Last, "" + std::to_string(ping) + " ms");
	}


	if (g_Vars.esp.draw_distance) {
		C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
		if (local && !local->IsDead()) {
			auto round_to_multiple = [&](int in, int multiple) {
				const auto ratio = static_cast<double>(in) / multiple;
				const auto iratio = std::lround(ratio);
				return static_cast<int>(iratio * multiple);
			};

			float distance = local->m_vecOrigin().Distance(player->m_vecOrigin());

			auto meters = distance * 0.0254f;
			auto feet = meters * 3.281f;

			std::string str = std::to_string(round_to_multiple(feet, 5)) + XorStr(" FT");
			g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(255, 255, 255, (int)(180 * m_flAlpha[player->EntIndex()])), str.c_str());
		}
	}

	auto weapons = player->m_hMyWeapons();
	for (size_t i = 0; i < 48; ++i) {
		auto weapon_handle = weapons[i];
		if (!weapon_handle.IsValid())
			break;

		auto weapon = (C_BaseCombatWeapon*)weapon_handle.Get();
		if (!weapon)
			continue;

		auto definition_index = weapon->m_Item().m_iItemDefinitionIndex();

		if (definition_index == WEAPON_C4 && g_Vars.esp.draw_bombc4)
			g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(255, 0, 0, (int)(180 * m_flAlpha[player->EntIndex()])), XorStr("BOMB"));
	}

	auto pWeapon = (C_WeaponCSBaseGun*)player->m_hActiveWeapon().Get();
	if (g_Vars.esp.draw_grenade_pin && pWeapon) {
		auto pWeaponData = pWeapon->GetCSWeaponData();
		if (pWeaponData.IsValid()) {
			if (pWeaponData->m_iWeaponType == WEAPONTYPE_GRENADE && pWeapon->m_bPinPulled()) {
				g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(255, 0, 0, (int)(180 * m_flAlpha[player->EntIndex()])), XorStr("PIN"));
			}
		}
	}

	auto local = C_CSPlayer::GetLocalPlayer();
	if (!local->IsDead() && anim_data && lag_data.IsValid() && g_Vars.esp.draw_resolver) {
		if (!anim_data->m_AnimationRecord.empty()) {
			auto current = &anim_data->m_AnimationRecord.front();
			if (current) {
				g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(0, 255, 255, (int)(180 * m_flAlpha[player->EntIndex()])), current->m_resolver_mode);
			}
		}
	}

	if (local && anim_data && !player->IsDormant() && lag_data.IsValid() && anim_data->m_AnimationRecord.size() >= 2 && g_Vars.esp.draw_layer_info) {
		int layer = g_Vars.esp.layer + 1;
		C_AnimationLayer* current_layer = &player->m_AnimOverlay()[layer];

		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(255, 255, 255, (int)(180 * m_flAlpha[player->EntIndex()])), std::string("C ") + std::to_string(current_layer->m_flCycle));
		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(255, 255, 255, (int)(180 * m_flAlpha[player->EntIndex()])), std::string("W ") + std::to_string(current_layer->m_flWeight));
		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(255, 255, 255, (int)(180 * m_flAlpha[player->EntIndex()])), std::string("P ") + std::to_string(current_layer->m_flPlaybackRate));
		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(255, 255, 255, (int)(180 * m_flAlpha[player->EntIndex()])), std::string("B ") + std::to_string(current_layer->m_flBlendIn));
		g_Vars.globals.m_vecTextInfo[player->EntIndex()].emplace_back(FloatColor(50, 255, 50, (int)(180 * m_flAlpha[player->EntIndex()])), std::to_string(player->GetSequenceActivity(current_layer->m_nSequence)));
	}

	int i = 0;
	for (auto text : g_Vars.globals.m_vecTextInfo[player->EntIndex()]) {
		Render::Engine::pixel_reg.string(bbox.x + bbox.w + 2, bbox.y + i, text.first.ToRegularColor(), text.second.c_str());
		i += (Render::Engine::pixel_reg.m_size.m_height - 1);
	}
}

std::map<int, char> weapon_icons = {
	{ WEAPON_DEAGLE, 'A' },
	{ WEAPON_ELITE, 'B' },
	{ WEAPON_FIVESEVEN, 'C' },
	{ WEAPON_GLOCK, 'D' },
	{ WEAPON_P2000, 'E' },
	{ WEAPON_P250, 'F' },
	{ WEAPON_USPS, 'G' },
	{ WEAPON_TEC9, 'H' },
	{ WEAPON_CZ75A, 'I' },
	{ WEAPON_REVOLVER, 'J' },
	{ WEAPON_MAC10, 'K' },
	{ WEAPON_UMP45, 'L' },
	{ WEAPON_BIZON, 'M' },
	{ WEAPON_MP7, 'N' },
	{ WEAPON_MP9, 'O' },
	{ WEAPON_P90, 'P' },
	{ WEAPON_GALIL, 'Q' },
	{ WEAPON_FAMAS, 'R' },
	{ WEAPON_M4A4, 'S' },
	{ WEAPON_M4A1S, 'T' },
	{ WEAPON_AUG, 'U' },
	{ WEAPON_SG553, 'V' },
	{ WEAPON_AK47, 'W' },
	{ WEAPON_G3SG1, 'X' },
	{ WEAPON_SCAR20, 'Y' },
	{ WEAPON_AWP, 'Z' },
	{ WEAPON_SSG08, 'a' },
	{ WEAPON_XM1014, 'b' },
	{ WEAPON_SAWEDOFF, 'c' },
	{ WEAPON_MAG7, 'd' },
	{ WEAPON_NOVA, 'e' },
	{ WEAPON_NEGEV, 'f' },
	{ WEAPON_M249, 'g' },
	{ WEAPON_ZEUS, 'h' },
	{ WEAPON_KNIFE_T, 'i' },
	{ WEAPON_KNIFE_CT, 'j' },
	{ WEAPON_KNIFE_FALCHION, '0' },
	{ WEAPON_KNIFE_BAYONET, '1' },
	{ WEAPON_KNIFE_FLIP, '2' },
	{ WEAPON_KNIFE_GUT, '3' },
	{ WEAPON_KNIFE_KARAMBIT, '4' },
	{ WEAPON_KNIFE_M9_BAYONET, '5' },
	{ WEAPON_KNIFE_HUNTSMAN, '6' },
	{ WEAPON_KNIFE_BOWIE, '7' },
	{ WEAPON_KNIFE_BUTTERFLY, '8' },
	{ WEAPON_FLASHBANG, 'k' },
	{ WEAPON_HEGRENADE, 'l' },
	{ WEAPON_SMOKE, 'm' },
	{ WEAPON_MOLOTOV, 'n' },
	{ WEAPON_DECOY, 'o' },
	{ WEAPON_FIREBOMB, 'p' },
	{ WEAPON_C4, 'q' },
};

std::string GetWeaponIcon(const int id) {
	auto search = weapon_icons.find(id);
	if (search != weapon_icons.end())
		return std::string(&search->second, 1);

	return "";
}

std::string GetLocalizedName(CCSWeaponInfo* wpn_data) {
	if (!wpn_data)
		return XorStr("ERROR");

	return Math::WideToMultiByte(Interfaces::m_pLocalize->Find(wpn_data->m_szHudName));
}

void CEsp::DrawBottomInfo(C_CSPlayer* player, BBox_t bbox, player_info_t player_info) {
	std::vector<std::pair<Color, std::pair<std::string, Render::Engine::Font>>> m_vecTextInfo;

	auto pWeapon = (C_WeaponCSBaseGun*)(player->m_hActiveWeapon().Get());
	auto color = g_Vars.esp.weapon_color.ToRegularColor().OverrideAlpha(180, true);
	color.RGBA[3] *= m_flAlpha[player->EntIndex()];

	auto color_icon = g_Vars.esp.weapon_icon_color.ToRegularColor().OverrideAlpha(180, true);
	color_icon.RGBA[3] *= m_flAlpha[player->EntIndex()];

	if (!pWeapon)
		return;

	auto pWeaponData = pWeapon->GetCSWeaponData();
	if (!pWeaponData.IsValid())
		return;

	bool enemy = player->m_iTeamNum() != m_LocalPlayer->m_iTeamNum();

	if (enemy)
	{
		float i = 2.f;

		if (g_Vars.esp.draw_ammo_bar && (pWeaponData->m_iWeaponType != WEAPONTYPE_GRENADE && pWeaponData->m_iWeaponType != WEAPONTYPE_KNIFE && pWeaponData->m_iWeaponType != WEAPONTYPE_C4))
			i += 6.f;

		if (g_Vars.esp.draw_lby_bar && Engine::g_ResolverData[player->EntIndex()].m_bPredictingUpdates)
			i += 6.f;

		if (g_Vars.esp.weapon_icon) {
			m_vecTextInfo.emplace_back(color_icon, std::pair{ GetWeaponIcon(pWeapon->m_iItemDefinitionIndex()), Render::Engine::cs });
		}

		if (g_Vars.esp.weapon) {
			std::string name{ GetLocalizedName(pWeaponData.Xor()) };

			std::transform(name.begin(), name.end(), name.begin(), ::toupper);

			m_vecTextInfo.emplace_back(color, std::pair{ name, Render::Engine::pixel_reg });
		}

		for (auto text : m_vecTextInfo) {
			if (text.second.second.m_handle == Render::Engine::pixel_reg.m_handle) {
				text.second.second.string(bbox.x + bbox.w / 2, (bbox.y + bbox.h - 2) + i, text.first, text.second.first.c_str(), Render::Engine::ALIGN_CENTER);
			}
			else {
				text.second.second.string(bbox.x + bbox.w / 2, bbox.y + bbox.h + i, text.first, text.second.first.c_str(), Render::Engine::ALIGN_CENTER);
			}

			i += text.second.second.m_size.m_height;
		}
	}
	else if (!enemy && player != m_LocalPlayer)
	{
		float i = 2.f;

		if (g_Vars.esp.draw_ammo_bar_team && (pWeaponData->m_iWeaponType != WEAPONTYPE_GRENADE && pWeaponData->m_iWeaponType != WEAPONTYPE_KNIFE && pWeaponData->m_iWeaponType != WEAPONTYPE_C4))
			i += 6.f;

		if (g_Vars.esp.weapon_icon_team) {
			m_vecTextInfo.emplace_back(color_icon, std::pair{ GetWeaponIcon(pWeapon->m_iItemDefinitionIndex()), Render::Engine::cs });
		}

		if (g_Vars.esp.weapon_team) {
			std::string name{ GetLocalizedName(pWeaponData.Xor()) };

			std::transform(name.begin(), name.end(), name.begin(), ::toupper);

			m_vecTextInfo.emplace_back(color, std::pair{ name, Render::Engine::pixel_reg });
		}

		for (auto text : m_vecTextInfo) {
			if (text.second.second.m_handle == Render::Engine::pixel_reg.m_handle) {
				text.second.second.string(bbox.x + bbox.w / 2, (bbox.y + bbox.h - 2) + i, text.first, text.second.first.c_str(), Render::Engine::ALIGN_CENTER);
			}
			else {
				text.second.second.string(bbox.x + bbox.w / 2, bbox.y + bbox.h + i, text.first, text.second.first.c_str(), Render::Engine::ALIGN_CENTER);
			}

			i += text.second.second.m_size.m_height;
		}
	}
}

void CEsp::DrawName(C_CSPlayer* player, BBox_t bbox, player_info_t player_info) {
	// fix retards with their namechange meme 
	// the point of this is overflowing unicode compares with hardcoded buffers, good hvh strat
	std::string name{ std::string(player_info.szName).substr(0, 24) };

	//#if defined (DEV)
	//	name.append( XorStr( " (" ) ).append( std::to_string( player->m_entIndex ) ).append( XorStr( ")" ) );
	//#endif

	Color clr;

	if (player->m_iTeamNum() != m_LocalPlayer->m_iTeamNum())
		clr = g_Vars.esp.name_color.ToRegularColor().OverrideAlpha(180, true);
	else
		clr = g_Vars.esp.name_color_team.ToRegularColor().OverrideAlpha(180, true);

	clr.RGBA[3] *= m_flAlpha[player->EntIndex()];

	Render::Engine::esp.string(bbox.x + bbox.w / 2, bbox.y - Render::Engine::segoe.m_size.m_height - 1, clr, name, Render::Engine::ALIGN_CENTER);

}

void CEsp::DrawSkeleton(C_CSPlayer* player) {
	auto model = player->GetModel();
	if (!model)
		return;

	if (player->IsDormant())
		return;

	auto* hdr = Interfaces::m_pModelInfo->GetStudiomodel(model);
	if (!hdr)
		return;

	// render skeleton
	Vector2D bone1, bone2;
	for (size_t n{ }; n < hdr->numbones; ++n) {
		auto* bone = hdr->pBone(n);
		if (!bone || !(bone->flags & 256) || bone->parent == -1) {
			continue;
		}

		auto BonePos = [&](int n) -> Vector {
			return Vector(
				player->m_CachedBoneData().m_Memory.m_pMemory[n][0][3],
				player->m_CachedBoneData().m_Memory.m_pMemory[n][1][3],
				player->m_CachedBoneData().m_Memory.m_pMemory[n][2][3]
			);
		};

		if (!WorldToScreen(BonePos(n), bone1) || !WorldToScreen(BonePos(bone->parent), bone2)) {
			continue;
		}

		auto color = g_Vars.esp.skeleton_color.ToRegularColor().OverrideAlpha(180, true);
		color.RGBA[3] *= m_flAlpha[player->EntIndex()];

		Render::Engine::Line(bone1, bone2, color);
	}
}

void CEsp::DrawHitSkeleton() {
	auto pLocal = C_CSPlayer::GetLocalPlayer();

	if (!g_Vars.globals.HackIsReady || !Interfaces::m_pEngine->IsConnected() || !Interfaces::m_pEngine->IsInGame() || !pLocal) {
		m_Hitmatrix.clear();
		return;
	}

	if (m_Hitmatrix.empty())
		return;

	Vector2D bone1, bone2;
	for (size_t i{ }; i < m_Hitmatrix.size(); ++i) {
		auto delta = Interfaces::m_pGlobalVars->realtime - m_Hitmatrix[i].m_flTime;
		if (delta > 0.0f && delta < 1.0f) {
			m_Hitmatrix[i].m_flAlpha -= delta;
		}

		if (m_Hitmatrix[i].m_flAlpha <= 0.0f || !m_Hitmatrix[i].pBoneToWorld || !m_Hitmatrix[i].m_pEntity->GetModel() || !m_Hitmatrix[i].m_pEntity) {
			continue;
		}

		auto* model = Interfaces::m_pModelInfo->GetStudiomodel(m_Hitmatrix[i].m_pEntity->GetModel());
		if (!model) {
			continue;
		}

		// render hurt skeleton
		for (size_t n{ }; n < model->numbones; ++n) {
			auto* bone = model->pBone(n);
			if (!bone || !(bone->flags & 256) || bone->parent == -1) {
				continue;
			}

			auto BonePos = [&](int n) -> Vector {
				return Vector(
					m_Hitmatrix[i].pBoneToWorld[n][0][3],
					m_Hitmatrix[i].pBoneToWorld[n][1][3],
					m_Hitmatrix[i].pBoneToWorld[n][2][3]
				);
			};

			if (!WorldToScreen(BonePos(n), bone1) || !WorldToScreen(BonePos(bone->parent), bone2)) {
				continue;
			}

			Render::Engine::Line(bone1, bone2, g_Vars.esp.hitskeleton_color.ToRegularColor().OverrideAlpha(220 * m_Hitmatrix[i].m_flAlpha, true));
		}
	}
}

void CEsp::Offscreen() {
	C_CSPlayer* LocalPlayer = C_CSPlayer::GetLocalPlayer();

	if (!LocalPlayer)
		return;

	QAngle viewangles;
	int width = Render::GetScreenSize().x, height = Render::GetScreenSize().y;

	Interfaces::m_pEngine.Xor()->GetViewAngles(viewangles);

	auto rotate_arrow = [](std::array< Vector2D, 3 >& points, float rotation) {
		const auto points_center = (points.at(0) + points.at(1) + points.at(2)) / 3;
		for (auto& point : points) {
			point -= points_center;

			const auto temp_x = point.x;
			const auto temp_y = point.y;

			const auto theta = DEG2RAD(rotation);
			const auto c = cos(theta);
			const auto s = sin(theta);

			point.x = temp_x * c - temp_y * s;
			point.y = temp_x * s + temp_y * c;

			point += points_center;
		}
	};

	auto m_width = Render::GetScreenSize().x, m_height = Render::GetScreenSize().y;
	for (auto i = 1; i <= Interfaces::m_pGlobalVars->maxClients; i++) {
		auto entity = C_CSPlayer::GetPlayerByIndex(i);
		if (!entity || !entity->IsPlayer() || entity == LocalPlayer || entity->IsDormant() || entity->IsDead()
			|| (g_Vars.esp.team_check && entity->m_iTeamNum() == LocalPlayer->m_iTeamNum()))
			continue;

		// get the player's center screen position.
		auto target_pos = entity->GetAbsOrigin();
		Vector2D screen_pos;
		auto is_on_screen = WorldToScreen(target_pos, screen_pos);

		// give some extra room for screen position to be off screen.
		auto leeway_x = m_width / 18.f;
		auto leeway_y = m_height / 18.f;

		if (!is_on_screen
			|| screen_pos.x < -leeway_x
			|| screen_pos.x >(m_width + leeway_x)
			|| screen_pos.y < -leeway_y
			|| screen_pos.y >(m_height + leeway_y)) {

			const auto screen_center = Vector2D(width * .5f, height * .5f);
			const auto angle_yaw_rad = DEG2RAD(viewangles.y - Math::CalcAngle(LocalPlayer->GetEyePosition(), entity->GetAbsOrigin(), true).y - 90);

			float radius = std::max(10.f, g_Vars.esp.offscren_distance);
			float size = std::max(5.f, g_Vars.esp.offscren_size);

			const auto new_point_x = screen_center.x + ((((width - (size * 3)) * .5f) * (radius / 100.0f)) * cos(angle_yaw_rad)) + (int)(6.0f * (((float)size - 4.f) / 16.0f));
			const auto new_point_y = screen_center.y + ((((height - (size * 3)) * .5f) * (radius / 100.0f)) * sin(angle_yaw_rad));

			std::array< Vector2D, 3 >points{ Vector2D(new_point_x - size, new_point_y - size),
				Vector2D(new_point_x + size, new_point_y),
				Vector2D(new_point_x - size, new_point_y + size) };

			rotate_arrow(points, viewangles.y - Math::CalcAngle(LocalPlayer->GetEyePosition(), entity->GetAbsOrigin(), true).y - 90);

			std::array< Vertex_t, 3 >vertices{ Vertex_t(points.at(0)), Vertex_t(points.at(1)), Vertex_t(points.at(2)) };
			static int texture_id = Interfaces::m_pSurface.Xor()->CreateNewTextureID(true);
			static unsigned char buf[4] = { 255, 255, 255, 255 };

			Color clr = g_Vars.esp.offscreen_color.ToRegularColor();

			// fill
			Interfaces::m_pSurface.Xor()->DrawSetColor(clr.r(), clr.g(), clr.b(), (clr.a() * 0.4f) * GetAlpha(i));
			Interfaces::m_pSurface.Xor()->DrawSetTexture(texture_id);
			Interfaces::m_pSurface.Xor()->DrawTexturedPolygon(3, vertices.data());

			// outline
			Interfaces::m_pSurface.Xor()->DrawSetColor(clr.r(), clr.g(), clr.b(), (clr.a()) * GetAlpha(i));
			Interfaces::m_pSurface.Xor()->DrawSetTexture(texture_id);
			Interfaces::m_pSurface.Xor()->DrawTexturedPolyLine(vertices.data(), 3);
		}
	}
}

void CEsp::OverlayInfo() {
	auto local = C_CSPlayer::GetLocalPlayer();
	if (!local)
		return;

	C_WeaponCSBaseGun* weapon = (C_WeaponCSBaseGun*)local->m_hActiveWeapon().Get();
	if (!weapon)
		return;

	if (g_Vars.esp.offscren_enabled)
		Offscreen();

	PenetrateCrosshair(Render::GetScreenSize() / 2);
}

bool CEsp::GetBBox(C_BaseEntity* entity, Vector2D screen_points[], BBox_t& outRect) {
	BBox_t rect{ };
	auto collideable = entity->GetCollideable();

	if (!collideable)
		return false;

	if (entity->IsPlayer()) {
		Vector origin, mins, maxs;
		Vector2D bottom, top;

		// get interpolated origin.
		origin = entity->GetAbsOrigin();

		// get hitbox bounds.
		entity->ComputeHitboxSurroundingBox(&mins, &maxs);

		// correct x and y coordinates.
		mins = { origin.x, origin.y, mins.z };
		maxs = { origin.x, origin.y, maxs.z + 8.f };

		if (!WorldToScreen(mins, bottom) || !WorldToScreen(maxs, top))
			return false;

		// state the box bounds
		outRect.h = bottom.y - top.y;
		outRect.w = outRect.h / 2.f;
		outRect.x = bottom.x - (outRect.w / 2.f);
		outRect.y = bottom.y - outRect.h;

		return true;
	}
	else {
		auto min = collideable->OBBMins();
		auto max = collideable->OBBMaxs();

		const matrix3x4_t& trans = entity->m_rgflCoordinateFrame();

		Vector points[] =
		{
			Vector(min.x, min.y, min.z),
			Vector(min.x, max.y, min.z),
			Vector(max.x, max.y, min.z),
			Vector(max.x, min.y, min.z),
			Vector(max.x, max.y, max.z),
			Vector(min.x, max.y, max.z),
			Vector(min.x, min.y, max.z),
			Vector(max.x, min.y, max.z)
		};

		for (int i = 0; i < 8; i++) {
			points[i] = points[i].Transform(trans);
		}

		for (int i = 0; i < 8; i++)
			if (!WorldToScreen(points[i], screen_points[i]))
				return false;

		auto left = screen_points[0].x;
		auto top = screen_points[0].y;
		auto right = screen_points[0].x;
		auto bottom = screen_points[0].y;

		for (int i = 1; i < 8; i++) {
			if (left > screen_points[i].x)
				left = screen_points[i].x;
			if (top < screen_points[i].y)
				top = screen_points[i].y;
			if (right < screen_points[i].x)
				right = screen_points[i].x;
			if (bottom > screen_points[i].y)
				bottom = screen_points[i].y;
		}

		left = std::ceilf(left);
		top = std::ceilf(top);
		right = std::floorf(right);
		bottom = std::floorf(bottom);

		// state the box bounds.
		outRect.x = left;
		outRect.y = top;
		outRect.w = right - left;
		outRect.h = (bottom - top);
		return true;
	}

	return false;
}

Encrypted_t<IEsp> IEsp::Get() {
	static CEsp instance;
	return &instance;
}
```

`CSGO SDK/Features/Visuals/ESP.hpp`:

```hpp
#pragma once
#pragma once
#include "../../SDK/sdk.hpp"

class C_Window {
public:
	Vector2D pos;
	Vector2D size;
	Vector2D mouse_pos;
	int id;

	C_Window() { }
	C_Window(Vector2D _pos, Vector2D _size, int _id)
		: pos(_pos), size(_size), id(_id) {
	}

	bool IsInBox(Vector2D m_MousePos, Vector2D box_pos, Vector2D box_size) {
		return (
			m_MousePos.x > box_pos.x &&
			m_MousePos.y > box_pos.y &&
			m_MousePos.x < box_pos.x + box_size.x &&
			m_MousePos.y < box_pos.y + box_size.y
			);
	}

	void Drag() {
		auto current_mouse_pos = InputSys::Get()->GetMousePosition();
		if (g_Vars.globals.menuOpen && !GUI::ctx->dragging
			&& InputSys::Get()->IsKeyDown(VirtualKeys::LeftButton)
			&& (IsInBox(current_mouse_pos, pos, size) || IsInBox(mouse_pos, pos, size))) {
			pos += current_mouse_pos - mouse_pos;

			switch (id) {
			case 0:
				g_Vars.esp.keybind_window_x = pos.x;
				g_Vars.esp.keybind_window_y = pos.y;
				g_Vars.globals.m_bDraggingKeyBind = true;
				break;
			case 1:
				g_Vars.esp.spec_window_x = pos.x;
				g_Vars.esp.spec_window_y = pos.y;
				g_Vars.globals.m_bDraggingSpecList = true;
				break;
			}
		}
		else {
			switch (id) {
			case 0:
				g_Vars.globals.m_bDraggingKeyBind = false;
				break;
			case 1:
				g_Vars.globals.m_bDraggingSpecList = false;
				break;
			}
		}

		switch (id) {
		case 0:
			pos.x = g_Vars.esp.keybind_window_x;
			pos.y = g_Vars.esp.keybind_window_y;
			break;
		case 1:
			pos.x = g_Vars.esp.spec_window_x;
			pos.y = g_Vars.esp.spec_window_y;
			break;
		}

		mouse_pos = InputSys::Get()->GetMousePosition();
	}
};


class __declspec(novtable) IEsp : public NonCopyable {
public:
	static Encrypted_t<IEsp> Get();
	virtual void DrawAntiAimIndicator() = NULL;
	virtual void Main() = NULL;
	virtual void SetAlpha(int idx) = NULL;
	virtual float GetAlpha(int idx) = NULL;
	virtual void AddSkeletonMatrix(C_CSPlayer* player, matrix3x4_t* bones) = NULL;
protected:
	IEsp() { };
	virtual ~IEsp() {
	}
};

```

`CSGO SDK/Features/Visuals/EventLogger.cpp`:

```cpp
#include "EventLogger.hpp"
#include "../../source.hpp"
#include "../../Renderer/Render.hpp"

class NotifyText {
public:
	std::string m_text;
	Color		m_color;
	float		m_time;

public:
	__forceinline NotifyText(const std::string& text, Color color, float time) : m_text{ text }, m_color{ color }, m_time{ time } {}
};

std::deque< std::shared_ptr< NotifyText > > m_notify_text;

class CLogger : public ILoggerEvent {
public:
	void Main() override;

	void PushEvent(std::string msg, FloatColor clr, bool visualise = true, std::string prefix = "") override;

private:
};

Encrypted_t<ILoggerEvent> ILoggerEvent::Get() {
	static CLogger instance;
	return &instance;
}

void CLogger::Main() {
	int		x{ 8 }, y{ 5 }, size{ Render::Engine::hud.m_size.m_height + 1 };
	Color	color;
	float	left;

	// update lifetimes.
	for (size_t i{ }; i < m_notify_text.size(); ++i) {
		auto notify = m_notify_text[i];

		notify->m_time -= Interfaces::m_pGlobalVars->frametime;

		if (notify->m_time <= 0.f) {
			m_notify_text.erase(m_notify_text.begin() + i);
			continue;
		}
	}

	// we have nothing to draw.
	if (m_notify_text.empty())
		return;

	// iterate entries.
	for (size_t i{ }; i < m_notify_text.size(); ++i) {
		auto notify = m_notify_text[i];

		if (notify->m_text.find(XorStr("%%%%")) != std::string::npos)
			notify->m_text.erase(notify->m_text.find(XorStr("%")), 3);

		left = notify->m_time;
		color = notify->m_color;

		if (left < .5f) {
			float f = left;
			f = Math::Clamp(f, 0.f, .5f);

			f /= .5f;

			color.RGBA[3] = (int)(f * 255.f);

			if (i == 0 && f < 0.2f)
				y -= size * (1.f - f / 0.2f);
		}

		else
			color.RGBA[3] = 255;

		Render::Engine::hud.string(x, y, color, notify->m_text);
		y += size;
	}

	// clear more than 10 entries.
	if (m_notify_text.size() > 10)
		m_notify_text.pop_front();
}

void CLogger::PushEvent(std::string msg, FloatColor clr, bool visualise, std::string prefix) {
	if (visualise) {
		m_notify_text.push_back(std::make_shared< NotifyText >(std::string(XorStr("")).append(prefix.data()).append(XorStr("")).append(msg), clr.ToRegularColor(), 8.f));
	}

	Color accent = g_Vars.menu.ascent.ToRegularColor();
	Color accent2 = g_Vars.misc.log_color.ToRegularColor();

	if (!g_Vars.misc.print_color)
		Interfaces::m_pCvar->ConsoleColorPrintf(accent, XorStr("[Autism] "));
	else
		Interfaces::m_pCvar->ConsoleColorPrintf(accent2, XorStr("[Autism] "));

	if (!prefix.empty()) {
		Interfaces::m_pCvar->ConsoleColorPrintf(g_Vars.menu.ascent.ToRegularColor(), std::string(XorStr("")).append(prefix.data()).append(XorStr("")).data());
	}

	Interfaces::m_pCvar->ConsoleColorPrintf(clr.ToRegularColor(), std::string(msg + XorStr("\n")).c_str());
}

```

`CSGO SDK/Features/Visuals/EventLogger.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

class __declspec(novtable) ILoggerEvent : NonCopyable {
public:
	static Encrypted_t<ILoggerEvent> Get();
	virtual void Main() = NULL;
	virtual void PushEvent(std::string msg, FloatColor clr, bool visualise = true, std::string prefix = "") = NULL;
protected:
	ILoggerEvent() { };
	virtual ~ILoggerEvent() { };
};

```

`CSGO SDK/Features/Visuals/ExtendedEsp.cpp`:

```cpp
#include "ExtendedEsp.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../source.hpp"
#include "ESP.hpp"

class CExtendedSound : public IExtendedEsp {
public:
	// Call before and after ESP.
	void Start() override;
	void Finish() override;

private:
	void AdjustPlayerBegin(C_CSPlayer* player);
	void AdjustPlayer(C_CSPlayer* player);
	void AdjustPlayerFinish();
	void SetupAdjustPlayer(C_CSPlayer* player, SndInfo_t& sound);

	bool ValidSound(SndInfo_t& sound);

	struct SoundPlayer {
		void Override(SndInfo_t& sound) {
			m_iIndex = sound.m_nSoundSource;
			//m_vecOrigin = *sound.m_pOrigin;
			m_iReceiveTime = GetTickCount();
		}

		int m_iIndex = 0;
		int m_iReceiveTime = 0;
		Vector m_vecOrigin = Vector(0, 0, 0);
		Vector m_vecLastOrigin = Vector(0, 0, 0);

		/* Restore data */
		int m_nFlags = 0;
		int playerindex = 0;
		Vector m_vecAbsOrigin = Vector(0, 0, 0);
		bool m_bDormant = false;
	} m_cSoundPlayers[65];

	CUtlVector<SndInfo_t> m_utlvecSoundBuffer;
	std::vector<SoundPlayer> m_arRestorePlayers;
};

Encrypted_t<IExtendedEsp> IExtendedEsp::Get() {
	static CExtendedSound instance;
	return &instance;
}

void CExtendedSound::Start() {
	if (!g_Vars.esp.fade_esp)
		return;

	CUtlVector<SndInfo_t> m_utlCurSoundList;
	Interfaces::m_pEngineSound->GetActiveSounds(m_utlCurSoundList);

	// No active sounds.
	if (!m_utlCurSoundList.Count())
		return;

	C_CSPlayer* LocalPlayer = C_CSPlayer::GetLocalPlayer();

	static auto flSpawnTime = 0.f;

	if (!LocalPlayer)
		return;

	if (flSpawnTime != LocalPlayer->m_flSpawnTime()) {
		flSpawnTime = LocalPlayer->m_flSpawnTime();
		return;
	}

	// Accumulate sounds for esp correction
	for (int iter = 0; iter < m_utlCurSoundList.Count(); iter++) {
		SndInfo_t& sound = m_utlCurSoundList[iter];
		if (sound.m_nSoundSource == 0 || // World
			sound.m_nSoundSource > 64)   // Most likely invalid
			continue;

		C_CSPlayer* player = C_CSPlayer::GetPlayerByIndex(sound.m_nSoundSource);

		if (!player || !sound.m_pOrigin || !player->IsPlayer() || player == LocalPlayer || player->IsTeammate(LocalPlayer) || sound.m_pOrigin->IsZero())
			continue;

		if (!ValidSound(sound))
			continue;

		SetupAdjustPlayer(player, sound);

		m_cSoundPlayers[sound.m_nSoundSource].Override(sound);
	}

	for (int iter = 1; iter < 64; ++iter) {
		C_CSPlayer* player = C_CSPlayer::GetPlayerByIndex(iter);
		if (!player || !player->IsPlayer() || player->IsDead())
			continue;

		AdjustPlayerBegin(player);

		if (!player->IsDormant()) {
			for (auto& player : m_arRestorePlayers) {
				if (player.playerindex == iter) {
					player.m_bDormant = false;
				}
			}
		}
		else {
			AdjustPlayer(player);
		}
	}

	m_utlvecSoundBuffer = m_utlCurSoundList;
}

void CExtendedSound::Finish() {
	if (!g_Vars.esp.fade_esp)
		return;

	// Do any finishing code here. If we add smtn like sonar radar this will be useful.
	AdjustPlayerFinish();
}

void CExtendedSound::AdjustPlayerBegin(C_CSPlayer* player) {
	if (!player)
		return;

	// Adjusts player's origin and other vars so we can show full-ish esp.
	constexpr int EXPIRE_DURATION = 450; // miliseconds-ish?
	auto& sound_player = m_cSoundPlayers[player->EntIndex()];
	bool sound_expired = GetTickCount() - sound_player.m_iReceiveTime > EXPIRE_DURATION;
	if (sound_expired)
		return;

	SoundPlayer current_player;
	current_player.playerindex = player->m_entIndex;
	current_player.m_bDormant = true;
	current_player.m_nFlags = player->m_fFlags();
	current_player.m_vecOrigin = player->m_vecOrigin();
	current_player.m_vecAbsOrigin = player->GetAbsOrigin();

	m_arRestorePlayers.emplace_back(current_player);
}

void CExtendedSound::AdjustPlayer(C_CSPlayer* player)
{
	if (!player)
		return;

	// Adjusts player's origin and other vars so we can show full-ish esp.
	constexpr int EXPIRE_DURATION = 450; // miliseconds-ish?
	auto& sound_player = m_cSoundPlayers[player->EntIndex()];
	bool sound_expired = GetTickCount() - sound_player.m_iReceiveTime > EXPIRE_DURATION;
	if (sound_expired)
		return;

	if (!sound_expired)
		*(bool*)((uintptr_t)player + 0xED) = false; // dormant check

	//printf( "player %i seted\n", sound_player.m_iIndex );
	player->m_fFlags() = sound_player.m_nFlags;
	player->m_vecOrigin() = sound_player.m_vecOrigin;
	player->SetAbsOrigin(sound_player.m_vecOrigin);
}

void CExtendedSound::AdjustPlayerFinish() {
	// Restore and clear saved players for next loop.
	for (auto& RestorePlayer : m_arRestorePlayers) {
		auto player = C_CSPlayer::GetPlayerByIndex(RestorePlayer.playerindex);
		if (!player)
			continue;

		//printf( "player %i restored\n", player->entindex( ) );
	   //  player->m_fFlags( ) = RestorePlayer.m_nFlags;
	   //  player->m_vecOrigin( ) = RestorePlayer.m_vecOrigin;
	   //  player->SetAbsOrigin( RestorePlayer.m_vecAbsOrigin );
		*(bool*)((uintptr_t)player + 0xED) = RestorePlayer.m_bDormant; // dormant check
	}

	m_arRestorePlayers.clear();
}

void CExtendedSound::SetupAdjustPlayer(C_CSPlayer* player, SndInfo_t& sound) {
	if (!player)
		return;

	Vector src3D, dst3D;
	CGameTrace tr;
	Ray_t ray;
	CTraceFilter filter;

	filter.pSkip = player;
	src3D = (*sound.m_pOrigin) + Vector(0, 0, 1); // So they dont dig into ground incase shit happens /shrug
	dst3D = src3D - Vector(0, 0, 100);
	ray.Init(src3D, dst3D);

	Interfaces::m_pEngineTrace->TraceRay(ray, MASK_PLAYERSOLID, &filter, &tr);

	// step = (tr.fraction < 0.20)
	// shot = (tr.fraction > 0.20)
	// stand = (tr.fraction > 0.50)
	// crouch = (tr.fraction < 0.50)

	/* Corrects origin and important flags. */

	// Player stuck, idk how this happened
	if (tr.allsolid) {
		m_cSoundPlayers[sound.m_nSoundSource].m_iReceiveTime = -1;
	}

	//*sound.m_pOrigin = (tr.fraction < 0.97 ? tr.endpos : *sound.m_pOrigin);
	m_cSoundPlayers[sound.m_nSoundSource].m_vecOrigin = (tr.fraction < 0.97 ? tr.endpos : *sound.m_pOrigin);
	m_cSoundPlayers[sound.m_nSoundSource].m_nFlags = player->m_fFlags();
	m_cSoundPlayers[sound.m_nSoundSource].m_nFlags |= (tr.fraction < 0.50f ? FL_DUCKING : 0) | (tr.fraction != 1 ? FL_ONGROUND : 0);   // Turn flags on
	m_cSoundPlayers[sound.m_nSoundSource].m_nFlags &= (tr.fraction > 0.50f ? ~FL_DUCKING : 0) | (tr.fraction == 1 ? ~FL_ONGROUND : 0); // Turn flags off
}

bool CExtendedSound::ValidSound(SndInfo_t& sound) {
	// Use only server dispatched sounds.
	//if (!sound.m_bFromServer)
	//   return false;

	//  We don't want the sound to keep following client's predicted origin.
	for (int iter = 0; iter < m_utlvecSoundBuffer.Count(); iter++) {
		const SndInfo_t& cached_sound = m_utlvecSoundBuffer[iter];
		if (cached_sound.m_nGuid == sound.m_nGuid) {
			return false;
		}
	}

	return true;
}

```

`CSGO SDK/Features/Visuals/ExtendedEsp.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

class __declspec(novtable) IExtendedEsp : public NonCopyable {
public:
	static Encrypted_t<IExtendedEsp> Get();
	virtual void Start() = NULL;
	virtual void Finish() = NULL;
protected:
	IExtendedEsp() {

	}

	virtual ~IExtendedEsp() {

	}
};
```

`CSGO SDK/Features/Visuals/Glow.cpp`:

```cpp
#include "Glow.hpp"
#include "../../source.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Classes/weapon.hpp"

class C_GlowOutline : public GlowOutline {
public:
	virtual void Render();
	virtual void Shutdown();

	C_GlowOutline() { };
	virtual ~C_GlowOutline() { };
};

GlowOutline* GlowOutline::Get() {
	static C_GlowOutline glow;
	return &glow;
}

void C_GlowOutline::Render() {
	static bool weapon_enabled = false;

	auto pLocal = C_CSPlayer::GetLocalPlayer();
	if (!pLocal)
		return;

	if (!pLocal || !Interfaces::m_pEngine->IsInGame())
		return;

	auto players = g_Vars.esp.glow_local || g_Vars.esp.glow_enemy || g_Vars.esp.glow_team;
	if (!players && !g_Vars.esp.glow_grenade && !g_Vars.esp.glow_weapons)
		return;

	for (auto i = 0; i < Interfaces::m_pGlowObjManager->m_GlowObjectDefinitions.m_Size; i++) {
		auto& glowObject = Interfaces::m_pGlowObjManager->m_GlowObjectDefinitions.m_Memory.m_pMemory[i];
		auto entity = reinterpret_cast<C_CSPlayer*>(glowObject.m_pEntity);

		if (!&glowObject)
			continue;

		if (glowObject.IsUnused())
			continue;

		if (!entity || entity->IsDormant() || entity->IsDead())
			continue;

		auto class_id = entity->GetClientClass()->m_ClassID;
		auto color = FloatColor{ };

		switch (class_id) {
		case CCSPlayer:
		{
			bool enemy = entity->m_iTeamNum() != pLocal->m_iTeamNum();

			bool team = entity->m_iTeamNum() == pLocal->m_iTeamNum() && pLocal != entity;

			if (!players || entity->IsDead())
				continue;

			if ((team && !g_Vars.esp.glow_team) || (enemy && !g_Vars.esp.glow_enemy) || (entity->EntIndex() == pLocal->EntIndex() && !g_Vars.esp.glow_local))
				continue;

			if (team)
				color = g_Vars.esp.glow_team_color;
			else if (enemy)
				color = g_Vars.esp.glow_enemy_color;
			else
				color = g_Vars.esp.glow_local_color;

			break;
		}
		case CMolotovProjectile:
		case CSmokeGrenadeProjectile:
		case CDecoyProjectile:
		case CBaseCSGrenadeProjectile:
		{
			if (g_Vars.esp.glow_grenade) {
				glowObject.m_bRenderWhenOccluded = false;
				glowObject.m_bRenderWhenUnoccluded = false;
				glowObject.m_vGlowColor.w = 0.0f;
				color = g_Vars.esp.glow_grenade_color;
			}
		}
		default:
		{
			if (entity->IsWeapon()) {
				if (!g_Vars.esp.glow_weapons) {
					if (weapon_enabled) {
						glowObject.m_bRenderWhenOccluded = false;
						glowObject.m_bRenderWhenUnoccluded = false;
						glowObject.m_vGlowColor.w = 0.0f;
					}
					continue;
				}
				weapon_enabled = true;
				color = g_Vars.esp.glow_weapons_color;
			}
		}
		}
		glowObject.m_nGlowStyle = g_Vars.esp.glow_type;
		glowObject.m_vGlowColor = Vector4D(color.r, color.g, color.b, color.a);
		glowObject.m_bRenderWhenOccluded = true;
		glowObject.m_bRenderWhenUnoccluded = false;
	}


	if (weapon_enabled && !g_Vars.esp.glow_weapons) {
		weapon_enabled = false;
	}
}

void C_GlowOutline::Shutdown() {
	// Remove glow from all entities
	for (auto i = 0; i < Interfaces::m_pGlowObjManager->m_GlowObjectDefinitions.m_Size; i++) {
		auto& glowObject = Interfaces::m_pGlowObjManager->m_GlowObjectDefinitions.m_Memory.m_pMemory[i];
		auto entity = reinterpret_cast<C_BasePlayer*>(glowObject.m_pEntity);

		if (glowObject.IsUnused())
			continue;

		if (!entity || entity->IsDormant())
			continue;

		glowObject.m_vGlowColor.w = 0.0f;
	}
}
```

`CSGO SDK/Features/Visuals/Glow.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

class __declspec(novtable) GlowOutline : public NonCopyable {
public:
	static GlowOutline* Get();
	virtual void Render() = 0;
	virtual void Shutdown() = 0;

protected:
	GlowOutline() { };
	virtual ~GlowOutline() { };
};
```

`CSGO SDK/Features/Visuals/GrenadePrediction.cpp`:

```cpp
#include "GrenadePrediction.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Valve/CBaseHandle.hpp"
#include "../../SDK/Classes/entity.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "../../Renderer/Render.hpp"
#include "../Rage/Autowall.h"

class CGrenadePrediction : public IGrenadePrediction {
public:
	void View() override;
	void Paint() override;
private:
	void Setup(C_BasePlayer* pl, Vector& vecSrc, Vector& vecThrow, const QAngle& angEyeAngles);
	void Simulate(QAngle& Angles, C_BasePlayer* pLocal);
	int Step(Vector& vecSrc, Vector& vecThrow, int tick, float interval);
	bool CheckDetonate(const Vector& vecThrow, const CGameTrace& tr, int tick, float interval);
	void TraceHull(Vector& src, Vector& end, CGameTrace& tr);
	void AddGravityMove(Vector& move, Vector& vel, float frametime, bool onground);
	void PushEntity(Vector& src, const Vector& move, CGameTrace& tr);
	void ResolveFlyCollisionCustom(CGameTrace& tr, Vector& vecVelocity, float interval);
	int PhysicsClipVelocity(const Vector& in, const Vector& normal, Vector& out, float overbounce);

	int wpn_index = 0;
	float flThrowVelocity = 0.f;
	float flThrowStrength = 0.f;
	std::vector<Vector> vecPath;
	std::vector<std::pair<Vector, Color>> vecBounces;
	std::vector< C_BaseEntity* > vecIgnoredEntities;
};

class CPredTraceFilter : public ITraceFilter {
public:
	CPredTraceFilter() = default;

	bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/) {
		if (!pEntityHandle || entities.empty())
			return false;

		auto it = std::find(entities.begin(), entities.end(), pEntityHandle);
		if (it != entities.end())
			return false;

		ClientClass* pEntCC = ((IClientEntity*)pEntityHandle)->GetClientClass();
		if (pEntCC && strcmp(ccIgnore, "")) {
			if (pEntCC->m_pNetworkName == ccIgnore)
				return false;
		}

		return true;
	}

	virtual TraceType GetTraceType() const { return TraceType::TRACE_EVERYTHING; }

	inline void SetIgnoreClass(const char* Class) { ccIgnore = Class; }

	std::vector< C_BaseEntity* > entities;
	const char* ccIgnore = "";
};

IGrenadePrediction* IGrenadePrediction::Get() {
	static CGrenadePrediction instance;
	return &instance;
}

void CGrenadePrediction::View() {
	if (!g_Vars.esp.NadePred)
		return;

	C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer();

	if (!pLocal || pLocal->IsDead())
		return;

	auto pWeapon = (C_WeaponCSBaseGun*)pLocal->m_hActiveWeapon().Get();
	if (!pWeapon)
		return;

	auto pWeaponData = pWeapon->GetCSWeaponData().Xor();

	if (!pWeaponData)
		return;
	flThrowStrength = 0.f;
	flThrowVelocity = 0.f;

	if (pWeaponData->m_iWeaponType == WEAPONTYPE_GRENADE && pWeapon->m_fThrowTime() <= 0) {
		QAngle angThrow;
		Interfaces::m_pEngine->GetViewAngles(angThrow);

		flThrowStrength = pWeapon->m_flThrowStrength();
		flThrowVelocity = pWeaponData->m_flThrowVelocity;

		wpn_index = pWeapon->m_iItemDefinitionIndex();
		Simulate(angThrow, pLocal);
	}
	else {
		wpn_index = -1;
	}
}

inline float CSGO_Armor(float flDamage, int ArmorValue) {
	float flArmorRatio = 0.5f;
	float flArmorBonus = 0.5f;
	if (ArmorValue > 0) {
		float flNew = flDamage * flArmorRatio;
		float flArmor = (flDamage - flNew) * flArmorBonus;

		if (flArmor > static_cast<float>(ArmorValue)) {
			flArmor = static_cast<float>(ArmorValue) * (1.f / flArmorBonus);
			flNew = flDamage - flArmor;
		}

		flDamage = flNew;
	}
	return flDamage;
}


void CGrenadePrediction::Paint() {
	if (!g_Vars.esp.NadePred)
		return;

	C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer();

	if (!pLocal || pLocal->IsDead())
		return;

	auto pWeapon = (C_WeaponCSBaseGun*)pLocal->m_hActiveWeapon().Get();
	if (!pWeapon)
		return;

	auto pWeaponData = pWeapon->GetCSWeaponData().Xor();

	if (!pWeaponData)
		return;

	static CTraceFilter filter{ };
	CGameTrace	                   trace;
	std::pair< float, C_CSPlayer* >    target{ 0.f, nullptr };

	// setup trace filter for later.
	filter.pSkip = (pLocal);

	if ((wpn_index) && vecPath.size() > 1 && pWeaponData->m_iWeaponType == WEAPONTYPE_GRENADE && pWeapon->m_fThrowTime() <= 0) {
		Vector2D ab, cd;
		Vector prev = vecPath[0];

		// iterate all players.
		for (int i{ 1 }; i <= Interfaces::m_pGlobalVars->maxClients; ++i) {
			C_CSPlayer* player = (C_CSPlayer*)Interfaces::m_pEntList->GetClientEntity(i);
			if (!player)
				continue;

			if (player->IsDead() || player->m_bGunGameImmunity() || player->IsTeammate(pLocal))
				continue;

			// get center of mass for player.
			Vector center = player->WorldSpaceCenter();

			// get delta between center of mass and final nade pos.
			Vector delta = center - vecPath.back();

			if (wpn_index == WEAPON_HEGRENADE) {
				// is within damage radius?
				if (delta.Length() > 475.f)
					continue;

				// check if our path was obstructed by anything using a trace.
				Interfaces::m_pEngineTrace->TraceRay(Ray_t(vecPath.back(), center), MASK_SHOT, (ITraceFilter*)&filter, &trace);

				// something went wrong here.
				if (!trace.hit_entity || trace.hit_entity != player)
					continue;

				static float a = 105.0f;
				static float b = 25.0f;
				static float c = 140.0f;

				float d = ((((player->m_vecOrigin()) - vecPath.back()).Length() - b) / c);
				float flDamage = a * exp(-d * d);

				auto damage = std::max(static_cast<int>(ceilf(CSGO_Armor(flDamage, player->m_ArmorValue()))), 0);

				// better target?
				if (damage > target.first) {
					target.first = damage;
					target.second = player;
				}
			}
			else if (wpn_index == WEAPON_MOLOTOV || wpn_index == WEAPON_FIREBOMB) {
				// is within damage radius?
				if (delta.Length() > 131.f)
					continue;

				// hardcoded bullshit /shrug
				target.first = 0.f;
				target.second = player;
			}
		}

		if (wpn_index == WEAPON_MOLOTOV || wpn_index == WEAPON_FIREBOMB || wpn_index == WEAPON_HEGRENADE || wpn_index == WEAPON_SMOKE) {
			auto color = Color(255, 255, 255, 120);

			if (target.second) {
				if (target.first >= target.second->m_iHealth()) {
					color = Color(173, 208, 37, 120);
				}
			}

			Render::Engine::WorldCircle(*vecPath.rbegin(), 131.f, color, Color(0, 0, 0, 0));
		}

		// we have a target for damage.
		if (target.second) {
			Vector2D screen;

			g_Vars.globals.bReleaseGrenade = target.first >= target.second->m_iHealth();

			// replace the last bounce with green.
			if (!vecBounces.empty())
				vecBounces.back().second = { 0, 255, 0, 255 };

			if (WorldToScreen(vecBounces.back().first, screen)) {
				if (wpn_index == WEAPON_MOLOTOV || wpn_index == WEAPON_FIREBOMB) {
					Render::Engine::segoe.string(screen.x, screen.y + 5,
						Color(255, 255, 255, 180),
						std::string(XorStr("Reach")), Render::Engine::ALIGN_CENTER);
				}
				else {
					Render::Engine::segoe.string(screen.x, screen.y + 5,
						target.first >= target.second->m_iHealth() ? Color(173, 208, 37, 180) : Color(255, 255, 255, 180),
						std::string(XorStr("-") + std::to_string((int)target.first)), Render::Engine::ALIGN_CENTER);
				}
			}
		}

		// path.
		for (auto it = vecPath.begin(), end = vecPath.end(); it != end; ++it) {
			if (WorldToScreen(prev, ab) && WorldToScreen(*it, cd)) {
				Render::Engine::Line(ab, cd, g_Vars.esp.nade_pred_color.ToRegularColor());

				// hmm?
				Render::Engine::Line(ab + Vector2D(1, 0), cd + Vector2D(1, 0), g_Vars.esp.nade_pred_color.ToRegularColor());
			}

			prev = *it;
		}

		Vector2D temp;
		// bounces
		/*for( auto it = vecBounces.begin( ), end = vecBounces.end( ); it != end; ++it ) {
			if( WorldToScreen( it->first, temp ) ) {
				Render::Engine::CircleFilled( temp_point.x, temp_point.y, 2, 4, it->second );
			}
		}*/

		// last bounce
		if (WorldToScreen(vecBounces.rbegin()->first, temp)) {
			Render::Engine::CircleFilled(temp.x, temp.y, 2, 4, vecBounces.rbegin()->second);
		}
	}
}

// Returns A + (B-A)*flPercent.
	// float Lerp( float flPercent, float A, float B );
template <class T>
__forceinline T Lerp(float flPercent, T const& A, T const& B)
{
	return A + (B - A) * flPercent;
}

void CGrenadePrediction::Setup(C_BasePlayer* pl, Vector& vecSrc, Vector& vecThrow, const QAngle& angEyeAngles) {
	if (!pl)
		return;

	QAngle angThrow = angEyeAngles;
	float pitch = angThrow.pitch;

	if (pitch <= 90.0f) {
		if (pitch < -90.0f) {
			pitch += 360.0f;
		}
	}
	else {
		pitch -= 360.0f;
	}
	float a = pitch - (90.0f - fabs(pitch)) * 10.0f / 90.0f;
	angThrow.pitch = a;

	// get ThrowVelocity from weapon files.
	float flVel = flThrowVelocity * 0.9f;

	// clipped to [ 15, 750 ]
	Math::Clamp(flVel, 15.f, 750.f);

	//clamp the throw strength ranges just to be sure
	float flClampedThrowStrength = flThrowStrength;
	flClampedThrowStrength = std::clamp(flClampedThrowStrength, 0.0f, 1.0f);

	flVel *= Lerp(flClampedThrowStrength, 0.3f, 1.0f);

	Vector vForward, vRight, vUp;
	vForward = angThrow.ToVectors(&vRight, &vUp);

	// danke DucaRii, ich liebe dich
	// dieses code snippet hat mir so sehr geholfen https://cdn.discordapp.com/attachments/755873329151475845/762297342623088640/unknown.png
	// thanks DucaRii, you are the greatest
	// loveeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
	// kochamy DucaRii
	vecSrc = pl->GetAbsOrigin() + pl->m_vecViewOffset();
	float off = Lerp(flClampedThrowStrength, -12.f, 0.0f);
	vecSrc.z += off;

	// Game calls UTIL_TraceHull here with hull and assigns vecSrc tr.endpos
	CGameTrace tr;
	Vector vecDest = vecSrc;
	vecDest = (vecDest + vForward * 22.0f);
	TraceHull(vecSrc, vecDest, tr);

	// After the hull trace it moves 6 units back along vForward
	// vecSrc = tr.endpos - vForward * 6
	Vector vecBack = vForward; vecBack *= 6.0f;
	vecSrc = tr.endpos;
	vecSrc -= vecBack;

	// kurwa fix for anti-aim micromovements (c) NICO
	auto velocity = pl->m_vecVelocity();
	if (velocity.Length2D() > 3.4) {
		vecThrow = velocity;
	}
	else {
		vecThrow.Init();
	}

	vecThrow *= 1.25f;
	vecThrow += (vForward * flVel);
}

void CGrenadePrediction::Simulate(QAngle& Angles, C_BasePlayer* pLocal) {
	if (!pLocal)
		return;

	Vector vecSrc, vecThrow;
	Setup(pLocal, vecSrc, vecThrow, Angles);

	float interval = Interfaces::m_pGlobalVars->interval_per_tick;

	// Log positions 20 times per sec
	int logstep = TIME_TO_TICKS(0.05f);

	int logtimer = 0;

	vecIgnoredEntities.clear();
	vecPath.clear();
	vecBounces.clear();

	vecIgnoredEntities.push_back(pLocal);

	for (unsigned int i = 0; i < 2048; ++i) {
		if (!logtimer)
			vecPath.push_back(vecSrc);

		int s = Step(vecSrc, vecThrow, i, interval);
		if ((s & 1) || vecThrow == Vector(0, 0, 0))
			break;

		// Reset the log timer every logstep OR we bounced
		if ((s & 2) || logtimer >= logstep) logtimer = 0;
		else ++logtimer;

		if (vecThrow == Vector())
			break;
	}

	vecPath.push_back(vecSrc);
}

int CGrenadePrediction::Step(Vector& vecSrc, Vector& vecThrow, int tick, float interval) {
	// Apply gravity
	Vector move;
	AddGravityMove(move, vecThrow, interval, false);

	// Push entity
	CGameTrace tr;
	PushEntity(vecSrc, move, tr);

	int result = 0;
	// Check ending conditions
	if (CheckDetonate(vecThrow, tr, tick, interval)) {
		result |= 1;
	}

	// Resolve collisions
	if (tr.fraction != 1.0f && !tr.plane.normal.IsZero()) {
		result |= 2; // Collision!
		ResolveFlyCollisionCustom(tr, vecThrow, interval);
	}

	if ((result & 1) || vecThrow == Vector(0, 0, 0) || tr.fraction != 1.0f) {
		QAngle angles;
		Math::AngleVectors(angles, (tr.endpos - tr.startpos).Normalized());
		vecBounces.push_back(std::make_pair(tr.endpos, Color(255, 0, 0)));
	}

	// Set new position
	vecSrc = tr.endpos;

	return result;
}

bool CGrenadePrediction::CheckDetonate(const Vector& vecThrow, const CGameTrace& tr, int tick, float interval) {
	// convert current simulation tick to time.
	float time = TICKS_TO_TIME(tick);

	switch (wpn_index) {
	case WEAPON_SMOKE:
		return vecThrow.Length() <= 0.1f && !(tick % TIME_TO_TICKS(0.2f));
	case WEAPON_DECOY:
		return vecThrow.Length() <= 0.2f && !(tick % TIME_TO_TICKS(0.2f));
	case WEAPON_MOLOTOV:
	case WEAPON_FIREBOMB:
		// Detonate when hitting the floor
		if (tr.fraction != 1.0f && (std::cos(DEG2RAD(g_Vars.weapon_molotov_maxdetonateslope->GetFloat())) <= tr.plane.normal.z))
			return true;

		// detonate if we have traveled for too long.
		// checked every 0.1s
		return time >= g_Vars.molotov_throw_detonate_time->GetFloat() && !(tick % TIME_TO_TICKS(0.1f));

	case WEAPON_FLASHBANG:
	case WEAPON_HEGRENADE:
	{
		return time >= 1.5f && !(tick % TIME_TO_TICKS(0.2f));
	}
	default:
		return false;
	}

	return false;
}

void CGrenadePrediction::TraceHull(Vector& src, Vector& end, CGameTrace& tr) {
	// Setup grenade hull
	static const Vector hull[2] = { Vector(-2.0f, -2.0f, -2.0f), Vector(2.0f, 2.0f, 2.0f) };

	CPredTraceFilter filter;
	filter.SetIgnoreClass(XorStr("CBaseCSGrenadeProjectile"));
	filter.entities = vecIgnoredEntities;

	Ray_t ray;
	ray.Init(src, end, hull[0], hull[1]);

	const unsigned int mask = 0x200400B;
	Interfaces::m_pEngineTrace->TraceRay(ray, mask, &filter, &tr);
}

void CGrenadePrediction::AddGravityMove(Vector& move, Vector& vel, float frametime, bool onground) {
	// gravity for grenades.
	float gravity = g_Vars.sv_gravity->GetFloat() * 0.4f;

	// move one tick using current velocity.
	move.x = vel.x * Interfaces::m_pGlobalVars->interval_per_tick;
	move.y = vel.y * Interfaces::m_pGlobalVars->interval_per_tick;

	// apply linear acceleration due to gravity.
	// calculate new z velocity.
	float z = vel.z - (gravity * Interfaces::m_pGlobalVars->interval_per_tick);

	// apply velocity to move, the average of the new and the old.
	move.z = ((vel.z + z) / 2.f) * Interfaces::m_pGlobalVars->interval_per_tick;

	// write back new gravity corrected z-velocity.
	vel.z = z;
}

void CGrenadePrediction::PushEntity(Vector& src, const Vector& move, CGameTrace& tr) {
	Vector vecAbsEnd = src;
	vecAbsEnd += move;

	// Trace through world
	TraceHull(src, vecAbsEnd, tr);
}

void CGrenadePrediction::ResolveFlyCollisionCustom(CGameTrace& tr, Vector& vecVelocity, float interval) {
	// Calculate elasticity
	float flSurfaceElasticity = 1.0;  // Assume all surfaces have the same elasticity

	//Don't bounce off of players with perfect elasticity
	if (tr.hit_entity && ((C_BaseEntity*)tr.hit_entity)->IsPlayer()) {
		flSurfaceElasticity = 0.3f;
	}

	// if its breakable glass and we kill it, don't bounce.
	// give some damage to the glass, and if it breaks, pass
	// through it.
	if (Autowall::IsBreakable((C_BaseEntity*)tr.hit_entity)) {
		auto player = (C_CSPlayer*)tr.hit_entity;

		if (player && player->m_iHealth() <= 10) { // todo: need scale damage and other stuff
			vecIgnoredEntities.push_back((C_BaseEntity*)tr.hit_entity);

			// slow our flight a little bit
			vecVelocity *= 0.4f;
			return;
		}
	}

	float flGrenadeElasticity = 0.45f;
	float flTotalElasticity = flGrenadeElasticity * flSurfaceElasticity;
	if (flTotalElasticity > 0.9f)
		flTotalElasticity = 0.9f;

	if (flTotalElasticity < 0.0f)
		flTotalElasticity = 0.0f;

	// Calculate bounce
	Vector vecAbsVelocity;
	PhysicsClipVelocity(vecVelocity, tr.plane.normal, vecAbsVelocity, 2.0f);
	vecAbsVelocity *= flTotalElasticity;

	// Stop completely once we move too slow
	float flSpeedSqr = vecAbsVelocity.Length2DSquared();
	static const float flMinSpeedSqr = 20.0f * 20.0f; // 30.0f * 30.0f in CSS
	if (flSpeedSqr < flMinSpeedSqr) {
		vecAbsVelocity.x = vecAbsVelocity.y = vecAbsVelocity.z = 0;
	}

	// Stop if on ground
	if (tr.plane.normal.z > 0.7f) {
		vecVelocity = vecAbsVelocity;
		vecAbsVelocity.Mul((1.0f - tr.fraction) * interval);
		PushEntity(tr.endpos, vecAbsVelocity, tr);
	}
	else {
		vecVelocity = vecAbsVelocity;
	}
}

int CGrenadePrediction::PhysicsClipVelocity(const Vector& in, const Vector& normal, Vector& out, float overbounce) {
	static const float STOP_EPSILON = 0.1f;

	float    backoff;
	float    change;
	float    angle;
	int        i, blocked;

	blocked = 0;

	angle = normal[2];

	if (angle > 0) {
		blocked |= 1;        // floor
	}
	if (!angle) {
		blocked |= 2;        // step
	}

	backoff = in.Dot(normal) * overbounce;

	for (i = 0; i < 3; i++) {
		change = normal[i] * backoff;
		out[i] = in[i] - change;
		if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON) {
			out[i] = 0;
		}
	}

	return blocked;
}
```

`CSGO SDK/Features/Visuals/GrenadePrediction.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

class __declspec(novtable) IGrenadePrediction : public NonCopyable {
public:
	static IGrenadePrediction* Get();
	virtual void View() = 0;
	virtual void Paint() = 0;
protected:
	IGrenadePrediction() { };
	virtual ~IGrenadePrediction() {
	}
};
```

`CSGO SDK/Features/Visuals/Hitmarker.cpp`:

```cpp
#include "Hitmarker.hpp"
#include "../../SDK/Classes/player.hpp"
#include <chrono>
#include "../../SDK/CVariables.hpp"
#include "../../Renderer/Render.hpp"

std::vector<Hitmarkers::Hitmarkers_t> Hitmarkers::m_vecWorldHitmarkers{ };

void Hitmarkers::AddScreenHitmarker(Color uColor) {
	m_uMarkerColor = uColor;
	m_flMarkerAlpha = 255.f;
}

void Hitmarkers::AddWorldHitmarker(float flPosX, float flPosY, float flPosZ) {
	if (!Interfaces::m_pPrediction->GetUnpredictedGlobals())
		return;

	Hitmarkers_t info;

	info.m_flAlpha = 1.0f;

	info.m_flPosX = flPosX;
	info.m_flPosY = flPosY;
	info.m_flPosZ = flPosZ;
	info.m_flTime = Interfaces::m_pPrediction->GetUnpredictedGlobals()->curtime;

	m_vecWorldHitmarkers.push_back(info);
}

void Hitmarkers::RenderWorldHitmarkers() {
	if (!Interfaces::m_pPrediction->GetUnpredictedGlobals())
		return;

	if (!Hitmarkers::m_vecWorldHitmarkers.size()) {
		return;
	}

	for (size_t i{ }; i < Hitmarkers::m_vecWorldHitmarkers.size(); ++i) {
		Hitmarkers::Hitmarkers_t& info = Hitmarkers::m_vecWorldHitmarkers[i];
		// bool bLastHitmarker = Hitmarkers::m_vecWorldHitmarkers.begin( ) + 1 == Hitmarkers::m_vecWorldHitmarkers.end( );

		// If the delta between the current time and hurt time is larger than 0.5 seconds then we should erase
		if (Interfaces::m_pPrediction->GetUnpredictedGlobals()->curtime - info.m_flTime > 0.5f) {
			info.m_flAlpha -= (1.0f / 1.0f) * Interfaces::m_pGlobalVars->frametime;
			info.m_flAlpha = std::clamp<float>(info.m_flAlpha, 0.0f, 1.0f);
		}

		Vector2D vecPos;
		if (WorldToScreen(Vector(info.m_flPosX, info.m_flPosY, info.m_flPosZ), vecPos)) {
			constexpr int iLineSize{ 8 };

			if (info.m_flAlpha > 0.0f && g_Vars.esp.visualize_hitmarker_world) {
				auto DrawHitmarker = [&](Vector2D pos, Color clr) {
					Render::DirectX::line(
						Vector2D(static_cast<int>(pos.x - iLineSize), static_cast<int>(pos.y - iLineSize)),
						Vector2D(static_cast<int>(pos.x - (iLineSize / 2)), static_cast<int>(pos.y - (iLineSize / 2))),
						clr.OverrideAlpha(255 * info.m_flAlpha, true));

					Render::DirectX::line(
						Vector2D(static_cast<int>(pos.x - iLineSize), static_cast<int>(pos.y + iLineSize)),
						Vector2D(static_cast<int>(pos.x - (iLineSize / 2)), static_cast<int>(pos.y + (iLineSize / 2))),
						clr.OverrideAlpha(255 * info.m_flAlpha, true));

					Render::DirectX::line(
						Vector2D(static_cast<int>(pos.x + iLineSize), static_cast<int>(pos.y + iLineSize)),
						Vector2D(static_cast<int>(pos.x + (iLineSize / 2)), static_cast<int>(pos.y + (iLineSize / 2))),
						clr.OverrideAlpha(255 * info.m_flAlpha, true));

					Render::DirectX::line(
						Vector2D(static_cast<int>(pos.x + iLineSize), static_cast<int>(pos.y - iLineSize)),
						Vector2D(static_cast<int>(pos.x + (iLineSize / 2)), static_cast<int>(pos.y - (iLineSize / 2))),
						clr.OverrideAlpha(255 * info.m_flAlpha, true));
				};

				DrawHitmarker(vecPos - Vector2D(1, 0), Color::Palette_t::Black().OverrideAlpha(125));
				DrawHitmarker(vecPos - Vector2D(0, 1), Color::Palette_t::Black().OverrideAlpha(125));
				DrawHitmarker(vecPos + Vector2D(1, 0), Color::Palette_t::Black().OverrideAlpha(125));
				DrawHitmarker(vecPos + Vector2D(0, 1), Color::Palette_t::Black().OverrideAlpha(125));

				DrawHitmarker(vecPos, Color::Palette_t::White());
			}
		}

		if (Interfaces::m_pPrediction->GetUnpredictedGlobals()->curtime - info.m_flTime > 2.5f) {
			//printf( "cleared hit at %i (expired)\n", i );
			Hitmarkers::m_vecWorldHitmarkers.erase(Hitmarkers::m_vecWorldHitmarkers.begin() + i);
		}
	}
}

void Hitmarkers::RenderScreenHitmarkers() {
	static Vector2D vCenter = Render::GetScreenSize() * 0.5f;
	static Vector2D vDrawCenter = vCenter;
	if (m_flMarkerAlpha == 255.f) {
		if (!m_bFirstMarker) {
			RandomSeed(Interfaces::m_pGlobalVars->framecount);
			m_flRandomRotation = RandomFloat(-15.f, 15.f);
			m_flRandomEnlargement = RandomFloat(-2.f, 2.f);
			vDrawCenter.x += RandomFloat(-2.f, 2.f);
			vDrawCenter.y += RandomFloat(-2.f, 2.f);
		}
		else {
			m_flRandomRotation = 0.f;
			m_flRandomEnlargement = 0.f;
			vDrawCenter = vCenter;
			m_bFirstMarker = false;
		}
	}

	constexpr float flFadeFactor = 1.0f / 0.2f;
	float flFadeIncrement = (flFadeFactor * Interfaces::m_pGlobalVars->framecount);
	m_flMarkerAlpha -= flFadeFactor;
	m_flRandomEnlargement -= m_flMarkerAlpha / 1020;

	if (m_flMarkerAlpha <= 0) {
		m_bFirstMarker = true;
		m_flMarkerAlpha = 0;
		return;
	}

	auto DrawAngularLine = [](int x, int y, float rad, float length, float gap, Color uColor) -> void {
		const float flRadians = DEG2RAD(rad);
		Render::DirectX::line(
			Vector2D((int)round(x + (sin(flRadians) * length)), (int)round(y + (cos(flRadians) * length))),
			Vector2D((int)round(x + (sin(flRadians) * gap)), (int)round(y + (cos(flRadians) * gap))),
			uColor);
	};

	for (size_t i = 0; i < 4; i++) {
		DrawAngularLine(
			vDrawCenter.x,
			vDrawCenter.y,
			45.f + m_flRandomRotation + (90.f * i),
			18.f + m_flRandomEnlargement,
			24.f + m_flRandomEnlargement,
			Color(m_uMarkerColor.r(), m_uMarkerColor.g(), m_uMarkerColor.b(), m_flMarkerAlpha));
	}
}

void Hitmarkers::RenderHitmarkers() {
	if (g_Vars.esp.visualize_hitmarker_world || g_Vars.esp.visualize_damage) {
		RenderWorldHitmarkers();
	}

	if (g_Vars.esp.vizualize_hitmarker) {
		RenderScreenHitmarkers();
	}
}
```

`CSGO SDK/Features/Visuals/Hitmarker.hpp`:

```hpp
#pragma once
#include "../../SDK/sdk.hpp"

namespace Hitmarkers {
	// for world hitmarkers
	struct Hitmarkers_t {
		float m_flTime = 0.0f;
		float m_flAlpha = 0.0f;
		float m_flDamage = 0.0f;

		float m_flRandomRotation = 0.0f;
		float m_flRandomEnlargement = 0.0f;

		Color m_uColor = { };

		float m_flPosX = std::numeric_limits<float>::min();
		float m_flPosY = std::numeric_limits<float>::min();
		float m_flPosZ = std::numeric_limits<float>::min();
	};
	extern std::vector<Hitmarkers_t> m_vecWorldHitmarkers;


	inline std::pair<Color, int> m_nLastDamageData;

	void AddWorldHitmarker(float flPosX = -1.f, float flPosY = -1.f, float flPosZ = -1.f);

	// for screen hitmarkers
	inline float m_flMarkerAlpha;
	inline float m_flRandomRotation;
	inline float m_flRandomEnlargement;
	inline bool m_bFirstMarker;
	inline Color m_uMarkerColor;
	void AddScreenHitmarker(Color uColor);

	void RenderWorldHitmarkers();
	void RenderScreenHitmarkers();
	void RenderHitmarkers();
}
```

`CSGO SDK/Hooking/Hooked.hpp`:

```hpp
#pragma once

#include "../source.hpp"

struct vrect_t {
	int				x, y, width, height;
	vrect_t* pnext;
};

class CRecvProxyData;

namespace Hooked
{
	struct PlayerHook {
		Memory::VmtSwap clientHook;
		Memory::VmtSwap renderableHook;
		Memory::VmtSwap networkableHook;

		~PlayerHook();
		void SetHooks();
	};

	extern std::map< int, Hooked::PlayerHook > player_hooks;

	using CreateMoveFn = bool(__stdcall*)(float, CUserCmd*);
	inline CreateMoveFn oCreateMove;
	bool __stdcall CreateMove(float, CUserCmd*);

	//void __fastcall CreateMoveInput( void* _this, int, int sequence_number, float input_sample_frametime, bool active );

	using DoPostScreenEffectsFn = int(__thiscall*)(IClientMode*, int);
	inline DoPostScreenEffectsFn oDoPostScreenEffects;
	int __stdcall DoPostScreenEffects(int a1);

	using FrameStageNotifyFn = void(__thiscall*)(void*, ClientFrameStage_t);
	inline FrameStageNotifyFn oFrameStageNotify;
	void __fastcall FrameStageNotify(void* ecx, void* edx, ClientFrameStage_t stage);

	using RunCommandFn = void(__thiscall*)(void*, C_CSPlayer*, CUserCmd*, IMoveHelper*);
	inline RunCommandFn oRunCommand;
	void __fastcall RunCommand(void* ecx, void* edx, C_CSPlayer* player, CUserCmd* ucmd, IMoveHelper* moveHelper);

	using PaintTraverseFn = void(__thiscall*)(void*, unsigned int, bool, bool);
	inline PaintTraverseFn oPaintTraverse;
	void __fastcall PaintTraverse(void* ecx, void* edx, unsigned int vguiPanel, bool forceRepaint, bool allowForce);

	using ResetFn = HRESULT(__stdcall*)(IDirect3DDevice9*, D3DPRESENT_PARAMETERS*);
	inline ResetFn oReset;
	HRESULT __stdcall Reset(IDirect3DDevice9* pDevice, D3DPRESENT_PARAMETERS* pPresentationParameters);

	using PresentFn = HRESULT(__stdcall*)(IDirect3DDevice9*, const RECT*, const RECT*, HWND, const RGNDATA*);
	inline PresentFn oPresent;
	HRESULT __stdcall Present(LPDIRECT3DDEVICE9 pDevice, const RECT* pSourceRect, const RECT* pDestRect, HWND hDestWindowOverride, const RGNDATA* pDirtyRegion);

	using LockCursorFn = void(__thiscall*)(void*);
	inline LockCursorFn oLockCursor;
	void __stdcall LockCursor();

	using OverrideViewFn = void(__thiscall*)(void*, CViewSetup*);
	inline OverrideViewFn oOverrideView;
	void __fastcall OverrideView(void* ECX, int EDX, CViewSetup* vsView);

	using BeginFrameFn = void(__thiscall*)(void* ECX, float ft);
	inline BeginFrameFn oBeginFrame;
	void __fastcall BeginFrame(void* ECX, void* EDX, float ft);

	void __fastcall SetReservationCookie(void* ECX, void* EDX, int a2, int a3);

	using PacketStartFn = void(__thiscall*)(void*, int, int);
	inline PacketStartFn oPacketStart;
	void __fastcall PacketStart(void* ECX, void* EDX, int incoming_sequence, int outgoing_acknowledged);

	using PacketEndFn = void(__thiscall*)(void*);
	inline PacketEndFn oPacketEnd;
	void __fastcall PacketEnd(void* ECX, void* EDX);

	using TempEntitiesFn = bool(__thiscall*)(void*, void*);
	inline TempEntitiesFn oProcessTempEntities;
	bool __fastcall ProcessTempEntities(void* ecx, void*, void* msg);

	using CL_FireEventsFn = void (*)(void);
	inline CL_FireEventsFn CL_FireEvents;

	using ListLeavesInBoxFn = int(__thiscall*)(void*, Vector& mins, Vector& maxs, unsigned short* pList, int listMax);
	inline ListLeavesInBoxFn oListLeavesInBox;
	int __fastcall ListLeavesInBox(void* ECX, void* EDX, Vector& mins, Vector& maxs, unsigned short* pList, int listMax);

	using SendNetMsgFn = bool(__thiscall*)(INetChannel* pNetChan, INetMessage& msg, bool bForceReliable, bool bVoice);
	inline SendNetMsgFn oSendNetMsg;
	bool __fastcall SendNetMsg(INetChannel* pNetChan, void* edx, INetMessage& msg, bool bForceReliable, bool bVoice);

	using SendDatagramFn = int(__thiscall*)(INetChannel* pNetChan, void* buf);
	inline SendDatagramFn oSendDatagram;
	int __fastcall SendDatagram(INetChannel* pNetChan, void* edx, void* buf);

	using ProcessPacketFn = int(__thiscall*)(INetChannel* pNetChan, void* packet, bool header);
	inline ProcessPacketFn oProcessPacket;
	void __fastcall ProcessPacket(INetChannel* pNetChan, void* edx, void* packet, bool header);

	using ShutdownFn = void(__thiscall*)(INetChannel*, const char*);
	inline ShutdownFn oShutdown;
	void __fastcall Shutdown(INetChannel* pNetChan, void* EDX, const char* reason);

	using LooseFileAllowedFn = bool(__thiscall*)(void*);
	inline LooseFileAllowedFn oLooseFileAllowed;
	bool __fastcall LooseFileAllowed(void* ecx, void* edx);

	using CheckFileCRCsWithServerFn = void(__thiscall*)(void*);
	inline CheckFileCRCsWithServerFn oCheckFileCRCsWithServer;
	void __fastcall CheckFileCRCsWithServer(void* ecx, void* edx);

	using DrawModelFn = void(__thiscall*)(void*, void*, DrawModelInfo_t*, const matrix3x4_t*, float*, float*, Vector&, int);
	inline DrawModelFn oDrawModel;
	void __fastcall DrawModel(void* ECX, void* EDX, void* pResults, DrawModelInfo_t* pInfo, matrix3x4_t* pBoneToWorld, float* flpFlexWeights, float* flpFlexDelayedWeights, Vector& vrModelOrigin, int32_t iFlags);

	using DrawModelExecuteFn = void(__thiscall*)(void*, IMatRenderContext* MatRenderContext, DrawModelState_t& DrawModelState, ModelRenderInfo_t& RenderInfo, matrix3x4_t* pCustomBoneToWorld);
	inline DrawModelExecuteFn oDrawModelExecute;
	void __fastcall DrawModelExecute(void* ECX, void* EDX, IMatRenderContext* MatRenderContext, DrawModelState_t& DrawModelState, ModelRenderInfo_t& RenderInfo, matrix3x4_t* pCustomBoneToWorld);

	using WriteUsercmdDeltaToBufferFn = bool(__thiscall*)(void*, int, void*, int, int, bool);
	inline WriteUsercmdDeltaToBufferFn oWriteUsercmdDeltaToBuffer;
	bool WriteUsercmdDeltaToBuffer(void* ECX, void* EDX, int nSlot, void* buf, int from, int to, bool isnewcommand);

	IClientNetworkable* hkCreateCCSPlayer(int entnum, int serialNum);
	bool __fastcall hkSetupBones(uintptr_t ecx, void* edx, matrix3x4_t* matrix, int bone_count, int bone_mask, float time);
	void __fastcall hkEntityRelease(uintptr_t ecx, void* edx);

	using FnEmitSound = void(__thiscall*) (IEngineSound* thisptr, void* filter, int ent_index, int channel, const char* sound_entry, unsigned int sound_entry_hash,
		const char* sample, float volume, float attenuation, int seed, int flags, int pitch, const Vector* origin, const Vector* direction,
		void* vec_origins, bool update_positions, float sound_time, int speaker_entity, int test);
	inline FnEmitSound oEmitSound;

	void __fastcall hkEmitSound(IEngineSound* thisptr, uint32_t, void* filter, int ent_index, int channel, const char* sound_entry, unsigned int sound_entry_hash,
		const char* sample, float volume, float attenuation, int seed, int flags, int pitch, const Vector* origin, const Vector* direction,
		void* vec_origins, bool update_positions, float sound_time, int speaker_entity, int test);

	using FnGetScreenAspectRatio = float(__thiscall*)(void*, int32_t, int32_t);
	inline FnGetScreenAspectRatio oGetScreenAspectRatio;
	float __fastcall hkGetScreenAspectRatio(void* ECX, void* EDX, int32_t iWidth, int32_t iHeight);

	using FnInterpolateServerEntities = void(__cdecl*)(void);
	inline FnInterpolateServerEntities oInterpolateServerEntities;
	void __cdecl InterpolateServerEntities(void);

	using FnView_Render = void(__thiscall*)(void*, vrect_t*);
	inline FnView_Render oView_Render;
	void __fastcall View_Render(void* ecx, void* edx, vrect_t* rect);

	using FnOnSoundStarted = void(__thiscall*)(void*, int, StartSoundParams_t&, char const*);
	inline FnOnSoundStarted oOnSoundStarted;
	void __fastcall OnSoundStarted(void* ECX, void* EDX, int guid, StartSoundParams_t& params, char const* soundname);

	using FnIsBoxVisible = int(__thiscall*)(void* ECX, const Vector&, const Vector&);
	inline FnIsBoxVisible oIsBoxVisible;
	int __fastcall hkIsBoxVisible(void* ECX, uint32_t, const Vector& mins, const Vector& maxs);

	using FnIsPlayingDemo = bool(__thiscall*)(void* ECX);
	inline FnIsPlayingDemo oIsPlayingDemo;
	bool __fastcall hkIsPlayingDemo(void* ECX, void* EDX);

	using FnRetrieveMessage = EGCResults(__thiscall*) (void* ECX, uint32_t* punMsgType, void* pubDest, uint32_t cubDest, uint32_t* pcubMsgSize);
	inline FnRetrieveMessage oRetrieveMessage;
	EGCResults __fastcall hkRetrieveMessage(void* ECX, void* EDX, uint32_t* punMsgType, void* pubDest, uint32_t cubDest, uint32_t* pcubMsgSize);

	using ReportHitFn = bool(__cdecl*)(Hit_t*);
	inline ReportHitFn oReportHit;
	bool __cdecl ReportHit(Hit_t* hit);

	void __vectorcall CL_Move(bool bFinalTick, float accumulated_extra_samples);
	inline decltype(&CL_Move) oCL_Move;

	void __fastcall RunSimulation(void* this_, void*, int iCommandNumber, CUserCmd* pCmd, size_t local);
	inline Memory::DetourHook_t RunSimulationDetor(RunSimulation);

	void __fastcall PredictionUpdate(void* prediction, void*, int startframe, bool validframe, int incoming_acknowledged, int outgoing_command);
	inline Memory::DetourHook_t PredictionUpdateDetor(PredictionUpdate);

	using IsUsingStaticPropDebugModeFn = bool(__cdecl*)();
	inline IsUsingStaticPropDebugModeFn oIsUsingStaticPropDebugMode;
	bool __cdecl IsUsingStaticPropDebugMode();

	using FnIsConnected = bool(__thiscall*) (void);
	inline FnIsConnected oIsConnected;
	bool __fastcall hkIsConnected(void);

	using FnDispatchUserMessage = bool(__thiscall*) (void* ECX, int msg_type, int unk1, int nBytes, bf_read& msg_data);
	inline FnDispatchUserMessage oDispatchUserMessage;
	bool __fastcall hkDispatchUserMessage(void* ECX, void* EDX, int msg_type, int unk1, int nBytes, bf_read& msg_data);

	using FnRenderView = void(__thiscall*) (void* ECX, const CViewSetup& view, CViewSetup& hudViewSetup, int nClearFlags, int whatToDraw);
	inline FnRenderView oRenderView;
	void __fastcall hkRenderView(void* ECX, void* EDX, const CViewSetup& view, CViewSetup& hudViewSetup, int nClearFlags, int whatToDraw);

	// Recv proxy hook
	void m_nSmokeEffectTickBegin(CRecvProxyData* pData, void* pStruct, void* pOut);
	void RecvProxy_m_flAbsYaw(CRecvProxyData* pData, void* pStruct, void* pOut);
	void RecvProxy_m_flLowerBodyYawTarget(CRecvProxyData* pData, void* pStruct, void* pOut);
	void RecvProxy_PlaybackRate(CRecvProxyData* pData, void* pStruct, void* pOut);
	void m_bClientSideAnimation(CRecvProxyData* pData, void* pStruct, void* pOut);
}

```

`CSGO SDK/Hooking/Hooker.hpp`:

```hpp
#include <vector>
#include <algorithm>
#include "minhook-master/include/MinHook.h"

namespace Hooked
{
	struct hook_t {
		bool enabled = false;
		void* target = nullptr;
		void* custom = nullptr;

		__forceinline void Enable() {
			MH_EnableHook(target);
			enabled = true;
		}

		__forceinline void Disable() {
			MH_DisableHook(target);
			enabled = false;
		}
	};

	class C_Hooks {
		std::vector<hook_t> m_hooks;
	public:
		C_Hooks() {
		}
		~C_Hooks() {
		}

		template < typename o, typename fn = uintptr_t >
		__forceinline o HookVirtual(void* vtable, fn custom_func, int index) {
			return CreateHook<o, fn>(custom_func, Memory::VCall<fn>(vtable, index));
		}

		template < typename o, typename fn = uintptr_t >
		__forceinline o CreateHook(fn custom_func, void* o_func) {
			o original = { };
			hook_t hook = { };
			hook.target = o_func;
			hook.custom = custom_func;
			hook.enabled = false;

			if (MH_CreateHook(o_func, custom_func, (LPVOID*)&original) == MH_OK) {
				m_hooks.push_back(hook);
			}

			return original;
		}

		__forceinline void Enable() {
			for (auto h : m_hooks)
				h.Enable();
		}

		__forceinline void Restore() {
			for (auto h : m_hooks)
				h.Disable();
		}
	};

	inline C_Hooks HooksManager;
};
```

`CSGO SDK/Hooking/Hooks/BeginFrame.cpp`:

```cpp
#include "../hooked.hpp"
#include "../../Features/Miscellaneous/BulletBeamTracer.hpp"

void __fastcall Hooked::BeginFrame(void* ECX, void* EDX, float ft) {
	g_Vars.globals.szLastHookCalled = XorStr("1");

	if (g_Vars.esp.beam_enabled && g_Vars.globals.HackIsReady && g_Vars.globals.RenderIsReady && g_Vars.esp.beam_type == 1)
		IBulletBeamTracer::Get()->Main();

	oBeginFrame(ECX, ft);
}

```

`CSGO SDK/Hooking/Hooks/CreateMove.cpp`:

```cpp
#include "../Hooked.hpp"
#include "../../SDK/Displacement.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "../../Features/Game/Prediction.hpp"
#include "../../Features/Miscellaneous/Movement.hpp"
#include <intrin.h>
#include "../../Features/Rage/Ragebot.hpp"
#include "../../Features/Miscellaneous/Miscellaneous.hpp"
#include "../../Utils/InputSys.hpp"
#include "../../SDK/Classes/Exploits.hpp"
#include "../../Features/Rage/FakeLag.hpp"
#include "../../Features/Rage/LagCompensation.hpp"
#include "../../Utils/Threading/threading.h"
#include "../../SDK/Classes/CCSGO_HudDeathNotice.hpp"
#include "../../Features/Rage/ShotInformation.hpp"
#include <thread>
#include "../../Features/Visuals/GrenadePrediction.hpp"
#include "../../Features/Rage/TickbaseShift.hpp"
#include "../../Features/Game/SetupBones.hpp"
#include "../../Features/Visuals/Hitmarker.hpp"
#include "../../Features/Rage/AntiAim.hpp"

extern float fl_Override;
extern bool g_Override;

Vector AutoPeekPos;

int LastShotTime = 0;
int OutgoingTickcount = 0;

void PreserveKillfeed() {
	auto local = C_CSPlayer::GetLocalPlayer();

	if (!local || !Interfaces::m_pEngine->IsInGame() || !Interfaces::m_pEngine->IsConnected()) {
		return;
	}

	static auto status = false;
	static float m_spawn_time = local->m_flSpawnTime();

	auto set = false;
	if (m_spawn_time != local->m_flSpawnTime() || status != g_Vars.esp.preserve_killfeed) {
		set = true;
		status = g_Vars.esp.preserve_killfeed;
		m_spawn_time = local->m_flSpawnTime();
	}

	for (int i = 0; i < Interfaces::g_pDeathNotices->m_vecDeathNotices.Count(); i++) {
		auto cur = &Interfaces::g_pDeathNotices->m_vecDeathNotices[i];
		if (!cur) {
			continue;
		}

		if (local->IsDead() || set) {
			if (cur->set != 1.f && !set) {
				continue;
			}

			cur->m_flStartTime = Interfaces::m_pGlobalVars->curtime;
			cur->m_flStartTime -= local->m_iHealth() <= 0 ? 2.f : 7.5f;
			cur->set = 2.f;

			continue;
		}

		if (cur->set == 2.f) {
			continue;
		}

		if (!status) {
			cur->set = 1.f;
			return;
		}

		if (cur->set == 1.f) {
			continue;
		}

		if (cur->m_flLifeTimeModifier == 1.5f) {
			cur->m_flStartTime = FLT_MAX;
		}

		cur->set = 1.f;
	}
}

namespace Hooked
{
	inline float anglemod(float a)
	{
		a = (360.f / 65536) * ((int)(a * (65536.f / 360.0f)) & 65535);
		return a;
	}

	// BUGBUG: Why doesn't this call angle diff?!?!?
	float ApproachAngle(float target, float value, float speed)
	{
		target = anglemod(target);
		value = anglemod(value);

		float delta = target - value;

		// Speed is assumed to be positive
		if (speed < 0)
			speed = -speed;

		if (delta < -180)
			delta += 360;
		else if (delta > 180)
			delta -= 360;

		if (delta > speed)
			value += speed;
		else if (delta < -speed)
			value -= speed;
		else
			value = target;

		return value;
	}


	// BUGBUG: Why do we need both of these?
	float AngleDiff(float destAngle, float srcAngle)
	{
		float delta;

		delta = fmodf(destAngle - srcAngle, 360.0f);
		if (destAngle > srcAngle)
		{
			if (delta >= 180)
				delta -= 360;
		}
		else
		{
			if (delta <= -180)
				delta += 360;
		}
		return delta;
	}

	class NetPos {
	public:
		float  m_time;
		Vector m_pos;

	public:
		__forceinline NetPos() : m_time{ }, m_pos{ } {};
		__forceinline NetPos(float time, Vector pos) : m_time{ time }, m_pos{ pos } {};
	};

	void UpdateInformation(CUserCmd* cmd) {

		auto local = C_CSPlayer::GetLocalPlayer();

		if (!local)
			return;

		if (Interfaces::m_pClientState->m_nChokedCommands() > 0)
			return;

		local->m_fEffects() &= ~EF_NOINTERP;


		CCSGOPlayerAnimState* state = local->m_PlayerAnimState();
		if (!state)
			return;

		// update time.
		g_Vars.globals.m_flAnimFrame = TICKS_TO_TIME(local->m_nTickBase()) - g_Vars.globals.m_flAnimTime;
		g_Vars.globals.m_flAnimTime = TICKS_TO_TIME(local->m_nTickBase());

		// current angle will be animated.
		g_Vars.globals.RegularAngles = cmd->viewangles;


		Math::Clamp(g_Vars.globals.RegularAngles.x, -90.f, 90.f);
		g_Vars.globals.RegularAngles.Normalize();

		// write angles to model.
		Interfaces::m_pPrediction->SetLocalViewAngles(g_Vars.globals.RegularAngles);

		// set lby to predicted value.
		local->m_flLowerBodyYawTarget() = g_Vars.globals.m_flBody;

		// CCSGOPlayerAnimState::Update, bypass already animated checks.
		if (state->m_nLastFrame == Interfaces::m_pGlobalVars->framecount)
			state->m_nLastFrame -= 1;

		local->m_iEFlags() &= ~(EFL_DIRTY_ABSTRANSFORM | EFL_DIRTY_ABSVELOCITY);

		state->m_flFeetYawRate = 0.f;

		local->UpdateClientSideAnimationEx();

		auto flWeight12Backup = local->m_AnimOverlay().Element(12).m_flWeight;

		local->m_AnimOverlay().Element(12).m_flWeight = 0.f;

		// land fall anim fix.
		if (FL_ONGROUND) {
			// they are on ground.
			state->m_bOnGround = true;
			// no they didnt land.
			state->m_bLand = false;
		}

		bool bOnGround = local->m_fFlags() & FL_ONGROUND;
		bool bJumped = false;
		bool bLandedOnServer = false;
		float flLandTime = 0.f;
		float m_anim_time = Interfaces::m_pGlobalVars->curtime;

		if (FL_ONGROUND) {
			flLandTime = m_anim_time - float(local->m_AnimOverlay().Element(4).m_flPlaybackRate / local->m_AnimOverlay().Element(4).m_flCycle);
			bLandedOnServer = flLandTime >= m_anim_time;
		}

		if (bLandedOnServer && !bJumped) {
			if (flLandTime <= m_anim_time) {
				bJumped = true;
				bOnGround = true;
			}
			else {
				bOnGround = local->m_fFlags() & FL_ONGROUND;
			}
		}

		if (bOnGround) {
			local->m_fFlags() |= FL_ONGROUND;
		}
		else {
			local->m_fFlags() &= ~FL_ONGROUND;
		}

		local->UpdateClientSideAnimation();


		// pull the lower body direction towards the eye direction, but only when the player is moving
		// we landed.
		if (!g_Vars.globals.m_bGround && state->m_bOnGround) {
			g_Vars.globals.m_flBody = g_Vars.globals.RegularAngles.y;
			g_Vars.globals.m_flBodyPred = g_Vars.globals.m_flAnimTime;
		}

		// walking, delay lby update by .22.
		else if (local->m_vecVelocity().Length() > 0.1f) {
			if (state->m_bOnGround)
				g_Vars.globals.m_flBody = g_Vars.globals.RegularAngles.y;

			g_Vars.globals.m_flBodyPred = g_Vars.globals.m_flAnimTime + 0.22f;
		}

		// standing update every 1.1s
		else if (g_Vars.globals.m_flAnimTime > g_Vars.globals.m_flBodyPred && state->m_bOnGround) {
			g_Vars.globals.m_flBody = g_Vars.globals.RegularAngles.y;
			g_Vars.globals.m_flBodyPred = g_Vars.globals.m_flAnimTime + 1.1f;
		}

		// build bones at the end of everything

		g_BoneSetup.BuildBones(local, BONE_USED_BY_ANYTHING, BoneSetupFlags::None);

		g_Vars.globals.flRealYaw = state->m_flAbsRotation;
		g_Vars.globals.angViewangles = cmd->viewangles;

		// copy real bone positions
		auto boneCount = local->m_CachedBoneData().Count();
		std::memcpy(g_Vars.globals.m_RealBonesPositions, local->m_vecBonePos(), boneCount * sizeof(Vector));
		std::memcpy(g_Vars.globals.m_RealBonesRotations, local->m_quatBoneRot(), boneCount * sizeof(Quaternion));

		local->m_AnimOverlay().Element(12).m_flWeight = flWeight12Backup;
		if (g_Vars.globals.m_flPoseParams) {
			std::memcpy(local->m_flPoseParameter(), g_Vars.globals.m_flPoseParams, sizeof(local->m_flPoseParameter()));
		}

		if (local->m_CachedBoneData().Base() != local->m_BoneAccessor().m_pBones) {
			std::memcpy(local->m_BoneAccessor().m_pBones, local->m_CachedBoneData().Base(), local->m_CachedBoneData().Count() * sizeof(matrix3x4_t));
		}

		// save updated data.
		g_Vars.globals.m_bGround = state->m_bOnGround;
		g_Vars.globals.m_fFlags = local->m_fFlags();
		g_Vars.globals.m_speed = local->m_PlayerAnimState()->m_velocity;
	}

	std::deque< NetPos >   m_net_pos;
	bool CreateMoveHandler(float ft, CUserCmd* _cmd, bool* bSendPacket, bool* bFinalTick) {
		auto bRet = oCreateMove(ft, _cmd);

		g_Vars.globals.m_bInCreateMove = true;

		auto pLocal = C_CSPlayer::GetLocalPlayer();
		if (!pLocal || pLocal->IsDead()) {
			g_Vars.globals.WasShootingInPeek = false;
			AutoPeekPos.Set();

			Engine::Prediction::Instance().Invalidate();
			g_Vars.globals.m_bInCreateMove = false;
			return bRet;
		}

		auto weapon = (C_WeaponCSBaseGun*)(pLocal->m_hActiveWeapon().Get());
		if (!weapon) {
			Engine::Prediction::Instance().Invalidate();
			g_Vars.globals.m_bInCreateMove = false;

			return bRet;
		}


		g_Vars.globals.m_vecUnpredictedVel = pLocal->m_vecVelocity();

		g_Vars.globals.m_flCurtime = Interfaces::m_pGlobalVars->curtime;

		Encrypted_t<CUserCmd> cmd(_cmd);

		static auto m_iCrosshairData = Interfaces::m_pCvar->FindVar(XorStr("weapon_debug_spread_show"));
		if (g_Vars.esp.force_sniper_crosshair && m_iCrosshairData) {
			m_iCrosshairData->SetValue(!pLocal->m_bIsScoped() ? 3 : 0);
		}
		else {
			if (m_iCrosshairData)
				m_iCrosshairData->SetValue(0);
		}

		static auto g_GameRules = *(uintptr_t**)(Engine::Displacement.Data.m_GameRules);
		bool invalid = g_GameRules && *(bool*)(*(uintptr_t*)g_GameRules + 0x20) || (pLocal->m_fFlags() & (1 << 6));

		Encrypted_t<CVariables::GLOBAL> globals(&g_Vars.globals);

		static QAngle lockedAngles = QAngle();


		auto movement = Interfaces::Movement::Get();

		if (g_Vars.globals.menuOpen) {
			// just looks nicer
			auto RemoveButtons = [&](int key) { cmd->buttons &= ~key; };
			RemoveButtons(IN_ATTACK);
			RemoveButtons(IN_ATTACK2);
			RemoveButtons(IN_USE);

			if (GUI::ctx->typing) {
				RemoveButtons(IN_MOVERIGHT);
				RemoveButtons(IN_MOVELEFT);
				RemoveButtons(IN_FORWARD);
				RemoveButtons(IN_BACK);

				movement->InstantStop(cmd.Xor());
			}
		}

		g_Vars.globals.m_pCmd = cmd.Xor();

		auto weaponInfo = weapon->GetCSWeaponData();

		g_Vars.globals.bCanWeaponFire = pLocal->CanShoot();

		//g_TickbaseController.PreMovement( );

		g_Vars.globals.m_lerp = Engine::LagCompensation::Get()->GetLerp();


		Engine::Prediction::Instance()->RunGamePrediction();

		auto& prediction = Engine::Prediction::Instance();

		movement->PrePrediction(cmd, pLocal, bSendPacket, bFinalTick, nullptr);
		prediction.Begin(cmd, bSendPacket, cmd->command_number);
		{
			g_Vars.globals.m_bAimbotShot = false;

			if (g_Vars.misc.autopeek && g_Vars.misc.autopeek_bind.enabled) {
				if ((pLocal->m_fFlags() & FL_ONGROUND)) {
					if (AutoPeekPos.IsZero()) {
						AutoPeekPos = pLocal->GetAbsOrigin();
					}
				}
			}
			else {
				AutoPeekPos = Vector();
			}

			movement->InPrediction();
			movement->PostPrediction();

			g_Vars.globals.m_vecVelocity = pLocal->m_vecVelocity();
			/*
			if( !g_Vars.misc.slide_walk ) {
				if( pLocal->m_MoveType( ) != MOVETYPE_LADDER && pLocal->m_MoveType( ) != MOVETYPE_NOCLIP && pLocal->m_MoveType( ) != MOVETYPE_FLY )
					cmd->buttons &= ~( IN_FORWARD | IN_BACK | IN_MOVERIGHT | IN_MOVELEFT );
			}
			else {
				if( pLocal->m_MoveType( ) != MOVETYPE_LADDER && pLocal->m_fFlags( ) & FL_ONGROUND ) {
					if( cmd->forwardmove > 0 ) {
						cmd->buttons |= IN_BACK;
						cmd->buttons &= ~IN_FORWARD;
					}

					if( cmd->forwardmove < 0 ) {
						cmd->buttons |= IN_FORWARD;
						cmd->buttons &= ~IN_BACK;
					}

					if( cmd->sidemove < 0 ) {
						cmd->buttons |= IN_MOVERIGHT;
						cmd->buttons &= ~IN_MOVELEFT;
					}

					if( cmd->sidemove > 0 ) {
						cmd->buttons |= IN_MOVELEFT;
						cmd->buttons &= ~IN_MOVERIGHT;
					}
				}
			}*/

			int nShotCmd = -1;

			if (cmd->buttons & IN_ATTACK
				&& weapon->m_iItemDefinitionIndex() != WEAPON_C4
				&& weaponInfo->m_iWeaponType >= WEAPONTYPE_KNIFE
				&& weaponInfo->m_iWeaponType <= WEAPONTYPE_MACHINEGUN
				&& pLocal->CanShoot())
			{
				nShotCmd = cmd->command_number;
				g_Vars.globals.m_iShotTick = cmd->tick_count;
				lockedAngles = cmd->viewangles;
				LastShotTime = Interfaces::m_pGlobalVars->tickcount;

				if (weaponInfo->m_iWeaponType != WEAPONTYPE_KNIFE && weaponInfo->m_iWeaponType != WEAPONTYPE_GRENADE) {
					g_Vars.globals.m_flLastShotTime = Interfaces::m_pGlobalVars->realtime;
					//if( g_Vars.globals.bInRagebot ) {
					//	g_Vars.globals.m_flLastShotTimeInRage = g_Vars.globals.m_flLastShotTime;
					//}
				}

				g_Vars.globals.WasShootingInChokeCycle = !(*bSendPacket);
				g_Vars.globals.WasShooting = true;

				if (weaponInfo->m_iWeaponType != WEAPONTYPE_KNIFE)
					g_Vars.globals.WasShootingInPeek = true;

				//g_Vars.globals.m_ShotAngle = Interfaces::m_pInput->m_pCommands[ nShotCmd % 150 ].viewangles;

			}
			else {
				g_Vars.globals.WasShooting = false;
			}

			g_Vars.globals.iWeaponIndex = weapon->m_iItemDefinitionIndex();

			g_Vars.globals.m_flPreviousDuckAmount = pLocal->m_flDuckAmount();

			Engine::C_ShotInformation::Get()->CorrectSnapshots(*bSendPacket);

			bool bInAttack = cmd->buttons & IN_ATTACK;
			bool bCanShoot = TICKS_TO_TIME(pLocal->m_nTickBase()) >= weapon->m_flNextPrimaryAttack();

			if (!(TICKS_TO_TIME(pLocal->m_nTickBase()) >= pLocal->m_flNextAttack())) {
				bCanShoot = false;
			}

			if (weapon->m_iItemDefinitionIndex() == WEAPON_REVOLVER)
				bCanShoot = false;

			if (bCanShoot && bInAttack && weaponInfo->m_iWeaponType != WEAPONTYPE_GRENADE && weaponInfo->m_iWeaponType != WEAPONTYPE_C4) {
				if (!g_Vars.globals.Fakewalking)
					*bSendPacket = false;
			}

			UpdateInformation(cmd.Xor());

			g_Vars.globals.m_bOldShot = g_Vars.globals.m_bAimbotShot;

			//	g_TickbaseController.PostMovement( bSendPacket, cmd.Xor( ) );
		}
		prediction.End();

		if (!g_Vars.misc.slide_walk)
			if (pLocal->m_MoveType() != MOVETYPE_LADDER && pLocal->m_MoveType() != MOVETYPE_NOCLIP && pLocal->m_MoveType() != MOVETYPE_FLY)
				cmd->buttons &= ~(IN_FORWARD | IN_BACK | IN_MOVERIGHT | IN_MOVELEFT);

		if (g_Vars.antiaim.enabled && g_Vars.antiaim.manual && g_Vars.antiaim.mouse_override.enabled) {
			pLocal->pl().v_angle = globals->PreviousViewangles;
		}

		if (*bSendPacket) {
			g_Vars.globals.WasShootingInChokeCycle = false;

			g_Vars.globals.LastChokedCommands = Interfaces::m_pClientState->m_nChokedCommands();

			if (g_Vars.globals.FixCycle) {
				g_Vars.globals.FixCycle = false;
				g_Vars.globals.UnknownCycleFix = true;
			}

			OutgoingTickcount = Interfaces::m_pGlobalVars->tickcount;

			// TODO: make this lag compensated
			g_Vars.globals.m_iNetworkedTick = pLocal->m_nTickBase();
			g_Vars.globals.m_vecNetworkedOrigin = pLocal->m_vecOrigin();
		}

		if (!*bSendPacket || !*bFinalTick)
			g_Vars.globals.RegularAngles = cmd->viewangles;
		else
			g_Vars.globals.FakeAngle = cmd->viewangles;

		if (*bSendPacket) {
			Vector cur = pLocal->m_vecOrigin();
			Vector prev = m_net_pos.empty() ? cur : m_net_pos.front().m_pos;

			g_Vars.globals.bBrokeLC = (cur - prev).LengthSquared() > 4096.f;
			g_Vars.globals.delta = std::clamp((cur - prev).LengthSquared(), 0.f, 4096.f);

			m_net_pos.emplace_front(Interfaces::m_pGlobalVars->curtime, cur);
		}

		g_Vars.globals.bFinalPacket = *bSendPacket;

		if (g_Vars.misc.anti_untrusted) {
			cmd->viewangles.Normalize();
			cmd->viewangles.Clamp();
		}

		g_Vars.globals.m_bInCreateMove = false;

		return false;
	}

	bool __stdcall CreateMove(float ft, CUserCmd* _cmd) {
		g_Vars.globals.szLastHookCalled = XorStr("2");
		if (!_cmd || !_cmd->command_number)
			return oCreateMove(ft, _cmd);

		if (g_Vars.cl_csm_shadows->GetInt() != 0)
			g_Vars.cl_csm_shadows->SetValue(0);

		if (g_Vars.engine_no_focus_sleep->GetInt() != 0)
			g_Vars.engine_no_focus_sleep->SetValue(0);

		PreserveKillfeed();

		Encrypted_t<uintptr_t> pAddrOfRetAddr((uintptr_t*)_AddressOfReturnAddress());
		bool* bFinalTick = reinterpret_cast<bool*>(uintptr_t(pAddrOfRetAddr.Xor()) + 0x15);
		bool* bSendPacket = reinterpret_cast<bool*>(uintptr_t(pAddrOfRetAddr.Xor()) + 0x14);

		if (!(*bSendPacket))
			*bSendPacket = true;

		if (!*bFinalTick)
			*bSendPacket = false;

		int iLagLimit = 16;
		g_Vars.fakelag.iLagLimit = std::clamp(iLagLimit, 0, 16);

		auto result = CreateMoveHandler(ft, _cmd, bSendPacket, bFinalTick);

		Engine::Prediction::Instance()->KeepCommunication(bSendPacket, _cmd->command_number);

		auto pLocal = C_CSPlayer::GetLocalPlayer();
		if (!g_Vars.globals.HackIsReady || !pLocal || !Interfaces::m_pEngine->IsInGame()) {
			Engine::Prediction::Instance().Invalidate();
			return oCreateMove(ft, _cmd);
		}

		return result;
	}

	bool __cdecl ReportHit(Hit_t* hit) {
		if ((g_Vars.esp.visualize_hitmarker_world || g_Vars.esp.visualize_damage) && hit) {
			Hitmarkers::AddWorldHitmarker(hit->x, hit->y, hit->z);
		}

		return oReportHit(hit);
	}

	bool __cdecl IsUsingStaticPropDebugMode()
	{
		if (Interfaces::m_pEngine.IsValid() && !Interfaces::m_pEngine->IsInGame())
			return oIsUsingStaticPropDebugMode();

		return g_Vars.esp.night_mode;
	}

	void __fastcall RunSimulation(void* this_, void*, int iCommandNumber, CUserCmd* pCmd, size_t local) {
		g_TickbaseController.OnRunSimulation(this_, iCommandNumber, pCmd, local);
	}

	void __fastcall PredictionUpdate(void* prediction, void*, int startframe, bool validframe, int incoming_acknowledged, int outgoing_command) {
		g_TickbaseController.OnPredictionUpdate(prediction, nullptr, startframe, validframe, incoming_acknowledged, outgoing_command);
	}
}

```

`CSGO SDK/Hooking/Hooks/DispatchUserMessage.cpp`:

```cpp
#include "../hooked.hpp"
#include "../../SDK/Classes/player.hpp"
#include "../../SDK/CVariables.hpp"

bool __fastcall Hooked::hkDispatchUserMessage(void* ECX, void* EDX, int msg_type, int unk1, int nBytes, bf_read& msg_data) {
	g_Vars.globals.szLastHookCalled = XorStr("4");
	return oDispatchUserMessage(ECX, msg_type, unk1, nBytes, msg_data);
}

```

`CSGO SDK/Hooking/Hooks/DoPostScreenEffects.cpp`:

```cpp
#include "../Hooked.hpp"
#include "../../Features/Visuals/Glow.hpp"
#include "../../Features/Visuals/CChams.hpp"
#include "../../SDK/CVariables.hpp"

namespace Hooked
{
	int __stdcall DoPostScreenEffects(int a1) {
		g_Vars.globals.szLastHookCalled = ("5");
		if (g_Vars.globals.HackIsReady && g_Vars.globals.RenderIsReady)
			GlowOutline::Get()->Render();

		Interfaces::IChams::Get()->OnPostScreenEffects();

		g_Vars.globals.m_bInPostScreenEffects = true;
		auto result = oDoPostScreenEffects(Interfaces::m_pClientMode.Xor(), a1);
		g_Vars.globals.m_bInPostScreenEffects = false;

		return result;
	}
}

```

`CSGO SDK/Hooking/Hooks/DrawModel.cpp`:

```cpp
#include "../hooked.hpp"
#include "../../Features/Visuals/CChams.hpp"
#include "../../SDK/Classes/Player.hpp"
//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
struct matrix3x4_t;

struct MDLSquenceLayer_t {
	int		m_nSequenceIndex;
	float	m_flWeight;
	bool	m_bNoLoop;
	float	m_flCycleBeganAt;
};

uintptr_t* rel32(uintptr_t ptr) {
	auto offset = *(uintptr_t*)(ptr + 0x1);
	return (uintptr_t*)(ptr + 5 + offset);
}

class CMDLAttachmentData {
public:
	matrix3x4_t	m_AttachmentToWorld;
	bool m_bValid;
};

//-----------------------------------------------------------------------------
// Class containing simplistic MDL state for use in rendering
//-----------------------------------------------------------------------------
class CMDL {
public:
	CMDL() {
		static auto ctor = (void(__thiscall*)(void*))rel32(Memory::Scan("client.dll", "E8 ?? ?? ?? ?? 56 8D 4C 24 24"));
		ctor(this);
	}

	~CMDL() {
		static auto dector = (void(__thiscall*)(void*))rel32(Memory::Scan("client.dll", "E8 ?? ?? ?? ?? 8D 8E ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B CF"));
		dector(this);
	}

	//E8 ? ? ? ? 85 FF 74 42 
	void SetMDL(MDLHandle_t h) {
		static auto _SetMDL = (void(__thiscall*)(void*, MDLHandle_t))rel32(Memory::Scan("client.dll", "E8 ?? ?? ?? ?? 85 FF 74 42"));
		_SetMDL(this, h);
	}

	//MDLHandle_t GetMDL( ) const;

	// Simple version of drawing; sets up bones for you
	// void Draw( const matrix3x4_t& rootToWorld );

	//NOTE: This version of draw assumes you've filled in the bone to world
	//matrix yourself by calling IStudioRender::LockBoneMatrices. The pointer
	//returned by that method needs to be passed into here
	//@param flags allows you to specify additional STUDIORENDER_ flags -- usually never necessary
	//       unless you need to (eg) forcibly disable shadows for some reason.
	void Draw(const matrix3x4_t& rootToWorld, const matrix3x4_t* pBoneToWorld, int flags = 0) {
		static auto _Draw = (void(__thiscall*)(void*, const matrix3x4_t&, const matrix3x4_t*, int))rel32(Memory::Scan("client.dll", "E8 ?? ?? ?? ?? 8B FB 8D 4D F4"));
		_Draw(this, rootToWorld, pBoneToWorld, flags);
	}

	void SetUpBones(const matrix3x4_t& shapeToWorld, int nMaxBoneCount, matrix3x4_t* pOutputMatrices, const float* pPoseParameters = NULL, MDLSquenceLayer_t* pSequenceLayers = NULL, int nNumSequenceLayers = 0) {
		static auto _SetUpBones = (void(__thiscall*)(void*, const matrix3x4_t&, int, matrix3x4_t*, const float*, MDLSquenceLayer_t*, int))rel32(Memory::Scan("client.dll", "E8 ?? ?? ?? ?? 8B CB 8B 01"));
		_SetUpBones(this, shapeToWorld, nMaxBoneCount, pOutputMatrices, pPoseParameters, pSequenceLayers, nNumSequenceLayers);
	}

	//void SetupBonesWithBoneMerge( const CStudioHdr *pMergeHdr, matrix3x4_t *pMergeBoneToWorld,
	// const CStudioHdr *pFollow, const matrix3x4_t *pFollowBoneToWorld, const matrix3x4_t &matModelToWorld );

	// studiohdr_t *GetStudioHdr( );
	virtual bool GetAttachment(int number, matrix3x4_t& matrix) { return false; };

private:
	// void UnreferenceMDL( );
	CUtlVector<CMDLAttachmentData> m_Attachments;
public:
	MDLHandle_t	m_MDLHandle;
	Color		m_Color;
	int			m_nSkin;
	int			m_nBody;
	int			m_nSequence;
	int			m_nLOD;
	float		m_flPlaybackRate;
	float		m_flTime;
	float		m_pFlexControls[96 * 4];
	Vector		m_vecViewTarget;
	bool	m_bWorldSpaceViewTarget;
	char pad[0x420]; // for safety, cuz lazy to reverse
};


void __fastcall Hooked::DrawModelExecute(void* ECX, void* EDX, IMatRenderContext* MatRenderContext, DrawModelState_t& DrawModelState, ModelRenderInfo_t& RenderInfo, matrix3x4_t* pCustomBoneToWorld) {
	g_Vars.globals.szLastHookCalled = XorStr("6");
	if (!MatRenderContext || !pCustomBoneToWorld || !g_Vars.globals.RenderIsReady || ECX != Interfaces::m_pModelRender.Xor())
		return oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pCustomBoneToWorld);

	C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
	if (!local || !Interfaces::m_pEngine->IsInGame())
		return oDrawModelExecute(ECX, MatRenderContext, DrawModelState, RenderInfo, pCustomBoneToWorld);

	static bool run_once = false;
	static bool run_once2 = false;

	if (g_Vars.esp.remove_scope_blur) {
		if (!run_once) {
			auto blur_overlay = Interfaces::m_pMatSystem->FindMaterial(("dev/scope_bluroverlay"), XorStr(TEXTURE_GROUP_OTHER));
			auto lens_dirt = Interfaces::m_pMatSystem->FindMaterial(("models/weapons/shared/scope/scope_lens_dirt"), XorStr(TEXTURE_GROUP_OTHER));
			auto xblur_mat = Interfaces::m_pMatSystem->FindMaterial(("dev/blurfilterx_nohdr"), XorStr(TEXTURE_GROUP_OTHER));
			auto yblur_mat = Interfaces::m_pMatSystem->FindMaterial(("dev/blurfiltery_nohdr"), XorStr(TEXTURE_GROUP_OTHER));

			xblur_mat->SetMaterialVarFlag(MATERIAL_VAR_NO_DRAW, true);
			yblur_mat->SetMaterialVarFlag(MATERIAL_VAR_NO_DRAW, true);
			blur_overlay->SetMaterialVarFlag(MATERIAL_VAR_NO_DRAW, true);
			lens_dirt->SetMaterialVarFlag(MATERIAL_VAR_NO_DRAW, true);
			run_once = true;
			run_once2 = false;
		}
	}
	else {
		if (!run_once2) {
			auto blur_overlay = Interfaces::m_pMatSystem->FindMaterial(("dev/scope_bluroverlay"), XorStr(TEXTURE_GROUP_OTHER));
			auto lens_dirt = Interfaces::m_pMatSystem->FindMaterial(("models/weapons/shared/scope/scope_lens_dirt"), XorStr(TEXTURE_GROUP_OTHER));
			auto xblur_mat = Interfaces::m_pMatSystem->FindMaterial(("dev/blurfilterx_nohdr"), XorStr(TEXTURE_GROUP_OTHER));
			auto yblur_mat = Interfaces::m_pMatSystem->FindMaterial(("dev/blurfiltery_nohdr"), XorStr(TEXTURE_GROUP_OTHER));

			xblur_mat->SetMaterialVarFlag(MATERIAL_VAR_NO_DRAW, false);
			yblur_mat->SetMaterialVarFlag(MATERIAL_VAR_NO_DRAW, false);
			blur_overlay->SetMaterialVarFlag(MATERIAL_VAR_NO_DRAW, false);
			lens_dirt->SetMaterialVarFlag(MATERIAL_VAR_NO_DRAW, false);
			run_once = false;
			run_once2 = true;
		}
	}

	// fuck a nigga named shadow
	if (strstr(RenderInfo.pModel->szName, XorStr("shadow")) != nullptr)
		return;

	Interfaces::IChams::Get()->DrawModel(ECX, MatRenderContext, DrawModelState, RenderInfo, pCustomBoneToWorld);
}

```

`CSGO SDK/Hooking/Hooks/EmitSound.cpp`:

```cpp
#include "../hooked.hpp"
#include "../../Utils/FnvHash.hpp"
#include "../../Features/Game/Prediction.hpp"

void __fastcall Hooked::hkEmitSound(IEngineSound* thisptr, uint32_t, void* filter, int ent_index, int channel, const char* sound_entry, unsigned int sound_entry_hash,
	const char* sample, float volume, float attenuation, int seed, int flags, int pitch, const Vector* origin, const Vector* direction,
	void* vec_origins, bool update_positions, float sound_time, int speaker_entity, int test) {
	g_Vars.globals.szLastHookCalled = XorStr("7");

	auto& prediction = Engine::Prediction::Instance();

	if (strstr(sound_entry, XorStr("c4_beep")) != nullptr) {
		g_Vars.globals.bBombActive = true;
		g_Vars.globals.bBombTicked = true;
	}

	if (prediction.InPrediction()) {
		flags |= 1 << 2;
		goto end;
	}

end:
	oEmitSound(thisptr, filter, ent_index, channel, sound_entry, sound_entry_hash, sample, volume, attenuation, seed, flags,
		pitch, origin, direction, vec_origins, update_positions, sound_time, speaker_entity, test);
}
```

`CSGO SDK/Hooking/Hooks/FrameStageNotify.cpp`:

```cpp


#include "../Hooked.hpp"
#include "../../Features/Game/Prediction.hpp"
#include "../../SDK/Displacement.hpp"
#include "../../SDK/sdk.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../Features/Visuals/EventLogger.hpp"
#include "../../Features/Visuals/GrenadePrediction.hpp"
#include "../../Features/Visuals/ESP.hpp"
#include "../../Renderer/Render.hpp"
#include "../../Features/Visuals/ExtendedEsp.hpp"
#include "../../Features/Miscellaneous/Movement.hpp"
#include "../../Utils/InputSys.hpp"
#include "../../SDK/Classes/Exploits.hpp"
#include "../../Features/Miscellaneous/Miscellaneous.hpp"
#include "../../Features/Game/SetupBones.hpp"
#include "../../Features/Rage/LagCompensation.hpp"
#include "../../Utils/Threading/threading.h"
#include "../../Features/Rage/AnimationSystem.hpp"
#include "../../Features/Rage/ShotInformation.hpp"
#include "../../Features/Rage/Resolver.hpp"
#include "../../Features/Miscellaneous/BulletBeamTracer.hpp"
#include "../../Features/Rage/TickbaseShift.hpp"
#include "../../Features/Visuals/CChams.hpp"
#include "../../Features/Miscellaneous/WeatherController.hpp"

#ifdef DEV
//#define SERVER_HITBOXES
#endif

#ifdef DEBUG_SHOOTING
extern bool debugShoot;
#endif

float WorldExposure = 0.0f;
float ModelAmbient = 0.0f;
float BloomScale = 0.0f;

extern bool MoveJitter;
extern Vector JitterOrigin;

float RenderViewOffsetZ = 0.0f;

bool RestoreData = false;
Vector org_backup, vel_backup;

#ifdef SERVER_HITBOXES
void draw_server_hitboxes(int index) {
	if (g_Vars.globals.m_iServerType != 8)
		return;

	auto get_player_by_index = [](int index) -> C_CSPlayer* { //i dont need this shit func for anything else so it can be lambda
		typedef C_CSPlayer* (__fastcall* player_by_index)(int);
		static auto player_index = reinterpret_cast<player_by_index>(Memory::Scan(XorStr("server.dll"), XorStr("85 C9 7E 2A A1")));

		if (!player_index)
			return false;

		return player_index(index);
	};

	static auto fn = Memory::Scan(XorStr("server.dll"), XorStr("55 8B EC 81 EC ? ? ? ? 53 56 8B 35 ? ? ? ? 8B D9 57 8B CE"));
	auto duration = -1.f;
	PVOID entity = nullptr;

	entity = get_player_by_index(index);

	if (!entity)
		return;

	__asm {
		pushad
		movss xmm1, duration
		push 0 // 0 - colored, 1 - blue
		mov ecx, entity
		call fn
		popad
	}
}
#endif

namespace Hooked
{
	enum PostProcessParameterNames_t
	{
		PPPN_FADE_TIME = 0,
		PPPN_LOCAL_CONTRAST_STRENGTH,
		PPPN_LOCAL_CONTRAST_EDGE_STRENGTH,
		PPPN_VIGNETTE_START,
		PPPN_VIGNETTE_END,
		PPPN_VIGNETTE_BLUR_STRENGTH,
		PPPN_FADE_TO_BLACK_STRENGTH,
		PPPN_DEPTH_BLUR_FOCAL_DISTANCE,
		PPPN_DEPTH_BLUR_STRENGTH,
		PPPN_SCREEN_BLUR_STRENGTH,
		PPPN_FILM_GRAIN_STRENGTH,

		POST_PROCESS_PARAMETER_COUNT
	};

	struct PostProcessParameters_t
	{
		PostProcessParameters_t()
		{
			memset(m_flParameters, 0, sizeof(m_flParameters));
			m_flParameters[PPPN_VIGNETTE_START] = 0.8f;
			m_flParameters[PPPN_VIGNETTE_END] = 1.1f;
		}

		float m_flParameters[POST_PROCESS_PARAMETER_COUNT];
	};

	void __fastcall FrameStageNotify(void* ecx, void* edx, ClientFrameStage_t stage) {
		g_Vars.globals.szLastHookCalled = XorStr("9");
		auto local = C_CSPlayer::GetLocalPlayer();

		static auto mat_postprocess_enable = Interfaces::m_pCvar->FindVar(XorStr("mat_postprocess_enable"));

		// paranoic af
		g_Vars.globals.HackIsReady = local
			&& Interfaces::m_pEngine->IsInGame()
			&& Interfaces::m_pClientState->m_nDeltaTick() > 0
			&& local->m_flSpawnTime() > 0.f;

		// hack.
		if (!g_Vars.globals.HackIsReady) {
			Interfaces::IChams::Get()->OnPostScreenEffects();
			//g_TickbaseController.bExploiting = false;

			Engine::WeatherController::Get()->ResetWeather();
			g_Vars.globals.bCreatedRain = false;
		}

		if (g_Vars.esp.remove_post_proccesing) {
			static auto PostProcessParameters = *reinterpret_cast<PostProcessParameters_t**>((uintptr_t)Memory::Scan(("client.dll"), ("0F 11 05 ? ? ? ? 0F 10 87")) + 3);
			static float backupblur = PostProcessParameters->m_flParameters[PPPN_VIGNETTE_BLUR_STRENGTH];

			mat_postprocess_enable->SetValue(XorStr("0"));

			float blur = g_Vars.esp.remove_post_proccesing ? 0.f : backupblur;
			if (PostProcessParameters->m_flParameters[PPPN_VIGNETTE_BLUR_STRENGTH] != blur)
				PostProcessParameters->m_flParameters[PPPN_VIGNETTE_BLUR_STRENGTH] = blur;
		}
		else
			mat_postprocess_enable->SetValue(XorStr("1"));

		// cache random values cuz valve random system cause performance issues
		if (!g_Vars.globals.RandomInit) {
			std::vector<std::pair<int, float>> biggsetPi1;
			int low_seeds_count = 0;
			int high_seeds_count = 0;
			int seeds_count = 0;
			int add_seeds_count = 0;
			bool low_seeds_created = false;
			bool high_seeds_created = false;

			while (seeds_count < 200 + add_seeds_count) {
				seeds_count++;
				bool add_seed = false;

				RandomSeed(seeds_count + 1);

				float pi1 = RandomFloat(0.0f, 6.2831855f);
				float seed = RandomFloat(0.0f, 1.0f);
				float pi2 = RandomFloat(0.0f, 6.2831855f);

				if (low_seeds_count >= 50)
					low_seeds_created = true;

				if (high_seeds_count >= 100)
					high_seeds_created = true;

				if (!low_seeds_created) {
					if (seed < 0.5f && low_seeds_count < 50) {
						add_seed = true;
						low_seeds_count++;
					}
					else
						add_seeds_count++;
				}
				else if (!high_seeds_created) {
					if (seed > 0.5f && high_seeds_count < 100) {
						add_seed = true;
						high_seeds_count++;
					}
					else
						add_seeds_count++;
				}

				if (add_seed) {
					g_Vars.globals.SpreadRandom[seeds_count - add_seeds_count].flRand1 = seed;
					g_Vars.globals.SpreadRandom[seeds_count - add_seeds_count].flRandPi1 = pi1;
					g_Vars.globals.SpreadRandom[seeds_count - add_seeds_count].flRand2 = seed;
					g_Vars.globals.SpreadRandom[seeds_count - add_seeds_count].flRandPi2 = pi2;
				}
			}

			g_Vars.globals.RandomInit = true;
		}

		if (stage == FRAME_RENDER_START && Interfaces::m_pEngine->IsConnected() && local) {

			if (g_Vars.r_rainalpha->fnChangeCallback.m_Size != 0)
				g_Vars.r_rainalpha->fnChangeCallback.m_Size = 0;

			if (g_Vars.r_rainalpha->GetFloat() != g_Vars.esp.weather_alpha * 0.01f) {
				g_Vars.r_rainalpha->SetValueFloat(g_Vars.esp.weather_alpha * 0.01f);
			}

			for (int i = 1; i <= Interfaces::m_pGlobalVars->maxClients; ++i) {
				auto player = C_CSPlayer::GetPlayerByIndex(i);

				if (!local)
					continue;

				if (!player || player->IsDead())
					continue;

				if (player == local || player->IsTeammate(local))
					continue;

				player_info_t player_info;
				if (!Interfaces::m_pEngine->GetPlayerInfo(i, &player_info))
					continue;

				auto lagData = Engine::LagCompensation::Get()->GetLagData(player->m_entIndex);
				if (!lagData.IsValid() || lagData->m_History.empty())
					continue;

				player->m_bSpotted() = g_Vars.misc.ingame_radar;
			}
		}

		if (stage == FRAME_RENDER_START) {
			if (g_Vars.globals.HackIsReady) {
				static bool bShouldCall = false;
				if (bShouldCall && !g_Vars.esp.weather) {
					Engine::WeatherController::Get()->ResetWeather();
					bShouldCall = false;
				}

				if (!bShouldCall && g_Vars.esp.weather) {
					g_Vars.globals.bCreatedRain = false;
					bShouldCall = true;
				}

				if (bShouldCall) {
					Engine::WeatherController::Get()->UpdateWeather();
				}
			}

			if (g_Vars.esp.remove_smoke) {
				static auto smoke_count = *reinterpret_cast<uintptr_t*>(Engine::Displacement.DT_SmokeGrenadeProjectile.m_nSmokeCount);
				if (smoke_count)
					*reinterpret_cast<int*>(smoke_count) = 0;
			}

			static bool bReset = false;
			if (g_Vars.esp.ambient_ligtning) {
				bReset = false;
				if (g_Vars.mat_ambient_light_r->GetFloat() != g_Vars.esp.ambient_ligtning_color.r)
					g_Vars.mat_ambient_light_r->SetValueFloat(g_Vars.esp.ambient_ligtning_color.r);

				if (g_Vars.mat_ambient_light_g->GetFloat() != g_Vars.esp.ambient_ligtning_color.g)
					g_Vars.mat_ambient_light_g->SetValueFloat(g_Vars.esp.ambient_ligtning_color.g);

				if (g_Vars.mat_ambient_light_b->GetFloat() != g_Vars.esp.ambient_ligtning_color.b)
					g_Vars.mat_ambient_light_b->SetValueFloat(g_Vars.esp.ambient_ligtning_color.b);
			}
			else {
				if (!bReset) {
					g_Vars.mat_ambient_light_r->SetValueFloat(0.f);
					g_Vars.mat_ambient_light_g->SetValueFloat(0.f);
					g_Vars.mat_ambient_light_b->SetValueFloat(0.f);
					bReset = true;
				}
			}
		}

		static QAngle qAimPunch, qViewPunch;
		static QAngle* qpAimPunch = nullptr, * qpViewPunch = nullptr;
		if (g_Vars.globals.HackIsReady) {
			static float networkedCycle = 0.f;
			static float animationTime = 0.f;

			RenderViewOffsetZ = local->m_vecViewOffset().z;

			auto viewModel = local->m_hViewModel();

			// m_flAnimTime : 0x260
			if (viewModel) {
				// onetap.su
				if (stage == FRAME_NET_UPDATE_POSTDATAUPDATE_START && g_Vars.globals.UnknownCycleFix && *(float*)(uintptr_t(viewModel.Get()) + Engine::Displacement.DT_BaseAnimating.m_flCycle) == 0.0f) {
					*(float*)(uintptr_t(viewModel.Get()) + Engine::Displacement.DT_BaseAnimating.m_flCycle) = networkedCycle;
					*(float*)(uintptr_t(viewModel.Get()) + Engine::Displacement.DT_BaseEntity.m_flAnimTime) = animationTime;
					g_Vars.globals.UnknownCycleFix = false;
				}

				networkedCycle = *(float*)(uintptr_t(viewModel.Get()) + Engine::Displacement.DT_BaseAnimating.m_flCycle);
				animationTime = *(float*)(uintptr_t(viewModel.Get()) + Engine::Displacement.DT_BaseEntity.m_flAnimTime);
			}

			if (stage == FRAME_RENDER_START && Interfaces::m_pEngine->IsConnected()) {


#ifdef SERVER_HITBOXES
				if (Interfaces::m_pInput->CAM_IsThirdPerson())
					draw_server_hitboxes(local->EntIndex());
#endif

				auto aim_punch = local->m_aimPunchAngle() * g_Vars.weapon_recoil_scale->GetFloat() * g_Vars.view_recoil_tracking->GetFloat();
				if (g_Vars.esp.remove_recoil_shake)
					local->pl().v_angle -= local->m_viewPunchAngle() /*+ aim_punch*/;

				if (g_Vars.esp.remove_recoil_punch)
					local->pl().v_angle -= aim_punch;

				local->pl().v_angle.Normalize();

				if (g_Vars.esp.remove_flash)
					local->m_flFlashDuration() = 0.0f;


				if (g_Vars.misc.third_person && g_Vars.misc.third_person_bind.enabled) {
					Interfaces::m_pPrediction->SetLocalViewAngles(g_Vars.globals.RegularAngles);
				}
			}


			// fix netvar compression
			auto& prediction = Engine::Prediction::Instance();
			if (Interfaces::m_pEngine->IsInGame())
				prediction.OnFrameStageNotify(stage);
		}
		else {
			g_Vars.globals.RenderIsReady = false;
		}

		if (stage == FRAME_RENDER_END) {
			static bool IsConnected = false;

			if (Interfaces::m_pEngine->IsConnected() && !IsConnected) {
				if (!_stricmp(Interfaces::m_pEngine->GetNetChannelInfo()->GetAddress(), XorStr("loopback")))
					g_Vars.globals.server_adress = XorStr("Local server");
				else
					g_Vars.globals.server_adress = Interfaces::m_pEngine->GetNetChannelInfo()->GetAddress();

				IsConnected = true;
			}

			if (!Interfaces::m_pEngine->IsConnected())
				IsConnected = false;

			if (Interfaces::m_pEngine->IsConnected()) {
				static auto g_GameRules = *(uintptr_t**)(Engine::Displacement.Data.m_GameRules);
				if (g_GameRules && *(bool*)(*(uintptr_t*)g_GameRules + 0x75)) {
					g_Vars.globals.server_adress = XorStr("Valve server");

					if (g_Vars.game_type->GetInt() == 0) { // classic
						g_Vars.globals.m_iServerType = 1;
						if (g_Vars.game_mode->GetInt() == 0) {
							g_Vars.globals.m_iGameMode = 1; // casual
						}
						else if (g_Vars.game_mode->GetInt() == 1) {
							g_Vars.globals.m_iGameMode = 2; // competitive
						}
						else if (g_Vars.game_mode->GetInt() == 2) {
							g_Vars.globals.m_iGameMode = 3; // scrimcomp2v2
						}
						else if (g_Vars.game_mode->GetInt() == 3) {
							g_Vars.globals.m_iGameMode = 4; // scrimcomp5v5
						}
					}
					else if (g_Vars.game_type->GetInt() == 1) { // gungame
						g_Vars.globals.m_iServerType = 2;
						if (g_Vars.game_mode->GetInt() == 0) {
							g_Vars.globals.m_iGameMode = 1; // gungameprogressive
						}
						else if (g_Vars.game_mode->GetInt() == 1) {
							g_Vars.globals.m_iGameMode = 2; // gungametrbomb
						}
						else if (g_Vars.game_mode->GetInt() == 2) {
							g_Vars.globals.m_iGameMode = 3; // deathmatch
						}
					}
					else if (g_Vars.game_type->GetInt() == 2) { //training
						g_Vars.globals.m_iServerType = 3;
						g_Vars.globals.m_iGameMode = 0;
					}
					else if (g_Vars.game_type->GetInt() == 3) { //custom
						g_Vars.globals.m_iServerType = 4;
						g_Vars.globals.m_iGameMode = 0;
					}
					else if (g_Vars.game_type->GetInt() == 4) { //cooperative
						g_Vars.globals.m_iServerType = 5;
						g_Vars.globals.m_iGameMode = 0;
					}
					else if (g_Vars.game_type->GetInt() == 5) { //skirmish
						g_Vars.globals.m_iServerType = 6;
						g_Vars.globals.m_iGameMode = 0;
					}
					else if (g_Vars.game_type->GetInt() == 6) { //freeforall ( danger zone )
						g_Vars.globals.m_iServerType = 7;
						g_Vars.globals.m_iGameMode = 0;
					}
				}
				else {
					// onetap way
					if (!_stricmp(Interfaces::m_pEngine->GetNetChannelInfo()->GetAddress(), XorStr("loopback")))
						g_Vars.globals.m_iServerType = 8; // local server
					else
						g_Vars.globals.m_iServerType = 9; // no valve server
				}
			}
			else
				g_Vars.globals.m_iServerType = -1; // no connected

			Interfaces::Miscellaneous::Get()->Main();

			if (g_Vars.esp.beam_enabled && g_Vars.globals.HackIsReady && g_Vars.globals.RenderIsReady && g_Vars.esp.beam_type == 1)
				IBulletBeamTracer::Get()->Main();

			if (g_Vars.globals.HackIsReady)
				g_Vars.globals.RenderIsReady = true;
		}

		// m_flAnimTime : 0x260
		if (g_Vars.globals.HackIsReady) {
			static float m_flCycle = 0.0f;
			static float m_flAnimTime = 0.f;

			auto viewModel = local->m_hViewModel().Get();

			if (viewModel) {
				static auto cycle_offset = Memory::FindInDataMap(local->GetPredDescMap(), XorStr("m_flCycle"));
				static auto anim_time_offset = Memory::FindInDataMap(local->GetPredDescMap(), XorStr("m_flAnimTime"));

				// onetap.su
				if (stage == FRAME_NET_UPDATE_POSTDATAUPDATE_START) {
					*(float*)(uintptr_t(local) + cycle_offset) = m_flCycle;
					*(float*)(uintptr_t(local) + anim_time_offset) = m_flAnimTime;
				}

				m_flCycle = *(float*)(uintptr_t(local) + cycle_offset);
				m_flAnimTime = *(float*)(uintptr_t(local) + anim_time_offset);
			}
		}

		if (g_Vars.globals.HackIsReady) {
			if (stage == FRAME_NET_UPDATE_END && Interfaces::m_pEngine->IsConnected()) {

				Engine::C_ShotInformation::Get()->Start();


				Engine::AnimationSystem::Get()->CollectData();
				Engine::AnimationSystem::Get()->Update();
				Threading::FinishQueue(true);
				Engine::LagCompensation::Get()->Update();

				// fix issues when players we are spectating scope in
				if (local && local->m_iObserverMode() == 5) {
					local->m_iFOV() = 90.f;
				}
			}
		}

		oFrameStageNotify(ecx, stage);

		if (stage == FRAME_NET_UPDATE_END) {
			Hooked::CL_FireEvents();
		}
	}

	void __fastcall View_Render(void* ecx, void* edx, vrect_t* rect) {
		oView_Render(ecx, rect);
	}
}
```

`CSGO SDK/Hooking/Hooks/GetScreenAspectRatio.cpp`:

```cpp
#include "../hooked.hpp"

namespace Hooked
{
	float __fastcall hkGetScreenAspectRatio(void* ECX, void* EDX, int32_t iWidth, int32_t iHeight) {
		g_Vars.globals.szLastHookCalled = XorStr("10");
		if (g_Vars.esp.aspect_ratio)
			return g_Vars.esp.aspect_ratio_value;
		else
			return oGetScreenAspectRatio(ECX, iWidth, iHeight);
	}
}
```

`CSGO SDK/Hooking/Hooks/InterpolateServerEntities.cpp`:

```cpp
#include "../Hooked.hpp"
#include "../../SDK/Displacement.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../Features/Game/SetupBones.hpp"
#include "../../Features/Rage/LagCompensation.hpp"

namespace Hooked
{
	void __cdecl InterpolateServerEntities() {
		g_Vars.globals.szLastHookCalled = XorStr("11");
		if (!g_Vars.globals.RenderIsReady)
			return oInterpolateServerEntities();

		C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer();
		if (!pLocal || !Interfaces::m_pEngine->IsInGame())
			return oInterpolateServerEntities();

		oInterpolateServerEntities();

		auto pStudioHdr = pLocal->m_pStudioHdr();

		// fix server model origin
		{
			pLocal->SetAbsAngles(QAngle(0.0f, g_Vars.globals.flRealYaw, 0.0f));

			matrix3x4_t matWorldMatrix{ };
			matWorldMatrix.AngleMatrix(QAngle(0.f, g_Vars.globals.flRealYaw, 0.f), pLocal->GetAbsOrigin());

			if (pStudioHdr) {
				uint8_t uBoneComputed[0x20] = { 0 };
				pLocal->BuildTransformations(pStudioHdr, g_Vars.globals.m_RealBonesPositions, g_Vars.globals.m_RealBonesRotations,
					matWorldMatrix, BONE_USED_BY_ANYTHING, uBoneComputed);
			}

			pLocal->InvalidateBoneCache();

			auto pBackupBones = pLocal->m_BoneAccessor().m_pBones;
			pLocal->m_BoneAccessor().m_pBones = pLocal->m_CachedBoneData().Base();

			if (pStudioHdr) {
				using AttachmentHelper_t = void(__thiscall*)(C_CSPlayer*, CStudioHdr*);
				static AttachmentHelper_t AttachmentHelperFn = (AttachmentHelper_t)Engine::Displacement.Function.m_AttachmentHelper;
				AttachmentHelperFn(pLocal, pStudioHdr);
			}

			pLocal->m_BoneAccessor().m_pBones = pBackupBones;
		}
	}
}
```

`CSGO SDK/Hooking/Hooks/IsBoxVisible.cpp`:

```cpp
#include "../hooked.hpp"

int __fastcall Hooked::hkIsBoxVisible(void* ECX, uint32_t, const Vector& mins, const Vector& maxs) {
	g_Vars.globals.szLastHookCalled = XorStr("12");
	static const auto ret = XorStr("\x85\xC0\x74\x2D\x83\x7D\x10\x00\x75\x1C");

	if (!memcmp(_ReturnAddress(), ret, 10))
		return 1;

	return Hooked::oIsBoxVisible(ECX, mins, maxs);
}
```

`CSGO SDK/Hooking/Hooks/IsConnected.cpp`:

```cpp
#include "../hooked.hpp"
#include "../../SDK/Classes/Player.hpp"

bool __fastcall Hooked::hkIsConnected(void) {
    /*
    - string: "IsLoadoutAllowed"
    - follow up v8::FunctionTemplate::New function
    - inside it go to second function that is being called after "if" statement.
    - after that u need to open first function that is inside it.[ before( *( int ( ** )( void ) )( *( _DWORD* ) dword_152350E4 + 516 ) )( ); ]
    */

    g_Vars.globals.szLastHookCalled = XorStr("13");

    static void* is_loadout_allowed = (void*)(Memory::Scan(XorStr("client.dll"), XorStr("84 C0 75 04 B0 01 5F")));
    if (is_loadout_allowed) {
        C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();

        if (g_Vars.misc.unlock_inventory && Interfaces::m_pEngine->IsInGame() && local && _ReturnAddress() == is_loadout_allowed)
            return false;
    }

    return Hooked::oIsConnected();
}
```

`CSGO SDK/Hooking/Hooks/IsPlayingDemo.cpp`:

```cpp
#include "../hooked.hpp"

bool __fastcall Hooked::hkIsPlayingDemo(void* ECX, void* EDX) {
	g_Vars.globals.szLastHookCalled = XorStr("14");

	if (!ECX)
		return Hooked::oIsPlayingDemo(ECX);

	if (!Interfaces::m_pEngine->IsInGame() || !Interfaces::m_pEngine->IsConnected())
		return Hooked::oIsPlayingDemo(ECX);

	if (g_Vars.misc.money_revealer) {
		if (*static_cast<uintptr_t*>(_ReturnAddress()) == 0x0975C084
			&& **reinterpret_cast<uintptr_t**>(uintptr_t(_AddressOfReturnAddress()) + 4) == 0x0C75C084)
			return true;
	}

	return Hooked::oIsPlayingDemo(ECX);
}

```

`CSGO SDK/Hooking/Hooks/ListLeavesInBox.cpp`:

```cpp
#include "../hooked.hpp"
#include "../../SDK/CVariables.hpp"
#include "../../SDK/Classes/entity.hpp"
#include "../../SDK/Displacement.hpp"
#include <intrin.h>

class RenderableInfo_t {
public:
	IClientRenderable* m_pRenderable;
	void* m_pAlphaProperty;
	int m_EnumCount;
	int m_nRenderFrame;
	unsigned short m_FirstShadow;
	unsigned short m_LeafList;
	short m_Area;
	uint16_t m_Flags;   // 0x0016
	uint16_t m_Flags2; // 0x0018
	Vector m_vecBloatedAbsMins;
	Vector m_vecBloatedAbsMaxs;
	Vector m_vecAbsMins;
	Vector m_vecAbsMaxs;
	int pad;
};

int __fastcall Hooked::ListLeavesInBox(void* ECX, void* EDX, Vector& mins, Vector& maxs, unsigned short* pList, int listMax) {
	g_Vars.globals.szLastHookCalled = XorStr("15");
	// occulusion getting updated on player movement/angle change,
	// in RecomputeRenderableLeaves ( https://github.com/pmrowla/hl2sdk-csgo/blob/master/game/client/clientleafsystem.cpp#L674 );
	// check for return in CClientLeafSystem::InsertIntoTree 
	if (!g_Vars.esp.skip_occulusion)
		return oListLeavesInBox(ECX, mins, maxs, pList, listMax);

	// 0x14244489  *( uint32_t* )
	if (uintptr_t(_ReturnAddress()) != Engine::Displacement.Data.m_uListLeavesInBoxReturn)
		return oListLeavesInBox(ECX, mins, maxs, pList, listMax);

	// get current renderable info from stack ( https://github.com/pmrowla/hl2sdk-csgo/blob/master/game/client/clientleafsystem.cpp#L1470 )
	auto info = *(RenderableInfo_t**)((uintptr_t)_AddressOfReturnAddress() + 0x14);
	if (!info || !info->m_pRenderable)
		return oListLeavesInBox(ECX, mins, maxs, pList, listMax);

	// check if disabling occulusion for players ( https://github.com/pmrowla/hl2sdk-csgo/blob/master/game/client/clientleafsystem.cpp#L1491 )
	auto base_entity = info->m_pRenderable->GetIClientUnknown()->GetBaseEntity();
	if (!base_entity || !base_entity->IsPlayer())
		return oListLeavesInBox(ECX, mins, maxs, pList, listMax);

	// fix render order, force translucent group ( https://www.unknowncheats.me/forum/2429206-post15.html )
	// AddRenderablesToRenderLists: https://i.imgur.com/hcg0NB5.png ( https://github.com/pmrowla/hl2sdk-csgo/blob/master/game/client/clientleafsystem.cpp#L2473 )
	info->m_Flags &= ~0x100;
	info->m_Flags2 |= 0xC0;

	// extend world space bounds to maximum ( https://github.com/pmrowla/hl2sdk-csgo/blob/master/game/client/clientleafsystem.cpp#L707 )
	static Vector map_min = Vector(MIN_COORD_FLOAT, MIN_COORD_FLOAT, MIN_COORD_FLOAT);
	static Vector map_max = Vector(MAX_COORD_FLOAT, MAX_COORD_FLOAT, MAX_COORD_FLOAT);
	auto count = oListLeavesInBox(ECX, map_min, map_max, pList, listMax);
	return count;
}

```

`CSGO SDK/Hooking/Hooks/LockCursor.cpp`:

```cpp
#include "../Hooked.hpp"
#include "../../SDK/Classes/Player.hpp"

void __stdcall Hooked::LockCursor() {
	g_Vars.globals.szLastHookCalled = XorStr("16");

	oLockCursor((void*)Interfaces::m_pSurface.Xor());

	auto pLocal = C_CSPlayer::GetLocalPlayer();

	bool state = true;
	if (!Interfaces::m_pEngine->IsInGame() || (pLocal && pLocal->IsDead()) || GUI::ctx->typing) {
		state = !g_Vars.globals.menuOpen;
	}

	Interfaces::m_pInputSystem->EnableInput(state);

	if (g_Vars.globals.menuOpen)
		Interfaces::m_pSurface->UnlockCursor();
}

```

`CSGO SDK/Hooking/Hooks/OnSoundStarted.cpp`:

```cpp
#include "../hooked.hpp"

namespace Hooked
{
	void __fastcall OnSoundStarted(void* ECX, void* EDX, int guid, StartSoundParams_t& params, char const* soundname) {
		g_Vars.globals.szLastHookCalled = XorStr("17");
		oOnSoundStarted(ECX, guid, params, soundname);
		//if ( params.ServerFlags & SV_SND_FROMSERVER )
		   //g_ServerSounds.ProcessSound( guid, params, soundname );
	}
}
```

`CSGO SDK/Hooking/Hooks/OverrideView.cpp`:

```cpp
#include "../Hooked.hpp"
#include "../../Features/Miscellaneous/Movement.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "../../Utils/InputSys.hpp"
#include "../../Features/Miscellaneous/VisibilityOptimization.hpp"
#include "../../Features/Visuals/GrenadePrediction.hpp"
#include "../../SDK/Classes/PropManager.hpp"

void __fastcall Hooked::OverrideView(void* ECX, int EDX, CViewSetup* vsView) {
	g_Vars.globals.szLastHookCalled = XorStr("18");
	C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();

	bool bOk = g_Vars.globals.RenderIsReady && vsView && local && Interfaces::m_pEngine->IsInGame();

	if (bOk) {
		IGrenadePrediction::Get()->View();
		if (!local->IsDead()) {
			auto weapon = (C_WeaponCSBaseGun*)(local->m_hActiveWeapon().Get());
			if (weapon) {
				auto weapon_data = weapon->GetCSWeaponData();
				if (weapon_data.IsValid()) {
					if (local->m_bIsScoped()) {
						if (g_Vars.esp.remove_scope_zoom) {
							if (weapon->m_zoomLevel() == 2) {
								vsView->fov = 45.0f;
							}
							else {
								vsView->fov = g_Vars.esp.world_fov;
							}
						}
					}
					else {
						vsView->fov = g_Vars.esp.world_fov;
					}
				}
			}
		}
		if (local->IsDead())
			vsView->fov = g_Vars.esp.world_fov;
		Interfaces::Movement::Get()->ThirdPerson();
	}

	oOverrideView(ECX, vsView);
}

```

`CSGO SDK/Hooking/Hooks/PacketStart.cpp`:

```cpp
#pragma once
#include "../Hooked.hpp"
#include "../../source.hpp"
#include "../../Features/Game/Prediction.hpp"

#include "../../SDK/Classes/Player.hpp"

void __fastcall Hooked::PacketStart(void* ecx, void*, int incoming_sequence, int outgoing_acknowledged) {
	g_Vars.globals.szLastHookCalled = XorStr("19");

	C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
	if (!local || local->IsDead() || !Interfaces::m_pEngine->IsInGame() || g_Vars.globals.cmds.empty())
		return oPacketStart(ecx, incoming_sequence, outgoing_acknowledged);

	for (auto it = g_Vars.globals.cmds.begin(); it != g_Vars.globals.cmds.end(); ++it) {
		if (*it == outgoing_acknowledged) {
			g_Vars.globals.cmds.erase(it);
			return oPacketStart(ecx, incoming_sequence, outgoing_acknowledged);
		}
	}
}

void __fastcall Hooked::PacketEnd(void* ecx, void*) {
	g_Vars.globals.szLastHookCalled = XorStr("20");
	Engine::Prediction::Instance()->PacketCorrection(reinterpret_cast<uintptr_t>(ecx));
	oPacketEnd(ecx);
}

bool __fastcall Hooked::ProcessTempEntities(void* ecx, void*, void* msg) {
	auto backup = Interfaces::m_pClientState->m_nMaxClients();

	Interfaces::m_pClientState->m_nMaxClients() = 1;
	auto ret = oProcessTempEntities(ecx, msg);
	Interfaces::m_pClientState->m_nMaxClients() = backup;

	Hooked::CL_FireEvents();

	return ret;
}
```

`CSGO SDK/Hooking/Hooks/PaintTraverse.cpp`:

```cpp
#include "../Hooked.hpp"
#include "../../Features/Rage/LagCompensation.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "../../SDK/Valve/CBaseHandle.hpp"
#include "../../Renderer/Render.hpp"
#include "../../Features/Visuals/ESP.hpp"
#include "../../Features/Visuals/GrenadePrediction.hpp"
#include "../../Features/Visuals/EventLogger.hpp"
#include "../../Features/Visuals/ExtendedEsp.hpp"
#include "../../Features/Miscellaneous/BulletBeamTracer.hpp"
#include "../../Features/Rage/TickbaseShift.hpp"

//#define TICKBASE_DEBUG 

namespace Hooked
{
	void PrintOnInject() {
		if (g_Vars.globals.c_login.empty() || strlen(g_Vars.globals.user_info.username) < 2)
			return;

		using FnL = void(__cdecl*)(Color const&, char const*, ...);
		static FnL MsgCol = reinterpret_cast<FnL>(GetProcAddress(GetModuleHandleA(XorStr("tier0.dll")), XorStr("?ConColorMsg@@YAXABVColor@@PBDZZ")));

		Color accent = g_Vars.menu.ascent.ToRegularColor();
		static int days_remaining = g_Vars.globals.user_info.sub_expiration / (60 * 60 * 24);
		//static int days_remaining = 335;

		int display_number = 0;
		std::string display_text = { };
		static bool lifetime = false;
		if (days_remaining < 0) {
			// u mad?
			exit(69);
			return;
		}

		static int aaa = -1;
		if (aaa == -1) {
			Interfaces::m_pEngine->ClientCmd_Unrestricted(XorStr("clear"));
			aaa = GetTickCount();
		}

		/*
		if( GetTickCount( ) - aaa > 500 && aaa != -1 ) {
			static bool done = false;

			if( !done ) {
				MsgCol( Color( 255, 255, 255, 255 ), XorStr( "Welcome to placeholderhook.\n" ) );
				done = true;
			}
		}*/
	}

	void __fastcall PaintTraverse(void* ecx, void* edx, unsigned int vguiPanel, bool forceRepaint, bool allowForce) {
		g_Vars.globals.szLastHookCalled = XorStr("21");
		std::string szPanelName = Interfaces::m_pPanel->GetName(vguiPanel);

		if (!strcmp(XorStr("HudZoom"), szPanelName.data()) && g_Vars.esp.remove_post_proccesing)
			return;

		oPaintTraverse(ecx, vguiPanel, forceRepaint, allowForce);

		if (!szPanelName.empty() && !szPanelName.compare(XorStr("MatSystemTopPanel"))) {
			ILoggerEvent::Get()->Main();
			IEsp::Get()->DrawAntiAimIndicator();

			IGrenadePrediction::Get()->Paint();
			IExtendedEsp::Get()->Start();

			IEsp::Get()->Main();
			IExtendedEsp::Get()->Finish();

			if (g_Vars.esp.beam_enabled && g_Vars.globals.HackIsReady && g_Vars.globals.RenderIsReady && g_Vars.esp.beam_type == 0)
				IBulletBeamTracer::Get()->Main();

			PrintOnInject();

		}
	}
}

```

`CSGO SDK/Hooking/Hooks/PlayerHooks.cpp`:

```cpp
#include "../Hooked.hpp"
#include "../../SDK/sdk.hpp"
#include "../../SDK/Displacement.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "../../Features/Miscellaneous/SkinChanger.hpp"
#include "../../Features/Rage/LagCompensation.hpp"
#include <intrin.h>

#include "../../Utils/Threading/threading.h"

ClientClass* CCSPlayerClass;
CreateClientClassFn oCreateCCSPlayer;
std::map< int, Hooked::PlayerHook > Hooked::player_hooks;

namespace Hooked
{
	void __fastcall PostDataUpdate(uintptr_t ecx, void* edx, int updateType);

	void __fastcall DoExtraBonesProccesing(C_CSPlayer* ecx, void* edx, CStudioHdr* hdr, Vector* pos, Quaternion* rotations, matrix3x4_t* transforma, void* bone_list, void* ik_context) {
		g_Vars.globals.szLastHookCalled = XorStr("22");
		//printf( "debp called\n" );

		auto& hook = player_hooks[ecx->m_entIndex];

		using Fn = void(__thiscall*)(C_CSPlayer*, CStudioHdr*, Vector*, Quaternion*, matrix3x4_t*, void*, void*);
		auto _do_extra_bone_processing = hook.clientHook.VCall< Fn >(197);

		if (ecx->m_fEffects() & 8)
			return;

		auto animState = ecx->m_PlayerAnimState();

		if (!animState)
			_do_extra_bone_processing(ecx, hdr, pos, rotations, transforma, bone_list, ik_context);

		const auto backup_tickcount = *reinterpret_cast<int32_t*>(animState + 8);
		*reinterpret_cast<int32_t*>(animState + 8) = 0;
		_do_extra_bone_processing(ecx, hdr, pos, rotations, transforma, bone_list, ik_context);
		*reinterpret_cast<int32_t*>(animState + 8) = backup_tickcount;
	}

	Hooked::PlayerHook::~PlayerHook() {
		clientHook.Destroy();
		renderableHook.Destroy();
		networkableHook.Destroy();
	}

	void Hooked::PlayerHook::SetHooks() {
		networkableHook.Hook(hkEntityRelease, 1);
		networkableHook.Hook(PostDataUpdate, 7);
		renderableHook.Hook(hkSetupBones, 13);
		//clientHook.Hook( DoExtraBonesProccesing, 197 );
	}

	bool __fastcall hkSetupBones(uintptr_t ecx, void* edx, matrix3x4_t* matrix, int bone_count, int bone_mask, float time) {
		if (!ecx)
			return false;

		auto player = reinterpret_cast<C_BasePlayer*>(ecx - 0x4);
		if (!player)
			return false;

		auto& hook = player_hooks[player->m_entIndex];

		using SetupBonesFn = bool(__thiscall*)(uintptr_t, matrix3x4_t*, int, int, float);
		auto oSetupBones = hook.renderableHook.VCall< SetupBonesFn >(13);

		C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer();

		if (!pLocal)
			return false;

		if (player->EntIndex() != pLocal->EntIndex()) {
			auto ret = oSetupBones(ecx, matrix, bone_count, bone_mask, time);
			return ret;
		}

		if (matrix) {
			if (bone_count < player->m_CachedBoneData().Count())
				return false;

			std::memcpy(matrix, player->m_CachedBoneData().Base(), sizeof(matrix3x4_t) * player->m_CachedBoneData().Count());
		}

		return true;
	}

	void __fastcall hkEntityRelease(uintptr_t ecx, void* edx) {
		g_Vars.globals.szLastHookCalled = XorStr("24");
		auto entity = reinterpret_cast<C_BaseEntity*>(ecx - 0x8);

		auto& hook = player_hooks[entity->m_entIndex];

		using Fn = void(__thiscall*)(uintptr_t);
		auto orig = hook.networkableHook.VCall< Fn >(1);

		player_hooks.erase(entity->m_entIndex);

		orig(ecx);
	}

	void __fastcall PostDataUpdate(uintptr_t ecx, void* edx, int updateType) {
		g_Vars.globals.szLastHookCalled = XorStr("25");
		auto entity = reinterpret_cast<C_CSPlayer*>(ecx - 0x8);

		auto& hook = player_hooks[entity->m_entIndex];

		using Fn = void(__thiscall*)(uintptr_t, int);
		auto orig = hook.networkableHook.VCall< Fn >(7);

		auto local = C_CSPlayer::GetLocalPlayer();

		if (local == entity)
			ISkinChanger::Get()->OnNetworkUpdate(true);

		orig(ecx, updateType);

		if (local == entity)
			ISkinChanger::Get()->OnNetworkUpdate(false);
	}

	IClientNetworkable* hkCreateCCSPlayer(int entnum, int serialNum) {
		g_Vars.globals.szLastHookCalled = XorStr("26");
		auto entity = (IClientNetworkable*)oCreateCCSPlayer(entnum, serialNum);

		auto& new_hook = player_hooks[entnum];
		new_hook.clientHook.Create((void*)((uintptr_t)entity - 0x8));
		new_hook.renderableHook.Create((void*)((uintptr_t)entity - 0x4));
		new_hook.networkableHook.Create(entity);
		new_hook.SetHooks();
		return entity;
	}
}

```

`CSGO SDK/Hooking/Hooks/Present.cpp`:

```cpp
#include "../Hooked.hpp"
#include <intrin.h>
#include "../../Utils/InputSys.hpp"
#include "../../Features/Visuals/Hitmarker.hpp"
#include "../../Renderer/Render.hpp"
#include "../../Features/Visuals/ESP.hpp"
#include "../../SDK/Classes/entity.hpp"
#include "../../SDK/Classes/player.hpp"

HRESULT __stdcall Hooked::Present(LPDIRECT3DDEVICE9 pDevice, const RECT* pSourceRect, const RECT* pDestRect, HWND hDestWindowOverride, const RGNDATA* pDirtyRegion) {
	g_Vars.globals.szLastHookCalled = XorStr("27");
	g_Vars.globals.m_pD3D9Device = pDevice;

	if (Render::DirectX::initialized) {
		// gay idc
		InputHelper::Update();

		if (InputSys::Get()->WasKeyPressed(g_Vars.menu.key.key)) {
			g_Vars.globals.menuOpen = !g_Vars.globals.menuOpen;
		}

		Render::DirectX::begin();
		{
			GUI::ctx->animation = g_Vars.globals.menuOpen ? (GUI::ctx->animation + (1.0f / 0.2f) * Interfaces::m_pGlobalVars->frametime)
				: ((GUI::ctx->animation - (1.0f / 0.2f) * Interfaces::m_pGlobalVars->frametime));

			if (!g_Vars.globals.menuOpen)
				GUI::ctx->ColorPickerInfo.HashedID = 0;

			GUI::ctx->animation = std::clamp<float>(GUI::ctx->animation, 0.f, 1.0f);

			if (g_Vars.antiaim.enabled && false) {
				auto m_LocalPlayer = C_CSPlayer::GetLocalPlayer();
				if (g_Vars.globals.HackIsReady && m_LocalPlayer && Interfaces::m_pEngine->IsInGame() && !m_LocalPlayer->IsDead()) {
					if (TICKS_TO_TIME(m_LocalPlayer->m_nTickBase()) >= g_Vars.globals.m_flBodyPred) {
						g_Vars.globals.m_flBodyPredNoob = Interfaces::m_pGlobalVars->curtime + 1.1f;
					}

					float flRemaining = g_Vars.globals.m_flBodyPredNoob - Interfaces::m_pGlobalVars->curtime;

					// get the absolute change between current lby and animated angle.
					float change = std::abs(Math::AngleNormalize(g_Vars.globals.m_flBody - g_Vars.globals.RegularAngles.y));

					bool moving = m_LocalPlayer->m_vecVelocity().Length2D() > 0.1f && !g_Vars.globals.Fakewalking;

					// fps enhancer
					if (change > 35.f && !moving && g_Vars.globals.m_bGround) {
						Render::DirectX::arc(Vector2D(75, Render::GetScreenSize().y - 40 - (Render::Engine::indi.m_size.m_height / 2)), 9.f, 1.f, Color(0, 0, 0, 75));
						Render::DirectX::arc(Vector2D(75, Render::GetScreenSize().y - 40 - (Render::Engine::indi.m_size.m_height / 2)), 8.f, 1.f, Color(0, 0, 0, 75));
						Render::DirectX::arc(Vector2D(75, Render::GetScreenSize().y - 40 - (Render::Engine::indi.m_size.m_height / 2)), 7.f, 1.f, Color(0, 0, 0, 75));
						Render::DirectX::arc(Vector2D(75, Render::GetScreenSize().y - 40 - (Render::Engine::indi.m_size.m_height / 2)), 6.f, 1.f, Color(0, 0, 0, 75));
						Render::DirectX::arc(Vector2D(75, Render::GetScreenSize().y - 40 - (Render::Engine::indi.m_size.m_height / 2)), 5.f, 1.f, Color(0, 0, 0, 75));
						Render::DirectX::arc(Vector2D(75, Render::GetScreenSize().y - 40 - (Render::Engine::indi.m_size.m_height / 2)), 4.f, 1.f, Color(0, 0, 0, 75));

						Render::DirectX::arc(Vector2D(75, Render::GetScreenSize().y - 40 - (Render::Engine::indi.m_size.m_height / 2)), 7.f, (flRemaining / 1.1f), Color(150, 200, 60, 200), false);
						Render::DirectX::arc(Vector2D(75, Render::GetScreenSize().y - 40 - (Render::Engine::indi.m_size.m_height / 2)), 6.f, (flRemaining / 1.1f), Color(150, 200, 60), false);
						Render::DirectX::arc(Vector2D(74, Render::GetScreenSize().y - 40 - (Render::Engine::indi.m_size.m_height / 2)), 6.f, (flRemaining / 1.1f), Color(150, 200, 60), false);
						Render::DirectX::arc(Vector2D(76, Render::GetScreenSize().y - 40 - (Render::Engine::indi.m_size.m_height / 2)), 6.f, (flRemaining / 1.1f), Color(150, 200, 60), false);
						Render::DirectX::arc(Vector2D(75, Render::GetScreenSize().y - 40 - (Render::Engine::indi.m_size.m_height / 2)), 5.f, (flRemaining / 1.1f), Color(150, 200, 60, 200), false);
					}
				}
			}

			Hitmarkers::RenderHitmarkers();
			Menu::Draw();
		}
		Render::DirectX::end();

		if (g_Vars.misc.instant_stop_key.key != VK_SHIFT) {
			g_Vars.misc.instant_stop_key.key = VK_SHIFT;
		}

		// chat isn't open && console isn't open
		if (!Interfaces::m_pClient->IsChatRaised() && !Interfaces::m_pEngine->Con_IsVisible() && !g_Vars.globals.menuOpen) {
			// we aren't tabbed out
				// shit compiler, that's why no ternary operators
			if (InputHelper::Pressed(g_Vars.antiaim.manual_left_bind.key)) {
				if (g_Vars.globals.manual_aa == 0)
					g_Vars.globals.manual_aa = -1;
				else {
					g_Vars.globals.manual_aa = 0;
				}
			}

			if (InputHelper::Pressed(g_Vars.antiaim.manual_right_bind.key)) {
				if (g_Vars.globals.manual_aa == 2)
					g_Vars.globals.manual_aa = -1;
				else {
					g_Vars.globals.manual_aa = 2;
				}
			}

			if (InputHelper::Pressed(g_Vars.antiaim.manual_back_bind.key)) {
				if (g_Vars.globals.manual_aa == 1)
					g_Vars.globals.manual_aa = -1;
				else {
					g_Vars.globals.manual_aa = 1;
				}
			}


			for (auto& keybind : g_keybinds) {
				if (keybind == &g_Vars.misc.third_person_bind)
					continue;

				// hold
				if (keybind->cond == KeyBindType::HOLD) {
					keybind->enabled = InputHelper::Down(keybind->key);
				}

				// toggle
				else if (keybind->cond == KeyBindType::TOGGLE) {
					if (InputHelper::Pressed(keybind->key))
						keybind->enabled = !keybind->enabled;
				}

				// always on
				else if (keybind->cond == KeyBindType::ALWAYS_ON) {
					keybind->enabled = true;
				}

				// off hold
				else if (keybind->cond == KeyBindType::OFFHOLD) {
					keybind->enabled = !InputHelper::Down(keybind->key);
				}
			}
		}

		// handle thirdperson keybinds just for destiny
		// #STFU!
		if (!Interfaces::m_pClient->IsChatRaised() && !Interfaces::m_pEngine->Con_IsVisible()) {
			// hold
			if (g_Vars.misc.third_person_bind.cond == KeyBindType::HOLD) {
				g_Vars.misc.third_person_bind.enabled = InputHelper::Down(g_Vars.misc.third_person_bind.key);
			}

			// toggle
			else if (g_Vars.misc.third_person_bind.cond == KeyBindType::TOGGLE) {
				if (InputHelper::Pressed(g_Vars.misc.third_person_bind.key))
					g_Vars.misc.third_person_bind.enabled = !g_Vars.misc.third_person_bind.enabled;
			}

			// always on
			else if (g_Vars.misc.third_person_bind.cond == KeyBindType::ALWAYS_ON) {
				g_Vars.misc.third_person_bind.enabled = true;
			}
		}

		InputSys::Get()->SetScrollMouse(0.f);
	}

	return oPresent(pDevice, pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion);
}
```

`CSGO SDK/Hooking/Hooks/RecvProxyHooks.cpp`:

```cpp
#include "../Hooked.hpp"
#include "../../SDK/Displacement.hpp"
#include "../../SDK/sdk.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Valve/CBaseHandle.hpp"
#include "../../Features/Rage/LagCompensation.hpp"
#include "../../Features/Rage/Resolver.hpp"

namespace Hooked
{
	void m_nSmokeEffectTickBegin(CRecvProxyData* pData, void* pStruct, void* pOut) {
		g_Vars.globals.szLastHookCalled = XorStr("28");

		if (!pData || !pStruct || !pOut)
			return;

		Interfaces::m_pDidSmokeEffectSwap->GetOriginalFunction()(pData, pStruct, pOut);
		if (g_Vars.esp.remove_smoke) {
			*reinterpret_cast<bool*>(reinterpret_cast<uintptr_t>(pOut) + 0x1) = true;
		}
	}

	void RecvProxy_m_flAbsYaw(CRecvProxyData* pData, void* pStruct, void* pOut) {
		g_Vars.globals.szLastHookCalled = XorStr("29");

		if (!pData || !pStruct || !pOut)
			return;

		Interfaces::m_pFlAbsYawSwap->GetOriginalFunction()(pData, pStruct, pOut);

		if (Interfaces::m_pEngine->IsConnected() && Interfaces::m_pEngine->IsInGame()) {
			CBaseHandle handle = *(CBaseHandle*)((uintptr_t)pStruct + Engine::Displacement.DT_CSRagdoll.m_hPlayer);
			if (handle.IsValid()) {
				auto player = (C_CSPlayer*)handle.Get();

				if (player) {
					auto lag_data = Engine::LagCompensation::Get()->GetLagData(player->EntIndex()).Xor();
					if (lag_data && lag_data->m_History.size()) {
						lag_data->m_bGotAbsYaw = true;
						lag_data->m_flAbsYawHandled = pData->m_Value.m_Float;
					}
				}
			}

			Interfaces::m_pFlAbsYawSwap->GetOriginalFunction()(pData, pStruct, pOut);
		}
	}

	void m_bClientSideAnimation(CRecvProxyData* pData, void* pStruct, void* pOut) {
		auto local = C_CSPlayer::GetLocalPlayer();
		if (!local || local->IsDead())
			return Interfaces::m_bClientSideAnimationSwap->GetOriginalFunction()(pData, pStruct, pOut);

		auto player = (C_CSPlayer*)pStruct;

		if (player && player->IsPlayer() && !player->IsTeammate(local))
			*(int*)pOut = (g_Vars.globals.m_bUpdatingAnimations ? 1 : 0);
	}

	void RecvProxy_PlaybackRate(CRecvProxyData* pData, void* pStruct, void* pOut) {
		g_Vars.globals.szLastHookCalled = XorStr("47");
		// PlaybackRate
		Interfaces::m_pPlaybackRateSwap->GetOriginalFunction()(pData, pStruct, pOut);

		C_CSPlayer* LocalPlayer = C_CSPlayer::GetLocalPlayer();

		if (!LocalPlayer)
			return;

		auto pAnimOverlay = (C_AnimationLayer*)pStruct;
		if (pAnimOverlay) {
			auto player = (C_BasePlayer*)pAnimOverlay->m_pOwner;
			if (!player || player == LocalPlayer)
				return;

			auto& lag_data = Engine::LagCompensation::Get()->GetLagData(player->EntIndex());
			if (lag_data.Xor()) {
				lag_data->m_flRate = pAnimOverlay->m_flPlaybackRate;
				lag_data->m_bRateCheck = true;
			}
		}
	}
}

```

`CSGO SDK/Hooking/Hooks/RenderView.cpp`:

```cpp
#include "../hooked.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/CVariables.hpp"

class N00000B3B {
public:
	char pad_0x0000[0xC4]; //0x0000
	Vector N00000B6D; //0x00C4
	char pad_0x00D0[0x770]; //0x00D0

}; //Size=0x0840

void __fastcall Hooked::hkRenderView(void* ECX, void* EDX, const CViewSetup& view, CViewSetup& hudViewSetup, int nClearFlags, int whatToDraw) {
	g_Vars.globals.szLastHookCalled = XorStr("30");
	uintptr_t arg_0;

	oRenderView(ECX, view, hudViewSetup, nClearFlags, whatToDraw);
}
```

`CSGO SDK/Hooking/Hooks/Reset.cpp`:

```cpp
#include "../Hooked.hpp"
#include "../../Renderer/Render.hpp"

HRESULT __stdcall Hooked::Reset(IDirect3DDevice9* pDevice, D3DPRESENT_PARAMETERS* pPresentationParameters) {
	g_Vars.globals.szLastHookCalled = XorStr("31");

	Render::DirectX::invalidate();
	auto ret = oReset(pDevice, pPresentationParameters);

	if (ret == D3D_OK) {
		Render::DirectX::init(pDevice);
	}

	return ret;
}

```

`CSGO SDK/Hooking/Hooks/RetrieveMessage.cpp`:

```cpp
#include "../Hooked.hpp"

enum ECsgoGCMsg {
	k_EMsgGCCStrike15_v2_Base = 9100,
	k_EMsgGCCStrike15_v2_MatchmakingStart = 9101,
	k_EMsgGCCStrike15_v2_MatchmakingStop = 9102,
	k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing = 9103,
	k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = 9104,
	k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = 9105,
	k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse = 9106,
	k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = 9107,
	k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats = 9108,
	k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello = 9109,
	k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello = 9110,
	k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd = 9111,
	k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = 9112,
	k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick = 9113,
	k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = 9114,
	k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats = 9115,
	k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = 9116,
	k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = 9117,
	k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty = 9118,
	k_EMsgGCCStrike15_v2_ClientReportPlayer = 9119,
	k_EMsgGCCStrike15_v2_ClientReportServer = 9120,
	k_EMsgGCCStrike15_v2_ClientCommendPlayer = 9121,
	k_EMsgGCCStrike15_v2_ClientReportResponse = 9122,
	k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery = 9123,
	k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse = 9124,
	k_EMsgGCCStrike15_v2_WatchInfoUsers = 9126,
	k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile = 9127,
	k_EMsgGCCStrike15_v2_PlayersProfile = 9128,
	k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = 9131,
	k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = 9132,
	k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = 9133,
	k_EMsgGCCStrike15_v2_GC2ClientTextMsg = 9134,
	k_EMsgGCCStrike15_v2_Client2GCTextMsg = 9135,
	k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops = 9136,
	k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification = 9137,
	k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2 = 9138,
	k_EMsgGCCStrike15_v2_MatchList = 9139,
	k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = 9140,
	k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames = 9141,
	k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate = 9142,
	k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo = 9144,
	k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = 9145,
	k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames = 9146,
	k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo = 9147,
	k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest = 9148,
	k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse = 9149,
	k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo = 9150,
	k_EMsgGCToGCReloadVersions = 9151,
	k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote = 9152,
	k_EMsgGCCStrike15_v2_Server2GCClientValidate = 9153,
	k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = 9154,
	k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = 9155,
	k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = 9156,
	k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = 9157,
	k_EMsgGCCStrike15_v2_AccountPrivacySettings = 9158,
	k_EMsgGCCStrike15_v2_SetMyActivityInfo = 9159,
	k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions = 9160,
	k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions = 9161,
	k_EMsgGCCStrike15_v2_DraftSummary = 9162,
	k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData = 9163,
	k_EMsgGCCStrike15_v2_ClientRequestJoinServerData = 9164,
	k_EMsgGCCStrike15_v2_ClientRequestNewMission = 9165,
	k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded = 9166,
	k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo = 9167,
	k_EMsgGC_GlobalGame_Subscribe = 9168,
	k_EMsgGC_GlobalGame_Unsubscribe = 9169,
	k_EMsgGC_GlobalGame_Play = 9170,
	k_EMsgGCCStrike15_v2_AcknowledgePenalty = 9171,
	k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = 9172,
	k_EMsgGCCStrike15_v2_GC2ClientGlobalStats = 9173,
	k_EMsgGCCStrike15_v2_Client2GCStreamUnlock = 9174,
	k_EMsgGCCStrike15_v2_FantasyRequestClientData = 9175,
	k_EMsgGCCStrike15_v2_FantasyUpdateClientData = 9176,
	k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket = 9177,
	k_EMsgGCCStrike15_v2_ClientToGCRequestTicket = 9178,
	k_EMsgGCCStrike15_v2_ClientToGCRequestElevate = 9179,
	k_EMsgGCCStrike15_v2_GlobalChat = 9180,
	k_EMsgGCCStrike15_v2_GlobalChat_Subscribe = 9181,
	k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe = 9182,
	k_EMsgGCCStrike15_v2_ClientAuthKeyCode = 9183,
	k_EMsgGCCStrike15_v2_GotvSyncPacket = 9184,
	k_EMsgGCCStrike15_v2_ClientPlayerDecalSign = 9185,
	k_EMsgGCCStrike15_v2_ClientLogonFatalError = 9187,
	k_EMsgGCCStrike15_v2_ClientPollState = 9188,
	k_EMsgGCCStrike15_v2_Party_Register = 9189,
	k_EMsgGCCStrike15_v2_Party_Unregister = 9190,
	k_EMsgGCCStrike15_v2_Party_Search = 9191,
	k_EMsgGCCStrike15_v2_Party_Invite = 9192,
	k_EMsgGCCStrike15_v2_Account_RequestCoPlays = 9193,
	k_EMsgGCCStrike15_v2_ClientGCRankUpdate = 9194,
	k_EMsgGCCStrike15_v2_ClientRequestOffers = 9195,
	k_EMsgGCCStrike15_v2_ClientAccountBalance = 9196,
	k_EMsgGCCStrike15_v2_ClientPartyJoinRelay = 9197,
	k_EMsgGCCStrike15_v2_ClientPartyWarning = 9198,
	k_EMsgGCCStrike15_v2_MatchmakingServerMatchEndPartial = 9199,
	k_EMsgGCCStrike15_v2_ClientRequestSouvenir = 9204
};

EGCResults __fastcall Hooked::hkRetrieveMessage(void* ecx, void* edx, uint32_t* punMsgType, void* pubDest, uint32_t cubDest, uint32_t* pcubMsgSize) {

	EGCResults status = oRetrieveMessage(ecx, punMsgType, pubDest, cubDest, pcubMsgSize);
	if (status != k_EGCResultOK)
		return status;

	auto msg = *punMsgType & 0x7FFFFFFF;

	//printf( "[->] Message got from GC [%d]!\n", msg );

	if (g_Vars.misc.auto_accept && msg == ECsgoGCMsg::k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket)
	{
		auto SetLocalPlayerReady = [&]() -> void {
			// xref deferred ( if ( sub_108E78E0(str, "deferred") ) )

			static auto SetLocalPlayerReadyFn = reinterpret_cast<bool(__stdcall*)(const char*)>(Memory::Scan(XorStr("client.dll"), XorStr("55 8B EC 83 E4 F8 8B 4D 08 BA ? ? ? ? E8 ? ? ? ? 85 C0 75 12")));
			if (SetLocalPlayerReadyFn)
				SetLocalPlayerReadyFn(XorStr(""));
		};

		SetLocalPlayerReady();
	}

	return status;
}
```

`CSGO SDK/Hooking/Hooks/RunCommand.cpp`:

```cpp
#include "../Hooked.hpp"
#include "../../Features/Game/Prediction.hpp"
#include "../../SDK/Classes/weapon.hpp"
#include "../../SDK/Valve/CBaseHandle.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../SDK/Displacement.hpp"
#include "../../Features/Miscellaneous/Miscellaneous.hpp"
#include <deque>
#include "../../Features/Rage/TickbaseShift.hpp"

#ifndef DEV
#include "../../Utils/InputSys.hpp"
#endif


void FixViewmodel(CUserCmd* cmd, bool restore) {
	static float cycleBackup = 0.0f;
	static bool weaponAnimation = false;

	C_CSPlayer* player = C_CSPlayer::GetLocalPlayer();
	auto viewModel = player->m_hViewModel().Get();
	if (viewModel) {
		if (restore) {
			weaponAnimation = cmd->weaponselect > 0 || cmd->buttons & (IN_ATTACK2 | IN_ATTACK);
			cycleBackup = *(float*)(uintptr_t(viewModel) + 0xA14);
		}
		else if (weaponAnimation && !g_Vars.globals.FixCycle) {
			g_Vars.globals.FixCycle = *(float*)(uintptr_t(viewModel) + 0xA14) == 0.0f && cycleBackup > 0.0f;
		}
	}
}

namespace Hooked
{
	void __fastcall RunCommand(void* ecx, void* edx, C_CSPlayer* player, CUserCmd* ucmd, IMoveHelper* moveHelper) {
		g_Vars.globals.szLastHookCalled = XorStr("32");
		C_CSPlayer* local = C_CSPlayer::GetLocalPlayer();
		if (!local || !player || player != local) {
			oRunCommand(ecx, player, ucmd, moveHelper);
			return;
		}

		if (g_TickbaseController.IsTickcountValid(ucmd->tick_count)) {
			ucmd->hasbeenpredicted = true;
			return;
		}

		FixViewmodel(ucmd, true);

		auto backup = g_Vars.sv_show_impacts->GetInt();
		if (g_Vars.misc.impacts_spoof) {
			g_Vars.sv_show_impacts->SetValue(2);
		}

		static int nTickbaseRecords[150] = { };
		static bool bInAttackRecords[150] = { };
		static bool bCanShootRecords[150] = { };

		nTickbaseRecords[ucmd->command_number % 150] = player->m_nTickBase();
		bInAttackRecords[ucmd->command_number % 150] = (ucmd->buttons & (IN_ATTACK2 | IN_ATTACK)) != 0;
		bCanShootRecords[ucmd->command_number % 150] = player->CanShoot(true);

		auto FixPostponeTime = [player](int command_number) {
			auto weapon = (C_WeaponCSBaseGun*)player->m_hActiveWeapon().Get();
			if (weapon) {
				auto postpone = FLT_MAX;
				if (weapon->m_iItemDefinitionIndex() == WEAPON_REVOLVER) {
					auto tick_rate = int(1.0f / Interfaces::m_pGlobalVars->interval_per_tick);
					if (tick_rate >> 1 > 1) {
						auto cmd_nr = command_number - 1;
						auto shoot_nr = 0;
						for (int i = 1; i < tick_rate >> 1; ++i) {
							shoot_nr = cmd_nr;
							if (!bInAttackRecords[cmd_nr % 150] || !bCanShootRecords[cmd_nr % 150])
								break;

							--cmd_nr;
						}

						if (shoot_nr) {
							auto tick = 1 - (signed int)(float)(-0.03348f / Interfaces::m_pGlobalVars->interval_per_tick);
							if (command_number - shoot_nr >= tick)
								postpone = TICKS_TO_TIME(nTickbaseRecords[(tick + shoot_nr) % 150]) + 0.2f;
						}
					}
					weapon->m_flPostponeFireReadyTime() = postpone;
				}
			}
		};

		float flVelocityModifierBackup = local->m_flVelocityModifier();

		FixPostponeTime(ucmd->command_number);

		//	if( g_Vars.globals.m_bInCreateMove && ucmd->command_number == Interfaces::m_pClientState->m_nLastCommandAck( ) + 1 )
		//		local->m_flVelocityModifier( ) = g_Vars.globals.LastVelocityModifier;

		Engine::Prediction::Instance()->StoreNetvarCompression(ucmd);

		oRunCommand(ecx, player, ucmd, moveHelper);

		Engine::Prediction::Instance()->RestoreNetvarCompression(ucmd);

		FixPostponeTime(ucmd->command_number);

		//	if( !g_Vars.globals.m_bInCreateMove )
		//		local->m_flVelocityModifier( ) = flVelocityModifierBackup;

		if (g_Vars.misc.impacts_spoof) {
			g_Vars.sv_show_impacts->SetValue(backup);
		}

		FixViewmodel(ucmd, false);

		local->m_vphysicsCollisionState() = 0;

		if (!local->IsDead()) {
			auto& prediction = Engine::Prediction::Instance();
			prediction.OnRunCommand(local, ucmd);
		}
	}
}

```

`CSGO SDK/Hooking/Hooks/SendNetMsg.cpp`:

```cpp
#include "../hooked.hpp"
#include "../../Utils/InputSys.hpp"
#include "../../SDK/Classes/Exploits.hpp"
#include "../../SDK/Displacement.hpp"
#include "../../Features/Rage/ExtendedBactrack.hpp"
#include "../../SDK/Classes/Player.hpp"
#include "../../Features/Rage/TickbaseShift.hpp"

struct CIncomingSequence {
	int InSequence;
	int ReliableState;
};

std::vector<CIncomingSequence> IncomingSequences;

void WriteUsercmd(bf_write* buf, CUserCmd* incmd, CUserCmd* outcmd) {
	__asm
	{
		mov     ecx, buf
		mov     edx, incmd
		push    outcmd
		call    Engine::Displacement.Function.m_WriteUsercmd
		add     esp, 4
	}
}

void BypassChokeLimit(CCLCMsg_Move_t* CL_Move, INetChannel* pNetChan) {
	// not shifting or dont need do extra fakelag
	if (CL_Move->m_nNewCommands != 15 || Interfaces::m_pClientState->m_nChokedCommands() <= 14)
		return;

	using assign_lol = std::string& (__thiscall*)(void*, uint8_t*, size_t);
	auto assign_std_autistic_string = (assign_lol)Engine::Displacement.Function.m_StdStringAssign;

	// rebuild CL_SendMove
	uint8_t data[4000];
	bf_write buf;
	buf.m_nDataBytes = 4000;
	buf.m_nDataBits = 32000;
	buf.m_pData = data;
	buf.m_iCurBit = false;
	buf.m_bOverflow = false;
	buf.m_bAssertOnOverflow = false;
	buf.m_pDebugName = false;
	int numCmd = Interfaces::m_pClientState->m_nChokedCommands() + 1;
	int nextCmdNr = Interfaces::m_pClientState->m_nLastOutgoingCommand() + numCmd;
	if (numCmd > 62)
		numCmd = 62;

	bool bOk = true;

	auto to = nextCmdNr - numCmd + 1;
	auto from = -1;
	if (to <= nextCmdNr) {
		int newcmdnr = to >= (nextCmdNr - numCmd + 1);
		do {
			bOk = bOk && Interfaces::m_pInput->WriteUsercmdDeltaToBuffer(0, &buf, from, to, to >= newcmdnr);
			from = to++;
		} while (to <= nextCmdNr);
	}

	if (bOk) {
		if (g_TickbaseController.iCommandsToShift > 0) {
			CUserCmd from_cmd, to_cmd;
			from_cmd = Interfaces::m_pInput->m_pCommands[nextCmdNr % MULTIPLAYER_BACKUP];
			to_cmd = from_cmd;
			to_cmd.tick_count = INT_MAX;

			do {
				if (numCmd >= 62) {
					g_TickbaseController.iCommandsToShift = 0;
					break;
				}

				to_cmd.command_number++;
				WriteUsercmd(&buf, &to_cmd, &from_cmd);

				g_TickbaseController.iCommandsToShift--;
				numCmd++;
			} while (g_TickbaseController.iCommandsToShift > 0);
		}
		else {
			g_TickbaseController.iCommandsToShift = 0;
		}

		// bypass choke limit
		CL_Move->m_nNewCommands = numCmd;
		CL_Move->m_nBackupCommands = 0;

		int curbit = (buf.m_iCurBit + 7) >> 3;
		assign_std_autistic_string(CL_Move->m_data, buf.m_pData, curbit);
	}
}

bool __fastcall Hooked::SendNetMsg(INetChannel* pNetChan, void* edx, INetMessage& msg, bool bForceReliable, bool bVoice) {
	g_Vars.globals.szLastHookCalled = XorStr("33");
	if (pNetChan != Interfaces::m_pEngine->GetNetChannelInfo() || !g_Vars.globals.HackIsReady)
		return oSendNetMsg(pNetChan, msg, bForceReliable, bVoice);

	if (msg.GetType() == 14) // Return and don't send messsage if its FileCRCCheck
		return false;
	/*
	if( msg.GetGroup( ) == 11 ) {
		BypassChokeLimit( ( CCLCMsg_Move_t* )&msg, pNetChan );
	}
	else*/ if (msg.GetGroup() == 9) { // group 9 is VoiceData
	// Fixing fakelag with voice
		bVoice = true;
		g_Vars.globals.VoiceEnable = true;
	}
	else
	g_Vars.globals.VoiceEnable = false;

	return oSendNetMsg(pNetChan, msg, bForceReliable, bVoice);
}

#define NET_FRAMES_BACKUP 64 // must be power of 2. 
#define NET_FRAMES_MASK ( NET_FRAMES_BACKUP - 1 )
int __fastcall Hooked::SendDatagram(INetChannel* pNetChan, void* edx, void* buf) {
	g_Vars.globals.szLastHookCalled = XorStr("33");
	if (pNetChan != Interfaces::m_pEngine->GetNetChannelInfo() || !g_Vars.globals.HackIsReady || !g_Vars.misc.extended_backtrack || !g_Vars.misc.extended_backtrack_key.enabled)
		return oSendDatagram(pNetChan, buf);

	auto v10 = pNetChan->m_nInSequenceNr;
	auto v16 = pNetChan->m_nInReliableState;
	auto v17 = pNetChan->GetLatency(FLOW_OUTGOING);
	if (v17 < g_Vars.misc.extended_backtrack_time) {
		auto v13 = pNetChan->m_nInSequenceNr - TIME_TO_TICKS(g_Vars.misc.extended_backtrack_time - v17);
		pNetChan->m_nInSequenceNr = v13;
		for (auto& seq : IncomingSequences) {
			if (seq.InSequence != v13)
				continue;

			pNetChan->m_nInReliableState = seq.ReliableState;
		}
	}

	auto result = oSendDatagram(pNetChan, buf);
	pNetChan->m_nInSequenceNr = v10;
	pNetChan->m_nInReliableState = v16;
	return result;
}

void __fastcall Hooked::ProcessPacket(INetChannel* pNetChan, void* edx, void* packet, bool header) {
	g_Vars.globals.szLastHookCalled = XorStr("34");
	oProcessPacket(pNetChan, packet, header);

	IncomingSequences.push_back(CIncomingSequence{ pNetChan->m_nInSequenceNr, pNetChan->m_nInReliableState });
	for (auto it = IncomingSequences.begin(); it != IncomingSequences.end(); ++it) {
		auto delta = abs(pNetChan->m_nInSequenceNr - it->InSequence);
		if (delta > 128) {
			it = IncomingSequences.erase(it);
		}
	}

	// get this from CL_FireEvents string "Failed to execute event for classId" in engine.dll
	for (CEventInfo* it{ Interfaces::m_pClientState->m_pEvents() }; it != nullptr; it = it->m_next) {
		if (!it->m_class_id)
			continue;

		// set all delays to instant.
		it->m_fire_delay = 0.f;
	}

	// game events are actually fired in OnRenderStart which is WAY later after they are received
	// effective delay by lerp time, now we call them right after theyre received (all receive proxies are invoked without delay).
	Interfaces::m_pEngine->FireEvents();
}

void __fastcall Hooked::Shutdown(INetChannel* pNetChan, void* EDX, const char* reason) {
	g_Vars.globals.szLastHookCalled = XorStr("35");
	return oShutdown(pNetChan, reason);
}

bool __fastcall Hooked::LooseFileAllowed(void* ecx, void* edx) {
	return true;
}

void __fastcall Hooked::CheckFileCRCsWithServer(void* ecx, void* edx) {
	return;
}

```

`CSGO SDK/Hooking/Hooks/SetReservationCookie.cpp`:

```cpp
#pragma once
#include "../Hooked.hpp"

uint32_t cookie_0 = 0;
uint32_t cookie_1 = 0;

// just some test code
void __fastcall Hooked::SetReservationCookie(void* ECX, void* EDX, int a2, int a3) {
	g_Vars.globals.szLastHookCalled = XorStr("36");

	return;
}

```

`CSGO SDK/Libraries/json.h`:

```h
/*
	__ _____ _____ _____
 __|  |   __|     |   | |  JSON for Modern C++
|  |  |__   |  |  | | | |  version 3.3.0
|_____|_____|_____|_|___|  https://github.com/nlohmann/json

Licensed under the MIT License <http://opensource.org/licenses/MIT>.
SPDX-License-Identifier: MIT
Copyright (c) 2013-2018 Niels Lohmann <http://nlohmann.me>.

Permission is hereby  granted, free of charge, to any  person obtaining a copy
of this software and associated  documentation files (the "Software"), to deal
in the Software  without restriction, including without  limitation the rights
to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
furnished to do so, subject to the following conditions:
           
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#ifndef NLOHMANN_JSON_HPP
#define NLOHMANN_JSON_HPP

#ifndef DEV
#define JSON_NOEXCEPTION
#endif

#define NLOHMANN_JSON_VERSION_MAJOR 3
#define NLOHMANN_JSON_VERSION_MINOR 3
#define NLOHMANN_JSON_VERSION_PATCH 0

#include <algorithm> // all_of, find, for_each
#include <cassert> // assert
#include <ciso646> // and, not, or
#include <cstddef> // nullptr_t, ptrdiff_t, size_t
#include <functional> // hash, less
#include <initializer_list> // initializer_list
#include <iosfwd> // istream, ostream
#include <iterator> // iterator_traits, random_access_iterator_tag
#include <numeric> // accumulate
#include <string> // string, stoi, to_string
#include <utility> // declval, forward, move, pair, swap

// #include <nlohmann/json_fwd.hpp>
#ifndef NLOHMANN_JSON_FWD_HPP
#define NLOHMANN_JSON_FWD_HPP

#include <cstdint> // int64_t, uint64_t
#include <map> // map
#include <memory> // allocator
#include <string> // string
#include <vector> // vector

/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/

namespace nlohmann
{
	/*!
	@brief default JSONSerializer template argument

	This serializer ignores the template arguments and uses ADL
	([argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl))
	for serialization.
	*/
	template<typename T = void, typename SFINAE = void>
	struct adl_serializer;

	template<template<typename U, typename V, typename... Args> class ObjectType =
		std::map,
		template<typename U, typename... Args> class ArrayType = std::vector,
		class StringType = std::string, class BooleanType = bool,
		class NumberIntegerType = std::int64_t,
		class NumberUnsignedType = std::uint64_t,
		class NumberFloatType = double,
		template<typename U> class AllocatorType = std::allocator,
		template<typename T, typename SFINAE = void> class JSONSerializer =
		adl_serializer>
		class basic_json;

	/*!
	@brief JSON Pointer

	A JSON pointer defines a string syntax for identifying a specific value
	within a JSON document. It can be used with functions `at` and
	`operator[]`. Furthermore, JSON pointers are the base for JSON patches.

	@sa [RFC 6901](https://tools.ietf.org/html/rfc6901)

	@since version 2.0.0
	*/
	template<typename BasicJsonType>
	class json_pointer;

	/*!
	@brief default JSON class

	This type is the default specialization of the @ref basic_json class which
	uses the standard template types.

	@since version 1.0.0
	*/
	using json = basic_json<>;
}

#endif

// #include <nlohmann/detail/macro_scope.hpp>


// This file contains all internal macro definitions
// You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them

// exclude unsupported compilers
#if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
#if defined(__clang__)
#if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
#error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"
#endif
#elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
#if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800
#error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"
#endif
#endif
#endif

// disable float-equal warnings on GCC/clang
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif

// disable documentation warnings on clang
#if defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdocumentation"
#endif

// allow for portable deprecation warnings
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
#define JSON_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define JSON_DEPRECATED __declspec(deprecated)
#else
#define JSON_DEPRECATED
#endif

// allow to disable exceptions
#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)
#define JSON_THROW(exception) throw exception
#define JSON_TRY try
#define JSON_CATCH(exception) catch(exception)
#define JSON_INTERNAL_CATCH(exception) catch(exception)
#else
#define JSON_THROW(exception) std::abort()
#define JSON_TRY if(true)
#define JSON_CATCH(exception) if(false)
#define JSON_INTERNAL_CATCH(exception) if(false)
#endif

// override exception macros
#if defined(JSON_THROW_USER)
#undef JSON_THROW
#define JSON_THROW JSON_THROW_USER
#endif
#if defined(JSON_TRY_USER)
#undef JSON_TRY
#define JSON_TRY JSON_TRY_USER
#endif
#if defined(JSON_CATCH_USER)
#undef JSON_CATCH
#define JSON_CATCH JSON_CATCH_USER
#undef JSON_INTERNAL_CATCH
#define JSON_INTERNAL_CATCH JSON_CATCH_USER
#endif
#if defined(JSON_INTERNAL_CATCH_USER)
#undef JSON_INTERNAL_CATCH
#define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
#endif

// manual branch prediction
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
#define JSON_LIKELY(x)      __builtin_expect(!!(x), 1)
#define JSON_UNLIKELY(x)    __builtin_expect(!!(x), 0)
#else
#define JSON_LIKELY(x)      x
#define JSON_UNLIKELY(x)    x
#endif

// C++ language standard detection
#if (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) // fix for issue #464
#define JSON_HAS_CPP_17
#define JSON_HAS_CPP_14
#elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
#define JSON_HAS_CPP_14
#endif

// Ugly macros to avoid uglier copy-paste when specializing basic_json. They
// may be removed in the future once the class is split.

#define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
    template<template<typename, typename, typename...> class ObjectType,   \
             template<typename, typename...> class ArrayType,              \
             class StringType, class BooleanType, class NumberIntegerType, \
             class NumberUnsignedType, class NumberFloatType,              \
             template<typename> class AllocatorType,                       \
             template<typename, typename = void> class JSONSerializer>

#define NLOHMANN_BASIC_JSON_TPL                                            \
    basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
    AllocatorType, JSONSerializer>

// #include <nlohmann/detail/meta/cpp_future.hpp>


#include <ciso646> // not
#include <cstddef> // size_t
#include <type_traits> // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type

namespace nlohmann
{
	namespace detail
	{
		// alias templates to reduce boilerplate
		template<bool B, typename T = void>
		using enable_if_t = typename std::enable_if<B, T>::type;

		template<typename T>
		using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;

		// implementation of C++14 index_sequence and affiliates
		// source: https://stackoverflow.com/a/32223343
		template<std::size_t... Ints>
		struct index_sequence
		{
			using type = index_sequence;
			using value_type = std::size_t;
			static constexpr std::size_t size() noexcept
			{
				return sizeof...(Ints);
			}
		};

		template<class Sequence1, class Sequence2>
		struct merge_and_renumber;

		template<std::size_t... I1, std::size_t... I2>
		struct merge_and_renumber<index_sequence<I1...>, index_sequence<I2...>>
			: index_sequence < I1..., (sizeof...(I1) + I2)... > {};

		template<std::size_t N>
		struct make_index_sequence
			: merge_and_renumber < typename make_index_sequence < N / 2 >::type,
			typename make_index_sequence < N - N / 2 >::type > {};

		template<> struct make_index_sequence<0> : index_sequence<> {};
		template<> struct make_index_sequence<1> : index_sequence<0> {};

		template<typename... Ts>
		using index_sequence_for = make_index_sequence<sizeof...(Ts)>;

		// dispatch utility (taken from ranges-v3)
		template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
		template<> struct priority_tag<0> {};

		// taken from ranges-v3
		template<typename T>
		struct static_const
		{
			static constexpr T value{};
		};

		template<typename T>
		constexpr T static_const<T>::value;
	}
}

// #include <nlohmann/detail/meta/type_traits.hpp>


#include <ciso646> // not
#include <limits> // numeric_limits
#include <type_traits> // false_type, is_constructible, is_integral, is_same, true_type
#include <utility> // declval

// #include <nlohmann/json_fwd.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/detected.hpp>


#include <type_traits>

// #include <nlohmann/detail/meta/void_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		template <typename ...Ts> struct make_void
		{
			using type = void;
		};
		template <typename ...Ts> using void_t = typename make_void<Ts...>::type;
	}
}


// http://en.cppreference.com/w/cpp/experimental/is_detected
namespace nlohmann
{
	namespace detail
	{
		struct nonesuch
		{
			nonesuch() = delete;
			~nonesuch() = delete;
			nonesuch(nonesuch const&) = delete;
			void operator=(nonesuch const&) = delete;
		};

		template <class Default,
			class AlwaysVoid,
			template <class...> class Op,
			class... Args>
			struct detector
		{
			using value_t = std::false_type;
			using type = Default;
		};

		template <class Default, template <class...> class Op, class... Args>
		struct detector<Default, void_t<Op<Args...>>, Op, Args...>
		{
			using value_t = std::true_type;
			using type = Op<Args...>;
		};

		template <template <class...> class Op, class... Args>
		using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;

		template <template <class...> class Op, class... Args>
		using detected_t = typename detector<nonesuch, void, Op, Args...>::type;

		template <class Default, template <class...> class Op, class... Args>
		using detected_or = detector<Default, void, Op, Args...>;

		template <class Default, template <class...> class Op, class... Args>
		using detected_or_t = typename detected_or<Default, Op, Args...>::type;

		template <class Expected, template <class...> class Op, class... Args>
		using is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;

		template <class To, template <class...> class Op, class... Args>
		using is_detected_convertible =
			std::is_convertible<detected_t<Op, Args...>, To>;
	}
}

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
	/*!
	@brief detail namespace with internal helper functions

	This namespace collects functions that should not be exposed,
	implementations of some @ref basic_json methods, and meta-programming helpers.

	@since version 2.1.0
	*/
	namespace detail
	{
		/////////////
		// helpers //
		/////////////

		template<typename> struct is_basic_json : std::false_type {};

		NLOHMANN_BASIC_JSON_TPL_DECLARATION
			struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};

		//////////////////////////
		// aliases for detected //
		//////////////////////////

		template <typename T>
		using mapped_type_t = typename T::mapped_type;

		template <typename T>
		using key_type_t = typename T::key_type;

		template <typename T>
		using value_type_t = typename T::value_type;

		template <typename T>
		using difference_type_t = typename T::difference_type;

		template <typename T>
		using pointer_t = typename T::pointer;

		template <typename T>
		using reference_t = typename T::reference;

		template <typename T>
		using iterator_category_t = typename T::iterator_category;

		template <typename T>
		using iterator_t = typename T::iterator;

		template <typename T, typename... Args>
		using to_json_function = decltype(T::to_json(std::declval<Args>()...));

		template <typename T, typename... Args>
		using from_json_function = decltype(T::from_json(std::declval<Args>()...));

		template <typename T, typename U>
		using get_template_function = decltype(std::declval<T>().template get<U>());

		///////////////////
		// is_ functions //
		///////////////////

		template <typename T, typename = void>
		struct is_iterator_traits : std::false_type {};

		template <typename T>
		struct is_iterator_traits<std::iterator_traits<T>>
		{
		private:
			using traits = std::iterator_traits<T>;

		public:
			static constexpr auto value =
				is_detected<value_type_t, traits>::value &&
				is_detected<difference_type_t, traits>::value &&
				is_detected<pointer_t, traits>::value &&
				is_detected<iterator_category_t, traits>::value &&
				is_detected<reference_t, traits>::value;
		};

		// source: https://stackoverflow.com/a/37193089/4116453

		template <typename T, typename = void>
		struct is_complete_type : std::false_type {};

		template <typename T>
		struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};

		template <typename BasicJsonType, typename CompatibleObjectType,
			typename = void>
			struct is_compatible_object_type_impl : std::false_type {};

		template <typename BasicJsonType, typename CompatibleObjectType>
		struct is_compatible_object_type_impl <
			BasicJsonType, CompatibleObjectType,
			enable_if_t<is_detected<mapped_type_t, CompatibleObjectType>::value and
			is_detected<key_type_t, CompatibleObjectType>::value >>
		{

			using object_t = typename BasicJsonType::object_t;

			// macOS's is_constructible does not play well with nonesuch...
			static constexpr bool value =
				std::is_constructible<typename object_t::key_type,
				typename CompatibleObjectType::key_type>::value and
				std::is_constructible<typename object_t::mapped_type,
				typename CompatibleObjectType::mapped_type>::value;
		};

		template <typename BasicJsonType, typename CompatibleObjectType>
		struct is_compatible_object_type
			: is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};

		template <typename BasicJsonType, typename CompatibleStringType,
			typename = void>
			struct is_compatible_string_type_impl : std::false_type {};

		template <typename BasicJsonType, typename CompatibleStringType>
		struct is_compatible_string_type_impl <
			BasicJsonType, CompatibleStringType,
			enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,
			value_type_t, CompatibleStringType>::value >>
		{
			static constexpr auto value =
				std::is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;
		};

		template <typename BasicJsonType, typename CompatibleStringType>
		struct is_compatible_string_type
			: is_compatible_string_type_impl<BasicJsonType, CompatibleStringType> {};

		template <typename BasicJsonType, typename CompatibleArrayType, typename = void>
		struct is_compatible_array_type_impl : std::false_type {};

		template <typename BasicJsonType, typename CompatibleArrayType>
		struct is_compatible_array_type_impl <
			BasicJsonType, CompatibleArrayType,
			enable_if_t<is_detected<value_type_t, CompatibleArrayType>::value and
			is_detected<iterator_t, CompatibleArrayType>::value >>
		{
			// This is needed because json_reverse_iterator has a ::iterator type...
			// Therefore it is detected as a CompatibleArrayType.
			// The real fix would be to have an Iterable concept.
			static constexpr bool value = not is_iterator_traits<std::iterator_traits<CompatibleArrayType>>::value;
		};

		template <typename BasicJsonType, typename CompatibleArrayType>
		struct is_compatible_array_type
			: is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};

		template <typename RealIntegerType, typename CompatibleNumberIntegerType,
			typename = void>
			struct is_compatible_integer_type_impl : std::false_type {};

		template <typename RealIntegerType, typename CompatibleNumberIntegerType>
		struct is_compatible_integer_type_impl <
			RealIntegerType, CompatibleNumberIntegerType,
			enable_if_t<std::is_integral<RealIntegerType>::value and
			std::is_integral<CompatibleNumberIntegerType>::value and
			not std::is_same<bool, CompatibleNumberIntegerType>::value >>
		{
			// is there an assert somewhere on overflows?
			using RealLimits = std::numeric_limits<RealIntegerType>;
			using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;

			static constexpr auto value =
				std::is_constructible<RealIntegerType,
				CompatibleNumberIntegerType>::value and
				CompatibleLimits::is_integer and
				RealLimits::is_signed == CompatibleLimits::is_signed;
		};

		template <typename RealIntegerType, typename CompatibleNumberIntegerType>
		struct is_compatible_integer_type
			: is_compatible_integer_type_impl<RealIntegerType,
			CompatibleNumberIntegerType> {};

		// trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists
		template <typename BasicJsonType, typename T, typename = void>
		struct has_from_json : std::false_type {};

		template <typename BasicJsonType, typename T>
		struct has_from_json<BasicJsonType, T,
			enable_if_t<not is_basic_json<T>::value>>
		{
			using serializer = typename BasicJsonType::template json_serializer<T, void>;

			static constexpr bool value =
				is_detected_exact<void, from_json_function, serializer,
				const BasicJsonType&, T&>::value;
		};

		// This trait checks if JSONSerializer<T>::from_json(json const&) exists
		// this overload is used for non-default-constructible user-defined-types
		template <typename BasicJsonType, typename T, typename = void>
		struct has_non_default_from_json : std::false_type {};

		template<typename BasicJsonType, typename T>
		struct has_non_default_from_json<BasicJsonType, T, enable_if_t<not is_basic_json<T>::value>>
		{
			using serializer = typename BasicJsonType::template json_serializer<T, void>;

			static constexpr bool value =
				is_detected_exact<T, from_json_function, serializer,
				const BasicJsonType&>::value;
		};

		// This trait checks if BasicJsonType::json_serializer<T>::to_json exists
		// Do not evaluate the trait when T is a basic_json type, to avoid template instantiation infinite recursion.
		template <typename BasicJsonType, typename T, typename = void>
		struct has_to_json : std::false_type {};

		template <typename BasicJsonType, typename T>
		struct has_to_json<BasicJsonType, T, enable_if_t<not is_basic_json<T>::value>>
		{
			using serializer = typename BasicJsonType::template json_serializer<T, void>;

			static constexpr bool value =
				is_detected_exact<void, to_json_function, serializer, BasicJsonType&,
				T>::value;
		};

		template <typename BasicJsonType, typename CompatibleType, typename = void>
		struct is_compatible_type_impl : std::false_type {};

		template <typename BasicJsonType, typename CompatibleType>
		struct is_compatible_type_impl <
			BasicJsonType, CompatibleType,
			enable_if_t<is_complete_type<CompatibleType>::value >>
		{
			static constexpr bool value =
				has_to_json<BasicJsonType, CompatibleType>::value;
		};

		template <typename BasicJsonType, typename CompatibleType>
		struct is_compatible_type
			: is_compatible_type_impl<BasicJsonType, CompatibleType> {};
	}
}

// #include <nlohmann/detail/exceptions.hpp>


#include <exception> // exception
#include <stdexcept> // runtime_error
#include <string> // to_string

namespace nlohmann
{
	namespace detail
	{
		////////////////
		// exceptions //
		////////////////

		/*!
		@brief general exception of the @ref basic_json class

		This class is an extension of `std::exception` objects with a member @a id for
		exception ids. It is used as the base class for all exceptions thrown by the
		@ref basic_json class. This class can hence be used as "wildcard" to catch
		exceptions.

		Subclasses:
		- @ref parse_error for exceptions indicating a parse error
		- @ref invalid_iterator for exceptions indicating errors with iterators
		- @ref type_error for exceptions indicating executing a member function with
						  a wrong type
		- @ref out_of_range for exceptions indicating access out of the defined range
		- @ref other_error for exceptions indicating other library errors

		@internal
		@note To have nothrow-copy-constructible exceptions, we internally use
			  `std::runtime_error` which can cope with arbitrary-length error messages.
			  Intermediate strings are built with static functions and then passed to
			  the actual constructor.
		@endinternal

		@liveexample{The following code shows how arbitrary library exceptions can be
		caught.,exception}

		@since version 3.0.0
		*/
		class exception : public std::exception
		{
		public:
			/// returns the explanatory string
			const char* what() const noexcept override
			{
				return m.what();
			}

			/// the id of the exception
			const int id;

		protected:
			exception(int id_, const char* what_arg) : id(id_), m(what_arg) {}

			static std::string name(const std::string& ename, int id_)
			{
				return "[json.exception." + ename + "." + std::to_string(id_) + "] ";
			}

		private:
			/// an exception object as storage for error messages
			std::runtime_error m;
		};

		/*!
		@brief exception indicating a parse error

		This exception is thrown by the library when a parse error occurs. Parse errors
		can occur during the deserialization of JSON text, CBOR, MessagePack, as well
		as when using JSON Patch.

		Member @a byte holds the byte index of the last read character in the input
		file.

		Exceptions have ids 1xx.

		name / id                      | example message | description
		------------------------------ | --------------- | -------------------------
		json.exception.parse_error.101 | parse error at 2: unexpected end of input; expected string literal | This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member @a byte indicates the error position.
		json.exception.parse_error.102 | parse error at 14: missing or wrong low surrogate | JSON uses the `\uxxxx` format to describe Unicode characters. Code points above above 0xFFFF are split into two `\uxxxx` entries ("surrogate pairs"). This error indicates that the surrogate pair is incomplete or contains an invalid code point.
		json.exception.parse_error.103 | parse error: code points above 0x10FFFF are invalid | Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.
		json.exception.parse_error.104 | parse error: JSON patch must be an array of objects | [RFC 6902](https://tools.ietf.org/html/rfc6902) requires a JSON Patch document to be a JSON document that represents an array of objects.
		json.exception.parse_error.105 | parse error: operation must have string member 'op' | An operation of a JSON Patch document must contain exactly one "op" member, whose value indicates the operation to perform. Its value must be one of "add", "remove", "replace", "move", "copy", or "test"; other values are errors.
		json.exception.parse_error.106 | parse error: array index '01' must not begin with '0' | An array index in a JSON Pointer ([RFC 6901](https://tools.ietf.org/html/rfc6901)) may be `0` or any number without a leading `0`.
		json.exception.parse_error.107 | parse error: JSON pointer must be empty or begin with '/' - was: 'foo' | A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a `/` character.
		json.exception.parse_error.108 | parse error: escape character '~' must be followed with '0' or '1' | In a JSON Pointer, only `~0` and `~1` are valid escape sequences.
		json.exception.parse_error.109 | parse error: array index 'one' is not a number | A JSON Pointer array index must be a number.
		json.exception.parse_error.110 | parse error at 1: cannot read 2 bytes from vector | When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.
		json.exception.parse_error.112 | parse error at 1: error reading CBOR; last byte: 0xF8 | Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read.
		json.exception.parse_error.113 | parse error at 2: expected a CBOR string; last byte: 0x98 | While parsing a map key, a value that is not a string has been read.

		@note For an input with n bytes, 1 is the index of the first character and n+1
			  is the index of the terminating null byte or the end of file. This also
			  holds true when reading a byte vector (CBOR or MessagePack).

		@liveexample{The following code shows how a `parse_error` exception can be
		caught.,parse_error}

		@sa @ref exception for the base class of the library exceptions
		@sa @ref invalid_iterator for exceptions indicating errors with iterators
		@sa @ref type_error for exceptions indicating executing a member function with
							a wrong type
		@sa @ref out_of_range for exceptions indicating access out of the defined range
		@sa @ref other_error for exceptions indicating other library errors

		@since version 3.0.0
		*/
		class parse_error : public exception
		{
		public:
			/*!
			@brief create a parse error exception
			@param[in] id_       the id of the exception
			@param[in] byte_     the byte index where the error occurred (or 0 if the
								 position cannot be determined)
			@param[in] what_arg  the explanatory string
			@return parse_error object
			*/
			static parse_error create(int id_, std::size_t byte_, const std::string& what_arg)
			{
				std::string w = exception::name("parse_error", id_) + "parse error" +
					(byte_ != 0 ? (" at " + std::to_string(byte_)) : "") +
					": " + what_arg;
				return parse_error(id_, byte_, w.c_str());
			}

			/*!
			@brief byte index of the parse error

			The byte index of the last read character in the input file.

			@note For an input with n bytes, 1 is the index of the first character and
				  n+1 is the index of the terminating null byte or the end of file.
				  This also holds true when reading a byte vector (CBOR or MessagePack).
			*/
			const std::size_t byte;

		private:
			parse_error(int id_, std::size_t byte_, const char* what_arg)
				: exception(id_, what_arg), byte(byte_) {}
		};

		/*!
		@brief exception indicating errors with iterators

		This exception is thrown if iterators passed to a library function do not match
		the expected semantics.

		Exceptions have ids 2xx.

		name / id                           | example message | description
		----------------------------------- | --------------- | -------------------------
		json.exception.invalid_iterator.201 | iterators are not compatible | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
		json.exception.invalid_iterator.202 | iterator does not fit current value | In an erase or insert function, the passed iterator @a pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.
		json.exception.invalid_iterator.203 | iterators do not fit current value | Either iterator passed to function @ref erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.
		json.exception.invalid_iterator.204 | iterators out of range | When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly (@ref begin(), @ref end()), because this is the only way the single stored value is expressed. All other ranges are invalid.
		json.exception.invalid_iterator.205 | iterator out of range | When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the @ref begin() iterator, because it is the only way to address the stored value. All other iterators are invalid.
		json.exception.invalid_iterator.206 | cannot construct with iterators from null | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range.
		json.exception.invalid_iterator.207 | cannot use key() for non-object iterators | The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.
		json.exception.invalid_iterator.208 | cannot use operator[] for object iterators | The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
		json.exception.invalid_iterator.209 | cannot use offsets with object iterators | The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
		json.exception.invalid_iterator.210 | iterators do not fit | The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
		json.exception.invalid_iterator.211 | passed iterators may not belong to container | The iterator range passed to the insert function must not be a subrange of the container to insert to.
		json.exception.invalid_iterator.212 | cannot compare iterators of different containers | When two iterators are compared, they must belong to the same container.
		json.exception.invalid_iterator.213 | cannot compare order of object iterators | The order of object iterators cannot be compared, because JSON objects are unordered.
		json.exception.invalid_iterator.214 | cannot get value | Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to @ref begin().

		@liveexample{The following code shows how an `invalid_iterator` exception can be
		caught.,invalid_iterator}

		@sa @ref exception for the base class of the library exceptions
		@sa @ref parse_error for exceptions indicating a parse error
		@sa @ref type_error for exceptions indicating executing a member function with
							a wrong type
		@sa @ref out_of_range for exceptions indicating access out of the defined range
		@sa @ref other_error for exceptions indicating other library errors

		@since version 3.0.0
		*/
		class invalid_iterator : public exception
		{
		public:
			static invalid_iterator create(int id_, const std::string& what_arg)
			{
				std::string w = exception::name("invalid_iterator", id_) + what_arg;
				return invalid_iterator(id_, w.c_str());
			}

		private:
			invalid_iterator(int id_, const char* what_arg)
				: exception(id_, what_arg) {}
		};

		/*!
		@brief exception indicating executing a member function with a wrong type

		This exception is thrown in case of a type error; that is, a library function is
		executed on a JSON value whose type does not match the expected semantics.

		Exceptions have ids 3xx.

		name / id                     | example message | description
		----------------------------- | --------------- | -------------------------
		json.exception.type_error.301 | cannot create object from initializer list | To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.
		json.exception.type_error.302 | type must be object, but is array | During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.
		json.exception.type_error.303 | incompatible ReferenceType for get_ref, actual type is object | To retrieve a reference to a value stored in a @ref basic_json object with @ref get_ref, the type of the reference must match the value type. For instance, for a JSON array, the @a ReferenceType must be @ref array_t&.
		json.exception.type_error.304 | cannot use at() with string | The @ref at() member functions can only be executed for certain JSON types.
		json.exception.type_error.305 | cannot use operator[] with string | The @ref operator[] member functions can only be executed for certain JSON types.
		json.exception.type_error.306 | cannot use value() with string | The @ref value() member functions can only be executed for certain JSON types.
		json.exception.type_error.307 | cannot use erase() with string | The @ref erase() member functions can only be executed for certain JSON types.
		json.exception.type_error.308 | cannot use push_back() with string | The @ref push_back() and @ref operator+= member functions can only be executed for certain JSON types.
		json.exception.type_error.309 | cannot use insert() with | The @ref insert() member functions can only be executed for certain JSON types.
		json.exception.type_error.310 | cannot use swap() with number | The @ref swap() member functions can only be executed for certain JSON types.
		json.exception.type_error.311 | cannot use emplace_back() with string | The @ref emplace_back() member function can only be executed for certain JSON types.
		json.exception.type_error.312 | cannot use update() with string | The @ref update() member functions can only be executed for certain JSON types.
		json.exception.type_error.313 | invalid value to unflatten | The @ref unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined.
		json.exception.type_error.314 | only objects can be unflattened | The @ref unflatten function only works for an object whose keys are JSON Pointers.
		json.exception.type_error.315 | values in object must be primitive | The @ref unflatten function only works for an object whose keys are JSON Pointers and whose values are primitive.
		json.exception.type_error.316 | invalid UTF-8 byte at index 10: 0x7E | The @ref dump function only works with UTF-8 encoded strings; that is, if you assign a `std::string` to a JSON value, make sure it is UTF-8 encoded. |

		@liveexample{The following code shows how a `type_error` exception can be
		caught.,type_error}

		@sa @ref exception for the base class of the library exceptions
		@sa @ref parse_error for exceptions indicating a parse error
		@sa @ref invalid_iterator for exceptions indicating errors with iterators
		@sa @ref out_of_range for exceptions indicating access out of the defined range
		@sa @ref other_error for exceptions indicating other library errors

		@since version 3.0.0
		*/
		class type_error : public exception
		{
		public:
			static type_error create(int id_, const std::string& what_arg)
			{
				std::string w = exception::name("type_error", id_) + what_arg;
				return type_error(id_, w.c_str());
			}

		private:
			type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
		};

		/*!
		@brief exception indicating access out of the defined range

		This exception is thrown in case a library function is called on an input
		parameter that exceeds the expected range, for instance in case of array
		indices or nonexisting object keys.

		Exceptions have ids 4xx.

		name / id                       | example message | description
		------------------------------- | --------------- | -------------------------
		json.exception.out_of_range.401 | array index 3 is out of range | The provided array index @a i is larger than @a size-1.
		json.exception.out_of_range.402 | array index '-' (3) is out of range | The special array index `-` in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.
		json.exception.out_of_range.403 | key 'foo' not found | The provided key was not found in the JSON object.
		json.exception.out_of_range.404 | unresolved reference token 'foo' | A reference token in a JSON Pointer could not be resolved.
		json.exception.out_of_range.405 | JSON pointer has no parent | The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value.
		json.exception.out_of_range.406 | number overflow parsing '10E1000' | A parsed number could not be stored as without changing it to NaN or INF.
		json.exception.out_of_range.407 | number overflow serializing '9223372036854775808' | UBJSON only supports integers numbers up to 9223372036854775807. |
		json.exception.out_of_range.408 | excessive array size: 8658170730974374167 | The size (following `#`) of an UBJSON array or object exceeds the maximal capacity. |

		@liveexample{The following code shows how an `out_of_range` exception can be
		caught.,out_of_range}

		@sa @ref exception for the base class of the library exceptions
		@sa @ref parse_error for exceptions indicating a parse error
		@sa @ref invalid_iterator for exceptions indicating errors with iterators
		@sa @ref type_error for exceptions indicating executing a member function with
							a wrong type
		@sa @ref other_error for exceptions indicating other library errors

		@since version 3.0.0
		*/
		class out_of_range : public exception
		{
		public:
			static out_of_range create(int id_, const std::string& what_arg)
			{
				std::string w = exception::name("out_of_range", id_) + what_arg;
				return out_of_range(id_, w.c_str());
			}

		private:
			out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
		};

		/*!
		@brief exception indicating other library errors

		This exception is thrown in case of errors that cannot be classified with the
		other exception types.

		Exceptions have ids 5xx.

		name / id                      | example message | description
		------------------------------ | --------------- | -------------------------
		json.exception.other_error.501 | unsuccessful: {"op":"test","path":"/baz", "value":"bar"} | A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.

		@sa @ref exception for the base class of the library exceptions
		@sa @ref parse_error for exceptions indicating a parse error
		@sa @ref invalid_iterator for exceptions indicating errors with iterators
		@sa @ref type_error for exceptions indicating executing a member function with
							a wrong type
		@sa @ref out_of_range for exceptions indicating access out of the defined range

		@liveexample{The following code shows how an `other_error` exception can be
		caught.,other_error}

		@since version 3.0.0
		*/
		class other_error : public exception
		{
		public:
			static other_error create(int id_, const std::string& what_arg)
			{
				std::string w = exception::name("other_error", id_) + what_arg;
				return other_error(id_, w.c_str());
			}

		private:
			other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
		};
	}
}

// #include <nlohmann/detail/value_t.hpp>


#include <array> // array
#include <ciso646> // and
#include <cstddef> // size_t
#include <cstdint> // uint8_t

namespace nlohmann
{
	namespace detail
	{
		///////////////////////////
		// JSON type enumeration //
		///////////////////////////

		/*!
		@brief the JSON type enumeration

		This enumeration collects the different JSON types. It is internally used to
		distinguish the stored values, and the functions @ref basic_json::is_null(),
		@ref basic_json::is_object(), @ref basic_json::is_array(),
		@ref basic_json::is_string(), @ref basic_json::is_boolean(),
		@ref basic_json::is_number() (with @ref basic_json::is_number_integer(),
		@ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),
		@ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and
		@ref basic_json::is_structured() rely on it.

		@note There are three enumeration entries (number_integer, number_unsigned, and
		number_float), because the library distinguishes these three types for numbers:
		@ref basic_json::number_unsigned_t is used for unsigned integers,
		@ref basic_json::number_integer_t is used for signed integers, and
		@ref basic_json::number_float_t is used for floating-point numbers or to
		approximate integers which do not fit in the limits of their respective type.

		@sa @ref basic_json::basic_json(const value_t value_type) -- create a JSON
		value with the default value for a given type

		@since version 1.0.0
		*/
		enum class value_t : std::uint8_t
		{
			null,             ///< null value
			object,           ///< object (unordered set of name/value pairs)
			array,            ///< array (ordered collection of values)
			string,           ///< string value
			boolean,          ///< boolean value
			number_integer,   ///< number value (signed integer)
			number_unsigned,  ///< number value (unsigned integer)
			number_float,     ///< number value (floating-point)
			discarded         ///< discarded by the the parser callback function
		};

		/*!
		@brief comparison operator for JSON types

		Returns an ordering that is similar to Python:
		- order: null < boolean < number < object < array < string
		- furthermore, each type is not smaller than itself
		- discarded values are not comparable

		@since version 1.0.0
		*/
		inline bool operator<(const value_t lhs, const value_t rhs) noexcept
		{
			static constexpr std::array<std::uint8_t, 8> order = { {
					0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,
					1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */
				}
			};

			const auto l_index = static_cast<std::size_t>(lhs);
			const auto r_index = static_cast<std::size_t>(rhs);
			return l_index < order.size() and r_index < order.size() and order[l_index] < order[r_index];
		}
	}
}

// #include <nlohmann/detail/conversions/from_json.hpp>


#include <algorithm> // transform
#include <array> // array
#include <ciso646> // and, not
#include <forward_list> // forward_list
#include <iterator> // inserter, front_inserter, end
#include <map> // map
#include <string> // string
#include <tuple> // tuple, make_tuple
#include <type_traits> // is_arithmetic, is_same, is_enum, underlying_type, is_convertible
#include <unordered_map> // unordered_map
#include <utility> // pair, declval
#include <valarray> // valarray

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		template<typename BasicJsonType>
		void from_json(const BasicJsonType& j, typename std::nullptr_t& n)
		{
			if (JSON_UNLIKELY(not j.is_null()))
			{
				JSON_THROW(type_error::create(302, "type must be null, but is " + std::string(j.type_name())));
			}
			n = nullptr;
		}

		// overloads for basic_json template parameters
		template<typename BasicJsonType, typename ArithmeticType,
			enable_if_t<std::is_arithmetic<ArithmeticType>::value and
			not std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
			int> = 0>
			void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
		{
			switch (static_cast<value_t>(j))
			{
			case value_t::number_unsigned:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
				break;
			}
			case value_t::number_integer:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
				break;
			}
			case value_t::number_float:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
				break;
			}

			default:
				JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
			}
		}

		template<typename BasicJsonType>
		void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
		{
			if (JSON_UNLIKELY(not j.is_boolean()))
			{
				JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(j.type_name())));
			}
			b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
		}

		template<typename BasicJsonType>
		void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
		{
			if (JSON_UNLIKELY(not j.is_string()))
			{
				JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
			}
			s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
		}

		template <
			typename BasicJsonType, typename CompatibleStringType,
			enable_if_t <
			is_compatible_string_type<BasicJsonType, CompatibleStringType>::value and
			not std::is_same<typename BasicJsonType::string_t,
			CompatibleStringType>::value,
			int > = 0 >
			void from_json(const BasicJsonType& j, CompatibleStringType& s)
		{
			if (JSON_UNLIKELY(not j.is_string()))
			{
				JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
			}

			s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
		}

		template<typename BasicJsonType>
		void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
		{
			get_arithmetic_value(j, val);
		}

		template<typename BasicJsonType>
		void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
		{
			get_arithmetic_value(j, val);
		}

		template<typename BasicJsonType>
		void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
		{
			get_arithmetic_value(j, val);
		}

		template<typename BasicJsonType, typename EnumType,
			enable_if_t<std::is_enum<EnumType>::value, int> = 0>
			void from_json(const BasicJsonType& j, EnumType& e)
		{
			typename std::underlying_type<EnumType>::type val;
			get_arithmetic_value(j, val);
			e = static_cast<EnumType>(val);
		}

		// forward_list doesn't have an insert method
		template<typename BasicJsonType, typename T, typename Allocator,
			enable_if_t<std::is_convertible<BasicJsonType, T>::value, int> = 0>
			void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
		{
			if (JSON_UNLIKELY(not j.is_array()))
			{
				JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
			}
			std::transform(j.rbegin(), j.rend(),
				std::front_inserter(l), [](const BasicJsonType & i)
			{
				return i.template get<T>();
			});
		}

		// valarray doesn't have an insert method
		template<typename BasicJsonType, typename T,
			enable_if_t<std::is_convertible<BasicJsonType, T>::value, int> = 0>
			void from_json(const BasicJsonType& j, std::valarray<T>& l)
		{
			if (JSON_UNLIKELY(not j.is_array()))
			{
				JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
			}
			l.resize(j.size());
			std::copy(j.m_value.array->begin(), j.m_value.array->end(), std::begin(l));
		}

		template<typename BasicJsonType>
		void from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> /*unused*/)
		{
			arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
		}

		template <typename BasicJsonType, typename T, std::size_t N>
		auto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,
			priority_tag<2> /*unused*/)
			-> decltype(j.template get<T>(), void())
		{
			for (std::size_t i = 0; i < N; ++i)
			{
				arr[i] = j.at(i).template get<T>();
			}
		}

		template<typename BasicJsonType, typename CompatibleArrayType>
		auto from_json_array_impl(const BasicJsonType& j, CompatibleArrayType& arr, priority_tag<1> /*unused*/)
			-> decltype(
				arr.reserve(std::declval<typename CompatibleArrayType::size_type>()),
				j.template get<typename CompatibleArrayType::value_type>(),
				void())
		{
			using std::end;

			arr.reserve(j.size());
			std::transform(j.begin(), j.end(),
				std::inserter(arr, end(arr)), [](const BasicJsonType & i)
			{
				// get<BasicJsonType>() returns *this, this won't call a from_json
				// method when value_type is BasicJsonType
				return i.template get<typename CompatibleArrayType::value_type>();
			});
		}

		template <typename BasicJsonType, typename CompatibleArrayType>
		void from_json_array_impl(const BasicJsonType& j, CompatibleArrayType& arr,
			priority_tag<0> /*unused*/)
		{
			using std::end;

			std::transform(
				j.begin(), j.end(), std::inserter(arr, end(arr)),
				[](const BasicJsonType & i)
			{
				// get<BasicJsonType>() returns *this, this won't call a from_json
				// method when value_type is BasicJsonType
				return i.template get<typename CompatibleArrayType::value_type>();
			});
		}

		template <typename BasicJsonType, typename CompatibleArrayType,
			enable_if_t <
			is_compatible_array_type<BasicJsonType, CompatibleArrayType>::value and
			not is_compatible_object_type<BasicJsonType, CompatibleArrayType>::value and
			not is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value and
			not is_basic_json<CompatibleArrayType>::value,
			int > = 0 >

			auto from_json(const BasicJsonType& j, CompatibleArrayType& arr)
			-> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
				j.template get<typename CompatibleArrayType::value_type>(),
				void())
		{
			if (JSON_UNLIKELY(not j.is_array()))
			{
				JSON_THROW(type_error::create(302, "type must be array, but is " +
					std::string(j.type_name())));
			}

			from_json_array_impl(j, arr, priority_tag<3> {});
		}

		template<typename BasicJsonType, typename CompatibleObjectType,
			enable_if_t<is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value, int> = 0>
			void from_json(const BasicJsonType& j, CompatibleObjectType& obj)
		{
			if (JSON_UNLIKELY(not j.is_object()))
			{
				JSON_THROW(type_error::create(302, "type must be object, but is " + std::string(j.type_name())));
			}

			auto inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
			using value_type = typename CompatibleObjectType::value_type;
			std::transform(
				inner_object->begin(), inner_object->end(),
				std::inserter(obj, obj.begin()),
				[](typename BasicJsonType::object_t::value_type const & p)
			{
				return value_type(p.first, p.second.template get<typename CompatibleObjectType::mapped_type>());
			});
		}

		// overload for arithmetic types, not chosen for basic_json template arguments
		// (BooleanType, etc..); note: Is it really necessary to provide explicit
		// overloads for boolean_t etc. in case of a custom BooleanType which is not
		// an arithmetic type?
		template<typename BasicJsonType, typename ArithmeticType,
			enable_if_t <
			std::is_arithmetic<ArithmeticType>::value and
			not std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value and
			not std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value and
			not std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value and
			not std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
			int> = 0>
			void from_json(const BasicJsonType& j, ArithmeticType& val)
		{
			switch (static_cast<value_t>(j))
			{
			case value_t::number_unsigned:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
				break;
			}
			case value_t::number_integer:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
				break;
			}
			case value_t::number_float:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
				break;
			}
			case value_t::boolean:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
				break;
			}

			default:
				JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
			}
		}

		template<typename BasicJsonType, typename A1, typename A2>
		void from_json(const BasicJsonType& j, std::pair<A1, A2>& p)
		{
			p = { j.at(0).template get<A1>(), j.at(1).template get<A2>() };
		}

		template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
		void from_json_tuple_impl(const BasicJsonType& j, Tuple& t, index_sequence<Idx...>)
		{
			t = std::make_tuple(j.at(Idx).template get<typename std::tuple_element<Idx, Tuple>::type>()...);
		}

		template<typename BasicJsonType, typename... Args>
		void from_json(const BasicJsonType& j, std::tuple<Args...>& t)
		{
			from_json_tuple_impl(j, t, index_sequence_for<Args...> {});
		}

		template <typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
			typename = enable_if_t<not std::is_constructible<
			typename BasicJsonType::string_t, Key>::value>>
			void from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)
		{
			if (JSON_UNLIKELY(not j.is_array()))
			{
				JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
			}
			for (const auto& p : j)
			{
				if (JSON_UNLIKELY(not p.is_array()))
				{
					JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name())));
				}
				m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
			}
		}

		template <typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
			typename = enable_if_t<not std::is_constructible<
			typename BasicJsonType::string_t, Key>::value>>
			void from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)
		{
			if (JSON_UNLIKELY(not j.is_array()))
			{
				JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
			}
			for (const auto& p : j)
			{
				if (JSON_UNLIKELY(not p.is_array()))
				{
					JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name())));
				}
				m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
			}
		}

		struct from_json_fn
		{
			template<typename BasicJsonType, typename T>
			auto operator()(const BasicJsonType& j, T& val) const
				noexcept(noexcept(from_json(j, val)))
				-> decltype(from_json(j, val), void())
			{
				return from_json(j, val);
			}
		};
	}

	/// namespace to hold default `from_json` function
	/// to see why this is required:
	/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
	namespace
	{
		constexpr const auto& from_json = detail::static_const<detail::from_json_fn>::value;
	}
}

// #include <nlohmann/detail/conversions/to_json.hpp>


#include <ciso646> // or, and, not
#include <iterator> // begin, end
#include <tuple> // tuple, get
#include <type_traits> // is_same, is_constructible, is_floating_point, is_enum, underlying_type
#include <utility> // move, forward, declval, pair
#include <valarray> // valarray
#include <vector> // vector

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>


#include <cstddef> // size_t
#include <string> // string, to_string
#include <iterator> // input_iterator_tag

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		/// proxy class for the items() function
		template<typename IteratorType> class iteration_proxy
		{
		private:
			/// helper class for iteration
			class iteration_proxy_internal
			{
			public:
				using difference_type = std::ptrdiff_t;
				using value_type = iteration_proxy_internal;
				using pointer = iteration_proxy_internal * ;
				using reference = iteration_proxy_internal & ;
				using iterator_category = std::input_iterator_tag;

			private:
				/// the iterator
				IteratorType anchor;
				/// an index for arrays (used to create key names)
				std::size_t array_index = 0;
				/// last stringified array index
				mutable std::size_t array_index_last = 0;
				/// a string representation of the array index
				mutable std::string array_index_str = "0";
				/// an empty string (to return a reference for primitive values)
				const std::string empty_str = "";

			public:
				explicit iteration_proxy_internal(IteratorType it) noexcept : anchor(it) {}

				iteration_proxy_internal(const iteration_proxy_internal&) = default;
				iteration_proxy_internal& operator=(const iteration_proxy_internal&) = default;

				/// dereference operator (needed for range-based for)
				iteration_proxy_internal& operator*()
				{
					return *this;
				}

				/// increment operator (needed for range-based for)
				iteration_proxy_internal& operator++()
				{
					++anchor;
					++array_index;

					return *this;
				}

				/// equality operator (needed for InputIterator)
				bool operator==(const iteration_proxy_internal& o) const noexcept
				{
					return anchor == o.anchor;
				}

				/// inequality operator (needed for range-based for)
				bool operator!=(const iteration_proxy_internal& o) const noexcept
				{
					return anchor != o.anchor;
				}

				/// return key of the iterator
				const std::string& key() const
				{
					assert(anchor.m_object != nullptr);

					switch (anchor.m_object->type())
					{
						// use integer array index as key
					case value_t::array:
					{
						if (array_index != array_index_last)
						{
							array_index_str = std::to_string(array_index);
							array_index_last = array_index;
						}
						return array_index_str;
					}

					// use key from the object
					case value_t::object:
						return anchor.key();

						// use an empty key for all primitive types
					default:
						return empty_str;
					}
				}

				/// return value of the iterator
				typename IteratorType::reference value() const
				{
					return anchor.value();
				}
			};

			/// the container to iterate
			typename IteratorType::reference container;

		public:
			/// construct iteration proxy from a container
			explicit iteration_proxy(typename IteratorType::reference cont) noexcept
				: container(cont) {}

			/// return iterator begin (needed for range-based for)
			iteration_proxy_internal begin() noexcept
			{
				return iteration_proxy_internal(container.begin());
			}

			/// return iterator end (needed for range-based for)
			iteration_proxy_internal end() noexcept
			{
				return iteration_proxy_internal(container.end());
			}
		};
	}
}


namespace nlohmann
{
	namespace detail
	{
		//////////////////
		// constructors //
		//////////////////

		template<value_t> struct external_constructor;

		template<>
		struct external_constructor<value_t::boolean>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
			{
				j.m_type = value_t::boolean;
				j.m_value = b;
				j.assert_invariant();
			}
		};

		template<>
		struct external_constructor<value_t::string>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
			{
				j.m_type = value_t::string;
				j.m_value = s;
				j.assert_invariant();
			}

			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
			{
				j.m_type = value_t::string;
				j.m_value = std::move(s);
				j.assert_invariant();
			}

			template<typename BasicJsonType, typename CompatibleStringType,
				enable_if_t<not std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,
				int> = 0>
				static void construct(BasicJsonType& j, const CompatibleStringType& str)
			{
				j.m_type = value_t::string;
				j.m_value.string = j.template create<typename BasicJsonType::string_t>(str);
				j.assert_invariant();
			}
		};

		template<>
		struct external_constructor<value_t::number_float>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
			{
				j.m_type = value_t::number_float;
				j.m_value = val;
				j.assert_invariant();
			}
		};

		template<>
		struct external_constructor<value_t::number_unsigned>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
			{
				j.m_type = value_t::number_unsigned;
				j.m_value = val;
				j.assert_invariant();
			}
		};

		template<>
		struct external_constructor<value_t::number_integer>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
			{
				j.m_type = value_t::number_integer;
				j.m_value = val;
				j.assert_invariant();
			}
		};

		template<>
		struct external_constructor<value_t::array>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
			{
				j.m_type = value_t::array;
				j.m_value = arr;
				j.assert_invariant();
			}

			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
			{
				j.m_type = value_t::array;
				j.m_value = std::move(arr);
				j.assert_invariant();
			}

			template<typename BasicJsonType, typename CompatibleArrayType,
				enable_if_t<not std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
				int> = 0>
				static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
			{
				using std::begin;
				using std::end;
				j.m_type = value_t::array;
				j.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
				j.assert_invariant();
			}

			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, const std::vector<bool>& arr)
			{
				j.m_type = value_t::array;
				j.m_value = value_t::array;
				j.m_value.array->reserve(arr.size());
				for (const bool x : arr)
				{
					j.m_value.array->push_back(x);
				}
				j.assert_invariant();
			}

			template<typename BasicJsonType, typename T,
				enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
				static void construct(BasicJsonType& j, const std::valarray<T>& arr)
			{
				j.m_type = value_t::array;
				j.m_value = value_t::array;
				j.m_value.array->resize(arr.size());
				std::copy(std::begin(arr), std::end(arr), j.m_value.array->begin());
				j.assert_invariant();
			}
		};

		template<>
		struct external_constructor<value_t::object>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
			{
				j.m_type = value_t::object;
				j.m_value = obj;
				j.assert_invariant();
			}

			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
			{
				j.m_type = value_t::object;
				j.m_value = std::move(obj);
				j.assert_invariant();
			}

			template<typename BasicJsonType, typename CompatibleObjectType,
				enable_if_t<not std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int> = 0>
				static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
			{
				using std::begin;
				using std::end;

				j.m_type = value_t::object;
				j.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
				j.assert_invariant();
			}
		};

		/////////////
		// to_json //
		/////////////

		template<typename BasicJsonType, typename T,
			enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
			void to_json(BasicJsonType& j, T b) noexcept
		{
			external_constructor<value_t::boolean>::construct(j, b);
		}

		template<typename BasicJsonType, typename CompatibleString,
			enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
			void to_json(BasicJsonType& j, const CompatibleString& s)
		{
			external_constructor<value_t::string>::construct(j, s);
		}

		template<typename BasicJsonType>
		void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
		{
			external_constructor<value_t::string>::construct(j, std::move(s));
		}

		template<typename BasicJsonType, typename FloatType,
			enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
			void to_json(BasicJsonType& j, FloatType val) noexcept
		{
			external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
		}

		template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
			enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
			void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
		{
			external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
		}

		template<typename BasicJsonType, typename CompatibleNumberIntegerType,
			enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
			void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
		{
			external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
		}

		template<typename BasicJsonType, typename EnumType,
			enable_if_t<std::is_enum<EnumType>::value, int> = 0>
			void to_json(BasicJsonType& j, EnumType e) noexcept
		{
			using underlying_type = typename std::underlying_type<EnumType>::type;
			external_constructor<value_t::number_integer>::construct(j, static_cast<underlying_type>(e));
		}

		template<typename BasicJsonType>
		void to_json(BasicJsonType& j, const std::vector<bool>& e)
		{
			external_constructor<value_t::array>::construct(j, e);
		}

		template <typename BasicJsonType, typename CompatibleArrayType,
			enable_if_t<is_compatible_array_type<BasicJsonType,
			CompatibleArrayType>::value and
			not is_compatible_object_type<
			BasicJsonType, CompatibleArrayType>::value and
			not is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value and
			not is_basic_json<CompatibleArrayType>::value,
			int> = 0>
			void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
		{
			external_constructor<value_t::array>::construct(j, arr);
		}

		template<typename BasicJsonType, typename T,
			enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
			void to_json(BasicJsonType& j, const std::valarray<T>& arr)
		{
			external_constructor<value_t::array>::construct(j, std::move(arr));
		}

		template<typename BasicJsonType>
		void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
		{
			external_constructor<value_t::array>::construct(j, std::move(arr));
		}

		template<typename BasicJsonType, typename CompatibleObjectType,
			enable_if_t<is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value and not is_basic_json<CompatibleObjectType>::value, int> = 0>
			void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
		{
			external_constructor<value_t::object>::construct(j, obj);
		}

		template<typename BasicJsonType>
		void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
		{
			external_constructor<value_t::object>::construct(j, std::move(obj));
		}

		template <
			typename BasicJsonType, typename T, std::size_t N,
			enable_if_t<not std::is_constructible<typename BasicJsonType::string_t,
			const T(&)[N]>::value,
			int> = 0 >
			void to_json(BasicJsonType& j, const T(&arr)[N])
		{
			external_constructor<value_t::array>::construct(j, arr);
		}

		template<typename BasicJsonType, typename... Args>
		void to_json(BasicJsonType& j, const std::pair<Args...>& p)
		{
			j = { p.first, p.second };
		}

		// for https://github.com/nlohmann/json/pull/1134
		template<typename BasicJsonType, typename T,
			enable_if_t<std::is_same<T, typename iteration_proxy<typename BasicJsonType::iterator>::iteration_proxy_internal>::value, int> = 0>
			void to_json(BasicJsonType& j, T b) noexcept
		{
			j = { {b.key(), b.value()} };
		}

		template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
		void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...>)
		{
			j = { std::get<Idx>(t)... };
		}

		template<typename BasicJsonType, typename... Args>
		void to_json(BasicJsonType& j, const std::tuple<Args...>& t)
		{
			to_json_tuple_impl(j, t, index_sequence_for<Args...> {});
		}

		struct to_json_fn
		{
			template<typename BasicJsonType, typename T>
			auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
				-> decltype(to_json(j, std::forward<T>(val)), void())
			{
				return to_json(j, std::forward<T>(val));
			}
		};
	}

	/// namespace to hold default `to_json` function
	namespace
	{
		constexpr const auto& to_json = detail::static_const<detail::to_json_fn>::value;
	}
}

// #include <nlohmann/detail/input/input_adapters.hpp>


#include <cassert> // assert
#include <cstddef> // size_t
#include <cstring> // strlen
#include <istream> // istream
#include <iterator> // begin, end, iterator_traits, random_access_iterator_tag, distance, next
#include <memory> // shared_ptr, make_shared, addressof
#include <numeric> // accumulate
#include <string> // string, char_traits
#include <type_traits> // enable_if, is_base_of, is_pointer, is_integral, remove_pointer
#include <utility> // pair, declval

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
	namespace detail
	{
		/// the supported input formats
		enum class input_format_t { json, cbor, msgpack, ubjson };

		////////////////////
		// input adapters //
		////////////////////

		/*!
		@brief abstract input adapter interface

		Produces a stream of std::char_traits<char>::int_type characters from a
		std::istream, a buffer, or some other input type. Accepts the return of
		exactly one non-EOF character for future input. The int_type characters
		returned consist of all valid char values as positive values (typically
		unsigned char), plus an EOF value outside that range, specified by the value
		of the function std::char_traits<char>::eof(). This value is typically -1, but
		could be any arbitrary value which is not a valid char value.
		*/
		struct input_adapter_protocol
		{
			/// get a character [0,255] or std::char_traits<char>::eof().
			virtual std::char_traits<char>::int_type get_character() = 0;
			virtual ~input_adapter_protocol() = default;
		};

		/// a type to simplify interfaces
		using input_adapter_t = std::shared_ptr<input_adapter_protocol>;

		/*!
		Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at
		beginning of input. Does not support changing the underlying std::streambuf
		in mid-input. Maintains underlying std::istream and std::streambuf to support
		subsequent use of standard std::istream operations to process any input
		characters following those used in parsing the JSON input.  Clears the
		std::istream flags; any input errors (e.g., EOF) will be detected by the first
		subsequent call for input from the std::istream.
		*/
		class input_stream_adapter : public input_adapter_protocol
		{
		public:
			~input_stream_adapter() override
			{
				// clear stream flags; we use underlying streambuf I/O, do not
				// maintain ifstream flags
				is.clear();
			}

			explicit input_stream_adapter(std::istream& i)
				: is(i), sb(*i.rdbuf())
			{}

			// delete because of pointer members
			input_stream_adapter(const input_stream_adapter&) = delete;
			input_stream_adapter& operator=(input_stream_adapter&) = delete;

			// std::istream/std::streambuf use std::char_traits<char>::to_int_type, to
			// ensure that std::char_traits<char>::eof() and the character 0xFF do not
			// end up as the same value, eg. 0xFFFFFFFF.
			std::char_traits<char>::int_type get_character() override
			{
				return sb.sbumpc();
			}

		private:
			/// the associated input stream
			std::istream& is;
			std::streambuf& sb;
		};

		/// input adapter for buffer input
		class input_buffer_adapter : public input_adapter_protocol
		{
		public:
			input_buffer_adapter(const char* b, const std::size_t l)
				: cursor(b), limit(b + l)
			{}

			// delete because of pointer members
			input_buffer_adapter(const input_buffer_adapter&) = delete;
			input_buffer_adapter& operator=(input_buffer_adapter&) = delete;

			std::char_traits<char>::int_type get_character() noexcept override
			{
				if (JSON_LIKELY(cursor < limit))
				{
					return std::char_traits<char>::to_int_type(*(cursor++));
				}

				return std::char_traits<char>::eof();
			}

		private:
			/// pointer to the current character
			const char* cursor;
			/// pointer past the last character
			const char* const limit;
		};

		template<typename WideStringType, size_t T>
		struct wide_string_input_helper
		{
			// UTF-32
			static void fill_buffer(const WideStringType& str, size_t& current_wchar, std::array<std::char_traits<char>::int_type, 4>& utf8_bytes, size_t& utf8_bytes_index, size_t& utf8_bytes_filled)
			{
				utf8_bytes_index = 0;

				if (current_wchar == str.size())
				{
					utf8_bytes[0] = std::char_traits<char>::eof();
					utf8_bytes_filled = 1;
				}
				else
				{
					// get the current character
					const int wc = static_cast<int>(str[current_wchar++]);

					// UTF-32 to UTF-8 encoding
					if (wc < 0x80)
					{
						utf8_bytes[0] = wc;
						utf8_bytes_filled = 1;
					}
					else if (wc <= 0x7FF)
					{
						utf8_bytes[0] = 0xC0 | ((wc >> 6) & 0x1F);
						utf8_bytes[1] = 0x80 | (wc & 0x3F);
						utf8_bytes_filled = 2;
					}
					else if (wc <= 0xFFFF)
					{
						utf8_bytes[0] = 0xE0 | ((wc >> 12) & 0x0F);
						utf8_bytes[1] = 0x80 | ((wc >> 6) & 0x3F);
						utf8_bytes[2] = 0x80 | (wc & 0x3F);
						utf8_bytes_filled = 3;
					}
					else if (wc <= 0x10FFFF)
					{
						utf8_bytes[0] = 0xF0 | ((wc >> 18) & 0x07);
						utf8_bytes[1] = 0x80 | ((wc >> 12) & 0x3F);
						utf8_bytes[2] = 0x80 | ((wc >> 6) & 0x3F);
						utf8_bytes[3] = 0x80 | (wc & 0x3F);
						utf8_bytes_filled = 4;
					}
					else
					{
						// unknown character
						utf8_bytes[0] = wc;
						utf8_bytes_filled = 1;
					}
				}
			}
		};

		template<typename WideStringType>
		struct wide_string_input_helper<WideStringType, 2>
		{
			// UTF-16
			static void fill_buffer(const WideStringType& str, size_t& current_wchar, std::array<std::char_traits<char>::int_type, 4>& utf8_bytes, size_t& utf8_bytes_index, size_t& utf8_bytes_filled)
			{
				utf8_bytes_index = 0;

				if (current_wchar == str.size())
				{
					utf8_bytes[0] = std::char_traits<char>::eof();
					utf8_bytes_filled = 1;
				}
				else
				{
					// get the current character
					const int wc = static_cast<int>(str[current_wchar++]);

					// UTF-16 to UTF-8 encoding
					if (wc < 0x80)
					{
						utf8_bytes[0] = wc;
						utf8_bytes_filled = 1;
					}
					else if (wc <= 0x7FF)
					{
						utf8_bytes[0] = 0xC0 | ((wc >> 6));
						utf8_bytes[1] = 0x80 | (wc & 0x3F);
						utf8_bytes_filled = 2;
					}
					else if (0xD800 > wc or wc >= 0xE000)
					{
						utf8_bytes[0] = 0xE0 | ((wc >> 12));
						utf8_bytes[1] = 0x80 | ((wc >> 6) & 0x3F);
						utf8_bytes[2] = 0x80 | (wc & 0x3F);
						utf8_bytes_filled = 3;
					}
					else
					{
						if (current_wchar < str.size())
						{
							const int wc2 = static_cast<int>(str[current_wchar++]);
							const int charcode = 0x10000 + (((wc & 0x3FF) << 10) | (wc2 & 0x3FF));
							utf8_bytes[0] = 0xf0 | (charcode >> 18);
							utf8_bytes[1] = 0x80 | ((charcode >> 12) & 0x3F);
							utf8_bytes[2] = 0x80 | ((charcode >> 6) & 0x3F);
							utf8_bytes[3] = 0x80 | (charcode & 0x3F);
							utf8_bytes_filled = 4;
						}
						else
						{
							// unknown character
							++current_wchar;
							utf8_bytes[0] = wc;
							utf8_bytes_filled = 1;
						}
					}
				}
			}
		};

		template<typename WideStringType>
		class wide_string_input_adapter : public input_adapter_protocol
		{
		public:
			explicit wide_string_input_adapter(const WideStringType& w) : str(w) {}

			std::char_traits<char>::int_type get_character() noexcept override
			{
				// check if buffer needs to be filled
				if (utf8_bytes_index == utf8_bytes_filled)
				{
					fill_buffer<sizeof(typename WideStringType::value_type)>();

					assert(utf8_bytes_filled > 0);
					assert(utf8_bytes_index == 0);
				}

				// use buffer
				assert(utf8_bytes_filled > 0);
				assert(utf8_bytes_index < utf8_bytes_filled);
				return utf8_bytes[utf8_bytes_index++];
			}

		private:
			template<size_t T>
			void fill_buffer()
			{
				wide_string_input_helper<WideStringType, T>::fill_buffer(str, current_wchar, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
			}

			/// the wstring to process
			const WideStringType& str;

			/// index of the current wchar in str
			std::size_t current_wchar = 0;

			/// a buffer for UTF-8 bytes
			std::array<std::char_traits<char>::int_type, 4> utf8_bytes = { {0, 0, 0, 0} };

			/// index to the utf8_codes array for the next valid byte
			std::size_t utf8_bytes_index = 0;
			/// number of valid bytes in the utf8_codes array
			std::size_t utf8_bytes_filled = 0;
		};

		class input_adapter
		{
		public:
			// native support

			/// input adapter for input stream
			input_adapter(std::istream& i)
				: ia(std::make_shared<input_stream_adapter>(i)) {}

			/// input adapter for input stream
			input_adapter(std::istream&& i)
				: ia(std::make_shared<input_stream_adapter>(i)) {}

			input_adapter(const std::wstring& ws)
				: ia(std::make_shared<wide_string_input_adapter<std::wstring>>(ws)) {}

			input_adapter(const std::u16string& ws)
				: ia(std::make_shared<wide_string_input_adapter<std::u16string>>(ws)) {}

			input_adapter(const std::u32string& ws)
				: ia(std::make_shared<wide_string_input_adapter<std::u32string>>(ws)) {}

			/// input adapter for buffer
			template<typename CharT,
				typename std::enable_if<
				std::is_pointer<CharT>::value and
				std::is_integral<typename std::remove_pointer<CharT>::type>::value and
				sizeof(typename std::remove_pointer<CharT>::type) == 1,
				int>::type = 0>
				input_adapter(CharT b, std::size_t l)
				: ia(std::make_shared<input_buffer_adapter>(reinterpret_cast<const char*>(b), l)) {}

			// derived support

			/// input adapter for string literal
			template<typename CharT,
				typename std::enable_if<
				std::is_pointer<CharT>::value and
				std::is_integral<typename std::remove_pointer<CharT>::type>::value and
				sizeof(typename std::remove_pointer<CharT>::type) == 1,
				int>::type = 0>
				input_adapter(CharT b)
				: input_adapter(reinterpret_cast<const char*>(b),
					std::strlen(reinterpret_cast<const char*>(b))) {}

			/// input adapter for iterator range with contiguous storage
			template<class IteratorType,
				typename std::enable_if<
				std::is_same<typename std::iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
				int>::type = 0>
				input_adapter(IteratorType first, IteratorType last)
			{
#ifndef NDEBUG
				// assertion to check that the iterator range is indeed contiguous,
				// see http://stackoverflow.com/a/35008842/266378 for more discussion
				const auto is_contiguous = std::accumulate(
					first, last, std::pair<bool, int>(true, 0),
					[&first](std::pair<bool, int> res, decltype(*first) val)
				{
					res.first &= (val == *(std::next(std::addressof(*first), res.second++)));
					return res;
				}).first;
				assert(is_contiguous);
#endif

				// assertion to check that each element is 1 byte long
				static_assert(
					sizeof(typename std::iterator_traits<IteratorType>::value_type) == 1,
					"each element in the iterator range must have the size of 1 byte");

				const auto len = static_cast<size_t>(std::distance(first, last));
				if (JSON_LIKELY(len > 0))
				{
					// there is at least one element: use the address of first
					ia = std::make_shared<input_buffer_adapter>(reinterpret_cast<const char*>(&(*first)), len);
				}
				else
				{
					// the address of first cannot be used: use nullptr
					ia = std::make_shared<input_buffer_adapter>(nullptr, len);
				}
			}

			/// input adapter for array
			template<class T, std::size_t N>
			input_adapter(T(&array)[N])
				: input_adapter(std::begin(array), std::end(array)) {}

			/// input adapter for contiguous container
			template<class ContiguousContainer, typename
				std::enable_if<not std::is_pointer<ContiguousContainer>::value and
				std::is_base_of<std::random_access_iterator_tag, typename std::iterator_traits<decltype(std::begin(std::declval<ContiguousContainer const>()))>::iterator_category>::value,
				int>::type = 0>
				input_adapter(const ContiguousContainer& c)
				: input_adapter(std::begin(c), std::end(c)) {}

			operator input_adapter_t()
			{
				return ia;
			}

		private:
			/// the actual adapter
			input_adapter_t ia = nullptr;
		};
	}
}

// #include <nlohmann/detail/input/lexer.hpp>


#include <clocale> // localeconv
#include <cstddef> // size_t
#include <cstdlib> // strtof, strtod, strtold, strtoll, strtoull
#include <cstdio> // snprintf
#include <initializer_list> // initializer_list
#include <string> // char_traits, string
#include <vector> // vector

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>


namespace nlohmann
{
	namespace detail
	{
		///////////
		// lexer //
		///////////

		/*!
		@brief lexical analysis

		This class organizes the lexical analysis during JSON deserialization.
		*/
		template<typename BasicJsonType>
		class lexer
		{
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;

		public:
			/// token types for the parser
			enum class token_type
			{
				uninitialized,    ///< indicating the scanner is uninitialized
				literal_true,     ///< the `true` literal
				literal_false,    ///< the `false` literal
				literal_null,     ///< the `null` literal
				value_string,     ///< a string -- use get_string() for actual value
				value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value
				value_integer,    ///< a signed integer -- use get_number_integer() for actual value
				value_float,      ///< an floating point number -- use get_number_float() for actual value
				begin_array,      ///< the character for array begin `[`
				begin_object,     ///< the character for object begin `{`
				end_array,        ///< the character for array end `]`
				end_object,       ///< the character for object end `}`
				name_separator,   ///< the name separator `:`
				value_separator,  ///< the value separator `,`
				parse_error,      ///< indicating a parse error
				end_of_input,     ///< indicating the end of the input buffer
				literal_or_value  ///< a literal or the begin of a value (only for diagnostics)
			};

			/// return name of values of type token_type (only used for errors)
			static const char* token_type_name(const token_type t) noexcept
			{
				switch (t)
				{
				case token_type::uninitialized:
					return "<uninitialized>";
				case token_type::literal_true:
					return "true literal";
				case token_type::literal_false:
					return "false literal";
				case token_type::literal_null:
					return "null literal";
				case token_type::value_string:
					return "string literal";
				case lexer::token_type::value_unsigned:
				case lexer::token_type::value_integer:
				case lexer::token_type::value_float:
					return "number literal";
				case token_type::begin_array:
					return "'['";
				case token_type::begin_object:
					return "'{'";
				case token_type::end_array:
					return "']'";
				case token_type::end_object:
					return "'}'";
				case token_type::name_separator:
					return "':'";
				case token_type::value_separator:
					return "','";
				case token_type::parse_error:
					return "<parse error>";
				case token_type::end_of_input:
					return "end of input";
				case token_type::literal_or_value:
					return "'[', '{', or a literal";
					// LCOV_EXCL_START
				default: // catch non-enum values
					return "unknown token";
					// LCOV_EXCL_STOP
				}
			}

			explicit lexer(detail::input_adapter_t&& adapter)
				: ia(std::move(adapter)), decimal_point_char(get_decimal_point()) {}

			// delete because of pointer members
			lexer(const lexer&) = delete;
			lexer& operator=(lexer&) = delete;

		private:
			/////////////////////
			// locales
			/////////////////////

			/// return the locale-dependent decimal point
			static char get_decimal_point() noexcept
			{
				const auto loc = localeconv();
				assert(loc != nullptr);
				return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
			}

			/////////////////////
			// scan functions
			/////////////////////

			/*!
			@brief get codepoint from 4 hex characters following `\u`

			For input "\u c1 c2 c3 c4" the codepoint is:
			  (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4
			= (c1 << 12) + (c2 << 8) + (c3 << 4) + (c4 << 0)

			Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'
			must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The
			conversion is done by subtracting the offset (0x30, 0x37, and 0x57)
			between the ASCII value of the character and the desired integer value.

			@return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
					non-hex character)
			*/
			int get_codepoint()
			{
				// this function only makes sense after reading `\u`
				assert(current == 'u');
				int codepoint = 0;

				const auto factors = { 12, 8, 4, 0 };
				for (const auto factor : factors)
				{
					get();

					if (current >= '0' and current <= '9')
					{
						codepoint += ((current - 0x30) << factor);
					}
					else if (current >= 'A' and current <= 'F')
					{
						codepoint += ((current - 0x37) << factor);
					}
					else if (current >= 'a' and current <= 'f')
					{
						codepoint += ((current - 0x57) << factor);
					}
					else
					{
						return -1;
					}
				}

				assert(0x0000 <= codepoint and codepoint <= 0xFFFF);
				return codepoint;
			}

			/*!
			@brief check if the next byte(s) are inside a given range

			Adds the current byte and, for each passed range, reads a new byte and
			checks if it is inside the range. If a violation was detected, set up an
			error message and return false. Otherwise, return true.

			@param[in] ranges  list of integers; interpreted as list of pairs of
							   inclusive lower and upper bound, respectively

			@pre The passed list @a ranges must have 2, 4, or 6 elements; that is,
				 1, 2, or 3 pairs. This precondition is enforced by an assertion.

			@return true if and only if no range violation was detected
			*/
			bool next_byte_in_range(std::initializer_list<int> ranges)
			{
				assert(ranges.size() == 2 or ranges.size() == 4 or ranges.size() == 6);
				add(current);

				for (auto range = ranges.begin(); range != ranges.end(); ++range)
				{
					get();
					if (JSON_LIKELY(*range <= current and current <= *(++range)))
					{
						add(current);
					}
					else
					{
						error_message = "invalid string: ill-formed UTF-8 byte";
						return false;
					}
				}

				return true;
			}

			/*!
			@brief scan a string literal

			This function scans a string according to Sect. 7 of RFC 7159. While
			scanning, bytes are escaped and copied into buffer token_buffer. Then the
			function returns successfully, token_buffer is *not* null-terminated (as it
			may contain \0 bytes), and token_buffer.size() is the number of bytes in the
			string.

			@return token_type::value_string if string could be successfully scanned,
					token_type::parse_error otherwise

			@note In case of errors, variable error_message contains a textual
				  description.
			*/
			token_type scan_string()
			{
				// reset token_buffer (ignore opening quote)
				reset();

				// we entered the function by reading an open quote
				assert(current == '\"');

				while (true)
				{
					// get next character
					switch (get())
					{
						// end of file while parsing string
					case std::char_traits<char>::eof():
					{
						error_message = "invalid string: missing closing quote";
						return token_type::parse_error;
					}

					// closing quote
					case '\"':
					{
						return token_type::value_string;
					}

					// escapes
					case '\\':
					{
						switch (get())
						{
							// quotation mark
						case '\"':
							add('\"');
							break;
							// reverse solidus
						case '\\':
							add('\\');
							break;
							// solidus
						case '/':
							add('/');
							break;
							// backspace
						case 'b':
							add('\b');
							break;
							// form feed
						case 'f':
							add('\f');
							break;
							// line feed
						case 'n':
							add('\n');
							break;
							// carriage return
						case 'r':
							add('\r');
							break;
							// tab
						case 't':
							add('\t');
							break;

							// unicode escapes
						case 'u':
						{
							const int codepoint1 = get_codepoint();
							int codepoint = codepoint1; // start with codepoint1

							if (JSON_UNLIKELY(codepoint1 == -1))
							{
								error_message = "invalid string: '\\u' must be followed by 4 hex digits";
								return token_type::parse_error;
							}

							// check if code point is a high surrogate
							if (0xD800 <= codepoint1 and codepoint1 <= 0xDBFF)
							{
								// expect next \uxxxx entry
								if (JSON_LIKELY(get() == '\\' and get() == 'u'))
								{
									const int codepoint2 = get_codepoint();

									if (JSON_UNLIKELY(codepoint2 == -1))
									{
										error_message = "invalid string: '\\u' must be followed by 4 hex digits";
										return token_type::parse_error;
									}

									// check if codepoint2 is a low surrogate
									if (JSON_LIKELY(0xDC00 <= codepoint2 and codepoint2 <= 0xDFFF))
									{
										// overwrite codepoint
										codepoint =
											// high surrogate occupies the most significant 22 bits
											(codepoint1 << 10)
											// low surrogate occupies the least significant 15 bits
											+ codepoint2
											// there is still the 0xD800, 0xDC00 and 0x10000 noise
											// in the result so we have to subtract with:
											// (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
											-0x35FDC00;
									}
									else
									{
										error_message = "invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF";
										return token_type::parse_error;
									}
								}
								else
								{
									error_message = "invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF";
									return token_type::parse_error;
								}
							}
							else
							{
								if (JSON_UNLIKELY(0xDC00 <= codepoint1 and codepoint1 <= 0xDFFF))
								{
									error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
									return token_type::parse_error;
								}
							}

							// result of the above calculation yields a proper codepoint
							assert(0x00 <= codepoint and codepoint <= 0x10FFFF);

							// translate codepoint into bytes
							if (codepoint < 0x80)
							{
								// 1-byte characters: 0xxxxxxx (ASCII)
								add(codepoint);
							}
							else if (codepoint <= 0x7FF)
							{
								// 2-byte characters: 110xxxxx 10xxxxxx
								add(0xC0 | (codepoint >> 6));
								add(0x80 | (codepoint & 0x3F));
							}
							else if (codepoint <= 0xFFFF)
							{
								// 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
								add(0xE0 | (codepoint >> 12));
								add(0x80 | ((codepoint >> 6) & 0x3F));
								add(0x80 | (codepoint & 0x3F));
							}
							else
							{
								// 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
								add(0xF0 | (codepoint >> 18));
								add(0x80 | ((codepoint >> 12) & 0x3F));
								add(0x80 | ((codepoint >> 6) & 0x3F));
								add(0x80 | (codepoint & 0x3F));
							}

							break;
						}

						// other characters after escape
						default:
							error_message = "invalid string: forbidden character after backslash";
							return token_type::parse_error;
						}

						break;
					}

					// invalid control characters
					case 0x00:
					case 0x01:
					case 0x02:
					case 0x03:
					case 0x04:
					case 0x05:
					case 0x06:
					case 0x07:
					case 0x08:
					case 0x09:
					case 0x0A:
					case 0x0B:
					case 0x0C:
					case 0x0D:
					case 0x0E:
					case 0x0F:
					case 0x10:
					case 0x11:
					case 0x12:
					case 0x13:
					case 0x14:
					case 0x15:
					case 0x16:
					case 0x17:
					case 0x18:
					case 0x19:
					case 0x1A:
					case 0x1B:
					case 0x1C:
					case 0x1D:
					case 0x1E:
					case 0x1F:
					{
						error_message = "invalid string: control character must be escaped";
						return token_type::parse_error;
					}

					// U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))
					case 0x20:
					case 0x21:
					case 0x23:
					case 0x24:
					case 0x25:
					case 0x26:
					case 0x27:
					case 0x28:
					case 0x29:
					case 0x2A:
					case 0x2B:
					case 0x2C:
					case 0x2D:
					case 0x2E:
					case 0x2F:
					case 0x30:
					case 0x31:
					case 0x32:
					case 0x33:
					case 0x34:
					case 0x35:
					case 0x36:
					case 0x37:
					case 0x38:
					case 0x39:
					case 0x3A:
					case 0x3B:
					case 0x3C:
					case 0x3D:
					case 0x3E:
					case 0x3F:
					case 0x40:
					case 0x41:
					case 0x42:
					case 0x43:
					case 0x44:
					case 0x45:
					case 0x46:
					case 0x47:
					case 0x48:
					case 0x49:
					case 0x4A:
					case 0x4B:
					case 0x4C:
					case 0x4D:
					case 0x4E:
					case 0x4F:
					case 0x50:
					case 0x51:
					case 0x52:
					case 0x53:
					case 0x54:
					case 0x55:
					case 0x56:
					case 0x57:
					case 0x58:
					case 0x59:
					case 0x5A:
					case 0x5B:
					case 0x5D:
					case 0x5E:
					case 0x5F:
					case 0x60:
					case 0x61:
					case 0x62:
					case 0x63:
					case 0x64:
					case 0x65:
					case 0x66:
					case 0x67:
					case 0x68:
					case 0x69:
					case 0x6A:
					case 0x6B:
					case 0x6C:
					case 0x6D:
					case 0x6E:
					case 0x6F:
					case 0x70:
					case 0x71:
					case 0x72:
					case 0x73:
					case 0x74:
					case 0x75:
					case 0x76:
					case 0x77:
					case 0x78:
					case 0x79:
					case 0x7A:
					case 0x7B:
					case 0x7C:
					case 0x7D:
					case 0x7E:
					case 0x7F:
					{
						add(current);
						break;
					}

					// U+0080..U+07FF: bytes C2..DF 80..BF
					case 0xC2:
					case 0xC3:
					case 0xC4:
					case 0xC5:
					case 0xC6:
					case 0xC7:
					case 0xC8:
					case 0xC9:
					case 0xCA:
					case 0xCB:
					case 0xCC:
					case 0xCD:
					case 0xCE:
					case 0xCF:
					case 0xD0:
					case 0xD1:
					case 0xD2:
					case 0xD3:
					case 0xD4:
					case 0xD5:
					case 0xD6:
					case 0xD7:
					case 0xD8:
					case 0xD9:
					case 0xDA:
					case 0xDB:
					case 0xDC:
					case 0xDD:
					case 0xDE:
					case 0xDF:
					{
						if (JSON_UNLIKELY(not next_byte_in_range({ 0x80, 0xBF })))
						{
							return token_type::parse_error;
						}
						break;
					}

					// U+0800..U+0FFF: bytes E0 A0..BF 80..BF
					case 0xE0:
					{
						if (JSON_UNLIKELY(not (next_byte_in_range({ 0xA0, 0xBF, 0x80, 0xBF }))))
						{
							return token_type::parse_error;
						}
						break;
					}

					// U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF
					// U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF
					case 0xE1:
					case 0xE2:
					case 0xE3:
					case 0xE4:
					case 0xE5:
					case 0xE6:
					case 0xE7:
					case 0xE8:
					case 0xE9:
					case 0xEA:
					case 0xEB:
					case 0xEC:
					case 0xEE:
					case 0xEF:
					{
						if (JSON_UNLIKELY(not (next_byte_in_range({ 0x80, 0xBF, 0x80, 0xBF }))))
						{
							return token_type::parse_error;
						}
						break;
					}

					// U+D000..U+D7FF: bytes ED 80..9F 80..BF
					case 0xED:
					{
						if (JSON_UNLIKELY(not (next_byte_in_range({ 0x80, 0x9F, 0x80, 0xBF }))))
						{
							return token_type::parse_error;
						}
						break;
					}

					// U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
					case 0xF0:
					{
						if (JSON_UNLIKELY(not (next_byte_in_range({ 0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF }))))
						{
							return token_type::parse_error;
						}
						break;
					}

					// U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
					case 0xF1:
					case 0xF2:
					case 0xF3:
					{
						if (JSON_UNLIKELY(not (next_byte_in_range({ 0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF }))))
						{
							return token_type::parse_error;
						}
						break;
					}

					// U+100000..U+10FFFF F4 80..8F 80..BF 80..BF
					case 0xF4:
					{
						if (JSON_UNLIKELY(not (next_byte_in_range({ 0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF }))))
						{
							return token_type::parse_error;
						}
						break;
					}

					// remaining bytes (80..C1 and F5..FF) are ill-formed
					default:
					{
						error_message = "invalid string: ill-formed UTF-8 byte";
						return token_type::parse_error;
					}
					}
				}
			}

			static void strtof(float& f, const char* str, char** endptr) noexcept
			{
				f = std::strtof(str, endptr);
			}

			static void strtof(double& f, const char* str, char** endptr) noexcept
			{
				f = std::strtod(str, endptr);
			}

			static void strtof(long double& f, const char* str, char** endptr) noexcept
			{
				f = std::strtold(str, endptr);
			}

			/*!
			@brief scan a number literal

			This function scans a string according to Sect. 6 of RFC 7159.

			The function is realized with a deterministic finite state machine derived
			from the grammar described in RFC 7159. Starting in state "init", the
			input is read and used to determined the next state. Only state "done"
			accepts the number. State "error" is a trap state to model errors. In the
			table below, "anything" means any character but the ones listed before.

			state    | 0        | 1-9      | e E      | +       | -       | .        | anything
			---------|----------|----------|----------|---------|---------|----------|-----------
			init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]
			minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]
			zero     | done     | done     | exponent | done    | done    | decimal1 | done
			any1     | any1     | any1     | exponent | done    | done    | decimal1 | done
			decimal1 | decimal2 | [error]  | [error]  | [error] | [error] | [error]  | [error]
			decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done
			exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]
			sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]
			any2     | any2     | any2     | done     | done    | done    | done     | done

			The state machine is realized with one label per state (prefixed with
			"scan_number_") and `goto` statements between them. The state machine
			contains cycles, but any cycle can be left when EOF is read. Therefore,
			the function is guaranteed to terminate.

			During scanning, the read bytes are stored in token_buffer. This string is
			then converted to a signed integer, an unsigned integer, or a
			floating-point number.

			@return token_type::value_unsigned, token_type::value_integer, or
					token_type::value_float if number could be successfully scanned,
					token_type::parse_error otherwise

			@note The scanner is independent of the current locale. Internally, the
				  locale's decimal point is used instead of `.` to work with the
				  locale-dependent converters.
			*/
			token_type scan_number()
			{
				// reset token_buffer to store the number's bytes
				reset();

				// the type of the parsed number; initially set to unsigned; will be
				// changed if minus sign, decimal point or exponent is read
				token_type number_type = token_type::value_unsigned;

				// state (init): we just found out we need to scan a number
				switch (current)
				{
				case '-':
				{
					add(current);
					goto scan_number_minus;
				}

				case '0':
				{
					add(current);
					goto scan_number_zero;
				}

				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_any1;
				}

				// LCOV_EXCL_START
				default:
				{
					// all other characters are rejected outside scan_number()
					assert(false);
				}
				// LCOV_EXCL_STOP
				}

			scan_number_minus:
				// state: we just parsed a leading minus sign
				number_type = token_type::value_integer;
				switch (get())
				{
				case '0':
				{
					add(current);
					goto scan_number_zero;
				}

				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_any1;
				}

				default:
				{
					error_message = "invalid number; expected digit after '-'";
					return token_type::parse_error;
				}
				}

			scan_number_zero:
				// state: we just parse a zero (maybe with a leading minus sign)
				switch (get())
				{
				case '.':
				{
					add(decimal_point_char);
					goto scan_number_decimal1;
				}

				case 'e':
				case 'E':
				{
					add(current);
					goto scan_number_exponent;
				}

				default:
					goto scan_number_done;
				}

			scan_number_any1:
				// state: we just parsed a number 0-9 (maybe with a leading minus sign)
				switch (get())
				{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_any1;
				}

				case '.':
				{
					add(decimal_point_char);
					goto scan_number_decimal1;
				}

				case 'e':
				case 'E':
				{
					add(current);
					goto scan_number_exponent;
				}

				default:
					goto scan_number_done;
				}

			scan_number_decimal1:
				// state: we just parsed a decimal point
				number_type = token_type::value_float;
				switch (get())
				{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_decimal2;
				}

				default:
				{
					error_message = "invalid number; expected digit after '.'";
					return token_type::parse_error;
				}
				}

			scan_number_decimal2:
				// we just parsed at least one number after a decimal point
				switch (get())
				{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_decimal2;
				}

				case 'e':
				case 'E':
				{
					add(current);
					goto scan_number_exponent;
				}

				default:
					goto scan_number_done;
				}

			scan_number_exponent:
				// we just parsed an exponent
				number_type = token_type::value_float;
				switch (get())
				{
				case '+':
				case '-':
				{
					add(current);
					goto scan_number_sign;
				}

				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_any2;
				}

				default:
				{
					error_message =
						"invalid number; expected '+', '-', or digit after exponent";
					return token_type::parse_error;
				}
				}

			scan_number_sign:
				// we just parsed an exponent sign
				switch (get())
				{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_any2;
				}

				default:
				{
					error_message = "invalid number; expected digit after exponent sign";
					return token_type::parse_error;
				}
				}

			scan_number_any2:
				// we just parsed a number after the exponent or exponent sign
				switch (get())
				{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_any2;
				}

				default:
					goto scan_number_done;
				}

			scan_number_done:
				// unget the character after the number (we only read it to know that
				// we are done scanning a number)
				unget();

				char* endptr = nullptr;
				errno = 0;

				// try to parse integers first and fall back to floats
				if (number_type == token_type::value_unsigned)
				{
					const auto x = std::strtoull(token_buffer.data(), &endptr, 10);

					// we checked the number format before
					assert(endptr == token_buffer.data() + token_buffer.size());

					if (errno == 0)
					{
						value_unsigned = static_cast<number_unsigned_t>(x);
						if (value_unsigned == x)
						{
							return token_type::value_unsigned;
						}
					}
				}
				else if (number_type == token_type::value_integer)
				{
					const auto x = std::strtoll(token_buffer.data(), &endptr, 10);

					// we checked the number format before
					assert(endptr == token_buffer.data() + token_buffer.size());

					if (errno == 0)
					{
						value_integer = static_cast<number_integer_t>(x);
						if (value_integer == x)
						{
							return token_type::value_integer;
						}
					}
				}

				// this code is reached if we parse a floating-point number or if an
				// integer conversion above failed
				strtof(value_float, token_buffer.data(), &endptr);

				// we checked the number format before
				assert(endptr == token_buffer.data() + token_buffer.size());

				return token_type::value_float;
			}

			/*!
			@param[in] literal_text  the literal text to expect
			@param[in] length        the length of the passed literal text
			@param[in] return_type   the token type to return on success
			*/
			token_type scan_literal(const char* literal_text, const std::size_t length,
				token_type return_type)
			{
				assert(current == literal_text[0]);
				for (std::size_t i = 1; i < length; ++i)
				{
					if (JSON_UNLIKELY(get() != literal_text[i]))
					{
						error_message = "invalid literal";
						return token_type::parse_error;
					}
				}
				return return_type;
			}

			/////////////////////
			// input management
			/////////////////////

			/// reset token_buffer; current character is beginning of token
			void reset() noexcept
			{
				token_buffer.clear();
				token_string.clear();
				token_string.push_back(std::char_traits<char>::to_char_type(current));
			}

			/*
			@brief get next character from the input

			This function provides the interface to the used input adapter. It does
			not throw in case the input reached EOF, but returns a
			`std::char_traits<char>::eof()` in that case.  Stores the scanned characters
			for use in error messages.

			@return character read from the input
			*/
			std::char_traits<char>::int_type get()
			{
				++chars_read;
				if (next_unget)
				{
					// just reset the next_unget variable and work with current
					next_unget = false;
				}
				else
				{
					current = ia->get_character();
				}

				if (JSON_LIKELY(current != std::char_traits<char>::eof()))
				{
					token_string.push_back(std::char_traits<char>::to_char_type(current));
				}
				return current;
			}

			/*!
			@brief unget current character (read it again on next get)

			We implement unget by setting variable next_unget to true. The input is not
			changed - we just simulate ungetting by modifying chars_read and
			token_string. The next call to get() will behave as if the unget character
			is read again.
			*/
			void unget()
			{
				next_unget = true;
				--chars_read;
				if (JSON_LIKELY(current != std::char_traits<char>::eof()))
				{
					assert(token_string.size() != 0);
					token_string.pop_back();
				}
			}

			/// add a character to token_buffer
			void add(int c)
			{
				token_buffer.push_back(std::char_traits<char>::to_char_type(c));
			}

		public:
			/////////////////////
			// value getters
			/////////////////////

			/// return integer value
			constexpr number_integer_t get_number_integer() const noexcept
			{
				return value_integer;
			}

			/// return unsigned integer value
			constexpr number_unsigned_t get_number_unsigned() const noexcept
			{
				return value_unsigned;
			}

			/// return floating-point value
			constexpr number_float_t get_number_float() const noexcept
			{
				return value_float;
			}

			/// return current string value (implicitly resets the token; useful only once)
			string_t& get_string()
			{
				return token_buffer;
			}

			/////////////////////
			// diagnostics
			/////////////////////

			/// return position of last read token
			constexpr std::size_t get_position() const noexcept
			{
				return chars_read;
			}

			/// return the last read token (for errors only).  Will never contain EOF
			/// (an arbitrary value that is not a valid char value, often -1), because
			/// 255 may legitimately occur.  May contain NUL, which should be escaped.
			std::string get_token_string() const
			{
				// escape control characters
				std::string result;
				for (const auto c : token_string)
				{
					if ('\x00' <= c and c <= '\x1F')
					{
						// escape control characters
						char cs[9];
						snprintf(cs, 9, "<U+%.4X>", static_cast<unsigned char>(c));
						result += cs;
					}
					else
					{
						// add character as is
						result.push_back(c);
					}
				}

				return result;
			}

			/// return syntax error message
			constexpr const char* get_error_message() const noexcept
			{
				return error_message;
			}

			/////////////////////
			// actual scanner
			/////////////////////

			/*!
			@brief skip the UTF-8 byte order mark
			@return true iff there is no BOM or the correct BOM has been skipped
			*/
			bool skip_bom()
			{
				if (get() == 0xEF)
				{
					if (get() == 0xBB and get() == 0xBF)
					{
						// we completely parsed the BOM
						return true;
					}
					else
					{
						// after reading 0xEF, an unexpected character followed
						return false;
					}
				}
				else
				{
					// the first character is not the beginning of the BOM; unget it to
					// process is later
					unget();
					return true;
				}
			}

			token_type scan()
			{
				// initially, skip the BOM
				if (chars_read == 0 and not skip_bom())
				{
					error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
					return token_type::parse_error;
				}

				// read next character and ignore whitespace
				do
				{
					get();
				} while (current == ' ' or current == '\t' or current == '\n' or current == '\r');

				switch (current)
				{
					// structural characters
				case '[':
					return token_type::begin_array;
				case ']':
					return token_type::end_array;
				case '{':
					return token_type::begin_object;
				case '}':
					return token_type::end_object;
				case ':':
					return token_type::name_separator;
				case ',':
					return token_type::value_separator;

					// literals
				case 't':
					return scan_literal("true", 4, token_type::literal_true);
				case 'f':
					return scan_literal("false", 5, token_type::literal_false);
				case 'n':
					return scan_literal("null", 4, token_type::literal_null);

					// string
				case '\"':
					return scan_string();

					// number
				case '-':
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					return scan_number();

					// end of input (the null byte is needed when parsing from
					// string literals)
				case '\0':
				case std::char_traits<char>::eof():
					return token_type::end_of_input;

					// error
				default:
					error_message = "invalid literal";
					return token_type::parse_error;
				}
			}

		private:
			/// input adapter
			detail::input_adapter_t ia = nullptr;

			/// the current character
			std::char_traits<char>::int_type current = std::char_traits<char>::eof();

			/// whether the next get() call should just return current
			bool next_unget = false;

			/// the number of characters read
			std::size_t chars_read = 0;

			/// raw input token string (for error messages)
			std::vector<char> token_string{};

			/// buffer for variable-length tokens (numbers, strings)
			string_t token_buffer{};

			/// a description of occurred lexer errors
			const char* error_message = "";

			// number values
			number_integer_t value_integer = 0;
			number_unsigned_t value_unsigned = 0;
			number_float_t value_float = 0;

			/// the decimal point
			const char decimal_point_char = '.';
		};
	}
}

// #include <nlohmann/detail/input/parser.hpp>


#include <cassert> // assert
#include <cmath> // isfinite
#include <cstdint> // uint8_t
#include <functional> // function
#include <string> // string
#include <utility> // move

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>


#include <cstdint> // size_t
#include <utility> // declval

// #include <nlohmann/detail/meta/detected.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


namespace nlohmann
{
	namespace detail
	{
		template <typename T>
		using null_function_t = decltype(std::declval<T&>().null());

		template <typename T>
		using boolean_function_t =
			decltype(std::declval<T&>().boolean(std::declval<bool>()));

		template <typename T, typename Integer>
		using number_integer_function_t =
			decltype(std::declval<T&>().number_integer(std::declval<Integer>()));

		template <typename T, typename Unsigned>
		using number_unsigned_function_t =
			decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));

		template <typename T, typename Float, typename String>
		using number_float_function_t = decltype(std::declval<T&>().number_float(
			std::declval<Float>(), std::declval<const String&>()));

		template <typename T, typename String>
		using string_function_t =
			decltype(std::declval<T&>().string(std::declval<String&>()));

		template <typename T>
		using start_object_function_t =
			decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));

		template <typename T, typename String>
		using key_function_t =
			decltype(std::declval<T&>().key(std::declval<String&>()));

		template <typename T>
		using end_object_function_t = decltype(std::declval<T&>().end_object());

		template <typename T>
		using start_array_function_t =
			decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));

		template <typename T>
		using end_array_function_t = decltype(std::declval<T&>().end_array());

		template <typename T, typename Exception>
		using parse_error_function_t = decltype(std::declval<T&>().parse_error(
			std::declval<std::size_t>(), std::declval<const std::string&>(),
			std::declval<const Exception&>()));

		template <typename SAX, typename BasicJsonType>
		struct is_sax
		{
		private:
			static_assert(is_basic_json<BasicJsonType>::value,
				"BasicJsonType must be of type basic_json<...>");

			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;
			using exception_t = typename BasicJsonType::exception;

		public:
			static constexpr bool value =
				is_detected_exact<bool, null_function_t, SAX>::value &&
				is_detected_exact<bool, boolean_function_t, SAX>::value &&
				is_detected_exact<bool, number_integer_function_t, SAX,
				number_integer_t>::value &&
				is_detected_exact<bool, number_unsigned_function_t, SAX,
				number_unsigned_t>::value &&
				is_detected_exact<bool, number_float_function_t, SAX, number_float_t,
				string_t>::value &&
				is_detected_exact<bool, string_function_t, SAX, string_t>::value &&
				is_detected_exact<bool, start_object_function_t, SAX>::value &&
				is_detected_exact<bool, key_function_t, SAX, string_t>::value &&
				is_detected_exact<bool, end_object_function_t, SAX>::value &&
				is_detected_exact<bool, start_array_function_t, SAX>::value &&
				is_detected_exact<bool, end_array_function_t, SAX>::value &&
				is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;
		};

		template <typename SAX, typename BasicJsonType>
		struct is_sax_static_asserts
		{
		private:
			static_assert(is_basic_json<BasicJsonType>::value,
				"BasicJsonType must be of type basic_json<...>");

			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;
			using exception_t = typename BasicJsonType::exception;

		public:
			static_assert(is_detected_exact<bool, null_function_t, SAX>::value,
				"Missing/invalid function: bool null()");
			static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
				"Missing/invalid function: bool boolean(bool)");
			static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
				"Missing/invalid function: bool boolean(bool)");
			static_assert(
				is_detected_exact<bool, number_integer_function_t, SAX,
				number_integer_t>::value,
				"Missing/invalid function: bool number_integer(number_integer_t)");
			static_assert(
				is_detected_exact<bool, number_unsigned_function_t, SAX,
				number_unsigned_t>::value,
				"Missing/invalid function: bool number_unsigned(number_unsigned_t)");
			static_assert(is_detected_exact<bool, number_float_function_t, SAX,
				number_float_t, string_t>::value,
				"Missing/invalid function: bool number_float(number_float_t, const string_t&)");
			static_assert(
				is_detected_exact<bool, string_function_t, SAX, string_t>::value,
				"Missing/invalid function: bool string(string_t&)");
			static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,
				"Missing/invalid function: bool start_object(std::size_t)");
			static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,
				"Missing/invalid function: bool key(string_t&)");
			static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,
				"Missing/invalid function: bool end_object()");
			static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,
				"Missing/invalid function: bool start_array(std::size_t)");
			static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,
				"Missing/invalid function: bool end_array()");
			static_assert(
				is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,
				"Missing/invalid function: bool parse_error(std::size_t, const "
				"std::string&, const exception&)");
		};
	}
}

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/json_sax.hpp>


#include <cstddef>
#include <string>
#include <vector>

// #include <nlohmann/detail/input/parser.hpp>

// #include <nlohmann/detail/exceptions.hpp>


namespace nlohmann
{

	/*!
	@brief SAX interface

	This class describes the SAX interface used by @ref nlohmann::json::sax_parse.
	Each function is called in different situations while the input is parsed. The
	boolean return value informs the parser whether to continue processing the
	input.
	*/
	template<typename BasicJsonType>
	struct json_sax
	{
		/// type for (signed) integers
		using number_integer_t = typename BasicJsonType::number_integer_t;
		/// type for unsigned integers
		using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
		/// type for floating-point numbers
		using number_float_t = typename BasicJsonType::number_float_t;
		/// type for strings
		using string_t = typename BasicJsonType::string_t;

		/*!
		@brief a null value was read
		@return whether parsing should proceed
		*/
		virtual bool null() = 0;

		/*!
		@brief a boolean value was read
		@param[in] val  boolean value
		@return whether parsing should proceed
		*/
		virtual bool boolean(bool val) = 0;

		/*!
		@brief an integer number was read
		@param[in] val  integer value
		@return whether parsing should proceed
		*/
		virtual bool number_integer(number_integer_t val) = 0;

		/*!
		@brief an unsigned integer number was read
		@param[in] val  unsigned integer value
		@return whether parsing should proceed
		*/
		virtual bool number_unsigned(number_unsigned_t val) = 0;

		/*!
		@brief an floating-point number was read
		@param[in] val  floating-point value
		@param[in] s    raw token value
		@return whether parsing should proceed
		*/
		virtual bool number_float(number_float_t val, const string_t& s) = 0;

		/*!
		@brief a string was read
		@param[in] val  string value
		@return whether parsing should proceed
		@note It is safe to move the passed string.
		*/
		virtual bool string(string_t& val) = 0;

		/*!
		@brief the beginning of an object was read
		@param[in] elements  number of object elements or -1 if unknown
		@return whether parsing should proceed
		@note binary formats may report the number of elements
		*/
		virtual bool start_object(std::size_t elements) = 0;

		/*!
		@brief an object key was read
		@param[in] val  object key
		@return whether parsing should proceed
		@note It is safe to move the passed string.
		*/
		virtual bool key(string_t& val) = 0;

		/*!
		@brief the end of an object was read
		@return whether parsing should proceed
		*/
		virtual bool end_object() = 0;

		/*!
		@brief the beginning of an array was read
		@param[in] elements  number of array elements or -1 if unknown
		@return whether parsing should proceed
		@note binary formats may report the number of elements
		*/
		virtual bool start_array(std::size_t elements) = 0;

		/*!
		@brief the end of an array was read
		@return whether parsing should proceed
		*/
		virtual bool end_array() = 0;

		/*!
		@brief a parse error occurred
		@param[in] position    the position in the input where the error occurs
		@param[in] last_token  the last read token
		@param[in] error_msg   a detailed error message
		@return whether parsing should proceed (must return false)
		*/
		virtual bool parse_error(std::size_t position,
			const std::string& last_token,
			const detail::exception& ex) = 0;

		virtual ~json_sax() = default;
	};


	namespace detail
	{
		/*!
		@brief SAX implementation to create a JSON value from SAX events

		This class implements the @ref json_sax interface and processes the SAX events
		to create a JSON value which makes it basically a DOM parser. The structure or
		hierarchy of the JSON value is managed by the stack `ref_stack` which contains
		a pointer to the respective array or object for each recursion depth.

		After successful parsing, the value that is passed by reference to the
		constructor contains the parsed value.

		@tparam BasicJsonType  the JSON type
		*/
		template<typename BasicJsonType>
		class json_sax_dom_parser
		{
		public:
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;

			/*!
			@param[in, out] r  reference to a JSON value that is manipulated while
							   parsing
			@param[in] allow_exceptions_  whether parse errors yield exceptions
			*/
			explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true)
				: root(r), allow_exceptions(allow_exceptions_)
			{}

			bool null()
			{
				handle_value(nullptr);
				return true;
			}

			bool boolean(bool val)
			{
				handle_value(val);
				return true;
			}

			bool number_integer(number_integer_t val)
			{
				handle_value(val);
				return true;
			}

			bool number_unsigned(number_unsigned_t val)
			{
				handle_value(val);
				return true;
			}

			bool number_float(number_float_t val, const string_t&)
			{
				handle_value(val);
				return true;
			}

			bool string(string_t& val)
			{
				handle_value(val);
				return true;
			}

			bool start_object(std::size_t len)
			{
				ref_stack.push_back(handle_value(BasicJsonType::value_t::object));

				if (JSON_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
				{
					JSON_THROW(out_of_range::create(408,
						"excessive object size: " + std::to_string(len)));
				}

				return true;
			}

			bool key(string_t& val)
			{
				// add null at given key and store the reference for later
				object_element = &(ref_stack.back()->m_value.object->operator[](val));
				return true;
			}

			bool end_object()
			{
				ref_stack.pop_back();
				return true;
			}

			bool start_array(std::size_t len)
			{
				ref_stack.push_back(handle_value(BasicJsonType::value_t::array));

				if (JSON_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
				{
					JSON_THROW(out_of_range::create(408,
						"excessive array size: " + std::to_string(len)));
				}

				return true;
			}

			bool end_array()
			{
				ref_stack.pop_back();
				return true;
			}

			bool parse_error(std::size_t, const std::string&,
				const detail::exception& ex)
			{
				errored = true;
				if (allow_exceptions)
				{
					// determine the proper exception type from the id
					switch ((ex.id / 100) % 100)
					{
					case 1:
						JSON_THROW(*reinterpret_cast<const detail::parse_error*>(&ex));
					case 4:
						JSON_THROW(*reinterpret_cast<const detail::out_of_range*>(&ex));
						// LCOV_EXCL_START
					case 2:
						JSON_THROW(*reinterpret_cast<const detail::invalid_iterator*>(&ex));
					case 3:
						JSON_THROW(*reinterpret_cast<const detail::type_error*>(&ex));
					case 5:
						JSON_THROW(*reinterpret_cast<const detail::other_error*>(&ex));
					default:
						assert(false);
						// LCOV_EXCL_STOP
					}
				}
				return false;
			}

			constexpr bool is_errored() const
			{
				return errored;
			}

		private:
			/*!
			@invariant If the ref stack is empty, then the passed value will be the new
					   root.
			@invariant If the ref stack contains a value, then it is an array or an
					   object to which we can add elements
			*/
			template<typename Value>
			BasicJsonType* handle_value(Value&& v)
			{
				if (ref_stack.empty())
				{
					root = BasicJsonType(std::forward<Value>(v));
					return &root;
				}
				else
				{
					assert(ref_stack.back()->is_array() or ref_stack.back()->is_object());
					if (ref_stack.back()->is_array())
					{
						ref_stack.back()->m_value.array->emplace_back(std::forward<Value>(v));
						return &(ref_stack.back()->m_value.array->back());
					}
					else
					{
						assert(object_element);
						*object_element = BasicJsonType(std::forward<Value>(v));
						return object_element;
					}
				}
			}

			/// the parsed JSON value
			BasicJsonType& root;
			/// stack to model hierarchy of values
			std::vector<BasicJsonType*> ref_stack;
			/// helper to hold the reference for the next object element
			BasicJsonType* object_element = nullptr;
			/// whether a syntax error occurred
			bool errored = false;
			/// whether to throw exceptions in case of errors
			const bool allow_exceptions = true;
		};

		template<typename BasicJsonType>
		class json_sax_dom_callback_parser
		{
		public:
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;
			using parser_callback_t = typename BasicJsonType::parser_callback_t;
			using parse_event_t = typename BasicJsonType::parse_event_t;

			json_sax_dom_callback_parser(BasicJsonType& r,
				const parser_callback_t cb,
				const bool allow_exceptions_ = true)
				: root(r), callback(cb), allow_exceptions(allow_exceptions_)
			{
				keep_stack.push_back(true);
			}

			bool null()
			{
				handle_value(nullptr);
				return true;
			}

			bool boolean(bool val)
			{
				handle_value(val);
				return true;
			}

			bool number_integer(number_integer_t val)
			{
				handle_value(val);
				return true;
			}

			bool number_unsigned(number_unsigned_t val)
			{
				handle_value(val);
				return true;
			}

			bool number_float(number_float_t val, const string_t&)
			{
				handle_value(val);
				return true;
			}

			bool string(string_t& val)
			{
				handle_value(val);
				return true;
			}

			bool start_object(std::size_t len)
			{
				// check callback for object start
				const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
				keep_stack.push_back(keep);

				auto val = handle_value(BasicJsonType::value_t::object, true);
				ref_stack.push_back(val.second);

				// check object limit
				if (ref_stack.back())
				{
					if (JSON_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
					{
						JSON_THROW(out_of_range::create(408,
							"excessive object size: " + std::to_string(len)));
					}
				}

				return true;
			}

			bool key(string_t& val)
			{
				BasicJsonType k = BasicJsonType(val);

				// check callback for key
				const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);
				key_keep_stack.push_back(keep);

				// add discarded value at given key and store the reference for later
				if (keep and ref_stack.back())
				{
					object_element = &(ref_stack.back()->m_value.object->operator[](val) = discarded);
				}

				return true;
			}

			bool end_object()
			{
				if (ref_stack.back())
				{
					if (not callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
					{
						// discard object
						*ref_stack.back() = discarded;
					}
				}

				assert(not ref_stack.empty());
				assert(not keep_stack.empty());
				ref_stack.pop_back();
				keep_stack.pop_back();

				if (not ref_stack.empty() and ref_stack.back())
				{
					// remove discarded value
					if (ref_stack.back()->is_object())
					{
						for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
						{
							if (it->is_discarded())
							{
								ref_stack.back()->erase(it);
								break;
							}
						}
					}
				}

				return true;
			}

			bool start_array(std::size_t len)
			{
				const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
				keep_stack.push_back(keep);

				auto val = handle_value(BasicJsonType::value_t::array, true);
				ref_stack.push_back(val.second);

				// check array limit
				if (ref_stack.back())
				{
					if (JSON_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
					{
						JSON_THROW(out_of_range::create(408,
							"excessive array size: " + std::to_string(len)));
					}
				}

				return true;
			}

			bool end_array()
			{
				bool keep = true;

				if (ref_stack.back())
				{
					keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
					if (not keep)
					{
						// discard array
						*ref_stack.back() = discarded;
					}
				}

				assert(not ref_stack.empty());
				assert(not keep_stack.empty());
				ref_stack.pop_back();
				keep_stack.pop_back();

				// remove discarded value
				if (not keep and not ref_stack.empty())
				{
					if (ref_stack.back()->is_array())
					{
						ref_stack.back()->m_value.array->pop_back();
					}
				}

				return true;
			}

			bool parse_error(std::size_t, const std::string&,
				const detail::exception& ex)
			{
				errored = true;
				if (allow_exceptions)
				{
					// determine the proper exception type from the id
					switch ((ex.id / 100) % 100)
					{
					case 1:
						JSON_THROW(*reinterpret_cast<const detail::parse_error*>(&ex));
					case 4:
						JSON_THROW(*reinterpret_cast<const detail::out_of_range*>(&ex));
						// LCOV_EXCL_START
					case 2:
						JSON_THROW(*reinterpret_cast<const detail::invalid_iterator*>(&ex));
					case 3:
						JSON_THROW(*reinterpret_cast<const detail::type_error*>(&ex));
					case 5:
						JSON_THROW(*reinterpret_cast<const detail::other_error*>(&ex));
					default:
						assert(false);
						// LCOV_EXCL_STOP
					}
				}
				return false;
			}

			constexpr bool is_errored() const
			{
				return errored;
			}

		private:
			/*!
			@param[in] v  value to add to the JSON value we build during parsing
			@param[in] skip_callback  whether we should skip calling the callback
					   function; this is required after start_array() and
					   start_object() SAX events, because otherwise we would call the
					   callback function with an empty array or object, respectively.

			@invariant If the ref stack is empty, then the passed value will be the new
					   root.
			@invariant If the ref stack contains a value, then it is an array or an
					   object to which we can add elements

			@return pair of boolean (whether value should be kept) and pointer (to the
					passed value in the ref_stack hierarchy; nullptr if not kept)
			*/
			template<typename Value>
			std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)
			{
				assert(not keep_stack.empty());

				// do not handle this value if we know it would be added to a discarded
				// container
				if (not keep_stack.back())
				{
					return { false, nullptr };
				}

				// create value
				auto value = BasicJsonType(std::forward<Value>(v));

				// check callback
				const bool keep = skip_callback or callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);

				// do not handle this value if we just learnt it shall be discarded
				if (not keep)
				{
					return { false, nullptr };
				}

				if (ref_stack.empty())
				{
					root = std::move(value);
					return { true, &root };
				}
				else
				{
					// skip this value if we already decided to skip the parent
					// (https://github.com/nlohmann/json/issues/971#issuecomment-413678360)
					if (not ref_stack.back())
					{
						return { false, nullptr };
					}

					assert(ref_stack.back()->is_array() or ref_stack.back()->is_object());
					if (ref_stack.back()->is_array())
					{
						ref_stack.back()->m_value.array->push_back(std::move(value));
						return { true, &(ref_stack.back()->m_value.array->back()) };
					}
					else
					{
						// check if we should store an element for the current key
						assert(not key_keep_stack.empty());
						const bool store_element = key_keep_stack.back();
						key_keep_stack.pop_back();

						if (not store_element)
						{
							return { false, nullptr };
						}

						assert(object_element);
						*object_element = std::move(value);
						return { true, object_element };
					}
				}
			}

			/// the parsed JSON value
			BasicJsonType& root;
			/// stack to model hierarchy of values
			std::vector<BasicJsonType*> ref_stack;
			/// stack to manage which values to keep
			std::vector<bool> keep_stack;
			/// stack to manage which object keys to keep
			std::vector<bool> key_keep_stack;
			/// helper to hold the reference for the next object element
			BasicJsonType* object_element = nullptr;
			/// whether a syntax error occurred
			bool errored = false;
			/// callback function
			const parser_callback_t callback = nullptr;
			/// whether to throw exceptions in case of errors
			const bool allow_exceptions = true;
			/// a discarded value for the callback
			BasicJsonType discarded = BasicJsonType::value_t::discarded;
		};

		template<typename BasicJsonType>
		class json_sax_acceptor
		{
		public:
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;

			bool null()
			{
				return true;
			}

			bool boolean(bool)
			{
				return true;
			}

			bool number_integer(number_integer_t)
			{
				return true;
			}

			bool number_unsigned(number_unsigned_t)
			{
				return true;
			}

			bool number_float(number_float_t, const string_t&)
			{
				return true;
			}

			bool string(string_t&)
			{
				return true;
			}

			bool start_object(std::size_t = std::size_t(-1))
			{
				return true;
			}

			bool key(string_t&)
			{
				return true;
			}

			bool end_object()
			{
				return true;
			}

			bool start_array(std::size_t = std::size_t(-1))
			{
				return true;
			}

			bool end_array()
			{
				return true;
			}

			bool parse_error(std::size_t, const std::string&, const detail::exception&)
			{
				return false;
			}
		};
	}

}

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		////////////
		// parser //
		////////////

		/*!
		@brief syntax analysis

		This class implements a recursive decent parser.
		*/
		template<typename BasicJsonType>
		class parser
		{
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;
			using lexer_t = lexer<BasicJsonType>;
			using token_type = typename lexer_t::token_type;

		public:
			enum class parse_event_t : uint8_t
			{
				/// the parser read `{` and started to process a JSON object
				object_start,
				/// the parser read `}` and finished processing a JSON object
				object_end,
				/// the parser read `[` and started to process a JSON array
				array_start,
				/// the parser read `]` and finished processing a JSON array
				array_end,
				/// the parser read a key of a value in an object
				key,
				/// the parser finished reading a JSON value
				value
			};

			using parser_callback_t =
				std::function<bool(int depth, parse_event_t event, BasicJsonType& parsed)>;

			/// a parser reading from an input adapter
			explicit parser(detail::input_adapter_t&& adapter,
				const parser_callback_t cb = nullptr,
				const bool allow_exceptions_ = true)
				: callback(cb), m_lexer(std::move(adapter)), allow_exceptions(allow_exceptions_)
			{
				// read first token
				get_token();
			}

			/*!
			@brief public parser interface

			@param[in] strict      whether to expect the last token to be EOF
			@param[in,out] result  parsed JSON value

			@throw parse_error.101 in case of an unexpected token
			@throw parse_error.102 if to_unicode fails or surrogate error
			@throw parse_error.103 if to_unicode fails
			*/
			void parse(const bool strict, BasicJsonType& result)
			{
				if (callback)
				{
					json_sax_dom_callback_parser<BasicJsonType> sdp(result, callback, allow_exceptions);
					sax_parse_internal(&sdp);
					result.assert_invariant();

					// in strict mode, input must be completely read
					if (strict and (get_token() != token_type::end_of_input))
					{
						sdp.parse_error(m_lexer.get_position(),
							m_lexer.get_token_string(),
							parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input)));
					}

					// in case of an error, return discarded value
					if (sdp.is_errored())
					{
						result = value_t::discarded;
						return;
					}

					// set top-level value to null if it was discarded by the callback
					// function
					if (result.is_discarded())
					{
						result = nullptr;
					}
				}
				else
				{
					json_sax_dom_parser<BasicJsonType> sdp(result, allow_exceptions);
					sax_parse_internal(&sdp);
					result.assert_invariant();

					// in strict mode, input must be completely read
					if (strict and (get_token() != token_type::end_of_input))
					{
						sdp.parse_error(m_lexer.get_position(),
							m_lexer.get_token_string(),
							parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input)));
					}

					// in case of an error, return discarded value
					if (sdp.is_errored())
					{
						result = value_t::discarded;
						return;
					}
				}
			}

			/*!
			@brief public accept interface

			@param[in] strict  whether to expect the last token to be EOF
			@return whether the input is a proper JSON text
			*/
			bool accept(const bool strict = true)
			{
				json_sax_acceptor<BasicJsonType> sax_acceptor;
				return sax_parse(&sax_acceptor, strict);
			}

			template <typename SAX>
			bool sax_parse(SAX* sax, const bool strict = true)
			{
				(void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
				const bool result = sax_parse_internal(sax);

				// strict mode: next byte must be EOF
				if (result and strict and (get_token() != token_type::end_of_input))
				{
					return sax->parse_error(m_lexer.get_position(),
						m_lexer.get_token_string(),
						parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input)));
				}

				return result;
			}

		private:
			template <typename SAX>
			bool sax_parse_internal(SAX* sax)
			{
				// stack to remember the hieararchy of structured values we are parsing
				// true = array; false = object
				std::vector<bool> states;
				// value to avoid a goto (see comment where set to true)
				bool skip_to_state_evaluation = false;

				while (true)
				{
					if (not skip_to_state_evaluation)
					{
						// invariant: get_token() was called before each iteration
						switch (last_token)
						{
						case token_type::begin_object:
						{
							if (JSON_UNLIKELY(not sax->start_object(std::size_t(-1))))
							{
								return false;
							}

							// closing } -> we are done
							if (get_token() == token_type::end_object)
							{
								if (JSON_UNLIKELY(not sax->end_object()))
								{
									return false;
								}
								break;
							}

							// parse key
							if (JSON_UNLIKELY(last_token != token_type::value_string))
							{
								return sax->parse_error(m_lexer.get_position(),
									m_lexer.get_token_string(),
									parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string)));
							}
							else
							{
								if (JSON_UNLIKELY(not sax->key(m_lexer.get_string())))
								{
									return false;
								}
							}

							// parse separator (:)
							if (JSON_UNLIKELY(get_token() != token_type::name_separator))
							{
								return sax->parse_error(m_lexer.get_position(),
									m_lexer.get_token_string(),
									parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator)));
							}

							// remember we are now inside an object
							states.push_back(false);

							// parse values
							get_token();
							continue;
						}

						case token_type::begin_array:
						{
							if (JSON_UNLIKELY(not sax->start_array(std::size_t(-1))))
							{
								return false;
							}

							// closing ] -> we are done
							if (get_token() == token_type::end_array)
							{
								if (JSON_UNLIKELY(not sax->end_array()))
								{
									return false;
								}
								break;
							}

							// remember we are now inside an array
							states.push_back(true);

							// parse values (no need to call get_token)
							continue;
						}

						case token_type::value_float:
						{
							const auto res = m_lexer.get_number_float();

							if (JSON_UNLIKELY(not std::isfinite(res)))
							{
								return sax->parse_error(m_lexer.get_position(),
									m_lexer.get_token_string(),
									out_of_range::create(406, "number overflow parsing '" + m_lexer.get_token_string() + "'"));
							}
							else
							{
								if (JSON_UNLIKELY(not sax->number_float(res, m_lexer.get_string())))
								{
									return false;
								}
								break;
							}
						}

						case token_type::literal_false:
						{
							if (JSON_UNLIKELY(not sax->boolean(false)))
							{
								return false;
							}
							break;
						}

						case token_type::literal_null:
						{
							if (JSON_UNLIKELY(not sax->null()))
							{
								return false;
							}
							break;
						}

						case token_type::literal_true:
						{
							if (JSON_UNLIKELY(not sax->boolean(true)))
							{
								return false;
							}
							break;
						}

						case token_type::value_integer:
						{
							if (JSON_UNLIKELY(not sax->number_integer(m_lexer.get_number_integer())))
							{
								return false;
							}
							break;
						}

						case token_type::value_string:
						{
							if (JSON_UNLIKELY(not sax->string(m_lexer.get_string())))
							{
								return false;
							}
							break;
						}

						case token_type::value_unsigned:
						{
							if (JSON_UNLIKELY(not sax->number_unsigned(m_lexer.get_number_unsigned())))
							{
								return false;
							}
							break;
						}

						case token_type::parse_error:
						{
							// using "uninitialized" to avoid "expected" message
							return sax->parse_error(m_lexer.get_position(),
								m_lexer.get_token_string(),
								parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized)));
						}

						default: // the last token was unexpected
						{
							return sax->parse_error(m_lexer.get_position(),
								m_lexer.get_token_string(),
								parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value)));
						}
						}
					}
					else
					{
						skip_to_state_evaluation = false;
					}

					// we reached this line after we successfully parsed a value
					if (states.empty())
					{
						// empty stack: we reached the end of the hieararchy: done
						return true;
					}
					else
					{
						if (states.back())  // array
						{
							// comma -> next value
							if (get_token() == token_type::value_separator)
							{
								// parse a new value
								get_token();
								continue;
							}

							// closing ]
							if (JSON_LIKELY(last_token == token_type::end_array))
							{
								if (JSON_UNLIKELY(not sax->end_array()))
								{
									return false;
								}

								// We are done with this array. Before we can parse a
								// new value, we need to evaluate the new state first.
								// By setting skip_to_state_evaluation to false, we
								// are effectively jumping to the beginning of this if.
								assert(not states.empty());
								states.pop_back();
								skip_to_state_evaluation = true;
								continue;
							}
							else
							{
								return sax->parse_error(m_lexer.get_position(),
									m_lexer.get_token_string(),
									parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array)));
							}
						}
						else  // object
						{
							// comma -> next value
							if (get_token() == token_type::value_separator)
							{
								// parse key
								if (JSON_UNLIKELY(get_token() != token_type::value_string))
								{
									return sax->parse_error(m_lexer.get_position(),
										m_lexer.get_token_string(),
										parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string)));
								}
								else
								{
									if (JSON_UNLIKELY(not sax->key(m_lexer.get_string())))
									{
										return false;
									}
								}

								// parse separator (:)
								if (JSON_UNLIKELY(get_token() != token_type::name_separator))
								{
									return sax->parse_error(m_lexer.get_position(),
										m_lexer.get_token_string(),
										parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator)));
								}

								// parse values
								get_token();
								continue;
							}

							// closing }
							if (JSON_LIKELY(last_token == token_type::end_object))
							{
								if (JSON_UNLIKELY(not sax->end_object()))
								{
									return false;
								}

								// We are done with this object. Before we can parse a
								// new value, we need to evaluate the new state first.
								// By setting skip_to_state_evaluation to false, we
								// are effectively jumping to the beginning of this if.
								assert(not states.empty());
								states.pop_back();
								skip_to_state_evaluation = true;
								continue;
							}
							else
							{
								return sax->parse_error(m_lexer.get_position(),
									m_lexer.get_token_string(),
									parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object)));
							}
						}
					}
				}
			}

			/// get next token from lexer
			token_type get_token()
			{
				return (last_token = m_lexer.scan());
			}

			std::string exception_message(const token_type expected)
			{
				std::string error_msg = "syntax error - ";
				if (last_token == token_type::parse_error)
				{
					error_msg += std::string(m_lexer.get_error_message()) + "; last read: '" +
						m_lexer.get_token_string() + "'";
				}
				else
				{
					error_msg += "unexpected " + std::string(lexer_t::token_type_name(last_token));
				}

				if (expected != token_type::uninitialized)
				{
					error_msg += "; expected " + std::string(lexer_t::token_type_name(expected));
				}

				return error_msg;
			}

		private:
			/// callback function
			const parser_callback_t callback = nullptr;
			/// the type of the last read token
			token_type last_token = token_type::uninitialized;
			/// the lexer
			lexer_t m_lexer;
			/// whether to throw exceptions in case of errors
			const bool allow_exceptions = true;
		};
	}
}

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>


#include <cstddef> // ptrdiff_t
#include <limits>  // numeric_limits

namespace nlohmann
{
	namespace detail
	{
		/*
		@brief an iterator for primitive JSON types

		This class models an iterator for primitive JSON types (boolean, number,
		string). It's only purpose is to allow the iterator/const_iterator classes
		to "iterate" over primitive values. Internally, the iterator is modeled by
		a `difference_type` variable. Value begin_value (`0`) models the begin,
		end_value (`1`) models past the end.
		*/
		class primitive_iterator_t
		{
		private:
			using difference_type = std::ptrdiff_t;
			static constexpr difference_type begin_value = 0;
			static constexpr difference_type end_value = begin_value + 1;

			/// iterator as signed integer type
			difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();

		public:
			constexpr difference_type get_value() const noexcept
			{
				return m_it;
			}

			/// set iterator to a defined beginning
			void set_begin() noexcept
			{
				m_it = begin_value;
			}

			/// set iterator to a defined past the end
			void set_end() noexcept
			{
				m_it = end_value;
			}

			/// return whether the iterator can be dereferenced
			constexpr bool is_begin() const noexcept
			{
				return m_it == begin_value;
			}

			/// return whether the iterator is at end
			constexpr bool is_end() const noexcept
			{
				return m_it == end_value;
			}

			friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
			{
				return lhs.m_it == rhs.m_it;
			}

			friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
			{
				return lhs.m_it < rhs.m_it;
			}

			primitive_iterator_t operator+(difference_type n) noexcept
			{
				auto result = *this;
				result += n;
				return result;
			}

			friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
			{
				return lhs.m_it - rhs.m_it;
			}

			primitive_iterator_t& operator++() noexcept
			{
				++m_it;
				return *this;
			}

			primitive_iterator_t const operator++(int) noexcept
			{
				auto result = *this;
				++m_it;
				return result;
			}

			primitive_iterator_t& operator--() noexcept
			{
				--m_it;
				return *this;
			}

			primitive_iterator_t const operator--(int) noexcept
			{
				auto result = *this;
				--m_it;
				return result;
			}

			primitive_iterator_t& operator+=(difference_type n) noexcept
			{
				m_it += n;
				return *this;
			}

			primitive_iterator_t& operator-=(difference_type n) noexcept
			{
				m_it -= n;
				return *this;
			}
		};
	}
}

// #include <nlohmann/detail/iterators/internal_iterator.hpp>


// #include <nlohmann/detail/iterators/primitive_iterator.hpp>


namespace nlohmann
{
	namespace detail
	{
		/*!
		@brief an iterator value

		@note This structure could easily be a union, but MSVC currently does not allow
		unions members with complex constructors, see https://github.com/nlohmann/json/pull/105.
		*/
		template<typename BasicJsonType> struct internal_iterator
		{
			/// iterator for JSON objects
			typename BasicJsonType::object_t::iterator object_iterator{};
			/// iterator for JSON arrays
			typename BasicJsonType::array_t::iterator array_iterator{};
			/// generic iterator for all other types
			primitive_iterator_t primitive_iterator{};
		};
	}
}

// #include <nlohmann/detail/iterators/iter_impl.hpp>


#include <ciso646> // not
#include <iterator> // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next
#include <type_traits> // conditional, is_const, remove_const

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/iterators/internal_iterator.hpp>

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		// forward declare, to be able to friend it later on
		template<typename IteratorType> class iteration_proxy;

		/*!
		@brief a template for a bidirectional iterator for the @ref basic_json class

		This class implements a both iterators (iterator and const_iterator) for the
		@ref basic_json class.

		@note An iterator is called *initialized* when a pointer to a JSON value has
			  been set (e.g., by a constructor or a copy assignment). If the iterator is
			  default-constructed, it is *uninitialized* and most methods are undefined.
			  **The library uses assertions to detect calls on uninitialized iterators.**

		@requirement The class satisfies the following concept requirements:
		-
		[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
		  The iterator that can be moved can be moved in both directions (i.e.
		  incremented and decremented).

		@since version 1.0.0, simplified in version 2.0.9, change to bidirectional
			   iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)
		*/
		template<typename BasicJsonType>
		class iter_impl
		{
			/// allow basic_json to access private members
			friend iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
			friend BasicJsonType;
			friend iteration_proxy<iter_impl>;

			using object_t = typename BasicJsonType::object_t;
			using array_t = typename BasicJsonType::array_t;
			// make sure BasicJsonType is basic_json or const basic_json
			static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
				"iter_impl only accepts (const) basic_json");

		public:

			/// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.
			/// The C++ Standard has never required user-defined iterators to derive from std::iterator.
			/// A user-defined iterator should provide publicly accessible typedefs named
			/// iterator_category, value_type, difference_type, pointer, and reference.
			/// Note that value_type is required to be non-const, even for constant iterators.
			using iterator_category = std::bidirectional_iterator_tag;

			/// the type of the values when the iterator is dereferenced
			using value_type = typename BasicJsonType::value_type;
			/// a type to represent differences between iterators
			using difference_type = typename BasicJsonType::difference_type;
			/// defines a pointer to the type iterated over (value_type)
			using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
				typename BasicJsonType::const_pointer,
				typename BasicJsonType::pointer>::type;
			/// defines a reference to the type iterated over (value_type)
			using reference =
				typename std::conditional<std::is_const<BasicJsonType>::value,
				typename BasicJsonType::const_reference,
				typename BasicJsonType::reference>::type;

			/// default constructor
			iter_impl() = default;

			/*!
			@brief constructor for a given JSON instance
			@param[in] object  pointer to a JSON object for this iterator
			@pre object != nullptr
			@post The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			explicit iter_impl(pointer object) noexcept : m_object(object)
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					m_it.object_iterator = typename object_t::iterator();
					break;
				}

				case value_t::array:
				{
					m_it.array_iterator = typename array_t::iterator();
					break;
				}

				default:
				{
					m_it.primitive_iterator = primitive_iterator_t();
					break;
				}
				}
			}

			/*!
			@note The conventional copy constructor and copy assignment are implicitly
				  defined. Combined with the following converting constructor and
				  assignment, they support: (1) copy from iterator to iterator, (2)
				  copy from const iterator to const iterator, and (3) conversion from
				  iterator to const iterator. However conversion from const iterator
				  to iterator is not defined.
			*/

			/*!
			@brief converting constructor
			@param[in] other  non-const iterator to copy from
			@note It is not checked whether @a other is initialized.
			*/
			iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
				: m_object(other.m_object), m_it(other.m_it) {}

			/*!
			@brief converting assignment
			@param[in,out] other  non-const iterator to copy from
			@return const/non-const iterator
			@note It is not checked whether @a other is initialized.
			*/
			iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
			{
				m_object = other.m_object;
				m_it = other.m_it;
				return *this;
			}

		private:
			/*!
			@brief set the iterator to the first value
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			void set_begin() noexcept
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					m_it.object_iterator = m_object->m_value.object->begin();
					break;
				}

				case value_t::array:
				{
					m_it.array_iterator = m_object->m_value.array->begin();
					break;
				}

				case value_t::null:
				{
					// set to end so begin()==end() is true: null is empty
					m_it.primitive_iterator.set_end();
					break;
				}

				default:
				{
					m_it.primitive_iterator.set_begin();
					break;
				}
				}
			}

			/*!
			@brief set the iterator past the last value
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			void set_end() noexcept
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					m_it.object_iterator = m_object->m_value.object->end();
					break;
				}

				case value_t::array:
				{
					m_it.array_iterator = m_object->m_value.array->end();
					break;
				}

				default:
				{
					m_it.primitive_iterator.set_end();
					break;
				}
				}
			}

		public:
			/*!
			@brief return a reference to the value pointed to by the iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			reference operator*() const
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					assert(m_it.object_iterator != m_object->m_value.object->end());
					return m_it.object_iterator->second;
				}

				case value_t::array:
				{
					assert(m_it.array_iterator != m_object->m_value.array->end());
					return *m_it.array_iterator;
				}

				case value_t::null:
					JSON_THROW(invalid_iterator::create(214, "cannot get value"));

				default:
				{
					if (JSON_LIKELY(m_it.primitive_iterator.is_begin()))
					{
						return *m_object;
					}

					JSON_THROW(invalid_iterator::create(214, "cannot get value"));
				}
				}
			}

			/*!
			@brief dereference the iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			pointer operator->() const
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					assert(m_it.object_iterator != m_object->m_value.object->end());
					return &(m_it.object_iterator->second);
				}

				case value_t::array:
				{
					assert(m_it.array_iterator != m_object->m_value.array->end());
					return &*m_it.array_iterator;
				}

				default:
				{
					if (JSON_LIKELY(m_it.primitive_iterator.is_begin()))
					{
						return m_object;
					}

					JSON_THROW(invalid_iterator::create(214, "cannot get value"));
				}
				}
			}

			/*!
			@brief post-increment (it++)
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl const operator++(int)
			{
				auto result = *this;
				++(*this);
				return result;
			}

			/*!
			@brief pre-increment (++it)
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl& operator++()
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					std::advance(m_it.object_iterator, 1);
					break;
				}

				case value_t::array:
				{
					std::advance(m_it.array_iterator, 1);
					break;
				}

				default:
				{
					++m_it.primitive_iterator;
					break;
				}
				}

				return *this;
			}

			/*!
			@brief post-decrement (it--)
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl const operator--(int)
			{
				auto result = *this;
				--(*this);
				return result;
			}

			/*!
			@brief pre-decrement (--it)
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl& operator--()
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					std::advance(m_it.object_iterator, -1);
					break;
				}

				case value_t::array:
				{
					std::advance(m_it.array_iterator, -1);
					break;
				}

				default:
				{
					--m_it.primitive_iterator;
					break;
				}
				}

				return *this;
			}

			/*!
			@brief  comparison: equal
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			bool operator==(const iter_impl& other) const
			{
				// if objects are not the same, the comparison is undefined
				if (JSON_UNLIKELY(m_object != other.m_object))
				{
					JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
				}

				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
					return (m_it.object_iterator == other.m_it.object_iterator);

				case value_t::array:
					return (m_it.array_iterator == other.m_it.array_iterator);

				default:
					return (m_it.primitive_iterator == other.m_it.primitive_iterator);
				}
			}

			/*!
			@brief  comparison: not equal
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			bool operator!=(const iter_impl& other) const
			{
				return not operator==(other);
			}

			/*!
			@brief  comparison: smaller
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			bool operator<(const iter_impl& other) const
			{
				// if objects are not the same, the comparison is undefined
				if (JSON_UNLIKELY(m_object != other.m_object))
				{
					JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
				}

				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
					JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators"));

				case value_t::array:
					return (m_it.array_iterator < other.m_it.array_iterator);

				default:
					return (m_it.primitive_iterator < other.m_it.primitive_iterator);
				}
			}

			/*!
			@brief  comparison: less than or equal
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			bool operator<=(const iter_impl& other) const
			{
				return not other.operator < (*this);
			}

			/*!
			@brief  comparison: greater than
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			bool operator>(const iter_impl& other) const
			{
				return not operator<=(other);
			}

			/*!
			@brief  comparison: greater than or equal
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			bool operator>=(const iter_impl& other) const
			{
				return not operator<(other);
			}

			/*!
			@brief  add to iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl& operator+=(difference_type i)
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
					JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

				case value_t::array:
				{
					std::advance(m_it.array_iterator, i);
					break;
				}

				default:
				{
					m_it.primitive_iterator += i;
					break;
				}
				}

				return *this;
			}

			/*!
			@brief  subtract from iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl& operator-=(difference_type i)
			{
				return operator+=(-i);
			}

			/*!
			@brief  add to iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl operator+(difference_type i) const
			{
				auto result = *this;
				result += i;
				return result;
			}

			/*!
			@brief  addition of distance and iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			friend iter_impl operator+(difference_type i, const iter_impl& it)
			{
				auto result = it;
				result += i;
				return result;
			}

			/*!
			@brief  subtract from iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl operator-(difference_type i) const
			{
				auto result = *this;
				result -= i;
				return result;
			}

			/*!
			@brief  return difference
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			difference_type operator-(const iter_impl& other) const
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
					JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

				case value_t::array:
					return m_it.array_iterator - other.m_it.array_iterator;

				default:
					return m_it.primitive_iterator - other.m_it.primitive_iterator;
				}
			}

			/*!
			@brief  access to successor
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			reference operator[](difference_type n) const
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
					JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators"));

				case value_t::array:
					return *std::next(m_it.array_iterator, n);

				case value_t::null:
					JSON_THROW(invalid_iterator::create(214, "cannot get value"));

				default:
				{
					if (JSON_LIKELY(m_it.primitive_iterator.get_value() == -n))
					{
						return *m_object;
					}

					JSON_THROW(invalid_iterator::create(214, "cannot get value"));
				}
				}
			}

			/*!
			@brief  return the key of an object iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			const typename object_t::key_type& key() const
			{
				assert(m_object != nullptr);

				if (JSON_LIKELY(m_object->is_object()))
				{
					return m_it.object_iterator->first;
				}

				JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators"));
			}

			/*!
			@brief  return the value of an iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			reference value() const
			{
				return operator*();
			}

		private:
			/// associated JSON instance
			pointer m_object = nullptr;
			/// the actual iterator of the associated instance
			internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it;
		};
	}
}

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>

// #include <nlohmann/detail/iterators/json_reverse_iterator.hpp>


#include <cstddef> // ptrdiff_t
#include <iterator> // reverse_iterator
#include <utility> // declval

namespace nlohmann
{
	namespace detail
	{
		//////////////////////
		// reverse_iterator //
		//////////////////////

		/*!
		@brief a template for a reverse iterator class

		@tparam Base the base iterator type to reverse. Valid types are @ref
		iterator (to create @ref reverse_iterator) and @ref const_iterator (to
		create @ref const_reverse_iterator).

		@requirement The class satisfies the following concept requirements:
		-
		[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
		  The iterator that can be moved can be moved in both directions (i.e.
		  incremented and decremented).
		- [OutputIterator](https://en.cppreference.com/w/cpp/named_req/OutputIterator):
		  It is possible to write to the pointed-to element (only if @a Base is
		  @ref iterator).

		@since version 1.0.0
		*/
		template<typename Base>
		class json_reverse_iterator : public std::reverse_iterator<Base>
		{
		public:
			using difference_type = std::ptrdiff_t;
			/// shortcut to the reverse iterator adapter
			using base_iterator = std::reverse_iterator<Base>;
			/// the reference type for the pointed-to element
			using reference = typename Base::reference;

			/// create reverse iterator from iterator
			explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
				: base_iterator(it) {}

			/// create reverse iterator from base class
			explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}

			/// post-increment (it++)
			json_reverse_iterator const operator++(int)
			{
				return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
			}

			/// pre-increment (++it)
			json_reverse_iterator& operator++()
			{
				return static_cast<json_reverse_iterator&>(base_iterator::operator++());
			}

			/// post-decrement (it--)
			json_reverse_iterator const operator--(int)
			{
				return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
			}

			/// pre-decrement (--it)
			json_reverse_iterator& operator--()
			{
				return static_cast<json_reverse_iterator&>(base_iterator::operator--());
			}

			/// add to iterator
			json_reverse_iterator& operator+=(difference_type i)
			{
				return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
			}

			/// add to iterator
			json_reverse_iterator operator+(difference_type i) const
			{
				return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
			}

			/// subtract from iterator
			json_reverse_iterator operator-(difference_type i) const
			{
				return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
			}

			/// return difference
			difference_type operator-(const json_reverse_iterator& other) const
			{
				return base_iterator(*this) - base_iterator(other);
			}

			/// access to successor
			reference operator[](difference_type n) const
			{
				return *(this->operator+(n));
			}

			/// return the key of an object iterator
			auto key() const -> decltype(std::declval<Base>().key())
			{
				auto it = --this->base();
				return it.key();
			}

			/// return the value of an iterator
			reference value() const
			{
				auto it = --this->base();
				return it.operator * ();
			}
		};
	}
}

// #include <nlohmann/detail/output/output_adapters.hpp>


#include <algorithm> // copy
#include <cstddef> // size_t
#include <ios> // streamsize
#include <iterator> // back_inserter
#include <memory> // shared_ptr, make_shared
#include <ostream> // basic_ostream
#include <string> // basic_string
#include <vector> // vector

namespace nlohmann
{
	namespace detail
	{
		/// abstract output adapter interface
		template<typename CharType> struct output_adapter_protocol
		{
			virtual void write_character(CharType c) = 0;
			virtual void write_characters(const CharType* s, std::size_t length) = 0;
			virtual ~output_adapter_protocol() = default;
		};

		/// a type to simplify interfaces
		template<typename CharType>
		using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;

		/// output adapter for byte vectors
		template<typename CharType>
		class output_vector_adapter : public output_adapter_protocol<CharType>
		{
		public:
			explicit output_vector_adapter(std::vector<CharType>& vec) : v(vec) {}

			void write_character(CharType c) override
			{
				v.push_back(c);
			}

			void write_characters(const CharType* s, std::size_t length) override
			{
				std::copy(s, s + length, std::back_inserter(v));
			}

		private:
			std::vector<CharType>& v;
		};

		/// output adapter for output streams
		template<typename CharType>
		class output_stream_adapter : public output_adapter_protocol<CharType>
		{
		public:
			explicit output_stream_adapter(std::basic_ostream<CharType>& s) : stream(s) {}

			void write_character(CharType c) override
			{
				stream.put(c);
			}

			void write_characters(const CharType* s, std::size_t length) override
			{
				stream.write(s, static_cast<std::streamsize>(length));
			}

		private:
			std::basic_ostream<CharType>& stream;
		};

		/// output adapter for basic_string
		template<typename CharType, typename StringType = std::basic_string<CharType>>
		class output_string_adapter : public output_adapter_protocol<CharType>
		{
		public:
			explicit output_string_adapter(StringType& s) : str(s) {}

			void write_character(CharType c) override
			{
				str.push_back(c);
			}

			void write_characters(const CharType* s, std::size_t length) override
			{
				str.append(s, length);
			}

		private:
			StringType& str;
		};

		template<typename CharType, typename StringType = std::basic_string<CharType>>
		class output_adapter
		{
		public:
			output_adapter(std::vector<CharType>& vec)
				: oa(std::make_shared<output_vector_adapter<CharType>>(vec)) {}

			output_adapter(std::basic_ostream<CharType>& s)
				: oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}

			output_adapter(StringType& s)
				: oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}

			operator output_adapter_t<CharType>()
			{
				return oa;
			}

		private:
			output_adapter_t<CharType> oa = nullptr;
		};
	}
}

// #include <nlohmann/detail/input/binary_reader.hpp>


#include <algorithm> // generate_n
#include <array> // array
#include <cassert> // assert
#include <cmath> // ldexp
#include <cstddef> // size_t
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstdio> // snprintf
#include <cstring> // memcpy
#include <iterator> // back_inserter
#include <limits> // numeric_limits
#include <string> // char_traits, string
#include <utility> // make_pair, move

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/json_sax.hpp>

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		///////////////////
		// binary reader //
		///////////////////

		/*!
		@brief deserialization of CBOR, MessagePack, and UBJSON values
		*/
		template<typename BasicJsonType, typename SAX = json_sax_dom_parser<BasicJsonType>>
		class binary_reader
		{
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;
			using json_sax_t = SAX;

		public:
			/*!
			@brief create a binary reader

			@param[in] adapter  input adapter to read from
			*/
			explicit binary_reader(input_adapter_t adapter) : ia(std::move(adapter))
			{
				(void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
				assert(ia);
			}

			/*!
			@param[in] format  the binary format to parse
			@param[in] sax_    a SAX event processor
			@param[in] strict  whether to expect the input to be consumed completed

			@return
			*/
			bool sax_parse(const input_format_t format,
				json_sax_t* sax_,
				const bool strict = true)
			{
				sax = sax_;
				bool result = false;

				switch (format)
				{
				case input_format_t::cbor:
					result = parse_cbor_internal();
					break;

				case input_format_t::msgpack:
					result = parse_msgpack_internal();
					break;

				case input_format_t::ubjson:
					result = parse_ubjson_internal();
					break;

					// LCOV_EXCL_START
				default:
					assert(false);
					// LCOV_EXCL_STOP
				}

				// strict mode: next byte must be EOF
				if (result and strict)
				{
					if (format == input_format_t::ubjson)
					{
						get_ignore_noop();
					}
					else
					{
						get();
					}

					if (JSON_UNLIKELY(current != std::char_traits<char>::eof()))
					{
						return sax->parse_error(chars_read, get_token_string(), parse_error::create(110, chars_read, "expected end of input"));
					}
				}

				return result;
			}

			/*!
			@brief determine system byte order

			@return true if and only if system's byte order is little endian

			@note from http://stackoverflow.com/a/1001328/266378
			*/
			static constexpr bool little_endianess(int num = 1) noexcept
			{
				return (*reinterpret_cast<char*>(&num) == 1);
			}

		private:
			/*!
			@param[in] get_char  whether a new character should be retrieved from the
								 input (true, default) or whether the last read
								 character should be considered instead

			@return whether a valid CBOR value was passed to the SAX parser
			*/
			bool parse_cbor_internal(const bool get_char = true)
			{
				switch (get_char ? get() : current)
				{
					// EOF
				case std::char_traits<char>::eof():
					return unexpect_eof();

					// Integer 0x00..0x17 (0..23)
				case 0x00:
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x04:
				case 0x05:
				case 0x06:
				case 0x07:
				case 0x08:
				case 0x09:
				case 0x0A:
				case 0x0B:
				case 0x0C:
				case 0x0D:
				case 0x0E:
				case 0x0F:
				case 0x10:
				case 0x11:
				case 0x12:
				case 0x13:
				case 0x14:
				case 0x15:
				case 0x16:
				case 0x17:
					return sax->number_unsigned(static_cast<number_unsigned_t>(current));

				case 0x18: // Unsigned integer (one-byte uint8_t follows)
				{
					uint8_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0x19: // Unsigned integer (two-byte uint16_t follows)
				{
					uint16_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0x1A: // Unsigned integer (four-byte uint32_t follows)
				{
					uint32_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0x1B: // Unsigned integer (eight-byte uint64_t follows)
				{
					uint64_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				// Negative integer -1-0x00..-1-0x17 (-1..-24)
				case 0x20:
				case 0x21:
				case 0x22:
				case 0x23:
				case 0x24:
				case 0x25:
				case 0x26:
				case 0x27:
				case 0x28:
				case 0x29:
				case 0x2A:
				case 0x2B:
				case 0x2C:
				case 0x2D:
				case 0x2E:
				case 0x2F:
				case 0x30:
				case 0x31:
				case 0x32:
				case 0x33:
				case 0x34:
				case 0x35:
				case 0x36:
				case 0x37:
					return sax->number_integer(static_cast<int8_t>(0x20 - 1 - current));

				case 0x38: // Negative integer (one-byte uint8_t follows)
				{
					uint8_t number;
					return get_number(number) and sax->number_integer(static_cast<number_integer_t>(-1) - number);
				}

				case 0x39: // Negative integer -1-n (two-byte uint16_t follows)
				{
					uint16_t number;
					return get_number(number) and sax->number_integer(static_cast<number_integer_t>(-1) - number);
				}

				case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)
				{
					uint32_t number;
					return get_number(number) and sax->number_integer(static_cast<number_integer_t>(-1) - number);
				}

				case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)
				{
					uint64_t number;
					return get_number(number) and sax->number_integer(static_cast<number_integer_t>(-1)
						- static_cast<number_integer_t>(number));
				}

				// UTF-8 string (0x00..0x17 bytes follow)
				case 0x60:
				case 0x61:
				case 0x62:
				case 0x63:
				case 0x64:
				case 0x65:
				case 0x66:
				case 0x67:
				case 0x68:
				case 0x69:
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:
				case 0x6E:
				case 0x6F:
				case 0x70:
				case 0x71:
				case 0x72:
				case 0x73:
				case 0x74:
				case 0x75:
				case 0x76:
				case 0x77:
				case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
				case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
				case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
				case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
				case 0x7F: // UTF-8 string (indefinite length)
				{
					string_t s;
					return get_cbor_string(s) and sax->string(s);
				}

				// array (0x00..0x17 data items follow)
				case 0x80:
				case 0x81:
				case 0x82:
				case 0x83:
				case 0x84:
				case 0x85:
				case 0x86:
				case 0x87:
				case 0x88:
				case 0x89:
				case 0x8A:
				case 0x8B:
				case 0x8C:
				case 0x8D:
				case 0x8E:
				case 0x8F:
				case 0x90:
				case 0x91:
				case 0x92:
				case 0x93:
				case 0x94:
				case 0x95:
				case 0x96:
				case 0x97:
					return get_cbor_array(static_cast<std::size_t>(current & 0x1F));

				case 0x98: // array (one-byte uint8_t for n follows)
				{
					uint8_t len;
					return get_number(len) and get_cbor_array(static_cast<std::size_t>(len));
				}

				case 0x99: // array (two-byte uint16_t for n follow)
				{
					uint16_t len;
					return get_number(len) and get_cbor_array(static_cast<std::size_t>(len));
				}

				case 0x9A: // array (four-byte uint32_t for n follow)
				{
					uint32_t len;
					return get_number(len) and get_cbor_array(static_cast<std::size_t>(len));
				}

				case 0x9B: // array (eight-byte uint64_t for n follow)
				{
					uint64_t len;
					return get_number(len) and get_cbor_array(static_cast<std::size_t>(len));
				}

				case 0x9F: // array (indefinite length)
					return get_cbor_array(std::size_t(-1));

					// map (0x00..0x17 pairs of data items follow)
				case 0xA0:
				case 0xA1:
				case 0xA2:
				case 0xA3:
				case 0xA4:
				case 0xA5:
				case 0xA6:
				case 0xA7:
				case 0xA8:
				case 0xA9:
				case 0xAA:
				case 0xAB:
				case 0xAC:
				case 0xAD:
				case 0xAE:
				case 0xAF:
				case 0xB0:
				case 0xB1:
				case 0xB2:
				case 0xB3:
				case 0xB4:
				case 0xB5:
				case 0xB6:
				case 0xB7:
					return get_cbor_object(static_cast<std::size_t>(current & 0x1F));

				case 0xB8: // map (one-byte uint8_t for n follows)
				{
					uint8_t len;
					return get_number(len) and get_cbor_object(static_cast<std::size_t>(len));
				}

				case 0xB9: // map (two-byte uint16_t for n follow)
				{
					uint16_t len;
					return get_number(len) and get_cbor_object(static_cast<std::size_t>(len));
				}

				case 0xBA: // map (four-byte uint32_t for n follow)
				{
					uint32_t len;
					return get_number(len) and get_cbor_object(static_cast<std::size_t>(len));
				}

				case 0xBB: // map (eight-byte uint64_t for n follow)
				{
					uint64_t len;
					return get_number(len) and get_cbor_object(static_cast<std::size_t>(len));
				}

				case 0xBF: // map (indefinite length)
					return get_cbor_object(std::size_t(-1));

				case 0xF4: // false
					return sax->boolean(false);

				case 0xF5: // true
					return sax->boolean(true);

				case 0xF6: // null
					return sax->null();

				case 0xF9: // Half-Precision Float (two-byte IEEE 754)
				{
					const int byte1 = get();
					if (JSON_UNLIKELY(not unexpect_eof()))
					{
						return false;
					}
					const int byte2 = get();
					if (JSON_UNLIKELY(not unexpect_eof()))
					{
						return false;
					}

					// code from RFC 7049, Appendix D, Figure 3:
					// As half-precision floating-point numbers were only added
					// to IEEE 754 in 2008, today's programming platforms often
					// still only have limited support for them. It is very
					// easy to include at least decoding support for them even
					// without such support. An example of a small decoder for
					// half-precision floating-point numbers in the C language
					// is shown in Fig. 3.
					const int half = (byte1 << 8) + byte2;
					const double val = [&half]
					{
						const int exp = (half >> 10) & 0x1F;
						const int mant = half & 0x3FF;
						assert(0 <= exp and exp <= 32);
						assert(0 <= mant and mant <= 1024);
						switch (exp)
						{
						case 0:
							return std::ldexp(mant, -24);
						case 31:
							return (mant == 0)
								? std::numeric_limits<double>::infinity()
								: std::numeric_limits<double>::quiet_NaN();
						default:
							return std::ldexp(mant + 1024, exp - 25);
						}
					}();
					return sax->number_float((half & 0x8000) != 0
						? static_cast<number_float_t>(-val)
						: static_cast<number_float_t>(val), "");
				}

				case 0xFA: // Single-Precision Float (four-byte IEEE 754)
				{
					float number;
					return get_number(number) and sax->number_float(static_cast<number_float_t>(number), "");
				}

				case 0xFB: // Double-Precision Float (eight-byte IEEE 754)
				{
					double number;
					return get_number(number) and sax->number_float(static_cast<number_float_t>(number), "");
				}

				default: // anything else (0xFF is handled inside the other types)
				{
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, "error reading CBOR; last byte: 0x" + last_token));
				}
				}
			}

			/*!
			@return whether a valid MessagePack value was passed to the SAX parser
			*/
			bool parse_msgpack_internal()
			{
				switch (get())
				{
					// EOF
				case std::char_traits<char>::eof():
					return unexpect_eof();

					// positive fixint
				case 0x00:
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x04:
				case 0x05:
				case 0x06:
				case 0x07:
				case 0x08:
				case 0x09:
				case 0x0A:
				case 0x0B:
				case 0x0C:
				case 0x0D:
				case 0x0E:
				case 0x0F:
				case 0x10:
				case 0x11:
				case 0x12:
				case 0x13:
				case 0x14:
				case 0x15:
				case 0x16:
				case 0x17:
				case 0x18:
				case 0x19:
				case 0x1A:
				case 0x1B:
				case 0x1C:
				case 0x1D:
				case 0x1E:
				case 0x1F:
				case 0x20:
				case 0x21:
				case 0x22:
				case 0x23:
				case 0x24:
				case 0x25:
				case 0x26:
				case 0x27:
				case 0x28:
				case 0x29:
				case 0x2A:
				case 0x2B:
				case 0x2C:
				case 0x2D:
				case 0x2E:
				case 0x2F:
				case 0x30:
				case 0x31:
				case 0x32:
				case 0x33:
				case 0x34:
				case 0x35:
				case 0x36:
				case 0x37:
				case 0x38:
				case 0x39:
				case 0x3A:
				case 0x3B:
				case 0x3C:
				case 0x3D:
				case 0x3E:
				case 0x3F:
				case 0x40:
				case 0x41:
				case 0x42:
				case 0x43:
				case 0x44:
				case 0x45:
				case 0x46:
				case 0x47:
				case 0x48:
				case 0x49:
				case 0x4A:
				case 0x4B:
				case 0x4C:
				case 0x4D:
				case 0x4E:
				case 0x4F:
				case 0x50:
				case 0x51:
				case 0x52:
				case 0x53:
				case 0x54:
				case 0x55:
				case 0x56:
				case 0x57:
				case 0x58:
				case 0x59:
				case 0x5A:
				case 0x5B:
				case 0x5C:
				case 0x5D:
				case 0x5E:
				case 0x5F:
				case 0x60:
				case 0x61:
				case 0x62:
				case 0x63:
				case 0x64:
				case 0x65:
				case 0x66:
				case 0x67:
				case 0x68:
				case 0x69:
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:
				case 0x6E:
				case 0x6F:
				case 0x70:
				case 0x71:
				case 0x72:
				case 0x73:
				case 0x74:
				case 0x75:
				case 0x76:
				case 0x77:
				case 0x78:
				case 0x79:
				case 0x7A:
				case 0x7B:
				case 0x7C:
				case 0x7D:
				case 0x7E:
				case 0x7F:
					return sax->number_unsigned(static_cast<number_unsigned_t>(current));

					// fixmap
				case 0x80:
				case 0x81:
				case 0x82:
				case 0x83:
				case 0x84:
				case 0x85:
				case 0x86:
				case 0x87:
				case 0x88:
				case 0x89:
				case 0x8A:
				case 0x8B:
				case 0x8C:
				case 0x8D:
				case 0x8E:
				case 0x8F:
					return get_msgpack_object(static_cast<std::size_t>(current & 0x0F));

					// fixarray
				case 0x90:
				case 0x91:
				case 0x92:
				case 0x93:
				case 0x94:
				case 0x95:
				case 0x96:
				case 0x97:
				case 0x98:
				case 0x99:
				case 0x9A:
				case 0x9B:
				case 0x9C:
				case 0x9D:
				case 0x9E:
				case 0x9F:
					return get_msgpack_array(static_cast<std::size_t>(current & 0x0F));

					// fixstr
				case 0xA0:
				case 0xA1:
				case 0xA2:
				case 0xA3:
				case 0xA4:
				case 0xA5:
				case 0xA6:
				case 0xA7:
				case 0xA8:
				case 0xA9:
				case 0xAA:
				case 0xAB:
				case 0xAC:
				case 0xAD:
				case 0xAE:
				case 0xAF:
				case 0xB0:
				case 0xB1:
				case 0xB2:
				case 0xB3:
				case 0xB4:
				case 0xB5:
				case 0xB6:
				case 0xB7:
				case 0xB8:
				case 0xB9:
				case 0xBA:
				case 0xBB:
				case 0xBC:
				case 0xBD:
				case 0xBE:
				case 0xBF:
				{
					string_t s;
					return get_msgpack_string(s) and sax->string(s);
				}

				case 0xC0: // nil
					return sax->null();

				case 0xC2: // false
					return sax->boolean(false);

				case 0xC3: // true
					return sax->boolean(true);

				case 0xCA: // float 32
				{
					float number;
					return get_number(number) and sax->number_float(static_cast<number_float_t>(number), "");
				}

				case 0xCB: // float 64
				{
					double number;
					return get_number(number) and sax->number_float(static_cast<number_float_t>(number), "");
				}

				case 0xCC: // uint 8
				{
					uint8_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0xCD: // uint 16
				{
					uint16_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0xCE: // uint 32
				{
					uint32_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0xCF: // uint 64
				{
					uint64_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0xD0: // int 8
				{
					int8_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 0xD1: // int 16
				{
					int16_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 0xD2: // int 32
				{
					int32_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 0xD3: // int 64
				{
					int64_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 0xD9: // str 8
				case 0xDA: // str 16
				case 0xDB: // str 32
				{
					string_t s;
					return get_msgpack_string(s) and sax->string(s);
				}

				case 0xDC: // array 16
				{
					uint16_t len;
					return get_number(len) and get_msgpack_array(static_cast<std::size_t>(len));
				}

				case 0xDD: // array 32
				{
					uint32_t len;
					return get_number(len) and get_msgpack_array(static_cast<std::size_t>(len));
				}

				case 0xDE: // map 16
				{
					uint16_t len;
					return get_number(len) and get_msgpack_object(static_cast<std::size_t>(len));
				}

				case 0xDF: // map 32
				{
					uint32_t len;
					return get_number(len) and get_msgpack_object(static_cast<std::size_t>(len));
				}

				// negative fixint
				case 0xE0:
				case 0xE1:
				case 0xE2:
				case 0xE3:
				case 0xE4:
				case 0xE5:
				case 0xE6:
				case 0xE7:
				case 0xE8:
				case 0xE9:
				case 0xEA:
				case 0xEB:
				case 0xEC:
				case 0xED:
				case 0xEE:
				case 0xEF:
				case 0xF0:
				case 0xF1:
				case 0xF2:
				case 0xF3:
				case 0xF4:
				case 0xF5:
				case 0xF6:
				case 0xF7:
				case 0xF8:
				case 0xF9:
				case 0xFA:
				case 0xFB:
				case 0xFC:
				case 0xFD:
				case 0xFE:
				case 0xFF:
					return sax->number_integer(static_cast<int8_t>(current));

				default: // anything else
				{
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, "error reading MessagePack; last byte: 0x" + last_token));
				}
				}
			}

			/*!
			@param[in] get_char  whether a new character should be retrieved from the
								 input (true, default) or whether the last read
								 character should be considered instead

			@return whether a valid UBJSON value was passed to the SAX parser
			*/
			bool parse_ubjson_internal(const bool get_char = true)
			{
				return get_ubjson_value(get_char ? get_ignore_noop() : current);
			}

			/*!
			@brief get next character from the input

			This function provides the interface to the used input adapter. It does
			not throw in case the input reached EOF, but returns a -'ve valued
			`std::char_traits<char>::eof()` in that case.

			@return character read from the input
			*/
			int get()
			{
				++chars_read;
				return (current = ia->get_character());
			}

			/*!
			@return character read from the input after ignoring all 'N' entries
			*/
			int get_ignore_noop()
			{
				do
				{
					get();
				} while (current == 'N');

				return current;
			}

			/*
			@brief read a number from the input

			@tparam NumberType the type of the number
			@param[out] result  number of type @a NumberType

			@return whether conversion completed

			@note This function needs to respect the system's endianess, because
				  bytes in CBOR, MessagePack, and UBJSON are stored in network order
				  (big endian) and therefore need reordering on little endian systems.
			*/
			template<typename NumberType>
			bool get_number(NumberType& result)
			{
				// step 1: read input into array with system's byte order
				std::array<uint8_t, sizeof(NumberType)> vec;
				for (std::size_t i = 0; i < sizeof(NumberType); ++i)
				{
					get();
					if (JSON_UNLIKELY(not unexpect_eof()))
					{
						return false;
					}

					// reverse byte order prior to conversion if necessary
					if (is_little_endian)
					{
						vec[sizeof(NumberType) - i - 1] = static_cast<uint8_t>(current);
					}
					else
					{
						vec[i] = static_cast<uint8_t>(current); // LCOV_EXCL_LINE
					}
				}

				// step 2: convert array into number of type T and return
				std::memcpy(&result, vec.data(), sizeof(NumberType));
				return true;
			}

			/*!
			@brief create a string by reading characters from the input

			@tparam NumberType the type of the number
			@param[in] len number of characters to read
			@param[out] string created by reading @a len bytes

			@return whether string creation completed

			@note We can not reserve @a len bytes for the result, because @a len
				  may be too large. Usually, @ref unexpect_eof() detects the end of
				  the input before we run out of string memory.
			*/
			template<typename NumberType>
			bool get_string(const NumberType len, string_t& result)
			{
				bool success = true;
				std::generate_n(std::back_inserter(result), len, [this, &success]()
				{
					get();
					if (JSON_UNLIKELY(not unexpect_eof()))
					{
						success = false;
					}
					return static_cast<char>(current);
				});
				return success;
			}

			/*!
			@brief reads a CBOR string

			This function first reads starting bytes to determine the expected
			string length and then copies this number of bytes into a string.
			Additionally, CBOR's strings with indefinite lengths are supported.

			@param[out] result  created string

			@return whether string creation completed
			*/
			bool get_cbor_string(string_t& result)
			{
				if (JSON_UNLIKELY(not unexpect_eof()))
				{
					return false;
				}

				switch (current)
				{
					// UTF-8 string (0x00..0x17 bytes follow)
				case 0x60:
				case 0x61:
				case 0x62:
				case 0x63:
				case 0x64:
				case 0x65:
				case 0x66:
				case 0x67:
				case 0x68:
				case 0x69:
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:
				case 0x6E:
				case 0x6F:
				case 0x70:
				case 0x71:
				case 0x72:
				case 0x73:
				case 0x74:
				case 0x75:
				case 0x76:
				case 0x77:
				{
					return get_string(current & 0x1F, result);
				}

				case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
				{
					uint8_t len;
					return get_number(len) and get_string(len, result);
				}

				case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
				{
					uint16_t len;
					return get_number(len) and get_string(len, result);
				}

				case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
				{
					uint32_t len;
					return get_number(len) and get_string(len, result);
				}

				case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
				{
					uint64_t len;
					return get_number(len) and get_string(len, result);
				}

				case 0x7F: // UTF-8 string (indefinite length)
				{
					while (get() != 0xFF)
					{
						string_t chunk;
						if (not get_cbor_string(chunk))
						{
							return false;
						}
						result.append(chunk);
					}
					return true;
				}

				default:
				{
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, "expected a CBOR string; last byte: 0x" + last_token));
				}
				}
			}

			/*!
			@param[in] len  the length of the array or std::size_t(-1) for an
							array of indefinite size
			@return whether array creation completed
			*/
			bool get_cbor_array(const std::size_t len)
			{
				if (JSON_UNLIKELY(not sax->start_array(len)))
				{
					return false;
				}

				if (len != std::size_t(-1))
					for (std::size_t i = 0; i < len; ++i)
					{
						if (JSON_UNLIKELY(not parse_cbor_internal()))
						{
							return false;
						}
					}
				else
				{
					while (get() != 0xFF)
					{
						if (JSON_UNLIKELY(not parse_cbor_internal(false)))
						{
							return false;
						}
					}
				}

				return sax->end_array();
			}

			/*!
			@param[in] len  the length of the object or std::size_t(-1) for an
							object of indefinite size
			@return whether object creation completed
			*/
			bool get_cbor_object(const std::size_t len)
			{
				if (not JSON_UNLIKELY(sax->start_object(len)))
				{
					return false;
				}

				string_t key;
				if (len != std::size_t(-1))
				{
					for (std::size_t i = 0; i < len; ++i)
					{
						get();
						if (JSON_UNLIKELY(not get_cbor_string(key) or not sax->key(key)))
						{
							return false;
						}

						if (JSON_UNLIKELY(not parse_cbor_internal()))
						{
							return false;
						}
						key.clear();
					}
				}
				else
				{
					while (get() != 0xFF)
					{
						if (JSON_UNLIKELY(not get_cbor_string(key) or not sax->key(key)))
						{
							return false;
						}

						if (JSON_UNLIKELY(not parse_cbor_internal()))
						{
							return false;
						}
						key.clear();
					}
				}

				return sax->end_object();
			}

			/*!
			@brief reads a MessagePack string

			This function first reads starting bytes to determine the expected
			string length and then copies this number of bytes into a string.

			@param[out] result  created string

			@return whether string creation completed
			*/
			bool get_msgpack_string(string_t& result)
			{
				if (JSON_UNLIKELY(not unexpect_eof()))
				{
					return false;
				}

				switch (current)
				{
					// fixstr
				case 0xA0:
				case 0xA1:
				case 0xA2:
				case 0xA3:
				case 0xA4:
				case 0xA5:
				case 0xA6:
				case 0xA7:
				case 0xA8:
				case 0xA9:
				case 0xAA:
				case 0xAB:
				case 0xAC:
				case 0xAD:
				case 0xAE:
				case 0xAF:
				case 0xB0:
				case 0xB1:
				case 0xB2:
				case 0xB3:
				case 0xB4:
				case 0xB5:
				case 0xB6:
				case 0xB7:
				case 0xB8:
				case 0xB9:
				case 0xBA:
				case 0xBB:
				case 0xBC:
				case 0xBD:
				case 0xBE:
				case 0xBF:
				{
					return get_string(current & 0x1F, result);
				}

				case 0xD9: // str 8
				{
					uint8_t len;
					return get_number(len) and get_string(len, result);
				}

				case 0xDA: // str 16
				{
					uint16_t len;
					return get_number(len) and get_string(len, result);
				}

				case 0xDB: // str 32
				{
					uint32_t len;
					return get_number(len) and get_string(len, result);
				}

				default:
				{
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, "expected a MessagePack string; last byte: 0x" + last_token));
				}
				}
			}

			/*!
			@param[in] len  the length of the array
			@return whether array creation completed
			*/
			bool get_msgpack_array(const std::size_t len)
			{
				if (JSON_UNLIKELY(not sax->start_array(len)))
				{
					return false;
				}

				for (std::size_t i = 0; i < len; ++i)
				{
					if (JSON_UNLIKELY(not parse_msgpack_internal()))
					{
						return false;
					}
				}

				return sax->end_array();
			}

			/*!
			@param[in] len  the length of the object
			@return whether object creation completed
			*/
			bool get_msgpack_object(const std::size_t len)
			{
				if (JSON_UNLIKELY(not sax->start_object(len)))
				{
					return false;
				}

				string_t key;
				for (std::size_t i = 0; i < len; ++i)
				{
					get();
					if (JSON_UNLIKELY(not get_msgpack_string(key) or not sax->key(key)))
					{
						return false;
					}

					if (JSON_UNLIKELY(not parse_msgpack_internal()))
					{
						return false;
					}
					key.clear();
				}

				return sax->end_object();
			}

			/*!
			@brief reads a UBJSON string

			This function is either called after reading the 'S' byte explicitly
			indicating a string, or in case of an object key where the 'S' byte can be
			left out.

			@param[out] result   created string
			@param[in] get_char  whether a new character should be retrieved from the
								 input (true, default) or whether the last read
								 character should be considered instead

			@return whether string creation completed
			*/
			bool get_ubjson_string(string_t& result, const bool get_char = true)
			{
				if (get_char)
				{
					get();  // TODO: may we ignore N here?
				}

				if (JSON_UNLIKELY(not unexpect_eof()))
				{
					return false;
				}

				switch (current)
				{
				case 'U':
				{
					uint8_t len;
					return get_number(len) and get_string(len, result);
				}

				case 'i':
				{
					int8_t len;
					return get_number(len) and get_string(len, result);
				}

				case 'I':
				{
					int16_t len;
					return get_number(len) and get_string(len, result);
				}

				case 'l':
				{
					int32_t len;
					return get_number(len) and get_string(len, result);
				}

				case 'L':
				{
					int64_t len;
					return get_number(len) and get_string(len, result);
				}

				default:
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, "expected a UBJSON string; last byte: 0x" + last_token));
				}
			}

			/*!
			@param[out] result  determined size
			@return whether size determination completed
			*/
			bool get_ubjson_size_value(std::size_t& result)
			{
				switch (get_ignore_noop())
				{
				case 'U':
				{
					uint8_t number;
					if (JSON_UNLIKELY(not get_number(number)))
					{
						return false;
					}
					result = static_cast<std::size_t>(number);
					return true;
				}

				case 'i':
				{
					int8_t number;
					if (JSON_UNLIKELY(not get_number(number)))
					{
						return false;
					}
					result = static_cast<std::size_t>(number);
					return true;
				}

				case 'I':
				{
					int16_t number;
					if (JSON_UNLIKELY(not get_number(number)))
					{
						return false;
					}
					result = static_cast<std::size_t>(number);
					return true;
				}

				case 'l':
				{
					int32_t number;
					if (JSON_UNLIKELY(not get_number(number)))
					{
						return false;
					}
					result = static_cast<std::size_t>(number);
					return true;
				}

				case 'L':
				{
					int64_t number;
					if (JSON_UNLIKELY(not get_number(number)))
					{
						return false;
					}
					result = static_cast<std::size_t>(number);
					return true;
				}

				default:
				{
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, "byte after '#' must denote a number type; last byte: 0x" + last_token));
				}
				}
			}

			/*!
			@brief determine the type and size for a container

			In the optimized UBJSON format, a type and a size can be provided to allow
			for a more compact representation.

			@param[out] result  pair of the size and the type

			@return whether pair creation completed
			*/
			bool get_ubjson_size_type(std::pair<std::size_t, int>& result)
			{
				result.first = string_t::npos; // size
				result.second = 0; // type

				get_ignore_noop();

				if (current == '$')
				{
					result.second = get();  // must not ignore 'N', because 'N' maybe the type
					if (JSON_UNLIKELY(not unexpect_eof()))
					{
						return false;
					}

					get_ignore_noop();
					if (JSON_UNLIKELY(current != '#'))
					{
						if (JSON_UNLIKELY(not unexpect_eof()))
						{
							return false;
						}
						auto last_token = get_token_string();
						return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, "expected '#' after UBJSON type information; last byte: 0x" + last_token));
					}

					return get_ubjson_size_value(result.first);
				}
				else if (current == '#')
				{
					return get_ubjson_size_value(result.first);
				}
				return true;
			}

			/*!
			@param prefix  the previously read or set type prefix
			@return whether value creation completed
			*/
			bool get_ubjson_value(const int prefix)
			{
				switch (prefix)
				{
				case std::char_traits<char>::eof():  // EOF
					return unexpect_eof();

				case 'T':  // true
					return sax->boolean(true);
				case 'F':  // false
					return sax->boolean(false);

				case 'Z':  // null
					return sax->null();

				case 'U':
				{
					uint8_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 'i':
				{
					int8_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 'I':
				{
					int16_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 'l':
				{
					int32_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 'L':
				{
					int64_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 'd':
				{
					float number;
					return get_number(number) and sax->number_float(static_cast<number_float_t>(number), "");
				}

				case 'D':
				{
					double number;
					return get_number(number) and sax->number_float(static_cast<number_float_t>(number), "");
				}

				case 'C':  // char
				{
					get();
					if (JSON_UNLIKELY(not unexpect_eof()))
					{
						return false;
					}
					if (JSON_UNLIKELY(current > 127))
					{
						auto last_token = get_token_string();
						return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, "byte after 'C' must be in range 0x00..0x7F; last byte: 0x" + last_token));
					}
					string_t s(1, static_cast<char>(current));
					return sax->string(s);
				}

				case 'S':  // string
				{
					string_t s;
					return get_ubjson_string(s) and sax->string(s);
				}

				case '[':  // array
					return get_ubjson_array();

				case '{':  // object
					return get_ubjson_object();

				default: // anything else
				{
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, "error reading UBJSON; last byte: 0x" + last_token));
				}
				}
			}

			/*!
			@return whether array creation completed
			*/
			bool get_ubjson_array()
			{
				std::pair<std::size_t, int> size_and_type;
				if (JSON_UNLIKELY(not get_ubjson_size_type(size_and_type)))
				{
					return false;
				}

				if (size_and_type.first != string_t::npos)
				{
					if (JSON_UNLIKELY(not sax->start_array(size_and_type.first)))
					{
						return false;
					}

					if (size_and_type.second != 0)
					{
						if (size_and_type.second != 'N')
						{
							for (std::size_t i = 0; i < size_and_type.first; ++i)
							{
								if (JSON_UNLIKELY(not get_ubjson_value(size_and_type.second)))
								{
									return false;
								}
							}
						}
					}
					else
					{
						for (std::size_t i = 0; i < size_and_type.first; ++i)
						{
							if (JSON_UNLIKELY(not parse_ubjson_internal()))
							{
								return false;
							}
						}
					}
				}
				else
				{
					if (JSON_UNLIKELY(not sax->start_array(std::size_t(-1))))
					{
						return false;
					}

					while (current != ']')
					{
						if (JSON_UNLIKELY(not parse_ubjson_internal(false)))
						{
							return false;
						}
						get_ignore_noop();
					}
				}

				return sax->end_array();
			}

			/*!
			@return whether object creation completed
			*/
			bool get_ubjson_object()
			{
				std::pair<std::size_t, int> size_and_type;
				if (JSON_UNLIKELY(not get_ubjson_size_type(size_and_type)))
				{
					return false;
				}

				string_t key;
				if (size_and_type.first != string_t::npos)
				{
					if (JSON_UNLIKELY(not sax->start_object(size_and_type.first)))
					{
						return false;
					}

					if (size_and_type.second != 0)
					{
						for (std::size_t i = 0; i < size_and_type.first; ++i)
						{
							if (JSON_UNLIKELY(not get_ubjson_string(key) or not sax->key(key)))
							{
								return false;
							}
							if (JSON_UNLIKELY(not get_ubjson_value(size_and_type.second)))
							{
								return false;
							}
							key.clear();
						}
					}
					else
					{
						for (std::size_t i = 0; i < size_and_type.first; ++i)
						{
							if (JSON_UNLIKELY(not get_ubjson_string(key) or not sax->key(key)))
							{
								return false;
							}
							if (JSON_UNLIKELY(not parse_ubjson_internal()))
							{
								return false;
							}
							key.clear();
						}
					}
				}
				else
				{
					if (JSON_UNLIKELY(not sax->start_object(std::size_t(-1))))
					{
						return false;
					}

					while (current != '}')
					{
						if (JSON_UNLIKELY(not get_ubjson_string(key, false) or not sax->key(key)))
						{
							return false;
						}
						if (JSON_UNLIKELY(not parse_ubjson_internal()))
						{
							return false;
						}
						get_ignore_noop();
						key.clear();
					}
				}

				return sax->end_object();
			}

			/*!
			@return whether the last read character is not EOF
			*/
			bool unexpect_eof() const
			{
				if (JSON_UNLIKELY(current == std::char_traits<char>::eof()))
				{
					return sax->parse_error(chars_read, "<end of file>", parse_error::create(110, chars_read, "unexpected end of input"));
				}
				return true;
			}

			/*!
			@return a string representation of the last read byte
			*/
			std::string get_token_string() const
			{
				char cr[3];
				snprintf(cr, 3, "%.2hhX", static_cast<unsigned char>(current));
				return std::string{ cr };
			}

		private:
			/// input adapter
			input_adapter_t ia = nullptr;

			/// the current character
			int current = std::char_traits<char>::eof();

			/// the number of characters read
			std::size_t chars_read = 0;

			/// whether we can assume little endianess
			const bool is_little_endian = little_endianess();

			/// the SAX parser
			json_sax_t* sax = nullptr;
		};
	}
}

// #include <nlohmann/detail/output/binary_writer.hpp>


#include <algorithm> // reverse
#include <array> // array
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstring> // memcpy
#include <limits> // numeric_limits

// #include <nlohmann/detail/input/binary_reader.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>


namespace nlohmann
{
	namespace detail
	{
		///////////////////
		// binary writer //
		///////////////////

		/*!
		@brief serialization to CBOR and MessagePack values
		*/
		template<typename BasicJsonType, typename CharType>
		class binary_writer
		{
		public:
			/*!
			@brief create a binary writer

			@param[in] adapter  output adapter to write to
			*/
			explicit binary_writer(output_adapter_t<CharType> adapter) : oa(adapter)
			{
				assert(oa);
			}

			/*!
			@brief[in] j  JSON value to serialize
			*/
			void write_cbor(const BasicJsonType& j)
			{
				switch (j.type())
				{
				case value_t::null:
				{
					oa->write_character(static_cast<CharType>(0xF6));
					break;
				}

				case value_t::boolean:
				{
					oa->write_character(j.m_value.boolean
						? static_cast<CharType>(0xF5)
						: static_cast<CharType>(0xF4));
					break;
				}

				case value_t::number_integer:
				{
					if (j.m_value.number_integer >= 0)
					{
						// CBOR does not differentiate between positive signed
						// integers and unsigned integers. Therefore, we used the
						// code from the value_t::number_unsigned case here.
						if (j.m_value.number_integer <= 0x17)
						{
							write_number(static_cast<uint8_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer <= (std::numeric_limits<uint8_t>::max)())
						{
							oa->write_character(static_cast<CharType>(0x18));
							write_number(static_cast<uint8_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer <= (std::numeric_limits<uint16_t>::max)())
						{
							oa->write_character(static_cast<CharType>(0x19));
							write_number(static_cast<uint16_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer <= (std::numeric_limits<uint32_t>::max)())
						{
							oa->write_character(static_cast<CharType>(0x1A));
							write_number(static_cast<uint32_t>(j.m_value.number_integer));
						}
						else
						{
							oa->write_character(static_cast<CharType>(0x1B));
							write_number(static_cast<uint64_t>(j.m_value.number_integer));
						}
					}
					else
					{
						// The conversions below encode the sign in the first
						// byte, and the value is converted to a positive number.
						const auto positive_number = -1 - j.m_value.number_integer;
						if (j.m_value.number_integer >= -24)
						{
							write_number(static_cast<uint8_t>(0x20 + positive_number));
						}
						else if (positive_number <= (std::numeric_limits<uint8_t>::max)())
						{
							oa->write_character(static_cast<CharType>(0x38));
							write_number(static_cast<uint8_t>(positive_number));
						}
						else if (positive_number <= (std::numeric_limits<uint16_t>::max)())
						{
							oa->write_character(static_cast<CharType>(0x39));
							write_number(static_cast<uint16_t>(positive_number));
						}
						else if (positive_number <= (std::numeric_limits<uint32_t>::max)())
						{
							oa->write_character(static_cast<CharType>(0x3A));
							write_number(static_cast<uint32_t>(positive_number));
						}
						else
						{
							oa->write_character(static_cast<CharType>(0x3B));
							write_number(static_cast<uint64_t>(positive_number));
						}
					}
					break;
				}

				case value_t::number_unsigned:
				{
					if (j.m_value.number_unsigned <= 0x17)
					{
						write_number(static_cast<uint8_t>(j.m_value.number_unsigned));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint8_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x18));
						write_number(static_cast<uint8_t>(j.m_value.number_unsigned));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint16_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x19));
						write_number(static_cast<uint16_t>(j.m_value.number_unsigned));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint32_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x1A));
						write_number(static_cast<uint32_t>(j.m_value.number_unsigned));
					}
					else
					{
						oa->write_character(static_cast<CharType>(0x1B));
						write_number(static_cast<uint64_t>(j.m_value.number_unsigned));
					}
					break;
				}

				case value_t::number_float:
				{
					oa->write_character(get_cbor_float_prefix(j.m_value.number_float));
					write_number(j.m_value.number_float);
					break;
				}

				case value_t::string:
				{
					// step 1: write control byte and the string length
					const auto N = j.m_value.string->size();
					if (N <= 0x17)
					{
						write_number(static_cast<uint8_t>(0x60 + N));
					}
					else if (N <= (std::numeric_limits<uint8_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x78));
						write_number(static_cast<uint8_t>(N));
					}
					else if (N <= (std::numeric_limits<uint16_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x79));
						write_number(static_cast<uint16_t>(N));
					}
					else if (N <= (std::numeric_limits<uint32_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x7A));
						write_number(static_cast<uint32_t>(N));
					}
					// LCOV_EXCL_START
					else if (N <= (std::numeric_limits<uint64_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x7B));
						write_number(static_cast<uint64_t>(N));
					}
					// LCOV_EXCL_STOP

					// step 2: write the string
					oa->write_characters(
						reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
						j.m_value.string->size());
					break;
				}

				case value_t::array:
				{
					// step 1: write control byte and the array size
					const auto N = j.m_value.array->size();
					if (N <= 0x17)
					{
						write_number(static_cast<uint8_t>(0x80 + N));
					}
					else if (N <= (std::numeric_limits<uint8_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x98));
						write_number(static_cast<uint8_t>(N));
					}
					else if (N <= (std::numeric_limits<uint16_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x99));
						write_number(static_cast<uint16_t>(N));
					}
					else if (N <= (std::numeric_limits<uint32_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x9A));
						write_number(static_cast<uint32_t>(N));
					}
					// LCOV_EXCL_START
					else if (N <= (std::numeric_limits<uint64_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x9B));
						write_number(static_cast<uint64_t>(N));
					}
					// LCOV_EXCL_STOP

					// step 2: write each element
					for (const auto& el : *j.m_value.array)
					{
						write_cbor(el);
					}
					break;
				}

				case value_t::object:
				{
					// step 1: write control byte and the object size
					const auto N = j.m_value.object->size();
					if (N <= 0x17)
					{
						write_number(static_cast<uint8_t>(0xA0 + N));
					}
					else if (N <= (std::numeric_limits<uint8_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0xB8));
						write_number(static_cast<uint8_t>(N));
					}
					else if (N <= (std::numeric_limits<uint16_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0xB9));
						write_number(static_cast<uint16_t>(N));
					}
					else if (N <= (std::numeric_limits<uint32_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0xBA));
						write_number(static_cast<uint32_t>(N));
					}
					// LCOV_EXCL_START
					else if (N <= (std::numeric_limits<uint64_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0xBB));
						write_number(static_cast<uint64_t>(N));
					}
					// LCOV_EXCL_STOP

					// step 2: write each element
					for (const auto& el : *j.m_value.object)
					{
						write_cbor(el.first);
						write_cbor(el.second);
					}
					break;
				}

				default:
					break;
				}
			}

			/*!
			@brief[in] j  JSON value to serialize
			*/
			void write_msgpack(const BasicJsonType& j)
			{
				switch (j.type())
				{
				case value_t::null: // nil
				{
					oa->write_character(static_cast<CharType>(0xC0));
					break;
				}

				case value_t::boolean: // true and false
				{
					oa->write_character(j.m_value.boolean
						? static_cast<CharType>(0xC3)
						: static_cast<CharType>(0xC2));
					break;
				}

				case value_t::number_integer:
				{
					if (j.m_value.number_integer >= 0)
					{
						// MessagePack does not differentiate between positive
						// signed integers and unsigned integers. Therefore, we used
						// the code from the value_t::number_unsigned case here.
						if (j.m_value.number_unsigned < 128)
						{
							// positive fixnum
							write_number(static_cast<uint8_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_unsigned <= (std::numeric_limits<uint8_t>::max)())
						{
							// uint 8
							oa->write_character(static_cast<CharType>(0xCC));
							write_number(static_cast<uint8_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_unsigned <= (std::numeric_limits<uint16_t>::max)())
						{
							// uint 16
							oa->write_character(static_cast<CharType>(0xCD));
							write_number(static_cast<uint16_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_unsigned <= (std::numeric_limits<uint32_t>::max)())
						{
							// uint 32
							oa->write_character(static_cast<CharType>(0xCE));
							write_number(static_cast<uint32_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_unsigned <= (std::numeric_limits<uint64_t>::max)())
						{
							// uint 64
							oa->write_character(static_cast<CharType>(0xCF));
							write_number(static_cast<uint64_t>(j.m_value.number_integer));
						}
					}
					else
					{
						if (j.m_value.number_integer >= -32)
						{
							// negative fixnum
							write_number(static_cast<int8_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer >= (std::numeric_limits<int8_t>::min)() and
							j.m_value.number_integer <= (std::numeric_limits<int8_t>::max)())
						{
							// int 8
							oa->write_character(static_cast<CharType>(0xD0));
							write_number(static_cast<int8_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer >= (std::numeric_limits<int16_t>::min)() and
							j.m_value.number_integer <= (std::numeric_limits<int16_t>::max)())
						{
							// int 16
							oa->write_character(static_cast<CharType>(0xD1));
							write_number(static_cast<int16_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer >= (std::numeric_limits<int32_t>::min)() and
							j.m_value.number_integer <= (std::numeric_limits<int32_t>::max)())
						{
							// int 32
							oa->write_character(static_cast<CharType>(0xD2));
							write_number(static_cast<int32_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer >= (std::numeric_limits<int64_t>::min)() and
							j.m_value.number_integer <= (std::numeric_limits<int64_t>::max)())
						{
							// int 64
							oa->write_character(static_cast<CharType>(0xD3));
							write_number(static_cast<int64_t>(j.m_value.number_integer));
						}
					}
					break;
				}

				case value_t::number_unsigned:
				{
					if (j.m_value.number_unsigned < 128)
					{
						// positive fixnum
						write_number(static_cast<uint8_t>(j.m_value.number_integer));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint8_t>::max)())
					{
						// uint 8
						oa->write_character(static_cast<CharType>(0xCC));
						write_number(static_cast<uint8_t>(j.m_value.number_integer));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint16_t>::max)())
					{
						// uint 16
						oa->write_character(static_cast<CharType>(0xCD));
						write_number(static_cast<uint16_t>(j.m_value.number_integer));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint32_t>::max)())
					{
						// uint 32
						oa->write_character(static_cast<CharType>(0xCE));
						write_number(static_cast<uint32_t>(j.m_value.number_integer));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint64_t>::max)())
					{
						// uint 64
						oa->write_character(static_cast<CharType>(0xCF));
						write_number(static_cast<uint64_t>(j.m_value.number_integer));
					}
					break;
				}

				case value_t::number_float:
				{
					oa->write_character(get_msgpack_float_prefix(j.m_value.number_float));
					write_number(j.m_value.number_float);
					break;
				}

				case value_t::string:
				{
					// step 1: write control byte and the string length
					const auto N = j.m_value.string->size();
					if (N <= 31)
					{
						// fixstr
						write_number(static_cast<uint8_t>(0xA0 | N));
					}
					else if (N <= (std::numeric_limits<uint8_t>::max)())
					{
						// str 8
						oa->write_character(static_cast<CharType>(0xD9));
						write_number(static_cast<uint8_t>(N));
					}
					else if (N <= (std::numeric_limits<uint16_t>::max)())
					{
						// str 16
						oa->write_character(static_cast<CharType>(0xDA));
						write_number(static_cast<uint16_t>(N));
					}
					else if (N <= (std::numeric_limits<uint32_t>::max)())
					{
						// str 32
						oa->write_character(static_cast<CharType>(0xDB));
						write_number(static_cast<uint32_t>(N));
					}

					// step 2: write the string
					oa->write_characters(
						reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
						j.m_value.string->size());
					break;
				}

				case value_t::array:
				{
					// step 1: write control byte and the array size
					const auto N = j.m_value.array->size();
					if (N <= 15)
					{
						// fixarray
						write_number(static_cast<uint8_t>(0x90 | N));
					}
					else if (N <= (std::numeric_limits<uint16_t>::max)())
					{
						// array 16
						oa->write_character(static_cast<CharType>(0xDC));
						write_number(static_cast<uint16_t>(N));
					}
					else if (N <= (std::numeric_limits<uint32_t>::max)())
					{
						// array 32
						oa->write_character(static_cast<CharType>(0xDD));
						write_number(static_cast<uint32_t>(N));
					}

					// step 2: write each element
					for (const auto& el : *j.m_value.array)
					{
						write_msgpack(el);
					}
					break;
				}

				case value_t::object:
				{
					// step 1: write control byte and the object size
					const auto N = j.m_value.object->size();
					if (N <= 15)
					{
						// fixmap
						write_number(static_cast<uint8_t>(0x80 | (N & 0xF)));
					}
					else if (N <= (std::numeric_limits<uint16_t>::max)())
					{
						// map 16
						oa->write_character(static_cast<CharType>(0xDE));
						write_number(static_cast<uint16_t>(N));
					}
					else if (N <= (std::numeric_limits<uint32_t>::max)())
					{
						// map 32
						oa->write_character(static_cast<CharType>(0xDF));
						write_number(static_cast<uint32_t>(N));
					}

					// step 2: write each element
					for (const auto& el : *j.m_value.object)
					{
						write_msgpack(el.first);
						write_msgpack(el.second);
					}
					break;
				}

				default:
					break;
				}
			}

			/*!
			@param[in] j  JSON value to serialize
			@param[in] use_count   whether to use '#' prefixes (optimized format)
			@param[in] use_type    whether to use '$' prefixes (optimized format)
			@param[in] add_prefix  whether prefixes need to be used for this value
			*/
			void write_ubjson(const BasicJsonType& j, const bool use_count,
				const bool use_type, const bool add_prefix = true)
			{
				switch (j.type())
				{
				case value_t::null:
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('Z'));
					}
					break;
				}

				case value_t::boolean:
				{
					if (add_prefix)
						oa->write_character(j.m_value.boolean
							? static_cast<CharType>('T')
							: static_cast<CharType>('F'));
					break;
				}

				case value_t::number_integer:
				{
					write_number_with_ubjson_prefix(j.m_value.number_integer, add_prefix);
					break;
				}

				case value_t::number_unsigned:
				{
					write_number_with_ubjson_prefix(j.m_value.number_unsigned, add_prefix);
					break;
				}

				case value_t::number_float:
				{
					write_number_with_ubjson_prefix(j.m_value.number_float, add_prefix);
					break;
				}

				case value_t::string:
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('S'));
					}
					write_number_with_ubjson_prefix(j.m_value.string->size(), true);
					oa->write_characters(
						reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
						j.m_value.string->size());
					break;
				}

				case value_t::array:
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('['));
					}

					bool prefix_required = true;
					if (use_type and not j.m_value.array->empty())
					{
						assert(use_count);
						const CharType first_prefix = ubjson_prefix(j.front());
						const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
							[this, first_prefix](const BasicJsonType & v)
						{
							return ubjson_prefix(v) == first_prefix;
						});

						if (same_prefix)
						{
							prefix_required = false;
							oa->write_character(static_cast<CharType>('$'));
							oa->write_character(first_prefix);
						}
					}

					if (use_count)
					{
						oa->write_character(static_cast<CharType>('#'));
						write_number_with_ubjson_prefix(j.m_value.array->size(), true);
					}

					for (const auto& el : *j.m_value.array)
					{
						write_ubjson(el, use_count, use_type, prefix_required);
					}

					if (not use_count)
					{
						oa->write_character(static_cast<CharType>(']'));
					}

					break;
				}

				case value_t::object:
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('{'));
					}

					bool prefix_required = true;
					if (use_type and not j.m_value.object->empty())
					{
						assert(use_count);
						const CharType first_prefix = ubjson_prefix(j.front());
						const bool same_prefix = std::all_of(j.begin(), j.end(),
							[this, first_prefix](const BasicJsonType & v)
						{
							return ubjson_prefix(v) == first_prefix;
						});

						if (same_prefix)
						{
							prefix_required = false;
							oa->write_character(static_cast<CharType>('$'));
							oa->write_character(first_prefix);
						}
					}

					if (use_count)
					{
						oa->write_character(static_cast<CharType>('#'));
						write_number_with_ubjson_prefix(j.m_value.object->size(), true);
					}

					for (const auto& el : *j.m_value.object)
					{
						write_number_with_ubjson_prefix(el.first.size(), true);
						oa->write_characters(
							reinterpret_cast<const CharType*>(el.first.c_str()),
							el.first.size());
						write_ubjson(el.second, use_count, use_type, prefix_required);
					}

					if (not use_count)
					{
						oa->write_character(static_cast<CharType>('}'));
					}

					break;
				}

				default:
					break;
				}
			}

		private:
			/*
			@brief write a number to output input

			@param[in] n number of type @a NumberType
			@tparam NumberType the type of the number

			@note This function needs to respect the system's endianess, because bytes
				  in CBOR, MessagePack, and UBJSON are stored in network order (big
				  endian) and therefore need reordering on little endian systems.
			*/
			template<typename NumberType>
			void write_number(const NumberType n)
			{
				// step 1: write number to array of length NumberType
				std::array<CharType, sizeof(NumberType)> vec;
				std::memcpy(vec.data(), &n, sizeof(NumberType));

				// step 2: write array to output (with possible reordering)
				if (is_little_endian)
				{
					// reverse byte order prior to conversion if necessary
					std::reverse(vec.begin(), vec.end());
				}

				oa->write_characters(vec.data(), sizeof(NumberType));
			}

			// UBJSON: write number (floating point)
			template<typename NumberType, typename std::enable_if<
				std::is_floating_point<NumberType>::value, int>::type = 0>
				void write_number_with_ubjson_prefix(const NumberType n,
					const bool add_prefix)
			{
				if (add_prefix)
				{
					oa->write_character(get_ubjson_float_prefix(n));
				}
				write_number(n);
			}

			// UBJSON: write number (unsigned integer)
			template<typename NumberType, typename std::enable_if<
				std::is_unsigned<NumberType>::value, int>::type = 0>
				void write_number_with_ubjson_prefix(const NumberType n,
					const bool add_prefix)
			{
				if (n <= static_cast<uint64_t>((std::numeric_limits<int8_t>::max)()))
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('i'));  // int8
					}
					write_number(static_cast<uint8_t>(n));
				}
				else if (n <= (std::numeric_limits<uint8_t>::max)())
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('U'));  // uint8
					}
					write_number(static_cast<uint8_t>(n));
				}
				else if (n <= static_cast<uint64_t>((std::numeric_limits<int16_t>::max)()))
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('I'));  // int16
					}
					write_number(static_cast<int16_t>(n));
				}
				else if (n <= static_cast<uint64_t>((std::numeric_limits<int32_t>::max)()))
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('l'));  // int32
					}
					write_number(static_cast<int32_t>(n));
				}
				else if (n <= static_cast<uint64_t>((std::numeric_limits<int64_t>::max)()))
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('L'));  // int64
					}
					write_number(static_cast<int64_t>(n));
				}
				else
				{
					JSON_THROW(out_of_range::create(407, "number overflow serializing " + std::to_string(n)));
				}
			}

			// UBJSON: write number (signed integer)
			template<typename NumberType, typename std::enable_if<
				std::is_signed<NumberType>::value and
				not std::is_floating_point<NumberType>::value, int>::type = 0>
				void write_number_with_ubjson_prefix(const NumberType n,
					const bool add_prefix)
			{
				if ((std::numeric_limits<int8_t>::min)() <= n and n <= (std::numeric_limits<int8_t>::max)())
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('i'));  // int8
					}
					write_number(static_cast<int8_t>(n));
				}
				else if (static_cast<int64_t>((std::numeric_limits<uint8_t>::min)()) <= n and n <= static_cast<int64_t>((std::numeric_limits<uint8_t>::max)()))
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('U'));  // uint8
					}
					write_number(static_cast<uint8_t>(n));
				}
				else if ((std::numeric_limits<int16_t>::min)() <= n and n <= (std::numeric_limits<int16_t>::max)())
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('I'));  // int16
					}
					write_number(static_cast<int16_t>(n));
				}
				else if ((std::numeric_limits<int32_t>::min)() <= n and n <= (std::numeric_limits<int32_t>::max)())
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('l'));  // int32
					}
					write_number(static_cast<int32_t>(n));
				}
				else if ((std::numeric_limits<int64_t>::min)() <= n and n <= (std::numeric_limits<int64_t>::max)())
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('L'));  // int64
					}
					write_number(static_cast<int64_t>(n));
				}
				// LCOV_EXCL_START
				else
				{
					JSON_THROW(out_of_range::create(407, "number overflow serializing " + std::to_string(n)));
				}
				// LCOV_EXCL_STOP
			}

			/*!
			@brief determine the type prefix of container values

			@note This function does not need to be 100% accurate when it comes to
				  integer limits. In case a number exceeds the limits of int64_t,
				  this will be detected by a later call to function
				  write_number_with_ubjson_prefix. Therefore, we return 'L' for any
				  value that does not fit the previous limits.
			*/
			CharType ubjson_prefix(const BasicJsonType& j) const noexcept
			{
				switch (j.type())
				{
				case value_t::null:
					return 'Z';

				case value_t::boolean:
					return j.m_value.boolean ? 'T' : 'F';

				case value_t::number_integer:
				{
					if ((std::numeric_limits<int8_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<int8_t>::max)())
					{
						return 'i';
					}
					else if ((std::numeric_limits<uint8_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<uint8_t>::max)())
					{
						return 'U';
					}
					else if ((std::numeric_limits<int16_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<int16_t>::max)())
					{
						return 'I';
					}
					else if ((std::numeric_limits<int32_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<int32_t>::max)())
					{
						return 'l';
					}
					else  // no check and assume int64_t (see note above)
					{
						return 'L';
					}
				}

				case value_t::number_unsigned:
				{
					if (j.m_value.number_unsigned <= (std::numeric_limits<int8_t>::max)())
					{
						return 'i';
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint8_t>::max)())
					{
						return 'U';
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<int16_t>::max)())
					{
						return 'I';
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<int32_t>::max)())
					{
						return 'l';
					}
					else  // no check and assume int64_t (see note above)
					{
						return 'L';
					}
				}

				case value_t::number_float:
					return get_ubjson_float_prefix(j.m_value.number_float);

				case value_t::string:
					return 'S';

				case value_t::array:
					return '[';

				case value_t::object:
					return '{';

				default:  // discarded values
					return 'N';
				}
			}

			static constexpr CharType get_cbor_float_prefix(float)
			{
				return static_cast<CharType>(0xFA);  // Single-Precision Float
			}

			static constexpr CharType get_cbor_float_prefix(double)
			{
				return static_cast<CharType>(0xFB);  // Double-Precision Float
			}

			static constexpr CharType get_msgpack_float_prefix(float)
			{
				return static_cast<CharType>(0xCA);  // float 32
			}

			static constexpr CharType get_msgpack_float_prefix(double)
			{
				return static_cast<CharType>(0xCB);  // float 64
			}

			static constexpr CharType get_ubjson_float_prefix(float)
			{
				return 'd';  // float 32
			}

			static constexpr CharType get_ubjson_float_prefix(double)
			{
				return 'D';  // float 64
			}

		private:
			/// whether we can assume little endianess
			const bool is_little_endian = binary_reader<BasicJsonType>::little_endianess();

			/// the output
			output_adapter_t<CharType> oa = nullptr;
		};
	}
}

// #include <nlohmann/detail/output/serializer.hpp>


#include <algorithm> // reverse, remove, fill, find, none_of
#include <array> // array
#include <cassert> // assert
#include <ciso646> // and, or
#include <clocale> // localeconv, lconv
#include <cmath> // labs, isfinite, isnan, signbit
#include <cstddef> // size_t, ptrdiff_t
#include <cstdint> // uint8_t
#include <cstdio> // snprintf
#include <limits> // numeric_limits
#include <string> // string
#include <type_traits> // is_same

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/conversions/to_chars.hpp>


#include <cassert> // assert
#include <ciso646> // or, and, not
#include <cmath>   // signbit, isfinite
#include <cstdint> // intN_t, uintN_t
#include <cstring> // memcpy, memmove

namespace nlohmann
{
	namespace detail
	{

		/*!
		@brief implements the Grisu2 algorithm for binary to decimal floating-point
		conversion.

		This implementation is a slightly modified version of the reference
		implementation which may be obtained from
		http://florian.loitsch.com/publications (bench.tar.gz).

		The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.

		For a detailed description of the algorithm see:

		[1] Loitsch, "Printing Floating-Point Numbers Quickly and Accurately with
			Integers", Proceedings of the ACM SIGPLAN 2010 Conference on Programming
			Language Design and Implementation, PLDI 2010
		[2] Burger, Dybvig, "Printing Floating-Point Numbers Quickly and Accurately",
			Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language
			Design and Implementation, PLDI 1996
		*/
		namespace dtoa_impl
		{

			template <typename Target, typename Source>
			Target reinterpret_bits(const Source source)
			{
				static_assert(sizeof(Target) == sizeof(Source), "size mismatch");

				Target target;
				std::memcpy(&target, &source, sizeof(Source));
				return target;
			}

			struct diyfp // f * 2^e
			{
				static constexpr int kPrecision = 64; // = q

				uint64_t f;
				int e;

				constexpr diyfp() noexcept : f(0), e(0) {}
				constexpr diyfp(uint64_t f_, int e_) noexcept : f(f_), e(e_) {}

				/*!
				@brief returns x - y
				@pre x.e == y.e and x.f >= y.f
				*/
				static diyfp sub(const diyfp& x, const diyfp& y) noexcept
				{
					assert(x.e == y.e);
					assert(x.f >= y.f);

					return diyfp(x.f - y.f, x.e);
				}

				/*!
				@brief returns x * y
				@note The result is rounded. (Only the upper q bits are returned.)
				*/
				static diyfp mul(const diyfp& x, const diyfp& y) noexcept
				{
					static_assert(kPrecision == 64, "internal error");

					// Computes:
					//  f = round((x.f * y.f) / 2^q)
					//  e = x.e + y.e + q

					// Emulate the 64-bit * 64-bit multiplication:
					//
					// p = u * v
					//   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)
					//   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )
					//   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )
					//   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )
					//   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)
					//   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )
					//   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )
					//
					// (Since Q might be larger than 2^32 - 1)
					//
					//   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)
					//
					// (Q_hi + H does not overflow a 64-bit int)
					//
					//   = p_lo + 2^64 p_hi

					const uint64_t u_lo = x.f & 0xFFFFFFFF;
					const uint64_t u_hi = x.f >> 32;
					const uint64_t v_lo = y.f & 0xFFFFFFFF;
					const uint64_t v_hi = y.f >> 32;

					const uint64_t p0 = u_lo * v_lo;
					const uint64_t p1 = u_lo * v_hi;
					const uint64_t p2 = u_hi * v_lo;
					const uint64_t p3 = u_hi * v_hi;

					const uint64_t p0_hi = p0 >> 32;
					const uint64_t p1_lo = p1 & 0xFFFFFFFF;
					const uint64_t p1_hi = p1 >> 32;
					const uint64_t p2_lo = p2 & 0xFFFFFFFF;
					const uint64_t p2_hi = p2 >> 32;

					uint64_t Q = p0_hi + p1_lo + p2_lo;

					// The full product might now be computed as
					//
					// p_hi = p3 + p2_hi + p1_hi + (Q >> 32)
					// p_lo = p0_lo + (Q << 32)
					//
					// But in this particular case here, the full p_lo is not required.
					// Effectively we only need to add the highest bit in p_lo to p_hi (and
					// Q_hi + 1 does not overflow).

					Q += uint64_t{ 1 } << (64 - 32 - 1); // round, ties up

					const uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32);

					return diyfp(h, x.e + y.e + 64);
				}

				/*!
				@brief normalize x such that the significand is >= 2^(q-1)
				@pre x.f != 0
				*/
				static diyfp normalize(diyfp x) noexcept
				{
					assert(x.f != 0);

					while ((x.f >> 63) == 0)
					{
						x.f <<= 1;
						x.e--;
					}

					return x;
				}

				/*!
				@brief normalize x such that the result has the exponent E
				@pre e >= x.e and the upper e - x.e bits of x.f must be zero.
				*/
				static diyfp normalize_to(const diyfp& x, const int target_exponent) noexcept
				{
					const int delta = x.e - target_exponent;

					assert(delta >= 0);
					assert(((x.f << delta) >> delta) == x.f);

					return diyfp(x.f << delta, target_exponent);
				}
			};

			struct boundaries
			{
				diyfp w;
				diyfp minus;
				diyfp plus;
			};

			/*!
			Compute the (normalized) diyfp representing the input number 'value' and its
			boundaries.

			@pre value must be finite and positive
			*/
			template <typename FloatType>
			boundaries compute_boundaries(FloatType value)
			{
				assert(std::isfinite(value));
				assert(value > 0);

				// Convert the IEEE representation into a diyfp.
				//
				// If v is denormal:
				//      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
				// If v is normalized:
				//      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))

				static_assert(std::numeric_limits<FloatType>::is_iec559,
					"internal error: dtoa_short requires an IEEE-754 floating-point implementation");

				constexpr int      kPrecision = std::numeric_limits<FloatType>::digits; // = p (includes the hidden bit)
				constexpr int      kBias = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
				constexpr int      kMinExp = 1 - kBias;
				constexpr uint64_t kHiddenBit = uint64_t{ 1 } << (kPrecision - 1); // = 2^(p-1)

				using bits_type = typename std::conditional< kPrecision == 24, uint32_t, uint64_t >::type;

				const uint64_t bits = reinterpret_bits<bits_type>(value);
				const uint64_t E = bits >> (kPrecision - 1);
				const uint64_t F = bits & (kHiddenBit - 1);

				const bool is_denormal = (E == 0);
				const diyfp v = is_denormal
					? diyfp(F, kMinExp)
					: diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);

				// Compute the boundaries m- and m+ of the floating-point value
				// v = f * 2^e.
				//
				// Determine v- and v+, the floating-point predecessor and successor if v,
				// respectively.
				//
				//      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
				//         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)
				//
				//      v+ = v + 2^e
				//
				// Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_
				// between m- and m+ round to v, regardless of how the input rounding
				// algorithm breaks ties.
				//
				//      ---+-------------+-------------+-------------+-------------+---  (A)
				//         v-            m-            v             m+            v+
				//
				//      -----------------+------+------+-------------+-------------+---  (B)
				//                       v-     m-     v             m+            v+

				const bool lower_boundary_is_closer = (F == 0 and E > 1);
				const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
				const diyfp m_minus = lower_boundary_is_closer
					? diyfp(4 * v.f - 1, v.e - 2)  // (B)
					: diyfp(2 * v.f - 1, v.e - 1); // (A)

// Determine the normalized w+ = m+.
				const diyfp w_plus = diyfp::normalize(m_plus);

				// Determine w- = m- such that e_(w-) = e_(w+).
				const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);

				return { diyfp::normalize(v), w_minus, w_plus };
			}

			// Given normalized diyfp w, Grisu needs to find a (normalized) cached
			// power-of-ten c, such that the exponent of the product c * w = f * 2^e lies
			// within a certain range [alpha, gamma] (Definition 3.2 from [1])
			//
			//      alpha <= e = e_c + e_w + q <= gamma
			//
			// or
			//
			//      f_c * f_w * 2^alpha <= f_c 2^(e_c) * f_w 2^(e_w) * 2^q
			//                          <= f_c * f_w * 2^gamma
			//
			// Since c and w are normalized, i.e. 2^(q-1) <= f < 2^q, this implies
			//
			//      2^(q-1) * 2^(q-1) * 2^alpha <= c * w * 2^q < 2^q * 2^q * 2^gamma
			//
			// or
			//
			//      2^(q - 2 + alpha) <= c * w < 2^(q + gamma)
			//
			// The choice of (alpha,gamma) determines the size of the table and the form of
			// the digit generation procedure. Using (alpha,gamma)=(-60,-32) works out well
			// in practice:
			//
			// The idea is to cut the number c * w = f * 2^e into two parts, which can be
			// processed independently: An integral part p1, and a fractional part p2:
			//
			//      f * 2^e = ( (f div 2^-e) * 2^-e + (f mod 2^-e) ) * 2^e
			//              = (f div 2^-e) + (f mod 2^-e) * 2^e
			//              = p1 + p2 * 2^e
			//
			// The conversion of p1 into decimal form requires a series of divisions and
			// modulos by (a power of) 10. These operations are faster for 32-bit than for
			// 64-bit integers, so p1 should ideally fit into a 32-bit integer. This can be
			// achieved by choosing
			//
			//      -e >= 32   or   e <= -32 := gamma
			//
			// In order to convert the fractional part
			//
			//      p2 * 2^e = p2 / 2^-e = d[-1] / 10^1 + d[-2] / 10^2 + ...
			//
			// into decimal form, the fraction is repeatedly multiplied by 10 and the digits
			// d[-i] are extracted in order:
			//
			//      (10 * p2) div 2^-e = d[-1]
			//      (10 * p2) mod 2^-e = d[-2] / 10^1 + ...
			//
			// The multiplication by 10 must not overflow. It is sufficient to choose
			//
			//      10 * p2 < 16 * p2 = 2^4 * p2 <= 2^64.
			//
			// Since p2 = f mod 2^-e < 2^-e,
			//
			//      -e <= 60   or   e >= -60 := alpha

			constexpr int kAlpha = -60;
			constexpr int kGamma = -32;

			struct cached_power // c = f * 2^e ~= 10^k
			{
				uint64_t f;
				int e;
				int k;
			};

			/*!
			For a normalized diyfp w = f * 2^e, this function returns a (normalized) cached
			power-of-ten c = f_c * 2^e_c, such that the exponent of the product w * c
			satisfies (Definition 3.2 from [1])

				 alpha <= e_c + e + q <= gamma.
			*/
			inline cached_power get_cached_power_for_binary_exponent(int e)
			{
				// Now
				//
				//      alpha <= e_c + e + q <= gamma                                    (1)
				//      ==> f_c * 2^alpha <= c * 2^e * 2^q
				//
				// and since the c's are normalized, 2^(q-1) <= f_c,
				//
				//      ==> 2^(q - 1 + alpha) <= c * 2^(e + q)
				//      ==> 2^(alpha - e - 1) <= c
				//
				// If c were an exakt power of ten, i.e. c = 10^k, one may determine k as
				//
				//      k = ceil( log_10( 2^(alpha - e - 1) ) )
				//        = ceil( (alpha - e - 1) * log_10(2) )
				//
				// From the paper:
				// "In theory the result of the procedure could be wrong since c is rounded,
				//  and the computation itself is approximated [...]. In practice, however,
				//  this simple function is sufficient."
				//
				// For IEEE double precision floating-point numbers converted into
				// normalized diyfp's w = f * 2^e, with q = 64,
				//
				//      e >= -1022      (min IEEE exponent)
				//           -52        (p - 1)
				//           -52        (p - 1, possibly normalize denormal IEEE numbers)
				//           -11        (normalize the diyfp)
				//         = -1137
				//
				// and
				//
				//      e <= +1023      (max IEEE exponent)
				//           -52        (p - 1)
				//           -11        (normalize the diyfp)
				//         = 960
				//
				// This binary exponent range [-1137,960] results in a decimal exponent
				// range [-307,324]. One does not need to store a cached power for each
				// k in this range. For each such k it suffices to find a cached power
				// such that the exponent of the product lies in [alpha,gamma].
				// This implies that the difference of the decimal exponents of adjacent
				// table entries must be less than or equal to
				//
				//      floor( (gamma - alpha) * log_10(2) ) = 8.
				//
				// (A smaller distance gamma-alpha would require a larger table.)

				// NB:
				// Actually this function returns c, such that -60 <= e_c + e + 64 <= -34.

				constexpr int kCachedPowersSize = 79;
				constexpr int kCachedPowersMinDecExp = -300;
				constexpr int kCachedPowersDecStep = 8;

				static constexpr cached_power kCachedPowers[] =
				{
					{ 0xAB70FE17C79AC6CA, -1060, -300 },
					{ 0xFF77B1FCBEBCDC4F, -1034, -292 },
					{ 0xBE5691EF416BD60C, -1007, -284 },
					{ 0x8DD01FAD907FFC3C,  -980, -276 },
					{ 0xD3515C2831559A83,  -954, -268 },
					{ 0x9D71AC8FADA6C9B5,  -927, -260 },
					{ 0xEA9C227723EE8BCB,  -901, -252 },
					{ 0xAECC49914078536D,  -874, -244 },
					{ 0x823C12795DB6CE57,  -847, -236 },
					{ 0xC21094364DFB5637,  -821, -228 },
					{ 0x9096EA6F3848984F,  -794, -220 },
					{ 0xD77485CB25823AC7,  -768, -212 },
					{ 0xA086CFCD97BF97F4,  -741, -204 },
					{ 0xEF340A98172AACE5,  -715, -196 },
					{ 0xB23867FB2A35B28E,  -688, -188 },
					{ 0x84C8D4DFD2C63F3B,  -661, -180 },
					{ 0xC5DD44271AD3CDBA,  -635, -172 },
					{ 0x936B9FCEBB25C996,  -608, -164 },
					{ 0xDBAC6C247D62A584,  -582, -156 },
					{ 0xA3AB66580D5FDAF6,  -555, -148 },
					{ 0xF3E2F893DEC3F126,  -529, -140 },
					{ 0xB5B5ADA8AAFF80B8,  -502, -132 },
					{ 0x87625F056C7C4A8B,  -475, -124 },
					{ 0xC9BCFF6034C13053,  -449, -116 },
					{ 0x964E858C91BA2655,  -422, -108 },
					{ 0xDFF9772470297EBD,  -396, -100 },
					{ 0xA6DFBD9FB8E5B88F,  -369,  -92 },
					{ 0xF8A95FCF88747D94,  -343,  -84 },
					{ 0xB94470938FA89BCF,  -316,  -76 },
					{ 0x8A08F0F8BF0F156B,  -289,  -68 },
					{ 0xCDB02555653131B6,  -263,  -60 },
					{ 0x993FE2C6D07B7FAC,  -236,  -52 },
					{ 0xE45C10C42A2B3B06,  -210,  -44 },
					{ 0xAA242499697392D3,  -183,  -36 },
					{ 0xFD87B5F28300CA0E,  -157,  -28 },
					{ 0xBCE5086492111AEB,  -130,  -20 },
					{ 0x8CBCCC096F5088CC,  -103,  -12 },
					{ 0xD1B71758E219652C,   -77,   -4 },
					{ 0x9C40000000000000,   -50,    4 },
					{ 0xE8D4A51000000000,   -24,   12 },
					{ 0xAD78EBC5AC620000,     3,   20 },
					{ 0x813F3978F8940984,    30,   28 },
					{ 0xC097CE7BC90715B3,    56,   36 },
					{ 0x8F7E32CE7BEA5C70,    83,   44 },
					{ 0xD5D238A4ABE98068,   109,   52 },
					{ 0x9F4F2726179A2245,   136,   60 },
					{ 0xED63A231D4C4FB27,   162,   68 },
					{ 0xB0DE65388CC8ADA8,   189,   76 },
					{ 0x83C7088E1AAB65DB,   216,   84 },
					{ 0xC45D1DF942711D9A,   242,   92 },
					{ 0x924D692CA61BE758,   269,  100 },
					{ 0xDA01EE641A708DEA,   295,  108 },
					{ 0xA26DA3999AEF774A,   322,  116 },
					{ 0xF209787BB47D6B85,   348,  124 },
					{ 0xB454E4A179DD1877,   375,  132 },
					{ 0x865B86925B9BC5C2,   402,  140 },
					{ 0xC83553C5C8965D3D,   428,  148 },
					{ 0x952AB45CFA97A0B3,   455,  156 },
					{ 0xDE469FBD99A05FE3,   481,  164 },
					{ 0xA59BC234DB398C25,   508,  172 },
					{ 0xF6C69A72A3989F5C,   534,  180 },
					{ 0xB7DCBF5354E9BECE,   561,  188 },
					{ 0x88FCF317F22241E2,   588,  196 },
					{ 0xCC20CE9BD35C78A5,   614,  204 },
					{ 0x98165AF37B2153DF,   641,  212 },
					{ 0xE2A0B5DC971F303A,   667,  220 },
					{ 0xA8D9D1535CE3B396,   694,  228 },
					{ 0xFB9B7CD9A4A7443C,   720,  236 },
					{ 0xBB764C4CA7A44410,   747,  244 },
					{ 0x8BAB8EEFB6409C1A,   774,  252 },
					{ 0xD01FEF10A657842C,   800,  260 },
					{ 0x9B10A4E5E9913129,   827,  268 },
					{ 0xE7109BFBA19C0C9D,   853,  276 },
					{ 0xAC2820D9623BF429,   880,  284 },
					{ 0x80444B5E7AA7CF85,   907,  292 },
					{ 0xBF21E44003ACDD2D,   933,  300 },
					{ 0x8E679C2F5E44FF8F,   960,  308 },
					{ 0xD433179D9C8CB841,   986,  316 },
					{ 0x9E19DB92B4E31BA9,  1013,  324 },
				};

				// This computation gives exactly the same results for k as
				//      k = ceil((kAlpha - e - 1) * 0.30102999566398114)
				// for |e| <= 1500, but doesn't require floating-point operations.
				// NB: log_10(2) ~= 78913 / 2^18
				assert(e >= -1500);
				assert(e <= 1500);
				const int f = kAlpha - e - 1;
				const int k = (f * 78913) / (1 << 18) + (f > 0);

				const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
				assert(index >= 0);
				assert(index < kCachedPowersSize);
				static_cast<void>(kCachedPowersSize); // Fix warning.

				const cached_power cached = kCachedPowers[index];
				assert(kAlpha <= cached.e + e + 64);
				assert(kGamma >= cached.e + e + 64);

				return cached;
			}

			/*!
			For n != 0, returns k, such that pow10 := 10^(k-1) <= n < 10^k.
			For n == 0, returns 1 and sets pow10 := 1.
			*/
			inline int find_largest_pow10(const uint32_t n, uint32_t& pow10)
			{
				// LCOV_EXCL_START
				if (n >= 1000000000)
				{
					pow10 = 1000000000;
					return 10;
				}
				// LCOV_EXCL_STOP
				else if (n >= 100000000)
				{
					pow10 = 100000000;
					return  9;
				}
				else if (n >= 10000000)
				{
					pow10 = 10000000;
					return  8;
				}
				else if (n >= 1000000)
				{
					pow10 = 1000000;
					return  7;
				}
				else if (n >= 100000)
				{
					pow10 = 100000;
					return  6;
				}
				else if (n >= 10000)
				{
					pow10 = 10000;
					return  5;
				}
				else if (n >= 1000)
				{
					pow10 = 1000;
					return  4;
				}
				else if (n >= 100)
				{
					pow10 = 100;
					return  3;
				}
				else if (n >= 10)
				{
					pow10 = 10;
					return  2;
				}
				else
				{
					pow10 = 1;
					return 1;
				}
			}

			inline void grisu2_round(char* buf, int len, uint64_t dist, uint64_t delta,
				uint64_t rest, uint64_t ten_k)
			{
				assert(len >= 1);
				assert(dist <= delta);
				assert(rest <= delta);
				assert(ten_k > 0);

				//               <--------------------------- delta ---->
				//                                  <---- dist --------->
				// --------------[------------------+-------------------]--------------
				//               M-                 w                   M+
				//
				//                                  ten_k
				//                                <------>
				//                                       <---- rest ---->
				// --------------[------------------+----+--------------]--------------
				//                                  w    V
				//                                       = buf * 10^k
				//
				// ten_k represents a unit-in-the-last-place in the decimal representation
				// stored in buf.
				// Decrement buf by ten_k while this takes buf closer to w.

				// The tests are written in this order to avoid overflow in unsigned
				// integer arithmetic.

				while (rest < dist
					and delta - rest >= ten_k
					and (rest + ten_k < dist or dist - rest > rest + ten_k - dist))
				{
					assert(buf[len - 1] != '0');
					buf[len - 1]--;
					rest += ten_k;
				}
			}

			/*!
			Generates V = buffer * 10^decimal_exponent, such that M- <= V <= M+.
			M- and M+ must be normalized and share the same exponent -60 <= e <= -32.
			*/
			inline void grisu2_digit_gen(char* buffer, int& length, int& decimal_exponent,
				diyfp M_minus, diyfp w, diyfp M_plus)
			{
				static_assert(kAlpha >= -60, "internal error");
				static_assert(kGamma <= -32, "internal error");

				// Generates the digits (and the exponent) of a decimal floating-point
				// number V = buffer * 10^decimal_exponent in the range [M-, M+]. The diyfp's
				// w, M- and M+ share the same exponent e, which satisfies alpha <= e <= gamma.
				//
				//               <--------------------------- delta ---->
				//                                  <---- dist --------->
				// --------------[------------------+-------------------]--------------
				//               M-                 w                   M+
				//
				// Grisu2 generates the digits of M+ from left to right and stops as soon as
				// V is in [M-,M+].

				assert(M_plus.e >= kAlpha);
				assert(M_plus.e <= kGamma);

				uint64_t delta = diyfp::sub(M_plus, M_minus).f; // (significand of (M+ - M-), implicit exponent is e)
				uint64_t dist = diyfp::sub(M_plus, w).f; // (significand of (M+ - w ), implicit exponent is e)

				// Split M+ = f * 2^e into two parts p1 and p2 (note: e < 0):
				//
				//      M+ = f * 2^e
				//         = ((f div 2^-e) * 2^-e + (f mod 2^-e)) * 2^e
				//         = ((p1        ) * 2^-e + (p2        )) * 2^e
				//         = p1 + p2 * 2^e

				const diyfp one(uint64_t{ 1 } << -M_plus.e, M_plus.e);

				uint32_t p1 = static_cast<uint32_t>(M_plus.f >> -one.e); // p1 = f div 2^-e (Since -e >= 32, p1 fits into a 32-bit int.)
				uint64_t p2 = M_plus.f & (one.f - 1);                    // p2 = f mod 2^-e

				// 1)
				//
				// Generate the digits of the integral part p1 = d[n-1]...d[1]d[0]

				assert(p1 > 0);

				uint32_t pow10;
				const int k = find_largest_pow10(p1, pow10);

				//      10^(k-1) <= p1 < 10^k, pow10 = 10^(k-1)
				//
				//      p1 = (p1 div 10^(k-1)) * 10^(k-1) + (p1 mod 10^(k-1))
				//         = (d[k-1]         ) * 10^(k-1) + (p1 mod 10^(k-1))
				//
				//      M+ = p1                                             + p2 * 2^e
				//         = d[k-1] * 10^(k-1) + (p1 mod 10^(k-1))          + p2 * 2^e
				//         = d[k-1] * 10^(k-1) + ((p1 mod 10^(k-1)) * 2^-e + p2) * 2^e
				//         = d[k-1] * 10^(k-1) + (                         rest) * 2^e
				//
				// Now generate the digits d[n] of p1 from left to right (n = k-1,...,0)
				//
				//      p1 = d[k-1]...d[n] * 10^n + d[n-1]...d[0]
				//
				// but stop as soon as
				//
				//      rest * 2^e = (d[n-1]...d[0] * 2^-e + p2) * 2^e <= delta * 2^e

				int n = k;
				while (n > 0)
				{
					// Invariants:
					//      M+ = buffer * 10^n + (p1 + p2 * 2^e)    (buffer = 0 for n = k)
					//      pow10 = 10^(n-1) <= p1 < 10^n
					//
					const uint32_t d = p1 / pow10;  // d = p1 div 10^(n-1)
					const uint32_t r = p1 % pow10;  // r = p1 mod 10^(n-1)
					//
					//      M+ = buffer * 10^n + (d * 10^(n-1) + r) + p2 * 2^e
					//         = (buffer * 10 + d) * 10^(n-1) + (r + p2 * 2^e)
					//
					assert(d <= 9);
					buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
					//
					//      M+ = buffer * 10^(n-1) + (r + p2 * 2^e)
					//
					p1 = r;
					n--;
					//
					//      M+ = buffer * 10^n + (p1 + p2 * 2^e)
					//      pow10 = 10^n
					//

					// Now check if enough digits have been generated.
					// Compute
					//
					//      p1 + p2 * 2^e = (p1 * 2^-e + p2) * 2^e = rest * 2^e
					//
					// Note:
					// Since rest and delta share the same exponent e, it suffices to
					// compare the significands.
					const uint64_t rest = (uint64_t{ p1 } << -one.e) + p2;
					if (rest <= delta)
					{
						// V = buffer * 10^n, with M- <= V <= M+.

						decimal_exponent += n;

						// We may now just stop. But instead look if the buffer could be
						// decremented to bring V closer to w.
						//
						// pow10 = 10^n is now 1 ulp in the decimal representation V.
						// The rounding procedure works with diyfp's with an implicit
						// exponent of e.
						//
						//      10^n = (10^n * 2^-e) * 2^e = ulp * 2^e
						//
						const uint64_t ten_n = uint64_t{ pow10 } << -one.e;
						grisu2_round(buffer, length, dist, delta, rest, ten_n);

						return;
					}

					pow10 /= 10;
					//
					//      pow10 = 10^(n-1) <= p1 < 10^n
					// Invariants restored.
				}

				// 2)
				//
				// The digits of the integral part have been generated:
				//
				//      M+ = d[k-1]...d[1]d[0] + p2 * 2^e
				//         = buffer            + p2 * 2^e
				//
				// Now generate the digits of the fractional part p2 * 2^e.
				//
				// Note:
				// No decimal point is generated: the exponent is adjusted instead.
				//
				// p2 actually represents the fraction
				//
				//      p2 * 2^e
				//          = p2 / 2^-e
				//          = d[-1] / 10^1 + d[-2] / 10^2 + ...
				//
				// Now generate the digits d[-m] of p1 from left to right (m = 1,2,...)
				//
				//      p2 * 2^e = d[-1]d[-2]...d[-m] * 10^-m
				//                      + 10^-m * (d[-m-1] / 10^1 + d[-m-2] / 10^2 + ...)
				//
				// using
				//
				//      10^m * p2 = ((10^m * p2) div 2^-e) * 2^-e + ((10^m * p2) mod 2^-e)
				//                = (                   d) * 2^-e + (                   r)
				//
				// or
				//      10^m * p2 * 2^e = d + r * 2^e
				//
				// i.e.
				//
				//      M+ = buffer + p2 * 2^e
				//         = buffer + 10^-m * (d + r * 2^e)
				//         = (buffer * 10^m + d) * 10^-m + 10^-m * r * 2^e
				//
				// and stop as soon as 10^-m * r * 2^e <= delta * 2^e

				assert(p2 > delta);

				int m = 0;
				for (;;)
				{
					// Invariant:
					//      M+ = buffer * 10^-m + 10^-m * (d[-m-1] / 10 + d[-m-2] / 10^2 + ...) * 2^e
					//         = buffer * 10^-m + 10^-m * (p2                                 ) * 2^e
					//         = buffer * 10^-m + 10^-m * (1/10 * (10 * p2)                   ) * 2^e
					//         = buffer * 10^-m + 10^-m * (1/10 * ((10*p2 div 2^-e) * 2^-e + (10*p2 mod 2^-e)) * 2^e
					//
					assert(p2 <= UINT64_MAX / 10);
					p2 *= 10;
					const uint64_t d = p2 >> -one.e;     // d = (10 * p2) div 2^-e
					const uint64_t r = p2 & (one.f - 1); // r = (10 * p2) mod 2^-e
					//
					//      M+ = buffer * 10^-m + 10^-m * (1/10 * (d * 2^-e + r) * 2^e
					//         = buffer * 10^-m + 10^-m * (1/10 * (d + r * 2^e))
					//         = (buffer * 10 + d) * 10^(-m-1) + 10^(-m-1) * r * 2^e
					//
					assert(d <= 9);
					buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
					//
					//      M+ = buffer * 10^(-m-1) + 10^(-m-1) * r * 2^e
					//
					p2 = r;
					m++;
					//
					//      M+ = buffer * 10^-m + 10^-m * p2 * 2^e
					// Invariant restored.

					// Check if enough digits have been generated.
					//
					//      10^-m * p2 * 2^e <= delta * 2^e
					//              p2 * 2^e <= 10^m * delta * 2^e
					//                    p2 <= 10^m * delta
					delta *= 10;
					dist *= 10;
					if (p2 <= delta)
					{
						break;
					}
				}

				// V = buffer * 10^-m, with M- <= V <= M+.

				decimal_exponent -= m;

				// 1 ulp in the decimal representation is now 10^-m.
				// Since delta and dist are now scaled by 10^m, we need to do the
				// same with ulp in order to keep the units in sync.
				//
				//      10^m * 10^-m = 1 = 2^-e * 2^e = ten_m * 2^e
				//
				const uint64_t ten_m = one.f;
				grisu2_round(buffer, length, dist, delta, p2, ten_m);

				// By construction this algorithm generates the shortest possible decimal
				// number (Loitsch, Theorem 6.2) which rounds back to w.
				// For an input number of precision p, at least
				//
				//      N = 1 + ceil(p * log_10(2))
				//
				// decimal digits are sufficient to identify all binary floating-point
				// numbers (Matula, "In-and-Out conversions").
				// This implies that the algorithm does not produce more than N decimal
				// digits.
				//
				//      N = 17 for p = 53 (IEEE double precision)
				//      N = 9  for p = 24 (IEEE single precision)
			}

			/*!
			v = buf * 10^decimal_exponent
			len is the length of the buffer (number of decimal digits)
			The buffer must be large enough, i.e. >= max_digits10.
			*/
			inline void grisu2(char* buf, int& len, int& decimal_exponent,
				diyfp m_minus, diyfp v, diyfp m_plus)
			{
				assert(m_plus.e == m_minus.e);
				assert(m_plus.e == v.e);

				//  --------(-----------------------+-----------------------)--------    (A)
				//          m-                      v                       m+
				//
				//  --------------------(-----------+-----------------------)--------    (B)
				//                      m-          v                       m+
				//
				// First scale v (and m- and m+) such that the exponent is in the range
				// [alpha, gamma].

				const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);

				const diyfp c_minus_k(cached.f, cached.e); // = c ~= 10^-k

				// The exponent of the products is = v.e + c_minus_k.e + q and is in the range [alpha,gamma]
				const diyfp w = diyfp::mul(v, c_minus_k);
				const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
				const diyfp w_plus = diyfp::mul(m_plus, c_minus_k);

				//  ----(---+---)---------------(---+---)---------------(---+---)----
				//          w-                      w                       w+
				//          = c*m-                  = c*v                   = c*m+
				//
				// diyfp::mul rounds its result and c_minus_k is approximated too. w, w- and
				// w+ are now off by a small amount.
				// In fact:
				//
				//      w - v * 10^k < 1 ulp
				//
				// To account for this inaccuracy, add resp. subtract 1 ulp.
				//
				//  --------+---[---------------(---+---)---------------]---+--------
				//          w-  M-                  w                   M+  w+
				//
				// Now any number in [M-, M+] (bounds included) will round to w when input,
				// regardless of how the input rounding algorithm breaks ties.
				//
				// And digit_gen generates the shortest possible such number in [M-, M+].
				// Note that this does not mean that Grisu2 always generates the shortest
				// possible number in the interval (m-, m+).
				const diyfp M_minus(w_minus.f + 1, w_minus.e);
				const diyfp M_plus(w_plus.f - 1, w_plus.e);

				decimal_exponent = -cached.k; // = -(-k) = k

				grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
			}

			/*!
			v = buf * 10^decimal_exponent
			len is the length of the buffer (number of decimal digits)
			The buffer must be large enough, i.e. >= max_digits10.
			*/
			template <typename FloatType>
			void grisu2(char* buf, int& len, int& decimal_exponent, FloatType value)
			{
				static_assert(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,
					"internal error: not enough precision");

				assert(std::isfinite(value));
				assert(value > 0);

				// If the neighbors (and boundaries) of 'value' are always computed for double-precision
				// numbers, all float's can be recovered using strtod (and strtof). However, the resulting
				// decimal representations are not exactly "short".
				//
				// The documentation for 'std::to_chars' (https://en.cppreference.com/w/cpp/utility/to_chars)
				// says "value is converted to a string as if by std::sprintf in the default ("C") locale"
				// and since sprintf promotes float's to double's, I think this is exactly what 'std::to_chars'
				// does.
				// On the other hand, the documentation for 'std::to_chars' requires that "parsing the
				// representation using the corresponding std::from_chars function recovers value exactly". That
				// indicates that single precision floating-point numbers should be recovered using
				// 'std::strtof'.
				//
				// NB: If the neighbors are computed for single-precision numbers, there is a single float
				//     (7.0385307e-26f) which can't be recovered using strtod. The resulting double precision
				//     value is off by 1 ulp.
#if 0
				const boundaries w = compute_boundaries(static_cast<double>(value));
#else
				const boundaries w = compute_boundaries(value);
#endif

				grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
			}

			/*!
			@brief appends a decimal representation of e to buf
			@return a pointer to the element following the exponent.
			@pre -1000 < e < 1000
			*/
			inline char* append_exponent(char* buf, int e)
			{
				assert(e > -1000);
				assert(e < 1000);

				if (e < 0)
				{
					e = -e;
					*buf++ = '-';
				}
				else
				{
					*buf++ = '+';
				}

				uint32_t k = static_cast<uint32_t>(e);
				if (k < 10)
				{
					// Always print at least two digits in the exponent.
					// This is for compatibility with printf("%g").
					*buf++ = '0';
					*buf++ = static_cast<char>('0' + k);
				}
				else if (k < 100)
				{
					*buf++ = static_cast<char>('0' + k / 10);
					k %= 10;
					*buf++ = static_cast<char>('0' + k);
				}
				else
				{
					*buf++ = static_cast<char>('0' + k / 100);
					k %= 100;
					*buf++ = static_cast<char>('0' + k / 10);
					k %= 10;
					*buf++ = static_cast<char>('0' + k);
				}

				return buf;
			}

			/*!
			@brief prettify v = buf * 10^decimal_exponent

			If v is in the range [10^min_exp, 10^max_exp) it will be printed in fixed-point
			notation. Otherwise it will be printed in exponential notation.

			@pre min_exp < 0
			@pre max_exp > 0
			*/
			inline char* format_buffer(char* buf, int len, int decimal_exponent,
				int min_exp, int max_exp)
			{
				assert(min_exp < 0);
				assert(max_exp > 0);

				const int k = len;
				const int n = len + decimal_exponent;

				// v = buf * 10^(n-k)
				// k is the length of the buffer (number of decimal digits)
				// n is the position of the decimal point relative to the start of the buffer.

				if (k <= n and n <= max_exp)
				{
					// digits[000]
					// len <= max_exp + 2

					std::memset(buf + k, '0', static_cast<size_t>(n - k));
					// Make it look like a floating-point number (#362, #378)
					buf[n + 0] = '.';
					buf[n + 1] = '0';
					return buf + (n + 2);
				}

				if (0 < n and n <= max_exp)
				{
					// dig.its
					// len <= max_digits10 + 1

					assert(k > n);

					std::memmove(buf + (n + 1), buf + n, static_cast<size_t>(k - n));
					buf[n] = '.';
					return buf + (k + 1);
				}

				if (min_exp < n and n <= 0)
				{
					// 0.[000]digits
					// len <= 2 + (-min_exp - 1) + max_digits10

					std::memmove(buf + (2 + -n), buf, static_cast<size_t>(k));
					buf[0] = '0';
					buf[1] = '.';
					std::memset(buf + 2, '0', static_cast<size_t>(-n));
					return buf + (2 + (-n) + k);
				}

				if (k == 1)
				{
					// dE+123
					// len <= 1 + 5

					buf += 1;
				}
				else
				{
					// d.igitsE+123
					// len <= max_digits10 + 1 + 5

					std::memmove(buf + 2, buf + 1, static_cast<size_t>(k - 1));
					buf[1] = '.';
					buf += 1 + k;
				}

				*buf++ = 'e';
				return append_exponent(buf, n - 1);
			}

		} // namespace dtoa_impl

		/*!
		@brief generates a decimal representation of the floating-point number value in [first, last).

		The format of the resulting decimal representation is similar to printf's %g
		format. Returns an iterator pointing past-the-end of the decimal representation.

		@note The input number must be finite, i.e. NaN's and Inf's are not supported.
		@note The buffer must be large enough.
		@note The result is NOT null-terminated.
		*/
		template <typename FloatType>
		char* to_chars(char* first, char* last, FloatType value)
		{
			static_cast<void>(last); // maybe unused - fix warning
			assert(std::isfinite(value));

			// Use signbit(value) instead of (value < 0) since signbit works for -0.
			if (std::signbit(value))
			{
				value = -value;
				*first++ = '-';
			}

			if (value == 0) // +-0
			{
				*first++ = '0';
				// Make it look like a floating-point number (#362, #378)
				*first++ = '.';
				*first++ = '0';
				return first;
			}

			assert(last - first >= std::numeric_limits<FloatType>::max_digits10);

			// Compute v = buffer * 10^decimal_exponent.
			// The decimal digits are stored in the buffer, which needs to be interpreted
			// as an unsigned decimal integer.
			// len is the length of the buffer, i.e. the number of decimal digits.
			int len = 0;
			int decimal_exponent = 0;
			dtoa_impl::grisu2(first, len, decimal_exponent, value);

			assert(len <= std::numeric_limits<FloatType>::max_digits10);

			// Format the buffer like printf("%.*g", prec, value)
			constexpr int kMinExp = -4;
			// Use digits10 here to increase compatibility with version 2.
			constexpr int kMaxExp = std::numeric_limits<FloatType>::digits10;

			assert(last - first >= kMaxExp + 2);
			assert(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
			assert(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);

			return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
		}

	} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		///////////////////
		// serialization //
		///////////////////

		template<typename BasicJsonType>
		class serializer
		{
			using string_t = typename BasicJsonType::string_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			static constexpr uint8_t UTF8_ACCEPT = 0;
			static constexpr uint8_t UTF8_REJECT = 1;

		public:
			/*!
			@param[in] s  output stream to serialize to
			@param[in] ichar  indentation character to use
			*/
			serializer(output_adapter_t<char> s, const char ichar)
				: o(std::move(s)), loc(std::localeconv()),
				thousands_sep(loc->thousands_sep == nullptr ? '\0' : *(loc->thousands_sep)),
				decimal_point(loc->decimal_point == nullptr ? '\0' : *(loc->decimal_point)),
				indent_char(ichar), indent_string(512, indent_char)
			{}

			// delete because of pointer members
			serializer(const serializer&) = delete;
			serializer& operator=(const serializer&) = delete;

			/*!
			@brief internal implementation of the serialization function

			This function is called by the public member function dump and organizes
			the serialization internally. The indentation level is propagated as
			additional parameter. In case of arrays and objects, the function is
			called recursively.

			- strings and object keys are escaped using `escape_string()`
			- integer numbers are converted implicitly via `operator<<`
			- floating-point numbers are converted to a string using `"%g"` format

			@param[in] val             value to serialize
			@param[in] pretty_print    whether the output shall be pretty-printed
			@param[in] indent_step     the indent level
			@param[in] current_indent  the current indent level (only used internally)
			*/
			void dump(const BasicJsonType& val, const bool pretty_print,
				const bool ensure_ascii,
				const unsigned int indent_step,
				const unsigned int current_indent = 0)
			{
				switch (val.m_type)
				{
				case value_t::object:
				{
					if (val.m_value.object->empty())
					{
						o->write_characters("{}", 2);
						return;
					}

					if (pretty_print)
					{
						o->write_characters("{\n", 2);

						// variable to hold indentation for recursive calls
						const auto new_indent = current_indent + indent_step;
						if (JSON_UNLIKELY(indent_string.size() < new_indent))
						{
							indent_string.resize(indent_string.size() * 2, ' ');
						}

						// first n-1 elements
						auto i = val.m_value.object->cbegin();
						for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
						{
							o->write_characters(indent_string.c_str(), new_indent);
							o->write_character('\"');
							dump_escaped(i->first, ensure_ascii);
							o->write_characters("\": ", 3);
							dump(i->second, true, ensure_ascii, indent_step, new_indent);
							o->write_characters(",\n", 2);
						}

						// last element
						assert(i != val.m_value.object->cend());
						assert(std::next(i) == val.m_value.object->cend());
						o->write_characters(indent_string.c_str(), new_indent);
						o->write_character('\"');
						dump_escaped(i->first, ensure_ascii);
						o->write_characters("\": ", 3);
						dump(i->second, true, ensure_ascii, indent_step, new_indent);

						o->write_character('\n');
						o->write_characters(indent_string.c_str(), current_indent);
						o->write_character('}');
					}
					else
					{
						o->write_character('{');

						// first n-1 elements
						auto i = val.m_value.object->cbegin();
						for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
						{
							o->write_character('\"');
							dump_escaped(i->first, ensure_ascii);
							o->write_characters("\":", 2);
							dump(i->second, false, ensure_ascii, indent_step, current_indent);
							o->write_character(',');
						}

						// last element
						assert(i != val.m_value.object->cend());
						assert(std::next(i) == val.m_value.object->cend());
						o->write_character('\"');
						dump_escaped(i->first, ensure_ascii);
						o->write_characters("\":", 2);
						dump(i->second, false, ensure_ascii, indent_step, current_indent);

						o->write_character('}');
					}

					return;
				}

				case value_t::array:
				{
					if (val.m_value.array->empty())
					{
						o->write_characters("[]", 2);
						return;
					}

					if (pretty_print)
					{
						o->write_characters("[\n", 2);

						// variable to hold indentation for recursive calls
						const auto new_indent = current_indent + indent_step;
						if (JSON_UNLIKELY(indent_string.size() < new_indent))
						{
							indent_string.resize(indent_string.size() * 2, ' ');
						}

						// first n-1 elements
						for (auto i = val.m_value.array->cbegin();
							i != val.m_value.array->cend() - 1; ++i)
						{
							o->write_characters(indent_string.c_str(), new_indent);
							dump(*i, true, ensure_ascii, indent_step, new_indent);
							o->write_characters(",\n", 2);
						}

						// last element
						assert(not val.m_value.array->empty());
						o->write_characters(indent_string.c_str(), new_indent);
						dump(val.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);

						o->write_character('\n');
						o->write_characters(indent_string.c_str(), current_indent);
						o->write_character(']');
					}
					else
					{
						o->write_character('[');

						// first n-1 elements
						for (auto i = val.m_value.array->cbegin();
							i != val.m_value.array->cend() - 1; ++i)
						{
							dump(*i, false, ensure_ascii, indent_step, current_indent);
							o->write_character(',');
						}

						// last element
						assert(not val.m_value.array->empty());
						dump(val.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);

						o->write_character(']');
					}

					return;
				}

				case value_t::string:
				{
					o->write_character('\"');
					dump_escaped(*val.m_value.string, ensure_ascii);
					o->write_character('\"');
					return;
				}

				case value_t::boolean:
				{
					if (val.m_value.boolean)
					{
						o->write_characters("true", 4);
					}
					else
					{
						o->write_characters("false", 5);
					}
					return;
				}

				case value_t::number_integer:
				{
					dump_integer(val.m_value.number_integer);
					return;
				}

				case value_t::number_unsigned:
				{
					dump_integer(val.m_value.number_unsigned);
					return;
				}

				case value_t::number_float:
				{
					dump_float(val.m_value.number_float);
					return;
				}

				case value_t::discarded:
				{
					o->write_characters("<discarded>", 11);
					return;
				}

				case value_t::null:
				{
					o->write_characters("null", 4);
					return;
				}
				}
			}

		private:
			/*!
			@brief dump escaped string

			Escape a string by replacing certain special characters by a sequence of an
			escape character (backslash) and another character and other control
			characters by a sequence of "\u" followed by a four-digit hex
			representation. The escaped string is written to output stream @a o.

			@param[in] s  the string to escape
			@param[in] ensure_ascii  whether to escape non-ASCII characters with
									 \uXXXX sequences

			@complexity Linear in the length of string @a s.
			*/
			void dump_escaped(const string_t& s, const bool ensure_ascii)
			{
				uint32_t codepoint;
				uint8_t state = UTF8_ACCEPT;
				std::size_t bytes = 0;  // number of bytes written to string_buffer

				for (std::size_t i = 0; i < s.size(); ++i)
				{
					const auto byte = static_cast<uint8_t>(s[i]);

					switch (decode(state, codepoint, byte))
					{
					case UTF8_ACCEPT:  // decode found a new code point
					{
						switch (codepoint)
						{
						case 0x08: // backspace
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = 'b';
							break;
						}

						case 0x09: // SDKtal tab
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = 't';
							break;
						}

						case 0x0A: // newline
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = 'n';
							break;
						}

						case 0x0C: // formfeed
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = 'f';
							break;
						}

						case 0x0D: // carriage return
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = 'r';
							break;
						}

						case 0x22: // quotation mark
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = '\"';
							break;
						}

						case 0x5C: // reverse solidus
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = '\\';
							break;
						}

						default:
						{
							// escape control characters (0x00..0x1F) or, if
							// ensure_ascii parameter is used, non-ASCII characters
							if ((codepoint <= 0x1F) or (ensure_ascii and (codepoint >= 0x7F)))
							{
								if (codepoint <= 0xFFFF)
								{
									std::snprintf(string_buffer.data() + bytes, 7, "\\u%04x",
										static_cast<uint16_t>(codepoint));
									bytes += 6;
								}
								else
								{
									std::snprintf(string_buffer.data() + bytes, 13, "\\u%04x\\u%04x",
										static_cast<uint16_t>(0xD7C0 + (codepoint >> 10)),
										static_cast<uint16_t>(0xDC00 + (codepoint & 0x3FF)));
									bytes += 12;
								}
							}
							else
							{
								// copy byte to buffer (all previous bytes
								// been copied have in default case above)
								string_buffer[bytes++] = s[i];
							}
							break;
						}
						}

						// write buffer and reset index; there must be 13 bytes
						// left, as this is the maximal number of bytes to be
						// written ("\uxxxx\uxxxx\0") for one code point
						if (string_buffer.size() - bytes < 13)
						{
							o->write_characters(string_buffer.data(), bytes);
							bytes = 0;
						}
						break;
					}

					case UTF8_REJECT:  // decode found invalid UTF-8 byte
					{
						std::string sn(3, '\0');
						snprintf(&sn[0], sn.size(), "%.2X", byte);
						JSON_THROW(type_error::create(316, "invalid UTF-8 byte at index " + std::to_string(i) + ": 0x" + sn));
					}

					default:  // decode found yet incomplete multi-byte code point
					{
						if (not ensure_ascii)
						{
							// code point will not be escaped - copy byte to buffer
							string_buffer[bytes++] = s[i];
						}
						break;
					}
					}
				}

				if (JSON_LIKELY(state == UTF8_ACCEPT))
				{
					// write buffer
					if (bytes > 0)
					{
						o->write_characters(string_buffer.data(), bytes);
					}
				}
				else
				{
					// we finish reading, but do not accept: string was incomplete
					std::string sn(3, '\0');
					snprintf(&sn[0], sn.size(), "%.2X", static_cast<uint8_t>(s.back()));
					JSON_THROW(type_error::create(316, "incomplete UTF-8 string; last byte: 0x" + sn));
				}
			}

			/*!
			@brief dump an integer

			Dump a given integer to output stream @a o. Works internally with
			@a number_buffer.

			@param[in] x  integer number (signed or unsigned) to dump
			@tparam NumberType either @a number_integer_t or @a number_unsigned_t
			*/
			template<typename NumberType, detail::enable_if_t<
				std::is_same<NumberType, number_unsigned_t>::value or
				std::is_same<NumberType, number_integer_t>::value,
				int> = 0>
				void dump_integer(NumberType x)
			{
				// special case for "0"
				if (x == 0)
				{
					o->write_character('0');
					return;
				}

				const bool is_negative = not (x >= 0);  // see issue #755
				std::size_t i = 0;

				while (x != 0)
				{
					// spare 1 byte for '\0'
					assert(i < number_buffer.size() - 1);

					const auto digit = std::labs(static_cast<long>(x % 10));
					number_buffer[i++] = static_cast<char>('0' + digit);
					x /= 10;
				}

				if (is_negative)
				{
					// make sure there is capacity for the '-'
					assert(i < number_buffer.size() - 2);
					number_buffer[i++] = '-';
				}

				std::reverse(number_buffer.begin(), number_buffer.begin() + i);
				o->write_characters(number_buffer.data(), i);
			}

			/*!
			@brief dump a floating-point number

			Dump a given floating-point number to output stream @a o. Works internally
			with @a number_buffer.

			@param[in] x  floating-point number to dump
			*/
			void dump_float(number_float_t x)
			{
				// NaN / inf
				if (not std::isfinite(x))
				{
					o->write_characters("null", 4);
					return;
				}

				// If number_float_t is an IEEE-754 single or double precision number,
				// use the Grisu2 algorithm to produce short numbers which are
				// guaranteed to round-trip, using strtof and strtod, resp.
				//
				// NB: The test below works if <long double> == <double>.
				static constexpr bool is_ieee_single_or_double
					= (std::numeric_limits<number_float_t>::is_iec559 and std::numeric_limits<number_float_t>::digits == 24 and std::numeric_limits<number_float_t>::max_exponent == 128) or
					(std::numeric_limits<number_float_t>::is_iec559 and std::numeric_limits<number_float_t>::digits == 53 and std::numeric_limits<number_float_t>::max_exponent == 1024);

				dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());
			}

			void dump_float(number_float_t x, std::true_type /*is_ieee_single_or_double*/)
			{
				char* begin = number_buffer.data();
				char* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);

				o->write_characters(begin, static_cast<size_t>(end - begin));
			}

			void dump_float(number_float_t x, std::false_type /*is_ieee_single_or_double*/)
			{
				// get number of digits for a float -> text -> float round-trip
				static constexpr auto d = std::numeric_limits<number_float_t>::max_digits10;

				// the actual conversion
				std::ptrdiff_t len = snprintf(number_buffer.data(), number_buffer.size(), "%.*g", d, x);

				// negative value indicates an error
				assert(len > 0);
				// check if buffer was large enough
				assert(static_cast<std::size_t>(len) < number_buffer.size());

				// erase thousands separator
				if (thousands_sep != '\0')
				{
					const auto end = std::remove(number_buffer.begin(),
						number_buffer.begin() + len, thousands_sep);
					std::fill(end, number_buffer.end(), '\0');
					assert((end - number_buffer.begin()) <= len);
					len = (end - number_buffer.begin());
				}

				// convert decimal point to '.'
				if (decimal_point != '\0' and decimal_point != '.')
				{
					const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
					if (dec_pos != number_buffer.end())
					{
						*dec_pos = '.';
					}
				}

				o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));

				// determine if need to append ".0"
				const bool value_is_int_like =
					std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
						[](char c)
				{
					return (c == '.' or c == 'e');
				});

				if (value_is_int_like)
				{
					o->write_characters(".0", 2);
				}
			}

			/*!
			@brief check whether a string is UTF-8 encoded

			The function checks each byte of a string whether it is UTF-8 encoded. The
			result of the check is stored in the @a state parameter. The function must
			be called initially with state 0 (accept). State 1 means the string must
			be rejected, because the current byte is not allowed. If the string is
			completely processed, but the state is non-zero, the string ended
			prematurely; that is, the last byte indicated more bytes should have
			followed.

			@param[in,out] state  the state of the decoding
			@param[in,out] codep  codepoint (valid only if resulting state is UTF8_ACCEPT)
			@param[in] byte       next byte to decode
			@return               new state

			@note The function has been edited: a std::array is used.

			@copyright Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
			@sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
			*/
			static uint8_t decode(uint8_t& state, uint32_t& codep, const uint8_t byte) noexcept
			{
				static const std::array<uint8_t, 400> utf8d =
				{
					{
						0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1F
						0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3F
						0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5F
						0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7F
						1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9F
						7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // A0..BF
						8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // C0..DF
						0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // E0..EF
						0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // F0..FF
						0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0
						1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2
						1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4
						1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6
						1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s7..s8
					}
				};

				const uint8_t type = utf8d[byte];

				codep = (state != UTF8_ACCEPT)
					? (byte & 0x3fu) | (codep << 6)
					: static_cast<uint32_t>(0xff >> type) & (byte);

				state = utf8d[256u + state * 16u + type];
				return state;
			}

		private:
			/// the output of the serializer
			output_adapter_t<char> o = nullptr;

			/// a (hopefully) large enough character buffer
			std::array<char, 64> number_buffer{ {} };

			/// the locale
			const std::lconv* loc = nullptr;
			/// the locale's thousand separator character
			const char thousands_sep = '\0';
			/// the locale's decimal point character
			const char decimal_point = '\0';

			/// string buffer
			std::array<char, 512> string_buffer{ {} };

			/// the indentation character
			const char indent_char;
			/// the indentation string
			string_t indent_string;
		};
	}
}

// #include <nlohmann/detail/json_ref.hpp>


#include <initializer_list>
#include <utility>

namespace nlohmann
{
	namespace detail
	{
		template<typename BasicJsonType>
		class json_ref
		{
		public:
			using value_type = BasicJsonType;

			json_ref(value_type&& value)
				: owned_value(std::move(value)), value_ref(&owned_value), is_rvalue(true)
			{}

			json_ref(const value_type& value)
				: value_ref(const_cast<value_type*>(&value)), is_rvalue(false)
			{}

			json_ref(std::initializer_list<json_ref> init)
				: owned_value(init), value_ref(&owned_value), is_rvalue(true)
			{}

			template<class... Args>
			json_ref(Args&& ... args)
				: owned_value(std::forward<Args>(args)...), value_ref(&owned_value), is_rvalue(true)
			{}

			// class should be movable only
			json_ref(json_ref&&) = default;
			json_ref(const json_ref&) = delete;
			json_ref& operator=(const json_ref&) = delete;

			value_type moved_or_copied() const
			{
				if (is_rvalue)
				{
					return std::move(*value_ref);
				}
				return *value_ref;
			}

			value_type const& operator*() const
			{
				return *static_cast<value_type const*>(value_ref);
			}

			value_type const* operator->() const
			{
				return static_cast<value_type const*>(value_ref);
			}

		private:
			mutable value_type owned_value = nullptr;
			value_type* value_ref = nullptr;
			const bool is_rvalue;
		};
	}
}

// #include <nlohmann/detail/json_pointer.hpp>


#include <cassert> // assert
#include <numeric> // accumulate
#include <string> // string
#include <vector> // vector

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	template<typename BasicJsonType>
	class json_pointer
	{
		// allow basic_json to access private members
		NLOHMANN_BASIC_JSON_TPL_DECLARATION
			friend class basic_json;

	public:
		/*!
		@brief create JSON pointer

		Create a JSON pointer according to the syntax described in
		[Section 3 of RFC6901](https://tools.ietf.org/html/rfc6901#section-3).

		@param[in] s  string representing the JSON pointer; if omitted, the empty
					  string is assumed which references the whole JSON value

		@throw parse_error.107 if the given JSON pointer @a s is nonempty and does
							   not begin with a slash (`/`); see example below

		@throw parse_error.108 if a tilde (`~`) in the given JSON pointer @a s is
		not followed by `0` (representing `~`) or `1` (representing `/`); see
		example below

		@liveexample{The example shows the construction several valid JSON pointers
		as well as the exceptional behavior.,json_pointer}

		@since version 2.0.0
		*/
		explicit json_pointer(const std::string& s = "")
			: reference_tokens(split(s))
		{}

		/*!
		@brief return a string representation of the JSON pointer

		@invariant For each JSON pointer `ptr`, it holds:
		@code {.cpp}
		ptr == json_pointer(ptr.to_string());
		@endcode

		@return a string representation of the JSON pointer

		@liveexample{The example shows the result of `to_string`.,
		json_pointer__to_string}

		@since version 2.0.0
		*/
		std::string to_string() const noexcept
		{
			return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
				std::string{},
				[](const std::string & a, const std::string & b)
			{
				return a + "/" + escape(b);
			});
		}

		/// @copydoc to_string()
		operator std::string() const
		{
			return to_string();
		}

		/*!
		@param[in] s  reference token to be converted into an array index

		@return integer representation of @a s

		@throw out_of_range.404 if string @a s could not be converted to an integer
		*/
		static int array_index(const std::string& s)
		{
			std::size_t processed_chars = 0;
			const int res = std::stoi(s, &processed_chars);

			// check if the string was completely read
			if (JSON_UNLIKELY(processed_chars != s.size()))
			{
				JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + s + "'"));
			}

			return res;
		}

	private:
		/*!
		@brief remove and return last reference pointer
		@throw out_of_range.405 if JSON pointer has no parent
		*/
		std::string pop_back()
		{
			if (JSON_UNLIKELY(is_root()))
			{
				JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
			}

			auto last = reference_tokens.back();
			reference_tokens.pop_back();
			return last;
		}

		/// return whether pointer points to the root document
		bool is_root() const
		{
			return reference_tokens.empty();
		}

		json_pointer top() const
		{
			if (JSON_UNLIKELY(is_root()))
			{
				JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
			}

			json_pointer result = *this;
			result.reference_tokens = { reference_tokens[0] };
			return result;
		}

		/*!
		@brief create and return a reference to the pointed to value

		@complexity Linear in the number of reference tokens.

		@throw parse_error.109 if array index is not a number
		@throw type_error.313 if value cannot be unflattened
		*/
		BasicJsonType& get_and_create(BasicJsonType& j) const
		{
			using size_type = typename BasicJsonType::size_type;
			auto result = &j;

			// in case no reference tokens exist, return a reference to the JSON value
			// j which will be overwritten by a primitive value
			for (const auto& reference_token : reference_tokens)
			{
				switch (result->m_type)
				{
				case detail::value_t::null:
				{
					if (reference_token == "0")
					{
						// start a new array if reference token is 0
						result = &result->operator[](0);
					}
					else
					{
						// start a new object otherwise
						result = &result->operator[](reference_token);
					}
					break;
				}

				case detail::value_t::object:
				{
					// create an entry in the object
					result = &result->operator[](reference_token);
					break;
				}

				case detail::value_t::array:
				{
					// create an entry in the array
					JSON_TRY
					{
						result = &result->operator[](static_cast<size_type>(array_index(reference_token)));
					}
						JSON_CATCH(std::invalid_argument&)
					{
						JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
					}
					break;
				}

				/*
				The following code is only reached if there exists a reference
				token _and_ the current value is primitive. In this case, we have
				an error situation, because primitive values may only occur as
				single value; that is, with an empty list of reference tokens.
				*/
				default:
					JSON_THROW(detail::type_error::create(313, "invalid value to unflatten"));
				}
			}

			return *result;
		}

		/*!
		@brief return a reference to the pointed to value

		@note This version does not throw if a value is not present, but tries to
			  create nested values instead. For instance, calling this function
			  with pointer `"/this/that"` on a null value is equivalent to calling
			  `operator[]("this").operator[]("that")` on that value, effectively
			  changing the null value to an object.

		@param[in] ptr  a JSON value

		@return reference to the JSON value pointed to by the JSON pointer

		@complexity Linear in the length of the JSON pointer.

		@throw parse_error.106   if an array index begins with '0'
		@throw parse_error.109   if an array index was not a number
		@throw out_of_range.404  if the JSON pointer can not be resolved
		*/
		BasicJsonType& get_unchecked(BasicJsonType* ptr) const
		{
			using size_type = typename BasicJsonType::size_type;
			for (const auto& reference_token : reference_tokens)
			{
				// convert null values to arrays or objects before continuing
				if (ptr->m_type == detail::value_t::null)
				{
					// check if reference token is a number
					const bool nums =
						std::all_of(reference_token.begin(), reference_token.end(),
							[](const char x)
					{
						return (x >= '0' and x <= '9');
					});

					// change value to array for numbers or "-" or to object otherwise
					*ptr = (nums or reference_token == "-")
						? detail::value_t::array
						: detail::value_t::object;
				}

				switch (ptr->m_type)
				{
				case detail::value_t::object:
				{
					// use unchecked object access
					ptr = &ptr->operator[](reference_token);
					break;
				}

				case detail::value_t::array:
				{
					// error condition (cf. RFC 6901, Sect. 4)
					if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
					{
						JSON_THROW(detail::parse_error::create(106, 0,
							"array index '" + reference_token +
							"' must not begin with '0'"));
					}

					if (reference_token == "-")
					{
						// explicitly treat "-" as index beyond the end
						ptr = &ptr->operator[](ptr->m_value.array->size());
					}
					else
					{
						// convert array index to number; unchecked access
						JSON_TRY
						{
							ptr = &ptr->operator[](
								static_cast<size_type>(array_index(reference_token)));
						}
							JSON_CATCH(std::invalid_argument&)
						{
							JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
						}
					}
					break;
				}

				default:
					JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
				}
			}

			return *ptr;
		}

		/*!
		@throw parse_error.106   if an array index begins with '0'
		@throw parse_error.109   if an array index was not a number
		@throw out_of_range.402  if the array index '-' is used
		@throw out_of_range.404  if the JSON pointer can not be resolved
		*/
		BasicJsonType& get_checked(BasicJsonType* ptr) const
		{
			using size_type = typename BasicJsonType::size_type;
			for (const auto& reference_token : reference_tokens)
			{
				switch (ptr->m_type)
				{
				case detail::value_t::object:
				{
					// note: at performs range check
					ptr = &ptr->at(reference_token);
					break;
				}

				case detail::value_t::array:
				{
					if (JSON_UNLIKELY(reference_token == "-"))
					{
						// "-" always fails the range check
						JSON_THROW(detail::out_of_range::create(402,
							"array index '-' (" + std::to_string(ptr->m_value.array->size()) +
							") is out of range"));
					}

					// error condition (cf. RFC 6901, Sect. 4)
					if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
					{
						JSON_THROW(detail::parse_error::create(106, 0,
							"array index '" + reference_token +
							"' must not begin with '0'"));
					}

					// note: at performs range check
					JSON_TRY
					{
						ptr = &ptr->at(static_cast<size_type>(array_index(reference_token)));
					}
						JSON_CATCH(std::invalid_argument&)
					{
						JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
					}
					break;
				}

				default:
					JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
				}
			}

			return *ptr;
		}

		/*!
		@brief return a const reference to the pointed to value

		@param[in] ptr  a JSON value

		@return const reference to the JSON value pointed to by the JSON
		pointer

		@throw parse_error.106   if an array index begins with '0'
		@throw parse_error.109   if an array index was not a number
		@throw out_of_range.402  if the array index '-' is used
		@throw out_of_range.404  if the JSON pointer can not be resolved
		*/
		const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
		{
			using size_type = typename BasicJsonType::size_type;
			for (const auto& reference_token : reference_tokens)
			{
				switch (ptr->m_type)
				{
				case detail::value_t::object:
				{
					// use unchecked object access
					ptr = &ptr->operator[](reference_token);
					break;
				}

				case detail::value_t::array:
				{
					if (JSON_UNLIKELY(reference_token == "-"))
					{
						// "-" cannot be used for const access
						JSON_THROW(detail::out_of_range::create(402,
							"array index '-' (" + std::to_string(ptr->m_value.array->size()) +
							") is out of range"));
					}

					// error condition (cf. RFC 6901, Sect. 4)
					if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
					{
						JSON_THROW(detail::parse_error::create(106, 0,
							"array index '" + reference_token +
							"' must not begin with '0'"));
					}

					// use unchecked array access
					JSON_TRY
					{
						ptr = &ptr->operator[](
							static_cast<size_type>(array_index(reference_token)));
					}
						JSON_CATCH(std::invalid_argument&)
					{
						JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
					}
					break;
				}

				default:
					JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
				}
			}

			return *ptr;
		}

		/*!
		@throw parse_error.106   if an array index begins with '0'
		@throw parse_error.109   if an array index was not a number
		@throw out_of_range.402  if the array index '-' is used
		@throw out_of_range.404  if the JSON pointer can not be resolved
		*/
		const BasicJsonType& get_checked(const BasicJsonType* ptr) const
		{
			using size_type = typename BasicJsonType::size_type;
			for (const auto& reference_token : reference_tokens)
			{
				switch (ptr->m_type)
				{
				case detail::value_t::object:
				{
					// note: at performs range check
					ptr = &ptr->at(reference_token);
					break;
				}

				case detail::value_t::array:
				{
					if (JSON_UNLIKELY(reference_token == "-"))
					{
						// "-" always fails the range check
						JSON_THROW(detail::out_of_range::create(402,
							"array index '-' (" + std::to_string(ptr->m_value.array->size()) +
							") is out of range"));
					}

					// error condition (cf. RFC 6901, Sect. 4)
					if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
					{
						JSON_THROW(detail::parse_error::create(106, 0,
							"array index '" + reference_token +
							"' must not begin with '0'"));
					}

					// note: at performs range check
					JSON_TRY
					{
						ptr = &ptr->at(static_cast<size_type>(array_index(reference_token)));
					}
						JSON_CATCH(std::invalid_argument&)
					{
						JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
					}
					break;
				}

				default:
					JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
				}
			}

			return *ptr;
		}

		/*!
		@brief split the string input to reference tokens

		@note This function is only called by the json_pointer constructor.
			  All exceptions below are documented there.

		@throw parse_error.107  if the pointer is not empty or begins with '/'
		@throw parse_error.108  if character '~' is not followed by '0' or '1'
		*/
		static std::vector<std::string> split(const std::string& reference_string)
		{
			std::vector<std::string> result;

			// special case: empty reference string -> no reference tokens
			if (reference_string.empty())
			{
				return result;
			}

			// check if nonempty reference string begins with slash
			if (JSON_UNLIKELY(reference_string[0] != '/'))
			{
				JSON_THROW(detail::parse_error::create(107, 1,
					"JSON pointer must be empty or begin with '/' - was: '" +
					reference_string + "'"));
			}

			// extract the reference tokens:
			// - slash: position of the last read slash (or end of string)
			// - start: position after the previous slash
			for (
				// search for the first slash after the first character
				std::size_t slash = reference_string.find_first_of('/', 1),
				// set the beginning of the first reference token
				start = 1;
				// we can stop if start == string::npos+1 = 0
				start != 0;
				// set the beginning of the next reference token
				// (will eventually be 0 if slash == std::string::npos)
				start = slash + 1,
				// find next slash
				slash = reference_string.find_first_of('/', start))
			{
				// use the text between the beginning of the reference token
				// (start) and the last slash (slash).
				auto reference_token = reference_string.substr(start, slash - start);

				// check reference tokens are properly escaped
				for (std::size_t pos = reference_token.find_first_of('~');
					pos != std::string::npos;
					pos = reference_token.find_first_of('~', pos + 1))
				{
					assert(reference_token[pos] == '~');

					// ~ must be followed by 0 or 1
					if (JSON_UNLIKELY(pos == reference_token.size() - 1 or
						(reference_token[pos + 1] != '0' and
							reference_token[pos + 1] != '1')))
					{
						JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'"));
					}
				}

				// finally, store the reference token
				unescape(reference_token);
				result.push_back(reference_token);
			}

			return result;
		}

		/*!
		@brief replace all occurrences of a substring by another string

		@param[in,out] s  the string to manipulate; changed so that all
					   occurrences of @a f are replaced with @a t
		@param[in]     f  the substring to replace with @a t
		@param[in]     t  the string to replace @a f

		@pre The search string @a f must not be empty. **This precondition is
		enforced with an assertion.**

		@since version 2.0.0
		*/
		static void replace_substring(std::string& s, const std::string& f,
			const std::string& t)
		{
			assert(not f.empty());
			for (auto pos = s.find(f);                // find first occurrence of f
				pos != std::string::npos;         // make sure f was found
				s.replace(pos, f.size(), t),      // replace with t, and
				pos = s.find(f, pos + t.size()))  // find next occurrence of f
			{
			}
		}

		/// escape "~"" to "~0" and "/" to "~1"
		static std::string escape(std::string s)
		{
			replace_substring(s, "~", "~0");
			replace_substring(s, "/", "~1");
			return s;
		}

		/// unescape "~1" to tilde and "~0" to slash (order is important!)
		static void unescape(std::string& s)
		{
			replace_substring(s, "~1", "/");
			replace_substring(s, "~0", "~");
		}

		/*!
		@param[in] reference_string  the reference string to the current value
		@param[in] value             the value to consider
		@param[in,out] result        the result object to insert values to

		@note Empty objects or arrays are flattened to `null`.
		*/
		static void flatten(const std::string& reference_string,
			const BasicJsonType& value,
			BasicJsonType& result)
		{
			switch (value.m_type)
			{
			case detail::value_t::array:
			{
				if (value.m_value.array->empty())
				{
					// flatten empty array as null
					result[reference_string] = nullptr;
				}
				else
				{
					// iterate array and use index as reference string
					for (std::size_t i = 0; i < value.m_value.array->size(); ++i)
					{
						flatten(reference_string + "/" + std::to_string(i),
							value.m_value.array->operator[](i), result);
					}
				}
				break;
			}

			case detail::value_t::object:
			{
				if (value.m_value.object->empty())
				{
					// flatten empty object as null
					result[reference_string] = nullptr;
				}
				else
				{
					// iterate object and use keys as reference string
					for (const auto& element : *value.m_value.object)
					{
						flatten(reference_string + "/" + escape(element.first), element.second, result);
					}
				}
				break;
			}

			default:
			{
				// add primitive value with its reference string
				result[reference_string] = value;
				break;
			}
			}
		}

		/*!
		@param[in] value  flattened JSON

		@return unflattened JSON

		@throw parse_error.109 if array index is not a number
		@throw type_error.314  if value is not an object
		@throw type_error.315  if object values are not primitive
		@throw type_error.313  if value cannot be unflattened
		*/
		static BasicJsonType
			unflatten(const BasicJsonType& value)
		{
			if (JSON_UNLIKELY(not value.is_object()))
			{
				JSON_THROW(detail::type_error::create(314, "only objects can be unflattened"));
			}

			BasicJsonType result;

			// iterate the JSON object values
			for (const auto& element : *value.m_value.object)
			{
				if (JSON_UNLIKELY(not element.second.is_primitive()))
				{
					JSON_THROW(detail::type_error::create(315, "values in object must be primitive"));
				}

				// assign value to reference pointed to by JSON pointer; Note that if
				// the JSON pointer is "" (i.e., points to the whole value), function
				// get_and_create returns a reference to result itself. An assignment
				// will then create a primitive value.
				json_pointer(element.first).get_and_create(result) = element.second;
			}

			return result;
		}

		friend bool operator==(json_pointer const& lhs,
			json_pointer const& rhs) noexcept
		{
			return (lhs.reference_tokens == rhs.reference_tokens);
		}

		friend bool operator!=(json_pointer const& lhs,
			json_pointer const& rhs) noexcept
		{
			return not (lhs == rhs);
		}

		/// the reference tokens
		std::vector<std::string> reference_tokens;
	};
}

// #include <nlohmann/adl_serializer.hpp>


#include <utility>

// #include <nlohmann/detail/conversions/from_json.hpp>

// #include <nlohmann/detail/conversions/to_json.hpp>


namespace nlohmann
{
	template<typename, typename>
	struct adl_serializer
	{
		/*!
		@brief convert a JSON value to any value type

		This function is usually called by the `get()` function of the
		@ref basic_json class (either explicit or via conversion operators).

		@param[in] j         JSON value to read from
		@param[in,out] val  value to write to
		*/
		template<typename BasicJsonType, typename ValueType>
		static auto from_json(BasicJsonType&& j, ValueType& val) noexcept(
			noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val))) -> decltype(
				::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void()
				)
		{
			::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
		}

		/*!
		@brief convert any value type to a JSON value

		This function is usually called by the constructors of the @ref basic_json
		class.

		@param[in,out] j  JSON value to write to
		@param[in] val     value to read from
		*/
		template <typename BasicJsonType, typename ValueType>
		static auto to_json(BasicJsonType& j, ValueType&& val) noexcept(
			noexcept(::nlohmann::to_json(j, std::forward<ValueType>(val))))
			-> decltype(::nlohmann::to_json(j, std::forward<ValueType>(val)),
				void())
		{
			::nlohmann::to_json(j, std::forward<ValueType>(val));
		}
	};
}


/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
namespace nlohmann
{

	/*!
	@brief a class to store JSON values

	@tparam ObjectType type for JSON objects (`std::map` by default; will be used
	in @ref object_t)
	@tparam ArrayType type for JSON arrays (`std::vector` by default; will be used
	in @ref array_t)
	@tparam StringType type for JSON strings and object keys (`std::string` by
	default; will be used in @ref string_t)
	@tparam BooleanType type for JSON booleans (`bool` by default; will be used
	in @ref boolean_t)
	@tparam NumberIntegerType type for JSON integer numbers (`int64_t` by
	default; will be used in @ref number_integer_t)
	@tparam NumberUnsignedType type for JSON unsigned integer numbers (@c
	`uint64_t` by default; will be used in @ref number_unsigned_t)
	@tparam NumberFloatType type for JSON floating-point numbers (`double` by
	default; will be used in @ref number_float_t)
	@tparam AllocatorType type of the allocator to use (`std::allocator` by
	default)
	@tparam JSONSerializer the serializer to resolve internal calls to `to_json()`
	and `from_json()` (@ref adl_serializer by default)

	@requirement The class satisfies the following concept requirements:
	- Basic
	 - [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible):
	   JSON values can be default constructed. The result will be a JSON null
	   value.
	 - [MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible):
	   A JSON value can be constructed from an rvalue argument.
	 - [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible):
	   A JSON value can be copy-constructed from an lvalue expression.
	 - [MoveAssignable](https://en.cppreference.com/w/cpp/named_req/MoveAssignable):
	   A JSON value van be assigned from an rvalue argument.
	 - [CopyAssignable](https://en.cppreference.com/w/cpp/named_req/CopyAssignable):
	   A JSON value can be copy-assigned from an lvalue expression.
	 - [Destructible](https://en.cppreference.com/w/cpp/named_req/Destructible):
	   JSON values can be destructed.
	- Layout
	 - [StandardLayoutType](https://en.cppreference.com/w/cpp/named_req/StandardLayoutType):
	   JSON values have
	   [standard layout](https://en.cppreference.com/w/cpp/language/data_members#Standard_layout):
	   All non-static data members are private and standard layout types, the
	   class has no virtual functions or (virtual) base classes.
	- Library-wide
	 - [EqualityComparable](https://en.cppreference.com/w/cpp/named_req/EqualityComparable):
	   JSON values can be compared with `==`, see @ref
	   operator==(const_reference,const_reference).
	 - [LessThanComparable](https://en.cppreference.com/w/cpp/named_req/LessThanComparable):
	   JSON values can be compared with `<`, see @ref
	   operator<(const_reference,const_reference).
	 - [Swappable](https://en.cppreference.com/w/cpp/named_req/Swappable):
	   Any JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of
	   other compatible types, using unqualified function call @ref swap().
	 - [NullablePointer](https://en.cppreference.com/w/cpp/named_req/NullablePointer):
	   JSON values can be compared against `std::nullptr_t` objects which are used
	   to model the `null` value.
	- Container
	 - [Container](https://en.cppreference.com/w/cpp/named_req/Container):
	   JSON values can be used like STL containers and provide iterator access.
	 - [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer);
	   JSON values can be used like STL containers and provide reverse iterator
	   access.

	@invariant The member variables @a m_value and @a m_type have the following
	relationship:
	- If `m_type == value_t::object`, then `m_value.object != nullptr`.
	- If `m_type == value_t::array`, then `m_value.array != nullptr`.
	- If `m_type == value_t::string`, then `m_value.string != nullptr`.
	The invariants are checked by member function assert_invariant().

	@internal
	@note ObjectType trick from http://stackoverflow.com/a/9860911
	@endinternal

	@see [RFC 7159: The JavaScript Object Notation (JSON) Data Interchange
	Format](http://rfc7159.net/rfc7159)

	@since version 1.0.0

	@nosubgrouping
	*/
	NLOHMANN_BASIC_JSON_TPL_DECLARATION
		class basic_json
	{
	private:
		template<detail::value_t> friend struct detail::external_constructor;
		friend ::nlohmann::json_pointer<basic_json>;
		friend ::nlohmann::detail::parser<basic_json>;
		friend ::nlohmann::detail::serializer<basic_json>;
		template<typename BasicJsonType>
		friend class ::nlohmann::detail::iter_impl;
		template<typename BasicJsonType, typename CharType>
		friend class ::nlohmann::detail::binary_writer;
		template<typename BasicJsonType, typename SAX>
		friend class ::nlohmann::detail::binary_reader;
		template<typename BasicJsonType>
		friend class ::nlohmann::detail::json_sax_dom_parser;
		template<typename BasicJsonType>
		friend class ::nlohmann::detail::json_sax_dom_callback_parser;

		/// workaround type for MSVC
		using basic_json_t = NLOHMANN_BASIC_JSON_TPL;

		// convenience aliases for types residing in namespace detail;
		using lexer = ::nlohmann::detail::lexer<basic_json>;
		using parser = ::nlohmann::detail::parser<basic_json>;

		using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
		template<typename BasicJsonType>
		using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
		template<typename BasicJsonType>
		using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
		template<typename Iterator>
		using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
		template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;

		template<typename CharType>
		using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;

		using binary_reader = ::nlohmann::detail::binary_reader<basic_json>;
		template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;

		using serializer = ::nlohmann::detail::serializer<basic_json>;

	public:
		using value_t = detail::value_t;
		/// JSON Pointer, see @ref nlohmann::json_pointer
		using json_pointer = ::nlohmann::json_pointer<basic_json>;
		template<typename T, typename SFINAE>
		using json_serializer = JSONSerializer<T, SFINAE>;
		/// helper type for initializer lists of basic_json values
		using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;

		using input_format_t = detail::input_format_t;
		/// SAX interface type, see @ref nlohmann::json_sax
		using json_sax_t = json_sax<basic_json>;

		////////////////
		// exceptions //
		////////////////

		/// @name exceptions
		/// Classes to implement user-defined exceptions.
		/// @{

		/// @copydoc detail::exception
		using exception = detail::exception;
		/// @copydoc detail::parse_error
		using parse_error = detail::parse_error;
		/// @copydoc detail::invalid_iterator
		using invalid_iterator = detail::invalid_iterator;
		/// @copydoc detail::type_error
		using type_error = detail::type_error;
		/// @copydoc detail::out_of_range
		using out_of_range = detail::out_of_range;
		/// @copydoc detail::other_error
		using other_error = detail::other_error;

		/// @}


		/////////////////////
		// container types //
		/////////////////////

		/// @name container types
		/// The canonic container types to use @ref basic_json like any other STL
		/// container.
		/// @{

		/// the type of elements in a basic_json container
		using value_type = basic_json;

		/// the type of an element reference
		using reference = value_type & ;
		/// the type of an element const reference
		using const_reference = const value_type&;

		/// a type to represent differences between iterators
		using difference_type = std::ptrdiff_t;
		/// a type to represent container sizes
		using size_type = std::size_t;

		/// the allocator type
		using allocator_type = AllocatorType<basic_json>;

		/// the type of an element pointer
		using pointer = typename std::allocator_traits<allocator_type>::pointer;
		/// the type of an element const pointer
		using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;

		/// an iterator for a basic_json container
		using iterator = iter_impl<basic_json>;
		/// a const iterator for a basic_json container
		using const_iterator = iter_impl<const basic_json>;
		/// a reverse iterator for a basic_json container
		using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
		/// a const reverse iterator for a basic_json container
		using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;

		/// @}


		/*!
		@brief returns the allocator associated with the container
		*/
		static allocator_type get_allocator()
		{
			return allocator_type();
		}

		/*!
		@brief returns version information on the library

		This function returns a JSON object with information about the library,
		including the version number and information on the platform and compiler.

		@return JSON object holding version information
		key         | description
		----------- | ---------------
		`compiler`  | Information on the used compiler. It is an object with the following keys: `c++` (the used C++ standard), `family` (the compiler family; possible values are `clang`, `icc`, `gcc`, `ilecpp`, `msvc`, `pgcpp`, `sunpro`, and `unknown`), and `version` (the compiler version).
		`copyright` | The copyright line for the library as string.
		`name`      | The name of the library as string.
		`platform`  | The used platform as string. Possible values are `win32`, `linux`, `apple`, `unix`, and `unknown`.
		`url`       | The URL of the project as string.
		`version`   | The version of the library. It is an object with the following keys: `major`, `minor`, and `patch` as defined by [Semantic Versioning](http://semver.org), and `string` (the version string).

		@liveexample{The following code shows an example output of the `meta()`
		function.,meta}

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@complexity Constant.

		@since 2.1.0
		*/
		static basic_json meta()
		{
			basic_json result;

			result["copyright"] = "(C) 2013-2017 Niels Lohmann";
			result["name"] = "JSON for Modern C++";
			result["url"] = "https://github.com/nlohmann/json";
			result["version"]["string"] =
				std::to_string(NLOHMANN_JSON_VERSION_MAJOR) + "." +
				std::to_string(NLOHMANN_JSON_VERSION_MINOR) + "." +
				std::to_string(NLOHMANN_JSON_VERSION_PATCH);
			result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
			result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
			result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;

#ifdef _WIN32
			result["platform"] = "win32";
#elif defined __linux__
			result["platform"] = "linux";
#elif defined __APPLE__
			result["platform"] = "apple";
#elif defined __unix__
			result["platform"] = "unix";
#else
			result["platform"] = "unknown";
#endif

#if defined(__ICC) || defined(__INTEL_COMPILER)
			result["compiler"] = { {"family", "icc"}, {"version", __INTEL_COMPILER} };
#elif defined(__clang__)
			result["compiler"] = { {"family", "clang"}, {"version", __clang_version__} };
#elif defined(__GNUC__) || defined(__GNUG__)
			result["compiler"] = { {"family", "gcc"}, {"version", std::to_string(__GNUC__) + "." + std::to_string(__GNUC_MINOR__) + "." + std::to_string(__GNUC_PATCHLEVEL__)} };
#elif defined(__HP_cc) || defined(__HP_aCC)
			result["compiler"] = "hp"
#elif defined(__IBMCPP__)
			result["compiler"] = { {"family", "ilecpp"}, {"version", __IBMCPP__} };
#elif defined(_MSC_VER)
			result["compiler"] = { {"family", "msvc"}, {"version", _MSC_VER} };
#elif defined(__PGI)
			result["compiler"] = { {"family", "pgcpp"}, {"version", __PGI} };
#elif defined(__SUNPRO_CC)
			result["compiler"] = { {"family", "sunpro"}, {"version", __SUNPRO_CC} };
#else
			result["compiler"] = { {"family", "unknown"}, {"version", "unknown"} };
#endif

#ifdef __cplusplus
			result["compiler"]["c++"] = std::to_string(__cplusplus);
#else
			result["compiler"]["c++"] = "unknown";
#endif
			return result;
		}


		///////////////////////////
		// JSON value data types //
		///////////////////////////

		/// @name JSON value data types
		/// The data types to store a JSON value. These types are derived from
		/// the template arguments passed to class @ref basic_json.
		/// @{

#if defined(JSON_HAS_CPP_14)
	// Use transparent comparator if possible, combined with perfect forwarding
	// on find() and count() calls prevents unnecessary string construction.
		using object_comparator_t = std::less<>;
#else
		using object_comparator_t = std::less<StringType>;
#endif

		/*!
		@brief a type for an object

		[RFC 7159](http://rfc7159.net/rfc7159) describes JSON objects as follows:
		> An object is an unordered collection of zero or more name/value pairs,
		> where a name is a string and a value is a string, number, boolean, null,
		> object, or array.

		To store objects in C++, a type is defined by the template parameters
		described below.

		@tparam ObjectType  the container to store objects (e.g., `std::map` or
		`std::unordered_map`)
		@tparam StringType the type of the keys or names (e.g., `std::string`).
		The comparison function `std::less<StringType>` is used to order elements
		inside the container.
		@tparam AllocatorType the allocator to use for objects (e.g.,
		`std::allocator`)

		#### Default type

		With the default values for @a ObjectType (`std::map`), @a StringType
		(`std::string`), and @a AllocatorType (`std::allocator`), the default
		value for @a object_t is:

		@code {.cpp}
		std::map<
		  std::string, // key_type
		  basic_json, // value_type
		  std::less<std::string>, // key_compare
		  std::allocator<std::pair<const std::string, basic_json>> // allocator_type
		>
		@endcode

		#### Behavior

		The choice of @a object_t influences the behavior of the JSON class. With
		the default type, objects have the following behavior:

		- When all names are unique, objects will be interoperable in the sense
		  that all software implementations receiving that object will agree on
		  the name-value mappings.
		- When the names within an object are not unique, it is unspecified which
		  one of the values for a given key will be chosen. For instance,
		  `{"key": 2, "key": 1}` could be equal to either `{"key": 1}` or
		  `{"key": 2}`.
		- Internally, name/value pairs are stored in lexicographical order of the
		  names. Objects will also be serialized (see @ref dump) in this order.
		  For instance, `{"b": 1, "a": 2}` and `{"a": 2, "b": 1}` will be stored
		  and serialized as `{"a": 2, "b": 1}`.
		- When comparing objects, the order of the name/value pairs is irrelevant.
		  This makes objects interoperable in the sense that they will not be
		  affected by these differences. For instance, `{"b": 1, "a": 2}` and
		  `{"a": 2, "b": 1}` will be treated as equal.

		#### Limits

		[RFC 7159](http://rfc7159.net/rfc7159) specifies:
		> An implementation may set limits on the maximum depth of nesting.

		In this class, the object's limit of nesting is not explicitly constrained.
		However, a maximum depth of nesting may be introduced by the compiler or
		runtime environment. A theoretical limit can be queried by calling the
		@ref max_size function of a JSON object.

		#### Storage

		Objects are stored as pointers in a @ref basic_json type. That is, for any
		access to object values, a pointer of type `object_t*` must be
		dereferenced.

		@sa @ref array_t -- type for an array value

		@since version 1.0.0

		@note The order name/value pairs are added to the object is *not*
		preserved by the library. Therefore, iterating an object may return
		name/value pairs in a different order than they were originally stored. In
		fact, keys will be traversed in alphabetical order as `std::map` with
		`std::less` is used by default. Please note this behavior conforms to [RFC
		7159](http://rfc7159.net/rfc7159), because any order implements the
		specified "unordered" nature of JSON objects.
		*/
		using object_t = ObjectType<StringType,
			basic_json,
			object_comparator_t,
			AllocatorType<std::pair<const StringType,
			basic_json>>>;

		/*!
		@brief a type for an array

		[RFC 7159](http://rfc7159.net/rfc7159) describes JSON arrays as follows:
		> An array is an ordered sequence of zero or more values.

		To store objects in C++, a type is defined by the template parameters
		explained below.

		@tparam ArrayType  container type to store arrays (e.g., `std::vector` or
		`std::list`)
		@tparam AllocatorType allocator to use for arrays (e.g., `std::allocator`)

		#### Default type

		With the default values for @a ArrayType (`std::vector`) and @a
		AllocatorType (`std::allocator`), the default value for @a array_t is:

		@code {.cpp}
		std::vector<
		  basic_json, // value_type
		  std::allocator<basic_json> // allocator_type
		>
		@endcode

		#### Limits

		[RFC 7159](http://rfc7159.net/rfc7159) specifies:
		> An implementation may set limits on the maximum depth of nesting.

		In this class, the array's limit of nesting is not explicitly constrained.
		However, a maximum depth of nesting may be introduced by the compiler or
		runtime environment. A theoretical limit can be queried by calling the
		@ref max_size function of a JSON array.

		#### Storage

		Arrays are stored as pointers in a @ref basic_json type. That is, for any
		access to array values, a pointer of type `array_t*` must be dereferenced.

		@sa @ref object_t -- type for an object value

		@since version 1.0.0
		*/
		using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;

		/*!
		@brief a type for a string

		[RFC 7159](http://rfc7159.net/rfc7159) describes JSON strings as follows:
		> A string is a sequence of zero or more Unicode characters.

		To store objects in C++, a type is defined by the template parameter
		described below. Unicode values are split by the JSON class into
		byte-sized characters during deserialization.

		@tparam StringType  the container to store strings (e.g., `std::string`).
		Note this container is used for keys/names in objects, see @ref object_t.

		#### Default type

		With the default values for @a StringType (`std::string`), the default
		value for @a string_t is:

		@code {.cpp}
		std::string
		@endcode

		#### Encoding

		Strings are stored in UTF-8 encoding. Therefore, functions like
		`std::string::size()` or `std::string::length()` return the number of
		bytes in the string rather than the number of characters or glyphs.

		#### String comparison

		[RFC 7159](http://rfc7159.net/rfc7159) states:
		> Software implementations are typically required to test names of object
		> members for equality. Implementations that transform the textual
		> representation into sequences of Unicode code units and then perform the
		> comparison numerically, code unit by code unit, are interoperable in the
		> sense that implementations will agree in all cases on equality or
		> inequality of two strings. For example, implementations that compare
		> strings with escaped characters unconverted may incorrectly find that
		> `"a\\b"` and `"a\u005Cb"` are not equal.

		This implementation is interoperable as it does compare strings code unit
		by code unit.

		#### Storage

		String values are stored as pointers in a @ref basic_json type. That is,
		for any access to string values, a pointer of type `string_t*` must be
		dereferenced.

		@since version 1.0.0
		*/
		using string_t = StringType;

		/*!
		@brief a type for a boolean

		[RFC 7159](http://rfc7159.net/rfc7159) implicitly describes a boolean as a
		type which differentiates the two literals `true` and `false`.

		To store objects in C++, a type is defined by the template parameter @a
		BooleanType which chooses the type to use.

		#### Default type

		With the default values for @a BooleanType (`bool`), the default value for
		@a boolean_t is:

		@code {.cpp}
		bool
		@endcode

		#### Storage

		Boolean values are stored directly inside a @ref basic_json type.

		@since version 1.0.0
		*/
		using boolean_t = BooleanType;

		/*!
		@brief a type for a number (integer)

		[RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
		> The representation of numbers is similar to that used in most
		> programming languages. A number is represented in base 10 using decimal
		> digits. It contains an integer component that may be prefixed with an
		> optional minus sign, which may be followed by a fraction part and/or an
		> exponent part. Leading zeros are not allowed. (...) Numeric values that
		> cannot be represented in the grammar below (such as Infinity and NaN)
		> are not permitted.

		This description includes both integer and floating-point numbers.
		However, C++ allows more precise storage if it is known whether the number
		is a signed integer, an unsigned integer or a floating-point number.
		Therefore, three different types, @ref number_integer_t, @ref
		number_unsigned_t and @ref number_float_t are used.

		To store integer numbers in C++, a type is defined by the template
		parameter @a NumberIntegerType which chooses the type to use.

		#### Default type

		With the default values for @a NumberIntegerType (`int64_t`), the default
		value for @a number_integer_t is:

		@code {.cpp}
		int64_t
		@endcode

		#### Default behavior

		- The restrictions about leading zeros is not enforced in C++. Instead,
		  leading zeros in integer literals lead to an interpretation as octal
		  number. Internally, the value will be stored as decimal number. For
		  instance, the C++ integer literal `010` will be serialized to `8`.
		  During deserialization, leading zeros yield an error.
		- Not-a-number (NaN) values will be serialized to `null`.

		#### Limits

		[RFC 7159](http://rfc7159.net/rfc7159) specifies:
		> An implementation may set limits on the range and precision of numbers.

		When the default type is used, the maximal integer number that can be
		stored is `9223372036854775807` (INT64_MAX) and the minimal integer number
		that can be stored is `-9223372036854775808` (INT64_MIN). Integer numbers
		that are out of range will yield over/underflow when used in a
		constructor. During deserialization, too large or small integer numbers
		will be automatically be stored as @ref number_unsigned_t or @ref
		number_float_t.

		[RFC 7159](http://rfc7159.net/rfc7159) further states:
		> Note that when such software is used, numbers that are integers and are
		> in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
		> that implementations will agree exactly on their numeric values.

		As this range is a subrange of the exactly supported range [INT64_MIN,
		INT64_MAX], this class's integer type is interoperable.

		#### Storage

		Integer number values are stored directly inside a @ref basic_json type.

		@sa @ref number_float_t -- type for number values (floating-point)

		@sa @ref number_unsigned_t -- type for number values (unsigned integer)

		@since version 1.0.0
		*/
		using number_integer_t = NumberIntegerType;

		/*!
		@brief a type for a number (unsigned)

		[RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
		> The representation of numbers is similar to that used in most
		> programming languages. A number is represented in base 10 using decimal
		> digits. It contains an integer component that may be prefixed with an
		> optional minus sign, which may be followed by a fraction part and/or an
		> exponent part. Leading zeros are not allowed. (...) Numeric values that
		> cannot be represented in the grammar below (such as Infinity and NaN)
		> are not permitted.

		This description includes both integer and floating-point numbers.
		However, C++ allows more precise storage if it is known whether the number
		is a signed integer, an unsigned integer or a floating-point number.
		Therefore, three different types, @ref number_integer_t, @ref
		number_unsigned_t and @ref number_float_t are used.

		To store unsigned integer numbers in C++, a type is defined by the
		template parameter @a NumberUnsignedType which chooses the type to use.

		#### Default type

		With the default values for @a NumberUnsignedType (`uint64_t`), the
		default value for @a number_unsigned_t is:

		@code {.cpp}
		uint64_t
		@endcode

		#### Default behavior

		- The restrictions about leading zeros is not enforced in C++. Instead,
		  leading zeros in integer literals lead to an interpretation as octal
		  number. Internally, the value will be stored as decimal number. For
		  instance, the C++ integer literal `010` will be serialized to `8`.
		  During deserialization, leading zeros yield an error.
		- Not-a-number (NaN) values will be serialized to `null`.

		#### Limits

		[RFC 7159](http://rfc7159.net/rfc7159) specifies:
		> An implementation may set limits on the range and precision of numbers.

		When the default type is used, the maximal integer number that can be
		stored is `18446744073709551615` (UINT64_MAX) and the minimal integer
		number that can be stored is `0`. Integer numbers that are out of range
		will yield over/underflow when used in a constructor. During
		deserialization, too large or small integer numbers will be automatically
		be stored as @ref number_integer_t or @ref number_float_t.

		[RFC 7159](http://rfc7159.net/rfc7159) further states:
		> Note that when such software is used, numbers that are integers and are
		> in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
		> that implementations will agree exactly on their numeric values.

		As this range is a subrange (when considered in conjunction with the
		number_integer_t type) of the exactly supported range [0, UINT64_MAX],
		this class's integer type is interoperable.

		#### Storage

		Integer number values are stored directly inside a @ref basic_json type.

		@sa @ref number_float_t -- type for number values (floating-point)
		@sa @ref number_integer_t -- type for number values (integer)

		@since version 2.0.0
		*/
		using number_unsigned_t = NumberUnsignedType;

		/*!
		@brief a type for a number (floating-point)

		[RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
		> The representation of numbers is similar to that used in most
		> programming languages. A number is represented in base 10 using decimal
		> digits. It contains an integer component that may be prefixed with an
		> optional minus sign, which may be followed by a fraction part and/or an
		> exponent part. Leading zeros are not allowed. (...) Numeric values that
		> cannot be represented in the grammar below (such as Infinity and NaN)
		> are not permitted.

		This description includes both integer and floating-point numbers.
		However, C++ allows more precise storage if it is known whether the number
		is a signed integer, an unsigned integer or a floating-point number.
		Therefore, three different types, @ref number_integer_t, @ref
		number_unsigned_t and @ref number_float_t are used.

		To store floating-point numbers in C++, a type is defined by the template
		parameter @a NumberFloatType which chooses the type to use.

		#### Default type

		With the default values for @a NumberFloatType (`double`), the default
		value for @a number_float_t is:

		@code {.cpp}
		double
		@endcode

		#### Default behavior

		- The restrictions about leading zeros is not enforced in C++. Instead,
		  leading zeros in floating-point literals will be ignored. Internally,
		  the value will be stored as decimal number. For instance, the C++
		  floating-point literal `01.2` will be serialized to `1.2`. During
		  deserialization, leading zeros yield an error.
		- Not-a-number (NaN) values will be serialized to `null`.

		#### Limits

		[RFC 7159](http://rfc7159.net/rfc7159) states:
		> This specification allows implementations to set limits on the range and
		> precision of numbers accepted. Since software that implements IEEE
		> 754-2008 binary64 (double precision) numbers is generally available and
		> widely used, good interoperability can be achieved by implementations
		> that expect no more precision or range than these provide, in the sense
		> that implementations will approximate JSON numbers within the expected
		> precision.

		This implementation does exactly follow this approach, as it uses double
		precision floating-point numbers. Note values smaller than
		`-1.79769313486232e+308` and values greater than `1.79769313486232e+308`
		will be stored as NaN internally and be serialized to `null`.

		#### Storage

		Floating-point number values are stored directly inside a @ref basic_json
		type.

		@sa @ref number_integer_t -- type for number values (integer)

		@sa @ref number_unsigned_t -- type for number values (unsigned integer)

		@since version 1.0.0
		*/
		using number_float_t = NumberFloatType;

		/// @}

	private:

		////helper for exception-safe object creation
		template<typename T, typename... Args>
		static T* create(Args&& ... args)
		{
			AllocatorType<T> alloc;
			using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;

			auto deleter = [&](T * object)
			{
				AllocatorTraits::deallocate(alloc, object, 1);
			};
			std::unique_ptr<T, decltype(deleter)> object(AllocatorTraits::allocate(alloc, 1), deleter);
			AllocatorTraits::construct(alloc, object.get(), std::forward<Args>(args)...);
			assert(object != nullptr);
			return object.release();
		}

		////////////////////////
		// JSON value storage //
		////////////////////////

		/*!
		@brief a JSON value

		The actual storage for a JSON value of the @ref basic_json class. This
		union combines the different storage types for the JSON value types
		defined in @ref value_t.

		JSON type | value_t type    | used type
		--------- | --------------- | ------------------------
		object    | object          | pointer to @ref object_t
		array     | array           | pointer to @ref array_t
		string    | string          | pointer to @ref string_t
		boolean   | boolean         | @ref boolean_t
		number    | number_integer  | @ref number_integer_t
		number    | number_unsigned | @ref number_unsigned_t
		number    | number_float    | @ref number_float_t
		null      | null            | *no value is stored*

		@note Variable-length types (objects, arrays, and strings) are stored as
		pointers. The size of the union should not exceed 64 bits if the default
		value types are used.

		@since version 1.0.0
		*/
		union json_value
		{
			/// object (stored with pointer to save storage)
			object_t* object;
			/// array (stored with pointer to save storage)
			array_t* array;
			/// string (stored with pointer to save storage)
			string_t* string;
			/// boolean
			boolean_t boolean;
			/// number (integer)
			number_integer_t number_integer;
			/// number (unsigned integer)
			number_unsigned_t number_unsigned;
			/// number (floating-point)
			number_float_t number_float;

			/// default constructor (for null values)
			json_value() = default;
			/// constructor for booleans
			json_value(boolean_t v) noexcept : boolean(v) {}
			/// constructor for numbers (integer)
			json_value(number_integer_t v) noexcept : number_integer(v) {}
			/// constructor for numbers (unsigned)
			json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
			/// constructor for numbers (floating-point)
			json_value(number_float_t v) noexcept : number_float(v) {}
			/// constructor for empty values of a given type
			json_value(value_t t)
			{
				switch (t)
				{
				case value_t::object:
				{
					object = create<object_t>();
					break;
				}

				case value_t::array:
				{
					array = create<array_t>();
					break;
				}

				case value_t::string:
				{
					string = create<string_t>("");
					break;
				}

				case value_t::boolean:
				{
					boolean = boolean_t(false);
					break;
				}

				case value_t::number_integer:
				{
					number_integer = number_integer_t(0);
					break;
				}

				case value_t::number_unsigned:
				{
					number_unsigned = number_unsigned_t(0);
					break;
				}

				case value_t::number_float:
				{
					number_float = number_float_t(0.0);
					break;
				}

				case value_t::null:
				{
					object = nullptr;  // silence warning, see #821
					break;
				}

				default:
				{
					object = nullptr;  // silence warning, see #821
					if (JSON_UNLIKELY(t == value_t::null))
					{
						JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.3.0")); // LCOV_EXCL_LINE
					}
					break;
				}
				}
			}

			/// constructor for strings
			json_value(const string_t& value)
			{
				string = create<string_t>(value);
			}

			/// constructor for rvalue strings
			json_value(string_t&& value)
			{
				string = create<string_t>(std::move(value));
			}

			/// constructor for objects
			json_value(const object_t& value)
			{
				object = create<object_t>(value);
			}

			/// constructor for rvalue objects
			json_value(object_t&& value)
			{
				object = create<object_t>(std::move(value));
			}

			/// constructor for arrays
			json_value(const array_t& value)
			{
				array = create<array_t>(value);
			}

			/// constructor for rvalue arrays
			json_value(array_t&& value)
			{
				array = create<array_t>(std::move(value));
			}

			void destroy(value_t t) noexcept
			{
				switch (t)
				{
				case value_t::object:
				{
					AllocatorType<object_t> alloc;
					std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
					std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
					break;
				}

				case value_t::array:
				{
					AllocatorType<array_t> alloc;
					std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
					std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
					break;
				}

				case value_t::string:
				{
					AllocatorType<string_t> alloc;
					std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
					std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
					break;
				}

				default:
				{
					break;
				}
				}
			}
		};

		/*!
		@brief checks the class invariants

		This function asserts the class invariants. It needs to be called at the
		end of every constructor to make sure that created objects respect the
		invariant. Furthermore, it has to be called each time the type of a JSON
		value is changed, because the invariant expresses a relationship between
		@a m_type and @a m_value.
		*/
		void assert_invariant() const noexcept
		{
			assert(m_type != value_t::object or m_value.object != nullptr);
			assert(m_type != value_t::array or m_value.array != nullptr);
			assert(m_type != value_t::string or m_value.string != nullptr);
		}

	public:
		//////////////////////////
		// JSON parser callback //
		//////////////////////////

		/*!
		@brief parser event types

		The parser callback distinguishes the following events:
		- `object_start`: the parser read `{` and started to process a JSON object
		- `key`: the parser read a key of a value in an object
		- `object_end`: the parser read `}` and finished processing a JSON object
		- `array_start`: the parser read `[` and started to process a JSON array
		- `array_end`: the parser read `]` and finished processing a JSON array
		- `value`: the parser finished reading a JSON value

		@image html callback_events.png "Example when certain parse events are triggered"

		@sa @ref parser_callback_t for more information and examples
		*/
		using parse_event_t = typename parser::parse_event_t;

		/*!
		@brief per-element parser callback type

		With a parser callback function, the result of parsing a JSON text can be
		influenced. When passed to @ref parse, it is called on certain events
		(passed as @ref parse_event_t via parameter @a event) with a set recursion
		depth @a depth and context JSON value @a parsed. The return value of the
		callback function is a boolean indicating whether the element that emitted
		the callback shall be kept or not.

		We distinguish six scenarios (determined by the event type) in which the
		callback function can be called. The following table describes the values
		of the parameters @a depth, @a event, and @a parsed.

		parameter @a event | description | parameter @a depth | parameter @a parsed
		------------------ | ----------- | ------------------ | -------------------
		parse_event_t::object_start | the parser read `{` and started to process a JSON object | depth of the parent of the JSON object | a JSON value with type discarded
		parse_event_t::key | the parser read a key of a value in an object | depth of the currently parsed JSON object | a JSON string containing the key
		parse_event_t::object_end | the parser read `}` and finished processing a JSON object | depth of the parent of the JSON object | the parsed JSON object
		parse_event_t::array_start | the parser read `[` and started to process a JSON array | depth of the parent of the JSON array | a JSON value with type discarded
		parse_event_t::array_end | the parser read `]` and finished processing a JSON array | depth of the parent of the JSON array | the parsed JSON array
		parse_event_t::value | the parser finished reading a JSON value | depth of the value | the parsed JSON value

		@image html callback_events.png "Example when certain parse events are triggered"

		Discarding a value (i.e., returning `false`) has different effects
		depending on the context in which function was called:

		- Discarded values in structured types are skipped. That is, the parser
		  will behave as if the discarded value was never read.
		- In case a value outside a structured type is skipped, it is replaced
		  with `null`. This case happens if the top-level element is skipped.

		@param[in] depth  the depth of the recursion during parsing

		@param[in] event  an event of type parse_event_t indicating the context in
		the callback function has been called

		@param[in,out] parsed  the current intermediate parse result; note that
		writing to this value has no effect for parse_event_t::key events

		@return Whether the JSON value which called the function during parsing
		should be kept (`true`) or not (`false`). In the latter case, it is either
		skipped completely or replaced by an empty discarded object.

		@sa @ref parse for examples

		@since version 1.0.0
		*/
		using parser_callback_t = typename parser::parser_callback_t;

		//////////////////
		// constructors //
		//////////////////

		/// @name constructors and destructors
		/// Constructors of class @ref basic_json, copy/move constructor, copy
		/// assignment, static functions creating objects, and the destructor.
		/// @{

		/*!
		@brief create an empty value with a given type

		Create an empty JSON value with a given type. The value will be default
		initialized with an empty value which depends on the type:

		Value type  | initial value
		----------- | -------------
		null        | `null`
		boolean     | `false`
		string      | `""`
		number      | `0`
		object      | `{}`
		array       | `[]`

		@param[in] v  the type of the value to create

		@complexity Constant.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@liveexample{The following code shows the constructor for different @ref
		value_t values,basic_json__value_t}

		@sa @ref clear() -- restores the postcondition of this constructor

		@since version 1.0.0
		*/
		basic_json(const value_t v)
			: m_type(v), m_value(v)
		{
			assert_invariant();
		}

		/*!
		@brief create a null object

		Create a `null` JSON value. It either takes a null pointer as parameter
		(explicitly creating `null`) or no parameter (implicitly creating `null`).
		The passed null pointer itself is not read -- it is only used to choose
		the right constructor.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this constructor never throws
		exceptions.

		@liveexample{The following code shows the constructor with and without a
		null pointer parameter.,basic_json__nullptr_t}

		@since version 1.0.0
		*/
		basic_json(std::nullptr_t = nullptr) noexcept
			: basic_json(value_t::null)
		{
			assert_invariant();
		}

		/*!
		@brief create a JSON value

		This is a "catch all" constructor for all compatible JSON types; that is,
		types for which a `to_json()` method exists. The constructor forwards the
		parameter @a val to that method (to `json_serializer<U>::to_json` method
		with `U = uncvref_t<CompatibleType>`, to be exact).

		Template type @a CompatibleType includes, but is not limited to, the
		following types:
		- **arrays**: @ref array_t and all kinds of compatible containers such as
		  `std::vector`, `std::deque`, `std::list`, `std::forward_list`,
		  `std::array`, `std::valarray`, `std::set`, `std::unordered_set`,
		  `std::multiset`, and `std::unordered_multiset` with a `value_type` from
		  which a @ref basic_json value can be constructed.
		- **objects**: @ref object_t and all kinds of compatible associative
		  containers such as `std::map`, `std::unordered_map`, `std::multimap`,
		  and `std::unordered_multimap` with a `key_type` compatible to
		  @ref string_t and a `value_type` from which a @ref basic_json value can
		  be constructed.
		- **strings**: @ref string_t, string literals, and all compatible string
		  containers can be used.
		- **numbers**: @ref number_integer_t, @ref number_unsigned_t,
		  @ref number_float_t, and all convertible number types such as `int`,
		  `size_t`, `int64_t`, `float` or `double` can be used.
		- **boolean**: @ref boolean_t / `bool` can be used.

		See the examples below.

		@tparam CompatibleType a type such that:
		- @a CompatibleType is not derived from `std::istream`,
		- @a CompatibleType is not @ref basic_json (to avoid hijacking copy/move
			 constructors),
		- @a CompatibleType is not a different @ref basic_json type (i.e. with different template arguments)
		- @a CompatibleType is not a @ref basic_json nested type (e.g.,
			 @ref json_pointer, @ref iterator, etc ...)
		- @ref @ref json_serializer<U> has a
			 `to_json(basic_json_t&, CompatibleType&&)` method

		@tparam U = `uncvref_t<CompatibleType>`

		@param[in] val the value to be forwarded to the respective constructor

		@complexity Usually linear in the size of the passed @a val, also
					depending on the implementation of the called `to_json()`
					method.

		@exceptionsafety Depends on the called constructor. For types directly
		supported by the library (i.e., all types for which no `to_json()` function
		was provided), strong guarantee holds: if an exception is thrown, there are
		no changes to any JSON value.

		@liveexample{The following code shows the constructor with several
		compatible types.,basic_json__CompatibleType}

		@since version 2.1.0
		*/
		template <typename CompatibleType,
			typename U = detail::uncvref_t<CompatibleType>,
			detail::enable_if_t<
			not detail::is_basic_json<U>::value and detail::is_compatible_type<basic_json_t, U>::value, int> = 0>
			basic_json(CompatibleType && val) noexcept(noexcept(
				JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),
					std::forward<CompatibleType>(val))))
		{
			JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
			assert_invariant();
		}

		/*!
		@brief create a JSON value from an existing one

		This is a constructor for existing @ref basic_json types.
		It does not hijack copy/move constructors, since the parameter has different
		template arguments than the current ones.

		The constructor tries to convert the internal @ref m_value of the parameter.

		@tparam BasicJsonType a type such that:
		- @a BasicJsonType is a @ref basic_json type.
		- @a BasicJsonType has different template arguments than @ref basic_json_t.

		@param[in] val the @ref basic_json value to be converted.

		@complexity Usually linear in the size of the passed @a val, also
					depending on the implementation of the called `to_json()`
					method.

		@exceptionsafety Depends on the called constructor. For types directly
		supported by the library (i.e., all types for which no `to_json()` function
		was provided), strong guarantee holds: if an exception is thrown, there are
		no changes to any JSON value.

		@since version 3.2.0
		*/
		template <typename BasicJsonType,
			detail::enable_if_t<
			detail::is_basic_json<BasicJsonType>::value and not std::is_same<basic_json, BasicJsonType>::value, int> = 0>
			basic_json(const BasicJsonType& val)
		{
			using other_boolean_t = typename BasicJsonType::boolean_t;
			using other_number_float_t = typename BasicJsonType::number_float_t;
			using other_number_integer_t = typename BasicJsonType::number_integer_t;
			using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using other_string_t = typename BasicJsonType::string_t;
			using other_object_t = typename BasicJsonType::object_t;
			using other_array_t = typename BasicJsonType::array_t;

			switch (val.type())
			{
			case value_t::boolean:
				JSONSerializer<other_boolean_t>::to_json(*this, val.template get<other_boolean_t>());
				break;
			case value_t::number_float:
				JSONSerializer<other_number_float_t>::to_json(*this, val.template get<other_number_float_t>());
				break;
			case value_t::number_integer:
				JSONSerializer<other_number_integer_t>::to_json(*this, val.template get<other_number_integer_t>());
				break;
			case value_t::number_unsigned:
				JSONSerializer<other_number_unsigned_t>::to_json(*this, val.template get<other_number_unsigned_t>());
				break;
			case value_t::string:
				JSONSerializer<other_string_t>::to_json(*this, val.template get_ref<const other_string_t&>());
				break;
			case value_t::object:
				JSONSerializer<other_object_t>::to_json(*this, val.template get_ref<const other_object_t&>());
				break;
			case value_t::array:
				JSONSerializer<other_array_t>::to_json(*this, val.template get_ref<const other_array_t&>());
				break;
			case value_t::null:
				*this = nullptr;
				break;
			case value_t::discarded:
				m_type = value_t::discarded;
				break;
			}
			assert_invariant();
		}

		/*!
		@brief create a container (array or object) from an initializer list

		Creates a JSON value of type array or object from the passed initializer
		list @a init. In case @a type_deduction is `true` (default), the type of
		the JSON value to be created is deducted from the initializer list @a init
		according to the following rules:

		1. If the list is empty, an empty JSON object value `{}` is created.
		2. If the list consists of pairs whose first element is a string, a JSON
		   object value is created where the first elements of the pairs are
		   treated as keys and the second elements are as values.
		3. In all other cases, an array is created.

		The rules aim to create the best fit between a C++ initializer list and
		JSON values. The rationale is as follows:

		1. The empty initializer list is written as `{}` which is exactly an empty
		   JSON object.
		2. C++ has no way of describing mapped types other than to list a list of
		   pairs. As JSON requires that keys must be of type string, rule 2 is the
		   weakest constraint one can pose on initializer lists to interpret them
		   as an object.
		3. In all other cases, the initializer list could not be interpreted as
		   JSON object type, so interpreting it as JSON array type is safe.

		With the rules described above, the following JSON values cannot be
		expressed by an initializer list:

		- the empty array (`[]`): use @ref array(initializer_list_t)
		  with an empty initializer list in this case
		- arrays whose elements satisfy rule 2: use @ref
		  array(initializer_list_t) with the same initializer list
		  in this case

		@note When used without parentheses around an empty initializer list, @ref
		basic_json() is called instead of this function, yielding the JSON null
		value.

		@param[in] init  initializer list with JSON values

		@param[in] type_deduction internal parameter; when set to `true`, the type
		of the JSON value is deducted from the initializer list @a init; when set
		to `false`, the type provided via @a manual_type is forced. This mode is
		used by the functions @ref array(initializer_list_t) and
		@ref object(initializer_list_t).

		@param[in] manual_type internal parameter; when @a type_deduction is set
		to `false`, the created JSON value will use the provided type (only @ref
		value_t::array and @ref value_t::object are valid); when @a type_deduction
		is set to `true`, this parameter has no effect

		@throw type_error.301 if @a type_deduction is `false`, @a manual_type is
		`value_t::object`, but @a init contains an element which is not a pair
		whose first element is a string. In this case, the constructor could not
		create an object. If @a type_deduction would have be `true`, an array
		would have been created. See @ref object(initializer_list_t)
		for an example.

		@complexity Linear in the size of the initializer list @a init.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@liveexample{The example below shows how JSON values are created from
		initializer lists.,basic_json__list_init_t}

		@sa @ref array(initializer_list_t) -- create a JSON array
		value from an initializer list
		@sa @ref object(initializer_list_t) -- create a JSON object
		value from an initializer list

		@since version 1.0.0
		*/
		basic_json(initializer_list_t init,
			bool type_deduction = true,
			value_t manual_type = value_t::array)
		{
			// check if each element is an array with two elements whose first
			// element is a string
			bool is_an_object = std::all_of(init.begin(), init.end(),
				[](const detail::json_ref<basic_json>& element_ref)
			{
				return (element_ref->is_array() and element_ref->size() == 2 and (*element_ref)[0].is_string());
			});

			// adjust type if type deduction is not wanted
			if (not type_deduction)
			{
				// if array is wanted, do not create an object though possible
				if (manual_type == value_t::array)
				{
					is_an_object = false;
				}

				// if object is wanted but impossible, throw an exception
				if (JSON_UNLIKELY(manual_type == value_t::object and not is_an_object))
				{
					JSON_THROW(type_error::create(301, "cannot create object from initializer list"));
				}
			}

			if (is_an_object)
			{
				// the initializer list is a list of pairs -> create object
				m_type = value_t::object;
				m_value = value_t::object;

				std::for_each(init.begin(), init.end(), [this](const detail::json_ref<basic_json>& element_ref)
				{
					auto element = element_ref.moved_or_copied();
					m_value.object->emplace(
						std::move(*((*element.m_value.array)[0].m_value.string)),
						std::move((*element.m_value.array)[1]));
				});
			}
			else
			{
				// the initializer list describes an array -> create array
				m_type = value_t::array;
				m_value.array = create<array_t>(init.begin(), init.end());
			}

			assert_invariant();
		}

		/*!
		@brief explicitly create an array from an initializer list

		Creates a JSON array value from a given initializer list. That is, given a
		list of values `a, b, c`, creates the JSON value `[a, b, c]`. If the
		initializer list is empty, the empty array `[]` is created.

		@note This function is only needed to express two edge cases that cannot
		be realized with the initializer list constructor (@ref
		basic_json(initializer_list_t, bool, value_t)). These cases
		are:
		1. creating an array whose elements are all pairs whose first element is a
		string -- in this case, the initializer list constructor would create an
		object, taking the first elements as keys
		2. creating an empty array -- passing the empty initializer list to the
		initializer list constructor yields an empty object

		@param[in] init  initializer list with JSON values to create an array from
		(optional)

		@return JSON array value

		@complexity Linear in the size of @a init.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@liveexample{The following code shows an example for the `array`
		function.,array}

		@sa @ref basic_json(initializer_list_t, bool, value_t) --
		create a JSON value from an initializer list
		@sa @ref object(initializer_list_t) -- create a JSON object
		value from an initializer list

		@since version 1.0.0
		*/
		static basic_json array(initializer_list_t init = {})
		{
			return basic_json(init, false, value_t::array);
		}

		/*!
		@brief explicitly create an object from an initializer list

		Creates a JSON object value from a given initializer list. The initializer
		lists elements must be pairs, and their first elements must be strings. If
		the initializer list is empty, the empty object `{}` is created.

		@note This function is only added for symmetry reasons. In contrast to the
		related function @ref array(initializer_list_t), there are
		no cases which can only be expressed by this function. That is, any
		initializer list @a init can also be passed to the initializer list
		constructor @ref basic_json(initializer_list_t, bool, value_t).

		@param[in] init  initializer list to create an object from (optional)

		@return JSON object value

		@throw type_error.301 if @a init is not a list of pairs whose first
		elements are strings. In this case, no object can be created. When such a
		value is passed to @ref basic_json(initializer_list_t, bool, value_t),
		an array would have been created from the passed initializer list @a init.
		See example below.

		@complexity Linear in the size of @a init.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@liveexample{The following code shows an example for the `object`
		function.,object}

		@sa @ref basic_json(initializer_list_t, bool, value_t) --
		create a JSON value from an initializer list
		@sa @ref array(initializer_list_t) -- create a JSON array
		value from an initializer list

		@since version 1.0.0
		*/
		static basic_json object(initializer_list_t init = {})
		{
			return basic_json(init, false, value_t::object);
		}

		/*!
		@brief construct an array with count copies of given value

		Constructs a JSON array value by creating @a cnt copies of a passed value.
		In case @a cnt is `0`, an empty array is created.

		@param[in] cnt  the number of JSON copies of @a val to create
		@param[in] val  the JSON value to copy

		@post `std::distance(begin(),end()) == cnt` holds.

		@complexity Linear in @a cnt.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@liveexample{The following code shows examples for the @ref
		basic_json(size_type\, const basic_json&)
		constructor.,basic_json__size_type_basic_json}

		@since version 1.0.0
		*/
		basic_json(size_type cnt, const basic_json& val)
			: m_type(value_t::array)
		{
			m_value.array = create<array_t>(cnt, val);
			assert_invariant();
		}

		/*!
		@brief construct a JSON container given an iterator range

		Constructs the JSON value with the contents of the range `[first, last)`.
		The semantics depends on the different types a JSON value can have:
		- In case of a null type, invalid_iterator.206 is thrown.
		- In case of other primitive types (number, boolean, or string), @a first
		  must be `begin()` and @a last must be `end()`. In this case, the value is
		  copied. Otherwise, invalid_iterator.204 is thrown.
		- In case of structured types (array, object), the constructor behaves as
		  similar versions for `std::vector` or `std::map`; that is, a JSON array
		  or object is constructed from the values in the range.

		@tparam InputIT an input iterator type (@ref iterator or @ref
		const_iterator)

		@param[in] first begin of the range to copy from (included)
		@param[in] last end of the range to copy from (excluded)

		@pre Iterators @a first and @a last must be initialized. **This
			 precondition is enforced with an assertion (see warning).** If
			 assertions are switched off, a violation of this precondition yields
			 undefined behavior.

		@pre Range `[first, last)` is valid. Usually, this precondition cannot be
			 checked efficiently. Only certain edge cases are detected; see the
			 description of the exceptions below. A violation of this precondition
			 yields undefined behavior.

		@warning A precondition is enforced with a runtime assertion that will
				 result in calling `std::abort` if this precondition is not met.
				 Assertions can be disabled by defining `NDEBUG` at compile time.
				 See https://en.cppreference.com/w/cpp/error/assert for more
				 information.

		@throw invalid_iterator.201 if iterators @a first and @a last are not
		compatible (i.e., do not belong to the same JSON value). In this case,
		the range `[first, last)` is undefined.
		@throw invalid_iterator.204 if iterators @a first and @a last belong to a
		primitive type (number, boolean, or string), but @a first does not point
		to the first element any more. In this case, the range `[first, last)` is
		undefined. See example code below.
		@throw invalid_iterator.206 if iterators @a first and @a last belong to a
		null value. In this case, the range `[first, last)` is undefined.

		@complexity Linear in distance between @a first and @a last.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@liveexample{The example below shows several ways to create JSON values by
		specifying a subrange with iterators.,basic_json__InputIt_InputIt}

		@since version 1.0.0
		*/
		template<class InputIT, typename std::enable_if<
			std::is_same<InputIT, typename basic_json_t::iterator>::value or
			std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int>::type = 0>
			basic_json(InputIT first, InputIT last)
		{
			assert(first.m_object != nullptr);
			assert(last.m_object != nullptr);

			// make sure iterator fits the current value
			if (JSON_UNLIKELY(first.m_object != last.m_object))
			{
				JSON_THROW(invalid_iterator::create(201, "iterators are not compatible"));
			}

			// copy type from first iterator
			m_type = first.m_object->m_type;

			// check if iterator range is complete for primitive values
			switch (m_type)
			{
			case value_t::boolean:
			case value_t::number_float:
			case value_t::number_integer:
			case value_t::number_unsigned:
			case value_t::string:
			{
				if (JSON_UNLIKELY(not first.m_it.primitive_iterator.is_begin()
					or not last.m_it.primitive_iterator.is_end()))
				{
					JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
				}
				break;
			}

			default:
				break;
			}

			switch (m_type)
			{
			case value_t::number_integer:
			{
				m_value.number_integer = first.m_object->m_value.number_integer;
				break;
			}

			case value_t::number_unsigned:
			{
				m_value.number_unsigned = first.m_object->m_value.number_unsigned;
				break;
			}

			case value_t::number_float:
			{
				m_value.number_float = first.m_object->m_value.number_float;
				break;
			}

			case value_t::boolean:
			{
				m_value.boolean = first.m_object->m_value.boolean;
				break;
			}

			case value_t::string:
			{
				m_value = *first.m_object->m_value.string;
				break;
			}

			case value_t::object:
			{
				m_value.object = create<object_t>(first.m_it.object_iterator,
					last.m_it.object_iterator);
				break;
			}

			case value_t::array:
			{
				m_value.array = create<array_t>(first.m_it.array_iterator,
					last.m_it.array_iterator);
				break;
			}

			default:
				JSON_THROW(invalid_iterator::create(206, "cannot construct with iterators from " +
					std::string(first.m_object->type_name())));
			}

			assert_invariant();
		}


		///////////////////////////////////////
		// other constructors and destructor //
		///////////////////////////////////////

		/// @private
		basic_json(const detail::json_ref<basic_json>& ref)
			: basic_json(ref.moved_or_copied())
		{}

		/*!
		@brief copy constructor

		Creates a copy of a given JSON value.

		@param[in] other  the JSON value to copy

		@post `*this == other`

		@complexity Linear in the size of @a other.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is linear.
		- As postcondition, it holds: `other == basic_json(other)`.

		@liveexample{The following code shows an example for the copy
		constructor.,basic_json__basic_json}

		@since version 1.0.0
		*/
		basic_json(const basic_json& other)
			: m_type(other.m_type)
		{
			// check of passed value is valid
			other.assert_invariant();

			switch (m_type)
			{
			case value_t::object:
			{
				m_value = *other.m_value.object;
				break;
			}

			case value_t::array:
			{
				m_value = *other.m_value.array;
				break;
			}

			case value_t::string:
			{
				m_value = *other.m_value.string;
				break;
			}

			case value_t::boolean:
			{
				m_value = other.m_value.boolean;
				break;
			}

			case value_t::number_integer:
			{
				m_value = other.m_value.number_integer;
				break;
			}

			case value_t::number_unsigned:
			{
				m_value = other.m_value.number_unsigned;
				break;
			}

			case value_t::number_float:
			{
				m_value = other.m_value.number_float;
				break;
			}

			default:
				break;
			}

			assert_invariant();
		}

		/*!
		@brief move constructor

		Move constructor. Constructs a JSON value with the contents of the given
		value @a other using move semantics. It "steals" the resources from @a
		other and leaves it as JSON null value.

		@param[in,out] other  value to move to this object

		@post `*this` has the same value as @a other before the call.
		@post @a other is a JSON null value.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this constructor never throws
		exceptions.

		@requirement This function helps `basic_json` satisfying the
		[MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible)
		requirements.

		@liveexample{The code below shows the move constructor explicitly called
		via std::move.,basic_json__moveconstructor}

		@since version 1.0.0
		*/
		basic_json(basic_json&& other) noexcept
			: m_type(std::move(other.m_type)),
			m_value(std::move(other.m_value))
		{
			// check that passed value is valid
			other.assert_invariant();

			// invalidate payload
			other.m_type = value_t::null;
			other.m_value = {};

			assert_invariant();
		}

		/*!
		@brief copy assignment

		Copy assignment operator. Copies a JSON value via the "copy and swap"
		strategy: It is expressed in terms of the copy constructor, destructor,
		and the `swap()` member function.

		@param[in] other  value to copy from

		@complexity Linear.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is linear.

		@liveexample{The code below shows and example for the copy assignment. It
		creates a copy of value `a` which is then swapped with `b`. Finally\, the
		copy of `a` (which is the null value after the swap) is
		destroyed.,basic_json__copyassignment}

		@since version 1.0.0
		*/
		reference& operator=(basic_json other) noexcept (
			std::is_nothrow_move_constructible<value_t>::value and
			std::is_nothrow_move_assignable<value_t>::value and
			std::is_nothrow_move_constructible<json_value>::value and
			std::is_nothrow_move_assignable<json_value>::value
			)
		{
			// check that passed value is valid
			other.assert_invariant();

			using std::swap;
			swap(m_type, other.m_type);
			swap(m_value, other.m_value);

			assert_invariant();
			return *this;
		}

		/*!
		@brief destructor

		Destroys the JSON value and frees all allocated memory.

		@complexity Linear.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is linear.
		- All stored elements are destroyed and all memory is freed.

		@since version 1.0.0
		*/
		~basic_json() noexcept
		{
			assert_invariant();
			m_value.destroy(m_type);
		}

		/// @}

	public:
		///////////////////////
		// object inspection //
		///////////////////////

		/// @name object inspection
		/// Functions to inspect the type of a JSON value.
		/// @{

		/*!
		@brief serialization

		Serialization function for JSON values. The function tries to mimic
		Python's `json.dumps()` function, and currently supports its @a indent
		and @a ensure_ascii parameters.

		@param[in] indent If indent is nonnegative, then array elements and object
		members will be pretty-printed with that indent level. An indent level of
		`0` will only insert newlines. `-1` (the default) selects the most compact
		representation.
		@param[in] indent_char The character to use for indentation if @a indent is
		greater than `0`. The default is ` ` (space).
		@param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
		in the output are escaped with `\uXXXX` sequences, and the result consists
		of ASCII characters only.

		@return string containing the serialization of the JSON value

		@throw type_error.316 if a string stored inside the JSON value is not
							  UTF-8 encoded

		@complexity Linear.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@liveexample{The following example shows the effect of different @a indent\,
		@a indent_char\, and @a ensure_ascii parameters to the result of the
		serialization.,dump}

		@see https://docs.python.org/2/library/json.html#json.dump

		@since version 1.0.0; indentation character @a indent_char, option
			   @a ensure_ascii and exceptions added in version 3.0.0
		*/
		string_t dump(const int indent = -1, const char indent_char = ' ',
			const bool ensure_ascii = false) const
		{
			string_t result;
			serializer s(detail::output_adapter<char, string_t>(result), indent_char);

			if (indent >= 0)
			{
				s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
			}
			else
			{
				s.dump(*this, false, ensure_ascii, 0);
			}

			return result;
		}

		/*!
		@brief return the type of the JSON value (explicit)

		Return the type of the JSON value as a value from the @ref value_t
		enumeration.

		@return the type of the JSON value
				Value type                | return value
				------------------------- | -------------------------
				null                      | value_t::null
				boolean                   | value_t::boolean
				string                    | value_t::string
				number (integer)          | value_t::number_integer
				number (unsigned integer) | value_t::number_unsigned
				number (floating-point)   | value_t::number_float
				object                    | value_t::object
				array                     | value_t::array
				discarded                 | value_t::discarded

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `type()` for all JSON
		types.,type}

		@sa @ref operator value_t() -- return the type of the JSON value (implicit)
		@sa @ref type_name() -- return the type as string

		@since version 1.0.0
		*/
		constexpr value_t type() const noexcept
		{
			return m_type;
		}

		/*!
		@brief return whether type is primitive

		This function returns true if and only if the JSON type is primitive
		(string, number, boolean, or null).

		@return `true` if type is primitive (string, number, boolean, or null),
		`false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_primitive()` for all JSON
		types.,is_primitive}

		@sa @ref is_structured() -- returns whether JSON value is structured
		@sa @ref is_null() -- returns whether JSON value is `null`
		@sa @ref is_string() -- returns whether JSON value is a string
		@sa @ref is_boolean() -- returns whether JSON value is a boolean
		@sa @ref is_number() -- returns whether JSON value is a number

		@since version 1.0.0
		*/
		constexpr bool is_primitive() const noexcept
		{
			return is_null() or is_string() or is_boolean() or is_number();
		}

		/*!
		@brief return whether type is structured

		This function returns true if and only if the JSON type is structured
		(array or object).

		@return `true` if type is structured (array or object), `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_structured()` for all JSON
		types.,is_structured}

		@sa @ref is_primitive() -- returns whether value is primitive
		@sa @ref is_array() -- returns whether value is an array
		@sa @ref is_object() -- returns whether value is an object

		@since version 1.0.0
		*/
		constexpr bool is_structured() const noexcept
		{
			return is_array() or is_object();
		}

		/*!
		@brief return whether value is null

		This function returns true if and only if the JSON value is null.

		@return `true` if type is null, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_null()` for all JSON
		types.,is_null}

		@since version 1.0.0
		*/
		constexpr bool is_null() const noexcept
		{
			return (m_type == value_t::null);
		}

		/*!
		@brief return whether value is a boolean

		This function returns true if and only if the JSON value is a boolean.

		@return `true` if type is boolean, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_boolean()` for all JSON
		types.,is_boolean}

		@since version 1.0.0
		*/
		constexpr bool is_boolean() const noexcept
		{
			return (m_type == value_t::boolean);
		}

		/*!
		@brief return whether value is a number

		This function returns true if and only if the JSON value is a number. This
		includes both integer (signed and unsigned) and floating-point values.

		@return `true` if type is number (regardless whether integer, unsigned
		integer or floating-type), `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_number()` for all JSON
		types.,is_number}

		@sa @ref is_number_integer() -- check if value is an integer or unsigned
		integer number
		@sa @ref is_number_unsigned() -- check if value is an unsigned integer
		number
		@sa @ref is_number_float() -- check if value is a floating-point number

		@since version 1.0.0
		*/
		constexpr bool is_number() const noexcept
		{
			return is_number_integer() or is_number_float();
		}

		/*!
		@brief return whether value is an integer number

		This function returns true if and only if the JSON value is a signed or
		unsigned integer number. This excludes floating-point values.

		@return `true` if type is an integer or unsigned integer number, `false`
		otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_number_integer()` for all
		JSON types.,is_number_integer}

		@sa @ref is_number() -- check if value is a number
		@sa @ref is_number_unsigned() -- check if value is an unsigned integer
		number
		@sa @ref is_number_float() -- check if value is a floating-point number

		@since version 1.0.0
		*/
		constexpr bool is_number_integer() const noexcept
		{
			return (m_type == value_t::number_integer or m_type == value_t::number_unsigned);
		}

		/*!
		@brief return whether value is an unsigned integer number

		This function returns true if and only if the JSON value is an unsigned
		integer number. This excludes floating-point and signed integer values.

		@return `true` if type is an unsigned integer number, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_number_unsigned()` for all
		JSON types.,is_number_unsigned}

		@sa @ref is_number() -- check if value is a number
		@sa @ref is_number_integer() -- check if value is an integer or unsigned
		integer number
		@sa @ref is_number_float() -- check if value is a floating-point number

		@since version 2.0.0
		*/
		constexpr bool is_number_unsigned() const noexcept
		{
			return (m_type == value_t::number_unsigned);
		}

		/*!
		@brief return whether value is a floating-point number

		This function returns true if and only if the JSON value is a
		floating-point number. This excludes signed and unsigned integer values.

		@return `true` if type is a floating-point number, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_number_float()` for all
		JSON types.,is_number_float}

		@sa @ref is_number() -- check if value is number
		@sa @ref is_number_integer() -- check if value is an integer number
		@sa @ref is_number_unsigned() -- check if value is an unsigned integer
		number

		@since version 1.0.0
		*/
		constexpr bool is_number_float() const noexcept
		{
			return (m_type == value_t::number_float);
		}

		/*!
		@brief return whether value is an object

		This function returns true if and only if the JSON value is an object.

		@return `true` if type is object, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_object()` for all JSON
		types.,is_object}

		@since version 1.0.0
		*/
		constexpr bool is_object() const noexcept
		{
			return (m_type == value_t::object);
		}

		/*!
		@brief return whether value is an array

		This function returns true if and only if the JSON value is an array.

		@return `true` if type is array, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_array()` for all JSON
		types.,is_array}

		@since version 1.0.0
		*/
		constexpr bool is_array() const noexcept
		{
			return (m_type == value_t::array);
		}

		/*!
		@brief return whether value is a string

		This function returns true if and only if the JSON value is a string.

		@return `true` if type is string, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_string()` for all JSON
		types.,is_string}

		@since version 1.0.0
		*/
		constexpr bool is_string() const noexcept
		{
			return (m_type == value_t::string);
		}

		/*!
		@brief return whether value is discarded

		This function returns true if and only if the JSON value was discarded
		during parsing with a callback function (see @ref parser_callback_t).

		@note This function will always be `false` for JSON values after parsing.
		That is, discarded values can only occur during parsing, but will be
		removed when inside a structured value or replaced by null in other cases.

		@return `true` if type is discarded, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_discarded()` for all JSON
		types.,is_discarded}

		@since version 1.0.0
		*/
		constexpr bool is_discarded() const noexcept
		{
			return (m_type == value_t::discarded);
		}

		/*!
		@brief return the type of the JSON value (implicit)

		Implicitly return the type of the JSON value as a value from the @ref
		value_t enumeration.

		@return the type of the JSON value

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies the @ref value_t operator for
		all JSON types.,operator__value_t}

		@sa @ref type() -- return the type of the JSON value (explicit)
		@sa @ref type_name() -- return the type as string

		@since version 1.0.0
		*/
		constexpr operator value_t() const noexcept
		{
			return m_type;
		}

		/// @}

	private:
		//////////////////
		// value access //
		//////////////////

		/// get a boolean (explicit)
		boolean_t get_impl(boolean_t* /*unused*/) const
		{
			if (JSON_LIKELY(is_boolean()))
			{
				return m_value.boolean;
			}

			JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(type_name())));
		}

		/// get a pointer to the value (object)
		object_t* get_impl_ptr(object_t* /*unused*/) noexcept
		{
			return is_object() ? m_value.object : nullptr;
		}

		/// get a pointer to the value (object)
		constexpr const object_t* get_impl_ptr(const object_t* /*unused*/) const noexcept
		{
			return is_object() ? m_value.object : nullptr;
		}

		/// get a pointer to the value (array)
		array_t* get_impl_ptr(array_t* /*unused*/) noexcept
		{
			return is_array() ? m_value.array : nullptr;
		}

		/// get a pointer to the value (array)
		constexpr const array_t* get_impl_ptr(const array_t* /*unused*/) const noexcept
		{
			return is_array() ? m_value.array : nullptr;
		}

		/// get a pointer to the value (string)
		string_t* get_impl_ptr(string_t* /*unused*/) noexcept
		{
			return is_string() ? m_value.string : nullptr;
		}

		/// get a pointer to the value (string)
		constexpr const string_t* get_impl_ptr(const string_t* /*unused*/) const noexcept
		{
			return is_string() ? m_value.string : nullptr;
		}

		/// get a pointer to the value (boolean)
		boolean_t* get_impl_ptr(boolean_t* /*unused*/) noexcept
		{
			return is_boolean() ? &m_value.boolean : nullptr;
		}

		/// get a pointer to the value (boolean)
		constexpr const boolean_t* get_impl_ptr(const boolean_t* /*unused*/) const noexcept
		{
			return is_boolean() ? &m_value.boolean : nullptr;
		}

		/// get a pointer to the value (integer number)
		number_integer_t* get_impl_ptr(number_integer_t* /*unused*/) noexcept
		{
			return is_number_integer() ? &m_value.number_integer : nullptr;
		}

		/// get a pointer to the value (integer number)
		constexpr const number_integer_t* get_impl_ptr(const number_integer_t* /*unused*/) const noexcept
		{
			return is_number_integer() ? &m_value.number_integer : nullptr;
		}

		/// get a pointer to the value (unsigned number)
		number_unsigned_t* get_impl_ptr(number_unsigned_t* /*unused*/) noexcept
		{
			return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
		}

		/// get a pointer to the value (unsigned number)
		constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* /*unused*/) const noexcept
		{
			return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
		}

		/// get a pointer to the value (floating-point number)
		number_float_t* get_impl_ptr(number_float_t* /*unused*/) noexcept
		{
			return is_number_float() ? &m_value.number_float : nullptr;
		}

		/// get a pointer to the value (floating-point number)
		constexpr const number_float_t* get_impl_ptr(const number_float_t* /*unused*/) const noexcept
		{
			return is_number_float() ? &m_value.number_float : nullptr;
		}

		/*!
		@brief helper function to implement get_ref()

		This function helps to implement get_ref() without code duplication for
		const and non-const overloads

		@tparam ThisType will be deduced as `basic_json` or `const basic_json`

		@throw type_error.303 if ReferenceType does not match underlying value
		type of the current JSON
		*/
		template<typename ReferenceType, typename ThisType>
		static ReferenceType get_ref_impl(ThisType& obj)
		{
			// delegate the call to get_ptr<>()
			auto ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();

			if (JSON_LIKELY(ptr != nullptr))
			{
				return *ptr;
			}

			JSON_THROW(type_error::create(303, "incompatible ReferenceType for get_ref, actual type is " + std::string(obj.type_name())));
		}

	public:
		/// @name value access
		/// Direct access to the stored value of a JSON value.
		/// @{

		/*!
		@brief get special-case overload

		This overloads avoids a lot of template boilerplate, it can be seen as the
		identity method

		@tparam BasicJsonType == @ref basic_json

		@return a copy of *this

		@complexity Constant.

		@since version 2.1.0
		*/
		template<typename BasicJsonType, detail::enable_if_t<
			std::is_same<typename std::remove_const<BasicJsonType>::type, basic_json_t>::value,
			int> = 0>
			basic_json get() const
		{
			return *this;
		}

		/*!
		@brief get special-case overload

		This overloads converts the current @ref basic_json in a different
		@ref basic_json type

		@tparam BasicJsonType == @ref basic_json

		@return a copy of *this, converted into @tparam BasicJsonType

		@complexity Depending on the implementation of the called `from_json()`
					method.

		@since version 3.2.0
		*/
		template<typename BasicJsonType, detail::enable_if_t<
			not std::is_same<BasicJsonType, basic_json>::value and
			detail::is_basic_json<BasicJsonType>::value, int> = 0>
			BasicJsonType get() const
		{
			return *this;
		}

		/*!
		@brief get a value (explicit)

		Explicit type conversion between the JSON value and a compatible value
		which is [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
		and [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
		The value is converted by calling the @ref json_serializer<ValueType>
		`from_json()` method.

		The function is equivalent to executing
		@code {.cpp}
		ValueType ret;
		JSONSerializer<ValueType>::from_json(*this, ret);
		return ret;
		@endcode

		This overloads is chosen if:
		- @a ValueType is not @ref basic_json,
		- @ref json_serializer<ValueType> has a `from_json()` method of the form
		  `void from_json(const basic_json&, ValueType&)`, and
		- @ref json_serializer<ValueType> does not have a `from_json()` method of
		  the form `ValueType from_json(const basic_json&)`

		@tparam ValueTypeCV the provided value type
		@tparam ValueType the returned value type

		@return copy of the JSON value, converted to @a ValueType

		@throw what @ref json_serializer<ValueType> `from_json()` method throws

		@liveexample{The example below shows several conversions from JSON values
		to other types. There a few things to note: (1) Floating-point numbers can
		be converted to integers\, (2) A JSON array can be converted to a standard
		`std::vector<short>`\, (3) A JSON object can be converted to C++
		associative containers such as `std::unordered_map<std::string\,
		json>`.,get__ValueType_const}

		@since version 2.1.0
		*/
		template<typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
			detail::enable_if_t <
			not detail::is_basic_json<ValueType>::value and
			detail::has_from_json<basic_json_t, ValueType>::value and
			not detail::has_non_default_from_json<basic_json_t, ValueType>::value,
			int> = 0>
			ValueType get() const noexcept(noexcept(
				JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
		{
			// we cannot static_assert on ValueTypeCV being non-const, because
			// there is support for get<const basic_json_t>(), which is why we
			// still need the uncvref
			static_assert(not std::is_reference<ValueTypeCV>::value,
				"get() cannot be used with reference types, you might want to use get_ref()");
			static_assert(std::is_default_constructible<ValueType>::value,
				"types must be DefaultConstructible when used with get()");

			ValueType ret;
			JSONSerializer<ValueType>::from_json(*this, ret);
			return ret;
		}

		/*!
		@brief get a value (explicit); special case

		Explicit type conversion between the JSON value and a compatible value
		which is **not** [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
		and **not** [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
		The value is converted by calling the @ref json_serializer<ValueType>
		`from_json()` method.

		The function is equivalent to executing
		@code {.cpp}
		return JSONSerializer<ValueTypeCV>::from_json(*this);
		@endcode

		This overloads is chosen if:
		- @a ValueType is not @ref basic_json and
		- @ref json_serializer<ValueType> has a `from_json()` method of the form
		  `ValueType from_json(const basic_json&)`

		@note If @ref json_serializer<ValueType> has both overloads of
		`from_json()`, this one is chosen.

		@tparam ValueTypeCV the provided value type
		@tparam ValueType the returned value type

		@return copy of the JSON value, converted to @a ValueType

		@throw what @ref json_serializer<ValueType> `from_json()` method throws

		@since version 2.1.0
		*/
		template<typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
			detail::enable_if_t<not std::is_same<basic_json_t, ValueType>::value and
			detail::has_non_default_from_json<basic_json_t, ValueType>::value,
			int> = 0>
			ValueType get() const noexcept(noexcept(
				JSONSerializer<ValueTypeCV>::from_json(std::declval<const basic_json_t&>())))
		{
			static_assert(not std::is_reference<ValueTypeCV>::value,
				"get() cannot be used with reference types, you might want to use get_ref()");
			return JSONSerializer<ValueTypeCV>::from_json(*this);
		}

		/*!
		@brief get a value (explicit)

		Explicit type conversion between the JSON value and a compatible value.
		The value is filled into the input parameter by calling the @ref json_serializer<ValueType>
		`from_json()` method.

		The function is equivalent to executing
		@code {.cpp}
		ValueType v;
		JSONSerializer<ValueType>::from_json(*this, v);
		@endcode

		This overloads is chosen if:
		- @a ValueType is not @ref basic_json,
		- @ref json_serializer<ValueType> has a `from_json()` method of the form
		  `void from_json(const basic_json&, ValueType&)`, and

		@tparam ValueType the input parameter type.

		@return the input parameter, allowing chaining calls.

		@throw what @ref json_serializer<ValueType> `from_json()` method throws

		@liveexample{The example below shows several conversions from JSON values
		to other types. There a few things to note: (1) Floating-point numbers can
		be converted to integers\, (2) A JSON array can be converted to a standard
		`std::vector<short>`\, (3) A JSON object can be converted to C++
		associative containers such as `std::unordered_map<std::string\,
		json>`.,get_to}

		@since version 3.3.0
		*/
		template<typename ValueType,
			detail::enable_if_t <
			not detail::is_basic_json<ValueType>::value and
			detail::has_from_json<basic_json_t, ValueType>::value,
			int> = 0>
			ValueType & get_to(ValueType& v) const noexcept(noexcept(
				JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))
		{
			JSONSerializer<ValueType>::from_json(*this, v);
			return v;
		}


		/*!
		@brief get a pointer value (implicit)

		Implicit pointer access to the internally stored JSON value. No copies are
		made.

		@warning Writing data to the pointee of the result yields an undefined
		state.

		@tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
		object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
		@ref number_unsigned_t, or @ref number_float_t. Enforced by a static
		assertion.

		@return pointer to the internally stored JSON value if the requested
		pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

		@complexity Constant.

		@liveexample{The example below shows how pointers to internal values of a
		JSON value can be requested. Note that no type conversions are made and a
		`nullptr` is returned if the value and the requested pointer type does not
		match.,get_ptr}

		@since version 1.0.0
		*/
		template<typename PointerType, typename std::enable_if<
			std::is_pointer<PointerType>::value, int>::type = 0>
			auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
		{
			// delegate the call to get_impl_ptr<>()
			return get_impl_ptr(static_cast<PointerType>(nullptr));
		}

		/*!
		@brief get a pointer value (implicit)
		@copydoc get_ptr()
		*/
		template<typename PointerType, typename std::enable_if<
			std::is_pointer<PointerType>::value and
			std::is_const<typename std::remove_pointer<PointerType>::type>::value, int>::type = 0>
			constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
		{
			// delegate the call to get_impl_ptr<>() const
			return get_impl_ptr(static_cast<PointerType>(nullptr));
		}

		/*!
		@brief get a pointer value (explicit)

		Explicit pointer access to the internally stored JSON value. No copies are
		made.

		@warning The pointer becomes invalid if the underlying JSON object
		changes.

		@tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
		object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
		@ref number_unsigned_t, or @ref number_float_t.

		@return pointer to the internally stored JSON value if the requested
		pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

		@complexity Constant.

		@liveexample{The example below shows how pointers to internal values of a
		JSON value can be requested. Note that no type conversions are made and a
		`nullptr` is returned if the value and the requested pointer type does not
		match.,get__PointerType}

		@sa @ref get_ptr() for explicit pointer-member access

		@since version 1.0.0
		*/
		template<typename PointerType, typename std::enable_if<
			std::is_pointer<PointerType>::value, int>::type = 0>
			auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
		{
			// delegate the call to get_ptr
			return get_ptr<PointerType>();
		}

		/*!
		@brief get a pointer value (explicit)
		@copydoc get()
		*/
		template<typename PointerType, typename std::enable_if<
			std::is_pointer<PointerType>::value, int>::type = 0>
			constexpr auto get() const noexcept -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
		{
			// delegate the call to get_ptr
			return get_ptr<PointerType>();
		}

		/*!
		@brief get a reference value (implicit)

		Implicit reference access to the internally stored JSON value. No copies
		are made.

		@warning Writing data to the referee of the result yields an undefined
		state.

		@tparam ReferenceType reference type; must be a reference to @ref array_t,
		@ref object_t, @ref string_t, @ref boolean_t, @ref number_integer_t, or
		@ref number_float_t. Enforced by static assertion.

		@return reference to the internally stored JSON value if the requested
		reference type @a ReferenceType fits to the JSON value; throws
		type_error.303 otherwise

		@throw type_error.303 in case passed type @a ReferenceType is incompatible
		with the stored JSON value; see example below

		@complexity Constant.

		@liveexample{The example shows several calls to `get_ref()`.,get_ref}

		@since version 1.1.0
		*/
		template<typename ReferenceType, typename std::enable_if<
			std::is_reference<ReferenceType>::value, int>::type = 0>
			ReferenceType get_ref()
		{
			// delegate call to get_ref_impl
			return get_ref_impl<ReferenceType>(*this);
		}

		/*!
		@brief get a reference value (implicit)
		@copydoc get_ref()
		*/
		template<typename ReferenceType, typename std::enable_if<
			std::is_reference<ReferenceType>::value and
			std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int>::type = 0>
			ReferenceType get_ref() const
		{
			// delegate call to get_ref_impl
			return get_ref_impl<ReferenceType>(*this);
		}

		/*!
		@brief get a value (implicit)

		Implicit type conversion between the JSON value and a compatible value.
		The call is realized by calling @ref get() const.

		@tparam ValueType non-pointer type compatible to the JSON value, for
		instance `int` for JSON integer numbers, `bool` for JSON booleans, or
		`std::vector` types for JSON arrays. The character type of @ref string_t
		as well as an initializer list of this type is excluded to avoid
		ambiguities as these types implicitly convert to `std::string`.

		@return copy of the JSON value, converted to type @a ValueType

		@throw type_error.302 in case passed type @a ValueType is incompatible
		to the JSON value type (e.g., the JSON value is of type boolean, but a
		string is requested); see example below

		@complexity Linear in the size of the JSON value.

		@liveexample{The example below shows several conversions from JSON values
		to other types. There a few things to note: (1) Floating-point numbers can
		be converted to integers\, (2) A JSON array can be converted to a standard
		`std::vector<short>`\, (3) A JSON object can be converted to C++
		associative containers such as `std::unordered_map<std::string\,
		json>`.,operator__ValueType}

		@since version 1.0.0
		*/
		template < typename ValueType, typename std::enable_if <
			not std::is_pointer<ValueType>::value and
			not std::is_same<ValueType, detail::json_ref<basic_json>>::value and
			not std::is_same<ValueType, typename string_t::value_type>::value and
			not detail::is_basic_json<ValueType>::value

#ifndef _MSC_VER  // fix for issue #167 operator<< ambiguity under VS2015
			and not std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>::value
#if defined(JSON_HAS_CPP_17) && defined(_MSC_VER) and _MSC_VER <= 1914
			and not std::is_same<ValueType, typename std::string_view>::value
#endif
#endif
			and detail::is_detected<detail::get_template_function, const basic_json_t&, ValueType>::value
			, int >::type = 0 >
			operator ValueType() const
		{
			// delegate the call to get<>() const
			return get<ValueType>();
		}

		/// @}


		////////////////////
		// element access //
		////////////////////

		/// @name element access
		/// Access to the JSON value.
		/// @{

		/*!
		@brief access specified array element with bounds checking

		Returns a reference to the element at specified location @a idx, with
		bounds checking.

		@param[in] idx  index of the element to access

		@return reference to the element at index @a idx

		@throw type_error.304 if the JSON value is not an array; in this case,
		calling `at` with an index makes no sense. See example below.
		@throw out_of_range.401 if the index @a idx is out of range of the array;
		that is, `idx >= size()`. See example below.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Constant.

		@since version 1.0.0

		@liveexample{The example below shows how array elements can be read and
		written using `at()`. It also demonstrates the different exceptions that
		can be thrown.,at__size_type}
		*/
		reference at(size_type idx)
		{
			// at only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				JSON_TRY
				{
					return m_value.array->at(idx);
				}
					JSON_CATCH(std::out_of_range&)
				{
					// create better exception explanation
					JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
				}
			}
			else
			{
				JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
			}
		}

		/*!
		@brief access specified array element with bounds checking

		Returns a const reference to the element at specified location @a idx,
		with bounds checking.

		@param[in] idx  index of the element to access

		@return const reference to the element at index @a idx

		@throw type_error.304 if the JSON value is not an array; in this case,
		calling `at` with an index makes no sense. See example below.
		@throw out_of_range.401 if the index @a idx is out of range of the array;
		that is, `idx >= size()`. See example below.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Constant.

		@since version 1.0.0

		@liveexample{The example below shows how array elements can be read using
		`at()`. It also demonstrates the different exceptions that can be thrown.,
		at__size_type_const}
		*/
		const_reference at(size_type idx) const
		{
			// at only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				JSON_TRY
				{
					return m_value.array->at(idx);
				}
					JSON_CATCH(std::out_of_range&)
				{
					// create better exception explanation
					JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
				}
			}
			else
			{
				JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
			}
		}

		/*!
		@brief access specified object element with bounds checking

		Returns a reference to the element at with specified key @a key, with
		bounds checking.

		@param[in] key  key of the element to access

		@return reference to the element at key @a key

		@throw type_error.304 if the JSON value is not an object; in this case,
		calling `at` with a key makes no sense. See example below.
		@throw out_of_range.403 if the key @a key is is not stored in the object;
		that is, `find(key) == end()`. See example below.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Logarithmic in the size of the container.

		@sa @ref operator[](const typename object_t::key_type&) for unchecked
		access by reference
		@sa @ref value() for access by value with a default value

		@since version 1.0.0

		@liveexample{The example below shows how object elements can be read and
		written using `at()`. It also demonstrates the different exceptions that
		can be thrown.,at__object_t_key_type}
		*/
		reference at(const typename object_t::key_type& key)
		{
			// at only works for objects
			if (JSON_LIKELY(is_object()))
			{
				JSON_TRY
				{
					return m_value.object->at(key);
				}
					JSON_CATCH(std::out_of_range&)
				{
					// create better exception explanation
					JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
				}
			}
			else
			{
				JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
			}
		}

		/*!
		@brief access specified object element with bounds checking

		Returns a const reference to the element at with specified key @a key,
		with bounds checking.

		@param[in] key  key of the element to access

		@return const reference to the element at key @a key

		@throw type_error.304 if the JSON value is not an object; in this case,
		calling `at` with a key makes no sense. See example below.
		@throw out_of_range.403 if the key @a key is is not stored in the object;
		that is, `find(key) == end()`. See example below.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Logarithmic in the size of the container.

		@sa @ref operator[](const typename object_t::key_type&) for unchecked
		access by reference
		@sa @ref value() for access by value with a default value

		@since version 1.0.0

		@liveexample{The example below shows how object elements can be read using
		`at()`. It also demonstrates the different exceptions that can be thrown.,
		at__object_t_key_type_const}
		*/
		const_reference at(const typename object_t::key_type& key) const
		{
			// at only works for objects
			if (JSON_LIKELY(is_object()))
			{
				JSON_TRY
				{
					return m_value.object->at(key);
				}
					JSON_CATCH(std::out_of_range&)
				{
					// create better exception explanation
					JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
				}
			}
			else
			{
				JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
			}
		}

		/*!
		@brief access specified array element

		Returns a reference to the element at specified location @a idx.

		@note If @a idx is beyond the range of the array (i.e., `idx >= size()`),
		then the array is silently filled up with `null` values to make `idx` a
		valid reference to the last stored element.

		@param[in] idx  index of the element to access

		@return reference to the element at index @a idx

		@throw type_error.305 if the JSON value is not an array or null; in that
		cases, using the [] operator with an index makes no sense.

		@complexity Constant if @a idx is in the range of the array. Otherwise
		linear in `idx - size()`.

		@liveexample{The example below shows how array elements can be read and
		written using `[]` operator. Note the addition of `null`
		values.,operatorarray__size_type}

		@since version 1.0.0
		*/
		reference operator[](size_type idx)
		{
			// implicitly convert null value to an empty array
			if (is_null())
			{
				m_type = value_t::array;
				m_value.array = create<array_t>();
				assert_invariant();
			}

			// operator[] only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				// fill up array with null values if given idx is outside range
				if (idx >= m_value.array->size())
				{
					m_value.array->insert(m_value.array->end(),
						idx - m_value.array->size() + 1,
						basic_json());
				}

				return m_value.array->operator[](idx);
			}

			JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
		}

		/*!
		@brief access specified array element

		Returns a const reference to the element at specified location @a idx.

		@param[in] idx  index of the element to access

		@return const reference to the element at index @a idx

		@throw type_error.305 if the JSON value is not an array; in that case,
		using the [] operator with an index makes no sense.

		@complexity Constant.

		@liveexample{The example below shows how array elements can be read using
		the `[]` operator.,operatorarray__size_type_const}

		@since version 1.0.0
		*/
		const_reference operator[](size_type idx) const
		{
			// const operator[] only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				return m_value.array->operator[](idx);
			}

			JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
		}

		/*!
		@brief access specified object element

		Returns a reference to the element at with specified key @a key.

		@note If @a key is not found in the object, then it is silently added to
		the object and filled with a `null` value to make `key` a valid reference.
		In case the value was `null` before, it is converted to an object.

		@param[in] key  key of the element to access

		@return reference to the element at key @a key

		@throw type_error.305 if the JSON value is not an object or null; in that
		cases, using the [] operator with a key makes no sense.

		@complexity Logarithmic in the size of the container.

		@liveexample{The example below shows how object elements can be read and
		written using the `[]` operator.,operatorarray__key_type}

		@sa @ref at(const typename object_t::key_type&) for access by reference
		with range checking
		@sa @ref value() for access by value with a default value

		@since version 1.0.0
		*/
		reference operator[](const typename object_t::key_type& key)
		{
			// implicitly convert null value to an empty object
			if (is_null())
			{
				m_type = value_t::object;
				m_value.object = create<object_t>();
				assert_invariant();
			}

			// operator[] only works for objects
			if (JSON_LIKELY(is_object()))
			{
				return m_value.object->operator[](key);
			}

			JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
		}

		/*!
		@brief read-only access specified object element

		Returns a const reference to the element at with specified key @a key. No
		bounds checking is performed.

		@warning If the element with key @a key does not exist, the behavior is
		undefined.

		@param[in] key  key of the element to access

		@return const reference to the element at key @a key

		@pre The element with key @a key must exist. **This precondition is
			 enforced with an assertion.**

		@throw type_error.305 if the JSON value is not an object; in that case,
		using the [] operator with a key makes no sense.

		@complexity Logarithmic in the size of the container.

		@liveexample{The example below shows how object elements can be read using
		the `[]` operator.,operatorarray__key_type_const}

		@sa @ref at(const typename object_t::key_type&) for access by reference
		with range checking
		@sa @ref value() for access by value with a default value

		@since version 1.0.0
		*/
		const_reference operator[](const typename object_t::key_type& key) const
		{
			// const operator[] only works for objects
			if (JSON_LIKELY(is_object()))
			{
				assert(m_value.object->find(key) != m_value.object->end());
				return m_value.object->find(key)->second;
			}

			JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
		}

		/*!
		@brief access specified object element

		Returns a reference to the element at with specified key @a key.

		@note If @a key is not found in the object, then it is silently added to
		the object and filled with a `null` value to make `key` a valid reference.
		In case the value was `null` before, it is converted to an object.

		@param[in] key  key of the element to access

		@return reference to the element at key @a key

		@throw type_error.305 if the JSON value is not an object or null; in that
		cases, using the [] operator with a key makes no sense.

		@complexity Logarithmic in the size of the container.

		@liveexample{The example below shows how object elements can be read and
		written using the `[]` operator.,operatorarray__key_type}

		@sa @ref at(const typename object_t::key_type&) for access by reference
		with range checking
		@sa @ref value() for access by value with a default value

		@since version 1.1.0
		*/
		template<typename T>
		reference operator[](T* key)
		{
			// implicitly convert null to object
			if (is_null())
			{
				m_type = value_t::object;
				m_value = value_t::object;
				assert_invariant();
			}

			// at only works for objects
			if (JSON_LIKELY(is_object()))
			{
				return m_value.object->operator[](key);
			}

			JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
		}

		/*!
		@brief read-only access specified object element

		Returns a const reference to the element at with specified key @a key. No
		bounds checking is performed.

		@warning If the element with key @a key does not exist, the behavior is
		undefined.

		@param[in] key  key of the element to access

		@return const reference to the element at key @a key

		@pre The element with key @a key must exist. **This precondition is
			 enforced with an assertion.**

		@throw type_error.305 if the JSON value is not an object; in that case,
		using the [] operator with a key makes no sense.

		@complexity Logarithmic in the size of the container.

		@liveexample{The example below shows how object elements can be read using
		the `[]` operator.,operatorarray__key_type_const}

		@sa @ref at(const typename object_t::key_type&) for access by reference
		with range checking
		@sa @ref value() for access by value with a default value

		@since version 1.1.0
		*/
		template<typename T>
		const_reference operator[](T* key) const
		{
			// at only works for objects
			if (JSON_LIKELY(is_object()))
			{
				assert(m_value.object->find(key) != m_value.object->end());
				return m_value.object->find(key)->second;
			}

			JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
		}

		/*!
		@brief access specified object element with default value

		Returns either a copy of an object's element at the specified key @a key
		or a given default value if no element with key @a key exists.

		The function is basically equivalent to executing
		@code {.cpp}
		try {
			return at(key);
		} catch(out_of_range) {
			return default_value;
		}
		@endcode

		@note Unlike @ref at(const typename object_t::key_type&), this function
		does not throw if the given key @a key was not found.

		@note Unlike @ref operator[](const typename object_t::key_type& key), this
		function does not implicitly add an element to the position defined by @a
		key. This function is furthermore also applicable to const objects.

		@param[in] key  key of the element to access
		@param[in] default_value  the value to return if @a key is not found

		@tparam ValueType type compatible to JSON values, for instance `int` for
		JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
		JSON arrays. Note the type of the expected value at @a key and the default
		value @a default_value must be compatible.

		@return copy of the element at key @a key or @a default_value if @a key
		is not found

		@throw type_error.306 if the JSON value is not an object; in that case,
		using `value()` with a key makes no sense.

		@complexity Logarithmic in the size of the container.

		@liveexample{The example below shows how object elements can be queried
		with a default value.,basic_json__value}

		@sa @ref at(const typename object_t::key_type&) for access by reference
		with range checking
		@sa @ref operator[](const typename object_t::key_type&) for unchecked
		access by reference

		@since version 1.0.0
		*/
		template<class ValueType, typename std::enable_if<
			std::is_convertible<basic_json_t, ValueType>::value, int>::type = 0>
			ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
		{
			// at only works for objects
			if (JSON_LIKELY(is_object()))
			{
				// if key is found, return value and given default value otherwise
				const auto it = find(key);
				if (it != end())
				{
					return *it;
				}

				return default_value;
			}

			JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
		}

		/*!
		@brief overload for a default value of type const char*
		@copydoc basic_json::value(const typename object_t::key_type&, ValueType) const
		*/
		string_t value(const typename object_t::key_type& key, const char* default_value) const
		{
			return value(key, string_t(default_value));
		}

		/*!
		@brief access specified object element via JSON Pointer with default value

		Returns either a copy of an object's element at the specified key @a key
		or a given default value if no element with key @a key exists.

		The function is basically equivalent to executing
		@code {.cpp}
		try {
			return at(ptr);
		} catch(out_of_range) {
			return default_value;
		}
		@endcode

		@note Unlike @ref at(const json_pointer&), this function does not throw
		if the given key @a key was not found.

		@param[in] ptr  a JSON pointer to the element to access
		@param[in] default_value  the value to return if @a ptr found no value

		@tparam ValueType type compatible to JSON values, for instance `int` for
		JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
		JSON arrays. Note the type of the expected value at @a key and the default
		value @a default_value must be compatible.

		@return copy of the element at key @a key or @a default_value if @a key
		is not found

		@throw type_error.306 if the JSON value is not an object; in that case,
		using `value()` with a key makes no sense.

		@complexity Logarithmic in the size of the container.

		@liveexample{The example below shows how object elements can be queried
		with a default value.,basic_json__value_ptr}

		@sa @ref operator[](const json_pointer&) for unchecked access by reference

		@since version 2.0.2
		*/
		template<class ValueType, typename std::enable_if<
			std::is_convertible<basic_json_t, ValueType>::value, int>::type = 0>
			ValueType value(const json_pointer& ptr, const ValueType& default_value) const
		{
			// at only works for objects
			if (JSON_LIKELY(is_object()))
			{
				// if pointer resolves a value, return it or use default value
				JSON_TRY
				{
					return ptr.get_checked(this);
				}
					JSON_INTERNAL_CATCH(out_of_range&)
				{
					return default_value;
				}
			}

			JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
		}

		/*!
		@brief overload for a default value of type const char*
		@copydoc basic_json::value(const json_pointer&, ValueType) const
		*/
		string_t value(const json_pointer& ptr, const char* default_value) const
		{
			return value(ptr, string_t(default_value));
		}

		/*!
		@brief access the first element

		Returns a reference to the first element in the container. For a JSON
		container `c`, the expression `c.front()` is equivalent to `*c.begin()`.

		@return In case of a structured type (array or object), a reference to the
		first element is returned. In case of number, string, or boolean values, a
		reference to the value is returned.

		@complexity Constant.

		@pre The JSON value must not be `null` (would throw `std::out_of_range`)
		or an empty array or object (undefined behavior, **guarded by
		assertions**).
		@post The JSON value remains unchanged.

		@throw invalid_iterator.214 when called on `null` value

		@liveexample{The following code shows an example for `front()`.,front}

		@sa @ref back() -- access the last element

		@since version 1.0.0
		*/
		reference front()
		{
			return *begin();
		}

		/*!
		@copydoc basic_json::front()
		*/
		const_reference front() const
		{
			return *cbegin();
		}

		/*!
		@brief access the last element

		Returns a reference to the last element in the container. For a JSON
		container `c`, the expression `c.back()` is equivalent to
		@code {.cpp}
		auto tmp = c.end();
		--tmp;
		return *tmp;
		@endcode

		@return In case of a structured type (array or object), a reference to the
		last element is returned. In case of number, string, or boolean values, a
		reference to the value is returned.

		@complexity Constant.

		@pre The JSON value must not be `null` (would throw `std::out_of_range`)
		or an empty array or object (undefined behavior, **guarded by
		assertions**).
		@post The JSON value remains unchanged.

		@throw invalid_iterator.214 when called on a `null` value. See example
		below.

		@liveexample{The following code shows an example for `back()`.,back}

		@sa @ref front() -- access the first element

		@since version 1.0.0
		*/
		reference back()
		{
			auto tmp = end();
			--tmp;
			return *tmp;
		}

		/*!
		@copydoc basic_json::back()
		*/
		const_reference back() const
		{
			auto tmp = cend();
			--tmp;
			return *tmp;
		}

		/*!
		@brief remove element given an iterator

		Removes the element specified by iterator @a pos. The iterator @a pos must
		be valid and dereferenceable. Thus the `end()` iterator (which is valid,
		but is not dereferenceable) cannot be used as a value for @a pos.

		If called on a primitive type other than `null`, the resulting JSON value
		will be `null`.

		@param[in] pos iterator to the element to remove
		@return Iterator following the last removed element. If the iterator @a
		pos refers to the last element, the `end()` iterator is returned.

		@tparam IteratorType an @ref iterator or @ref const_iterator

		@post Invalidates iterators and references at or after the point of the
		erase, including the `end()` iterator.

		@throw type_error.307 if called on a `null` value; example: `"cannot use
		erase() with null"`
		@throw invalid_iterator.202 if called on an iterator which does not belong
		to the current JSON value; example: `"iterator does not fit current
		value"`
		@throw invalid_iterator.205 if called on a primitive type with invalid
		iterator (i.e., any iterator which is not `begin()`); example: `"iterator
		out of range"`

		@complexity The complexity depends on the type:
		- objects: amortized constant
		- arrays: linear in distance between @a pos and the end of the container
		- strings: linear in the length of the string
		- other types: constant

		@liveexample{The example shows the result of `erase()` for different JSON
		types.,erase__IteratorType}

		@sa @ref erase(IteratorType, IteratorType) -- removes the elements in
		the given range
		@sa @ref erase(const typename object_t::key_type&) -- removes the element
		from an object at the given key
		@sa @ref erase(const size_type) -- removes the element from an array at
		the given index

		@since version 1.0.0
		*/
		template<class IteratorType, typename std::enable_if<
			std::is_same<IteratorType, typename basic_json_t::iterator>::value or
			std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int>::type
			= 0>
			IteratorType erase(IteratorType pos)
		{
			// make sure iterator fits the current value
			if (JSON_UNLIKELY(this != pos.m_object))
			{
				JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
			}

			IteratorType result = end();

			switch (m_type)
			{
			case value_t::boolean:
			case value_t::number_float:
			case value_t::number_integer:
			case value_t::number_unsigned:
			case value_t::string:
			{
				if (JSON_UNLIKELY(not pos.m_it.primitive_iterator.is_begin()))
				{
					JSON_THROW(invalid_iterator::create(205, "iterator out of range"));
				}

				if (is_string())
				{
					AllocatorType<string_t> alloc;
					std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
					std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
					m_value.string = nullptr;
				}

				m_type = value_t::null;
				assert_invariant();
				break;
			}

			case value_t::object:
			{
				result.m_it.object_iterator = m_value.object->erase(pos.m_it.object_iterator);
				break;
			}

			case value_t::array:
			{
				result.m_it.array_iterator = m_value.array->erase(pos.m_it.array_iterator);
				break;
			}

			default:
				JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
			}

			return result;
		}

		/*!
		@brief remove elements given an iterator range

		Removes the element specified by the range `[first; last)`. The iterator
		@a first does not need to be dereferenceable if `first == last`: erasing
		an empty range is a no-op.

		If called on a primitive type other than `null`, the resulting JSON value
		will be `null`.

		@param[in] first iterator to the beginning of the range to remove
		@param[in] last iterator past the end of the range to remove
		@return Iterator following the last removed element. If the iterator @a
		second refers to the last element, the `end()` iterator is returned.

		@tparam IteratorType an @ref iterator or @ref const_iterator

		@post Invalidates iterators and references at or after the point of the
		erase, including the `end()` iterator.

		@throw type_error.307 if called on a `null` value; example: `"cannot use
		erase() with null"`
		@throw invalid_iterator.203 if called on iterators which does not belong
		to the current JSON value; example: `"iterators do not fit current value"`
		@throw invalid_iterator.204 if called on a primitive type with invalid
		iterators (i.e., if `first != begin()` and `last != end()`); example:
		`"iterators out of range"`

		@complexity The complexity depends on the type:
		- objects: `log(size()) + std::distance(first, last)`
		- arrays: linear in the distance between @a first and @a last, plus linear
		  in the distance between @a last and end of the container
		- strings: linear in the length of the string
		- other types: constant

		@liveexample{The example shows the result of `erase()` for different JSON
		types.,erase__IteratorType_IteratorType}

		@sa @ref erase(IteratorType) -- removes the element at a given position
		@sa @ref erase(const typename object_t::key_type&) -- removes the element
		from an object at the given key
		@sa @ref erase(const size_type) -- removes the element from an array at
		the given index

		@since version 1.0.0
		*/
		template<class IteratorType, typename std::enable_if<
			std::is_same<IteratorType, typename basic_json_t::iterator>::value or
			std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int>::type
			= 0>
			IteratorType erase(IteratorType first, IteratorType last)
		{
			// make sure iterator fits the current value
			if (JSON_UNLIKELY(this != first.m_object or this != last.m_object))
			{
				JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value"));
			}

			IteratorType result = end();

			switch (m_type)
			{
			case value_t::boolean:
			case value_t::number_float:
			case value_t::number_integer:
			case value_t::number_unsigned:
			case value_t::string:
			{
				if (JSON_LIKELY(not first.m_it.primitive_iterator.is_begin()
					or not last.m_it.primitive_iterator.is_end()))
				{
					JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
				}

				if (is_string())
				{
					AllocatorType<string_t> alloc;
					std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
					std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
					m_value.string = nullptr;
				}

				m_type = value_t::null;
				assert_invariant();
				break;
			}

			case value_t::object:
			{
				result.m_it.object_iterator = m_value.object->erase(first.m_it.object_iterator,
					last.m_it.object_iterator);
				break;
			}

			case value_t::array:
			{
				result.m_it.array_iterator = m_value.array->erase(first.m_it.array_iterator,
					last.m_it.array_iterator);
				break;
			}

			default:
				JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
			}

			return result;
		}

		/*!
		@brief remove element from a JSON object given a key

		Removes elements from a JSON object with the key value @a key.

		@param[in] key value of the elements to remove

		@return Number of elements removed. If @a ObjectType is the default
		`std::map` type, the return value will always be `0` (@a key was not
		found) or `1` (@a key was found).

		@post References and iterators to the erased elements are invalidated.
		Other references and iterators are not affected.

		@throw type_error.307 when called on a type other than JSON object;
		example: `"cannot use erase() with null"`

		@complexity `log(size()) + count(key)`

		@liveexample{The example shows the effect of `erase()`.,erase__key_type}

		@sa @ref erase(IteratorType) -- removes the element at a given position
		@sa @ref erase(IteratorType, IteratorType) -- removes the elements in
		the given range
		@sa @ref erase(const size_type) -- removes the element from an array at
		the given index

		@since version 1.0.0
		*/
		size_type erase(const typename object_t::key_type& key)
		{
			// this erase only works for objects
			if (JSON_LIKELY(is_object()))
			{
				return m_value.object->erase(key);
			}

			JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
		}

		/*!
		@brief remove element from a JSON array given an index

		Removes element from a JSON array at the index @a idx.

		@param[in] idx index of the element to remove

		@throw type_error.307 when called on a type other than JSON object;
		example: `"cannot use erase() with null"`
		@throw out_of_range.401 when `idx >= size()`; example: `"array index 17
		is out of range"`

		@complexity Linear in distance between @a idx and the end of the container.

		@liveexample{The example shows the effect of `erase()`.,erase__size_type}

		@sa @ref erase(IteratorType) -- removes the element at a given position
		@sa @ref erase(IteratorType, IteratorType) -- removes the elements in
		the given range
		@sa @ref erase(const typename object_t::key_type&) -- removes the element
		from an object at the given key

		@since version 1.0.0
		*/
		void erase(const size_type idx)
		{
			// this erase only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				if (JSON_UNLIKELY(idx >= size()))
				{
					JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
				}

				m_value.array->erase(m_value.array->begin() + static_cast<difference_type>(idx));
			}
			else
			{
				JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
			}
		}

		/// @}


		////////////
		// lookup //
		////////////

		/// @name lookup
		/// @{

		/*!
		@brief find an element in a JSON object

		Finds an element in a JSON object with key equivalent to @a key. If the
		element is not found or the JSON value is not an object, end() is
		returned.

		@note This method always returns @ref end() when executed on a JSON type
			  that is not an object.

		@param[in] key key value of the element to search for.

		@return Iterator to an element with key equivalent to @a key. If no such
		element is found or the JSON value is not an object, past-the-end (see
		@ref end()) iterator is returned.

		@complexity Logarithmic in the size of the JSON object.

		@liveexample{The example shows how `find()` is used.,find__key_type}

		@since version 1.0.0
		*/
		template<typename KeyT>
		iterator find(KeyT&& key)
		{
			auto result = end();

			if (is_object())
			{
				result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
			}

			return result;
		}

		/*!
		@brief find an element in a JSON object
		@copydoc find(KeyT&&)
		*/
		template<typename KeyT>
		const_iterator find(KeyT&& key) const
		{
			auto result = cend();

			if (is_object())
			{
				result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
			}

			return result;
		}

		/*!
		@brief returns the number of occurrences of a key in a JSON object

		Returns the number of elements with key @a key. If ObjectType is the
		default `std::map` type, the return value will always be `0` (@a key was
		not found) or `1` (@a key was found).

		@note This method always returns `0` when executed on a JSON type that is
			  not an object.

		@param[in] key key value of the element to count

		@return Number of elements with key @a key. If the JSON value is not an
		object, the return value will be `0`.

		@complexity Logarithmic in the size of the JSON object.

		@liveexample{The example shows how `count()` is used.,count}

		@since version 1.0.0
		*/
		template<typename KeyT>
		size_type count(KeyT&& key) const
		{
			// return 0 for all nonobject types
			return is_object() ? m_value.object->count(std::forward<KeyT>(key)) : 0;
		}

		/// @}


		///////////////
		// iterators //
		///////////////

		/// @name iterators
		/// @{

		/*!
		@brief returns an iterator to the first element

		Returns an iterator to the first element.

		@image html range-begin-end.svg "Illustration from cppreference.com"

		@return iterator to the first element

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.

		@liveexample{The following code shows an example for `begin()`.,begin}

		@sa @ref cbegin() -- returns a const iterator to the beginning
		@sa @ref end() -- returns an iterator to the end
		@sa @ref cend() -- returns a const iterator to the end

		@since version 1.0.0
		*/
		iterator begin() noexcept
		{
			iterator result(this);
			result.set_begin();
			return result;
		}

		/*!
		@copydoc basic_json::cbegin()
		*/
		const_iterator begin() const noexcept
		{
			return cbegin();
		}

		/*!
		@brief returns a const iterator to the first element

		Returns a const iterator to the first element.

		@image html range-begin-end.svg "Illustration from cppreference.com"

		@return const iterator to the first element

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.
		- Has the semantics of `const_cast<const basic_json&>(*this).begin()`.

		@liveexample{The following code shows an example for `cbegin()`.,cbegin}

		@sa @ref begin() -- returns an iterator to the beginning
		@sa @ref end() -- returns an iterator to the end
		@sa @ref cend() -- returns a const iterator to the end

		@since version 1.0.0
		*/
		const_iterator cbegin() const noexcept
		{
			const_iterator result(this);
			result.set_begin();
			return result;
		}

		/*!
		@brief returns an iterator to one past the last element

		Returns an iterator to one past the last element.

		@image html range-begin-end.svg "Illustration from cppreference.com"

		@return iterator one past the last element

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.

		@liveexample{The following code shows an example for `end()`.,end}

		@sa @ref cend() -- returns a const iterator to the end
		@sa @ref begin() -- returns an iterator to the beginning
		@sa @ref cbegin() -- returns a const iterator to the beginning

		@since version 1.0.0
		*/
		iterator end() noexcept
		{
			iterator result(this);
			result.set_end();
			return result;
		}

		/*!
		@copydoc basic_json::cend()
		*/
		const_iterator end() const noexcept
		{
			return cend();
		}

		/*!
		@brief returns a const iterator to one past the last element

		Returns a const iterator to one past the last element.

		@image html range-begin-end.svg "Illustration from cppreference.com"

		@return const iterator one past the last element

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.
		- Has the semantics of `const_cast<const basic_json&>(*this).end()`.

		@liveexample{The following code shows an example for `cend()`.,cend}

		@sa @ref end() -- returns an iterator to the end
		@sa @ref begin() -- returns an iterator to the beginning
		@sa @ref cbegin() -- returns a const iterator to the beginning

		@since version 1.0.0
		*/
		const_iterator cend() const noexcept
		{
			const_iterator result(this);
			result.set_end();
			return result;
		}

		/*!
		@brief returns an iterator to the reverse-beginning

		Returns an iterator to the reverse-beginning; that is, the last element.

		@image html range-rbegin-rend.svg "Illustration from cppreference.com"

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
		requirements:
		- The complexity is constant.
		- Has the semantics of `reverse_iterator(end())`.

		@liveexample{The following code shows an example for `rbegin()`.,rbegin}

		@sa @ref crbegin() -- returns a const reverse iterator to the beginning
		@sa @ref rend() -- returns a reverse iterator to the end
		@sa @ref crend() -- returns a const reverse iterator to the end

		@since version 1.0.0
		*/
		reverse_iterator rbegin() noexcept
		{
			return reverse_iterator(end());
		}

		/*!
		@copydoc basic_json::crbegin()
		*/
		const_reverse_iterator rbegin() const noexcept
		{
			return crbegin();
		}

		/*!
		@brief returns an iterator to the reverse-end

		Returns an iterator to the reverse-end; that is, one before the first
		element.

		@image html range-rbegin-rend.svg "Illustration from cppreference.com"

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
		requirements:
		- The complexity is constant.
		- Has the semantics of `reverse_iterator(begin())`.

		@liveexample{The following code shows an example for `rend()`.,rend}

		@sa @ref crend() -- returns a const reverse iterator to the end
		@sa @ref rbegin() -- returns a reverse iterator to the beginning
		@sa @ref crbegin() -- returns a const reverse iterator to the beginning

		@since version 1.0.0
		*/
		reverse_iterator rend() noexcept
		{
			return reverse_iterator(begin());
		}

		/*!
		@copydoc basic_json::crend()
		*/
		const_reverse_iterator rend() const noexcept
		{
			return crend();
		}

		/*!
		@brief returns a const reverse iterator to the last element

		Returns a const iterator to the reverse-beginning; that is, the last
		element.

		@image html range-rbegin-rend.svg "Illustration from cppreference.com"

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
		requirements:
		- The complexity is constant.
		- Has the semantics of `const_cast<const basic_json&>(*this).rbegin()`.

		@liveexample{The following code shows an example for `crbegin()`.,crbegin}

		@sa @ref rbegin() -- returns a reverse iterator to the beginning
		@sa @ref rend() -- returns a reverse iterator to the end
		@sa @ref crend() -- returns a const reverse iterator to the end

		@since version 1.0.0
		*/
		const_reverse_iterator crbegin() const noexcept
		{
			return const_reverse_iterator(cend());
		}

		/*!
		@brief returns a const reverse iterator to one before the first

		Returns a const reverse iterator to the reverse-end; that is, one before
		the first element.

		@image html range-rbegin-rend.svg "Illustration from cppreference.com"

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
		requirements:
		- The complexity is constant.
		- Has the semantics of `const_cast<const basic_json&>(*this).rend()`.

		@liveexample{The following code shows an example for `crend()`.,crend}

		@sa @ref rend() -- returns a reverse iterator to the end
		@sa @ref rbegin() -- returns a reverse iterator to the beginning
		@sa @ref crbegin() -- returns a const reverse iterator to the beginning

		@since version 1.0.0
		*/
		const_reverse_iterator crend() const noexcept
		{
			return const_reverse_iterator(cbegin());
		}

	public:
		/*!
		@brief wrapper to access iterator member functions in range-based for

		This function allows to access @ref iterator::key() and @ref
		iterator::value() during range-based for loops. In these loops, a
		reference to the JSON values is returned, so there is no access to the
		underlying iterator.

		For loop without iterator_wrapper:

		@code{cpp}
		for (auto it = j_object.begin(); it != j_object.end(); ++it)
		{
			std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
		}
		@endcode

		Range-based for loop without iterator proxy:

		@code{cpp}
		for (auto it : j_object)
		{
			// "it" is of type json::reference and has no key() member
			std::cout << "value: " << it << '\n';
		}
		@endcode

		Range-based for loop with iterator proxy:

		@code{cpp}
		for (auto it : json::iterator_wrapper(j_object))
		{
			std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
		}
		@endcode

		@note When iterating over an array, `key()` will return the index of the
			  element as string (see example).

		@param[in] ref  reference to a JSON value
		@return iteration proxy object wrapping @a ref with an interface to use in
				range-based for loops

		@liveexample{The following code shows how the wrapper is used,iterator_wrapper}

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Constant.

		@note The name of this function is not yet final and may change in the
		future.

		@deprecated This stream operator is deprecated and will be removed in
					future 4.0.0 of the library. Please use @ref items() instead;
					that is, replace `json::iterator_wrapper(j)` with `j.items()`.
		*/
		JSON_DEPRECATED
			static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept
		{
			return ref.items();
		}

		/*!
		@copydoc iterator_wrapper(reference)
		*/
		JSON_DEPRECATED
			static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept
		{
			return ref.items();
		}

		/*!
		@brief helper to access iterator member functions in range-based for

		This function allows to access @ref iterator::key() and @ref
		iterator::value() during range-based for loops. In these loops, a
		reference to the JSON values is returned, so there is no access to the
		underlying iterator.

		For loop without `items()` function:

		@code{cpp}
		for (auto it = j_object.begin(); it != j_object.end(); ++it)
		{
			std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
		}
		@endcode

		Range-based for loop without `items()` function:

		@code{cpp}
		for (auto it : j_object)
		{
			// "it" is of type json::reference and has no key() member
			std::cout << "value: " << it << '\n';
		}
		@endcode

		Range-based for loop with `items()` function:

		@code{cpp}
		for (auto it : j_object.items())
		{
			std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
		}
		@endcode

		@note When iterating over an array, `key()` will return the index of the
			  element as string (see example). For primitive types (e.g., numbers),
			  `key()` returns an empty string.

		@return iteration proxy object wrapping @a ref with an interface to use in
				range-based for loops

		@liveexample{The following code shows how the function is used.,items}

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Constant.

		@since version 3.1.0.
		*/
		iteration_proxy<iterator> items() noexcept
		{
			return iteration_proxy<iterator>(*this);
		}

		/*!
		@copydoc items()
		*/
		iteration_proxy<const_iterator> items() const noexcept
		{
			return iteration_proxy<const_iterator>(*this);
		}

		/// @}


		//////////////
		// capacity //
		//////////////

		/// @name capacity
		/// @{

		/*!
		@brief checks whether the container is empty.

		Checks if a JSON value has no elements (i.e. whether its @ref size is `0`).

		@return The return value depends on the different types and is
				defined as follows:
				Value type  | return value
				----------- | -------------
				null        | `true`
				boolean     | `false`
				string      | `false`
				number      | `false`
				object      | result of function `object_t::empty()`
				array       | result of function `array_t::empty()`

		@liveexample{The following code uses `empty()` to check if a JSON
		object contains any elements.,empty}

		@complexity Constant, as long as @ref array_t and @ref object_t satisfy
		the Container concept; that is, their `empty()` functions have constant
		complexity.

		@iterators No changes.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@note This function does not return whether a string stored as JSON value
		is empty - it returns whether the JSON container itself is empty which is
		false in the case of a string.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.
		- Has the semantics of `begin() == end()`.

		@sa @ref size() -- returns the number of elements

		@since version 1.0.0
		*/
		bool empty() const noexcept
		{
			switch (m_type)
			{
			case value_t::null:
			{
				// null values are empty
				return true;
			}

			case value_t::array:
			{
				// delegate call to array_t::empty()
				return m_value.array->empty();
			}

			case value_t::object:
			{
				// delegate call to object_t::empty()
				return m_value.object->empty();
			}

			default:
			{
				// all other types are nonempty
				return false;
			}
			}
		}

		/*!
		@brief returns the number of elements

		Returns the number of elements in a JSON value.

		@return The return value depends on the different types and is
				defined as follows:
				Value type  | return value
				----------- | -------------
				null        | `0`
				boolean     | `1`
				string      | `1`
				number      | `1`
				object      | result of function object_t::size()
				array       | result of function array_t::size()

		@liveexample{The following code calls `size()` on the different value
		types.,size}

		@complexity Constant, as long as @ref array_t and @ref object_t satisfy
		the Container concept; that is, their size() functions have constant
		complexity.

		@iterators No changes.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@note This function does not return the length of a string stored as JSON
		value - it returns the number of elements in the JSON value which is 1 in
		the case of a string.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.
		- Has the semantics of `std::distance(begin(), end())`.

		@sa @ref empty() -- checks whether the container is empty
		@sa @ref max_size() -- returns the maximal number of elements

		@since version 1.0.0
		*/
		size_type size() const noexcept
		{
			switch (m_type)
			{
			case value_t::null:
			{
				// null values are empty
				return 0;
			}

			case value_t::array:
			{
				// delegate call to array_t::size()
				return m_value.array->size();
			}

			case value_t::object:
			{
				// delegate call to object_t::size()
				return m_value.object->size();
			}

			default:
			{
				// all other types have size 1
				return 1;
			}
			}
		}

		/*!
		@brief returns the maximum possible number of elements

		Returns the maximum number of elements a JSON value is able to hold due to
		system or library implementation limitations, i.e. `std::distance(begin(),
		end())` for the JSON value.

		@return The return value depends on the different types and is
				defined as follows:
				Value type  | return value
				----------- | -------------
				null        | `0` (same as `size()`)
				boolean     | `1` (same as `size()`)
				string      | `1` (same as `size()`)
				number      | `1` (same as `size()`)
				object      | result of function `object_t::max_size()`
				array       | result of function `array_t::max_size()`

		@liveexample{The following code calls `max_size()` on the different value
		types. Note the output is implementation specific.,max_size}

		@complexity Constant, as long as @ref array_t and @ref object_t satisfy
		the Container concept; that is, their `max_size()` functions have constant
		complexity.

		@iterators No changes.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.
		- Has the semantics of returning `b.size()` where `b` is the largest
		  possible JSON value.

		@sa @ref size() -- returns the number of elements

		@since version 1.0.0
		*/
		size_type max_size() const noexcept
		{
			switch (m_type)
			{
			case value_t::array:
			{
				// delegate call to array_t::max_size()
				return m_value.array->max_size();
			}

			case value_t::object:
			{
				// delegate call to object_t::max_size()
				return m_value.object->max_size();
			}

			default:
			{
				// all other types have max_size() == size()
				return size();
			}
			}
		}

		/// @}


		///////////////
		// modifiers //
		///////////////

		/// @name modifiers
		/// @{

		/*!
		@brief clears the contents

		Clears the content of a JSON value and resets it to the default value as
		if @ref basic_json(value_t) would have been called with the current value
		type from @ref type():

		Value type  | initial value
		----------- | -------------
		null        | `null`
		boolean     | `false`
		string      | `""`
		number      | `0`
		object      | `{}`
		array       | `[]`

		@post Has the same effect as calling
		@code {.cpp}
		*this = basic_json(type());
		@endcode

		@liveexample{The example below shows the effect of `clear()` to different
		JSON types.,clear}

		@complexity Linear in the size of the JSON value.

		@iterators All iterators, pointers and references related to this container
				   are invalidated.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@sa @ref basic_json(value_t) -- constructor that creates an object with the
			same value than calling `clear()`

		@since version 1.0.0
		*/
		void clear() noexcept
		{
			switch (m_type)
			{
			case value_t::number_integer:
			{
				m_value.number_integer = 0;
				break;
			}

			case value_t::number_unsigned:
			{
				m_value.number_unsigned = 0;
				break;
			}

			case value_t::number_float:
			{
				m_value.number_float = 0.0;
				break;
			}

			case value_t::boolean:
			{
				m_value.boolean = false;
				break;
			}

			case value_t::string:
			{
				m_value.string->clear();
				break;
			}

			case value_t::array:
			{
				m_value.array->clear();
				break;
			}

			case value_t::object:
			{
				m_value.object->clear();
				break;
			}

			default:
				break;
			}
		}

		/*!
		@brief add an object to an array

		Appends the given element @a val to the end of the JSON value. If the
		function is called on a JSON null value, an empty array is created before
		appending @a val.

		@param[in] val the value to add to the JSON array

		@throw type_error.308 when called on a type other than JSON array or
		null; example: `"cannot use push_back() with number"`

		@complexity Amortized constant.

		@liveexample{The example shows how `push_back()` and `+=` can be used to
		add elements to a JSON array. Note how the `null` value was silently
		converted to a JSON array.,push_back}

		@since version 1.0.0
		*/
		void push_back(basic_json&& val)
		{
			// push_back only works for null objects or arrays
			if (JSON_UNLIKELY(not(is_null() or is_array())))
			{
				JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
			}

			// transform null object into an array
			if (is_null())
			{
				m_type = value_t::array;
				m_value = value_t::array;
				assert_invariant();
			}

			// add element to array (move semantics)
			m_value.array->push_back(std::move(val));
			// invalidate object
			val.m_type = value_t::null;
		}

		/*!
		@brief add an object to an array
		@copydoc push_back(basic_json&&)
		*/
		reference operator+=(basic_json&& val)
		{
			push_back(std::move(val));
			return *this;
		}

		/*!
		@brief add an object to an array
		@copydoc push_back(basic_json&&)
		*/
		void push_back(const basic_json& val)
		{
			// push_back only works for null objects or arrays
			if (JSON_UNLIKELY(not(is_null() or is_array())))
			{
				JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
			}

			// transform null object into an array
			if (is_null())
			{
				m_type = value_t::array;
				m_value = value_t::array;
				assert_invariant();
			}

			// add element to array
			m_value.array->push_back(val);
		}

		/*!
		@brief add an object to an array
		@copydoc push_back(basic_json&&)
		*/
		reference operator+=(const basic_json& val)
		{
			push_back(val);
			return *this;
		}

		/*!
		@brief add an object to an object

		Inserts the given element @a val to the JSON object. If the function is
		called on a JSON null value, an empty object is created before inserting
		@a val.

		@param[in] val the value to add to the JSON object

		@throw type_error.308 when called on a type other than JSON object or
		null; example: `"cannot use push_back() with number"`

		@complexity Logarithmic in the size of the container, O(log(`size()`)).

		@liveexample{The example shows how `push_back()` and `+=` can be used to
		add elements to a JSON object. Note how the `null` value was silently
		converted to a JSON object.,push_back__object_t__value}

		@since version 1.0.0
		*/
		void push_back(const typename object_t::value_type& val)
		{
			// push_back only works for null objects or objects
			if (JSON_UNLIKELY(not(is_null() or is_object())))
			{
				JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
			}

			// transform null object into an object
			if (is_null())
			{
				m_type = value_t::object;
				m_value = value_t::object;
				assert_invariant();
			}

			// add element to array
			m_value.object->insert(val);
		}

		/*!
		@brief add an object to an object
		@copydoc push_back(const typename object_t::value_type&)
		*/
		reference operator+=(const typename object_t::value_type& val)
		{
			push_back(val);
			return *this;
		}

		/*!
		@brief add an object to an object

		This function allows to use `push_back` with an initializer list. In case

		1. the current value is an object,
		2. the initializer list @a init contains only two elements, and
		3. the first element of @a init is a string,

		@a init is converted into an object element and added using
		@ref push_back(const typename object_t::value_type&). Otherwise, @a init
		is converted to a JSON value and added using @ref push_back(basic_json&&).

		@param[in] init  an initializer list

		@complexity Linear in the size of the initializer list @a init.

		@note This function is required to resolve an ambiguous overload error,
			  because pairs like `{"key", "value"}` can be both interpreted as
			  `object_t::value_type` or `std::initializer_list<basic_json>`, see
			  https://github.com/nlohmann/json/issues/235 for more information.

		@liveexample{The example shows how initializer lists are treated as
		objects when possible.,push_back__initializer_list}
		*/
		void push_back(initializer_list_t init)
		{
			if (is_object() and init.size() == 2 and (*init.begin())->is_string())
			{
				basic_json&& key = init.begin()->moved_or_copied();
				push_back(typename object_t::value_type(
					std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
			}
			else
			{
				push_back(basic_json(init));
			}
		}

		/*!
		@brief add an object to an object
		@copydoc push_back(initializer_list_t)
		*/
		reference operator+=(initializer_list_t init)
		{
			push_back(init);
			return *this;
		}

		/*!
		@brief add an object to an array

		Creates a JSON value from the passed parameters @a args to the end of the
		JSON value. If the function is called on a JSON null value, an empty array
		is created before appending the value created from @a args.

		@param[in] args arguments to forward to a constructor of @ref basic_json
		@tparam Args compatible types to create a @ref basic_json object

		@throw type_error.311 when called on a type other than JSON array or
		null; example: `"cannot use emplace_back() with number"`

		@complexity Amortized constant.

		@liveexample{The example shows how `push_back()` can be used to add
		elements to a JSON array. Note how the `null` value was silently converted
		to a JSON array.,emplace_back}

		@since version 2.0.8
		*/
		template<class... Args>
		void emplace_back(Args&& ... args)
		{
			// emplace_back only works for null objects or arrays
			if (JSON_UNLIKELY(not(is_null() or is_array())))
			{
				JSON_THROW(type_error::create(311, "cannot use emplace_back() with " + std::string(type_name())));
			}

			// transform null object into an array
			if (is_null())
			{
				m_type = value_t::array;
				m_value = value_t::array;
				assert_invariant();
			}

			// add element to array (perfect forwarding)
			m_value.array->emplace_back(std::forward<Args>(args)...);
		}

		/*!
		@brief add an object to an object if key does not exist

		Inserts a new element into a JSON object constructed in-place with the
		given @a args if there is no element with the key in the container. If the
		function is called on a JSON null value, an empty object is created before
		appending the value created from @a args.

		@param[in] args arguments to forward to a constructor of @ref basic_json
		@tparam Args compatible types to create a @ref basic_json object

		@return a pair consisting of an iterator to the inserted element, or the
				already-existing element if no insertion happened, and a bool
				denoting whether the insertion took place.

		@throw type_error.311 when called on a type other than JSON object or
		null; example: `"cannot use emplace() with number"`

		@complexity Logarithmic in the size of the container, O(log(`size()`)).

		@liveexample{The example shows how `emplace()` can be used to add elements
		to a JSON object. Note how the `null` value was silently converted to a
		JSON object. Further note how no value is added if there was already one
		value stored with the same key.,emplace}

		@since version 2.0.8
		*/
		template<class... Args>
		std::pair<iterator, bool> emplace(Args&& ... args)
		{
			// emplace only works for null objects or arrays
			if (JSON_UNLIKELY(not(is_null() or is_object())))
			{
				JSON_THROW(type_error::create(311, "cannot use emplace() with " + std::string(type_name())));
			}

			// transform null object into an object
			if (is_null())
			{
				m_type = value_t::object;
				m_value = value_t::object;
				assert_invariant();
			}

			// add element to array (perfect forwarding)
			auto res = m_value.object->emplace(std::forward<Args>(args)...);
			// create result iterator and set iterator to the result of emplace
			auto it = begin();
			it.m_it.object_iterator = res.first;

			// return pair of iterator and boolean
			return { it, res.second };
		}

		/// Helper for insertion of an iterator
		/// @note: This uses std::distance to support GCC 4.8,
		///        see https://github.com/nlohmann/json/pull/1257
		template<typename... Args>
		iterator insert_iterator(const_iterator pos, Args&& ... args)
		{
			iterator result(this);
			assert(m_value.array != nullptr);

			auto insert_pos = std::distance(m_value.array->begin(), pos.m_it.array_iterator);
			m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);
			result.m_it.array_iterator = m_value.array->begin() + insert_pos;

			// This could have been written as:
			// result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, cnt, val);
			// but the return value of insert is missing in GCC 4.8, so it is written this way instead.

			return result;
		}

		/*!
		@brief inserts element

		Inserts element @a val before iterator @a pos.

		@param[in] pos iterator before which the content will be inserted; may be
		the end() iterator
		@param[in] val element to insert
		@return iterator pointing to the inserted @a val.

		@throw type_error.309 if called on JSON values other than arrays;
		example: `"cannot use insert() with string"`
		@throw invalid_iterator.202 if @a pos is not an iterator of *this;
		example: `"iterator does not fit current value"`

		@complexity Constant plus linear in the distance between @a pos and end of
		the container.

		@liveexample{The example shows how `insert()` is used.,insert}

		@since version 1.0.0
		*/
		iterator insert(const_iterator pos, const basic_json& val)
		{
			// insert only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				// check if iterator pos fits to this JSON value
				if (JSON_UNLIKELY(pos.m_object != this))
				{
					JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
				}

				// insert to array and return iterator
				return insert_iterator(pos, val);
			}

			JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
		}

		/*!
		@brief inserts element
		@copydoc insert(const_iterator, const basic_json&)
		*/
		iterator insert(const_iterator pos, basic_json&& val)
		{
			return insert(pos, val);
		}

		/*!
		@brief inserts elements

		Inserts @a cnt copies of @a val before iterator @a pos.

		@param[in] pos iterator before which the content will be inserted; may be
		the end() iterator
		@param[in] cnt number of copies of @a val to insert
		@param[in] val element to insert
		@return iterator pointing to the first element inserted, or @a pos if
		`cnt==0`

		@throw type_error.309 if called on JSON values other than arrays; example:
		`"cannot use insert() with string"`
		@throw invalid_iterator.202 if @a pos is not an iterator of *this;
		example: `"iterator does not fit current value"`

		@complexity Linear in @a cnt plus linear in the distance between @a pos
		and end of the container.

		@liveexample{The example shows how `insert()` is used.,insert__count}

		@since version 1.0.0
		*/
		iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
		{
			// insert only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				// check if iterator pos fits to this JSON value
				if (JSON_UNLIKELY(pos.m_object != this))
				{
					JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
				}

				// insert to array and return iterator
				return insert_iterator(pos, cnt, val);
			}

			JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
		}

		/*!
		@brief inserts elements

		Inserts elements from range `[first, last)` before iterator @a pos.

		@param[in] pos iterator before which the content will be inserted; may be
		the end() iterator
		@param[in] first begin of the range of elements to insert
		@param[in] last end of the range of elements to insert

		@throw type_error.309 if called on JSON values other than arrays; example:
		`"cannot use insert() with string"`
		@throw invalid_iterator.202 if @a pos is not an iterator of *this;
		example: `"iterator does not fit current value"`
		@throw invalid_iterator.210 if @a first and @a last do not belong to the
		same JSON value; example: `"iterators do not fit"`
		@throw invalid_iterator.211 if @a first or @a last are iterators into
		container for which insert is called; example: `"passed iterators may not
		belong to container"`

		@return iterator pointing to the first element inserted, or @a pos if
		`first==last`

		@complexity Linear in `std::distance(first, last)` plus linear in the
		distance between @a pos and end of the container.

		@liveexample{The example shows how `insert()` is used.,insert__range}

		@since version 1.0.0
		*/
		iterator insert(const_iterator pos, const_iterator first, const_iterator last)
		{
			// insert only works for arrays
			if (JSON_UNLIKELY(not is_array()))
			{
				JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
			}

			// check if iterator pos fits to this JSON value
			if (JSON_UNLIKELY(pos.m_object != this))
			{
				JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
			}

			// check if range iterators belong to the same JSON object
			if (JSON_UNLIKELY(first.m_object != last.m_object))
			{
				JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
			}

			if (JSON_UNLIKELY(first.m_object == this))
			{
				JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container"));
			}

			// insert to array and return iterator
			return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
		}

		/*!
		@brief inserts elements

		Inserts elements from initializer list @a ilist before iterator @a pos.

		@param[in] pos iterator before which the content will be inserted; may be
		the end() iterator
		@param[in] ilist initializer list to insert the values from

		@throw type_error.309 if called on JSON values other than arrays; example:
		`"cannot use insert() with string"`
		@throw invalid_iterator.202 if @a pos is not an iterator of *this;
		example: `"iterator does not fit current value"`

		@return iterator pointing to the first element inserted, or @a pos if
		`ilist` is empty

		@complexity Linear in `ilist.size()` plus linear in the distance between
		@a pos and end of the container.

		@liveexample{The example shows how `insert()` is used.,insert__ilist}

		@since version 1.0.0
		*/
		iterator insert(const_iterator pos, initializer_list_t ilist)
		{
			// insert only works for arrays
			if (JSON_UNLIKELY(not is_array()))
			{
				JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
			}

			// check if iterator pos fits to this JSON value
			if (JSON_UNLIKELY(pos.m_object != this))
			{
				JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
			}

			// insert to array and return iterator
			return insert_iterator(pos, ilist.begin(), ilist.end());
		}

		/*!
		@brief inserts elements

		Inserts elements from range `[first, last)`.

		@param[in] first begin of the range of elements to insert
		@param[in] last end of the range of elements to insert

		@throw type_error.309 if called on JSON values other than objects; example:
		`"cannot use insert() with string"`
		@throw invalid_iterator.202 if iterator @a first or @a last does does not
		point to an object; example: `"iterators first and last must point to
		objects"`
		@throw invalid_iterator.210 if @a first and @a last do not belong to the
		same JSON value; example: `"iterators do not fit"`

		@complexity Logarithmic: `O(N*log(size() + N))`, where `N` is the number
		of elements to insert.

		@liveexample{The example shows how `insert()` is used.,insert__range_object}

		@since version 3.0.0
		*/
		void insert(const_iterator first, const_iterator last)
		{
			// insert only works for objects
			if (JSON_UNLIKELY(not is_object()))
			{
				JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
			}

			// check if range iterators belong to the same JSON object
			if (JSON_UNLIKELY(first.m_object != last.m_object))
			{
				JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
			}

			// passed iterators must belong to objects
			if (JSON_UNLIKELY(not first.m_object->is_object()))
			{
				JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
			}

			m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
		}

		/*!
		@brief updates a JSON object from another object, overwriting existing keys

		Inserts all values from JSON object @a j and overwrites existing keys.

		@param[in] j  JSON object to read values from

		@throw type_error.312 if called on JSON values other than objects; example:
		`"cannot use update() with string"`

		@complexity O(N*log(size() + N)), where N is the number of elements to
					insert.

		@liveexample{The example shows how `update()` is used.,update}

		@sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

		@since version 3.0.0
		*/
		void update(const_reference j)
		{
			// implicitly convert null value to an empty object
			if (is_null())
			{
				m_type = value_t::object;
				m_value.object = create<object_t>();
				assert_invariant();
			}

			if (JSON_UNLIKELY(not is_object()))
			{
				JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
			}
			if (JSON_UNLIKELY(not j.is_object()))
			{
				JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(j.type_name())));
			}

			for (auto it = j.cbegin(); it != j.cend(); ++it)
			{
				m_value.object->operator[](it.key()) = it.value();
			}
		}

		/*!
		@brief updates a JSON object from another object, overwriting existing keys

		Inserts all values from from range `[first, last)` and overwrites existing
		keys.

		@param[in] first begin of the range of elements to insert
		@param[in] last end of the range of elements to insert

		@throw type_error.312 if called on JSON values other than objects; example:
		`"cannot use update() with string"`
		@throw invalid_iterator.202 if iterator @a first or @a last does does not
		point to an object; example: `"iterators first and last must point to
		objects"`
		@throw invalid_iterator.210 if @a first and @a last do not belong to the
		same JSON value; example: `"iterators do not fit"`

		@complexity O(N*log(size() + N)), where N is the number of elements to
					insert.

		@liveexample{The example shows how `update()` is used__range.,update}

		@sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

		@since version 3.0.0
		*/
		void update(const_iterator first, const_iterator last)
		{
			// implicitly convert null value to an empty object
			if (is_null())
			{
				m_type = value_t::object;
				m_value.object = create<object_t>();
				assert_invariant();
			}

			if (JSON_UNLIKELY(not is_object()))
			{
				JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
			}

			// check if range iterators belong to the same JSON object
			if (JSON_UNLIKELY(first.m_object != last.m_object))
			{
				JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
			}

			// passed iterators must belong to objects
			if (JSON_UNLIKELY(not first.m_object->is_object()
				or not last.m_object->is_object()))
			{
				JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
			}

			for (auto it = first; it != last; ++it)
			{
				m_value.object->operator[](it.key()) = it.value();
			}
		}

		/*!
		@brief exchanges the values

		Exchanges the contents of the JSON value with those of @a other. Does not
		invoke any move, copy, or swap operations on individual elements. All
		iterators and references remain valid. The past-the-end iterator is
		invalidated.

		@param[in,out] other JSON value to exchange the contents with

		@complexity Constant.

		@liveexample{The example below shows how JSON values can be swapped with
		`swap()`.,swap__reference}

		@since version 1.0.0
		*/
		void swap(reference other) noexcept (
			std::is_nothrow_move_constructible<value_t>::value and
			std::is_nothrow_move_assignable<value_t>::value and
			std::is_nothrow_move_constructible<json_value>::value and
			std::is_nothrow_move_assignable<json_value>::value
			)
		{
			std::swap(m_type, other.m_type);
			std::swap(m_value, other.m_value);
			assert_invariant();
		}

		/*!
		@brief exchanges the values

		Exchanges the contents of a JSON array with those of @a other. Does not
		invoke any move, copy, or swap operations on individual elements. All
		iterators and references remain valid. The past-the-end iterator is
		invalidated.

		@param[in,out] other array to exchange the contents with

		@throw type_error.310 when JSON value is not an array; example: `"cannot
		use swap() with string"`

		@complexity Constant.

		@liveexample{The example below shows how arrays can be swapped with
		`swap()`.,swap__array_t}

		@since version 1.0.0
		*/
		void swap(array_t& other)
		{
			// swap only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				std::swap(*(m_value.array), other);
			}
			else
			{
				JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
			}
		}

		/*!
		@brief exchanges the values

		Exchanges the contents of a JSON object with those of @a other. Does not
		invoke any move, copy, or swap operations on individual elements. All
		iterators and references remain valid. The past-the-end iterator is
		invalidated.

		@param[in,out] other object to exchange the contents with

		@throw type_error.310 when JSON value is not an object; example:
		`"cannot use swap() with string"`

		@complexity Constant.

		@liveexample{The example below shows how objects can be swapped with
		`swap()`.,swap__object_t}

		@since version 1.0.0
		*/
		void swap(object_t& other)
		{
			// swap only works for objects
			if (JSON_LIKELY(is_object()))
			{
				std::swap(*(m_value.object), other);
			}
			else
			{
				JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
			}
		}

		/*!
		@brief exchanges the values

		Exchanges the contents of a JSON string with those of @a other. Does not
		invoke any move, copy, or swap operations on individual elements. All
		iterators and references remain valid. The past-the-end iterator is
		invalidated.

		@param[in,out] other string to exchange the contents with

		@throw type_error.310 when JSON value is not a string; example: `"cannot
		use swap() with boolean"`

		@complexity Constant.

		@liveexample{The example below shows how strings can be swapped with
		`swap()`.,swap__string_t}

		@since version 1.0.0
		*/
		void swap(string_t& other)
		{
			// swap only works for strings
			if (JSON_LIKELY(is_string()))
			{
				std::swap(*(m_value.string), other);
			}
			else
			{
				JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
			}
		}

		/// @}

	public:
		//////////////////////////////////////////
		// lexicographical comparison operators //
		//////////////////////////////////////////

		/// @name lexicographical comparison operators
		/// @{

		/*!
		@brief comparison: equal

		Compares two JSON values for equality according to the following rules:
		- Two JSON values are equal if (1) they are from the same type and (2)
		  their stored values are the same according to their respective
		  `operator==`.
		- Integer and floating-point numbers are automatically converted before
		  comparison. Note than two NaN values are always treated as unequal.
		- Two JSON null values are equal.

		@note Floating-point inside JSON values numbers are compared with
		`json::number_float_t::operator==` which is `double::operator==` by
		default. To compare floating-point while respecting an epsilon, an alternative
		[comparison function](https://github.com/mariokonrad/marnav/blob/master/src/marnav/math/floatingpoint.hpp#L34-#L39)
		could be used, for instance
		@code {.cpp}
		template<typename T, typename = typename std::enable_if<std::is_floating_point<T>::value, T>::type>
		inline bool is_same(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept
		{
			return std::abs(a - b) <= epsilon;
		}
		@endcode

		@note NaN values never compare equal to themselves or to other NaN values.

		@param[in] lhs  first JSON value to consider
		@param[in] rhs  second JSON value to consider
		@return whether the values @a lhs and @a rhs are equal

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@complexity Linear.

		@liveexample{The example demonstrates comparing several JSON
		types.,operator__equal}

		@since version 1.0.0
		*/
		friend bool operator==(const_reference lhs, const_reference rhs) noexcept
		{
			const auto lhs_type = lhs.type();
			const auto rhs_type = rhs.type();

			if (lhs_type == rhs_type)
			{
				switch (lhs_type)
				{
				case value_t::array:
					return (*lhs.m_value.array == *rhs.m_value.array);

				case value_t::object:
					return (*lhs.m_value.object == *rhs.m_value.object);

				case value_t::null:
					return true;

				case value_t::string:
					return (*lhs.m_value.string == *rhs.m_value.string);

				case value_t::boolean:
					return (lhs.m_value.boolean == rhs.m_value.boolean);

				case value_t::number_integer:
					return (lhs.m_value.number_integer == rhs.m_value.number_integer);

				case value_t::number_unsigned:
					return (lhs.m_value.number_unsigned == rhs.m_value.number_unsigned);

				case value_t::number_float:
					return (lhs.m_value.number_float == rhs.m_value.number_float);

				default:
					return false;
				}
			}
			else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
			{
				return (static_cast<number_float_t>(lhs.m_value.number_integer) == rhs.m_value.number_float);
			}
			else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
			{
				return (lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_integer));
			}
			else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
			{
				return (static_cast<number_float_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_float);
			}
			else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
			{
				return (lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_unsigned));
			}
			else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
			{
				return (static_cast<number_integer_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_integer);
			}
			else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
			{
				return (lhs.m_value.number_integer == static_cast<number_integer_t>(rhs.m_value.number_unsigned));
			}

			return false;
		}

		/*!
		@brief comparison: equal
		@copydoc operator==(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator==(const_reference lhs, const ScalarType rhs) noexcept
		{
			return (lhs == basic_json(rhs));
		}

		/*!
		@brief comparison: equal
		@copydoc operator==(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator==(const ScalarType lhs, const_reference rhs) noexcept
		{
			return (basic_json(lhs) == rhs);
		}

		/*!
		@brief comparison: not equal

		Compares two JSON values for inequality by calculating `not (lhs == rhs)`.

		@param[in] lhs  first JSON value to consider
		@param[in] rhs  second JSON value to consider
		@return whether the values @a lhs and @a rhs are not equal

		@complexity Linear.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@liveexample{The example demonstrates comparing several JSON
		types.,operator__notequal}

		@since version 1.0.0
		*/
		friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
		{
			return not (lhs == rhs);
		}

		/*!
		@brief comparison: not equal
		@copydoc operator!=(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator!=(const_reference lhs, const ScalarType rhs) noexcept
		{
			return (lhs != basic_json(rhs));
		}

		/*!
		@brief comparison: not equal
		@copydoc operator!=(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator!=(const ScalarType lhs, const_reference rhs) noexcept
		{
			return (basic_json(lhs) != rhs);
		}

		/*!
		@brief comparison: less than

		Compares whether one JSON value @a lhs is less than another JSON value @a
		rhs according to the following rules:
		- If @a lhs and @a rhs have the same type, the values are compared using
		  the default `<` operator.
		- Integer and floating-point numbers are automatically converted before
		  comparison
		- In case @a lhs and @a rhs have different types, the values are ignored
		  and the order of the types is considered, see
		  @ref operator<(const value_t, const value_t).

		@param[in] lhs  first JSON value to consider
		@param[in] rhs  second JSON value to consider
		@return whether @a lhs is less than @a rhs

		@complexity Linear.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@liveexample{The example demonstrates comparing several JSON
		types.,operator__less}

		@since version 1.0.0
		*/
		friend bool operator<(const_reference lhs, const_reference rhs) noexcept
		{
			const auto lhs_type = lhs.type();
			const auto rhs_type = rhs.type();

			if (lhs_type == rhs_type)
			{
				switch (lhs_type)
				{
				case value_t::array:
					return (*lhs.m_value.array) < (*rhs.m_value.array);

				case value_t::object:
					return *lhs.m_value.object < *rhs.m_value.object;

				case value_t::null:
					return false;

				case value_t::string:
					return *lhs.m_value.string < *rhs.m_value.string;

				case value_t::boolean:
					return lhs.m_value.boolean < rhs.m_value.boolean;

				case value_t::number_integer:
					return lhs.m_value.number_integer < rhs.m_value.number_integer;

				case value_t::number_unsigned:
					return lhs.m_value.number_unsigned < rhs.m_value.number_unsigned;

				case value_t::number_float:
					return lhs.m_value.number_float < rhs.m_value.number_float;

				default:
					return false;
				}
			}
			else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
			{
				return static_cast<number_float_t>(lhs.m_value.number_integer) < rhs.m_value.number_float;
			}
			else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
			{
				return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_integer);
			}
			else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
			{
				return static_cast<number_float_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_float;
			}
			else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
			{
				return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_unsigned);
			}
			else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
			{
				return lhs.m_value.number_integer < static_cast<number_integer_t>(rhs.m_value.number_unsigned);
			}
			else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
			{
				return static_cast<number_integer_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_integer;
			}

			// We only reach this line if we cannot compare values. In that case,
			// we compare types. Note we have to call the operator explicitly,
			// because MSVC has problems otherwise.
			return operator<(lhs_type, rhs_type);
		}

		/*!
		@brief comparison: less than
		@copydoc operator<(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator<(const_reference lhs, const ScalarType rhs) noexcept
		{
			return (lhs < basic_json(rhs));
		}

		/*!
		@brief comparison: less than
		@copydoc operator<(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator<(const ScalarType lhs, const_reference rhs) noexcept
		{
			return (basic_json(lhs) < rhs);
		}

		/*!
		@brief comparison: less than or equal

		Compares whether one JSON value @a lhs is less than or equal to another
		JSON value by calculating `not (rhs < lhs)`.

		@param[in] lhs  first JSON value to consider
		@param[in] rhs  second JSON value to consider
		@return whether @a lhs is less than or equal to @a rhs

		@complexity Linear.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@liveexample{The example demonstrates comparing several JSON
		types.,operator__greater}

		@since version 1.0.0
		*/
		friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
		{
			return not (rhs < lhs);
		}

		/*!
		@brief comparison: less than or equal
		@copydoc operator<=(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator<=(const_reference lhs, const ScalarType rhs) noexcept
		{
			return (lhs <= basic_json(rhs));
		}

		/*!
		@brief comparison: less than or equal
		@copydoc operator<=(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator<=(const ScalarType lhs, const_reference rhs) noexcept
		{
			return (basic_json(lhs) <= rhs);
		}

		/*!
		@brief comparison: greater than

		Compares whether one JSON value @a lhs is greater than another
		JSON value by calculating `not (lhs <= rhs)`.

		@param[in] lhs  first JSON value to consider
		@param[in] rhs  second JSON value to consider
		@return whether @a lhs is greater than to @a rhs

		@complexity Linear.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@liveexample{The example demonstrates comparing several JSON
		types.,operator__lessequal}

		@since version 1.0.0
		*/
		friend bool operator>(const_reference lhs, const_reference rhs) noexcept
		{
			return not (lhs <= rhs);
		}

		/*!
		@brief comparison: greater than
		@copydoc operator>(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator>(const_reference lhs, const ScalarType rhs) noexcept
		{
			return (lhs > basic_json(rhs));
		}

		/*!
		@brief comparison: greater than
		@copydoc operator>(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator>(const ScalarType lhs, const_reference rhs) noexcept
		{
			return (basic_json(lhs) > rhs);
		}

		/*!
		@brief comparison: greater than or equal

		Compares whether one JSON value @a lhs is greater than or equal to another
		JSON value by calculating `not (lhs < rhs)`.

		@param[in] lhs  first JSON value to consider
		@param[in] rhs  second JSON value to consider
		@return whether @a lhs is greater than or equal to @a rhs

		@complexity Linear.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@liveexample{The example demonstrates comparing several JSON
		types.,operator__greaterequal}

		@since version 1.0.0
		*/
		friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
		{
			return not (lhs < rhs);
		}

		/*!
		@brief comparison: greater than or equal
		@copydoc operator>=(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator>=(const_reference lhs, const ScalarType rhs) noexcept
		{
			return (lhs >= basic_json(rhs));
		}

		/*!
		@brief comparison: greater than or equal
		@copydoc operator>=(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator>=(const ScalarType lhs, const_reference rhs) noexcept
		{
			return (basic_json(lhs) >= rhs);
		}

		/// @}

		///////////////////
		// serialization //
		///////////////////

		/// @name serialization
		/// @{

		/*!
		@brief serialize to stream

		Serialize the given JSON value @a j to the output stream @a o. The JSON
		value will be serialized using the @ref dump member function.

		- The indentation of the output can be controlled with the member variable
		  `width` of the output stream @a o. For instance, using the manipulator
		  `std::setw(4)` on @a o sets the indentation level to `4` and the
		  serialization result is the same as calling `dump(4)`.

		- The indentation character can be controlled with the member variable
		  `fill` of the output stream @a o. For instance, the manipulator
		  `std::setfill('\\t')` sets indentation to use a tab character rather than
		  the default space character.

		@param[in,out] o  stream to serialize to
		@param[in] j  JSON value to serialize

		@return the stream @a o

		@throw type_error.316 if a string stored inside the JSON value is not
							  UTF-8 encoded

		@complexity Linear.

		@liveexample{The example below shows the serialization with different
		parameters to `width` to adjust the indentation level.,operator_serialize}

		@since version 1.0.0; indentation character added in version 3.0.0
		*/
		friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
		{
			// read width member and use it as indentation parameter if nonzero
			const bool pretty_print = (o.width() > 0);
			const auto indentation = (pretty_print ? o.width() : 0);

			// reset width to 0 for subsequent calls to this stream
			o.width(0);

			// do the actual serialization
			serializer s(detail::output_adapter<char>(o), o.fill());
			s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
			return o;
		}

		/*!
		@brief serialize to stream
		@deprecated This stream operator is deprecated and will be removed in
					future 4.0.0 of the library. Please use
					@ref operator<<(std::ostream&, const basic_json&)
					instead; that is, replace calls like `j >> o;` with `o << j;`.
		@since version 1.0.0; deprecated since version 3.0.0
		*/
		JSON_DEPRECATED
			friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
		{
			return o << j;
		}

		/// @}


		/////////////////////
		// deserialization //
		/////////////////////

		/// @name deserialization
		/// @{

		/*!
		@brief deserialize from a compatible input

		This function reads from a compatible input. Examples are:
		- an array of 1-byte values
		- strings with character/literal type with size of 1 byte
		- input streams
		- container with contiguous storage of 1-byte values. Compatible container
		  types include `std::vector`, `std::string`, `std::array`,
		  `std::valarray`, and `std::initializer_list`. Furthermore, C-style
		  arrays can be used with `std::begin()`/`std::end()`. User-defined
		  containers can be used as long as they implement random-access iterators
		  and a contiguous storage.

		@pre Each element of the container has a size of 1 byte. Violating this
		precondition yields undefined behavior. **This precondition is enforced
		with a static assertion.**

		@pre The container storage is contiguous. Violating this precondition
		yields undefined behavior. **This precondition is enforced with an
		assertion.**
		@pre Each element of the container has a size of 1 byte. Violating this
		precondition yields undefined behavior. **This precondition is enforced
		with a static assertion.**

		@warning There is no way to enforce all preconditions at compile-time. If
				 the function is called with a noncompliant container and with
				 assertions switched off, the behavior is undefined and will most
				 likely yield segmentation violation.

		@param[in] i  input to read from
		@param[in] cb  a parser callback function of type @ref parser_callback_t
		which is used to control the deserialization by filtering unwanted values
		(optional)

		@return result of the deserialization

		@throw parse_error.101 if a parse error occurs; example: `""unexpected end
		of input; expected string literal""`
		@throw parse_error.102 if to_unicode fails or surrogate error
		@throw parse_error.103 if to_unicode fails

		@complexity Linear in the length of the input. The parser is a predictive
		LL(1) parser. The complexity can be higher if the parser callback function
		@a cb has a super-linear complexity.

		@note A UTF-8 byte order mark is silently ignored.

		@liveexample{The example below demonstrates the `parse()` function reading
		from an array.,parse__array__parser_callback_t}

		@liveexample{The example below demonstrates the `parse()` function with
		and without callback function.,parse__string__parser_callback_t}

		@liveexample{The example below demonstrates the `parse()` function with
		and without callback function.,parse__istream__parser_callback_t}

		@liveexample{The example below demonstrates the `parse()` function reading
		from a contiguous container.,parse__contiguouscontainer__parser_callback_t}

		@since version 2.0.3 (contiguous containers)
		*/
		static basic_json parse(detail::input_adapter&& i,
			const parser_callback_t cb = nullptr,
			const bool allow_exceptions = true)
		{
			basic_json result;
			parser(i, cb, allow_exceptions).parse(true, result);
			return result;
		}

		static bool accept(detail::input_adapter&& i)
		{
			return parser(i).accept(true);
		}

		/*!
		@brief generate SAX events

		The SAX event lister must follow the interface of @ref json_sax.

		This function reads from a compatible input. Examples are:
		- an array of 1-byte values
		- strings with character/literal type with size of 1 byte
		- input streams
		- container with contiguous storage of 1-byte values. Compatible container
		  types include `std::vector`, `std::string`, `std::array`,
		  `std::valarray`, and `std::initializer_list`. Furthermore, C-style
		  arrays can be used with `std::begin()`/`std::end()`. User-defined
		  containers can be used as long as they implement random-access iterators
		  and a contiguous storage.

		@pre Each element of the container has a size of 1 byte. Violating this
		precondition yields undefined behavior. **This precondition is enforced
		with a static assertion.**

		@pre The container storage is contiguous. Violating this precondition
		yields undefined behavior. **This precondition is enforced with an
		assertion.**
		@pre Each element of the container has a size of 1 byte. Violating this
		precondition yields undefined behavior. **This precondition is enforced
		with a static assertion.**

		@warning There is no way to enforce all preconditions at compile-time. If
				 the function is called with a noncompliant container and with
				 assertions switched off, the behavior is undefined and will most
				 likely yield segmentation violation.

		@param[in] i  input to read from
		@param[in,out] sax  SAX event listener
		@param[in] format  the format to parse (JSON, CBOR, MessagePack, or UBJSON)
		@param[in] strict  whether the input has to be consumed completely

		@return return value of the last processed SAX event

		@throw parse_error.101 if a parse error occurs; example: `""unexpected end
		of input; expected string literal""`
		@throw parse_error.102 if to_unicode fails or surrogate error
		@throw parse_error.103 if to_unicode fails

		@complexity Linear in the length of the input. The parser is a predictive
		LL(1) parser. The complexity can be higher if the SAX consumer @a sax has
		a super-linear complexity.

		@note A UTF-8 byte order mark is silently ignored.

		@liveexample{The example below demonstrates the `sax_parse()` function
		reading from string and processing the events with a user-defined SAX
		event consumer.,sax_parse}

		@since version 3.2.0
		*/
		template <typename SAX>
		static bool sax_parse(detail::input_adapter&& i, SAX* sax,
			input_format_t format = input_format_t::json,
			const bool strict = true)
		{
			assert(sax);
			switch (format)
			{
			case input_format_t::json:
				return parser(std::move(i)).sax_parse(sax, strict);
			default:
				return detail::binary_reader<basic_json, SAX>(std::move(i)).sax_parse(format, sax, strict);
			}
		}

		/*!
		@brief deserialize from an iterator range with contiguous storage

		This function reads from an iterator range of a container with contiguous
		storage of 1-byte values. Compatible container types include
		`std::vector`, `std::string`, `std::array`, `std::valarray`, and
		`std::initializer_list`. Furthermore, C-style arrays can be used with
		`std::begin()`/`std::end()`. User-defined containers can be used as long
		as they implement random-access iterators and a contiguous storage.

		@pre The iterator range is contiguous. Violating this precondition yields
		undefined behavior. **This precondition is enforced with an assertion.**
		@pre Each element in the range has a size of 1 byte. Violating this
		precondition yields undefined behavior. **This precondition is enforced
		with a static assertion.**

		@warning There is no way to enforce all preconditions at compile-time. If
				 the function is called with noncompliant iterators and with
				 assertions switched off, the behavior is undefined and will most
				 likely yield segmentation violation.

		@tparam IteratorType iterator of container with contiguous storage
		@param[in] first  begin of the range to parse (included)
		@param[in] last  end of the range to parse (excluded)
		@param[in] cb  a parser callback function of type @ref parser_callback_t
		which is used to control the deserialization by filtering unwanted values
		(optional)
		@param[in] allow_exceptions  whether to throw exceptions in case of a
		parse error (optional, true by default)

		@return result of the deserialization

		@throw parse_error.101 in case of an unexpected token
		@throw parse_error.102 if to_unicode fails or surrogate error
		@throw parse_error.103 if to_unicode fails

		@complexity Linear in the length of the input. The parser is a predictive
		LL(1) parser. The complexity can be higher if the parser callback function
		@a cb has a super-linear complexity.

		@note A UTF-8 byte order mark is silently ignored.

		@liveexample{The example below demonstrates the `parse()` function reading
		from an iterator range.,parse__iteratortype__parser_callback_t}

		@since version 2.0.3
		*/
		template<class IteratorType, typename std::enable_if<
			std::is_base_of<
			std::random_access_iterator_tag,
			typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
			static basic_json parse(IteratorType first, IteratorType last,
				const parser_callback_t cb = nullptr,
				const bool allow_exceptions = true)
		{
			basic_json result;
			parser(detail::input_adapter(first, last), cb, allow_exceptions).parse(true, result);
			return result;
		}

		template<class IteratorType, typename std::enable_if<
			std::is_base_of<
			std::random_access_iterator_tag,
			typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
			static bool accept(IteratorType first, IteratorType last)
		{
			return parser(detail::input_adapter(first, last)).accept(true);
		}

		template<class IteratorType, class SAX, typename std::enable_if<
			std::is_base_of<
			std::random_access_iterator_tag,
			typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
			static bool sax_parse(IteratorType first, IteratorType last, SAX* sax)
		{
			return parser(detail::input_adapter(first, last)).sax_parse(sax);
		}

		/*!
		@brief deserialize from stream
		@deprecated This stream operator is deprecated and will be removed in
					version 4.0.0 of the library. Please use
					@ref operator>>(std::istream&, basic_json&)
					instead; that is, replace calls like `j << i;` with `i >> j;`.
		@since version 1.0.0; deprecated since version 3.0.0
		*/
		JSON_DEPRECATED
			friend std::istream& operator<<(basic_json& j, std::istream& i)
		{
			return operator>>(i, j);
		}

		/*!
		@brief deserialize from stream

		Deserializes an input stream to a JSON value.

		@param[in,out] i  input stream to read a serialized JSON value from
		@param[in,out] j  JSON value to write the deserialized input to

		@throw parse_error.101 in case of an unexpected token
		@throw parse_error.102 if to_unicode fails or surrogate error
		@throw parse_error.103 if to_unicode fails

		@complexity Linear in the length of the input. The parser is a predictive
		LL(1) parser.

		@note A UTF-8 byte order mark is silently ignored.

		@liveexample{The example below shows how a JSON value is constructed by
		reading a serialization from a stream.,operator_deserialize}

		@sa parse(std::istream&, const parser_callback_t) for a variant with a
		parser callback function to filter values while parsing

		@since version 1.0.0
		*/
		friend std::istream& operator>>(std::istream& i, basic_json& j)
		{
			parser(detail::input_adapter(i)).parse(false, j);
			return i;
		}

		/// @}

		///////////////////////////
		// convenience functions //
		///////////////////////////

		/*!
		@brief return the type as string

		Returns the type name as string to be used in error messages - usually to
		indicate that a function was called on a wrong JSON type.

		@return a string representation of a the @a m_type member:
				Value type  | return value
				----------- | -------------
				null        | `"null"`
				boolean     | `"boolean"`
				string      | `"string"`
				number      | `"number"` (for all number types)
				object      | `"object"`
				array       | `"array"`
				discarded   | `"discarded"`

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@complexity Constant.

		@liveexample{The following code exemplifies `type_name()` for all JSON
		types.,type_name}

		@sa @ref type() -- return the type of the JSON value
		@sa @ref operator value_t() -- return the type of the JSON value (implicit)

		@since version 1.0.0, public since 2.1.0, `const char*` and `noexcept`
		since 3.0.0
		*/
		const char* type_name() const noexcept
		{
			{
				switch (m_type)
				{
				case value_t::null:
					return "null";
				case value_t::object:
					return "object";
				case value_t::array:
					return "array";
				case value_t::string:
					return "string";
				case value_t::boolean:
					return "boolean";
				case value_t::discarded:
					return "discarded";
				default:
					return "number";
				}
			}
		}


	private:
		//////////////////////
		// member variables //
		//////////////////////

		/// the type of the current element
		value_t m_type = value_t::null;

		/// the value of the current element
		json_value m_value = {};

		//////////////////////////////////////////
		// binary serialization/deserialization //
		//////////////////////////////////////////

		/// @name binary serialization/deserialization support
		/// @{

	public:
		/*!
		@brief create a CBOR serialization of a given JSON value

		Serializes a given JSON value @a j to a byte vector using the CBOR (Concise
		Binary Object Representation) serialization format. CBOR is a binary
		serialization format which aims to be more compact than JSON itself, yet
		more efficient to parse.

		The library uses the following mapping from JSON values types to
		CBOR types according to the CBOR specification (RFC 7049):

		JSON value type | value/range                                | CBOR type                          | first byte
		--------------- | ------------------------------------------ | ---------------------------------- | ---------------
		null            | `null`                                     | Null                               | 0xF6
		boolean         | `true`                                     | True                               | 0xF5
		boolean         | `false`                                    | False                              | 0xF4
		number_integer  | -9223372036854775808..-2147483649          | Negative integer (8 bytes follow)  | 0x3B
		number_integer  | -2147483648..-32769                        | Negative integer (4 bytes follow)  | 0x3A
		number_integer  | -32768..-129                               | Negative integer (2 bytes follow)  | 0x39
		number_integer  | -128..-25                                  | Negative integer (1 byte follow)   | 0x38
		number_integer  | -24..-1                                    | Negative integer                   | 0x20..0x37
		number_integer  | 0..23                                      | Integer                            | 0x00..0x17
		number_integer  | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
		number_integer  | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
		number_integer  | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
		number_integer  | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
		number_unsigned | 0..23                                      | Integer                            | 0x00..0x17
		number_unsigned | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
		number_unsigned | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
		number_unsigned | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
		number_unsigned | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
		number_float    | *any value*                                | Double-Precision Float             | 0xFB
		string          | *length*: 0..23                            | UTF-8 string                       | 0x60..0x77
		string          | *length*: 23..255                          | UTF-8 string (1 byte follow)       | 0x78
		string          | *length*: 256..65535                       | UTF-8 string (2 bytes follow)      | 0x79
		string          | *length*: 65536..4294967295                | UTF-8 string (4 bytes follow)      | 0x7A
		string          | *length*: 4294967296..18446744073709551615 | UTF-8 string (8 bytes follow)      | 0x7B
		array           | *size*: 0..23                              | array                              | 0x80..0x97
		array           | *size*: 23..255                            | array (1 byte follow)              | 0x98
		array           | *size*: 256..65535                         | array (2 bytes follow)             | 0x99
		array           | *size*: 65536..4294967295                  | array (4 bytes follow)             | 0x9A
		array           | *size*: 4294967296..18446744073709551615   | array (8 bytes follow)             | 0x9B
		object          | *size*: 0..23                              | map                                | 0xA0..0xB7
		object          | *size*: 23..255                            | map (1 byte follow)                | 0xB8
		object          | *size*: 256..65535                         | map (2 bytes follow)               | 0xB9
		object          | *size*: 65536..4294967295                  | map (4 bytes follow)               | 0xBA
		object          | *size*: 4294967296..18446744073709551615   | map (8 bytes follow)               | 0xBB

		@note The mapping is **complete** in the sense that any JSON value type
			  can be converted to a CBOR value.

		@note If NaN or Infinity are stored inside a JSON number, they are
			  serialized properly. This behavior differs from the @ref dump()
			  function which serializes NaN or Infinity to `null`.

		@note The following CBOR types are not used in the conversion:
			  - byte strings (0x40..0x5F)
			  - UTF-8 strings terminated by "break" (0x7F)
			  - arrays terminated by "break" (0x9F)
			  - maps terminated by "break" (0xBF)
			  - date/time (0xC0..0xC1)
			  - bignum (0xC2..0xC3)
			  - decimal fraction (0xC4)
			  - bigfloat (0xC5)
			  - tagged items (0xC6..0xD4, 0xD8..0xDB)
			  - expected conversions (0xD5..0xD7)
			  - simple values (0xE0..0xF3, 0xF8)
			  - undefined (0xF7)
			  - half and single-precision floats (0xF9-0xFA)
			  - break (0xFF)

		@param[in] j  JSON value to serialize
		@return MessagePack serialization as byte vector

		@complexity Linear in the size of the JSON value @a j.

		@liveexample{The example shows the serialization of a JSON value to a byte
		vector in CBOR format.,to_cbor}

		@sa http://cbor.io
		@sa @ref from_cbor(detail::input_adapter, const bool strict) for the
			analogous deserialization
		@sa @ref to_msgpack(const basic_json&) for the related MessagePack format
		@sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
				 related UBJSON format

		@since version 2.0.9
		*/
		static std::vector<uint8_t> to_cbor(const basic_json& j)
		{
			std::vector<uint8_t> result;
			to_cbor(j, result);
			return result;
		}

		static void to_cbor(const basic_json& j, detail::output_adapter<uint8_t> o)
		{
			binary_writer<uint8_t>(o).write_cbor(j);
		}

		static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
		{
			binary_writer<char>(o).write_cbor(j);
		}

		/*!
		@brief create a MessagePack serialization of a given JSON value

		Serializes a given JSON value @a j to a byte vector using the MessagePack
		serialization format. MessagePack is a binary serialization format which
		aims to be more compact than JSON itself, yet more efficient to parse.

		The library uses the following mapping from JSON values types to
		MessagePack types according to the MessagePack specification:

		JSON value type | value/range                       | MessagePack type | first byte
		--------------- | --------------------------------- | ---------------- | ----------
		null            | `null`                            | nil              | 0xC0
		boolean         | `true`                            | true             | 0xC3
		boolean         | `false`                           | false            | 0xC2
		number_integer  | -9223372036854775808..-2147483649 | int64            | 0xD3
		number_integer  | -2147483648..-32769               | int32            | 0xD2
		number_integer  | -32768..-129                      | int16            | 0xD1
		number_integer  | -128..-33                         | int8             | 0xD0
		number_integer  | -32..-1                           | negative fixint  | 0xE0..0xFF
		number_integer  | 0..127                            | positive fixint  | 0x00..0x7F
		number_integer  | 128..255                          | uint 8           | 0xCC
		number_integer  | 256..65535                        | uint 16          | 0xCD
		number_integer  | 65536..4294967295                 | uint 32          | 0xCE
		number_integer  | 4294967296..18446744073709551615  | uint 64          | 0xCF
		number_unsigned | 0..127                            | positive fixint  | 0x00..0x7F
		number_unsigned | 128..255                          | uint 8           | 0xCC
		number_unsigned | 256..65535                        | uint 16          | 0xCD
		number_unsigned | 65536..4294967295                 | uint 32          | 0xCE
		number_unsigned | 4294967296..18446744073709551615  | uint 64          | 0xCF
		number_float    | *any value*                       | float 64         | 0xCB
		string          | *length*: 0..31                   | fixstr           | 0xA0..0xBF
		string          | *length*: 32..255                 | str 8            | 0xD9
		string          | *length*: 256..65535              | str 16           | 0xDA
		string          | *length*: 65536..4294967295       | str 32           | 0xDB
		array           | *size*: 0..15                     | fixarray         | 0x90..0x9F
		array           | *size*: 16..65535                 | array 16         | 0xDC
		array           | *size*: 65536..4294967295         | array 32         | 0xDD
		object          | *size*: 0..15                     | fix map          | 0x80..0x8F
		object          | *size*: 16..65535                 | map 16           | 0xDE
		object          | *size*: 65536..4294967295         | map 32           | 0xDF

		@note The mapping is **complete** in the sense that any JSON value type
			  can be converted to a MessagePack value.

		@note The following values can **not** be converted to a MessagePack value:
			  - strings with more than 4294967295 bytes
			  - arrays with more than 4294967295 elements
			  - objects with more than 4294967295 elements

		@note The following MessagePack types are not used in the conversion:
			  - bin 8 - bin 32 (0xC4..0xC6)
			  - ext 8 - ext 32 (0xC7..0xC9)
			  - float 32 (0xCA)
			  - fixext 1 - fixext 16 (0xD4..0xD8)

		@note Any MessagePack output created @ref to_msgpack can be successfully
			  parsed by @ref from_msgpack.

		@note If NaN or Infinity are stored inside a JSON number, they are
			  serialized properly. This behavior differs from the @ref dump()
			  function which serializes NaN or Infinity to `null`.

		@param[in] j  JSON value to serialize
		@return MessagePack serialization as byte vector

		@complexity Linear in the size of the JSON value @a j.

		@liveexample{The example shows the serialization of a JSON value to a byte
		vector in MessagePack format.,to_msgpack}

		@sa http://msgpack.org
		@sa @ref from_msgpack(const std::vector<uint8_t>&, const size_t) for the
			analogous deserialization
		@sa @ref to_cbor(const basic_json& for the related CBOR format
		@sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
				 related UBJSON format

		@since version 2.0.9
		*/
		static std::vector<uint8_t> to_msgpack(const basic_json& j)
		{
			std::vector<uint8_t> result;
			to_msgpack(j, result);
			return result;
		}

		static void to_msgpack(const basic_json& j, detail::output_adapter<uint8_t> o)
		{
			binary_writer<uint8_t>(o).write_msgpack(j);
		}

		static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
		{
			binary_writer<char>(o).write_msgpack(j);
		}

		/*!
		@brief create a UBJSON serialization of a given JSON value

		Serializes a given JSON value @a j to a byte vector using the UBJSON
		(Universal Binary JSON) serialization format. UBJSON aims to be more compact
		than JSON itself, yet more efficient to parse.

		The library uses the following mapping from JSON values types to
		UBJSON types according to the UBJSON specification:

		JSON value type | value/range                       | UBJSON type | marker
		--------------- | --------------------------------- | ----------- | ------
		null            | `null`                            | null        | `Z`
		boolean         | `true`                            | true        | `T`
		boolean         | `false`                           | false       | `F`
		number_integer  | -9223372036854775808..-2147483649 | int64       | `L`
		number_integer  | -2147483648..-32769               | int32       | `l`
		number_integer  | -32768..-129                      | int16       | `I`
		number_integer  | -128..127                         | int8        | `i`
		number_integer  | 128..255                          | uint8       | `U`
		number_integer  | 256..32767                        | int16       | `I`
		number_integer  | 32768..2147483647                 | int32       | `l`
		number_integer  | 2147483648..9223372036854775807   | int64       | `L`
		number_unsigned | 0..127                            | int8        | `i`
		number_unsigned | 128..255                          | uint8       | `U`
		number_unsigned | 256..32767                        | int16       | `I`
		number_unsigned | 32768..2147483647                 | int32       | `l`
		number_unsigned | 2147483648..9223372036854775807   | int64       | `L`
		number_float    | *any value*                       | float64     | `D`
		string          | *with shortest length indicator*  | string      | `S`
		array           | *see notes on optimized format*   | array       | `[`
		object          | *see notes on optimized format*   | map         | `{`

		@note The mapping is **complete** in the sense that any JSON value type
			  can be converted to a UBJSON value.

		@note The following values can **not** be converted to a UBJSON value:
			  - strings with more than 9223372036854775807 bytes (theoretical)
			  - unsigned integer numbers above 9223372036854775807

		@note The following markers are not used in the conversion:
			  - `Z`: no-op values are not created.
			  - `C`: single-byte strings are serialized with `S` markers.

		@note Any UBJSON output created @ref to_ubjson can be successfully parsed
			  by @ref from_ubjson.

		@note If NaN or Infinity are stored inside a JSON number, they are
			  serialized properly. This behavior differs from the @ref dump()
			  function which serializes NaN or Infinity to `null`.

		@note The optimized formats for containers are supported: Parameter
			  @a use_size adds size information to the beginning of a container and
			  removes the closing marker. Parameter @a use_type further checks
			  whether all elements of a container have the same type and adds the
			  type marker to the beginning of the container. The @a use_type
			  parameter must only be used together with @a use_size = true. Note
			  that @a use_size = true alone may result in larger representations -
			  the benefit of this parameter is that the receiving side is
			  immediately informed on the number of elements of the container.

		@param[in] j  JSON value to serialize
		@param[in] use_size  whether to add size annotations to container types
		@param[in] use_type  whether to add type annotations to container types
							 (must be combined with @a use_size = true)
		@return UBJSON serialization as byte vector

		@complexity Linear in the size of the JSON value @a j.

		@liveexample{The example shows the serialization of a JSON value to a byte
		vector in UBJSON format.,to_ubjson}

		@sa http://ubjson.org
		@sa @ref from_ubjson(detail::input_adapter, const bool strict) for the
			analogous deserialization
		@sa @ref to_cbor(const basic_json& for the related CBOR format
		@sa @ref to_msgpack(const basic_json&) for the related MessagePack format

		@since version 3.1.0
		*/
		static std::vector<uint8_t> to_ubjson(const basic_json& j,
			const bool use_size = false,
			const bool use_type = false)
		{
			std::vector<uint8_t> result;
			to_ubjson(j, result, use_size, use_type);
			return result;
		}

		static void to_ubjson(const basic_json& j, detail::output_adapter<uint8_t> o,
			const bool use_size = false, const bool use_type = false)
		{
			binary_writer<uint8_t>(o).write_ubjson(j, use_size, use_type);
		}

		static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
			const bool use_size = false, const bool use_type = false)
		{
			binary_writer<char>(o).write_ubjson(j, use_size, use_type);
		}

		/*!
		@brief create a JSON value from an input in CBOR format

		Deserializes a given input @a i to a JSON value using the CBOR (Concise
		Binary Object Representation) serialization format.

		The library maps CBOR types to JSON value types as follows:

		CBOR type              | JSON value type | first byte
		---------------------- | --------------- | ----------
		Integer                | number_unsigned | 0x00..0x17
		Unsigned integer       | number_unsigned | 0x18
		Unsigned integer       | number_unsigned | 0x19
		Unsigned integer       | number_unsigned | 0x1A
		Unsigned integer       | number_unsigned | 0x1B
		Negative integer       | number_integer  | 0x20..0x37
		Negative integer       | number_integer  | 0x38
		Negative integer       | number_integer  | 0x39
		Negative integer       | number_integer  | 0x3A
		Negative integer       | number_integer  | 0x3B
		Negative integer       | number_integer  | 0x40..0x57
		UTF-8 string           | string          | 0x60..0x77
		UTF-8 string           | string          | 0x78
		UTF-8 string           | string          | 0x79
		UTF-8 string           | string          | 0x7A
		UTF-8 string           | string          | 0x7B
		UTF-8 string           | string          | 0x7F
		array                  | array           | 0x80..0x97
		array                  | array           | 0x98
		array                  | array           | 0x99
		array                  | array           | 0x9A
		array                  | array           | 0x9B
		array                  | array           | 0x9F
		map                    | object          | 0xA0..0xB7
		map                    | object          | 0xB8
		map                    | object          | 0xB9
		map                    | object          | 0xBA
		map                    | object          | 0xBB
		map                    | object          | 0xBF
		False                  | `false`         | 0xF4
		True                   | `true`          | 0xF5
		Nill                   | `null`          | 0xF6
		Half-Precision Float   | number_float    | 0xF9
		Single-Precision Float | number_float    | 0xFA
		Double-Precision Float | number_float    | 0xFB

		@warning The mapping is **incomplete** in the sense that not all CBOR
				 types can be converted to a JSON value. The following CBOR types
				 are not supported and will yield parse errors (parse_error.112):
				 - byte strings (0x40..0x5F)
				 - date/time (0xC0..0xC1)
				 - bignum (0xC2..0xC3)
				 - decimal fraction (0xC4)
				 - bigfloat (0xC5)
				 - tagged items (0xC6..0xD4, 0xD8..0xDB)
				 - expected conversions (0xD5..0xD7)
				 - simple values (0xE0..0xF3, 0xF8)
				 - undefined (0xF7)

		@warning CBOR allows map keys of any type, whereas JSON only allows
				 strings as keys in object values. Therefore, CBOR maps with keys
				 other than UTF-8 strings are rejected (parse_error.113).

		@note Any CBOR output created @ref to_cbor can be successfully parsed by
			  @ref from_cbor.

		@param[in] i  an input in CBOR format convertible to an input adapter
		@param[in] strict  whether to expect the input to be consumed until EOF
						   (true by default)
		@param[in] allow_exceptions  whether to throw exceptions in case of a
		parse error (optional, true by default)

		@return deserialized JSON value

		@throw parse_error.110 if the given input ends prematurely or the end of
		file was not reached when @a strict was set to true
		@throw parse_error.112 if unsupported features from CBOR were
		used in the given input @a v or if the input is not valid CBOR
		@throw parse_error.113 if a string was expected as map key, but not found

		@complexity Linear in the size of the input @a i.

		@liveexample{The example shows the deserialization of a byte vector in CBOR
		format to a JSON value.,from_cbor}

		@sa http://cbor.io
		@sa @ref to_cbor(const basic_json&) for the analogous serialization
		@sa @ref from_msgpack(detail::input_adapter, const bool, const bool) for the
			related MessagePack format
		@sa @ref from_ubjson(detail::input_adapter, const bool, const bool) for the
			related UBJSON format

		@since version 2.0.9; parameter @a start_index since 2.1.1; changed to
			   consume input adapters, removed start_index parameter, and added
			   @a strict parameter since 3.0.0; added @allow_exceptions parameter
			   since 3.2.0
		*/
		static basic_json from_cbor(detail::input_adapter&& i,
			const bool strict = true,
			const bool allow_exceptions = true)
		{
			basic_json result;
			detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
			const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::cbor, &sdp, strict);
			return res ? result : basic_json(value_t::discarded);
		}

		/*!
		@copydoc from_cbor(detail::input_adapter, const bool, const bool)
		*/
		template<typename A1, typename A2,
			detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
			static basic_json from_cbor(A1 && a1, A2 && a2,
				const bool strict = true,
				const bool allow_exceptions = true)
		{
			basic_json result;
			detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
			const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::cbor, &sdp, strict);
			return res ? result : basic_json(value_t::discarded);
		}

		/*!
		@brief create a JSON value from an input in MessagePack format

		Deserializes a given input @a i to a JSON value using the MessagePack
		serialization format.

		The library maps MessagePack types to JSON value types as follows:

		MessagePack type | JSON value type | first byte
		---------------- | --------------- | ----------
		positive fixint  | number_unsigned | 0x00..0x7F
		fixmap           | object          | 0x80..0x8F
		fixarray         | array           | 0x90..0x9F
		fixstr           | string          | 0xA0..0xBF
		nil              | `null`          | 0xC0
		false            | `false`         | 0xC2
		true             | `true`          | 0xC3
		float 32         | number_float    | 0xCA
		float 64         | number_float    | 0xCB
		uint 8           | number_unsigned | 0xCC
		uint 16          | number_unsigned | 0xCD
		uint 32          | number_unsigned | 0xCE
		uint 64          | number_unsigned | 0xCF
		int 8            | number_integer  | 0xD0
		int 16           | number_integer  | 0xD1
		int 32           | number_integer  | 0xD2
		int 64           | number_integer  | 0xD3
		str 8            | string          | 0xD9
		str 16           | string          | 0xDA
		str 32           | string          | 0xDB
		array 16         | array           | 0xDC
		array 32         | array           | 0xDD
		map 16           | object          | 0xDE
		map 32           | object          | 0xDF
		negative fixint  | number_integer  | 0xE0-0xFF

		@warning The mapping is **incomplete** in the sense that not all
				 MessagePack types can be converted to a JSON value. The following
				 MessagePack types are not supported and will yield parse errors:
				  - bin 8 - bin 32 (0xC4..0xC6)
				  - ext 8 - ext 32 (0xC7..0xC9)
				  - fixext 1 - fixext 16 (0xD4..0xD8)

		@note Any MessagePack output created @ref to_msgpack can be successfully
			  parsed by @ref from_msgpack.

		@param[in] i  an input in MessagePack format convertible to an input
					  adapter
		@param[in] strict  whether to expect the input to be consumed until EOF
						   (true by default)
		@param[in] allow_exceptions  whether to throw exceptions in case of a
		parse error (optional, true by default)

		@return deserialized JSON value

		@throw parse_error.110 if the given input ends prematurely or the end of
		file was not reached when @a strict was set to true
		@throw parse_error.112 if unsupported features from MessagePack were
		used in the given input @a i or if the input is not valid MessagePack
		@throw parse_error.113 if a string was expected as map key, but not found

		@complexity Linear in the size of the input @a i.

		@liveexample{The example shows the deserialization of a byte vector in
		MessagePack format to a JSON value.,from_msgpack}

		@sa http://msgpack.org
		@sa @ref to_msgpack(const basic_json&) for the analogous serialization
		@sa @ref from_cbor(detail::input_adapter, const bool, const bool) for the
			related CBOR format
		@sa @ref from_ubjson(detail::input_adapter, const bool, const bool) for
			the related UBJSON format

		@since version 2.0.9; parameter @a start_index since 2.1.1; changed to
			   consume input adapters, removed start_index parameter, and added
			   @a strict parameter since 3.0.0; added @allow_exceptions parameter
			   since 3.2.0
		*/
		static basic_json from_msgpack(detail::input_adapter&& i,
			const bool strict = true,
			const bool allow_exceptions = true)
		{
			basic_json result;
			detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
			const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::msgpack, &sdp, strict);
			return res ? result : basic_json(value_t::discarded);
		}

		/*!
		@copydoc from_msgpack(detail::input_adapter, const bool, const bool)
		*/
		template<typename A1, typename A2,
			detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
			static basic_json from_msgpack(A1 && a1, A2 && a2,
				const bool strict = true,
				const bool allow_exceptions = true)
		{
			basic_json result;
			detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
			const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::msgpack, &sdp, strict);
			return res ? result : basic_json(value_t::discarded);
		}

		/*!
		@brief create a JSON value from an input in UBJSON format

		Deserializes a given input @a i to a JSON value using the UBJSON (Universal
		Binary JSON) serialization format.

		The library maps UBJSON types to JSON value types as follows:

		UBJSON type | JSON value type                         | marker
		----------- | --------------------------------------- | ------
		no-op       | *no value, next value is read*          | `N`
		null        | `null`                                  | `Z`
		false       | `false`                                 | `F`
		true        | `true`                                  | `T`
		float32     | number_float                            | `d`
		float64     | number_float                            | `D`
		uint8       | number_unsigned                         | `U`
		int8        | number_integer                          | `i`
		int16       | number_integer                          | `I`
		int32       | number_integer                          | `l`
		int64       | number_integer                          | `L`
		string      | string                                  | `S`
		char        | string                                  | `C`
		array       | array (optimized values are supported)  | `[`
		object      | object (optimized values are supported) | `{`

		@note The mapping is **complete** in the sense that any UBJSON value can
			  be converted to a JSON value.

		@param[in] i  an input in UBJSON format convertible to an input adapter
		@param[in] strict  whether to expect the input to be consumed until EOF
						   (true by default)
		@param[in] allow_exceptions  whether to throw exceptions in case of a
		parse error (optional, true by default)

		@return deserialized JSON value

		@throw parse_error.110 if the given input ends prematurely or the end of
		file was not reached when @a strict was set to true
		@throw parse_error.112 if a parse error occurs
		@throw parse_error.113 if a string could not be parsed successfully

		@complexity Linear in the size of the input @a i.

		@liveexample{The example shows the deserialization of a byte vector in
		UBJSON format to a JSON value.,from_ubjson}

		@sa http://ubjson.org
		@sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
				 analogous serialization
		@sa @ref from_cbor(detail::input_adapter, const bool, const bool) for the
			related CBOR format
		@sa @ref from_msgpack(detail::input_adapter, const bool, const bool) for
			the related MessagePack format

		@since version 3.1.0; added @allow_exceptions parameter since 3.2.0
		*/
		static basic_json from_ubjson(detail::input_adapter&& i,
			const bool strict = true,
			const bool allow_exceptions = true)
		{
			basic_json result;
			detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
			const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::ubjson, &sdp, strict);
			return res ? result : basic_json(value_t::discarded);
		}

		/*!
		@copydoc from_ubjson(detail::input_adapter, const bool, const bool)
		*/
		template<typename A1, typename A2,
			detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
			static basic_json from_ubjson(A1 && a1, A2 && a2,
				const bool strict = true,
				const bool allow_exceptions = true)
		{
			basic_json result;
			detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
			const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::ubjson, &sdp, strict);
			return res ? result : basic_json(value_t::discarded);
		}

		/// @}

		//////////////////////////
		// JSON Pointer support //
		//////////////////////////

		/// @name JSON Pointer functions
		/// @{

		/*!
		@brief access specified element via JSON Pointer

		Uses a JSON pointer to retrieve a reference to the respective JSON value.
		No bound checking is performed. Similar to @ref operator[](const typename
		object_t::key_type&), `null` values are created in arrays and objects if
		necessary.

		In particular:
		- If the JSON pointer points to an object key that does not exist, it
		  is created an filled with a `null` value before a reference to it
		  is returned.
		- If the JSON pointer points to an array index that does not exist, it
		  is created an filled with a `null` value before a reference to it
		  is returned. All indices between the current maximum and the given
		  index are also filled with `null`.
		- The special value `-` is treated as a synonym for the index past the
		  end.

		@param[in] ptr  a JSON pointer

		@return reference to the element pointed to by @a ptr

		@complexity Constant.

		@throw parse_error.106   if an array index begins with '0'
		@throw parse_error.109   if an array index was not a number
		@throw out_of_range.404  if the JSON pointer can not be resolved

		@liveexample{The behavior is shown in the example.,operatorjson_pointer}

		@since version 2.0.0
		*/
		reference operator[](const json_pointer& ptr)
		{
			return ptr.get_unchecked(this);
		}

		/*!
		@brief access specified element via JSON Pointer

		Uses a JSON pointer to retrieve a reference to the respective JSON value.
		No bound checking is performed. The function does not change the JSON
		value; no `null` values are created. In particular, the the special value
		`-` yields an exception.

		@param[in] ptr  JSON pointer to the desired element

		@return const reference to the element pointed to by @a ptr

		@complexity Constant.

		@throw parse_error.106   if an array index begins with '0'
		@throw parse_error.109   if an array index was not a number
		@throw out_of_range.402  if the array index '-' is used
		@throw out_of_range.404  if the JSON pointer can not be resolved

		@liveexample{The behavior is shown in the example.,operatorjson_pointer_const}

		@since version 2.0.0
		*/
		const_reference operator[](const json_pointer& ptr) const
		{
			return ptr.get_unchecked(this);
		}

		/*!
		@brief access specified element via JSON Pointer

		Returns a reference to the element at with specified JSON pointer @a ptr,
		with bounds checking.

		@param[in] ptr  JSON pointer to the desired element

		@return reference to the element pointed to by @a ptr

		@throw parse_error.106 if an array index in the passed JSON pointer @a ptr
		begins with '0'. See example below.

		@throw parse_error.109 if an array index in the passed JSON pointer @a ptr
		is not a number. See example below.

		@throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
		is out of range. See example below.

		@throw out_of_range.402 if the array index '-' is used in the passed JSON
		pointer @a ptr. As `at` provides checked access (and no elements are
		implicitly inserted), the index '-' is always invalid. See example below.

		@throw out_of_range.403 if the JSON pointer describes a key of an object
		which cannot be found. See example below.

		@throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
		See example below.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Constant.

		@since version 2.0.0

		@liveexample{The behavior is shown in the example.,at_json_pointer}
		*/
		reference at(const json_pointer& ptr)
		{
			return ptr.get_checked(this);
		}

		/*!
		@brief access specified element via JSON Pointer

		Returns a const reference to the element at with specified JSON pointer @a
		ptr, with bounds checking.

		@param[in] ptr  JSON pointer to the desired element

		@return reference to the element pointed to by @a ptr

		@throw parse_error.106 if an array index in the passed JSON pointer @a ptr
		begins with '0'. See example below.

		@throw parse_error.109 if an array index in the passed JSON pointer @a ptr
		is not a number. See example below.

		@throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
		is out of range. See example below.

		@throw out_of_range.402 if the array index '-' is used in the passed JSON
		pointer @a ptr. As `at` provides checked access (and no elements are
		implicitly inserted), the index '-' is always invalid. See example below.

		@throw out_of_range.403 if the JSON pointer describes a key of an object
		which cannot be found. See example below.

		@throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
		See example below.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Constant.

		@since version 2.0.0

		@liveexample{The behavior is shown in the example.,at_json_pointer_const}
		*/
		const_reference at(const json_pointer& ptr) const
		{
			return ptr.get_checked(this);
		}

		/*!
		@brief return flattened JSON value

		The function creates a JSON object whose keys are JSON pointers (see [RFC
		6901](https://tools.ietf.org/html/rfc6901)) and whose values are all
		primitive. The original JSON value can be restored using the @ref
		unflatten() function.

		@return an object that maps JSON pointers to primitive values

		@note Empty objects and arrays are flattened to `null` and will not be
			  reconstructed correctly by the @ref unflatten() function.

		@complexity Linear in the size the JSON value.

		@liveexample{The following code shows how a JSON object is flattened to an
		object whose keys consist of JSON pointers.,flatten}

		@sa @ref unflatten() for the reverse function

		@since version 2.0.0
		*/
		basic_json flatten() const
		{
			basic_json result(value_t::object);
			json_pointer::flatten("", *this, result);
			return result;
		}

		/*!
		@brief unflatten a previously flattened JSON value

		The function restores the arbitrary nesting of a JSON value that has been
		flattened before using the @ref flatten() function. The JSON value must
		meet certain constraints:
		1. The value must be an object.
		2. The keys must be JSON pointers (see
		   [RFC 6901](https://tools.ietf.org/html/rfc6901))
		3. The mapped values must be primitive JSON types.

		@return the original JSON from a flattened version

		@note Empty objects and arrays are flattened by @ref flatten() to `null`
			  values and can not unflattened to their original type. Apart from
			  this example, for a JSON value `j`, the following is always true:
			  `j == j.flatten().unflatten()`.

		@complexity Linear in the size the JSON value.

		@throw type_error.314  if value is not an object
		@throw type_error.315  if object values are not primitive

		@liveexample{The following code shows how a flattened JSON object is
		unflattened into the original nested JSON object.,unflatten}

		@sa @ref flatten() for the reverse function

		@since version 2.0.0
		*/
		basic_json unflatten() const
		{
			return json_pointer::unflatten(*this);
		}

		/// @}

		//////////////////////////
		// JSON Patch functions //
		//////////////////////////

		/// @name JSON Patch functions
		/// @{

		/*!
		@brief applies a JSON patch

		[JSON Patch](http://jsonpatch.com) defines a JSON document structure for
		expressing a sequence of operations to apply to a JSON) document. With
		this function, a JSON Patch is applied to the current JSON value by
		executing all operations from the patch.

		@param[in] json_patch  JSON patch document
		@return patched document

		@note The application of a patch is atomic: Either all operations succeed
			  and the patched document is returned or an exception is thrown. In
			  any case, the original value is not changed: the patch is applied
			  to a copy of the value.

		@throw parse_error.104 if the JSON patch does not consist of an array of
		objects

		@throw parse_error.105 if the JSON patch is malformed (e.g., mandatory
		attributes are missing); example: `"operation add must have member path"`

		@throw out_of_range.401 if an array index is out of range.

		@throw out_of_range.403 if a JSON pointer inside the patch could not be
		resolved successfully in the current JSON value; example: `"key baz not
		found"`

		@throw out_of_range.405 if JSON pointer has no parent ("add", "remove",
		"move")

		@throw other_error.501 if "test" operation was unsuccessful

		@complexity Linear in the size of the JSON value and the length of the
		JSON patch. As usually only a fraction of the JSON value is affected by
		the patch, the complexity can usually be neglected.

		@liveexample{The following code shows how a JSON patch is applied to a
		value.,patch}

		@sa @ref diff -- create a JSON patch by comparing two JSON values

		@sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)
		@sa [RFC 6901 (JSON Pointer)](https://tools.ietf.org/html/rfc6901)

		@since version 2.0.0
		*/
		basic_json patch(const basic_json& json_patch) const
		{
			// make a working copy to apply the patch to
			basic_json result = *this;

			// the valid JSON Patch operations
			enum class patch_operations { add, remove, replace, move, copy, test, invalid };

			const auto get_op = [](const std::string & op)
			{
				if (op == "add")
				{
					return patch_operations::add;
				}
				if (op == "remove")
				{
					return patch_operations::remove;
				}
				if (op == "replace")
				{
					return patch_operations::replace;
				}
				if (op == "move")
				{
					return patch_operations::move;
				}
				if (op == "copy")
				{
					return patch_operations::copy;
				}
				if (op == "test")
				{
					return patch_operations::test;
				}

				return patch_operations::invalid;
			};

			// wrapper for "add" operation; add value at ptr
			const auto operation_add = [&result](json_pointer & ptr, basic_json val)
			{
				// adding to the root of the target document means replacing it
				if (ptr.is_root())
				{
					result = val;
				}
				else
				{
					// make sure the top element of the pointer exists
					json_pointer top_pointer = ptr.top();
					if (top_pointer != ptr)
					{
						result.at(top_pointer);
					}

					// get reference to parent of JSON pointer ptr
					const auto last_path = ptr.pop_back();
					basic_json& parent = result[ptr];

					switch (parent.m_type)
					{
					case value_t::null:
					case value_t::object:
					{
						// use operator[] to add value
						parent[last_path] = val;
						break;
					}

					case value_t::array:
					{
						if (last_path == "-")
						{
							// special case: append to back
							parent.push_back(val);
						}
						else
						{
							const auto idx = json_pointer::array_index(last_path);
							if (JSON_UNLIKELY(static_cast<size_type>(idx) > parent.size()))
							{
								// avoid undefined behavior
								JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
							}
							else
							{
								// default case: insert add offset
								parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
							}
						}
						break;
					}

					// LCOV_EXCL_START
					default:
					{
						// if there exists a parent it cannot be primitive
						assert(false);
					}
					// LCOV_EXCL_STOP
					}
				}
			};

			// wrapper for "remove" operation; remove value at ptr
			const auto operation_remove = [&result](json_pointer & ptr)
			{
				// get reference to parent of JSON pointer ptr
				const auto last_path = ptr.pop_back();
				basic_json& parent = result.at(ptr);

				// remove child
				if (parent.is_object())
				{
					// perform range check
					auto it = parent.find(last_path);
					if (JSON_LIKELY(it != parent.end()))
					{
						parent.erase(it);
					}
					else
					{
						JSON_THROW(out_of_range::create(403, "key '" + last_path + "' not found"));
					}
				}
				else if (parent.is_array())
				{
					// note erase performs range check
					parent.erase(static_cast<size_type>(json_pointer::array_index(last_path)));
				}
			};

			// type check: top level value must be an array
			if (JSON_UNLIKELY(not json_patch.is_array()))
			{
				JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
			}

			// iterate and apply the operations
			for (const auto& val : json_patch)
			{
				// wrapper to get a value for an operation
				const auto get_value = [&val](const std::string & op,
					const std::string & member,
					bool string_type) -> basic_json &
				{
					// find value
					auto it = val.m_value.object->find(member);

					// context-sensitive error message
					const auto error_msg = (op == "op") ? "operation" : "operation '" + op + "'";

					// check if desired value is present
					if (JSON_UNLIKELY(it == val.m_value.object->end()))
					{
						JSON_THROW(parse_error::create(105, 0, error_msg + " must have member '" + member + "'"));
					}

					// check if result is of type string
					if (JSON_UNLIKELY(string_type and not it->second.is_string()))
					{
						JSON_THROW(parse_error::create(105, 0, error_msg + " must have string member '" + member + "'"));
					}

					// no error: return value
					return it->second;
				};

				// type check: every element of the array must be an object
				if (JSON_UNLIKELY(not val.is_object()))
				{
					JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
				}

				// collect mandatory members
				const std::string op = get_value("op", "op", true);
				const std::string path = get_value(op, "path", true);
				json_pointer ptr(path);

				switch (get_op(op))
				{
				case patch_operations::add:
				{
					operation_add(ptr, get_value("add", "value", false));
					break;
				}

				case patch_operations::remove:
				{
					operation_remove(ptr);
					break;
				}

				case patch_operations::replace:
				{
					// the "path" location must exist - use at()
					result.at(ptr) = get_value("replace", "value", false);
					break;
				}

				case patch_operations::move:
				{
					const std::string from_path = get_value("move", "from", true);
					json_pointer from_ptr(from_path);

					// the "from" location must exist - use at()
					basic_json v = result.at(from_ptr);

					// The move operation is functionally identical to a
					// "remove" operation on the "from" location, followed
					// immediately by an "add" operation at the target
					// location with the value that was just removed.
					operation_remove(from_ptr);
					operation_add(ptr, v);
					break;
				}

				case patch_operations::copy:
				{
					const std::string from_path = get_value("copy", "from", true);
					const json_pointer from_ptr(from_path);

					// the "from" location must exist - use at()
					basic_json v = result.at(from_ptr);

					// The copy is functionally identical to an "add"
					// operation at the target location using the value
					// specified in the "from" member.
					operation_add(ptr, v);
					break;
				}

				case patch_operations::test:
				{
					bool success = false;
					JSON_TRY
					{
						// check if "value" matches the one at "path"
						// the "path" location must exist - use at()
						success = (result.at(ptr) == get_value("test", "value", false));
					}
						JSON_INTERNAL_CATCH(out_of_range&)
					{
						// ignore out of range errors: success remains false
					}

					// throw an exception if test fails
					if (JSON_UNLIKELY(not success))
					{
						JSON_THROW(other_error::create(501, "unsuccessful: " + val.dump()));
					}

					break;
				}

				case patch_operations::invalid:
				{
					// op must be "add", "remove", "replace", "move", "copy", or
					// "test"
					JSON_THROW(parse_error::create(105, 0, "operation value '" + op + "' is invalid"));
				}
				}
			}

			return result;
		}

		/*!
		@brief creates a diff as a JSON patch

		Creates a [JSON Patch](http://jsonpatch.com) so that value @a source can
		be changed into the value @a target by calling @ref patch function.

		@invariant For two JSON values @a source and @a target, the following code
		yields always `true`:
		@code {.cpp}
		source.patch(diff(source, target)) == target;
		@endcode

		@note Currently, only `remove`, `add`, and `replace` operations are
			  generated.

		@param[in] source  JSON value to compare from
		@param[in] target  JSON value to compare against
		@param[in] path    helper value to create JSON pointers

		@return a JSON patch to convert the @a source to @a target

		@complexity Linear in the lengths of @a source and @a target.

		@liveexample{The following code shows how a JSON patch is created as a
		diff for two JSON values.,diff}

		@sa @ref patch -- apply a JSON patch
		@sa @ref merge_patch -- apply a JSON Merge Patch

		@sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)

		@since version 2.0.0
		*/
		static basic_json diff(const basic_json& source, const basic_json& target,
			const std::string& path = "")
		{
			// the patch
			basic_json result(value_t::array);

			// if the values are the same, return empty patch
			if (source == target)
			{
				return result;
			}

			if (source.type() != target.type())
			{
				// different types: replace value
				result.push_back(
					{
						{"op", "replace"}, {"path", path}, {"value", target}
					});
			}
			else
			{
				switch (source.type())
				{
				case value_t::array:
				{
					// first pass: traverse common elements
					std::size_t i = 0;
					while (i < source.size() and i < target.size())
					{
						// recursive call to compare array values at index i
						auto temp_diff = diff(source[i], target[i], path + "/" + std::to_string(i));
						result.insert(result.end(), temp_diff.begin(), temp_diff.end());
						++i;
					}

					// i now reached the end of at least one array
					// in a second pass, traverse the remaining elements

					// remove my remaining elements
					const auto end_index = static_cast<difference_type>(result.size());
					while (i < source.size())
					{
						// add operations in reverse order to avoid invalid
						// indices
						result.insert(result.begin() + end_index, object(
							{
								{"op", "remove"},
								{"path", path + "/" + std::to_string(i)}
							}));
						++i;
					}

					// add other remaining elements
					while (i < target.size())
					{
						result.push_back(
							{
								{"op", "add"},
								{"path", path + "/" + std::to_string(i)},
								{"value", target[i]}
							});
						++i;
					}

					break;
				}

				case value_t::object:
				{
					// first pass: traverse this object's elements
					for (auto it = source.cbegin(); it != source.cend(); ++it)
					{
						// escape the key name to be used in a JSON patch
						const auto key = json_pointer::escape(it.key());

						if (target.find(it.key()) != target.end())
						{
							// recursive call to compare object values at key it
							auto temp_diff = diff(it.value(), target[it.key()], path + "/" + key);
							result.insert(result.end(), temp_diff.begin(), temp_diff.end());
						}
						else
						{
							// found a key that is not in o -> remove it
							result.push_back(object(
								{
									{"op", "remove"}, {"path", path + "/" + key}
								}));
						}
					}

					// second pass: traverse other object's elements
					for (auto it = target.cbegin(); it != target.cend(); ++it)
					{
						if (source.find(it.key()) == source.end())
						{
							// found a key that is not in this -> add it
							const auto key = json_pointer::escape(it.key());
							result.push_back(
								{
									{"op", "add"}, {"path", path + "/" + key},
									{"value", it.value()}
								});
						}
					}

					break;
				}

				default:
				{
					// both primitive type: replace value
					result.push_back(
						{
							{"op", "replace"}, {"path", path}, {"value", target}
						});
					break;
				}
				}
			}

			return result;
		}

		/// @}

		////////////////////////////////
		// JSON Merge Patch functions //
		////////////////////////////////

		/// @name JSON Merge Patch functions
		/// @{

		/*!
		@brief applies a JSON Merge Patch

		The merge patch format is primarily intended for use with the HTTP PATCH
		method as a means of describing a set of modifications to a target
		resource's content. This function applies a merge patch to the current
		JSON value.

		The function implements the following algorithm from Section 2 of
		[RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396):

		```
		define MergePatch(Target, Patch):
		  if Patch is an Object:
			if Target is not an Object:
			  Target = {} // Ignore the contents and set it to an empty Object
			for each Name/Value pair in Patch:
			  if Value is null:
				if Name exists in Target:
				  remove the Name/Value pair from Target
			  else:
				Target[Name] = MergePatch(Target[Name], Value)
			return Target
		  else:
			return Patch
		```

		Thereby, `Target` is the current object; that is, the patch is applied to
		the current value.

		@param[in] patch  the patch to apply

		@complexity Linear in the lengths of @a patch.

		@liveexample{The following code shows how a JSON Merge Patch is applied to
		a JSON document.,merge_patch}

		@sa @ref patch -- apply a JSON patch
		@sa [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396)

		@since version 3.0.0
		*/
		void merge_patch(const basic_json& patch)
		{
			if (patch.is_object())
			{
				if (not is_object())
				{
					*this = object();
				}
				for (auto it = patch.begin(); it != patch.end(); ++it)
				{
					if (it.value().is_null())
					{
						erase(it.key());
					}
					else
					{
						operator[](it.key()).merge_patch(it.value());
					}
				}
			}
			else
			{
				*this = patch;
			}
		}

		/// @}
	};
} // namespace nlohmann

///////////////////////
// nonmember support //
///////////////////////

// specialization of std::swap, and std::hash
namespace std
{

	/// hash value for JSON objects
	template<>
	struct hash<nlohmann::json>
	{
		/*!
		@brief return a hash value for a JSON object

		@since version 1.0.0
		*/
		std::size_t operator()(const nlohmann::json& j) const
		{
			// a naive hashing via the string representation
			const auto& h = hash<nlohmann::json::string_t>();
			return h(j.dump());
		}
	};

	/// specialization for std::less<value_t>
	/// @note: do not remove the space after '<',
	///        see https://github.com/nlohmann/json/pull/679
	template<>
	struct less< ::nlohmann::detail::value_t>
	{
		/*!
		@brief compare two value_t enum values
		@since version 3.0.0
		*/
		bool operator()(nlohmann::detail::value_t lhs,
			nlohmann::detail::value_t rhs) const noexcept
		{
			return nlohmann::detail::operator<(lhs, rhs);
		}
	};

	/*!
	@brief exchanges the values of two JSON objects

	@since version 1.0.0
	*/
	template<>
	inline void swap<nlohmann::json>(nlohmann::json& j1, nlohmann::json& j2) noexcept(
		is_nothrow_move_constructible<nlohmann::json>::value and
		is_nothrow_move_assignable<nlohmann::json>::value
		)
	{
		j1.swap(j2);
	}

} // namespace std

/*!
@brief user-defined string literal for JSON values

This operator implements a user-defined string literal for JSON objects. It
can be used by adding `"_json"` to a string literal and returns a JSON object
if no parse error occurred.

@param[in] s  a string representation of a JSON object
@param[in] n  the length of string @a s
@return a JSON object

@since version 1.0.0
*/
inline nlohmann::json operator "" _json(const char* s, std::size_t n)
{
	return nlohmann::json::parse(s, s + n);
}

/*!
@brief user-defined string literal for JSON pointer

This operator implements a user-defined string literal for JSON Pointers. It
can be used by adding `"_json_pointer"` to a string literal and returns a JSON pointer
object if no parse error occurred.

@param[in] s  a string representation of a JSON Pointer
@param[in] n  the length of string @a s
@return a JSON pointer object

@since version 2.0.0
*/
inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
{
	return nlohmann::json::json_pointer(std::string(s, n));
}

// #include <nlohmann/detail/macro_unscope.hpp>


// restore GCC/clang diagnostic settings
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#endif
#if defined(__clang__)
#pragma GCC diagnostic pop
#endif

// clean up
#undef JSON_INTERNAL_CATCH
#undef JSON_CATCH
#undef JSON_THROW
#undef JSON_TRY
#undef JSON_LIKELY
#undef JSON_UNLIKELY
#undef JSON_DEPRECATED
#undef JSON_HAS_CPP_14
#undef JSON_HAS_CPP_17
#undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
#undef NLOHMANN_BASIC_JSON_TPL


#endif/*
	__ _____ _____ _____
 __|  |   __|     |   | |  JSON for Modern C++
|  |  |__   |  |  | | | |  version 3.3.0
|_____|_____|_____|_|___|  https://github.com/nlohmann/json

Licensed under the MIT License <http://opensource.org/licenses/MIT>.
SPDX-License-Identifier: MIT
Copyright (c) 2013-2018 Niels Lohmann <http://nlohmann.me>.

Permission is hereby  granted, free of charge, to any  person obtaining a copy
of this software and associated  documentation files (the "Software"), to deal
in the Software  without restriction, including without  limitation the rights
to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#ifndef NLOHMANN_JSON_HPP
#define NLOHMANN_JSON_HPP

#define NLOHMANN_JSON_VERSION_MAJOR 3
#define NLOHMANN_JSON_VERSION_MINOR 3
#define NLOHMANN_JSON_VERSION_PATCH 0

#include <algorithm> // all_of, find, for_each
#include <cassert> // assert
#include <ciso646> // and, not, or
#include <cstddef> // nullptr_t, ptrdiff_t, size_t
#include <functional> // hash, less
#include <initializer_list> // initializer_list
#include <iosfwd> // istream, ostream
#include <iterator> // iterator_traits, random_access_iterator_tag
#include <numeric> // accumulate
#include <string> // string, stoi, to_string
#include <utility> // declval, forward, move, pair, swap

// #include <nlohmann/json_fwd.hpp>
#ifndef NLOHMANN_JSON_FWD_HPP
#define NLOHMANN_JSON_FWD_HPP

#include <cstdint> // int64_t, uint64_t
#include <map> // map
#include <memory> // allocator
#include <string> // string
#include <vector> // vector

/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
namespace nlohmann
{
	/*!
	@brief default JSONSerializer template argument

	This serializer ignores the template arguments and uses ADL
	([argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl))
	for serialization.
	*/
	template<typename T = void, typename SFINAE = void>
	struct adl_serializer;

	template<template<typename U, typename V, typename... Args> class ObjectType =
		std::map,
		template<typename U, typename... Args> class ArrayType = std::vector,
		class StringType = std::string, class BooleanType = bool,
		class NumberIntegerType = std::int64_t,
		class NumberUnsignedType = std::uint64_t,
		class NumberFloatType = double,
		template<typename U> class AllocatorType = std::allocator,
		template<typename T, typename SFINAE = void> class JSONSerializer =
		adl_serializer>
		class basic_json;

	/*!
	@brief JSON Pointer

	A JSON pointer defines a string syntax for identifying a specific value
	within a JSON document. It can be used with functions `at` and
	`operator[]`. Furthermore, JSON pointers are the base for JSON patches.

	@sa [RFC 6901](https://tools.ietf.org/html/rfc6901)

	@since version 2.0.0
	*/
	template<typename BasicJsonType>
	class json_pointer;

	/*!
	@brief default JSON class

	This type is the default specialization of the @ref basic_json class which
	uses the standard template types.

	@since version 1.0.0
	*/
	using json = basic_json<>;
}

#endif

// #include <nlohmann/detail/macro_scope.hpp>


// This file contains all internal macro definitions
// You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them

// exclude unsupported compilers
#if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
#if defined(__clang__)
#if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
#error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"
#endif
#elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
#if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800
#error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"
#endif
#endif
#endif

// disable float-equal warnings on GCC/clang
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif

// disable documentation warnings on clang
#if defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdocumentation"
#endif

// allow for portable deprecation warnings
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
#define JSON_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define JSON_DEPRECATED __declspec(deprecated)
#else
#define JSON_DEPRECATED
#endif

// allow to disable exceptions
#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)
#define JSON_THROW(exception) throw exception
#define JSON_TRY try
#define JSON_CATCH(exception) catch(exception)
#define JSON_INTERNAL_CATCH(exception) catch(exception)
#else
#define JSON_THROW(exception) std::abort()
#define JSON_TRY if(true)
#define JSON_CATCH(exception) if(false)
#define JSON_INTERNAL_CATCH(exception) if(false)
#endif

// override exception macros
#if defined(JSON_THROW_USER)
#undef JSON_THROW
#define JSON_THROW JSON_THROW_USER
#endif
#if defined(JSON_TRY_USER)
#undef JSON_TRY
#define JSON_TRY JSON_TRY_USER
#endif
#if defined(JSON_CATCH_USER)
#undef JSON_CATCH
#define JSON_CATCH JSON_CATCH_USER
#undef JSON_INTERNAL_CATCH
#define JSON_INTERNAL_CATCH JSON_CATCH_USER
#endif
#if defined(JSON_INTERNAL_CATCH_USER)
#undef JSON_INTERNAL_CATCH
#define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
#endif

// manual branch prediction
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
#define JSON_LIKELY(x)      __builtin_expect(!!(x), 1)
#define JSON_UNLIKELY(x)    __builtin_expect(!!(x), 0)
#else
#define JSON_LIKELY(x)      x
#define JSON_UNLIKELY(x)    x
#endif

// C++ language standard detection
#if (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) // fix for issue #464
#define JSON_HAS_CPP_17
#define JSON_HAS_CPP_14
#elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
#define JSON_HAS_CPP_14
#endif

// Ugly macros to avoid uglier copy-paste when specializing basic_json. They
// may be removed in the future once the class is split.

#define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
    template<template<typename, typename, typename...> class ObjectType,   \
             template<typename, typename...> class ArrayType,              \
             class StringType, class BooleanType, class NumberIntegerType, \
             class NumberUnsignedType, class NumberFloatType,              \
             template<typename> class AllocatorType,                       \
             template<typename, typename = void> class JSONSerializer>

#define NLOHMANN_BASIC_JSON_TPL                                            \
    basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
    AllocatorType, JSONSerializer>

// #include <nlohmann/detail/meta/cpp_future.hpp>


#include <ciso646> // not
#include <cstddef> // size_t
#include <type_traits> // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type

namespace nlohmann
{
	namespace detail
	{
		// alias templates to reduce boilerplate
		template<bool B, typename T = void>
		using enable_if_t = typename std::enable_if<B, T>::type;

		template<typename T>
		using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;

		// implementation of C++14 index_sequence and affiliates
		// source: https://stackoverflow.com/a/32223343
		template<std::size_t... Ints>
		struct index_sequence
		{
			using type = index_sequence;
			using value_type = std::size_t;
			static constexpr std::size_t size() noexcept
			{
				return sizeof...(Ints);
			}
		};

		template<class Sequence1, class Sequence2>
		struct merge_and_renumber;

		template<std::size_t... I1, std::size_t... I2>
		struct merge_and_renumber<index_sequence<I1...>, index_sequence<I2...>>
			: index_sequence < I1..., (sizeof...(I1) + I2)... > {};

		template<std::size_t N>
		struct make_index_sequence
			: merge_and_renumber < typename make_index_sequence < N / 2 >::type,
			typename make_index_sequence < N - N / 2 >::type > {};

		template<> struct make_index_sequence<0> : index_sequence<> {};
		template<> struct make_index_sequence<1> : index_sequence<0> {};

		template<typename... Ts>
		using index_sequence_for = make_index_sequence<sizeof...(Ts)>;

		// dispatch utility (taken from ranges-v3)
		template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
		template<> struct priority_tag<0> {};

		// taken from ranges-v3
		template<typename T>
		struct static_const
		{
			static constexpr T value{};
		};

		template<typename T>
		constexpr T static_const<T>::value;
	}
}

// #include <nlohmann/detail/meta/type_traits.hpp>


#include <ciso646> // not
#include <limits> // numeric_limits
#include <type_traits> // false_type, is_constructible, is_integral, is_same, true_type
#include <utility> // declval

// #include <nlohmann/json_fwd.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/detected.hpp>


#include <type_traits>

// #include <nlohmann/detail/meta/void_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		template <typename ...Ts> struct make_void
		{
			using type = void;
		};
		template <typename ...Ts> using void_t = typename make_void<Ts...>::type;
	}
}


// http://en.cppreference.com/w/cpp/experimental/is_detected
namespace nlohmann
{
	namespace detail
	{
		struct nonesuch
		{
			nonesuch() = delete;
			~nonesuch() = delete;
			nonesuch(nonesuch const&) = delete;
			void operator=(nonesuch const&) = delete;
		};

		template <class Default,
			class AlwaysVoid,
			template <class...> class Op,
			class... Args>
			struct detector
		{
			using value_t = std::false_type;
			using type = Default;
		};

		template <class Default, template <class...> class Op, class... Args>
		struct detector<Default, void_t<Op<Args...>>, Op, Args...>
		{
			using value_t = std::true_type;
			using type = Op<Args...>;
		};

		template <template <class...> class Op, class... Args>
		using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;

		template <template <class...> class Op, class... Args>
		using detected_t = typename detector<nonesuch, void, Op, Args...>::type;

		template <class Default, template <class...> class Op, class... Args>
		using detected_or = detector<Default, void, Op, Args...>;

		template <class Default, template <class...> class Op, class... Args>
		using detected_or_t = typename detected_or<Default, Op, Args...>::type;

		template <class Expected, template <class...> class Op, class... Args>
		using is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;

		template <class To, template <class...> class Op, class... Args>
		using is_detected_convertible =
			std::is_convertible<detected_t<Op, Args...>, To>;
	}
}

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
	/*!
	@brief detail namespace with internal helper functions

	This namespace collects functions that should not be exposed,
	implementations of some @ref basic_json methods, and meta-programming helpers.

	@since version 2.1.0
	*/
	namespace detail
	{
		/////////////
		// helpers //
		/////////////

		template<typename> struct is_basic_json : std::false_type {};

		NLOHMANN_BASIC_JSON_TPL_DECLARATION
			struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};

		//////////////////////////
		// aliases for detected //
		//////////////////////////

		template <typename T>
		using mapped_type_t = typename T::mapped_type;

		template <typename T>
		using key_type_t = typename T::key_type;

		template <typename T>
		using value_type_t = typename T::value_type;

		template <typename T>
		using difference_type_t = typename T::difference_type;

		template <typename T>
		using pointer_t = typename T::pointer;

		template <typename T>
		using reference_t = typename T::reference;

		template <typename T>
		using iterator_category_t = typename T::iterator_category;

		template <typename T>
		using iterator_t = typename T::iterator;

		template <typename T, typename... Args>
		using to_json_function = decltype(T::to_json(std::declval<Args>()...));

		template <typename T, typename... Args>
		using from_json_function = decltype(T::from_json(std::declval<Args>()...));

		template <typename T, typename U>
		using get_template_function = decltype(std::declval<T>().template get<U>());

		///////////////////
		// is_ functions //
		///////////////////

		template <typename T, typename = void>
		struct is_iterator_traits : std::false_type {};

		template <typename T>
		struct is_iterator_traits<std::iterator_traits<T>>
		{
		private:
			using traits = std::iterator_traits<T>;

		public:
			static constexpr auto value =
				is_detected<value_type_t, traits>::value &&
				is_detected<difference_type_t, traits>::value &&
				is_detected<pointer_t, traits>::value &&
				is_detected<iterator_category_t, traits>::value &&
				is_detected<reference_t, traits>::value;
		};

		// source: https://stackoverflow.com/a/37193089/4116453

		template <typename T, typename = void>
		struct is_complete_type : std::false_type {};

		template <typename T>
		struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};

		template <typename BasicJsonType, typename CompatibleObjectType,
			typename = void>
			struct is_compatible_object_type_impl : std::false_type {};

		template <typename BasicJsonType, typename CompatibleObjectType>
		struct is_compatible_object_type_impl <
			BasicJsonType, CompatibleObjectType,
			enable_if_t<is_detected<mapped_type_t, CompatibleObjectType>::value and
			is_detected<key_type_t, CompatibleObjectType>::value >>
		{

			using object_t = typename BasicJsonType::object_t;

			// macOS's is_constructible does not play well with nonesuch...
			static constexpr bool value =
				std::is_constructible<typename object_t::key_type,
				typename CompatibleObjectType::key_type>::value and
				std::is_constructible<typename object_t::mapped_type,
				typename CompatibleObjectType::mapped_type>::value;
		};

		template <typename BasicJsonType, typename CompatibleObjectType>
		struct is_compatible_object_type
			: is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};

		template <typename BasicJsonType, typename CompatibleStringType,
			typename = void>
			struct is_compatible_string_type_impl : std::false_type {};

		template <typename BasicJsonType, typename CompatibleStringType>
		struct is_compatible_string_type_impl <
			BasicJsonType, CompatibleStringType,
			enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,
			value_type_t, CompatibleStringType>::value >>
		{
			static constexpr auto value =
				std::is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;
		};

		template <typename BasicJsonType, typename CompatibleStringType>
		struct is_compatible_string_type
			: is_compatible_string_type_impl<BasicJsonType, CompatibleStringType> {};

		template <typename BasicJsonType, typename CompatibleArrayType, typename = void>
		struct is_compatible_array_type_impl : std::false_type {};

		template <typename BasicJsonType, typename CompatibleArrayType>
		struct is_compatible_array_type_impl <
			BasicJsonType, CompatibleArrayType,
			enable_if_t<is_detected<value_type_t, CompatibleArrayType>::value and
			is_detected<iterator_t, CompatibleArrayType>::value >>
		{
			// This is needed because json_reverse_iterator has a ::iterator type...
			// Therefore it is detected as a CompatibleArrayType.
			// The real fix would be to have an Iterable concept.
			static constexpr bool value = not is_iterator_traits<std::iterator_traits<CompatibleArrayType>>::value;
		};

		template <typename BasicJsonType, typename CompatibleArrayType>
		struct is_compatible_array_type
			: is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};

		template <typename RealIntegerType, typename CompatibleNumberIntegerType,
			typename = void>
			struct is_compatible_integer_type_impl : std::false_type {};

		template <typename RealIntegerType, typename CompatibleNumberIntegerType>
		struct is_compatible_integer_type_impl <
			RealIntegerType, CompatibleNumberIntegerType,
			enable_if_t<std::is_integral<RealIntegerType>::value and
			std::is_integral<CompatibleNumberIntegerType>::value and
			not std::is_same<bool, CompatibleNumberIntegerType>::value >>
		{
			// is there an assert somewhere on overflows?
			using RealLimits = std::numeric_limits<RealIntegerType>;
			using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;

			static constexpr auto value =
				std::is_constructible<RealIntegerType,
				CompatibleNumberIntegerType>::value and
				CompatibleLimits::is_integer and
				RealLimits::is_signed == CompatibleLimits::is_signed;
		};

		template <typename RealIntegerType, typename CompatibleNumberIntegerType>
		struct is_compatible_integer_type
			: is_compatible_integer_type_impl<RealIntegerType,
			CompatibleNumberIntegerType> {};

		// trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists
		template <typename BasicJsonType, typename T, typename = void>
		struct has_from_json : std::false_type {};

		template <typename BasicJsonType, typename T>
		struct has_from_json<BasicJsonType, T,
			enable_if_t<not is_basic_json<T>::value>>
		{
			using serializer = typename BasicJsonType::template json_serializer<T, void>;

			static constexpr bool value =
				is_detected_exact<void, from_json_function, serializer,
				const BasicJsonType&, T&>::value;
		};

		// This trait checks if JSONSerializer<T>::from_json(json const&) exists
		// this overload is used for non-default-constructible user-defined-types
		template <typename BasicJsonType, typename T, typename = void>
		struct has_non_default_from_json : std::false_type {};

		template<typename BasicJsonType, typename T>
		struct has_non_default_from_json<BasicJsonType, T, enable_if_t<not is_basic_json<T>::value>>
		{
			using serializer = typename BasicJsonType::template json_serializer<T, void>;

			static constexpr bool value =
				is_detected_exact<T, from_json_function, serializer,
				const BasicJsonType&>::value;
		};

		// This trait checks if BasicJsonType::json_serializer<T>::to_json exists
		// Do not evaluate the trait when T is a basic_json type, to avoid template instantiation infinite recursion.
		template <typename BasicJsonType, typename T, typename = void>
		struct has_to_json : std::false_type {};

		template <typename BasicJsonType, typename T>
		struct has_to_json<BasicJsonType, T, enable_if_t<not is_basic_json<T>::value>>
		{
			using serializer = typename BasicJsonType::template json_serializer<T, void>;

			static constexpr bool value =
				is_detected_exact<void, to_json_function, serializer, BasicJsonType&,
				T>::value;
		};

		template <typename BasicJsonType, typename CompatibleType, typename = void>
		struct is_compatible_type_impl : std::false_type {};

		template <typename BasicJsonType, typename CompatibleType>
		struct is_compatible_type_impl <
			BasicJsonType, CompatibleType,
			enable_if_t<is_complete_type<CompatibleType>::value >>
		{
			static constexpr bool value =
				has_to_json<BasicJsonType, CompatibleType>::value;
		};

		template <typename BasicJsonType, typename CompatibleType>
		struct is_compatible_type
			: is_compatible_type_impl<BasicJsonType, CompatibleType> {};
	}
}

// #include <nlohmann/detail/exceptions.hpp>


#include <exception> // exception
#include <stdexcept> // runtime_error
#include <string> // to_string

namespace nlohmann
{
	namespace detail
	{
		////////////////
		// exceptions //
		////////////////

		/*!
		@brief general exception of the @ref basic_json class

		This class is an extension of `std::exception` objects with a member @a id for
		exception ids. It is used as the base class for all exceptions thrown by the
		@ref basic_json class. This class can hence be used as "wildcard" to catch
		exceptions.

		Subclasses:
		- @ref parse_error for exceptions indicating a parse error
		- @ref invalid_iterator for exceptions indicating errors with iterators
		- @ref type_error for exceptions indicating executing a member function with
						  a wrong type
		- @ref out_of_range for exceptions indicating access out of the defined range
		- @ref other_error for exceptions indicating other library errors

		@internal
		@note To have nothrow-copy-constructible exceptions, we internally use
			  `std::runtime_error` which can cope with arbitrary-length error messages.
			  Intermediate strings are built with static functions and then passed to
			  the actual constructor.
		@endinternal

		@liveexample{The following code shows how arbitrary library exceptions can be
		caught.,exception}

		@since version 3.0.0
		*/
		class exception : public std::exception
		{
		public:
			/// returns the explanatory string
			const char* what() const noexcept override
			{
				return m.what();
			}

			/// the id of the exception
			const int id;

		protected:
			exception(int id_, const char* what_arg) : id(id_), m(what_arg) {}

			static std::string name(const std::string& ename, int id_)
			{
				return "[json.exception." + ename + "." + std::to_string(id_) + "] ";
			}

		private:
			/// an exception object as storage for error messages
			std::runtime_error m;
		};

		/*!
		@brief exception indicating a parse error

		This exception is thrown by the library when a parse error occurs. Parse errors
		can occur during the deserialization of JSON text, CBOR, MessagePack, as well
		as when using JSON Patch.

		Member @a byte holds the byte index of the last read character in the input
		file.

		Exceptions have ids 1xx.

		name / id                      | example message | description
		------------------------------ | --------------- | -------------------------
		json.exception.parse_error.101 | parse error at 2: unexpected end of input; expected string literal | This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member @a byte indicates the error position.
		json.exception.parse_error.102 | parse error at 14: missing or wrong low surrogate | JSON uses the `\uxxxx` format to describe Unicode characters. Code points above above 0xFFFF are split into two `\uxxxx` entries ("surrogate pairs"). This error indicates that the surrogate pair is incomplete or contains an invalid code point.
		json.exception.parse_error.103 | parse error: code points above 0x10FFFF are invalid | Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.
		json.exception.parse_error.104 | parse error: JSON patch must be an array of objects | [RFC 6902](https://tools.ietf.org/html/rfc6902) requires a JSON Patch document to be a JSON document that represents an array of objects.
		json.exception.parse_error.105 | parse error: operation must have string member 'op' | An operation of a JSON Patch document must contain exactly one "op" member, whose value indicates the operation to perform. Its value must be one of "add", "remove", "replace", "move", "copy", or "test"; other values are errors.
		json.exception.parse_error.106 | parse error: array index '01' must not begin with '0' | An array index in a JSON Pointer ([RFC 6901](https://tools.ietf.org/html/rfc6901)) may be `0` or any number without a leading `0`.
		json.exception.parse_error.107 | parse error: JSON pointer must be empty or begin with '/' - was: 'foo' | A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a `/` character.
		json.exception.parse_error.108 | parse error: escape character '~' must be followed with '0' or '1' | In a JSON Pointer, only `~0` and `~1` are valid escape sequences.
		json.exception.parse_error.109 | parse error: array index 'one' is not a number | A JSON Pointer array index must be a number.
		json.exception.parse_error.110 | parse error at 1: cannot read 2 bytes from vector | When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.
		json.exception.parse_error.112 | parse error at 1: error reading CBOR; last byte: 0xF8 | Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read.
		json.exception.parse_error.113 | parse error at 2: expected a CBOR string; last byte: 0x98 | While parsing a map key, a value that is not a string has been read.

		@note For an input with n bytes, 1 is the index of the first character and n+1
			  is the index of the terminating null byte or the end of file. This also
			  holds true when reading a byte vector (CBOR or MessagePack).

		@liveexample{The following code shows how a `parse_error` exception can be
		caught.,parse_error}

		@sa @ref exception for the base class of the library exceptions
		@sa @ref invalid_iterator for exceptions indicating errors with iterators
		@sa @ref type_error for exceptions indicating executing a member function with
							a wrong type
		@sa @ref out_of_range for exceptions indicating access out of the defined range
		@sa @ref other_error for exceptions indicating other library errors

		@since version 3.0.0
		*/
		class parse_error : public exception
		{
		public:
			/*!
			@brief create a parse error exception
			@param[in] id_       the id of the exception
			@param[in] byte_     the byte index where the error occurred (or 0 if the
								 position cannot be determined)
			@param[in] what_arg  the explanatory string
			@return parse_error object
			*/
			static parse_error create(int id_, std::size_t byte_, const std::string& what_arg)
			{
				std::string w = exception::name("parse_error", id_) + "parse error" +
					(byte_ != 0 ? (" at " + std::to_string(byte_)) : "") +
					": " + what_arg;
				return parse_error(id_, byte_, w.c_str());
			}

			/*!
			@brief byte index of the parse error

			The byte index of the last read character in the input file.

			@note For an input with n bytes, 1 is the index of the first character and
				  n+1 is the index of the terminating null byte or the end of file.
				  This also holds true when reading a byte vector (CBOR or MessagePack).
			*/
			const std::size_t byte;

		private:
			parse_error(int id_, std::size_t byte_, const char* what_arg)
				: exception(id_, what_arg), byte(byte_) {}
		};

		/*!
		@brief exception indicating errors with iterators

		This exception is thrown if iterators passed to a library function do not match
		the expected semantics.

		Exceptions have ids 2xx.

		name / id                           | example message | description
		----------------------------------- | --------------- | -------------------------
		json.exception.invalid_iterator.201 | iterators are not compatible | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
		json.exception.invalid_iterator.202 | iterator does not fit current value | In an erase or insert function, the passed iterator @a pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.
		json.exception.invalid_iterator.203 | iterators do not fit current value | Either iterator passed to function @ref erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.
		json.exception.invalid_iterator.204 | iterators out of range | When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly (@ref begin(), @ref end()), because this is the only way the single stored value is expressed. All other ranges are invalid.
		json.exception.invalid_iterator.205 | iterator out of range | When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the @ref begin() iterator, because it is the only way to address the stored value. All other iterators are invalid.
		json.exception.invalid_iterator.206 | cannot construct with iterators from null | The iterators passed to constructor @ref basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range.
		json.exception.invalid_iterator.207 | cannot use key() for non-object iterators | The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.
		json.exception.invalid_iterator.208 | cannot use operator[] for object iterators | The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
		json.exception.invalid_iterator.209 | cannot use offsets with object iterators | The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.
		json.exception.invalid_iterator.210 | iterators do not fit | The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.
		json.exception.invalid_iterator.211 | passed iterators may not belong to container | The iterator range passed to the insert function must not be a subrange of the container to insert to.
		json.exception.invalid_iterator.212 | cannot compare iterators of different containers | When two iterators are compared, they must belong to the same container.
		json.exception.invalid_iterator.213 | cannot compare order of object iterators | The order of object iterators cannot be compared, because JSON objects are unordered.
		json.exception.invalid_iterator.214 | cannot get value | Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to @ref begin().

		@liveexample{The following code shows how an `invalid_iterator` exception can be
		caught.,invalid_iterator}

		@sa @ref exception for the base class of the library exceptions
		@sa @ref parse_error for exceptions indicating a parse error
		@sa @ref type_error for exceptions indicating executing a member function with
							a wrong type
		@sa @ref out_of_range for exceptions indicating access out of the defined range
		@sa @ref other_error for exceptions indicating other library errors

		@since version 3.0.0
		*/
		class invalid_iterator : public exception
		{
		public:
			static invalid_iterator create(int id_, const std::string& what_arg)
			{
				std::string w = exception::name("invalid_iterator", id_) + what_arg;
				return invalid_iterator(id_, w.c_str());
			}

		private:
			invalid_iterator(int id_, const char* what_arg)
				: exception(id_, what_arg) {}
		};

		/*!
		@brief exception indicating executing a member function with a wrong type

		This exception is thrown in case of a type error; that is, a library function is
		executed on a JSON value whose type does not match the expected semantics.

		Exceptions have ids 3xx.

		name / id                     | example message | description
		----------------------------- | --------------- | -------------------------
		json.exception.type_error.301 | cannot create object from initializer list | To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.
		json.exception.type_error.302 | type must be object, but is array | During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.
		json.exception.type_error.303 | incompatible ReferenceType for get_ref, actual type is object | To retrieve a reference to a value stored in a @ref basic_json object with @ref get_ref, the type of the reference must match the value type. For instance, for a JSON array, the @a ReferenceType must be @ref array_t&.
		json.exception.type_error.304 | cannot use at() with string | The @ref at() member functions can only be executed for certain JSON types.
		json.exception.type_error.305 | cannot use operator[] with string | The @ref operator[] member functions can only be executed for certain JSON types.
		json.exception.type_error.306 | cannot use value() with string | The @ref value() member functions can only be executed for certain JSON types.
		json.exception.type_error.307 | cannot use erase() with string | The @ref erase() member functions can only be executed for certain JSON types.
		json.exception.type_error.308 | cannot use push_back() with string | The @ref push_back() and @ref operator+= member functions can only be executed for certain JSON types.
		json.exception.type_error.309 | cannot use insert() with | The @ref insert() member functions can only be executed for certain JSON types.
		json.exception.type_error.310 | cannot use swap() with number | The @ref swap() member functions can only be executed for certain JSON types.
		json.exception.type_error.311 | cannot use emplace_back() with string | The @ref emplace_back() member function can only be executed for certain JSON types.
		json.exception.type_error.312 | cannot use update() with string | The @ref update() member functions can only be executed for certain JSON types.
		json.exception.type_error.313 | invalid value to unflatten | The @ref unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined.
		json.exception.type_error.314 | only objects can be unflattened | The @ref unflatten function only works for an object whose keys are JSON Pointers.
		json.exception.type_error.315 | values in object must be primitive | The @ref unflatten function only works for an object whose keys are JSON Pointers and whose values are primitive.
		json.exception.type_error.316 | invalid UTF-8 byte at index 10: 0x7E | The @ref dump function only works with UTF-8 encoded strings; that is, if you assign a `std::string` to a JSON value, make sure it is UTF-8 encoded. |

		@liveexample{The following code shows how a `type_error` exception can be
		caught.,type_error}

		@sa @ref exception for the base class of the library exceptions
		@sa @ref parse_error for exceptions indicating a parse error
		@sa @ref invalid_iterator for exceptions indicating errors with iterators
		@sa @ref out_of_range for exceptions indicating access out of the defined range
		@sa @ref other_error for exceptions indicating other library errors

		@since version 3.0.0
		*/
		class type_error : public exception
		{
		public:
			static type_error create(int id_, const std::string& what_arg)
			{
				std::string w = exception::name("type_error", id_) + what_arg;
				return type_error(id_, w.c_str());
			}

		private:
			type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
		};

		/*!
		@brief exception indicating access out of the defined range

		This exception is thrown in case a library function is called on an input
		parameter that exceeds the expected range, for instance in case of array
		indices or nonexisting object keys.

		Exceptions have ids 4xx.

		name / id                       | example message | description
		------------------------------- | --------------- | -------------------------
		json.exception.out_of_range.401 | array index 3 is out of range | The provided array index @a i is larger than @a size-1.
		json.exception.out_of_range.402 | array index '-' (3) is out of range | The special array index `-` in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.
		json.exception.out_of_range.403 | key 'foo' not found | The provided key was not found in the JSON object.
		json.exception.out_of_range.404 | unresolved reference token 'foo' | A reference token in a JSON Pointer could not be resolved.
		json.exception.out_of_range.405 | JSON pointer has no parent | The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value.
		json.exception.out_of_range.406 | number overflow parsing '10E1000' | A parsed number could not be stored as without changing it to NaN or INF.
		json.exception.out_of_range.407 | number overflow serializing '9223372036854775808' | UBJSON only supports integers numbers up to 9223372036854775807. |
		json.exception.out_of_range.408 | excessive array size: 8658170730974374167 | The size (following `#`) of an UBJSON array or object exceeds the maximal capacity. |

		@liveexample{The following code shows how an `out_of_range` exception can be
		caught.,out_of_range}

		@sa @ref exception for the base class of the library exceptions
		@sa @ref parse_error for exceptions indicating a parse error
		@sa @ref invalid_iterator for exceptions indicating errors with iterators
		@sa @ref type_error for exceptions indicating executing a member function with
							a wrong type
		@sa @ref other_error for exceptions indicating other library errors

		@since version 3.0.0
		*/
		class out_of_range : public exception
		{
		public:
			static out_of_range create(int id_, const std::string& what_arg)
			{
				std::string w = exception::name("out_of_range", id_) + what_arg;
				return out_of_range(id_, w.c_str());
			}

		private:
			out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
		};

		/*!
		@brief exception indicating other library errors

		This exception is thrown in case of errors that cannot be classified with the
		other exception types.

		Exceptions have ids 5xx.

		name / id                      | example message | description
		------------------------------ | --------------- | -------------------------
		json.exception.other_error.501 | unsuccessful: {"op":"test","path":"/baz", "value":"bar"} | A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.

		@sa @ref exception for the base class of the library exceptions
		@sa @ref parse_error for exceptions indicating a parse error
		@sa @ref invalid_iterator for exceptions indicating errors with iterators
		@sa @ref type_error for exceptions indicating executing a member function with
							a wrong type
		@sa @ref out_of_range for exceptions indicating access out of the defined range

		@liveexample{The following code shows how an `other_error` exception can be
		caught.,other_error}

		@since version 3.0.0
		*/
		class other_error : public exception
		{
		public:
			static other_error create(int id_, const std::string& what_arg)
			{
				std::string w = exception::name("other_error", id_) + what_arg;
				return other_error(id_, w.c_str());
			}

		private:
			other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
		};
	}
}

// #include <nlohmann/detail/value_t.hpp>


#include <array> // array
#include <ciso646> // and
#include <cstddef> // size_t
#include <cstdint> // uint8_t

namespace nlohmann
{
	namespace detail
	{
		///////////////////////////
		// JSON type enumeration //
		///////////////////////////

		/*!
		@brief the JSON type enumeration

		This enumeration collects the different JSON types. It is internally used to
		distinguish the stored values, and the functions @ref basic_json::is_null(),
		@ref basic_json::is_object(), @ref basic_json::is_array(),
		@ref basic_json::is_string(), @ref basic_json::is_boolean(),
		@ref basic_json::is_number() (with @ref basic_json::is_number_integer(),
		@ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),
		@ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and
		@ref basic_json::is_structured() rely on it.

		@note There are three enumeration entries (number_integer, number_unsigned, and
		number_float), because the library distinguishes these three types for numbers:
		@ref basic_json::number_unsigned_t is used for unsigned integers,
		@ref basic_json::number_integer_t is used for signed integers, and
		@ref basic_json::number_float_t is used for floating-point numbers or to
		approximate integers which do not fit in the limits of their respective type.

		@sa @ref basic_json::basic_json(const value_t value_type) -- create a JSON
		value with the default value for a given type

		@since version 1.0.0
		*/
		enum class value_t : std::uint8_t
		{
			null,             ///< null value
			object,           ///< object (unordered set of name/value pairs)
			array,            ///< array (ordered collection of values)
			string,           ///< string value
			boolean,          ///< boolean value
			number_integer,   ///< number value (signed integer)
			number_unsigned,  ///< number value (unsigned integer)
			number_float,     ///< number value (floating-point)
			discarded         ///< discarded by the the parser callback function
		};

		/*!
		@brief comparison operator for JSON types

		Returns an ordering that is similar to Python:
		- order: null < boolean < number < object < array < string
		- furthermore, each type is not smaller than itself
		- discarded values are not comparable

		@since version 1.0.0
		*/
		inline bool operator<(const value_t lhs, const value_t rhs) noexcept
		{
			static constexpr std::array<std::uint8_t, 8> order = { {
					0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,
					1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */
				}
			};

			const auto l_index = static_cast<std::size_t>(lhs);
			const auto r_index = static_cast<std::size_t>(rhs);
			return l_index < order.size() and r_index < order.size() and order[l_index] < order[r_index];
		}
	}
}

// #include <nlohmann/detail/conversions/from_json.hpp>


#include <algorithm> // transform
#include <array> // array
#include <ciso646> // and, not
#include <forward_list> // forward_list
#include <iterator> // inserter, front_inserter, end
#include <map> // map
#include <string> // string
#include <tuple> // tuple, make_tuple
#include <type_traits> // is_arithmetic, is_same, is_enum, underlying_type, is_convertible
#include <unordered_map> // unordered_map
#include <utility> // pair, declval
#include <valarray> // valarray

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		template<typename BasicJsonType>
		void from_json(const BasicJsonType& j, typename std::nullptr_t& n)
		{
			if (JSON_UNLIKELY(not j.is_null()))
			{
				JSON_THROW(type_error::create(302, "type must be null, but is " + std::string(j.type_name())));
			}
			n = nullptr;
		}

		// overloads for basic_json template parameters
		template<typename BasicJsonType, typename ArithmeticType,
			enable_if_t<std::is_arithmetic<ArithmeticType>::value and
			not std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
			int> = 0>
			void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
		{
			switch (static_cast<value_t>(j))
			{
			case value_t::number_unsigned:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
				break;
			}
			case value_t::number_integer:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
				break;
			}
			case value_t::number_float:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
				break;
			}

			default:
				JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
			}
		}

		template<typename BasicJsonType>
		void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
		{
			if (JSON_UNLIKELY(not j.is_boolean()))
			{
				JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(j.type_name())));
			}
			b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
		}

		template<typename BasicJsonType>
		void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
		{
			if (JSON_UNLIKELY(not j.is_string()))
			{
				JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
			}
			s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
		}

		template <
			typename BasicJsonType, typename CompatibleStringType,
			enable_if_t <
			is_compatible_string_type<BasicJsonType, CompatibleStringType>::value and
			not std::is_same<typename BasicJsonType::string_t,
			CompatibleStringType>::value,
			int > = 0 >
			void from_json(const BasicJsonType& j, CompatibleStringType& s)
		{
			if (JSON_UNLIKELY(not j.is_string()))
			{
				JSON_THROW(type_error::create(302, "type must be string, but is " + std::string(j.type_name())));
			}

			s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
		}

		template<typename BasicJsonType>
		void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
		{
			get_arithmetic_value(j, val);
		}

		template<typename BasicJsonType>
		void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
		{
			get_arithmetic_value(j, val);
		}

		template<typename BasicJsonType>
		void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
		{
			get_arithmetic_value(j, val);
		}

		template<typename BasicJsonType, typename EnumType,
			enable_if_t<std::is_enum<EnumType>::value, int> = 0>
			void from_json(const BasicJsonType& j, EnumType& e)
		{
			typename std::underlying_type<EnumType>::type val;
			get_arithmetic_value(j, val);
			e = static_cast<EnumType>(val);
		}

		// forward_list doesn't have an insert method
		template<typename BasicJsonType, typename T, typename Allocator,
			enable_if_t<std::is_convertible<BasicJsonType, T>::value, int> = 0>
			void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
		{
			if (JSON_UNLIKELY(not j.is_array()))
			{
				JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
			}
			std::transform(j.rbegin(), j.rend(),
				std::front_inserter(l), [](const BasicJsonType & i)
			{
				return i.template get<T>();
			});
		}

		// valarray doesn't have an insert method
		template<typename BasicJsonType, typename T,
			enable_if_t<std::is_convertible<BasicJsonType, T>::value, int> = 0>
			void from_json(const BasicJsonType& j, std::valarray<T>& l)
		{
			if (JSON_UNLIKELY(not j.is_array()))
			{
				JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
			}
			l.resize(j.size());
			std::copy(j.m_value.array->begin(), j.m_value.array->end(), std::begin(l));
		}

		template<typename BasicJsonType>
		void from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> /*unused*/)
		{
			arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
		}

		template <typename BasicJsonType, typename T, std::size_t N>
		auto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,
			priority_tag<2> /*unused*/)
			-> decltype(j.template get<T>(), void())
		{
			for (std::size_t i = 0; i < N; ++i)
			{
				arr[i] = j.at(i).template get<T>();
			}
		}

		template<typename BasicJsonType, typename CompatibleArrayType>
		auto from_json_array_impl(const BasicJsonType& j, CompatibleArrayType& arr, priority_tag<1> /*unused*/)
			-> decltype(
				arr.reserve(std::declval<typename CompatibleArrayType::size_type>()),
				j.template get<typename CompatibleArrayType::value_type>(),
				void())
		{
			using std::end;

			arr.reserve(j.size());
			std::transform(j.begin(), j.end(),
				std::inserter(arr, end(arr)), [](const BasicJsonType & i)
			{
				// get<BasicJsonType>() returns *this, this won't call a from_json
				// method when value_type is BasicJsonType
				return i.template get<typename CompatibleArrayType::value_type>();
			});
		}

		template <typename BasicJsonType, typename CompatibleArrayType>
		void from_json_array_impl(const BasicJsonType& j, CompatibleArrayType& arr,
			priority_tag<0> /*unused*/)
		{
			using std::end;

			std::transform(
				j.begin(), j.end(), std::inserter(arr, end(arr)),
				[](const BasicJsonType & i)
			{
				// get<BasicJsonType>() returns *this, this won't call a from_json
				// method when value_type is BasicJsonType
				return i.template get<typename CompatibleArrayType::value_type>();
			});
		}

		template <typename BasicJsonType, typename CompatibleArrayType,
			enable_if_t <
			is_compatible_array_type<BasicJsonType, CompatibleArrayType>::value and
			not is_compatible_object_type<BasicJsonType, CompatibleArrayType>::value and
			not is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value and
			not is_basic_json<CompatibleArrayType>::value,
			int > = 0 >

			auto from_json(const BasicJsonType& j, CompatibleArrayType& arr)
			-> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
				j.template get<typename CompatibleArrayType::value_type>(),
				void())
		{
			if (JSON_UNLIKELY(not j.is_array()))
			{
				JSON_THROW(type_error::create(302, "type must be array, but is " +
					std::string(j.type_name())));
			}

			from_json_array_impl(j, arr, priority_tag<3> {});
		}

		template<typename BasicJsonType, typename CompatibleObjectType,
			enable_if_t<is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value, int> = 0>
			void from_json(const BasicJsonType& j, CompatibleObjectType& obj)
		{
			if (JSON_UNLIKELY(not j.is_object()))
			{
				JSON_THROW(type_error::create(302, "type must be object, but is " + std::string(j.type_name())));
			}

			auto inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
			using value_type = typename CompatibleObjectType::value_type;
			std::transform(
				inner_object->begin(), inner_object->end(),
				std::inserter(obj, obj.begin()),
				[](typename BasicJsonType::object_t::value_type const & p)
			{
				return value_type(p.first, p.second.template get<typename CompatibleObjectType::mapped_type>());
			});
		}

		// overload for arithmetic types, not chosen for basic_json template arguments
		// (BooleanType, etc..); note: Is it really necessary to provide explicit
		// overloads for boolean_t etc. in case of a custom BooleanType which is not
		// an arithmetic type?
		template<typename BasicJsonType, typename ArithmeticType,
			enable_if_t <
			std::is_arithmetic<ArithmeticType>::value and
			not std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value and
			not std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value and
			not std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value and
			not std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
			int> = 0>
			void from_json(const BasicJsonType& j, ArithmeticType& val)
		{
			switch (static_cast<value_t>(j))
			{
			case value_t::number_unsigned:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
				break;
			}
			case value_t::number_integer:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
				break;
			}
			case value_t::number_float:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
				break;
			}
			case value_t::boolean:
			{
				val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
				break;
			}

			default:
				JSON_THROW(type_error::create(302, "type must be number, but is " + std::string(j.type_name())));
			}
		}

		template<typename BasicJsonType, typename A1, typename A2>
		void from_json(const BasicJsonType& j, std::pair<A1, A2>& p)
		{
			p = { j.at(0).template get<A1>(), j.at(1).template get<A2>() };
		}

		template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
		void from_json_tuple_impl(const BasicJsonType& j, Tuple& t, index_sequence<Idx...>)
		{
			t = std::make_tuple(j.at(Idx).template get<typename std::tuple_element<Idx, Tuple>::type>()...);
		}

		template<typename BasicJsonType, typename... Args>
		void from_json(const BasicJsonType& j, std::tuple<Args...>& t)
		{
			from_json_tuple_impl(j, t, index_sequence_for<Args...> {});
		}

		template <typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
			typename = enable_if_t<not std::is_constructible<
			typename BasicJsonType::string_t, Key>::value>>
			void from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)
		{
			if (JSON_UNLIKELY(not j.is_array()))
			{
				JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
			}
			for (const auto& p : j)
			{
				if (JSON_UNLIKELY(not p.is_array()))
				{
					JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name())));
				}
				m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
			}
		}

		template <typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
			typename = enable_if_t<not std::is_constructible<
			typename BasicJsonType::string_t, Key>::value>>
			void from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)
		{
			if (JSON_UNLIKELY(not j.is_array()))
			{
				JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(j.type_name())));
			}
			for (const auto& p : j)
			{
				if (JSON_UNLIKELY(not p.is_array()))
				{
					JSON_THROW(type_error::create(302, "type must be array, but is " + std::string(p.type_name())));
				}
				m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
			}
		}

		struct from_json_fn
		{
			template<typename BasicJsonType, typename T>
			auto operator()(const BasicJsonType& j, T& val) const
				noexcept(noexcept(from_json(j, val)))
				-> decltype(from_json(j, val), void())
			{
				return from_json(j, val);
			}
		};
	}

	/// namespace to hold default `from_json` function
	/// to see why this is required:
	/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
	namespace
	{
		constexpr const auto& from_json = detail::static_const<detail::from_json_fn>::value;
	}
}

// #include <nlohmann/detail/conversions/to_json.hpp>


#include <ciso646> // or, and, not
#include <iterator> // begin, end
#include <tuple> // tuple, get
#include <type_traits> // is_same, is_constructible, is_floating_point, is_enum, underlying_type
#include <utility> // move, forward, declval, pair
#include <valarray> // valarray
#include <vector> // vector

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>


#include <cstddef> // size_t
#include <string> // string, to_string
#include <iterator> // input_iterator_tag

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		/// proxy class for the items() function
		template<typename IteratorType> class iteration_proxy
		{
		private:
			/// helper class for iteration
			class iteration_proxy_internal
			{
			public:
				using difference_type = std::ptrdiff_t;
				using value_type = iteration_proxy_internal;
				using pointer = iteration_proxy_internal * ;
				using reference = iteration_proxy_internal & ;
				using iterator_category = std::input_iterator_tag;

			private:
				/// the iterator
				IteratorType anchor;
				/// an index for arrays (used to create key names)
				std::size_t array_index = 0;
				/// last stringified array index
				mutable std::size_t array_index_last = 0;
				/// a string representation of the array index
				mutable std::string array_index_str = "0";
				/// an empty string (to return a reference for primitive values)
				const std::string empty_str = "";

			public:
				explicit iteration_proxy_internal(IteratorType it) noexcept : anchor(it) {}

				iteration_proxy_internal(const iteration_proxy_internal&) = default;
				iteration_proxy_internal& operator=(const iteration_proxy_internal&) = default;

				/// dereference operator (needed for range-based for)
				iteration_proxy_internal& operator*()
				{
					return *this;
				}

				/// increment operator (needed for range-based for)
				iteration_proxy_internal& operator++()
				{
					++anchor;
					++array_index;

					return *this;
				}

				/// equality operator (needed for InputIterator)
				bool operator==(const iteration_proxy_internal& o) const noexcept
				{
					return anchor == o.anchor;
				}

				/// inequality operator (needed for range-based for)
				bool operator!=(const iteration_proxy_internal& o) const noexcept
				{
					return anchor != o.anchor;
				}

				/// return key of the iterator
				const std::string& key() const
				{
					assert(anchor.m_object != nullptr);

					switch (anchor.m_object->type())
					{
						// use integer array index as key
					case value_t::array:
					{
						if (array_index != array_index_last)
						{
							array_index_str = std::to_string(array_index);
							array_index_last = array_index;
						}
						return array_index_str;
					}

					// use key from the object
					case value_t::object:
						return anchor.key();

						// use an empty key for all primitive types
					default:
						return empty_str;
					}
				}

				/// return value of the iterator
				typename IteratorType::reference value() const
				{
					return anchor.value();
				}
			};

			/// the container to iterate
			typename IteratorType::reference container;

		public:
			/// construct iteration proxy from a container
			explicit iteration_proxy(typename IteratorType::reference cont) noexcept
				: container(cont) {}

			/// return iterator begin (needed for range-based for)
			iteration_proxy_internal begin() noexcept
			{
				return iteration_proxy_internal(container.begin());
			}

			/// return iterator end (needed for range-based for)
			iteration_proxy_internal end() noexcept
			{
				return iteration_proxy_internal(container.end());
			}
		};
	}
}


namespace nlohmann
{
	namespace detail
	{
		//////////////////
		// constructors //
		//////////////////

		template<value_t> struct external_constructor;

		template<>
		struct external_constructor<value_t::boolean>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
			{
				j.m_type = value_t::boolean;
				j.m_value = b;
				j.assert_invariant();
			}
		};

		template<>
		struct external_constructor<value_t::string>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
			{
				j.m_type = value_t::string;
				j.m_value = s;
				j.assert_invariant();
			}

			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
			{
				j.m_type = value_t::string;
				j.m_value = std::move(s);
				j.assert_invariant();
			}

			template<typename BasicJsonType, typename CompatibleStringType,
				enable_if_t<not std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,
				int> = 0>
				static void construct(BasicJsonType& j, const CompatibleStringType& str)
			{
				j.m_type = value_t::string;
				j.m_value.string = j.template create<typename BasicJsonType::string_t>(str);
				j.assert_invariant();
			}
		};

		template<>
		struct external_constructor<value_t::number_float>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
			{
				j.m_type = value_t::number_float;
				j.m_value = val;
				j.assert_invariant();
			}
		};

		template<>
		struct external_constructor<value_t::number_unsigned>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
			{
				j.m_type = value_t::number_unsigned;
				j.m_value = val;
				j.assert_invariant();
			}
		};

		template<>
		struct external_constructor<value_t::number_integer>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
			{
				j.m_type = value_t::number_integer;
				j.m_value = val;
				j.assert_invariant();
			}
		};

		template<>
		struct external_constructor<value_t::array>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
			{
				j.m_type = value_t::array;
				j.m_value = arr;
				j.assert_invariant();
			}

			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
			{
				j.m_type = value_t::array;
				j.m_value = std::move(arr);
				j.assert_invariant();
			}

			template<typename BasicJsonType, typename CompatibleArrayType,
				enable_if_t<not std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
				int> = 0>
				static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
			{
				using std::begin;
				using std::end;
				j.m_type = value_t::array;
				j.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
				j.assert_invariant();
			}

			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, const std::vector<bool>& arr)
			{
				j.m_type = value_t::array;
				j.m_value = value_t::array;
				j.m_value.array->reserve(arr.size());
				for (const bool x : arr)
				{
					j.m_value.array->push_back(x);
				}
				j.assert_invariant();
			}

			template<typename BasicJsonType, typename T,
				enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
				static void construct(BasicJsonType& j, const std::valarray<T>& arr)
			{
				j.m_type = value_t::array;
				j.m_value = value_t::array;
				j.m_value.array->resize(arr.size());
				std::copy(std::begin(arr), std::end(arr), j.m_value.array->begin());
				j.assert_invariant();
			}
		};

		template<>
		struct external_constructor<value_t::object>
		{
			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
			{
				j.m_type = value_t::object;
				j.m_value = obj;
				j.assert_invariant();
			}

			template<typename BasicJsonType>
			static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
			{
				j.m_type = value_t::object;
				j.m_value = std::move(obj);
				j.assert_invariant();
			}

			template<typename BasicJsonType, typename CompatibleObjectType,
				enable_if_t<not std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int> = 0>
				static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
			{
				using std::begin;
				using std::end;

				j.m_type = value_t::object;
				j.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
				j.assert_invariant();
			}
		};

		/////////////
		// to_json //
		/////////////

		template<typename BasicJsonType, typename T,
			enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
			void to_json(BasicJsonType& j, T b) noexcept
		{
			external_constructor<value_t::boolean>::construct(j, b);
		}

		template<typename BasicJsonType, typename CompatibleString,
			enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
			void to_json(BasicJsonType& j, const CompatibleString& s)
		{
			external_constructor<value_t::string>::construct(j, s);
		}

		template<typename BasicJsonType>
		void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
		{
			external_constructor<value_t::string>::construct(j, std::move(s));
		}

		template<typename BasicJsonType, typename FloatType,
			enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
			void to_json(BasicJsonType& j, FloatType val) noexcept
		{
			external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
		}

		template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
			enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
			void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
		{
			external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
		}

		template<typename BasicJsonType, typename CompatibleNumberIntegerType,
			enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
			void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
		{
			external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
		}

		template<typename BasicJsonType, typename EnumType,
			enable_if_t<std::is_enum<EnumType>::value, int> = 0>
			void to_json(BasicJsonType& j, EnumType e) noexcept
		{
			using underlying_type = typename std::underlying_type<EnumType>::type;
			external_constructor<value_t::number_integer>::construct(j, static_cast<underlying_type>(e));
		}

		template<typename BasicJsonType>
		void to_json(BasicJsonType& j, const std::vector<bool>& e)
		{
			external_constructor<value_t::array>::construct(j, e);
		}

		template <typename BasicJsonType, typename CompatibleArrayType,
			enable_if_t<is_compatible_array_type<BasicJsonType,
			CompatibleArrayType>::value and
			not is_compatible_object_type<
			BasicJsonType, CompatibleArrayType>::value and
			not is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value and
			not is_basic_json<CompatibleArrayType>::value,
			int> = 0>
			void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
		{
			external_constructor<value_t::array>::construct(j, arr);
		}

		template<typename BasicJsonType, typename T,
			enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
			void to_json(BasicJsonType& j, const std::valarray<T>& arr)
		{
			external_constructor<value_t::array>::construct(j, std::move(arr));
		}

		template<typename BasicJsonType>
		void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
		{
			external_constructor<value_t::array>::construct(j, std::move(arr));
		}

		template<typename BasicJsonType, typename CompatibleObjectType,
			enable_if_t<is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value and not is_basic_json<CompatibleObjectType>::value, int> = 0>
			void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
		{
			external_constructor<value_t::object>::construct(j, obj);
		}

		template<typename BasicJsonType>
		void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
		{
			external_constructor<value_t::object>::construct(j, std::move(obj));
		}

		template <
			typename BasicJsonType, typename T, std::size_t N,
			enable_if_t<not std::is_constructible<typename BasicJsonType::string_t,
			const T(&)[N]>::value,
			int> = 0 >
			void to_json(BasicJsonType& j, const T(&arr)[N])
		{
			external_constructor<value_t::array>::construct(j, arr);
		}

		template<typename BasicJsonType, typename... Args>
		void to_json(BasicJsonType& j, const std::pair<Args...>& p)
		{
			j = { p.first, p.second };
		}

		// for https://github.com/nlohmann/json/pull/1134
		template<typename BasicJsonType, typename T,
			enable_if_t<std::is_same<T, typename iteration_proxy<typename BasicJsonType::iterator>::iteration_proxy_internal>::value, int> = 0>
			void to_json(BasicJsonType& j, T b) noexcept
		{
			j = { {b.key(), b.value()} };
		}

		template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
		void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...>)
		{
			j = { std::get<Idx>(t)... };
		}

		template<typename BasicJsonType, typename... Args>
		void to_json(BasicJsonType& j, const std::tuple<Args...>& t)
		{
			to_json_tuple_impl(j, t, index_sequence_for<Args...> {});
		}

		struct to_json_fn
		{
			template<typename BasicJsonType, typename T>
			auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
				-> decltype(to_json(j, std::forward<T>(val)), void())
			{
				return to_json(j, std::forward<T>(val));
			}
		};
	}

	/// namespace to hold default `to_json` function
	namespace
	{
		constexpr const auto& to_json = detail::static_const<detail::to_json_fn>::value;
	}
}

// #include <nlohmann/detail/input/input_adapters.hpp>


#include <cassert> // assert
#include <cstddef> // size_t
#include <cstring> // strlen
#include <istream> // istream
#include <iterator> // begin, end, iterator_traits, random_access_iterator_tag, distance, next
#include <memory> // shared_ptr, make_shared, addressof
#include <numeric> // accumulate
#include <string> // string, char_traits
#include <type_traits> // enable_if, is_base_of, is_pointer, is_integral, remove_pointer
#include <utility> // pair, declval

// #include <nlohmann/detail/macro_scope.hpp>


namespace nlohmann
{
	namespace detail
	{
		/// the supported input formats
		enum class input_format_t { json, cbor, msgpack, ubjson };

		////////////////////
		// input adapters //
		////////////////////

		/*!
		@brief abstract input adapter interface

		Produces a stream of std::char_traits<char>::int_type characters from a
		std::istream, a buffer, or some other input type. Accepts the return of
		exactly one non-EOF character for future input. The int_type characters
		returned consist of all valid char values as positive values (typically
		unsigned char), plus an EOF value outside that range, specified by the value
		of the function std::char_traits<char>::eof(). This value is typically -1, but
		could be any arbitrary value which is not a valid char value.
		*/
		struct input_adapter_protocol
		{
			/// get a character [0,255] or std::char_traits<char>::eof().
			virtual std::char_traits<char>::int_type get_character() = 0;
			virtual ~input_adapter_protocol() = default;
		};

		/// a type to simplify interfaces
		using input_adapter_t = std::shared_ptr<input_adapter_protocol>;

		/*!
		Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at
		beginning of input. Does not support changing the underlying std::streambuf
		in mid-input. Maintains underlying std::istream and std::streambuf to support
		subsequent use of standard std::istream operations to process any input
		characters following those used in parsing the JSON input.  Clears the
		std::istream flags; any input errors (e.g., EOF) will be detected by the first
		subsequent call for input from the std::istream.
		*/
		class input_stream_adapter : public input_adapter_protocol
		{
		public:
			~input_stream_adapter() override
			{
				// clear stream flags; we use underlying streambuf I/O, do not
				// maintain ifstream flags
				is.clear();
			}

			explicit input_stream_adapter(std::istream& i)
				: is(i), sb(*i.rdbuf())
			{}

			// delete because of pointer members
			input_stream_adapter(const input_stream_adapter&) = delete;
			input_stream_adapter& operator=(input_stream_adapter&) = delete;

			// std::istream/std::streambuf use std::char_traits<char>::to_int_type, to
			// ensure that std::char_traits<char>::eof() and the character 0xFF do not
			// end up as the same value, eg. 0xFFFFFFFF.
			std::char_traits<char>::int_type get_character() override
			{
				return sb.sbumpc();
			}

		private:
			/// the associated input stream
			std::istream& is;
			std::streambuf& sb;
		};

		/// input adapter for buffer input
		class input_buffer_adapter : public input_adapter_protocol
		{
		public:
			input_buffer_adapter(const char* b, const std::size_t l)
				: cursor(b), limit(b + l)
			{}

			// delete because of pointer members
			input_buffer_adapter(const input_buffer_adapter&) = delete;
			input_buffer_adapter& operator=(input_buffer_adapter&) = delete;

			std::char_traits<char>::int_type get_character() noexcept override
			{
				if (JSON_LIKELY(cursor < limit))
				{
					return std::char_traits<char>::to_int_type(*(cursor++));
				}

				return std::char_traits<char>::eof();
			}

		private:
			/// pointer to the current character
			const char* cursor;
			/// pointer past the last character
			const char* const limit;
		};

		template<typename WideStringType, size_t T>
		struct wide_string_input_helper
		{
			// UTF-32
			static void fill_buffer(const WideStringType& str, size_t& current_wchar, std::array<std::char_traits<char>::int_type, 4>& utf8_bytes, size_t& utf8_bytes_index, size_t& utf8_bytes_filled)
			{
				utf8_bytes_index = 0;

				if (current_wchar == str.size())
				{
					utf8_bytes[0] = std::char_traits<char>::eof();
					utf8_bytes_filled = 1;
				}
				else
				{
					// get the current character
					const int wc = static_cast<int>(str[current_wchar++]);

					// UTF-32 to UTF-8 encoding
					if (wc < 0x80)
					{
						utf8_bytes[0] = wc;
						utf8_bytes_filled = 1;
					}
					else if (wc <= 0x7FF)
					{
						utf8_bytes[0] = 0xC0 | ((wc >> 6) & 0x1F);
						utf8_bytes[1] = 0x80 | (wc & 0x3F);
						utf8_bytes_filled = 2;
					}
					else if (wc <= 0xFFFF)
					{
						utf8_bytes[0] = 0xE0 | ((wc >> 12) & 0x0F);
						utf8_bytes[1] = 0x80 | ((wc >> 6) & 0x3F);
						utf8_bytes[2] = 0x80 | (wc & 0x3F);
						utf8_bytes_filled = 3;
					}
					else if (wc <= 0x10FFFF)
					{
						utf8_bytes[0] = 0xF0 | ((wc >> 18) & 0x07);
						utf8_bytes[1] = 0x80 | ((wc >> 12) & 0x3F);
						utf8_bytes[2] = 0x80 | ((wc >> 6) & 0x3F);
						utf8_bytes[3] = 0x80 | (wc & 0x3F);
						utf8_bytes_filled = 4;
					}
					else
					{
						// unknown character
						utf8_bytes[0] = wc;
						utf8_bytes_filled = 1;
					}
				}
			}
		};

		template<typename WideStringType>
		struct wide_string_input_helper<WideStringType, 2>
		{
			// UTF-16
			static void fill_buffer(const WideStringType& str, size_t& current_wchar, std::array<std::char_traits<char>::int_type, 4>& utf8_bytes, size_t& utf8_bytes_index, size_t& utf8_bytes_filled)
			{
				utf8_bytes_index = 0;

				if (current_wchar == str.size())
				{
					utf8_bytes[0] = std::char_traits<char>::eof();
					utf8_bytes_filled = 1;
				}
				else
				{
					// get the current character
					const int wc = static_cast<int>(str[current_wchar++]);

					// UTF-16 to UTF-8 encoding
					if (wc < 0x80)
					{
						utf8_bytes[0] = wc;
						utf8_bytes_filled = 1;
					}
					else if (wc <= 0x7FF)
					{
						utf8_bytes[0] = 0xC0 | ((wc >> 6));
						utf8_bytes[1] = 0x80 | (wc & 0x3F);
						utf8_bytes_filled = 2;
					}
					else if (0xD800 > wc or wc >= 0xE000)
					{
						utf8_bytes[0] = 0xE0 | ((wc >> 12));
						utf8_bytes[1] = 0x80 | ((wc >> 6) & 0x3F);
						utf8_bytes[2] = 0x80 | (wc & 0x3F);
						utf8_bytes_filled = 3;
					}
					else
					{
						if (current_wchar < str.size())
						{
							const int wc2 = static_cast<int>(str[current_wchar++]);
							const int charcode = 0x10000 + (((wc & 0x3FF) << 10) | (wc2 & 0x3FF));
							utf8_bytes[0] = 0xf0 | (charcode >> 18);
							utf8_bytes[1] = 0x80 | ((charcode >> 12) & 0x3F);
							utf8_bytes[2] = 0x80 | ((charcode >> 6) & 0x3F);
							utf8_bytes[3] = 0x80 | (charcode & 0x3F);
							utf8_bytes_filled = 4;
						}
						else
						{
							// unknown character
							++current_wchar;
							utf8_bytes[0] = wc;
							utf8_bytes_filled = 1;
						}
					}
				}
			}
		};

		template<typename WideStringType>
		class wide_string_input_adapter : public input_adapter_protocol
		{
		public:
			explicit wide_string_input_adapter(const WideStringType& w) : str(w) {}

			std::char_traits<char>::int_type get_character() noexcept override
			{
				// check if buffer needs to be filled
				if (utf8_bytes_index == utf8_bytes_filled)
				{
					fill_buffer<sizeof(typename WideStringType::value_type)>();

					assert(utf8_bytes_filled > 0);
					assert(utf8_bytes_index == 0);
				}

				// use buffer
				assert(utf8_bytes_filled > 0);
				assert(utf8_bytes_index < utf8_bytes_filled);
				return utf8_bytes[utf8_bytes_index++];
			}

		private:
			template<size_t T>
			void fill_buffer()
			{
				wide_string_input_helper<WideStringType, T>::fill_buffer(str, current_wchar, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
			}

			/// the wstring to process
			const WideStringType& str;

			/// index of the current wchar in str
			std::size_t current_wchar = 0;

			/// a buffer for UTF-8 bytes
			std::array<std::char_traits<char>::int_type, 4> utf8_bytes = { {0, 0, 0, 0} };

			/// index to the utf8_codes array for the next valid byte
			std::size_t utf8_bytes_index = 0;
			/// number of valid bytes in the utf8_codes array
			std::size_t utf8_bytes_filled = 0;
		};

		class input_adapter
		{
		public:
			// native support

			/// input adapter for input stream
			input_adapter(std::istream& i)
				: ia(std::make_shared<input_stream_adapter>(i)) {}

			/// input adapter for input stream
			input_adapter(std::istream&& i)
				: ia(std::make_shared<input_stream_adapter>(i)) {}

			input_adapter(const std::wstring& ws)
				: ia(std::make_shared<wide_string_input_adapter<std::wstring>>(ws)) {}

			input_adapter(const std::u16string& ws)
				: ia(std::make_shared<wide_string_input_adapter<std::u16string>>(ws)) {}

			input_adapter(const std::u32string& ws)
				: ia(std::make_shared<wide_string_input_adapter<std::u32string>>(ws)) {}

			/// input adapter for buffer
			template<typename CharT,
				typename std::enable_if<
				std::is_pointer<CharT>::value and
				std::is_integral<typename std::remove_pointer<CharT>::type>::value and
				sizeof(typename std::remove_pointer<CharT>::type) == 1,
				int>::type = 0>
				input_adapter(CharT b, std::size_t l)
				: ia(std::make_shared<input_buffer_adapter>(reinterpret_cast<const char*>(b), l)) {}

			// derived support

			/// input adapter for string literal
			template<typename CharT,
				typename std::enable_if<
				std::is_pointer<CharT>::value and
				std::is_integral<typename std::remove_pointer<CharT>::type>::value and
				sizeof(typename std::remove_pointer<CharT>::type) == 1,
				int>::type = 0>
				input_adapter(CharT b)
				: input_adapter(reinterpret_cast<const char*>(b),
					std::strlen(reinterpret_cast<const char*>(b))) {}

			/// input adapter for iterator range with contiguous storage
			template<class IteratorType,
				typename std::enable_if<
				std::is_same<typename std::iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
				int>::type = 0>
				input_adapter(IteratorType first, IteratorType last)
			{
#ifndef NDEBUG
				// assertion to check that the iterator range is indeed contiguous,
				// see http://stackoverflow.com/a/35008842/266378 for more discussion
				const auto is_contiguous = std::accumulate(
					first, last, std::pair<bool, int>(true, 0),
					[&first](std::pair<bool, int> res, decltype(*first) val)
				{
					res.first &= (val == *(std::next(std::addressof(*first), res.second++)));
					return res;
				}).first;
				assert(is_contiguous);
#endif

				// assertion to check that each element is 1 byte long
				static_assert(
					sizeof(typename std::iterator_traits<IteratorType>::value_type) == 1,
					"each element in the iterator range must have the size of 1 byte");

				const auto len = static_cast<size_t>(std::distance(first, last));
				if (JSON_LIKELY(len > 0))
				{
					// there is at least one element: use the address of first
					ia = std::make_shared<input_buffer_adapter>(reinterpret_cast<const char*>(&(*first)), len);
				}
				else
				{
					// the address of first cannot be used: use nullptr
					ia = std::make_shared<input_buffer_adapter>(nullptr, len);
				}
			}

			/// input adapter for array
			template<class T, std::size_t N>
			input_adapter(T(&array)[N])
				: input_adapter(std::begin(array), std::end(array)) {}

			/// input adapter for contiguous container
			template<class ContiguousContainer, typename
				std::enable_if<not std::is_pointer<ContiguousContainer>::value and
				std::is_base_of<std::random_access_iterator_tag, typename std::iterator_traits<decltype(std::begin(std::declval<ContiguousContainer const>()))>::iterator_category>::value,
				int>::type = 0>
				input_adapter(const ContiguousContainer& c)
				: input_adapter(std::begin(c), std::end(c)) {}

			operator input_adapter_t()
			{
				return ia;
			}

		private:
			/// the actual adapter
			input_adapter_t ia = nullptr;
		};
	}
}

// #include <nlohmann/detail/input/lexer.hpp>


#include <clocale> // localeconv
#include <cstddef> // size_t
#include <cstdlib> // strtof, strtod, strtold, strtoll, strtoull
#include <cstdio> // snprintf
#include <initializer_list> // initializer_list
#include <string> // char_traits, string
#include <vector> // vector

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>


namespace nlohmann
{
	namespace detail
	{
		///////////
		// lexer //
		///////////

		/*!
		@brief lexical analysis

		This class organizes the lexical analysis during JSON deserialization.
		*/
		template<typename BasicJsonType>
		class lexer
		{
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;

		public:
			/// token types for the parser
			enum class token_type
			{
				uninitialized,    ///< indicating the scanner is uninitialized
				literal_true,     ///< the `true` literal
				literal_false,    ///< the `false` literal
				literal_null,     ///< the `null` literal
				value_string,     ///< a string -- use get_string() for actual value
				value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value
				value_integer,    ///< a signed integer -- use get_number_integer() for actual value
				value_float,      ///< an floating point number -- use get_number_float() for actual value
				begin_array,      ///< the character for array begin `[`
				begin_object,     ///< the character for object begin `{`
				end_array,        ///< the character for array end `]`
				end_object,       ///< the character for object end `}`
				name_separator,   ///< the name separator `:`
				value_separator,  ///< the value separator `,`
				parse_error,      ///< indicating a parse error
				end_of_input,     ///< indicating the end of the input buffer
				literal_or_value  ///< a literal or the begin of a value (only for diagnostics)
			};

			/// return name of values of type token_type (only used for errors)
			static const char* token_type_name(const token_type t) noexcept
			{
				switch (t)
				{
				case token_type::uninitialized:
					return "<uninitialized>";
				case token_type::literal_true:
					return "true literal";
				case token_type::literal_false:
					return "false literal";
				case token_type::literal_null:
					return "null literal";
				case token_type::value_string:
					return "string literal";
				case lexer::token_type::value_unsigned:
				case lexer::token_type::value_integer:
				case lexer::token_type::value_float:
					return "number literal";
				case token_type::begin_array:
					return "'['";
				case token_type::begin_object:
					return "'{'";
				case token_type::end_array:
					return "']'";
				case token_type::end_object:
					return "'}'";
				case token_type::name_separator:
					return "':'";
				case token_type::value_separator:
					return "','";
				case token_type::parse_error:
					return "<parse error>";
				case token_type::end_of_input:
					return "end of input";
				case token_type::literal_or_value:
					return "'[', '{', or a literal";
					// LCOV_EXCL_START
				default: // catch non-enum values
					return "unknown token";
					// LCOV_EXCL_STOP
				}
			}

			explicit lexer(detail::input_adapter_t&& adapter)
				: ia(std::move(adapter)), decimal_point_char(get_decimal_point()) {}

			// delete because of pointer members
			lexer(const lexer&) = delete;
			lexer& operator=(lexer&) = delete;

		private:
			/////////////////////
			// locales
			/////////////////////

			/// return the locale-dependent decimal point
			static char get_decimal_point() noexcept
			{
				const auto loc = localeconv();
				assert(loc != nullptr);
				return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
			}

			/////////////////////
			// scan functions
			/////////////////////

			/*!
			@brief get codepoint from 4 hex characters following `\u`

			For input "\u c1 c2 c3 c4" the codepoint is:
			  (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4
			= (c1 << 12) + (c2 << 8) + (c3 << 4) + (c4 << 0)

			Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'
			must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The
			conversion is done by subtracting the offset (0x30, 0x37, and 0x57)
			between the ASCII value of the character and the desired integer value.

			@return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
					non-hex character)
			*/
			int get_codepoint()
			{
				// this function only makes sense after reading `\u`
				assert(current == 'u');
				int codepoint = 0;

				const auto factors = { 12, 8, 4, 0 };
				for (const auto factor : factors)
				{
					get();

					if (current >= '0' and current <= '9')
					{
						codepoint += ((current - 0x30) << factor);
					}
					else if (current >= 'A' and current <= 'F')
					{
						codepoint += ((current - 0x37) << factor);
					}
					else if (current >= 'a' and current <= 'f')
					{
						codepoint += ((current - 0x57) << factor);
					}
					else
					{
						return -1;
					}
				}

				assert(0x0000 <= codepoint and codepoint <= 0xFFFF);
				return codepoint;
			}

			/*!
			@brief check if the next byte(s) are inside a given range

			Adds the current byte and, for each passed range, reads a new byte and
			checks if it is inside the range. If a violation was detected, set up an
			error message and return false. Otherwise, return true.

			@param[in] ranges  list of integers; interpreted as list of pairs of
							   inclusive lower and upper bound, respectively

			@pre The passed list @a ranges must have 2, 4, or 6 elements; that is,
				 1, 2, or 3 pairs. This precondition is enforced by an assertion.

			@return true if and only if no range violation was detected
			*/
			bool next_byte_in_range(std::initializer_list<int> ranges)
			{
				assert(ranges.size() == 2 or ranges.size() == 4 or ranges.size() == 6);
				add(current);

				for (auto range = ranges.begin(); range != ranges.end(); ++range)
				{
					get();
					if (JSON_LIKELY(*range <= current and current <= *(++range)))
					{
						add(current);
					}
					else
					{
						error_message = "invalid string: ill-formed UTF-8 byte";
						return false;
					}
				}

				return true;
			}

			/*!
			@brief scan a string literal

			This function scans a string according to Sect. 7 of RFC 7159. While
			scanning, bytes are escaped and copied into buffer token_buffer. Then the
			function returns successfully, token_buffer is *not* null-terminated (as it
			may contain \0 bytes), and token_buffer.size() is the number of bytes in the
			string.

			@return token_type::value_string if string could be successfully scanned,
					token_type::parse_error otherwise

			@note In case of errors, variable error_message contains a textual
				  description.
			*/
			token_type scan_string()
			{
				// reset token_buffer (ignore opening quote)
				reset();

				// we entered the function by reading an open quote
				assert(current == '\"');

				while (true)
				{
					// get next character
					switch (get())
					{
						// end of file while parsing string
					case std::char_traits<char>::eof():
					{
						error_message = "invalid string: missing closing quote";
						return token_type::parse_error;
					}

					// closing quote
					case '\"':
					{
						return token_type::value_string;
					}

					// escapes
					case '\\':
					{
						switch (get())
						{
							// quotation mark
						case '\"':
							add('\"');
							break;
							// reverse solidus
						case '\\':
							add('\\');
							break;
							// solidus
						case '/':
							add('/');
							break;
							// backspace
						case 'b':
							add('\b');
							break;
							// form feed
						case 'f':
							add('\f');
							break;
							// line feed
						case 'n':
							add('\n');
							break;
							// carriage return
						case 'r':
							add('\r');
							break;
							// tab
						case 't':
							add('\t');
							break;

							// unicode escapes
						case 'u':
						{
							const int codepoint1 = get_codepoint();
							int codepoint = codepoint1; // start with codepoint1

							if (JSON_UNLIKELY(codepoint1 == -1))
							{
								error_message = "invalid string: '\\u' must be followed by 4 hex digits";
								return token_type::parse_error;
							}

							// check if code point is a high surrogate
							if (0xD800 <= codepoint1 and codepoint1 <= 0xDBFF)
							{
								// expect next \uxxxx entry
								if (JSON_LIKELY(get() == '\\' and get() == 'u'))
								{
									const int codepoint2 = get_codepoint();

									if (JSON_UNLIKELY(codepoint2 == -1))
									{
										error_message = "invalid string: '\\u' must be followed by 4 hex digits";
										return token_type::parse_error;
									}

									// check if codepoint2 is a low surrogate
									if (JSON_LIKELY(0xDC00 <= codepoint2 and codepoint2 <= 0xDFFF))
									{
										// overwrite codepoint
										codepoint =
											// high surrogate occupies the most significant 22 bits
											(codepoint1 << 10)
											// low surrogate occupies the least significant 15 bits
											+ codepoint2
											// there is still the 0xD800, 0xDC00 and 0x10000 noise
											// in the result so we have to subtract with:
											// (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
											-0x35FDC00;
									}
									else
									{
										error_message = "invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF";
										return token_type::parse_error;
									}
								}
								else
								{
									error_message = "invalid string: surrogate U+DC00..U+DFFF must be followed by U+DC00..U+DFFF";
									return token_type::parse_error;
								}
							}
							else
							{
								if (JSON_UNLIKELY(0xDC00 <= codepoint1 and codepoint1 <= 0xDFFF))
								{
									error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
									return token_type::parse_error;
								}
							}

							// result of the above calculation yields a proper codepoint
							assert(0x00 <= codepoint and codepoint <= 0x10FFFF);

							// translate codepoint into bytes
							if (codepoint < 0x80)
							{
								// 1-byte characters: 0xxxxxxx (ASCII)
								add(codepoint);
							}
							else if (codepoint <= 0x7FF)
							{
								// 2-byte characters: 110xxxxx 10xxxxxx
								add(0xC0 | (codepoint >> 6));
								add(0x80 | (codepoint & 0x3F));
							}
							else if (codepoint <= 0xFFFF)
							{
								// 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
								add(0xE0 | (codepoint >> 12));
								add(0x80 | ((codepoint >> 6) & 0x3F));
								add(0x80 | (codepoint & 0x3F));
							}
							else
							{
								// 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
								add(0xF0 | (codepoint >> 18));
								add(0x80 | ((codepoint >> 12) & 0x3F));
								add(0x80 | ((codepoint >> 6) & 0x3F));
								add(0x80 | (codepoint & 0x3F));
							}

							break;
						}

						// other characters after escape
						default:
							error_message = "invalid string: forbidden character after backslash";
							return token_type::parse_error;
						}

						break;
					}

					// invalid control characters
					case 0x00:
					case 0x01:
					case 0x02:
					case 0x03:
					case 0x04:
					case 0x05:
					case 0x06:
					case 0x07:
					case 0x08:
					case 0x09:
					case 0x0A:
					case 0x0B:
					case 0x0C:
					case 0x0D:
					case 0x0E:
					case 0x0F:
					case 0x10:
					case 0x11:
					case 0x12:
					case 0x13:
					case 0x14:
					case 0x15:
					case 0x16:
					case 0x17:
					case 0x18:
					case 0x19:
					case 0x1A:
					case 0x1B:
					case 0x1C:
					case 0x1D:
					case 0x1E:
					case 0x1F:
					{
						error_message = "invalid string: control character must be escaped";
						return token_type::parse_error;
					}

					// U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))
					case 0x20:
					case 0x21:
					case 0x23:
					case 0x24:
					case 0x25:
					case 0x26:
					case 0x27:
					case 0x28:
					case 0x29:
					case 0x2A:
					case 0x2B:
					case 0x2C:
					case 0x2D:
					case 0x2E:
					case 0x2F:
					case 0x30:
					case 0x31:
					case 0x32:
					case 0x33:
					case 0x34:
					case 0x35:
					case 0x36:
					case 0x37:
					case 0x38:
					case 0x39:
					case 0x3A:
					case 0x3B:
					case 0x3C:
					case 0x3D:
					case 0x3E:
					case 0x3F:
					case 0x40:
					case 0x41:
					case 0x42:
					case 0x43:
					case 0x44:
					case 0x45:
					case 0x46:
					case 0x47:
					case 0x48:
					case 0x49:
					case 0x4A:
					case 0x4B:
					case 0x4C:
					case 0x4D:
					case 0x4E:
					case 0x4F:
					case 0x50:
					case 0x51:
					case 0x52:
					case 0x53:
					case 0x54:
					case 0x55:
					case 0x56:
					case 0x57:
					case 0x58:
					case 0x59:
					case 0x5A:
					case 0x5B:
					case 0x5D:
					case 0x5E:
					case 0x5F:
					case 0x60:
					case 0x61:
					case 0x62:
					case 0x63:
					case 0x64:
					case 0x65:
					case 0x66:
					case 0x67:
					case 0x68:
					case 0x69:
					case 0x6A:
					case 0x6B:
					case 0x6C:
					case 0x6D:
					case 0x6E:
					case 0x6F:
					case 0x70:
					case 0x71:
					case 0x72:
					case 0x73:
					case 0x74:
					case 0x75:
					case 0x76:
					case 0x77:
					case 0x78:
					case 0x79:
					case 0x7A:
					case 0x7B:
					case 0x7C:
					case 0x7D:
					case 0x7E:
					case 0x7F:
					{
						add(current);
						break;
					}

					// U+0080..U+07FF: bytes C2..DF 80..BF
					case 0xC2:
					case 0xC3:
					case 0xC4:
					case 0xC5:
					case 0xC6:
					case 0xC7:
					case 0xC8:
					case 0xC9:
					case 0xCA:
					case 0xCB:
					case 0xCC:
					case 0xCD:
					case 0xCE:
					case 0xCF:
					case 0xD0:
					case 0xD1:
					case 0xD2:
					case 0xD3:
					case 0xD4:
					case 0xD5:
					case 0xD6:
					case 0xD7:
					case 0xD8:
					case 0xD9:
					case 0xDA:
					case 0xDB:
					case 0xDC:
					case 0xDD:
					case 0xDE:
					case 0xDF:
					{
						if (JSON_UNLIKELY(not next_byte_in_range({ 0x80, 0xBF })))
						{
							return token_type::parse_error;
						}
						break;
					}

					// U+0800..U+0FFF: bytes E0 A0..BF 80..BF
					case 0xE0:
					{
						if (JSON_UNLIKELY(not (next_byte_in_range({ 0xA0, 0xBF, 0x80, 0xBF }))))
						{
							return token_type::parse_error;
						}
						break;
					}

					// U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF
					// U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF
					case 0xE1:
					case 0xE2:
					case 0xE3:
					case 0xE4:
					case 0xE5:
					case 0xE6:
					case 0xE7:
					case 0xE8:
					case 0xE9:
					case 0xEA:
					case 0xEB:
					case 0xEC:
					case 0xEE:
					case 0xEF:
					{
						if (JSON_UNLIKELY(not (next_byte_in_range({ 0x80, 0xBF, 0x80, 0xBF }))))
						{
							return token_type::parse_error;
						}
						break;
					}

					// U+D000..U+D7FF: bytes ED 80..9F 80..BF
					case 0xED:
					{
						if (JSON_UNLIKELY(not (next_byte_in_range({ 0x80, 0x9F, 0x80, 0xBF }))))
						{
							return token_type::parse_error;
						}
						break;
					}

					// U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
					case 0xF0:
					{
						if (JSON_UNLIKELY(not (next_byte_in_range({ 0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF }))))
						{
							return token_type::parse_error;
						}
						break;
					}

					// U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
					case 0xF1:
					case 0xF2:
					case 0xF3:
					{
						if (JSON_UNLIKELY(not (next_byte_in_range({ 0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF }))))
						{
							return token_type::parse_error;
						}
						break;
					}

					// U+100000..U+10FFFF F4 80..8F 80..BF 80..BF
					case 0xF4:
					{
						if (JSON_UNLIKELY(not (next_byte_in_range({ 0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF }))))
						{
							return token_type::parse_error;
						}
						break;
					}

					// remaining bytes (80..C1 and F5..FF) are ill-formed
					default:
					{
						error_message = "invalid string: ill-formed UTF-8 byte";
						return token_type::parse_error;
					}
					}
				}
			}

			static void strtof(float& f, const char* str, char** endptr) noexcept
			{
				f = std::strtof(str, endptr);
			}

			static void strtof(double& f, const char* str, char** endptr) noexcept
			{
				f = std::strtod(str, endptr);
			}

			static void strtof(long double& f, const char* str, char** endptr) noexcept
			{
				f = std::strtold(str, endptr);
			}

			/*!
			@brief scan a number literal

			This function scans a string according to Sect. 6 of RFC 7159.

			The function is realized with a deterministic finite state machine derived
			from the grammar described in RFC 7159. Starting in state "init", the
			input is read and used to determined the next state. Only state "done"
			accepts the number. State "error" is a trap state to model errors. In the
			table below, "anything" means any character but the ones listed before.

			state    | 0        | 1-9      | e E      | +       | -       | .        | anything
			---------|----------|----------|----------|---------|---------|----------|-----------
			init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]
			minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]
			zero     | done     | done     | exponent | done    | done    | decimal1 | done
			any1     | any1     | any1     | exponent | done    | done    | decimal1 | done
			decimal1 | decimal2 | [error]  | [error]  | [error] | [error] | [error]  | [error]
			decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done
			exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]
			sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]
			any2     | any2     | any2     | done     | done    | done    | done     | done

			The state machine is realized with one label per state (prefixed with
			"scan_number_") and `goto` statements between them. The state machine
			contains cycles, but any cycle can be left when EOF is read. Therefore,
			the function is guaranteed to terminate.

			During scanning, the read bytes are stored in token_buffer. This string is
			then converted to a signed integer, an unsigned integer, or a
			floating-point number.

			@return token_type::value_unsigned, token_type::value_integer, or
					token_type::value_float if number could be successfully scanned,
					token_type::parse_error otherwise

			@note The scanner is independent of the current locale. Internally, the
				  locale's decimal point is used instead of `.` to work with the
				  locale-dependent converters.
			*/
			token_type scan_number()
			{
				// reset token_buffer to store the number's bytes
				reset();

				// the type of the parsed number; initially set to unsigned; will be
				// changed if minus sign, decimal point or exponent is read
				token_type number_type = token_type::value_unsigned;

				// state (init): we just found out we need to scan a number
				switch (current)
				{
				case '-':
				{
					add(current);
					goto scan_number_minus;
				}

				case '0':
				{
					add(current);
					goto scan_number_zero;
				}

				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_any1;
				}

				// LCOV_EXCL_START
				default:
				{
					// all other characters are rejected outside scan_number()
					assert(false);
				}
				// LCOV_EXCL_STOP
				}

			scan_number_minus:
				// state: we just parsed a leading minus sign
				number_type = token_type::value_integer;
				switch (get())
				{
				case '0':
				{
					add(current);
					goto scan_number_zero;
				}

				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_any1;
				}

				default:
				{
					error_message = "invalid number; expected digit after '-'";
					return token_type::parse_error;
				}
				}

			scan_number_zero:
				// state: we just parse a zero (maybe with a leading minus sign)
				switch (get())
				{
				case '.':
				{
					add(decimal_point_char);
					goto scan_number_decimal1;
				}

				case 'e':
				case 'E':
				{
					add(current);
					goto scan_number_exponent;
				}

				default:
					goto scan_number_done;
				}

			scan_number_any1:
				// state: we just parsed a number 0-9 (maybe with a leading minus sign)
				switch (get())
				{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_any1;
				}

				case '.':
				{
					add(decimal_point_char);
					goto scan_number_decimal1;
				}

				case 'e':
				case 'E':
				{
					add(current);
					goto scan_number_exponent;
				}

				default:
					goto scan_number_done;
				}

			scan_number_decimal1:
				// state: we just parsed a decimal point
				number_type = token_type::value_float;
				switch (get())
				{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_decimal2;
				}

				default:
				{
					error_message = "invalid number; expected digit after '.'";
					return token_type::parse_error;
				}
				}

			scan_number_decimal2:
				// we just parsed at least one number after a decimal point
				switch (get())
				{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_decimal2;
				}

				case 'e':
				case 'E':
				{
					add(current);
					goto scan_number_exponent;
				}

				default:
					goto scan_number_done;
				}

			scan_number_exponent:
				// we just parsed an exponent
				number_type = token_type::value_float;
				switch (get())
				{
				case '+':
				case '-':
				{
					add(current);
					goto scan_number_sign;
				}

				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_any2;
				}

				default:
				{
					error_message =
						"invalid number; expected '+', '-', or digit after exponent";
					return token_type::parse_error;
				}
				}

			scan_number_sign:
				// we just parsed an exponent sign
				switch (get())
				{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_any2;
				}

				default:
				{
					error_message = "invalid number; expected digit after exponent sign";
					return token_type::parse_error;
				}
				}

			scan_number_any2:
				// we just parsed a number after the exponent or exponent sign
				switch (get())
				{
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				{
					add(current);
					goto scan_number_any2;
				}

				default:
					goto scan_number_done;
				}

			scan_number_done:
				// unget the character after the number (we only read it to know that
				// we are done scanning a number)
				unget();

				char* endptr = nullptr;
				errno = 0;

				// try to parse integers first and fall back to floats
				if (number_type == token_type::value_unsigned)
				{
					const auto x = std::strtoull(token_buffer.data(), &endptr, 10);

					// we checked the number format before
					assert(endptr == token_buffer.data() + token_buffer.size());

					if (errno == 0)
					{
						value_unsigned = static_cast<number_unsigned_t>(x);
						if (value_unsigned == x)
						{
							return token_type::value_unsigned;
						}
					}
				}
				else if (number_type == token_type::value_integer)
				{
					const auto x = std::strtoll(token_buffer.data(), &endptr, 10);

					// we checked the number format before
					assert(endptr == token_buffer.data() + token_buffer.size());

					if (errno == 0)
					{
						value_integer = static_cast<number_integer_t>(x);
						if (value_integer == x)
						{
							return token_type::value_integer;
						}
					}
				}

				// this code is reached if we parse a floating-point number or if an
				// integer conversion above failed
				strtof(value_float, token_buffer.data(), &endptr);

				// we checked the number format before
				assert(endptr == token_buffer.data() + token_buffer.size());

				return token_type::value_float;
			}

			/*!
			@param[in] literal_text  the literal text to expect
			@param[in] length        the length of the passed literal text
			@param[in] return_type   the token type to return on success
			*/
			token_type scan_literal(const char* literal_text, const std::size_t length,
				token_type return_type)
			{
				assert(current == literal_text[0]);
				for (std::size_t i = 1; i < length; ++i)
				{
					if (JSON_UNLIKELY(get() != literal_text[i]))
					{
						error_message = "invalid literal";
						return token_type::parse_error;
					}
				}
				return return_type;
			}

			/////////////////////
			// input management
			/////////////////////

			/// reset token_buffer; current character is beginning of token
			void reset() noexcept
			{
				token_buffer.clear();
				token_string.clear();
				token_string.push_back(std::char_traits<char>::to_char_type(current));
			}

			/*
			@brief get next character from the input

			This function provides the interface to the used input adapter. It does
			not throw in case the input reached EOF, but returns a
			`std::char_traits<char>::eof()` in that case.  Stores the scanned characters
			for use in error messages.

			@return character read from the input
			*/
			std::char_traits<char>::int_type get()
			{
				++chars_read;
				if (next_unget)
				{
					// just reset the next_unget variable and work with current
					next_unget = false;
				}
				else
				{
					current = ia->get_character();
				}

				if (JSON_LIKELY(current != std::char_traits<char>::eof()))
				{
					token_string.push_back(std::char_traits<char>::to_char_type(current));
				}
				return current;
			}

			/*!
			@brief unget current character (read it again on next get)

			We implement unget by setting variable next_unget to true. The input is not
			changed - we just simulate ungetting by modifying chars_read and
			token_string. The next call to get() will behave as if the unget character
			is read again.
			*/
			void unget()
			{
				next_unget = true;
				--chars_read;
				if (JSON_LIKELY(current != std::char_traits<char>::eof()))
				{
					assert(token_string.size() != 0);
					token_string.pop_back();
				}
			}

			/// add a character to token_buffer
			void add(int c)
			{
				token_buffer.push_back(std::char_traits<char>::to_char_type(c));
			}

		public:
			/////////////////////
			// value getters
			/////////////////////

			/// return integer value
			constexpr number_integer_t get_number_integer() const noexcept
			{
				return value_integer;
			}

			/// return unsigned integer value
			constexpr number_unsigned_t get_number_unsigned() const noexcept
			{
				return value_unsigned;
			}

			/// return floating-point value
			constexpr number_float_t get_number_float() const noexcept
			{
				return value_float;
			}

			/// return current string value (implicitly resets the token; useful only once)
			string_t& get_string()
			{
				return token_buffer;
			}

			/////////////////////
			// diagnostics
			/////////////////////

			/// return position of last read token
			constexpr std::size_t get_position() const noexcept
			{
				return chars_read;
			}

			/// return the last read token (for errors only).  Will never contain EOF
			/// (an arbitrary value that is not a valid char value, often -1), because
			/// 255 may legitimately occur.  May contain NUL, which should be escaped.
			std::string get_token_string() const
			{
				// escape control characters
				std::string result;
				for (const auto c : token_string)
				{
					if ('\x00' <= c and c <= '\x1F')
					{
						// escape control characters
						char cs[9];
						snprintf(cs, 9, "<U+%.4X>", static_cast<unsigned char>(c));
						result += cs;
					}
					else
					{
						// add character as is
						result.push_back(c);
					}
				}

				return result;
			}

			/// return syntax error message
			constexpr const char* get_error_message() const noexcept
			{
				return error_message;
			}

			/////////////////////
			// actual scanner
			/////////////////////

			/*!
			@brief skip the UTF-8 byte order mark
			@return true iff there is no BOM or the correct BOM has been skipped
			*/
			bool skip_bom()
			{
				if (get() == 0xEF)
				{
					if (get() == 0xBB and get() == 0xBF)
					{
						// we completely parsed the BOM
						return true;
					}
					else
					{
						// after reading 0xEF, an unexpected character followed
						return false;
					}
				}
				else
				{
					// the first character is not the beginning of the BOM; unget it to
					// process is later
					unget();
					return true;
				}
			}

			token_type scan()
			{
				// initially, skip the BOM
				if (chars_read == 0 and not skip_bom())
				{
					error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
					return token_type::parse_error;
				}

				// read next character and ignore whitespace
				do
				{
					get();
				} while (current == ' ' or current == '\t' or current == '\n' or current == '\r');

				switch (current)
				{
					// structural characters
				case '[':
					return token_type::begin_array;
				case ']':
					return token_type::end_array;
				case '{':
					return token_type::begin_object;
				case '}':
					return token_type::end_object;
				case ':':
					return token_type::name_separator;
				case ',':
					return token_type::value_separator;

					// literals
				case 't':
					return scan_literal("true", 4, token_type::literal_true);
				case 'f':
					return scan_literal("false", 5, token_type::literal_false);
				case 'n':
					return scan_literal("null", 4, token_type::literal_null);

					// string
				case '\"':
					return scan_string();

					// number
				case '-':
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					return scan_number();

					// end of input (the null byte is needed when parsing from
					// string literals)
				case '\0':
				case std::char_traits<char>::eof():
					return token_type::end_of_input;

					// error
				default:
					error_message = "invalid literal";
					return token_type::parse_error;
				}
			}

		private:
			/// input adapter
			detail::input_adapter_t ia = nullptr;

			/// the current character
			std::char_traits<char>::int_type current = std::char_traits<char>::eof();

			/// whether the next get() call should just return current
			bool next_unget = false;

			/// the number of characters read
			std::size_t chars_read = 0;

			/// raw input token string (for error messages)
			std::vector<char> token_string{};

			/// buffer for variable-length tokens (numbers, strings)
			string_t token_buffer{};

			/// a description of occurred lexer errors
			const char* error_message = "";

			// number values
			number_integer_t value_integer = 0;
			number_unsigned_t value_unsigned = 0;
			number_float_t value_float = 0;

			/// the decimal point
			const char decimal_point_char = '.';
		};
	}
}

// #include <nlohmann/detail/input/parser.hpp>


#include <cassert> // assert
#include <cmath> // isfinite
#include <cstdint> // uint8_t
#include <functional> // function
#include <string> // string
#include <utility> // move

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>


#include <cstdint> // size_t
#include <utility> // declval

// #include <nlohmann/detail/meta/detected.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


namespace nlohmann
{
	namespace detail
	{
		template <typename T>
		using null_function_t = decltype(std::declval<T&>().null());

		template <typename T>
		using boolean_function_t =
			decltype(std::declval<T&>().boolean(std::declval<bool>()));

		template <typename T, typename Integer>
		using number_integer_function_t =
			decltype(std::declval<T&>().number_integer(std::declval<Integer>()));

		template <typename T, typename Unsigned>
		using number_unsigned_function_t =
			decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));

		template <typename T, typename Float, typename String>
		using number_float_function_t = decltype(std::declval<T&>().number_float(
			std::declval<Float>(), std::declval<const String&>()));

		template <typename T, typename String>
		using string_function_t =
			decltype(std::declval<T&>().string(std::declval<String&>()));

		template <typename T>
		using start_object_function_t =
			decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));

		template <typename T, typename String>
		using key_function_t =
			decltype(std::declval<T&>().key(std::declval<String&>()));

		template <typename T>
		using end_object_function_t = decltype(std::declval<T&>().end_object());

		template <typename T>
		using start_array_function_t =
			decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));

		template <typename T>
		using end_array_function_t = decltype(std::declval<T&>().end_array());

		template <typename T, typename Exception>
		using parse_error_function_t = decltype(std::declval<T&>().parse_error(
			std::declval<std::size_t>(), std::declval<const std::string&>(),
			std::declval<const Exception&>()));

		template <typename SAX, typename BasicJsonType>
		struct is_sax
		{
		private:
			static_assert(is_basic_json<BasicJsonType>::value,
				"BasicJsonType must be of type basic_json<...>");

			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;
			using exception_t = typename BasicJsonType::exception;

		public:
			static constexpr bool value =
				is_detected_exact<bool, null_function_t, SAX>::value &&
				is_detected_exact<bool, boolean_function_t, SAX>::value &&
				is_detected_exact<bool, number_integer_function_t, SAX,
				number_integer_t>::value &&
				is_detected_exact<bool, number_unsigned_function_t, SAX,
				number_unsigned_t>::value &&
				is_detected_exact<bool, number_float_function_t, SAX, number_float_t,
				string_t>::value &&
				is_detected_exact<bool, string_function_t, SAX, string_t>::value &&
				is_detected_exact<bool, start_object_function_t, SAX>::value &&
				is_detected_exact<bool, key_function_t, SAX, string_t>::value &&
				is_detected_exact<bool, end_object_function_t, SAX>::value &&
				is_detected_exact<bool, start_array_function_t, SAX>::value &&
				is_detected_exact<bool, end_array_function_t, SAX>::value &&
				is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;
		};

		template <typename SAX, typename BasicJsonType>
		struct is_sax_static_asserts
		{
		private:
			static_assert(is_basic_json<BasicJsonType>::value,
				"BasicJsonType must be of type basic_json<...>");

			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;
			using exception_t = typename BasicJsonType::exception;

		public:
			static_assert(is_detected_exact<bool, null_function_t, SAX>::value,
				"Missing/invalid function: bool null()");
			static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
				"Missing/invalid function: bool boolean(bool)");
			static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
				"Missing/invalid function: bool boolean(bool)");
			static_assert(
				is_detected_exact<bool, number_integer_function_t, SAX,
				number_integer_t>::value,
				"Missing/invalid function: bool number_integer(number_integer_t)");
			static_assert(
				is_detected_exact<bool, number_unsigned_function_t, SAX,
				number_unsigned_t>::value,
				"Missing/invalid function: bool number_unsigned(number_unsigned_t)");
			static_assert(is_detected_exact<bool, number_float_function_t, SAX,
				number_float_t, string_t>::value,
				"Missing/invalid function: bool number_float(number_float_t, const string_t&)");
			static_assert(
				is_detected_exact<bool, string_function_t, SAX, string_t>::value,
				"Missing/invalid function: bool string(string_t&)");
			static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,
				"Missing/invalid function: bool start_object(std::size_t)");
			static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,
				"Missing/invalid function: bool key(string_t&)");
			static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,
				"Missing/invalid function: bool end_object()");
			static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,
				"Missing/invalid function: bool start_array(std::size_t)");
			static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,
				"Missing/invalid function: bool end_array()");
			static_assert(
				is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,
				"Missing/invalid function: bool parse_error(std::size_t, const "
				"std::string&, const exception&)");
		};
	}
}

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/json_sax.hpp>


#include <cstddef>
#include <string>
#include <vector>

// #include <nlohmann/detail/input/parser.hpp>

// #include <nlohmann/detail/exceptions.hpp>


namespace nlohmann
{

	/*!
	@brief SAX interface

	This class describes the SAX interface used by @ref nlohmann::json::sax_parse.
	Each function is called in different situations while the input is parsed. The
	boolean return value informs the parser whether to continue processing the
	input.
	*/
	template<typename BasicJsonType>
	struct json_sax
	{
		/// type for (signed) integers
		using number_integer_t = typename BasicJsonType::number_integer_t;
		/// type for unsigned integers
		using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
		/// type for floating-point numbers
		using number_float_t = typename BasicJsonType::number_float_t;
		/// type for strings
		using string_t = typename BasicJsonType::string_t;

		/*!
		@brief a null value was read
		@return whether parsing should proceed
		*/
		virtual bool null() = 0;

		/*!
		@brief a boolean value was read
		@param[in] val  boolean value
		@return whether parsing should proceed
		*/
		virtual bool boolean(bool val) = 0;

		/*!
		@brief an integer number was read
		@param[in] val  integer value
		@return whether parsing should proceed
		*/
		virtual bool number_integer(number_integer_t val) = 0;

		/*!
		@brief an unsigned integer number was read
		@param[in] val  unsigned integer value
		@return whether parsing should proceed
		*/
		virtual bool number_unsigned(number_unsigned_t val) = 0;

		/*!
		@brief an floating-point number was read
		@param[in] val  floating-point value
		@param[in] s    raw token value
		@return whether parsing should proceed
		*/
		virtual bool number_float(number_float_t val, const string_t& s) = 0;

		/*!
		@brief a string was read
		@param[in] val  string value
		@return whether parsing should proceed
		@note It is safe to move the passed string.
		*/
		virtual bool string(string_t& val) = 0;

		/*!
		@brief the beginning of an object was read
		@param[in] elements  number of object elements or -1 if unknown
		@return whether parsing should proceed
		@note binary formats may report the number of elements
		*/
		virtual bool start_object(std::size_t elements) = 0;

		/*!
		@brief an object key was read
		@param[in] val  object key
		@return whether parsing should proceed
		@note It is safe to move the passed string.
		*/
		virtual bool key(string_t& val) = 0;

		/*!
		@brief the end of an object was read
		@return whether parsing should proceed
		*/
		virtual bool end_object() = 0;

		/*!
		@brief the beginning of an array was read
		@param[in] elements  number of array elements or -1 if unknown
		@return whether parsing should proceed
		@note binary formats may report the number of elements
		*/
		virtual bool start_array(std::size_t elements) = 0;

		/*!
		@brief the end of an array was read
		@return whether parsing should proceed
		*/
		virtual bool end_array() = 0;

		/*!
		@brief a parse error occurred
		@param[in] position    the position in the input where the error occurs
		@param[in] last_token  the last read token
		@param[in] error_msg   a detailed error message
		@return whether parsing should proceed (must return false)
		*/
		virtual bool parse_error(std::size_t position,
			const std::string& last_token,
			const detail::exception& ex) = 0;

		virtual ~json_sax() = default;
	};


	namespace detail
	{
		/*!
		@brief SAX implementation to create a JSON value from SAX events

		This class implements the @ref json_sax interface and processes the SAX events
		to create a JSON value which makes it basically a DOM parser. The structure or
		hierarchy of the JSON value is managed by the stack `ref_stack` which contains
		a pointer to the respective array or object for each recursion depth.

		After successful parsing, the value that is passed by reference to the
		constructor contains the parsed value.

		@tparam BasicJsonType  the JSON type
		*/
		template<typename BasicJsonType>
		class json_sax_dom_parser
		{
		public:
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;

			/*!
			@param[in, out] r  reference to a JSON value that is manipulated while
							   parsing
			@param[in] allow_exceptions_  whether parse errors yield exceptions
			*/
			explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true)
				: root(r), allow_exceptions(allow_exceptions_)
			{}

			bool null()
			{
				handle_value(nullptr);
				return true;
			}

			bool boolean(bool val)
			{
				handle_value(val);
				return true;
			}

			bool number_integer(number_integer_t val)
			{
				handle_value(val);
				return true;
			}

			bool number_unsigned(number_unsigned_t val)
			{
				handle_value(val);
				return true;
			}

			bool number_float(number_float_t val, const string_t&)
			{
				handle_value(val);
				return true;
			}

			bool string(string_t& val)
			{
				handle_value(val);
				return true;
			}

			bool start_object(std::size_t len)
			{
				ref_stack.push_back(handle_value(BasicJsonType::value_t::object));

				if (JSON_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
				{
					JSON_THROW(out_of_range::create(408,
						"excessive object size: " + std::to_string(len)));
				}

				return true;
			}

			bool key(string_t& val)
			{
				// add null at given key and store the reference for later
				object_element = &(ref_stack.back()->m_value.object->operator[](val));
				return true;
			}

			bool end_object()
			{
				ref_stack.pop_back();
				return true;
			}

			bool start_array(std::size_t len)
			{
				ref_stack.push_back(handle_value(BasicJsonType::value_t::array));

				if (JSON_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
				{
					JSON_THROW(out_of_range::create(408,
						"excessive array size: " + std::to_string(len)));
				}

				return true;
			}

			bool end_array()
			{
				ref_stack.pop_back();
				return true;
			}

			bool parse_error(std::size_t, const std::string&,
				const detail::exception& ex)
			{
				errored = true;
				if (allow_exceptions)
				{
					// determine the proper exception type from the id
					switch ((ex.id / 100) % 100)
					{
					case 1:
						JSON_THROW(*reinterpret_cast<const detail::parse_error*>(&ex));
					case 4:
						JSON_THROW(*reinterpret_cast<const detail::out_of_range*>(&ex));
						// LCOV_EXCL_START
					case 2:
						JSON_THROW(*reinterpret_cast<const detail::invalid_iterator*>(&ex));
					case 3:
						JSON_THROW(*reinterpret_cast<const detail::type_error*>(&ex));
					case 5:
						JSON_THROW(*reinterpret_cast<const detail::other_error*>(&ex));
					default:
						assert(false);
						// LCOV_EXCL_STOP
					}
				}
				return false;
			}

			constexpr bool is_errored() const
			{
				return errored;
			}

		private:
			/*!
			@invariant If the ref stack is empty, then the passed value will be the new
					   root.
			@invariant If the ref stack contains a value, then it is an array or an
					   object to which we can add elements
			*/
			template<typename Value>
			BasicJsonType* handle_value(Value&& v)
			{
				if (ref_stack.empty())
				{
					root = BasicJsonType(std::forward<Value>(v));
					return &root;
				}
				else
				{
					assert(ref_stack.back()->is_array() or ref_stack.back()->is_object());
					if (ref_stack.back()->is_array())
					{
						ref_stack.back()->m_value.array->emplace_back(std::forward<Value>(v));
						return &(ref_stack.back()->m_value.array->back());
					}
					else
					{
						assert(object_element);
						*object_element = BasicJsonType(std::forward<Value>(v));
						return object_element;
					}
				}
			}

			/// the parsed JSON value
			BasicJsonType& root;
			/// stack to model hierarchy of values
			std::vector<BasicJsonType*> ref_stack;
			/// helper to hold the reference for the next object element
			BasicJsonType* object_element = nullptr;
			/// whether a syntax error occurred
			bool errored = false;
			/// whether to throw exceptions in case of errors
			const bool allow_exceptions = true;
		};

		template<typename BasicJsonType>
		class json_sax_dom_callback_parser
		{
		public:
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;
			using parser_callback_t = typename BasicJsonType::parser_callback_t;
			using parse_event_t = typename BasicJsonType::parse_event_t;

			json_sax_dom_callback_parser(BasicJsonType& r,
				const parser_callback_t cb,
				const bool allow_exceptions_ = true)
				: root(r), callback(cb), allow_exceptions(allow_exceptions_)
			{
				keep_stack.push_back(true);
			}

			bool null()
			{
				handle_value(nullptr);
				return true;
			}

			bool boolean(bool val)
			{
				handle_value(val);
				return true;
			}

			bool number_integer(number_integer_t val)
			{
				handle_value(val);
				return true;
			}

			bool number_unsigned(number_unsigned_t val)
			{
				handle_value(val);
				return true;
			}

			bool number_float(number_float_t val, const string_t&)
			{
				handle_value(val);
				return true;
			}

			bool string(string_t& val)
			{
				handle_value(val);
				return true;
			}

			bool start_object(std::size_t len)
			{
				// check callback for object start
				const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
				keep_stack.push_back(keep);

				auto val = handle_value(BasicJsonType::value_t::object, true);
				ref_stack.push_back(val.second);

				// check object limit
				if (ref_stack.back())
				{
					if (JSON_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
					{
						JSON_THROW(out_of_range::create(408,
							"excessive object size: " + std::to_string(len)));
					}
				}

				return true;
			}

			bool key(string_t& val)
			{
				BasicJsonType k = BasicJsonType(val);

				// check callback for key
				const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);
				key_keep_stack.push_back(keep);

				// add discarded value at given key and store the reference for later
				if (keep and ref_stack.back())
				{
					object_element = &(ref_stack.back()->m_value.object->operator[](val) = discarded);
				}

				return true;
			}

			bool end_object()
			{
				if (ref_stack.back())
				{
					if (not callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
					{
						// discard object
						*ref_stack.back() = discarded;
					}
				}

				assert(not ref_stack.empty());
				assert(not keep_stack.empty());
				ref_stack.pop_back();
				keep_stack.pop_back();

				if (not ref_stack.empty() and ref_stack.back())
				{
					// remove discarded value
					if (ref_stack.back()->is_object())
					{
						for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
						{
							if (it->is_discarded())
							{
								ref_stack.back()->erase(it);
								break;
							}
						}
					}
				}

				return true;
			}

			bool start_array(std::size_t len)
			{
				const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
				keep_stack.push_back(keep);

				auto val = handle_value(BasicJsonType::value_t::array, true);
				ref_stack.push_back(val.second);

				// check array limit
				if (ref_stack.back())
				{
					if (JSON_UNLIKELY(len != std::size_t(-1) and len > ref_stack.back()->max_size()))
					{
						JSON_THROW(out_of_range::create(408,
							"excessive array size: " + std::to_string(len)));
					}
				}

				return true;
			}

			bool end_array()
			{
				bool keep = true;

				if (ref_stack.back())
				{
					keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
					if (not keep)
					{
						// discard array
						*ref_stack.back() = discarded;
					}
				}

				assert(not ref_stack.empty());
				assert(not keep_stack.empty());
				ref_stack.pop_back();
				keep_stack.pop_back();

				// remove discarded value
				if (not keep and not ref_stack.empty())
				{
					if (ref_stack.back()->is_array())
					{
						ref_stack.back()->m_value.array->pop_back();
					}
				}

				return true;
			}

			bool parse_error(std::size_t, const std::string&,
				const detail::exception& ex)
			{
				errored = true;
				if (allow_exceptions)
				{
					// determine the proper exception type from the id
					switch ((ex.id / 100) % 100)
					{
					case 1:
						JSON_THROW(*reinterpret_cast<const detail::parse_error*>(&ex));
					case 4:
						JSON_THROW(*reinterpret_cast<const detail::out_of_range*>(&ex));
						// LCOV_EXCL_START
					case 2:
						JSON_THROW(*reinterpret_cast<const detail::invalid_iterator*>(&ex));
					case 3:
						JSON_THROW(*reinterpret_cast<const detail::type_error*>(&ex));
					case 5:
						JSON_THROW(*reinterpret_cast<const detail::other_error*>(&ex));
					default:
						assert(false);
						// LCOV_EXCL_STOP
					}
				}
				return false;
			}

			constexpr bool is_errored() const
			{
				return errored;
			}

		private:
			/*!
			@param[in] v  value to add to the JSON value we build during parsing
			@param[in] skip_callback  whether we should skip calling the callback
					   function; this is required after start_array() and
					   start_object() SAX events, because otherwise we would call the
					   callback function with an empty array or object, respectively.

			@invariant If the ref stack is empty, then the passed value will be the new
					   root.
			@invariant If the ref stack contains a value, then it is an array or an
					   object to which we can add elements

			@return pair of boolean (whether value should be kept) and pointer (to the
					passed value in the ref_stack hierarchy; nullptr if not kept)
			*/
			template<typename Value>
			std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)
			{
				assert(not keep_stack.empty());

				// do not handle this value if we know it would be added to a discarded
				// container
				if (not keep_stack.back())
				{
					return { false, nullptr };
				}

				// create value
				auto value = BasicJsonType(std::forward<Value>(v));

				// check callback
				const bool keep = skip_callback or callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);

				// do not handle this value if we just learnt it shall be discarded
				if (not keep)
				{
					return { false, nullptr };
				}

				if (ref_stack.empty())
				{
					root = std::move(value);
					return { true, &root };
				}
				else
				{
					// skip this value if we already decided to skip the parent
					// (https://github.com/nlohmann/json/issues/971#issuecomment-413678360)
					if (not ref_stack.back())
					{
						return { false, nullptr };
					}

					assert(ref_stack.back()->is_array() or ref_stack.back()->is_object());
					if (ref_stack.back()->is_array())
					{
						ref_stack.back()->m_value.array->push_back(std::move(value));
						return { true, &(ref_stack.back()->m_value.array->back()) };
					}
					else
					{
						// check if we should store an element for the current key
						assert(not key_keep_stack.empty());
						const bool store_element = key_keep_stack.back();
						key_keep_stack.pop_back();

						if (not store_element)
						{
							return { false, nullptr };
						}

						assert(object_element);
						*object_element = std::move(value);
						return { true, object_element };
					}
				}
			}

			/// the parsed JSON value
			BasicJsonType& root;
			/// stack to model hierarchy of values
			std::vector<BasicJsonType*> ref_stack;
			/// stack to manage which values to keep
			std::vector<bool> keep_stack;
			/// stack to manage which object keys to keep
			std::vector<bool> key_keep_stack;
			/// helper to hold the reference for the next object element
			BasicJsonType* object_element = nullptr;
			/// whether a syntax error occurred
			bool errored = false;
			/// callback function
			const parser_callback_t callback = nullptr;
			/// whether to throw exceptions in case of errors
			const bool allow_exceptions = true;
			/// a discarded value for the callback
			BasicJsonType discarded = BasicJsonType::value_t::discarded;
		};

		template<typename BasicJsonType>
		class json_sax_acceptor
		{
		public:
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;

			bool null()
			{
				return true;
			}

			bool boolean(bool)
			{
				return true;
			}

			bool number_integer(number_integer_t)
			{
				return true;
			}

			bool number_unsigned(number_unsigned_t)
			{
				return true;
			}

			bool number_float(number_float_t, const string_t&)
			{
				return true;
			}

			bool string(string_t&)
			{
				return true;
			}

			bool start_object(std::size_t = std::size_t(-1))
			{
				return true;
			}

			bool key(string_t&)
			{
				return true;
			}

			bool end_object()
			{
				return true;
			}

			bool start_array(std::size_t = std::size_t(-1))
			{
				return true;
			}

			bool end_array()
			{
				return true;
			}

			bool parse_error(std::size_t, const std::string&, const detail::exception&)
			{
				return false;
			}
		};
	}

}

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		////////////
		// parser //
		////////////

		/*!
		@brief syntax analysis

		This class implements a recursive decent parser.
		*/
		template<typename BasicJsonType>
		class parser
		{
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;
			using lexer_t = lexer<BasicJsonType>;
			using token_type = typename lexer_t::token_type;

		public:
			enum class parse_event_t : uint8_t
			{
				/// the parser read `{` and started to process a JSON object
				object_start,
				/// the parser read `}` and finished processing a JSON object
				object_end,
				/// the parser read `[` and started to process a JSON array
				array_start,
				/// the parser read `]` and finished processing a JSON array
				array_end,
				/// the parser read a key of a value in an object
				key,
				/// the parser finished reading a JSON value
				value
			};

			using parser_callback_t =
				std::function<bool(int depth, parse_event_t event, BasicJsonType& parsed)>;

			/// a parser reading from an input adapter
			explicit parser(detail::input_adapter_t&& adapter,
				const parser_callback_t cb = nullptr,
				const bool allow_exceptions_ = true)
				: callback(cb), m_lexer(std::move(adapter)), allow_exceptions(allow_exceptions_)
			{
				// read first token
				get_token();
			}

			/*!
			@brief public parser interface

			@param[in] strict      whether to expect the last token to be EOF
			@param[in,out] result  parsed JSON value

			@throw parse_error.101 in case of an unexpected token
			@throw parse_error.102 if to_unicode fails or surrogate error
			@throw parse_error.103 if to_unicode fails
			*/
			void parse(const bool strict, BasicJsonType& result)
			{
				if (callback)
				{
					json_sax_dom_callback_parser<BasicJsonType> sdp(result, callback, allow_exceptions);
					sax_parse_internal(&sdp);
					result.assert_invariant();

					// in strict mode, input must be completely read
					if (strict and (get_token() != token_type::end_of_input))
					{
						sdp.parse_error(m_lexer.get_position(),
							m_lexer.get_token_string(),
							parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input)));
					}

					// in case of an error, return discarded value
					if (sdp.is_errored())
					{
						result = value_t::discarded;
						return;
					}

					// set top-level value to null if it was discarded by the callback
					// function
					if (result.is_discarded())
					{
						result = nullptr;
					}
				}
				else
				{
					json_sax_dom_parser<BasicJsonType> sdp(result, allow_exceptions);
					sax_parse_internal(&sdp);
					result.assert_invariant();

					// in strict mode, input must be completely read
					if (strict and (get_token() != token_type::end_of_input))
					{
						sdp.parse_error(m_lexer.get_position(),
							m_lexer.get_token_string(),
							parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input)));
					}

					// in case of an error, return discarded value
					if (sdp.is_errored())
					{
						result = value_t::discarded;
						return;
					}
				}
			}

			/*!
			@brief public accept interface

			@param[in] strict  whether to expect the last token to be EOF
			@return whether the input is a proper JSON text
			*/
			bool accept(const bool strict = true)
			{
				json_sax_acceptor<BasicJsonType> sax_acceptor;
				return sax_parse(&sax_acceptor, strict);
			}

			template <typename SAX>
			bool sax_parse(SAX* sax, const bool strict = true)
			{
				(void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
				const bool result = sax_parse_internal(sax);

				// strict mode: next byte must be EOF
				if (result and strict and (get_token() != token_type::end_of_input))
				{
					return sax->parse_error(m_lexer.get_position(),
						m_lexer.get_token_string(),
						parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input)));
				}

				return result;
			}

		private:
			template <typename SAX>
			bool sax_parse_internal(SAX* sax)
			{
				// stack to remember the hieararchy of structured values we are parsing
				// true = array; false = object
				std::vector<bool> states;
				// value to avoid a goto (see comment where set to true)
				bool skip_to_state_evaluation = false;

				while (true)
				{
					if (not skip_to_state_evaluation)
					{
						// invariant: get_token() was called before each iteration
						switch (last_token)
						{
						case token_type::begin_object:
						{
							if (JSON_UNLIKELY(not sax->start_object(std::size_t(-1))))
							{
								return false;
							}

							// closing } -> we are done
							if (get_token() == token_type::end_object)
							{
								if (JSON_UNLIKELY(not sax->end_object()))
								{
									return false;
								}
								break;
							}

							// parse key
							if (JSON_UNLIKELY(last_token != token_type::value_string))
							{
								return sax->parse_error(m_lexer.get_position(),
									m_lexer.get_token_string(),
									parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string)));
							}
							else
							{
								if (JSON_UNLIKELY(not sax->key(m_lexer.get_string())))
								{
									return false;
								}
							}

							// parse separator (:)
							if (JSON_UNLIKELY(get_token() != token_type::name_separator))
							{
								return sax->parse_error(m_lexer.get_position(),
									m_lexer.get_token_string(),
									parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator)));
							}

							// remember we are now inside an object
							states.push_back(false);

							// parse values
							get_token();
							continue;
						}

						case token_type::begin_array:
						{
							if (JSON_UNLIKELY(not sax->start_array(std::size_t(-1))))
							{
								return false;
							}

							// closing ] -> we are done
							if (get_token() == token_type::end_array)
							{
								if (JSON_UNLIKELY(not sax->end_array()))
								{
									return false;
								}
								break;
							}

							// remember we are now inside an array
							states.push_back(true);

							// parse values (no need to call get_token)
							continue;
						}

						case token_type::value_float:
						{
							const auto res = m_lexer.get_number_float();

							if (JSON_UNLIKELY(not std::isfinite(res)))
							{
								return sax->parse_error(m_lexer.get_position(),
									m_lexer.get_token_string(),
									out_of_range::create(406, "number overflow parsing '" + m_lexer.get_token_string() + "'"));
							}
							else
							{
								if (JSON_UNLIKELY(not sax->number_float(res, m_lexer.get_string())))
								{
									return false;
								}
								break;
							}
						}

						case token_type::literal_false:
						{
							if (JSON_UNLIKELY(not sax->boolean(false)))
							{
								return false;
							}
							break;
						}

						case token_type::literal_null:
						{
							if (JSON_UNLIKELY(not sax->null()))
							{
								return false;
							}
							break;
						}

						case token_type::literal_true:
						{
							if (JSON_UNLIKELY(not sax->boolean(true)))
							{
								return false;
							}
							break;
						}

						case token_type::value_integer:
						{
							if (JSON_UNLIKELY(not sax->number_integer(m_lexer.get_number_integer())))
							{
								return false;
							}
							break;
						}

						case token_type::value_string:
						{
							if (JSON_UNLIKELY(not sax->string(m_lexer.get_string())))
							{
								return false;
							}
							break;
						}

						case token_type::value_unsigned:
						{
							if (JSON_UNLIKELY(not sax->number_unsigned(m_lexer.get_number_unsigned())))
							{
								return false;
							}
							break;
						}

						case token_type::parse_error:
						{
							// using "uninitialized" to avoid "expected" message
							return sax->parse_error(m_lexer.get_position(),
								m_lexer.get_token_string(),
								parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized)));
						}

						default: // the last token was unexpected
						{
							return sax->parse_error(m_lexer.get_position(),
								m_lexer.get_token_string(),
								parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value)));
						}
						}
					}
					else
					{
						skip_to_state_evaluation = false;
					}

					// we reached this line after we successfully parsed a value
					if (states.empty())
					{
						// empty stack: we reached the end of the hieararchy: done
						return true;
					}
					else
					{
						if (states.back())  // array
						{
							// comma -> next value
							if (get_token() == token_type::value_separator)
							{
								// parse a new value
								get_token();
								continue;
							}

							// closing ]
							if (JSON_LIKELY(last_token == token_type::end_array))
							{
								if (JSON_UNLIKELY(not sax->end_array()))
								{
									return false;
								}

								// We are done with this array. Before we can parse a
								// new value, we need to evaluate the new state first.
								// By setting skip_to_state_evaluation to false, we
								// are effectively jumping to the beginning of this if.
								assert(not states.empty());
								states.pop_back();
								skip_to_state_evaluation = true;
								continue;
							}
							else
							{
								return sax->parse_error(m_lexer.get_position(),
									m_lexer.get_token_string(),
									parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array)));
							}
						}
						else  // object
						{
							// comma -> next value
							if (get_token() == token_type::value_separator)
							{
								// parse key
								if (JSON_UNLIKELY(get_token() != token_type::value_string))
								{
									return sax->parse_error(m_lexer.get_position(),
										m_lexer.get_token_string(),
										parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string)));
								}
								else
								{
									if (JSON_UNLIKELY(not sax->key(m_lexer.get_string())))
									{
										return false;
									}
								}

								// parse separator (:)
								if (JSON_UNLIKELY(get_token() != token_type::name_separator))
								{
									return sax->parse_error(m_lexer.get_position(),
										m_lexer.get_token_string(),
										parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator)));
								}

								// parse values
								get_token();
								continue;
							}

							// closing }
							if (JSON_LIKELY(last_token == token_type::end_object))
							{
								if (JSON_UNLIKELY(not sax->end_object()))
								{
									return false;
								}

								// We are done with this object. Before we can parse a
								// new value, we need to evaluate the new state first.
								// By setting skip_to_state_evaluation to false, we
								// are effectively jumping to the beginning of this if.
								assert(not states.empty());
								states.pop_back();
								skip_to_state_evaluation = true;
								continue;
							}
							else
							{
								return sax->parse_error(m_lexer.get_position(),
									m_lexer.get_token_string(),
									parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object)));
							}
						}
					}
				}
			}

			/// get next token from lexer
			token_type get_token()
			{
				return (last_token = m_lexer.scan());
			}

			std::string exception_message(const token_type expected)
			{
				std::string error_msg = "syntax error - ";
				if (last_token == token_type::parse_error)
				{
					error_msg += std::string(m_lexer.get_error_message()) + "; last read: '" +
						m_lexer.get_token_string() + "'";
				}
				else
				{
					error_msg += "unexpected " + std::string(lexer_t::token_type_name(last_token));
				}

				if (expected != token_type::uninitialized)
				{
					error_msg += "; expected " + std::string(lexer_t::token_type_name(expected));
				}

				return error_msg;
			}

		private:
			/// callback function
			const parser_callback_t callback = nullptr;
			/// the type of the last read token
			token_type last_token = token_type::uninitialized;
			/// the lexer
			lexer_t m_lexer;
			/// whether to throw exceptions in case of errors
			const bool allow_exceptions = true;
		};
	}
}

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>


#include <cstddef> // ptrdiff_t
#include <limits>  // numeric_limits

namespace nlohmann
{
	namespace detail
	{
		/*
		@brief an iterator for primitive JSON types

		This class models an iterator for primitive JSON types (boolean, number,
		string). It's only purpose is to allow the iterator/const_iterator classes
		to "iterate" over primitive values. Internally, the iterator is modeled by
		a `difference_type` variable. Value begin_value (`0`) models the begin,
		end_value (`1`) models past the end.
		*/
		class primitive_iterator_t
		{
		private:
			using difference_type = std::ptrdiff_t;
			static constexpr difference_type begin_value = 0;
			static constexpr difference_type end_value = begin_value + 1;

			/// iterator as signed integer type
			difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();

		public:
			constexpr difference_type get_value() const noexcept
			{
				return m_it;
			}

			/// set iterator to a defined beginning
			void set_begin() noexcept
			{
				m_it = begin_value;
			}

			/// set iterator to a defined past the end
			void set_end() noexcept
			{
				m_it = end_value;
			}

			/// return whether the iterator can be dereferenced
			constexpr bool is_begin() const noexcept
			{
				return m_it == begin_value;
			}

			/// return whether the iterator is at end
			constexpr bool is_end() const noexcept
			{
				return m_it == end_value;
			}

			friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
			{
				return lhs.m_it == rhs.m_it;
			}

			friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
			{
				return lhs.m_it < rhs.m_it;
			}

			primitive_iterator_t operator+(difference_type n) noexcept
			{
				auto result = *this;
				result += n;
				return result;
			}

			friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
			{
				return lhs.m_it - rhs.m_it;
			}

			primitive_iterator_t& operator++() noexcept
			{
				++m_it;
				return *this;
			}

			primitive_iterator_t const operator++(int) noexcept
			{
				auto result = *this;
				++m_it;
				return result;
			}

			primitive_iterator_t& operator--() noexcept
			{
				--m_it;
				return *this;
			}

			primitive_iterator_t const operator--(int) noexcept
			{
				auto result = *this;
				--m_it;
				return result;
			}

			primitive_iterator_t& operator+=(difference_type n) noexcept
			{
				m_it += n;
				return *this;
			}

			primitive_iterator_t& operator-=(difference_type n) noexcept
			{
				m_it -= n;
				return *this;
			}
		};
	}
}

// #include <nlohmann/detail/iterators/internal_iterator.hpp>


// #include <nlohmann/detail/iterators/primitive_iterator.hpp>


namespace nlohmann
{
	namespace detail
	{
		/*!
		@brief an iterator value

		@note This structure could easily be a union, but MSVC currently does not allow
		unions members with complex constructors, see https://github.com/nlohmann/json/pull/105.
		*/
		template<typename BasicJsonType> struct internal_iterator
		{
			/// iterator for JSON objects
			typename BasicJsonType::object_t::iterator object_iterator{};
			/// iterator for JSON arrays
			typename BasicJsonType::array_t::iterator array_iterator{};
			/// generic iterator for all other types
			primitive_iterator_t primitive_iterator{};
		};
	}
}

// #include <nlohmann/detail/iterators/iter_impl.hpp>


#include <ciso646> // not
#include <iterator> // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next
#include <type_traits> // conditional, is_const, remove_const

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/iterators/internal_iterator.hpp>

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		// forward declare, to be able to friend it later on
		template<typename IteratorType> class iteration_proxy;

		/*!
		@brief a template for a bidirectional iterator for the @ref basic_json class

		This class implements a both iterators (iterator and const_iterator) for the
		@ref basic_json class.

		@note An iterator is called *initialized* when a pointer to a JSON value has
			  been set (e.g., by a constructor or a copy assignment). If the iterator is
			  default-constructed, it is *uninitialized* and most methods are undefined.
			  **The library uses assertions to detect calls on uninitialized iterators.**

		@requirement The class satisfies the following concept requirements:
		-
		[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
		  The iterator that can be moved can be moved in both directions (i.e.
		  incremented and decremented).

		@since version 1.0.0, simplified in version 2.0.9, change to bidirectional
			   iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)
		*/
		template<typename BasicJsonType>
		class iter_impl
		{
			/// allow basic_json to access private members
			friend iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
			friend BasicJsonType;
			friend iteration_proxy<iter_impl>;

			using object_t = typename BasicJsonType::object_t;
			using array_t = typename BasicJsonType::array_t;
			// make sure BasicJsonType is basic_json or const basic_json
			static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
				"iter_impl only accepts (const) basic_json");

		public:

			/// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.
			/// The C++ Standard has never required user-defined iterators to derive from std::iterator.
			/// A user-defined iterator should provide publicly accessible typedefs named
			/// iterator_category, value_type, difference_type, pointer, and reference.
			/// Note that value_type is required to be non-const, even for constant iterators.
			using iterator_category = std::bidirectional_iterator_tag;

			/// the type of the values when the iterator is dereferenced
			using value_type = typename BasicJsonType::value_type;
			/// a type to represent differences between iterators
			using difference_type = typename BasicJsonType::difference_type;
			/// defines a pointer to the type iterated over (value_type)
			using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
				typename BasicJsonType::const_pointer,
				typename BasicJsonType::pointer>::type;
			/// defines a reference to the type iterated over (value_type)
			using reference =
				typename std::conditional<std::is_const<BasicJsonType>::value,
				typename BasicJsonType::const_reference,
				typename BasicJsonType::reference>::type;

			/// default constructor
			iter_impl() = default;

			/*!
			@brief constructor for a given JSON instance
			@param[in] object  pointer to a JSON object for this iterator
			@pre object != nullptr
			@post The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			explicit iter_impl(pointer object) noexcept : m_object(object)
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					m_it.object_iterator = typename object_t::iterator();
					break;
				}

				case value_t::array:
				{
					m_it.array_iterator = typename array_t::iterator();
					break;
				}

				default:
				{
					m_it.primitive_iterator = primitive_iterator_t();
					break;
				}
				}
			}

			/*!
			@note The conventional copy constructor and copy assignment are implicitly
				  defined. Combined with the following converting constructor and
				  assignment, they support: (1) copy from iterator to iterator, (2)
				  copy from const iterator to const iterator, and (3) conversion from
				  iterator to const iterator. However conversion from const iterator
				  to iterator is not defined.
			*/

			/*!
			@brief converting constructor
			@param[in] other  non-const iterator to copy from
			@note It is not checked whether @a other is initialized.
			*/
			iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
				: m_object(other.m_object), m_it(other.m_it) {}

			/*!
			@brief converting assignment
			@param[in,out] other  non-const iterator to copy from
			@return const/non-const iterator
			@note It is not checked whether @a other is initialized.
			*/
			iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
			{
				m_object = other.m_object;
				m_it = other.m_it;
				return *this;
			}

		private:
			/*!
			@brief set the iterator to the first value
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			void set_begin() noexcept
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					m_it.object_iterator = m_object->m_value.object->begin();
					break;
				}

				case value_t::array:
				{
					m_it.array_iterator = m_object->m_value.array->begin();
					break;
				}

				case value_t::null:
				{
					// set to end so begin()==end() is true: null is empty
					m_it.primitive_iterator.set_end();
					break;
				}

				default:
				{
					m_it.primitive_iterator.set_begin();
					break;
				}
				}
			}

			/*!
			@brief set the iterator past the last value
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			void set_end() noexcept
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					m_it.object_iterator = m_object->m_value.object->end();
					break;
				}

				case value_t::array:
				{
					m_it.array_iterator = m_object->m_value.array->end();
					break;
				}

				default:
				{
					m_it.primitive_iterator.set_end();
					break;
				}
				}
			}

		public:
			/*!
			@brief return a reference to the value pointed to by the iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			reference operator*() const
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					assert(m_it.object_iterator != m_object->m_value.object->end());
					return m_it.object_iterator->second;
				}

				case value_t::array:
				{
					assert(m_it.array_iterator != m_object->m_value.array->end());
					return *m_it.array_iterator;
				}

				case value_t::null:
					JSON_THROW(invalid_iterator::create(214, "cannot get value"));

				default:
				{
					if (JSON_LIKELY(m_it.primitive_iterator.is_begin()))
					{
						return *m_object;
					}

					JSON_THROW(invalid_iterator::create(214, "cannot get value"));
				}
				}
			}

			/*!
			@brief dereference the iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			pointer operator->() const
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					assert(m_it.object_iterator != m_object->m_value.object->end());
					return &(m_it.object_iterator->second);
				}

				case value_t::array:
				{
					assert(m_it.array_iterator != m_object->m_value.array->end());
					return &*m_it.array_iterator;
				}

				default:
				{
					if (JSON_LIKELY(m_it.primitive_iterator.is_begin()))
					{
						return m_object;
					}

					JSON_THROW(invalid_iterator::create(214, "cannot get value"));
				}
				}
			}

			/*!
			@brief post-increment (it++)
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl const operator++(int)
			{
				auto result = *this;
				++(*this);
				return result;
			}

			/*!
			@brief pre-increment (++it)
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl& operator++()
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					std::advance(m_it.object_iterator, 1);
					break;
				}

				case value_t::array:
				{
					std::advance(m_it.array_iterator, 1);
					break;
				}

				default:
				{
					++m_it.primitive_iterator;
					break;
				}
				}

				return *this;
			}

			/*!
			@brief post-decrement (it--)
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl const operator--(int)
			{
				auto result = *this;
				--(*this);
				return result;
			}

			/*!
			@brief pre-decrement (--it)
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl& operator--()
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
				{
					std::advance(m_it.object_iterator, -1);
					break;
				}

				case value_t::array:
				{
					std::advance(m_it.array_iterator, -1);
					break;
				}

				default:
				{
					--m_it.primitive_iterator;
					break;
				}
				}

				return *this;
			}

			/*!
			@brief  comparison: equal
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			bool operator==(const iter_impl& other) const
			{
				// if objects are not the same, the comparison is undefined
				if (JSON_UNLIKELY(m_object != other.m_object))
				{
					JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
				}

				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
					return (m_it.object_iterator == other.m_it.object_iterator);

				case value_t::array:
					return (m_it.array_iterator == other.m_it.array_iterator);

				default:
					return (m_it.primitive_iterator == other.m_it.primitive_iterator);
				}
			}

			/*!
			@brief  comparison: not equal
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			bool operator!=(const iter_impl& other) const
			{
				return not operator==(other);
			}

			/*!
			@brief  comparison: smaller
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			bool operator<(const iter_impl& other) const
			{
				// if objects are not the same, the comparison is undefined
				if (JSON_UNLIKELY(m_object != other.m_object))
				{
					JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers"));
				}

				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
					JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators"));

				case value_t::array:
					return (m_it.array_iterator < other.m_it.array_iterator);

				default:
					return (m_it.primitive_iterator < other.m_it.primitive_iterator);
				}
			}

			/*!
			@brief  comparison: less than or equal
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			bool operator<=(const iter_impl& other) const
			{
				return not other.operator < (*this);
			}

			/*!
			@brief  comparison: greater than
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			bool operator>(const iter_impl& other) const
			{
				return not operator<=(other);
			}

			/*!
			@brief  comparison: greater than or equal
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			bool operator>=(const iter_impl& other) const
			{
				return not operator<(other);
			}

			/*!
			@brief  add to iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl& operator+=(difference_type i)
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
					JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

				case value_t::array:
				{
					std::advance(m_it.array_iterator, i);
					break;
				}

				default:
				{
					m_it.primitive_iterator += i;
					break;
				}
				}

				return *this;
			}

			/*!
			@brief  subtract from iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl& operator-=(difference_type i)
			{
				return operator+=(-i);
			}

			/*!
			@brief  add to iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl operator+(difference_type i) const
			{
				auto result = *this;
				result += i;
				return result;
			}

			/*!
			@brief  addition of distance and iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			friend iter_impl operator+(difference_type i, const iter_impl& it)
			{
				auto result = it;
				result += i;
				return result;
			}

			/*!
			@brief  subtract from iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			iter_impl operator-(difference_type i) const
			{
				auto result = *this;
				result -= i;
				return result;
			}

			/*!
			@brief  return difference
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			difference_type operator-(const iter_impl& other) const
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
					JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators"));

				case value_t::array:
					return m_it.array_iterator - other.m_it.array_iterator;

				default:
					return m_it.primitive_iterator - other.m_it.primitive_iterator;
				}
			}

			/*!
			@brief  access to successor
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			reference operator[](difference_type n) const
			{
				assert(m_object != nullptr);

				switch (m_object->m_type)
				{
				case value_t::object:
					JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators"));

				case value_t::array:
					return *std::next(m_it.array_iterator, n);

				case value_t::null:
					JSON_THROW(invalid_iterator::create(214, "cannot get value"));

				default:
				{
					if (JSON_LIKELY(m_it.primitive_iterator.get_value() == -n))
					{
						return *m_object;
					}

					JSON_THROW(invalid_iterator::create(214, "cannot get value"));
				}
				}
			}

			/*!
			@brief  return the key of an object iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			const typename object_t::key_type& key() const
			{
				assert(m_object != nullptr);

				if (JSON_LIKELY(m_object->is_object()))
				{
					return m_it.object_iterator->first;
				}

				JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators"));
			}

			/*!
			@brief  return the value of an iterator
			@pre The iterator is initialized; i.e. `m_object != nullptr`.
			*/
			reference value() const
			{
				return operator*();
			}

		private:
			/// associated JSON instance
			pointer m_object = nullptr;
			/// the actual iterator of the associated instance
			internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it;
		};
	}
}

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>

// #include <nlohmann/detail/iterators/json_reverse_iterator.hpp>


#include <cstddef> // ptrdiff_t
#include <iterator> // reverse_iterator
#include <utility> // declval

namespace nlohmann
{
	namespace detail
	{
		//////////////////////
		// reverse_iterator //
		//////////////////////

		/*!
		@brief a template for a reverse iterator class

		@tparam Base the base iterator type to reverse. Valid types are @ref
		iterator (to create @ref reverse_iterator) and @ref const_iterator (to
		create @ref const_reverse_iterator).

		@requirement The class satisfies the following concept requirements:
		-
		[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
		  The iterator that can be moved can be moved in both directions (i.e.
		  incremented and decremented).
		- [OutputIterator](https://en.cppreference.com/w/cpp/named_req/OutputIterator):
		  It is possible to write to the pointed-to element (only if @a Base is
		  @ref iterator).

		@since version 1.0.0
		*/
		template<typename Base>
		class json_reverse_iterator : public std::reverse_iterator<Base>
		{
		public:
			using difference_type = std::ptrdiff_t;
			/// shortcut to the reverse iterator adapter
			using base_iterator = std::reverse_iterator<Base>;
			/// the reference type for the pointed-to element
			using reference = typename Base::reference;

			/// create reverse iterator from iterator
			explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
				: base_iterator(it) {}

			/// create reverse iterator from base class
			explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}

			/// post-increment (it++)
			json_reverse_iterator const operator++(int)
			{
				return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
			}

			/// pre-increment (++it)
			json_reverse_iterator& operator++()
			{
				return static_cast<json_reverse_iterator&>(base_iterator::operator++());
			}

			/// post-decrement (it--)
			json_reverse_iterator const operator--(int)
			{
				return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
			}

			/// pre-decrement (--it)
			json_reverse_iterator& operator--()
			{
				return static_cast<json_reverse_iterator&>(base_iterator::operator--());
			}

			/// add to iterator
			json_reverse_iterator& operator+=(difference_type i)
			{
				return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
			}

			/// add to iterator
			json_reverse_iterator operator+(difference_type i) const
			{
				return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
			}

			/// subtract from iterator
			json_reverse_iterator operator-(difference_type i) const
			{
				return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
			}

			/// return difference
			difference_type operator-(const json_reverse_iterator& other) const
			{
				return base_iterator(*this) - base_iterator(other);
			}

			/// access to successor
			reference operator[](difference_type n) const
			{
				return *(this->operator+(n));
			}

			/// return the key of an object iterator
			auto key() const -> decltype(std::declval<Base>().key())
			{
				auto it = --this->base();
				return it.key();
			}

			/// return the value of an iterator
			reference value() const
			{
				auto it = --this->base();
				return it.operator * ();
			}
		};
	}
}

// #include <nlohmann/detail/output/output_adapters.hpp>


#include <algorithm> // copy
#include <cstddef> // size_t
#include <ios> // streamsize
#include <iterator> // back_inserter
#include <memory> // shared_ptr, make_shared
#include <ostream> // basic_ostream
#include <string> // basic_string
#include <vector> // vector

namespace nlohmann
{
	namespace detail
	{
		/// abstract output adapter interface
		template<typename CharType> struct output_adapter_protocol
		{
			virtual void write_character(CharType c) = 0;
			virtual void write_characters(const CharType* s, std::size_t length) = 0;
			virtual ~output_adapter_protocol() = default;
		};

		/// a type to simplify interfaces
		template<typename CharType>
		using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;

		/// output adapter for byte vectors
		template<typename CharType>
		class output_vector_adapter : public output_adapter_protocol<CharType>
		{
		public:
			explicit output_vector_adapter(std::vector<CharType>& vec) : v(vec) {}

			void write_character(CharType c) override
			{
				v.push_back(c);
			}

			void write_characters(const CharType* s, std::size_t length) override
			{
				std::copy(s, s + length, std::back_inserter(v));
			}

		private:
			std::vector<CharType>& v;
		};

		/// output adapter for output streams
		template<typename CharType>
		class output_stream_adapter : public output_adapter_protocol<CharType>
		{
		public:
			explicit output_stream_adapter(std::basic_ostream<CharType>& s) : stream(s) {}

			void write_character(CharType c) override
			{
				stream.put(c);
			}

			void write_characters(const CharType* s, std::size_t length) override
			{
				stream.write(s, static_cast<std::streamsize>(length));
			}

		private:
			std::basic_ostream<CharType>& stream;
		};

		/// output adapter for basic_string
		template<typename CharType, typename StringType = std::basic_string<CharType>>
		class output_string_adapter : public output_adapter_protocol<CharType>
		{
		public:
			explicit output_string_adapter(StringType& s) : str(s) {}

			void write_character(CharType c) override
			{
				str.push_back(c);
			}

			void write_characters(const CharType* s, std::size_t length) override
			{
				str.append(s, length);
			}

		private:
			StringType& str;
		};

		template<typename CharType, typename StringType = std::basic_string<CharType>>
		class output_adapter
		{
		public:
			output_adapter(std::vector<CharType>& vec)
				: oa(std::make_shared<output_vector_adapter<CharType>>(vec)) {}

			output_adapter(std::basic_ostream<CharType>& s)
				: oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}

			output_adapter(StringType& s)
				: oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}

			operator output_adapter_t<CharType>()
			{
				return oa;
			}

		private:
			output_adapter_t<CharType> oa = nullptr;
		};
	}
}

// #include <nlohmann/detail/input/binary_reader.hpp>


#include <algorithm> // generate_n
#include <array> // array
#include <cassert> // assert
#include <cmath> // ldexp
#include <cstddef> // size_t
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstdio> // snprintf
#include <cstring> // memcpy
#include <iterator> // back_inserter
#include <limits> // numeric_limits
#include <string> // char_traits, string
#include <utility> // make_pair, move

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/json_sax.hpp>

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		///////////////////
		// binary reader //
		///////////////////

		/*!
		@brief deserialization of CBOR, MessagePack, and UBJSON values
		*/
		template<typename BasicJsonType, typename SAX = json_sax_dom_parser<BasicJsonType>>
		class binary_reader
		{
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using string_t = typename BasicJsonType::string_t;
			using json_sax_t = SAX;

		public:
			/*!
			@brief create a binary reader

			@param[in] adapter  input adapter to read from
			*/
			explicit binary_reader(input_adapter_t adapter) : ia(std::move(adapter))
			{
				(void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
				assert(ia);
			}

			/*!
			@param[in] format  the binary format to parse
			@param[in] sax_    a SAX event processor
			@param[in] strict  whether to expect the input to be consumed completed

			@return
			*/
			bool sax_parse(const input_format_t format,
				json_sax_t* sax_,
				const bool strict = true)
			{
				sax = sax_;
				bool result = false;

				switch (format)
				{
				case input_format_t::cbor:
					result = parse_cbor_internal();
					break;

				case input_format_t::msgpack:
					result = parse_msgpack_internal();
					break;

				case input_format_t::ubjson:
					result = parse_ubjson_internal();
					break;

					// LCOV_EXCL_START
				default:
					assert(false);
					// LCOV_EXCL_STOP
				}

				// strict mode: next byte must be EOF
				if (result and strict)
				{
					if (format == input_format_t::ubjson)
					{
						get_ignore_noop();
					}
					else
					{
						get();
					}

					if (JSON_UNLIKELY(current != std::char_traits<char>::eof()))
					{
						return sax->parse_error(chars_read, get_token_string(), parse_error::create(110, chars_read, "expected end of input"));
					}
				}

				return result;
			}

			/*!
			@brief determine system byte order

			@return true if and only if system's byte order is little endian

			@note from http://stackoverflow.com/a/1001328/266378
			*/
			static constexpr bool little_endianess(int num = 1) noexcept
			{
				return (*reinterpret_cast<char*>(&num) == 1);
			}

		private:
			/*!
			@param[in] get_char  whether a new character should be retrieved from the
								 input (true, default) or whether the last read
								 character should be considered instead

			@return whether a valid CBOR value was passed to the SAX parser
			*/
			bool parse_cbor_internal(const bool get_char = true)
			{
				switch (get_char ? get() : current)
				{
					// EOF
				case std::char_traits<char>::eof():
					return unexpect_eof();

					// Integer 0x00..0x17 (0..23)
				case 0x00:
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x04:
				case 0x05:
				case 0x06:
				case 0x07:
				case 0x08:
				case 0x09:
				case 0x0A:
				case 0x0B:
				case 0x0C:
				case 0x0D:
				case 0x0E:
				case 0x0F:
				case 0x10:
				case 0x11:
				case 0x12:
				case 0x13:
				case 0x14:
				case 0x15:
				case 0x16:
				case 0x17:
					return sax->number_unsigned(static_cast<number_unsigned_t>(current));

				case 0x18: // Unsigned integer (one-byte uint8_t follows)
				{
					uint8_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0x19: // Unsigned integer (two-byte uint16_t follows)
				{
					uint16_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0x1A: // Unsigned integer (four-byte uint32_t follows)
				{
					uint32_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0x1B: // Unsigned integer (eight-byte uint64_t follows)
				{
					uint64_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				// Negative integer -1-0x00..-1-0x17 (-1..-24)
				case 0x20:
				case 0x21:
				case 0x22:
				case 0x23:
				case 0x24:
				case 0x25:
				case 0x26:
				case 0x27:
				case 0x28:
				case 0x29:
				case 0x2A:
				case 0x2B:
				case 0x2C:
				case 0x2D:
				case 0x2E:
				case 0x2F:
				case 0x30:
				case 0x31:
				case 0x32:
				case 0x33:
				case 0x34:
				case 0x35:
				case 0x36:
				case 0x37:
					return sax->number_integer(static_cast<int8_t>(0x20 - 1 - current));

				case 0x38: // Negative integer (one-byte uint8_t follows)
				{
					uint8_t number;
					return get_number(number) and sax->number_integer(static_cast<number_integer_t>(-1) - number);
				}

				case 0x39: // Negative integer -1-n (two-byte uint16_t follows)
				{
					uint16_t number;
					return get_number(number) and sax->number_integer(static_cast<number_integer_t>(-1) - number);
				}

				case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)
				{
					uint32_t number;
					return get_number(number) and sax->number_integer(static_cast<number_integer_t>(-1) - number);
				}

				case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)
				{
					uint64_t number;
					return get_number(number) and sax->number_integer(static_cast<number_integer_t>(-1)
						- static_cast<number_integer_t>(number));
				}

				// UTF-8 string (0x00..0x17 bytes follow)
				case 0x60:
				case 0x61:
				case 0x62:
				case 0x63:
				case 0x64:
				case 0x65:
				case 0x66:
				case 0x67:
				case 0x68:
				case 0x69:
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:
				case 0x6E:
				case 0x6F:
				case 0x70:
				case 0x71:
				case 0x72:
				case 0x73:
				case 0x74:
				case 0x75:
				case 0x76:
				case 0x77:
				case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
				case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
				case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
				case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
				case 0x7F: // UTF-8 string (indefinite length)
				{
					string_t s;
					return get_cbor_string(s) and sax->string(s);
				}

				// array (0x00..0x17 data items follow)
				case 0x80:
				case 0x81:
				case 0x82:
				case 0x83:
				case 0x84:
				case 0x85:
				case 0x86:
				case 0x87:
				case 0x88:
				case 0x89:
				case 0x8A:
				case 0x8B:
				case 0x8C:
				case 0x8D:
				case 0x8E:
				case 0x8F:
				case 0x90:
				case 0x91:
				case 0x92:
				case 0x93:
				case 0x94:
				case 0x95:
				case 0x96:
				case 0x97:
					return get_cbor_array(static_cast<std::size_t>(current & 0x1F));

				case 0x98: // array (one-byte uint8_t for n follows)
				{
					uint8_t len;
					return get_number(len) and get_cbor_array(static_cast<std::size_t>(len));
				}

				case 0x99: // array (two-byte uint16_t for n follow)
				{
					uint16_t len;
					return get_number(len) and get_cbor_array(static_cast<std::size_t>(len));
				}

				case 0x9A: // array (four-byte uint32_t for n follow)
				{
					uint32_t len;
					return get_number(len) and get_cbor_array(static_cast<std::size_t>(len));
				}

				case 0x9B: // array (eight-byte uint64_t for n follow)
				{
					uint64_t len;
					return get_number(len) and get_cbor_array(static_cast<std::size_t>(len));
				}

				case 0x9F: // array (indefinite length)
					return get_cbor_array(std::size_t(-1));

					// map (0x00..0x17 pairs of data items follow)
				case 0xA0:
				case 0xA1:
				case 0xA2:
				case 0xA3:
				case 0xA4:
				case 0xA5:
				case 0xA6:
				case 0xA7:
				case 0xA8:
				case 0xA9:
				case 0xAA:
				case 0xAB:
				case 0xAC:
				case 0xAD:
				case 0xAE:
				case 0xAF:
				case 0xB0:
				case 0xB1:
				case 0xB2:
				case 0xB3:
				case 0xB4:
				case 0xB5:
				case 0xB6:
				case 0xB7:
					return get_cbor_object(static_cast<std::size_t>(current & 0x1F));

				case 0xB8: // map (one-byte uint8_t for n follows)
				{
					uint8_t len;
					return get_number(len) and get_cbor_object(static_cast<std::size_t>(len));
				}

				case 0xB9: // map (two-byte uint16_t for n follow)
				{
					uint16_t len;
					return get_number(len) and get_cbor_object(static_cast<std::size_t>(len));
				}

				case 0xBA: // map (four-byte uint32_t for n follow)
				{
					uint32_t len;
					return get_number(len) and get_cbor_object(static_cast<std::size_t>(len));
				}

				case 0xBB: // map (eight-byte uint64_t for n follow)
				{
					uint64_t len;
					return get_number(len) and get_cbor_object(static_cast<std::size_t>(len));
				}

				case 0xBF: // map (indefinite length)
					return get_cbor_object(std::size_t(-1));

				case 0xF4: // false
					return sax->boolean(false);

				case 0xF5: // true
					return sax->boolean(true);

				case 0xF6: // null
					return sax->null();

				case 0xF9: // Half-Precision Float (two-byte IEEE 754)
				{
					const int byte1 = get();
					if (JSON_UNLIKELY(not unexpect_eof()))
					{
						return false;
					}
					const int byte2 = get();
					if (JSON_UNLIKELY(not unexpect_eof()))
					{
						return false;
					}

					// code from RFC 7049, Appendix D, Figure 3:
					// As half-precision floating-point numbers were only added
					// to IEEE 754 in 2008, today's programming platforms often
					// still only have limited support for them. It is very
					// easy to include at least decoding support for them even
					// without such support. An example of a small decoder for
					// half-precision floating-point numbers in the C language
					// is shown in Fig. 3.
					const int half = (byte1 << 8) + byte2;
					const double val = [&half]
					{
						const int exp = (half >> 10) & 0x1F;
						const int mant = half & 0x3FF;
						assert(0 <= exp and exp <= 32);
						assert(0 <= mant and mant <= 1024);
						switch (exp)
						{
						case 0:
							return std::ldexp(mant, -24);
						case 31:
							return (mant == 0)
								? std::numeric_limits<double>::infinity()
								: std::numeric_limits<double>::quiet_NaN();
						default:
							return std::ldexp(mant + 1024, exp - 25);
						}
					}();
					return sax->number_float((half & 0x8000) != 0
						? static_cast<number_float_t>(-val)
						: static_cast<number_float_t>(val), "");
				}

				case 0xFA: // Single-Precision Float (four-byte IEEE 754)
				{
					float number;
					return get_number(number) and sax->number_float(static_cast<number_float_t>(number), "");
				}

				case 0xFB: // Double-Precision Float (eight-byte IEEE 754)
				{
					double number;
					return get_number(number) and sax->number_float(static_cast<number_float_t>(number), "");
				}

				default: // anything else (0xFF is handled inside the other types)
				{
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, "error reading CBOR; last byte: 0x" + last_token));
				}
				}
			}

			/*!
			@return whether a valid MessagePack value was passed to the SAX parser
			*/
			bool parse_msgpack_internal()
			{
				switch (get())
				{
					// EOF
				case std::char_traits<char>::eof():
					return unexpect_eof();

					// positive fixint
				case 0x00:
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x04:
				case 0x05:
				case 0x06:
				case 0x07:
				case 0x08:
				case 0x09:
				case 0x0A:
				case 0x0B:
				case 0x0C:
				case 0x0D:
				case 0x0E:
				case 0x0F:
				case 0x10:
				case 0x11:
				case 0x12:
				case 0x13:
				case 0x14:
				case 0x15:
				case 0x16:
				case 0x17:
				case 0x18:
				case 0x19:
				case 0x1A:
				case 0x1B:
				case 0x1C:
				case 0x1D:
				case 0x1E:
				case 0x1F:
				case 0x20:
				case 0x21:
				case 0x22:
				case 0x23:
				case 0x24:
				case 0x25:
				case 0x26:
				case 0x27:
				case 0x28:
				case 0x29:
				case 0x2A:
				case 0x2B:
				case 0x2C:
				case 0x2D:
				case 0x2E:
				case 0x2F:
				case 0x30:
				case 0x31:
				case 0x32:
				case 0x33:
				case 0x34:
				case 0x35:
				case 0x36:
				case 0x37:
				case 0x38:
				case 0x39:
				case 0x3A:
				case 0x3B:
				case 0x3C:
				case 0x3D:
				case 0x3E:
				case 0x3F:
				case 0x40:
				case 0x41:
				case 0x42:
				case 0x43:
				case 0x44:
				case 0x45:
				case 0x46:
				case 0x47:
				case 0x48:
				case 0x49:
				case 0x4A:
				case 0x4B:
				case 0x4C:
				case 0x4D:
				case 0x4E:
				case 0x4F:
				case 0x50:
				case 0x51:
				case 0x52:
				case 0x53:
				case 0x54:
				case 0x55:
				case 0x56:
				case 0x57:
				case 0x58:
				case 0x59:
				case 0x5A:
				case 0x5B:
				case 0x5C:
				case 0x5D:
				case 0x5E:
				case 0x5F:
				case 0x60:
				case 0x61:
				case 0x62:
				case 0x63:
				case 0x64:
				case 0x65:
				case 0x66:
				case 0x67:
				case 0x68:
				case 0x69:
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:
				case 0x6E:
				case 0x6F:
				case 0x70:
				case 0x71:
				case 0x72:
				case 0x73:
				case 0x74:
				case 0x75:
				case 0x76:
				case 0x77:
				case 0x78:
				case 0x79:
				case 0x7A:
				case 0x7B:
				case 0x7C:
				case 0x7D:
				case 0x7E:
				case 0x7F:
					return sax->number_unsigned(static_cast<number_unsigned_t>(current));

					// fixmap
				case 0x80:
				case 0x81:
				case 0x82:
				case 0x83:
				case 0x84:
				case 0x85:
				case 0x86:
				case 0x87:
				case 0x88:
				case 0x89:
				case 0x8A:
				case 0x8B:
				case 0x8C:
				case 0x8D:
				case 0x8E:
				case 0x8F:
					return get_msgpack_object(static_cast<std::size_t>(current & 0x0F));

					// fixarray
				case 0x90:
				case 0x91:
				case 0x92:
				case 0x93:
				case 0x94:
				case 0x95:
				case 0x96:
				case 0x97:
				case 0x98:
				case 0x99:
				case 0x9A:
				case 0x9B:
				case 0x9C:
				case 0x9D:
				case 0x9E:
				case 0x9F:
					return get_msgpack_array(static_cast<std::size_t>(current & 0x0F));

					// fixstr
				case 0xA0:
				case 0xA1:
				case 0xA2:
				case 0xA3:
				case 0xA4:
				case 0xA5:
				case 0xA6:
				case 0xA7:
				case 0xA8:
				case 0xA9:
				case 0xAA:
				case 0xAB:
				case 0xAC:
				case 0xAD:
				case 0xAE:
				case 0xAF:
				case 0xB0:
				case 0xB1:
				case 0xB2:
				case 0xB3:
				case 0xB4:
				case 0xB5:
				case 0xB6:
				case 0xB7:
				case 0xB8:
				case 0xB9:
				case 0xBA:
				case 0xBB:
				case 0xBC:
				case 0xBD:
				case 0xBE:
				case 0xBF:
				{
					string_t s;
					return get_msgpack_string(s) and sax->string(s);
				}

				case 0xC0: // nil
					return sax->null();

				case 0xC2: // false
					return sax->boolean(false);

				case 0xC3: // true
					return sax->boolean(true);

				case 0xCA: // float 32
				{
					float number;
					return get_number(number) and sax->number_float(static_cast<number_float_t>(number), "");
				}

				case 0xCB: // float 64
				{
					double number;
					return get_number(number) and sax->number_float(static_cast<number_float_t>(number), "");
				}

				case 0xCC: // uint 8
				{
					uint8_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0xCD: // uint 16
				{
					uint16_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0xCE: // uint 32
				{
					uint32_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0xCF: // uint 64
				{
					uint64_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 0xD0: // int 8
				{
					int8_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 0xD1: // int 16
				{
					int16_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 0xD2: // int 32
				{
					int32_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 0xD3: // int 64
				{
					int64_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 0xD9: // str 8
				case 0xDA: // str 16
				case 0xDB: // str 32
				{
					string_t s;
					return get_msgpack_string(s) and sax->string(s);
				}

				case 0xDC: // array 16
				{
					uint16_t len;
					return get_number(len) and get_msgpack_array(static_cast<std::size_t>(len));
				}

				case 0xDD: // array 32
				{
					uint32_t len;
					return get_number(len) and get_msgpack_array(static_cast<std::size_t>(len));
				}

				case 0xDE: // map 16
				{
					uint16_t len;
					return get_number(len) and get_msgpack_object(static_cast<std::size_t>(len));
				}

				case 0xDF: // map 32
				{
					uint32_t len;
					return get_number(len) and get_msgpack_object(static_cast<std::size_t>(len));
				}

				// negative fixint
				case 0xE0:
				case 0xE1:
				case 0xE2:
				case 0xE3:
				case 0xE4:
				case 0xE5:
				case 0xE6:
				case 0xE7:
				case 0xE8:
				case 0xE9:
				case 0xEA:
				case 0xEB:
				case 0xEC:
				case 0xED:
				case 0xEE:
				case 0xEF:
				case 0xF0:
				case 0xF1:
				case 0xF2:
				case 0xF3:
				case 0xF4:
				case 0xF5:
				case 0xF6:
				case 0xF7:
				case 0xF8:
				case 0xF9:
				case 0xFA:
				case 0xFB:
				case 0xFC:
				case 0xFD:
				case 0xFE:
				case 0xFF:
					return sax->number_integer(static_cast<int8_t>(current));

				default: // anything else
				{
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, "error reading MessagePack; last byte: 0x" + last_token));
				}
				}
			}

			/*!
			@param[in] get_char  whether a new character should be retrieved from the
								 input (true, default) or whether the last read
								 character should be considered instead

			@return whether a valid UBJSON value was passed to the SAX parser
			*/
			bool parse_ubjson_internal(const bool get_char = true)
			{
				return get_ubjson_value(get_char ? get_ignore_noop() : current);
			}

			/*!
			@brief get next character from the input

			This function provides the interface to the used input adapter. It does
			not throw in case the input reached EOF, but returns a -'ve valued
			`std::char_traits<char>::eof()` in that case.

			@return character read from the input
			*/
			int get()
			{
				++chars_read;
				return (current = ia->get_character());
			}

			/*!
			@return character read from the input after ignoring all 'N' entries
			*/
			int get_ignore_noop()
			{
				do
				{
					get();
				} while (current == 'N');

				return current;
			}

			/*
			@brief read a number from the input

			@tparam NumberType the type of the number
			@param[out] result  number of type @a NumberType

			@return whether conversion completed

			@note This function needs to respect the system's endianess, because
				  bytes in CBOR, MessagePack, and UBJSON are stored in network order
				  (big endian) and therefore need reordering on little endian systems.
			*/
			template<typename NumberType>
			bool get_number(NumberType& result)
			{
				// step 1: read input into array with system's byte order
				std::array<uint8_t, sizeof(NumberType)> vec;
				for (std::size_t i = 0; i < sizeof(NumberType); ++i)
				{
					get();
					if (JSON_UNLIKELY(not unexpect_eof()))
					{
						return false;
					}

					// reverse byte order prior to conversion if necessary
					if (is_little_endian)
					{
						vec[sizeof(NumberType) - i - 1] = static_cast<uint8_t>(current);
					}
					else
					{
						vec[i] = static_cast<uint8_t>(current); // LCOV_EXCL_LINE
					}
				}

				// step 2: convert array into number of type T and return
				std::memcpy(&result, vec.data(), sizeof(NumberType));
				return true;
			}

			/*!
			@brief create a string by reading characters from the input

			@tparam NumberType the type of the number
			@param[in] len number of characters to read
			@param[out] string created by reading @a len bytes

			@return whether string creation completed

			@note We can not reserve @a len bytes for the result, because @a len
				  may be too large. Usually, @ref unexpect_eof() detects the end of
				  the input before we run out of string memory.
			*/
			template<typename NumberType>
			bool get_string(const NumberType len, string_t& result)
			{
				bool success = true;
				std::generate_n(std::back_inserter(result), len, [this, &success]()
				{
					get();
					if (JSON_UNLIKELY(not unexpect_eof()))
					{
						success = false;
					}
					return static_cast<char>(current);
				});
				return success;
			}

			/*!
			@brief reads a CBOR string

			This function first reads starting bytes to determine the expected
			string length and then copies this number of bytes into a string.
			Additionally, CBOR's strings with indefinite lengths are supported.

			@param[out] result  created string

			@return whether string creation completed
			*/
			bool get_cbor_string(string_t& result)
			{
				if (JSON_UNLIKELY(not unexpect_eof()))
				{
					return false;
				}

				switch (current)
				{
					// UTF-8 string (0x00..0x17 bytes follow)
				case 0x60:
				case 0x61:
				case 0x62:
				case 0x63:
				case 0x64:
				case 0x65:
				case 0x66:
				case 0x67:
				case 0x68:
				case 0x69:
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:
				case 0x6E:
				case 0x6F:
				case 0x70:
				case 0x71:
				case 0x72:
				case 0x73:
				case 0x74:
				case 0x75:
				case 0x76:
				case 0x77:
				{
					return get_string(current & 0x1F, result);
				}

				case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
				{
					uint8_t len;
					return get_number(len) and get_string(len, result);
				}

				case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
				{
					uint16_t len;
					return get_number(len) and get_string(len, result);
				}

				case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
				{
					uint32_t len;
					return get_number(len) and get_string(len, result);
				}

				case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
				{
					uint64_t len;
					return get_number(len) and get_string(len, result);
				}

				case 0x7F: // UTF-8 string (indefinite length)
				{
					while (get() != 0xFF)
					{
						string_t chunk;
						if (not get_cbor_string(chunk))
						{
							return false;
						}
						result.append(chunk);
					}
					return true;
				}

				default:
				{
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, "expected a CBOR string; last byte: 0x" + last_token));
				}
				}
			}

			/*!
			@param[in] len  the length of the array or std::size_t(-1) for an
							array of indefinite size
			@return whether array creation completed
			*/
			bool get_cbor_array(const std::size_t len)
			{
				if (JSON_UNLIKELY(not sax->start_array(len)))
				{
					return false;
				}

				if (len != std::size_t(-1))
					for (std::size_t i = 0; i < len; ++i)
					{
						if (JSON_UNLIKELY(not parse_cbor_internal()))
						{
							return false;
						}
					}
				else
				{
					while (get() != 0xFF)
					{
						if (JSON_UNLIKELY(not parse_cbor_internal(false)))
						{
							return false;
						}
					}
				}

				return sax->end_array();
			}

			/*!
			@param[in] len  the length of the object or std::size_t(-1) for an
							object of indefinite size
			@return whether object creation completed
			*/
			bool get_cbor_object(const std::size_t len)
			{
				if (not JSON_UNLIKELY(sax->start_object(len)))
				{
					return false;
				}

				string_t key;
				if (len != std::size_t(-1))
				{
					for (std::size_t i = 0; i < len; ++i)
					{
						get();
						if (JSON_UNLIKELY(not get_cbor_string(key) or not sax->key(key)))
						{
							return false;
						}

						if (JSON_UNLIKELY(not parse_cbor_internal()))
						{
							return false;
						}
						key.clear();
					}
				}
				else
				{
					while (get() != 0xFF)
					{
						if (JSON_UNLIKELY(not get_cbor_string(key) or not sax->key(key)))
						{
							return false;
						}

						if (JSON_UNLIKELY(not parse_cbor_internal()))
						{
							return false;
						}
						key.clear();
					}
				}

				return sax->end_object();
			}

			/*!
			@brief reads a MessagePack string

			This function first reads starting bytes to determine the expected
			string length and then copies this number of bytes into a string.

			@param[out] result  created string

			@return whether string creation completed
			*/
			bool get_msgpack_string(string_t& result)
			{
				if (JSON_UNLIKELY(not unexpect_eof()))
				{
					return false;
				}

				switch (current)
				{
					// fixstr
				case 0xA0:
				case 0xA1:
				case 0xA2:
				case 0xA3:
				case 0xA4:
				case 0xA5:
				case 0xA6:
				case 0xA7:
				case 0xA8:
				case 0xA9:
				case 0xAA:
				case 0xAB:
				case 0xAC:
				case 0xAD:
				case 0xAE:
				case 0xAF:
				case 0xB0:
				case 0xB1:
				case 0xB2:
				case 0xB3:
				case 0xB4:
				case 0xB5:
				case 0xB6:
				case 0xB7:
				case 0xB8:
				case 0xB9:
				case 0xBA:
				case 0xBB:
				case 0xBC:
				case 0xBD:
				case 0xBE:
				case 0xBF:
				{
					return get_string(current & 0x1F, result);
				}

				case 0xD9: // str 8
				{
					uint8_t len;
					return get_number(len) and get_string(len, result);
				}

				case 0xDA: // str 16
				{
					uint16_t len;
					return get_number(len) and get_string(len, result);
				}

				case 0xDB: // str 32
				{
					uint32_t len;
					return get_number(len) and get_string(len, result);
				}

				default:
				{
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, "expected a MessagePack string; last byte: 0x" + last_token));
				}
				}
			}

			/*!
			@param[in] len  the length of the array
			@return whether array creation completed
			*/
			bool get_msgpack_array(const std::size_t len)
			{
				if (JSON_UNLIKELY(not sax->start_array(len)))
				{
					return false;
				}

				for (std::size_t i = 0; i < len; ++i)
				{
					if (JSON_UNLIKELY(not parse_msgpack_internal()))
					{
						return false;
					}
				}

				return sax->end_array();
			}

			/*!
			@param[in] len  the length of the object
			@return whether object creation completed
			*/
			bool get_msgpack_object(const std::size_t len)
			{
				if (JSON_UNLIKELY(not sax->start_object(len)))
				{
					return false;
				}

				string_t key;
				for (std::size_t i = 0; i < len; ++i)
				{
					get();
					if (JSON_UNLIKELY(not get_msgpack_string(key) or not sax->key(key)))
					{
						return false;
					}

					if (JSON_UNLIKELY(not parse_msgpack_internal()))
					{
						return false;
					}
					key.clear();
				}

				return sax->end_object();
			}

			/*!
			@brief reads a UBJSON string

			This function is either called after reading the 'S' byte explicitly
			indicating a string, or in case of an object key where the 'S' byte can be
			left out.

			@param[out] result   created string
			@param[in] get_char  whether a new character should be retrieved from the
								 input (true, default) or whether the last read
								 character should be considered instead

			@return whether string creation completed
			*/
			bool get_ubjson_string(string_t& result, const bool get_char = true)
			{
				if (get_char)
				{
					get();  // TODO: may we ignore N here?
				}

				if (JSON_UNLIKELY(not unexpect_eof()))
				{
					return false;
				}

				switch (current)
				{
				case 'U':
				{
					uint8_t len;
					return get_number(len) and get_string(len, result);
				}

				case 'i':
				{
					int8_t len;
					return get_number(len) and get_string(len, result);
				}

				case 'I':
				{
					int16_t len;
					return get_number(len) and get_string(len, result);
				}

				case 'l':
				{
					int32_t len;
					return get_number(len) and get_string(len, result);
				}

				case 'L':
				{
					int64_t len;
					return get_number(len) and get_string(len, result);
				}

				default:
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, "expected a UBJSON string; last byte: 0x" + last_token));
				}
			}

			/*!
			@param[out] result  determined size
			@return whether size determination completed
			*/
			bool get_ubjson_size_value(std::size_t& result)
			{
				switch (get_ignore_noop())
				{
				case 'U':
				{
					uint8_t number;
					if (JSON_UNLIKELY(not get_number(number)))
					{
						return false;
					}
					result = static_cast<std::size_t>(number);
					return true;
				}

				case 'i':
				{
					int8_t number;
					if (JSON_UNLIKELY(not get_number(number)))
					{
						return false;
					}
					result = static_cast<std::size_t>(number);
					return true;
				}

				case 'I':
				{
					int16_t number;
					if (JSON_UNLIKELY(not get_number(number)))
					{
						return false;
					}
					result = static_cast<std::size_t>(number);
					return true;
				}

				case 'l':
				{
					int32_t number;
					if (JSON_UNLIKELY(not get_number(number)))
					{
						return false;
					}
					result = static_cast<std::size_t>(number);
					return true;
				}

				case 'L':
				{
					int64_t number;
					if (JSON_UNLIKELY(not get_number(number)))
					{
						return false;
					}
					result = static_cast<std::size_t>(number);
					return true;
				}

				default:
				{
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, "byte after '#' must denote a number type; last byte: 0x" + last_token));
				}
				}
			}

			/*!
			@brief determine the type and size for a container

			In the optimized UBJSON format, a type and a size can be provided to allow
			for a more compact representation.

			@param[out] result  pair of the size and the type

			@return whether pair creation completed
			*/
			bool get_ubjson_size_type(std::pair<std::size_t, int>& result)
			{
				result.first = string_t::npos; // size
				result.second = 0; // type

				get_ignore_noop();

				if (current == '$')
				{
					result.second = get();  // must not ignore 'N', because 'N' maybe the type
					if (JSON_UNLIKELY(not unexpect_eof()))
					{
						return false;
					}

					get_ignore_noop();
					if (JSON_UNLIKELY(current != '#'))
					{
						if (JSON_UNLIKELY(not unexpect_eof()))
						{
							return false;
						}
						auto last_token = get_token_string();
						return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, "expected '#' after UBJSON type information; last byte: 0x" + last_token));
					}

					return get_ubjson_size_value(result.first);
				}
				else if (current == '#')
				{
					return get_ubjson_size_value(result.first);
				}
				return true;
			}

			/*!
			@param prefix  the previously read or set type prefix
			@return whether value creation completed
			*/
			bool get_ubjson_value(const int prefix)
			{
				switch (prefix)
				{
				case std::char_traits<char>::eof():  // EOF
					return unexpect_eof();

				case 'T':  // true
					return sax->boolean(true);
				case 'F':  // false
					return sax->boolean(false);

				case 'Z':  // null
					return sax->null();

				case 'U':
				{
					uint8_t number;
					return get_number(number) and sax->number_unsigned(number);
				}

				case 'i':
				{
					int8_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 'I':
				{
					int16_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 'l':
				{
					int32_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 'L':
				{
					int64_t number;
					return get_number(number) and sax->number_integer(number);
				}

				case 'd':
				{
					float number;
					return get_number(number) and sax->number_float(static_cast<number_float_t>(number), "");
				}

				case 'D':
				{
					double number;
					return get_number(number) and sax->number_float(static_cast<number_float_t>(number), "");
				}

				case 'C':  // char
				{
					get();
					if (JSON_UNLIKELY(not unexpect_eof()))
					{
						return false;
					}
					if (JSON_UNLIKELY(current > 127))
					{
						auto last_token = get_token_string();
						return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, "byte after 'C' must be in range 0x00..0x7F; last byte: 0x" + last_token));
					}
					string_t s(1, static_cast<char>(current));
					return sax->string(s);
				}

				case 'S':  // string
				{
					string_t s;
					return get_ubjson_string(s) and sax->string(s);
				}

				case '[':  // array
					return get_ubjson_array();

				case '{':  // object
					return get_ubjson_object();

				default: // anything else
				{
					auto last_token = get_token_string();
					return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, "error reading UBJSON; last byte: 0x" + last_token));
				}
				}
			}

			/*!
			@return whether array creation completed
			*/
			bool get_ubjson_array()
			{
				std::pair<std::size_t, int> size_and_type;
				if (JSON_UNLIKELY(not get_ubjson_size_type(size_and_type)))
				{
					return false;
				}

				if (size_and_type.first != string_t::npos)
				{
					if (JSON_UNLIKELY(not sax->start_array(size_and_type.first)))
					{
						return false;
					}

					if (size_and_type.second != 0)
					{
						if (size_and_type.second != 'N')
						{
							for (std::size_t i = 0; i < size_and_type.first; ++i)
							{
								if (JSON_UNLIKELY(not get_ubjson_value(size_and_type.second)))
								{
									return false;
								}
							}
						}
					}
					else
					{
						for (std::size_t i = 0; i < size_and_type.first; ++i)
						{
							if (JSON_UNLIKELY(not parse_ubjson_internal()))
							{
								return false;
							}
						}
					}
				}
				else
				{
					if (JSON_UNLIKELY(not sax->start_array(std::size_t(-1))))
					{
						return false;
					}

					while (current != ']')
					{
						if (JSON_UNLIKELY(not parse_ubjson_internal(false)))
						{
							return false;
						}
						get_ignore_noop();
					}
				}

				return sax->end_array();
			}

			/*!
			@return whether object creation completed
			*/
			bool get_ubjson_object()
			{
				std::pair<std::size_t, int> size_and_type;
				if (JSON_UNLIKELY(not get_ubjson_size_type(size_and_type)))
				{
					return false;
				}

				string_t key;
				if (size_and_type.first != string_t::npos)
				{
					if (JSON_UNLIKELY(not sax->start_object(size_and_type.first)))
					{
						return false;
					}

					if (size_and_type.second != 0)
					{
						for (std::size_t i = 0; i < size_and_type.first; ++i)
						{
							if (JSON_UNLIKELY(not get_ubjson_string(key) or not sax->key(key)))
							{
								return false;
							}
							if (JSON_UNLIKELY(not get_ubjson_value(size_and_type.second)))
							{
								return false;
							}
							key.clear();
						}
					}
					else
					{
						for (std::size_t i = 0; i < size_and_type.first; ++i)
						{
							if (JSON_UNLIKELY(not get_ubjson_string(key) or not sax->key(key)))
							{
								return false;
							}
							if (JSON_UNLIKELY(not parse_ubjson_internal()))
							{
								return false;
							}
							key.clear();
						}
					}
				}
				else
				{
					if (JSON_UNLIKELY(not sax->start_object(std::size_t(-1))))
					{
						return false;
					}

					while (current != '}')
					{
						if (JSON_UNLIKELY(not get_ubjson_string(key, false) or not sax->key(key)))
						{
							return false;
						}
						if (JSON_UNLIKELY(not parse_ubjson_internal()))
						{
							return false;
						}
						get_ignore_noop();
						key.clear();
					}
				}

				return sax->end_object();
			}

			/*!
			@return whether the last read character is not EOF
			*/
			bool unexpect_eof() const
			{
				if (JSON_UNLIKELY(current == std::char_traits<char>::eof()))
				{
					return sax->parse_error(chars_read, "<end of file>", parse_error::create(110, chars_read, "unexpected end of input"));
				}
				return true;
			}

			/*!
			@return a string representation of the last read byte
			*/
			std::string get_token_string() const
			{
				char cr[3];
				snprintf(cr, 3, "%.2hhX", static_cast<unsigned char>(current));
				return std::string{ cr };
			}

		private:
			/// input adapter
			input_adapter_t ia = nullptr;

			/// the current character
			int current = std::char_traits<char>::eof();

			/// the number of characters read
			std::size_t chars_read = 0;

			/// whether we can assume little endianess
			const bool is_little_endian = little_endianess();

			/// the SAX parser
			json_sax_t* sax = nullptr;
		};
	}
}

// #include <nlohmann/detail/output/binary_writer.hpp>


#include <algorithm> // reverse
#include <array> // array
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstring> // memcpy
#include <limits> // numeric_limits

// #include <nlohmann/detail/input/binary_reader.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>


namespace nlohmann
{
	namespace detail
	{
		///////////////////
		// binary writer //
		///////////////////

		/*!
		@brief serialization to CBOR and MessagePack values
		*/
		template<typename BasicJsonType, typename CharType>
		class binary_writer
		{
		public:
			/*!
			@brief create a binary writer

			@param[in] adapter  output adapter to write to
			*/
			explicit binary_writer(output_adapter_t<CharType> adapter) : oa(adapter)
			{
				assert(oa);
			}

			/*!
			@brief[in] j  JSON value to serialize
			*/
			void write_cbor(const BasicJsonType& j)
			{
				switch (j.type())
				{
				case value_t::null:
				{
					oa->write_character(static_cast<CharType>(0xF6));
					break;
				}

				case value_t::boolean:
				{
					oa->write_character(j.m_value.boolean
						? static_cast<CharType>(0xF5)
						: static_cast<CharType>(0xF4));
					break;
				}

				case value_t::number_integer:
				{
					if (j.m_value.number_integer >= 0)
					{
						// CBOR does not differentiate between positive signed
						// integers and unsigned integers. Therefore, we used the
						// code from the value_t::number_unsigned case here.
						if (j.m_value.number_integer <= 0x17)
						{
							write_number(static_cast<uint8_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer <= (std::numeric_limits<uint8_t>::max)())
						{
							oa->write_character(static_cast<CharType>(0x18));
							write_number(static_cast<uint8_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer <= (std::numeric_limits<uint16_t>::max)())
						{
							oa->write_character(static_cast<CharType>(0x19));
							write_number(static_cast<uint16_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer <= (std::numeric_limits<uint32_t>::max)())
						{
							oa->write_character(static_cast<CharType>(0x1A));
							write_number(static_cast<uint32_t>(j.m_value.number_integer));
						}
						else
						{
							oa->write_character(static_cast<CharType>(0x1B));
							write_number(static_cast<uint64_t>(j.m_value.number_integer));
						}
					}
					else
					{
						// The conversions below encode the sign in the first
						// byte, and the value is converted to a positive number.
						const auto positive_number = -1 - j.m_value.number_integer;
						if (j.m_value.number_integer >= -24)
						{
							write_number(static_cast<uint8_t>(0x20 + positive_number));
						}
						else if (positive_number <= (std::numeric_limits<uint8_t>::max)())
						{
							oa->write_character(static_cast<CharType>(0x38));
							write_number(static_cast<uint8_t>(positive_number));
						}
						else if (positive_number <= (std::numeric_limits<uint16_t>::max)())
						{
							oa->write_character(static_cast<CharType>(0x39));
							write_number(static_cast<uint16_t>(positive_number));
						}
						else if (positive_number <= (std::numeric_limits<uint32_t>::max)())
						{
							oa->write_character(static_cast<CharType>(0x3A));
							write_number(static_cast<uint32_t>(positive_number));
						}
						else
						{
							oa->write_character(static_cast<CharType>(0x3B));
							write_number(static_cast<uint64_t>(positive_number));
						}
					}
					break;
				}

				case value_t::number_unsigned:
				{
					if (j.m_value.number_unsigned <= 0x17)
					{
						write_number(static_cast<uint8_t>(j.m_value.number_unsigned));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint8_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x18));
						write_number(static_cast<uint8_t>(j.m_value.number_unsigned));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint16_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x19));
						write_number(static_cast<uint16_t>(j.m_value.number_unsigned));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint32_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x1A));
						write_number(static_cast<uint32_t>(j.m_value.number_unsigned));
					}
					else
					{
						oa->write_character(static_cast<CharType>(0x1B));
						write_number(static_cast<uint64_t>(j.m_value.number_unsigned));
					}
					break;
				}

				case value_t::number_float:
				{
					oa->write_character(get_cbor_float_prefix(j.m_value.number_float));
					write_number(j.m_value.number_float);
					break;
				}

				case value_t::string:
				{
					// step 1: write control byte and the string length
					const auto N = j.m_value.string->size();
					if (N <= 0x17)
					{
						write_number(static_cast<uint8_t>(0x60 + N));
					}
					else if (N <= (std::numeric_limits<uint8_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x78));
						write_number(static_cast<uint8_t>(N));
					}
					else if (N <= (std::numeric_limits<uint16_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x79));
						write_number(static_cast<uint16_t>(N));
					}
					else if (N <= (std::numeric_limits<uint32_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x7A));
						write_number(static_cast<uint32_t>(N));
					}
					// LCOV_EXCL_START
					else if (N <= (std::numeric_limits<uint64_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x7B));
						write_number(static_cast<uint64_t>(N));
					}
					// LCOV_EXCL_STOP

					// step 2: write the string
					oa->write_characters(
						reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
						j.m_value.string->size());
					break;
				}

				case value_t::array:
				{
					// step 1: write control byte and the array size
					const auto N = j.m_value.array->size();
					if (N <= 0x17)
					{
						write_number(static_cast<uint8_t>(0x80 + N));
					}
					else if (N <= (std::numeric_limits<uint8_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x98));
						write_number(static_cast<uint8_t>(N));
					}
					else if (N <= (std::numeric_limits<uint16_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x99));
						write_number(static_cast<uint16_t>(N));
					}
					else if (N <= (std::numeric_limits<uint32_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x9A));
						write_number(static_cast<uint32_t>(N));
					}
					// LCOV_EXCL_START
					else if (N <= (std::numeric_limits<uint64_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0x9B));
						write_number(static_cast<uint64_t>(N));
					}
					// LCOV_EXCL_STOP

					// step 2: write each element
					for (const auto& el : *j.m_value.array)
					{
						write_cbor(el);
					}
					break;
				}

				case value_t::object:
				{
					// step 1: write control byte and the object size
					const auto N = j.m_value.object->size();
					if (N <= 0x17)
					{
						write_number(static_cast<uint8_t>(0xA0 + N));
					}
					else if (N <= (std::numeric_limits<uint8_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0xB8));
						write_number(static_cast<uint8_t>(N));
					}
					else if (N <= (std::numeric_limits<uint16_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0xB9));
						write_number(static_cast<uint16_t>(N));
					}
					else if (N <= (std::numeric_limits<uint32_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0xBA));
						write_number(static_cast<uint32_t>(N));
					}
					// LCOV_EXCL_START
					else if (N <= (std::numeric_limits<uint64_t>::max)())
					{
						oa->write_character(static_cast<CharType>(0xBB));
						write_number(static_cast<uint64_t>(N));
					}
					// LCOV_EXCL_STOP

					// step 2: write each element
					for (const auto& el : *j.m_value.object)
					{
						write_cbor(el.first);
						write_cbor(el.second);
					}
					break;
				}

				default:
					break;
				}
			}

			/*!
			@brief[in] j  JSON value to serialize
			*/
			void write_msgpack(const BasicJsonType& j)
			{
				switch (j.type())
				{
				case value_t::null: // nil
				{
					oa->write_character(static_cast<CharType>(0xC0));
					break;
				}

				case value_t::boolean: // true and false
				{
					oa->write_character(j.m_value.boolean
						? static_cast<CharType>(0xC3)
						: static_cast<CharType>(0xC2));
					break;
				}

				case value_t::number_integer:
				{
					if (j.m_value.number_integer >= 0)
					{
						// MessagePack does not differentiate between positive
						// signed integers and unsigned integers. Therefore, we used
						// the code from the value_t::number_unsigned case here.
						if (j.m_value.number_unsigned < 128)
						{
							// positive fixnum
							write_number(static_cast<uint8_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_unsigned <= (std::numeric_limits<uint8_t>::max)())
						{
							// uint 8
							oa->write_character(static_cast<CharType>(0xCC));
							write_number(static_cast<uint8_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_unsigned <= (std::numeric_limits<uint16_t>::max)())
						{
							// uint 16
							oa->write_character(static_cast<CharType>(0xCD));
							write_number(static_cast<uint16_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_unsigned <= (std::numeric_limits<uint32_t>::max)())
						{
							// uint 32
							oa->write_character(static_cast<CharType>(0xCE));
							write_number(static_cast<uint32_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_unsigned <= (std::numeric_limits<uint64_t>::max)())
						{
							// uint 64
							oa->write_character(static_cast<CharType>(0xCF));
							write_number(static_cast<uint64_t>(j.m_value.number_integer));
						}
					}
					else
					{
						if (j.m_value.number_integer >= -32)
						{
							// negative fixnum
							write_number(static_cast<int8_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer >= (std::numeric_limits<int8_t>::min)() and
							j.m_value.number_integer <= (std::numeric_limits<int8_t>::max)())
						{
							// int 8
							oa->write_character(static_cast<CharType>(0xD0));
							write_number(static_cast<int8_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer >= (std::numeric_limits<int16_t>::min)() and
							j.m_value.number_integer <= (std::numeric_limits<int16_t>::max)())
						{
							// int 16
							oa->write_character(static_cast<CharType>(0xD1));
							write_number(static_cast<int16_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer >= (std::numeric_limits<int32_t>::min)() and
							j.m_value.number_integer <= (std::numeric_limits<int32_t>::max)())
						{
							// int 32
							oa->write_character(static_cast<CharType>(0xD2));
							write_number(static_cast<int32_t>(j.m_value.number_integer));
						}
						else if (j.m_value.number_integer >= (std::numeric_limits<int64_t>::min)() and
							j.m_value.number_integer <= (std::numeric_limits<int64_t>::max)())
						{
							// int 64
							oa->write_character(static_cast<CharType>(0xD3));
							write_number(static_cast<int64_t>(j.m_value.number_integer));
						}
					}
					break;
				}

				case value_t::number_unsigned:
				{
					if (j.m_value.number_unsigned < 128)
					{
						// positive fixnum
						write_number(static_cast<uint8_t>(j.m_value.number_integer));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint8_t>::max)())
					{
						// uint 8
						oa->write_character(static_cast<CharType>(0xCC));
						write_number(static_cast<uint8_t>(j.m_value.number_integer));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint16_t>::max)())
					{
						// uint 16
						oa->write_character(static_cast<CharType>(0xCD));
						write_number(static_cast<uint16_t>(j.m_value.number_integer));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint32_t>::max)())
					{
						// uint 32
						oa->write_character(static_cast<CharType>(0xCE));
						write_number(static_cast<uint32_t>(j.m_value.number_integer));
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint64_t>::max)())
					{
						// uint 64
						oa->write_character(static_cast<CharType>(0xCF));
						write_number(static_cast<uint64_t>(j.m_value.number_integer));
					}
					break;
				}

				case value_t::number_float:
				{
					oa->write_character(get_msgpack_float_prefix(j.m_value.number_float));
					write_number(j.m_value.number_float);
					break;
				}

				case value_t::string:
				{
					// step 1: write control byte and the string length
					const auto N = j.m_value.string->size();
					if (N <= 31)
					{
						// fixstr
						write_number(static_cast<uint8_t>(0xA0 | N));
					}
					else if (N <= (std::numeric_limits<uint8_t>::max)())
					{
						// str 8
						oa->write_character(static_cast<CharType>(0xD9));
						write_number(static_cast<uint8_t>(N));
					}
					else if (N <= (std::numeric_limits<uint16_t>::max)())
					{
						// str 16
						oa->write_character(static_cast<CharType>(0xDA));
						write_number(static_cast<uint16_t>(N));
					}
					else if (N <= (std::numeric_limits<uint32_t>::max)())
					{
						// str 32
						oa->write_character(static_cast<CharType>(0xDB));
						write_number(static_cast<uint32_t>(N));
					}

					// step 2: write the string
					oa->write_characters(
						reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
						j.m_value.string->size());
					break;
				}

				case value_t::array:
				{
					// step 1: write control byte and the array size
					const auto N = j.m_value.array->size();
					if (N <= 15)
					{
						// fixarray
						write_number(static_cast<uint8_t>(0x90 | N));
					}
					else if (N <= (std::numeric_limits<uint16_t>::max)())
					{
						// array 16
						oa->write_character(static_cast<CharType>(0xDC));
						write_number(static_cast<uint16_t>(N));
					}
					else if (N <= (std::numeric_limits<uint32_t>::max)())
					{
						// array 32
						oa->write_character(static_cast<CharType>(0xDD));
						write_number(static_cast<uint32_t>(N));
					}

					// step 2: write each element
					for (const auto& el : *j.m_value.array)
					{
						write_msgpack(el);
					}
					break;
				}

				case value_t::object:
				{
					// step 1: write control byte and the object size
					const auto N = j.m_value.object->size();
					if (N <= 15)
					{
						// fixmap
						write_number(static_cast<uint8_t>(0x80 | (N & 0xF)));
					}
					else if (N <= (std::numeric_limits<uint16_t>::max)())
					{
						// map 16
						oa->write_character(static_cast<CharType>(0xDE));
						write_number(static_cast<uint16_t>(N));
					}
					else if (N <= (std::numeric_limits<uint32_t>::max)())
					{
						// map 32
						oa->write_character(static_cast<CharType>(0xDF));
						write_number(static_cast<uint32_t>(N));
					}

					// step 2: write each element
					for (const auto& el : *j.m_value.object)
					{
						write_msgpack(el.first);
						write_msgpack(el.second);
					}
					break;
				}

				default:
					break;
				}
			}

			/*!
			@param[in] j  JSON value to serialize
			@param[in] use_count   whether to use '#' prefixes (optimized format)
			@param[in] use_type    whether to use '$' prefixes (optimized format)
			@param[in] add_prefix  whether prefixes need to be used for this value
			*/
			void write_ubjson(const BasicJsonType& j, const bool use_count,
				const bool use_type, const bool add_prefix = true)
			{
				switch (j.type())
				{
				case value_t::null:
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('Z'));
					}
					break;
				}

				case value_t::boolean:
				{
					if (add_prefix)
						oa->write_character(j.m_value.boolean
							? static_cast<CharType>('T')
							: static_cast<CharType>('F'));
					break;
				}

				case value_t::number_integer:
				{
					write_number_with_ubjson_prefix(j.m_value.number_integer, add_prefix);
					break;
				}

				case value_t::number_unsigned:
				{
					write_number_with_ubjson_prefix(j.m_value.number_unsigned, add_prefix);
					break;
				}

				case value_t::number_float:
				{
					write_number_with_ubjson_prefix(j.m_value.number_float, add_prefix);
					break;
				}

				case value_t::string:
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('S'));
					}
					write_number_with_ubjson_prefix(j.m_value.string->size(), true);
					oa->write_characters(
						reinterpret_cast<const CharType*>(j.m_value.string->c_str()),
						j.m_value.string->size());
					break;
				}

				case value_t::array:
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('['));
					}

					bool prefix_required = true;
					if (use_type and not j.m_value.array->empty())
					{
						assert(use_count);
						const CharType first_prefix = ubjson_prefix(j.front());
						const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
							[this, first_prefix](const BasicJsonType & v)
						{
							return ubjson_prefix(v) == first_prefix;
						});

						if (same_prefix)
						{
							prefix_required = false;
							oa->write_character(static_cast<CharType>('$'));
							oa->write_character(first_prefix);
						}
					}

					if (use_count)
					{
						oa->write_character(static_cast<CharType>('#'));
						write_number_with_ubjson_prefix(j.m_value.array->size(), true);
					}

					for (const auto& el : *j.m_value.array)
					{
						write_ubjson(el, use_count, use_type, prefix_required);
					}

					if (not use_count)
					{
						oa->write_character(static_cast<CharType>(']'));
					}

					break;
				}

				case value_t::object:
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('{'));
					}

					bool prefix_required = true;
					if (use_type and not j.m_value.object->empty())
					{
						assert(use_count);
						const CharType first_prefix = ubjson_prefix(j.front());
						const bool same_prefix = std::all_of(j.begin(), j.end(),
							[this, first_prefix](const BasicJsonType & v)
						{
							return ubjson_prefix(v) == first_prefix;
						});

						if (same_prefix)
						{
							prefix_required = false;
							oa->write_character(static_cast<CharType>('$'));
							oa->write_character(first_prefix);
						}
					}

					if (use_count)
					{
						oa->write_character(static_cast<CharType>('#'));
						write_number_with_ubjson_prefix(j.m_value.object->size(), true);
					}

					for (const auto& el : *j.m_value.object)
					{
						write_number_with_ubjson_prefix(el.first.size(), true);
						oa->write_characters(
							reinterpret_cast<const CharType*>(el.first.c_str()),
							el.first.size());
						write_ubjson(el.second, use_count, use_type, prefix_required);
					}

					if (not use_count)
					{
						oa->write_character(static_cast<CharType>('}'));
					}

					break;
				}

				default:
					break;
				}
			}

		private:
			/*
			@brief write a number to output input

			@param[in] n number of type @a NumberType
			@tparam NumberType the type of the number

			@note This function needs to respect the system's endianess, because bytes
				  in CBOR, MessagePack, and UBJSON are stored in network order (big
				  endian) and therefore need reordering on little endian systems.
			*/
			template<typename NumberType>
			void write_number(const NumberType n)
			{
				// step 1: write number to array of length NumberType
				std::array<CharType, sizeof(NumberType)> vec;
				std::memcpy(vec.data(), &n, sizeof(NumberType));

				// step 2: write array to output (with possible reordering)
				if (is_little_endian)
				{
					// reverse byte order prior to conversion if necessary
					std::reverse(vec.begin(), vec.end());
				}

				oa->write_characters(vec.data(), sizeof(NumberType));
			}

			// UBJSON: write number (floating point)
			template<typename NumberType, typename std::enable_if<
				std::is_floating_point<NumberType>::value, int>::type = 0>
				void write_number_with_ubjson_prefix(const NumberType n,
					const bool add_prefix)
			{
				if (add_prefix)
				{
					oa->write_character(get_ubjson_float_prefix(n));
				}
				write_number(n);
			}

			// UBJSON: write number (unsigned integer)
			template<typename NumberType, typename std::enable_if<
				std::is_unsigned<NumberType>::value, int>::type = 0>
				void write_number_with_ubjson_prefix(const NumberType n,
					const bool add_prefix)
			{
				if (n <= static_cast<uint64_t>((std::numeric_limits<int8_t>::max)()))
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('i'));  // int8
					}
					write_number(static_cast<uint8_t>(n));
				}
				else if (n <= (std::numeric_limits<uint8_t>::max)())
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('U'));  // uint8
					}
					write_number(static_cast<uint8_t>(n));
				}
				else if (n <= static_cast<uint64_t>((std::numeric_limits<int16_t>::max)()))
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('I'));  // int16
					}
					write_number(static_cast<int16_t>(n));
				}
				else if (n <= static_cast<uint64_t>((std::numeric_limits<int32_t>::max)()))
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('l'));  // int32
					}
					write_number(static_cast<int32_t>(n));
				}
				else if (n <= static_cast<uint64_t>((std::numeric_limits<int64_t>::max)()))
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('L'));  // int64
					}
					write_number(static_cast<int64_t>(n));
				}
				else
				{
					JSON_THROW(out_of_range::create(407, "number overflow serializing " + std::to_string(n)));
				}
			}

			// UBJSON: write number (signed integer)
			template<typename NumberType, typename std::enable_if<
				std::is_signed<NumberType>::value and
				not std::is_floating_point<NumberType>::value, int>::type = 0>
				void write_number_with_ubjson_prefix(const NumberType n,
					const bool add_prefix)
			{
				if ((std::numeric_limits<int8_t>::min)() <= n and n <= (std::numeric_limits<int8_t>::max)())
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('i'));  // int8
					}
					write_number(static_cast<int8_t>(n));
				}
				else if (static_cast<int64_t>((std::numeric_limits<uint8_t>::min)()) <= n and n <= static_cast<int64_t>((std::numeric_limits<uint8_t>::max)()))
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('U'));  // uint8
					}
					write_number(static_cast<uint8_t>(n));
				}
				else if ((std::numeric_limits<int16_t>::min)() <= n and n <= (std::numeric_limits<int16_t>::max)())
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('I'));  // int16
					}
					write_number(static_cast<int16_t>(n));
				}
				else if ((std::numeric_limits<int32_t>::min)() <= n and n <= (std::numeric_limits<int32_t>::max)())
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('l'));  // int32
					}
					write_number(static_cast<int32_t>(n));
				}
				else if ((std::numeric_limits<int64_t>::min)() <= n and n <= (std::numeric_limits<int64_t>::max)())
				{
					if (add_prefix)
					{
						oa->write_character(static_cast<CharType>('L'));  // int64
					}
					write_number(static_cast<int64_t>(n));
				}
				// LCOV_EXCL_START
				else
				{
					JSON_THROW(out_of_range::create(407, "number overflow serializing " + std::to_string(n)));
				}
				// LCOV_EXCL_STOP
			}

			/*!
			@brief determine the type prefix of container values

			@note This function does not need to be 100% accurate when it comes to
				  integer limits. In case a number exceeds the limits of int64_t,
				  this will be detected by a later call to function
				  write_number_with_ubjson_prefix. Therefore, we return 'L' for any
				  value that does not fit the previous limits.
			*/
			CharType ubjson_prefix(const BasicJsonType& j) const noexcept
			{
				switch (j.type())
				{
				case value_t::null:
					return 'Z';

				case value_t::boolean:
					return j.m_value.boolean ? 'T' : 'F';

				case value_t::number_integer:
				{
					if ((std::numeric_limits<int8_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<int8_t>::max)())
					{
						return 'i';
					}
					else if ((std::numeric_limits<uint8_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<uint8_t>::max)())
					{
						return 'U';
					}
					else if ((std::numeric_limits<int16_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<int16_t>::max)())
					{
						return 'I';
					}
					else if ((std::numeric_limits<int32_t>::min)() <= j.m_value.number_integer and j.m_value.number_integer <= (std::numeric_limits<int32_t>::max)())
					{
						return 'l';
					}
					else  // no check and assume int64_t (see note above)
					{
						return 'L';
					}
				}

				case value_t::number_unsigned:
				{
					if (j.m_value.number_unsigned <= (std::numeric_limits<int8_t>::max)())
					{
						return 'i';
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<uint8_t>::max)())
					{
						return 'U';
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<int16_t>::max)())
					{
						return 'I';
					}
					else if (j.m_value.number_unsigned <= (std::numeric_limits<int32_t>::max)())
					{
						return 'l';
					}
					else  // no check and assume int64_t (see note above)
					{
						return 'L';
					}
				}

				case value_t::number_float:
					return get_ubjson_float_prefix(j.m_value.number_float);

				case value_t::string:
					return 'S';

				case value_t::array:
					return '[';

				case value_t::object:
					return '{';

				default:  // discarded values
					return 'N';
				}
			}

			static constexpr CharType get_cbor_float_prefix(float)
			{
				return static_cast<CharType>(0xFA);  // Single-Precision Float
			}

			static constexpr CharType get_cbor_float_prefix(double)
			{
				return static_cast<CharType>(0xFB);  // Double-Precision Float
			}

			static constexpr CharType get_msgpack_float_prefix(float)
			{
				return static_cast<CharType>(0xCA);  // float 32
			}

			static constexpr CharType get_msgpack_float_prefix(double)
			{
				return static_cast<CharType>(0xCB);  // float 64
			}

			static constexpr CharType get_ubjson_float_prefix(float)
			{
				return 'd';  // float 32
			}

			static constexpr CharType get_ubjson_float_prefix(double)
			{
				return 'D';  // float 64
			}

		private:
			/// whether we can assume little endianess
			const bool is_little_endian = binary_reader<BasicJsonType>::little_endianess();

			/// the output
			output_adapter_t<CharType> oa = nullptr;
		};
	}
}

// #include <nlohmann/detail/output/serializer.hpp>


#include <algorithm> // reverse, remove, fill, find, none_of
#include <array> // array
#include <cassert> // assert
#include <ciso646> // and, or
#include <clocale> // localeconv, lconv
#include <cmath> // labs, isfinite, isnan, signbit
#include <cstddef> // size_t, ptrdiff_t
#include <cstdint> // uint8_t
#include <cstdio> // snprintf
#include <limits> // numeric_limits
#include <string> // string
#include <type_traits> // is_same

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/conversions/to_chars.hpp>


#include <cassert> // assert
#include <ciso646> // or, and, not
#include <cmath>   // signbit, isfinite
#include <cstdint> // intN_t, uintN_t
#include <cstring> // memcpy, memmove

namespace nlohmann
{
	namespace detail
	{

		/*!
		@brief implements the Grisu2 algorithm for binary to decimal floating-point
		conversion.

		This implementation is a slightly modified version of the reference
		implementation which may be obtained from
		http://florian.loitsch.com/publications (bench.tar.gz).

		The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.

		For a detailed description of the algorithm see:

		[1] Loitsch, "Printing Floating-Point Numbers Quickly and Accurately with
			Integers", Proceedings of the ACM SIGPLAN 2010 Conference on Programming
			Language Design and Implementation, PLDI 2010
		[2] Burger, Dybvig, "Printing Floating-Point Numbers Quickly and Accurately",
			Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language
			Design and Implementation, PLDI 1996
		*/
		namespace dtoa_impl
		{

			template <typename Target, typename Source>
			Target reinterpret_bits(const Source source)
			{
				static_assert(sizeof(Target) == sizeof(Source), "size mismatch");

				Target target;
				std::memcpy(&target, &source, sizeof(Source));
				return target;
			}

			struct diyfp // f * 2^e
			{
				static constexpr int kPrecision = 64; // = q

				uint64_t f;
				int e;

				constexpr diyfp() noexcept : f(0), e(0) {}
				constexpr diyfp(uint64_t f_, int e_) noexcept : f(f_), e(e_) {}

				/*!
				@brief returns x - y
				@pre x.e == y.e and x.f >= y.f
				*/
				static diyfp sub(const diyfp& x, const diyfp& y) noexcept
				{
					assert(x.e == y.e);
					assert(x.f >= y.f);

					return diyfp(x.f - y.f, x.e);
				}

				/*!
				@brief returns x * y
				@note The result is rounded. (Only the upper q bits are returned.)
				*/
				static diyfp mul(const diyfp& x, const diyfp& y) noexcept
				{
					static_assert(kPrecision == 64, "internal error");

					// Computes:
					//  f = round((x.f * y.f) / 2^q)
					//  e = x.e + y.e + q

					// Emulate the 64-bit * 64-bit multiplication:
					//
					// p = u * v
					//   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)
					//   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )
					//   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )
					//   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )
					//   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)
					//   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )
					//   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )
					//
					// (Since Q might be larger than 2^32 - 1)
					//
					//   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)
					//
					// (Q_hi + H does not overflow a 64-bit int)
					//
					//   = p_lo + 2^64 p_hi

					const uint64_t u_lo = x.f & 0xFFFFFFFF;
					const uint64_t u_hi = x.f >> 32;
					const uint64_t v_lo = y.f & 0xFFFFFFFF;
					const uint64_t v_hi = y.f >> 32;

					const uint64_t p0 = u_lo * v_lo;
					const uint64_t p1 = u_lo * v_hi;
					const uint64_t p2 = u_hi * v_lo;
					const uint64_t p3 = u_hi * v_hi;

					const uint64_t p0_hi = p0 >> 32;
					const uint64_t p1_lo = p1 & 0xFFFFFFFF;
					const uint64_t p1_hi = p1 >> 32;
					const uint64_t p2_lo = p2 & 0xFFFFFFFF;
					const uint64_t p2_hi = p2 >> 32;

					uint64_t Q = p0_hi + p1_lo + p2_lo;

					// The full product might now be computed as
					//
					// p_hi = p3 + p2_hi + p1_hi + (Q >> 32)
					// p_lo = p0_lo + (Q << 32)
					//
					// But in this particular case here, the full p_lo is not required.
					// Effectively we only need to add the highest bit in p_lo to p_hi (and
					// Q_hi + 1 does not overflow).

					Q += uint64_t{ 1 } << (64 - 32 - 1); // round, ties up

					const uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32);

					return diyfp(h, x.e + y.e + 64);
				}

				/*!
				@brief normalize x such that the significand is >= 2^(q-1)
				@pre x.f != 0
				*/
				static diyfp normalize(diyfp x) noexcept
				{
					assert(x.f != 0);

					while ((x.f >> 63) == 0)
					{
						x.f <<= 1;
						x.e--;
					}

					return x;
				}

				/*!
				@brief normalize x such that the result has the exponent E
				@pre e >= x.e and the upper e - x.e bits of x.f must be zero.
				*/
				static diyfp normalize_to(const diyfp& x, const int target_exponent) noexcept
				{
					const int delta = x.e - target_exponent;

					assert(delta >= 0);
					assert(((x.f << delta) >> delta) == x.f);

					return diyfp(x.f << delta, target_exponent);
				}
			};

			struct boundaries
			{
				diyfp w;
				diyfp minus;
				diyfp plus;
			};

			/*!
			Compute the (normalized) diyfp representing the input number 'value' and its
			boundaries.

			@pre value must be finite and positive
			*/
			template <typename FloatType>
			boundaries compute_boundaries(FloatType value)
			{
				assert(std::isfinite(value));
				assert(value > 0);

				// Convert the IEEE representation into a diyfp.
				//
				// If v is denormal:
				//      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
				// If v is normalized:
				//      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))

				static_assert(std::numeric_limits<FloatType>::is_iec559,
					"internal error: dtoa_short requires an IEEE-754 floating-point implementation");

				constexpr int      kPrecision = std::numeric_limits<FloatType>::digits; // = p (includes the hidden bit)
				constexpr int      kBias = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
				constexpr int      kMinExp = 1 - kBias;
				constexpr uint64_t kHiddenBit = uint64_t{ 1 } << (kPrecision - 1); // = 2^(p-1)

				using bits_type = typename std::conditional< kPrecision == 24, uint32_t, uint64_t >::type;

				const uint64_t bits = reinterpret_bits<bits_type>(value);
				const uint64_t E = bits >> (kPrecision - 1);
				const uint64_t F = bits & (kHiddenBit - 1);

				const bool is_denormal = (E == 0);
				const diyfp v = is_denormal
					? diyfp(F, kMinExp)
					: diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);

				// Compute the boundaries m- and m+ of the floating-point value
				// v = f * 2^e.
				//
				// Determine v- and v+, the floating-point predecessor and successor if v,
				// respectively.
				//
				//      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
				//         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)
				//
				//      v+ = v + 2^e
				//
				// Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_
				// between m- and m+ round to v, regardless of how the input rounding
				// algorithm breaks ties.
				//
				//      ---+-------------+-------------+-------------+-------------+---  (A)
				//         v-            m-            v             m+            v+
				//
				//      -----------------+------+------+-------------+-------------+---  (B)
				//                       v-     m-     v             m+            v+

				const bool lower_boundary_is_closer = (F == 0 and E > 1);
				const diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);
				const diyfp m_minus = lower_boundary_is_closer
					? diyfp(4 * v.f - 1, v.e - 2)  // (B)
					: diyfp(2 * v.f - 1, v.e - 1); // (A)

// Determine the normalized w+ = m+.
				const diyfp w_plus = diyfp::normalize(m_plus);

				// Determine w- = m- such that e_(w-) = e_(w+).
				const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);

				return { diyfp::normalize(v), w_minus, w_plus };
			}

			// Given normalized diyfp w, Grisu needs to find a (normalized) cached
			// power-of-ten c, such that the exponent of the product c * w = f * 2^e lies
			// within a certain range [alpha, gamma] (Definition 3.2 from [1])
			//
			//      alpha <= e = e_c + e_w + q <= gamma
			//
			// or
			//
			//      f_c * f_w * 2^alpha <= f_c 2^(e_c) * f_w 2^(e_w) * 2^q
			//                          <= f_c * f_w * 2^gamma
			//
			// Since c and w are normalized, i.e. 2^(q-1) <= f < 2^q, this implies
			//
			//      2^(q-1) * 2^(q-1) * 2^alpha <= c * w * 2^q < 2^q * 2^q * 2^gamma
			//
			// or
			//
			//      2^(q - 2 + alpha) <= c * w < 2^(q + gamma)
			//
			// The choice of (alpha,gamma) determines the size of the table and the form of
			// the digit generation procedure. Using (alpha,gamma)=(-60,-32) works out well
			// in practice:
			//
			// The idea is to cut the number c * w = f * 2^e into two parts, which can be
			// processed independently: An integral part p1, and a fractional part p2:
			//
			//      f * 2^e = ( (f div 2^-e) * 2^-e + (f mod 2^-e) ) * 2^e
			//              = (f div 2^-e) + (f mod 2^-e) * 2^e
			//              = p1 + p2 * 2^e
			//
			// The conversion of p1 into decimal form requires a series of divisions and
			// modulos by (a power of) 10. These operations are faster for 32-bit than for
			// 64-bit integers, so p1 should ideally fit into a 32-bit integer. This can be
			// achieved by choosing
			//
			//      -e >= 32   or   e <= -32 := gamma
			//
			// In order to convert the fractional part
			//
			//      p2 * 2^e = p2 / 2^-e = d[-1] / 10^1 + d[-2] / 10^2 + ...
			//
			// into decimal form, the fraction is repeatedly multiplied by 10 and the digits
			// d[-i] are extracted in order:
			//
			//      (10 * p2) div 2^-e = d[-1]
			//      (10 * p2) mod 2^-e = d[-2] / 10^1 + ...
			//
			// The multiplication by 10 must not overflow. It is sufficient to choose
			//
			//      10 * p2 < 16 * p2 = 2^4 * p2 <= 2^64.
			//
			// Since p2 = f mod 2^-e < 2^-e,
			//
			//      -e <= 60   or   e >= -60 := alpha

			constexpr int kAlpha = -60;
			constexpr int kGamma = -32;

			struct cached_power // c = f * 2^e ~= 10^k
			{
				uint64_t f;
				int e;
				int k;
			};

			/*!
			For a normalized diyfp w = f * 2^e, this function returns a (normalized) cached
			power-of-ten c = f_c * 2^e_c, such that the exponent of the product w * c
			satisfies (Definition 3.2 from [1])

				 alpha <= e_c + e + q <= gamma.
			*/
			inline cached_power get_cached_power_for_binary_exponent(int e)
			{
				// Now
				//
				//      alpha <= e_c + e + q <= gamma                                    (1)
				//      ==> f_c * 2^alpha <= c * 2^e * 2^q
				//
				// and since the c's are normalized, 2^(q-1) <= f_c,
				//
				//      ==> 2^(q - 1 + alpha) <= c * 2^(e + q)
				//      ==> 2^(alpha - e - 1) <= c
				//
				// If c were an exakt power of ten, i.e. c = 10^k, one may determine k as
				//
				//      k = ceil( log_10( 2^(alpha - e - 1) ) )
				//        = ceil( (alpha - e - 1) * log_10(2) )
				//
				// From the paper:
				// "In theory the result of the procedure could be wrong since c is rounded,
				//  and the computation itself is approximated [...]. In practice, however,
				//  this simple function is sufficient."
				//
				// For IEEE double precision floating-point numbers converted into
				// normalized diyfp's w = f * 2^e, with q = 64,
				//
				//      e >= -1022      (min IEEE exponent)
				//           -52        (p - 1)
				//           -52        (p - 1, possibly normalize denormal IEEE numbers)
				//           -11        (normalize the diyfp)
				//         = -1137
				//
				// and
				//
				//      e <= +1023      (max IEEE exponent)
				//           -52        (p - 1)
				//           -11        (normalize the diyfp)
				//         = 960
				//
				// This binary exponent range [-1137,960] results in a decimal exponent
				// range [-307,324]. One does not need to store a cached power for each
				// k in this range. For each such k it suffices to find a cached power
				// such that the exponent of the product lies in [alpha,gamma].
				// This implies that the difference of the decimal exponents of adjacent
				// table entries must be less than or equal to
				//
				//      floor( (gamma - alpha) * log_10(2) ) = 8.
				//
				// (A smaller distance gamma-alpha would require a larger table.)

				// NB:
				// Actually this function returns c, such that -60 <= e_c + e + 64 <= -34.

				constexpr int kCachedPowersSize = 79;
				constexpr int kCachedPowersMinDecExp = -300;
				constexpr int kCachedPowersDecStep = 8;

				static constexpr cached_power kCachedPowers[] =
				{
					{ 0xAB70FE17C79AC6CA, -1060, -300 },
					{ 0xFF77B1FCBEBCDC4F, -1034, -292 },
					{ 0xBE5691EF416BD60C, -1007, -284 },
					{ 0x8DD01FAD907FFC3C,  -980, -276 },
					{ 0xD3515C2831559A83,  -954, -268 },
					{ 0x9D71AC8FADA6C9B5,  -927, -260 },
					{ 0xEA9C227723EE8BCB,  -901, -252 },
					{ 0xAECC49914078536D,  -874, -244 },
					{ 0x823C12795DB6CE57,  -847, -236 },
					{ 0xC21094364DFB5637,  -821, -228 },
					{ 0x9096EA6F3848984F,  -794, -220 },
					{ 0xD77485CB25823AC7,  -768, -212 },
					{ 0xA086CFCD97BF97F4,  -741, -204 },
					{ 0xEF340A98172AACE5,  -715, -196 },
					{ 0xB23867FB2A35B28E,  -688, -188 },
					{ 0x84C8D4DFD2C63F3B,  -661, -180 },
					{ 0xC5DD44271AD3CDBA,  -635, -172 },
					{ 0x936B9FCEBB25C996,  -608, -164 },
					{ 0xDBAC6C247D62A584,  -582, -156 },
					{ 0xA3AB66580D5FDAF6,  -555, -148 },
					{ 0xF3E2F893DEC3F126,  -529, -140 },
					{ 0xB5B5ADA8AAFF80B8,  -502, -132 },
					{ 0x87625F056C7C4A8B,  -475, -124 },
					{ 0xC9BCFF6034C13053,  -449, -116 },
					{ 0x964E858C91BA2655,  -422, -108 },
					{ 0xDFF9772470297EBD,  -396, -100 },
					{ 0xA6DFBD9FB8E5B88F,  -369,  -92 },
					{ 0xF8A95FCF88747D94,  -343,  -84 },
					{ 0xB94470938FA89BCF,  -316,  -76 },
					{ 0x8A08F0F8BF0F156B,  -289,  -68 },
					{ 0xCDB02555653131B6,  -263,  -60 },
					{ 0x993FE2C6D07B7FAC,  -236,  -52 },
					{ 0xE45C10C42A2B3B06,  -210,  -44 },
					{ 0xAA242499697392D3,  -183,  -36 },
					{ 0xFD87B5F28300CA0E,  -157,  -28 },
					{ 0xBCE5086492111AEB,  -130,  -20 },
					{ 0x8CBCCC096F5088CC,  -103,  -12 },
					{ 0xD1B71758E219652C,   -77,   -4 },
					{ 0x9C40000000000000,   -50,    4 },
					{ 0xE8D4A51000000000,   -24,   12 },
					{ 0xAD78EBC5AC620000,     3,   20 },
					{ 0x813F3978F8940984,    30,   28 },
					{ 0xC097CE7BC90715B3,    56,   36 },
					{ 0x8F7E32CE7BEA5C70,    83,   44 },
					{ 0xD5D238A4ABE98068,   109,   52 },
					{ 0x9F4F2726179A2245,   136,   60 },
					{ 0xED63A231D4C4FB27,   162,   68 },
					{ 0xB0DE65388CC8ADA8,   189,   76 },
					{ 0x83C7088E1AAB65DB,   216,   84 },
					{ 0xC45D1DF942711D9A,   242,   92 },
					{ 0x924D692CA61BE758,   269,  100 },
					{ 0xDA01EE641A708DEA,   295,  108 },
					{ 0xA26DA3999AEF774A,   322,  116 },
					{ 0xF209787BB47D6B85,   348,  124 },
					{ 0xB454E4A179DD1877,   375,  132 },
					{ 0x865B86925B9BC5C2,   402,  140 },
					{ 0xC83553C5C8965D3D,   428,  148 },
					{ 0x952AB45CFA97A0B3,   455,  156 },
					{ 0xDE469FBD99A05FE3,   481,  164 },
					{ 0xA59BC234DB398C25,   508,  172 },
					{ 0xF6C69A72A3989F5C,   534,  180 },
					{ 0xB7DCBF5354E9BECE,   561,  188 },
					{ 0x88FCF317F22241E2,   588,  196 },
					{ 0xCC20CE9BD35C78A5,   614,  204 },
					{ 0x98165AF37B2153DF,   641,  212 },
					{ 0xE2A0B5DC971F303A,   667,  220 },
					{ 0xA8D9D1535CE3B396,   694,  228 },
					{ 0xFB9B7CD9A4A7443C,   720,  236 },
					{ 0xBB764C4CA7A44410,   747,  244 },
					{ 0x8BAB8EEFB6409C1A,   774,  252 },
					{ 0xD01FEF10A657842C,   800,  260 },
					{ 0x9B10A4E5E9913129,   827,  268 },
					{ 0xE7109BFBA19C0C9D,   853,  276 },
					{ 0xAC2820D9623BF429,   880,  284 },
					{ 0x80444B5E7AA7CF85,   907,  292 },
					{ 0xBF21E44003ACDD2D,   933,  300 },
					{ 0x8E679C2F5E44FF8F,   960,  308 },
					{ 0xD433179D9C8CB841,   986,  316 },
					{ 0x9E19DB92B4E31BA9,  1013,  324 },
				};

				// This computation gives exactly the same results for k as
				//      k = ceil((kAlpha - e - 1) * 0.30102999566398114)
				// for |e| <= 1500, but doesn't require floating-point operations.
				// NB: log_10(2) ~= 78913 / 2^18
				assert(e >= -1500);
				assert(e <= 1500);
				const int f = kAlpha - e - 1;
				const int k = (f * 78913) / (1 << 18) + (f > 0);

				const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
				assert(index >= 0);
				assert(index < kCachedPowersSize);
				static_cast<void>(kCachedPowersSize); // Fix warning.

				const cached_power cached = kCachedPowers[index];
				assert(kAlpha <= cached.e + e + 64);
				assert(kGamma >= cached.e + e + 64);

				return cached;
			}

			/*!
			For n != 0, returns k, such that pow10 := 10^(k-1) <= n < 10^k.
			For n == 0, returns 1 and sets pow10 := 1.
			*/
			inline int find_largest_pow10(const uint32_t n, uint32_t& pow10)
			{
				// LCOV_EXCL_START
				if (n >= 1000000000)
				{
					pow10 = 1000000000;
					return 10;
				}
				// LCOV_EXCL_STOP
				else if (n >= 100000000)
				{
					pow10 = 100000000;
					return  9;
				}
				else if (n >= 10000000)
				{
					pow10 = 10000000;
					return  8;
				}
				else if (n >= 1000000)
				{
					pow10 = 1000000;
					return  7;
				}
				else if (n >= 100000)
				{
					pow10 = 100000;
					return  6;
				}
				else if (n >= 10000)
				{
					pow10 = 10000;
					return  5;
				}
				else if (n >= 1000)
				{
					pow10 = 1000;
					return  4;
				}
				else if (n >= 100)
				{
					pow10 = 100;
					return  3;
				}
				else if (n >= 10)
				{
					pow10 = 10;
					return  2;
				}
				else
				{
					pow10 = 1;
					return 1;
				}
			}

			inline void grisu2_round(char* buf, int len, uint64_t dist, uint64_t delta,
				uint64_t rest, uint64_t ten_k)
			{
				assert(len >= 1);
				assert(dist <= delta);
				assert(rest <= delta);
				assert(ten_k > 0);

				//               <--------------------------- delta ---->
				//                                  <---- dist --------->
				// --------------[------------------+-------------------]--------------
				//               M-                 w                   M+
				//
				//                                  ten_k
				//                                <------>
				//                                       <---- rest ---->
				// --------------[------------------+----+--------------]--------------
				//                                  w    V
				//                                       = buf * 10^k
				//
				// ten_k represents a unit-in-the-last-place in the decimal representation
				// stored in buf.
				// Decrement buf by ten_k while this takes buf closer to w.

				// The tests are written in this order to avoid overflow in unsigned
				// integer arithmetic.

				while (rest < dist
					and delta - rest >= ten_k
					and (rest + ten_k < dist or dist - rest > rest + ten_k - dist))
				{
					assert(buf[len - 1] != '0');
					buf[len - 1]--;
					rest += ten_k;
				}
			}

			/*!
			Generates V = buffer * 10^decimal_exponent, such that M- <= V <= M+.
			M- and M+ must be normalized and share the same exponent -60 <= e <= -32.
			*/
			inline void grisu2_digit_gen(char* buffer, int& length, int& decimal_exponent,
				diyfp M_minus, diyfp w, diyfp M_plus)
			{
				static_assert(kAlpha >= -60, "internal error");
				static_assert(kGamma <= -32, "internal error");

				// Generates the digits (and the exponent) of a decimal floating-point
				// number V = buffer * 10^decimal_exponent in the range [M-, M+]. The diyfp's
				// w, M- and M+ share the same exponent e, which satisfies alpha <= e <= gamma.
				//
				//               <--------------------------- delta ---->
				//                                  <---- dist --------->
				// --------------[------------------+-------------------]--------------
				//               M-                 w                   M+
				//
				// Grisu2 generates the digits of M+ from left to right and stops as soon as
				// V is in [M-,M+].

				assert(M_plus.e >= kAlpha);
				assert(M_plus.e <= kGamma);

				uint64_t delta = diyfp::sub(M_plus, M_minus).f; // (significand of (M+ - M-), implicit exponent is e)
				uint64_t dist = diyfp::sub(M_plus, w).f; // (significand of (M+ - w ), implicit exponent is e)

				// Split M+ = f * 2^e into two parts p1 and p2 (note: e < 0):
				//
				//      M+ = f * 2^e
				//         = ((f div 2^-e) * 2^-e + (f mod 2^-e)) * 2^e
				//         = ((p1        ) * 2^-e + (p2        )) * 2^e
				//         = p1 + p2 * 2^e

				const diyfp one(uint64_t{ 1 } << -M_plus.e, M_plus.e);

				uint32_t p1 = static_cast<uint32_t>(M_plus.f >> -one.e); // p1 = f div 2^-e (Since -e >= 32, p1 fits into a 32-bit int.)
				uint64_t p2 = M_plus.f & (one.f - 1);                    // p2 = f mod 2^-e

				// 1)
				//
				// Generate the digits of the integral part p1 = d[n-1]...d[1]d[0]

				assert(p1 > 0);

				uint32_t pow10;
				const int k = find_largest_pow10(p1, pow10);

				//      10^(k-1) <= p1 < 10^k, pow10 = 10^(k-1)
				//
				//      p1 = (p1 div 10^(k-1)) * 10^(k-1) + (p1 mod 10^(k-1))
				//         = (d[k-1]         ) * 10^(k-1) + (p1 mod 10^(k-1))
				//
				//      M+ = p1                                             + p2 * 2^e
				//         = d[k-1] * 10^(k-1) + (p1 mod 10^(k-1))          + p2 * 2^e
				//         = d[k-1] * 10^(k-1) + ((p1 mod 10^(k-1)) * 2^-e + p2) * 2^e
				//         = d[k-1] * 10^(k-1) + (                         rest) * 2^e
				//
				// Now generate the digits d[n] of p1 from left to right (n = k-1,...,0)
				//
				//      p1 = d[k-1]...d[n] * 10^n + d[n-1]...d[0]
				//
				// but stop as soon as
				//
				//      rest * 2^e = (d[n-1]...d[0] * 2^-e + p2) * 2^e <= delta * 2^e

				int n = k;
				while (n > 0)
				{
					// Invariants:
					//      M+ = buffer * 10^n + (p1 + p2 * 2^e)    (buffer = 0 for n = k)
					//      pow10 = 10^(n-1) <= p1 < 10^n
					//
					const uint32_t d = p1 / pow10;  // d = p1 div 10^(n-1)
					const uint32_t r = p1 % pow10;  // r = p1 mod 10^(n-1)
					//
					//      M+ = buffer * 10^n + (d * 10^(n-1) + r) + p2 * 2^e
					//         = (buffer * 10 + d) * 10^(n-1) + (r + p2 * 2^e)
					//
					assert(d <= 9);
					buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
					//
					//      M+ = buffer * 10^(n-1) + (r + p2 * 2^e)
					//
					p1 = r;
					n--;
					//
					//      M+ = buffer * 10^n + (p1 + p2 * 2^e)
					//      pow10 = 10^n
					//

					// Now check if enough digits have been generated.
					// Compute
					//
					//      p1 + p2 * 2^e = (p1 * 2^-e + p2) * 2^e = rest * 2^e
					//
					// Note:
					// Since rest and delta share the same exponent e, it suffices to
					// compare the significands.
					const uint64_t rest = (uint64_t{ p1 } << -one.e) + p2;
					if (rest <= delta)
					{
						// V = buffer * 10^n, with M- <= V <= M+.

						decimal_exponent += n;

						// We may now just stop. But instead look if the buffer could be
						// decremented to bring V closer to w.
						//
						// pow10 = 10^n is now 1 ulp in the decimal representation V.
						// The rounding procedure works with diyfp's with an implicit
						// exponent of e.
						//
						//      10^n = (10^n * 2^-e) * 2^e = ulp * 2^e
						//
						const uint64_t ten_n = uint64_t{ pow10 } << -one.e;
						grisu2_round(buffer, length, dist, delta, rest, ten_n);

						return;
					}

					pow10 /= 10;
					//
					//      pow10 = 10^(n-1) <= p1 < 10^n
					// Invariants restored.
				}

				// 2)
				//
				// The digits of the integral part have been generated:
				//
				//      M+ = d[k-1]...d[1]d[0] + p2 * 2^e
				//         = buffer            + p2 * 2^e
				//
				// Now generate the digits of the fractional part p2 * 2^e.
				//
				// Note:
				// No decimal point is generated: the exponent is adjusted instead.
				//
				// p2 actually represents the fraction
				//
				//      p2 * 2^e
				//          = p2 / 2^-e
				//          = d[-1] / 10^1 + d[-2] / 10^2 + ...
				//
				// Now generate the digits d[-m] of p1 from left to right (m = 1,2,...)
				//
				//      p2 * 2^e = d[-1]d[-2]...d[-m] * 10^-m
				//                      + 10^-m * (d[-m-1] / 10^1 + d[-m-2] / 10^2 + ...)
				//
				// using
				//
				//      10^m * p2 = ((10^m * p2) div 2^-e) * 2^-e + ((10^m * p2) mod 2^-e)
				//                = (                   d) * 2^-e + (                   r)
				//
				// or
				//      10^m * p2 * 2^e = d + r * 2^e
				//
				// i.e.
				//
				//      M+ = buffer + p2 * 2^e
				//         = buffer + 10^-m * (d + r * 2^e)
				//         = (buffer * 10^m + d) * 10^-m + 10^-m * r * 2^e
				//
				// and stop as soon as 10^-m * r * 2^e <= delta * 2^e

				assert(p2 > delta);

				int m = 0;
				for (;;)
				{
					// Invariant:
					//      M+ = buffer * 10^-m + 10^-m * (d[-m-1] / 10 + d[-m-2] / 10^2 + ...) * 2^e
					//         = buffer * 10^-m + 10^-m * (p2                                 ) * 2^e
					//         = buffer * 10^-m + 10^-m * (1/10 * (10 * p2)                   ) * 2^e
					//         = buffer * 10^-m + 10^-m * (1/10 * ((10*p2 div 2^-e) * 2^-e + (10*p2 mod 2^-e)) * 2^e
					//
					assert(p2 <= UINT64_MAX / 10);
					p2 *= 10;
					const uint64_t d = p2 >> -one.e;     // d = (10 * p2) div 2^-e
					const uint64_t r = p2 & (one.f - 1); // r = (10 * p2) mod 2^-e
					//
					//      M+ = buffer * 10^-m + 10^-m * (1/10 * (d * 2^-e + r) * 2^e
					//         = buffer * 10^-m + 10^-m * (1/10 * (d + r * 2^e))
					//         = (buffer * 10 + d) * 10^(-m-1) + 10^(-m-1) * r * 2^e
					//
					assert(d <= 9);
					buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
					//
					//      M+ = buffer * 10^(-m-1) + 10^(-m-1) * r * 2^e
					//
					p2 = r;
					m++;
					//
					//      M+ = buffer * 10^-m + 10^-m * p2 * 2^e
					// Invariant restored.

					// Check if enough digits have been generated.
					//
					//      10^-m * p2 * 2^e <= delta * 2^e
					//              p2 * 2^e <= 10^m * delta * 2^e
					//                    p2 <= 10^m * delta
					delta *= 10;
					dist *= 10;
					if (p2 <= delta)
					{
						break;
					}
				}

				// V = buffer * 10^-m, with M- <= V <= M+.

				decimal_exponent -= m;

				// 1 ulp in the decimal representation is now 10^-m.
				// Since delta and dist are now scaled by 10^m, we need to do the
				// same with ulp in order to keep the units in sync.
				//
				//      10^m * 10^-m = 1 = 2^-e * 2^e = ten_m * 2^e
				//
				const uint64_t ten_m = one.f;
				grisu2_round(buffer, length, dist, delta, p2, ten_m);

				// By construction this algorithm generates the shortest possible decimal
				// number (Loitsch, Theorem 6.2) which rounds back to w.
				// For an input number of precision p, at least
				//
				//      N = 1 + ceil(p * log_10(2))
				//
				// decimal digits are sufficient to identify all binary floating-point
				// numbers (Matula, "In-and-Out conversions").
				// This implies that the algorithm does not produce more than N decimal
				// digits.
				//
				//      N = 17 for p = 53 (IEEE double precision)
				//      N = 9  for p = 24 (IEEE single precision)
			}

			/*!
			v = buf * 10^decimal_exponent
			len is the length of the buffer (number of decimal digits)
			The buffer must be large enough, i.e. >= max_digits10.
			*/
			inline void grisu2(char* buf, int& len, int& decimal_exponent,
				diyfp m_minus, diyfp v, diyfp m_plus)
			{
				assert(m_plus.e == m_minus.e);
				assert(m_plus.e == v.e);

				//  --------(-----------------------+-----------------------)--------    (A)
				//          m-                      v                       m+
				//
				//  --------------------(-----------+-----------------------)--------    (B)
				//                      m-          v                       m+
				//
				// First scale v (and m- and m+) such that the exponent is in the range
				// [alpha, gamma].

				const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);

				const diyfp c_minus_k(cached.f, cached.e); // = c ~= 10^-k

				// The exponent of the products is = v.e + c_minus_k.e + q and is in the range [alpha,gamma]
				const diyfp w = diyfp::mul(v, c_minus_k);
				const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
				const diyfp w_plus = diyfp::mul(m_plus, c_minus_k);

				//  ----(---+---)---------------(---+---)---------------(---+---)----
				//          w-                      w                       w+
				//          = c*m-                  = c*v                   = c*m+
				//
				// diyfp::mul rounds its result and c_minus_k is approximated too. w, w- and
				// w+ are now off by a small amount.
				// In fact:
				//
				//      w - v * 10^k < 1 ulp
				//
				// To account for this inaccuracy, add resp. subtract 1 ulp.
				//
				//  --------+---[---------------(---+---)---------------]---+--------
				//          w-  M-                  w                   M+  w+
				//
				// Now any number in [M-, M+] (bounds included) will round to w when input,
				// regardless of how the input rounding algorithm breaks ties.
				//
				// And digit_gen generates the shortest possible such number in [M-, M+].
				// Note that this does not mean that Grisu2 always generates the shortest
				// possible number in the interval (m-, m+).
				const diyfp M_minus(w_minus.f + 1, w_minus.e);
				const diyfp M_plus(w_plus.f - 1, w_plus.e);

				decimal_exponent = -cached.k; // = -(-k) = k

				grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
			}

			/*!
			v = buf * 10^decimal_exponent
			len is the length of the buffer (number of decimal digits)
			The buffer must be large enough, i.e. >= max_digits10.
			*/
			template <typename FloatType>
			void grisu2(char* buf, int& len, int& decimal_exponent, FloatType value)
			{
				static_assert(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,
					"internal error: not enough precision");

				assert(std::isfinite(value));
				assert(value > 0);

				// If the neighbors (and boundaries) of 'value' are always computed for double-precision
				// numbers, all float's can be recovered using strtod (and strtof). However, the resulting
				// decimal representations are not exactly "short".
				//
				// The documentation for 'std::to_chars' (https://en.cppreference.com/w/cpp/utility/to_chars)
				// says "value is converted to a string as if by std::sprintf in the default ("C") locale"
				// and since sprintf promotes float's to double's, I think this is exactly what 'std::to_chars'
				// does.
				// On the other hand, the documentation for 'std::to_chars' requires that "parsing the
				// representation using the corresponding std::from_chars function recovers value exactly". That
				// indicates that single precision floating-point numbers should be recovered using
				// 'std::strtof'.
				//
				// NB: If the neighbors are computed for single-precision numbers, there is a single float
				//     (7.0385307e-26f) which can't be recovered using strtod. The resulting double precision
				//     value is off by 1 ulp.
#if 0
				const boundaries w = compute_boundaries(static_cast<double>(value));
#else
				const boundaries w = compute_boundaries(value);
#endif

				grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
			}

			/*!
			@brief appends a decimal representation of e to buf
			@return a pointer to the element following the exponent.
			@pre -1000 < e < 1000
			*/
			inline char* append_exponent(char* buf, int e)
			{
				assert(e > -1000);
				assert(e < 1000);

				if (e < 0)
				{
					e = -e;
					*buf++ = '-';
				}
				else
				{
					*buf++ = '+';
				}

				uint32_t k = static_cast<uint32_t>(e);
				if (k < 10)
				{
					// Always print at least two digits in the exponent.
					// This is for compatibility with printf("%g").
					*buf++ = '0';
					*buf++ = static_cast<char>('0' + k);
				}
				else if (k < 100)
				{
					*buf++ = static_cast<char>('0' + k / 10);
					k %= 10;
					*buf++ = static_cast<char>('0' + k);
				}
				else
				{
					*buf++ = static_cast<char>('0' + k / 100);
					k %= 100;
					*buf++ = static_cast<char>('0' + k / 10);
					k %= 10;
					*buf++ = static_cast<char>('0' + k);
				}

				return buf;
			}

			/*!
			@brief prettify v = buf * 10^decimal_exponent

			If v is in the range [10^min_exp, 10^max_exp) it will be printed in fixed-point
			notation. Otherwise it will be printed in exponential notation.

			@pre min_exp < 0
			@pre max_exp > 0
			*/
			inline char* format_buffer(char* buf, int len, int decimal_exponent,
				int min_exp, int max_exp)
			{
				assert(min_exp < 0);
				assert(max_exp > 0);

				const int k = len;
				const int n = len + decimal_exponent;

				// v = buf * 10^(n-k)
				// k is the length of the buffer (number of decimal digits)
				// n is the position of the decimal point relative to the start of the buffer.

				if (k <= n and n <= max_exp)
				{
					// digits[000]
					// len <= max_exp + 2

					std::memset(buf + k, '0', static_cast<size_t>(n - k));
					// Make it look like a floating-point number (#362, #378)
					buf[n + 0] = '.';
					buf[n + 1] = '0';
					return buf + (n + 2);
				}

				if (0 < n and n <= max_exp)
				{
					// dig.its
					// len <= max_digits10 + 1

					assert(k > n);

					std::memmove(buf + (n + 1), buf + n, static_cast<size_t>(k - n));
					buf[n] = '.';
					return buf + (k + 1);
				}

				if (min_exp < n and n <= 0)
				{
					// 0.[000]digits
					// len <= 2 + (-min_exp - 1) + max_digits10

					std::memmove(buf + (2 + -n), buf, static_cast<size_t>(k));
					buf[0] = '0';
					buf[1] = '.';
					std::memset(buf + 2, '0', static_cast<size_t>(-n));
					return buf + (2 + (-n) + k);
				}

				if (k == 1)
				{
					// dE+123
					// len <= 1 + 5

					buf += 1;
				}
				else
				{
					// d.igitsE+123
					// len <= max_digits10 + 1 + 5

					std::memmove(buf + 2, buf + 1, static_cast<size_t>(k - 1));
					buf[1] = '.';
					buf += 1 + k;
				}

				*buf++ = 'e';
				return append_exponent(buf, n - 1);
			}

		} // namespace dtoa_impl

		/*!
		@brief generates a decimal representation of the floating-point number value in [first, last).

		The format of the resulting decimal representation is similar to printf's %g
		format. Returns an iterator pointing past-the-end of the decimal representation.

		@note The input number must be finite, i.e. NaN's and Inf's are not supported.
		@note The buffer must be large enough.
		@note The result is NOT null-terminated.
		*/
		template <typename FloatType>
		char* to_chars(char* first, char* last, FloatType value)
		{
			static_cast<void>(last); // maybe unused - fix warning
			assert(std::isfinite(value));

			// Use signbit(value) instead of (value < 0) since signbit works for -0.
			if (std::signbit(value))
			{
				value = -value;
				*first++ = '-';
			}

			if (value == 0) // +-0
			{
				*first++ = '0';
				// Make it look like a floating-point number (#362, #378)
				*first++ = '.';
				*first++ = '0';
				return first;
			}

			assert(last - first >= std::numeric_limits<FloatType>::max_digits10);

			// Compute v = buffer * 10^decimal_exponent.
			// The decimal digits are stored in the buffer, which needs to be interpreted
			// as an unsigned decimal integer.
			// len is the length of the buffer, i.e. the number of decimal digits.
			int len = 0;
			int decimal_exponent = 0;
			dtoa_impl::grisu2(first, len, decimal_exponent, value);

			assert(len <= std::numeric_limits<FloatType>::max_digits10);

			// Format the buffer like printf("%.*g", prec, value)
			constexpr int kMinExp = -4;
			// Use digits10 here to increase compatibility with version 2.
			constexpr int kMaxExp = std::numeric_limits<FloatType>::digits10;

			assert(last - first >= kMaxExp + 2);
			assert(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
			assert(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);

			return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
		}

	} // namespace detail
} // namespace nlohmann

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	namespace detail
	{
		///////////////////
		// serialization //
		///////////////////

		template<typename BasicJsonType>
		class serializer
		{
			using string_t = typename BasicJsonType::string_t;
			using number_float_t = typename BasicJsonType::number_float_t;
			using number_integer_t = typename BasicJsonType::number_integer_t;
			using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			static constexpr uint8_t UTF8_ACCEPT = 0;
			static constexpr uint8_t UTF8_REJECT = 1;

		public:
			/*!
			@param[in] s  output stream to serialize to
			@param[in] ichar  indentation character to use
			*/
			serializer(output_adapter_t<char> s, const char ichar)
				: o(std::move(s)), loc(std::localeconv()),
				thousands_sep(loc->thousands_sep == nullptr ? '\0' : *(loc->thousands_sep)),
				decimal_point(loc->decimal_point == nullptr ? '\0' : *(loc->decimal_point)),
				indent_char(ichar), indent_string(512, indent_char)
			{}

			// delete because of pointer members
			serializer(const serializer&) = delete;
			serializer& operator=(const serializer&) = delete;

			/*!
			@brief internal implementation of the serialization function

			This function is called by the public member function dump and organizes
			the serialization internally. The indentation level is propagated as
			additional parameter. In case of arrays and objects, the function is
			called recursively.

			- strings and object keys are escaped using `escape_string()`
			- integer numbers are converted implicitly via `operator<<`
			- floating-point numbers are converted to a string using `"%g"` format

			@param[in] val             value to serialize
			@param[in] pretty_print    whether the output shall be pretty-printed
			@param[in] indent_step     the indent level
			@param[in] current_indent  the current indent level (only used internally)
			*/
			void dump(const BasicJsonType& val, const bool pretty_print,
				const bool ensure_ascii,
				const unsigned int indent_step,
				const unsigned int current_indent = 0)
			{
				switch (val.m_type)
				{
				case value_t::object:
				{
					if (val.m_value.object->empty())
					{
						o->write_characters("{}", 2);
						return;
					}

					if (pretty_print)
					{
						o->write_characters("{\n", 2);

						// variable to hold indentation for recursive calls
						const auto new_indent = current_indent + indent_step;
						if (JSON_UNLIKELY(indent_string.size() < new_indent))
						{
							indent_string.resize(indent_string.size() * 2, ' ');
						}

						// first n-1 elements
						auto i = val.m_value.object->cbegin();
						for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
						{
							o->write_characters(indent_string.c_str(), new_indent);
							o->write_character('\"');
							dump_escaped(i->first, ensure_ascii);
							o->write_characters("\": ", 3);
							dump(i->second, true, ensure_ascii, indent_step, new_indent);
							o->write_characters(",\n", 2);
						}

						// last element
						assert(i != val.m_value.object->cend());
						assert(std::next(i) == val.m_value.object->cend());
						o->write_characters(indent_string.c_str(), new_indent);
						o->write_character('\"');
						dump_escaped(i->first, ensure_ascii);
						o->write_characters("\": ", 3);
						dump(i->second, true, ensure_ascii, indent_step, new_indent);

						o->write_character('\n');
						o->write_characters(indent_string.c_str(), current_indent);
						o->write_character('}');
					}
					else
					{
						o->write_character('{');

						// first n-1 elements
						auto i = val.m_value.object->cbegin();
						for (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)
						{
							o->write_character('\"');
							dump_escaped(i->first, ensure_ascii);
							o->write_characters("\":", 2);
							dump(i->second, false, ensure_ascii, indent_step, current_indent);
							o->write_character(',');
						}

						// last element
						assert(i != val.m_value.object->cend());
						assert(std::next(i) == val.m_value.object->cend());
						o->write_character('\"');
						dump_escaped(i->first, ensure_ascii);
						o->write_characters("\":", 2);
						dump(i->second, false, ensure_ascii, indent_step, current_indent);

						o->write_character('}');
					}

					return;
				}

				case value_t::array:
				{
					if (val.m_value.array->empty())
					{
						o->write_characters("[]", 2);
						return;
					}

					if (pretty_print)
					{
						o->write_characters("[\n", 2);

						// variable to hold indentation for recursive calls
						const auto new_indent = current_indent + indent_step;
						if (JSON_UNLIKELY(indent_string.size() < new_indent))
						{
							indent_string.resize(indent_string.size() * 2, ' ');
						}

						// first n-1 elements
						for (auto i = val.m_value.array->cbegin();
							i != val.m_value.array->cend() - 1; ++i)
						{
							o->write_characters(indent_string.c_str(), new_indent);
							dump(*i, true, ensure_ascii, indent_step, new_indent);
							o->write_characters(",\n", 2);
						}

						// last element
						assert(not val.m_value.array->empty());
						o->write_characters(indent_string.c_str(), new_indent);
						dump(val.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);

						o->write_character('\n');
						o->write_characters(indent_string.c_str(), current_indent);
						o->write_character(']');
					}
					else
					{
						o->write_character('[');

						// first n-1 elements
						for (auto i = val.m_value.array->cbegin();
							i != val.m_value.array->cend() - 1; ++i)
						{
							dump(*i, false, ensure_ascii, indent_step, current_indent);
							o->write_character(',');
						}

						// last element
						assert(not val.m_value.array->empty());
						dump(val.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);

						o->write_character(']');
					}

					return;
				}

				case value_t::string:
				{
					o->write_character('\"');
					dump_escaped(*val.m_value.string, ensure_ascii);
					o->write_character('\"');
					return;
				}

				case value_t::boolean:
				{
					if (val.m_value.boolean)
					{
						o->write_characters("true", 4);
					}
					else
					{
						o->write_characters("false", 5);
					}
					return;
				}

				case value_t::number_integer:
				{
					dump_integer(val.m_value.number_integer);
					return;
				}

				case value_t::number_unsigned:
				{
					dump_integer(val.m_value.number_unsigned);
					return;
				}

				case value_t::number_float:
				{
					dump_float(val.m_value.number_float);
					return;
				}

				case value_t::discarded:
				{
					o->write_characters("<discarded>", 11);
					return;
				}

				case value_t::null:
				{
					o->write_characters("null", 4);
					return;
				}
				}
			}

		private:
			/*!
			@brief dump escaped string

			Escape a string by replacing certain special characters by a sequence of an
			escape character (backslash) and another character and other control
			characters by a sequence of "\u" followed by a four-digit hex
			representation. The escaped string is written to output stream @a o.

			@param[in] s  the string to escape
			@param[in] ensure_ascii  whether to escape non-ASCII characters with
									 \uXXXX sequences

			@complexity Linear in the length of string @a s.
			*/
			void dump_escaped(const string_t& s, const bool ensure_ascii)
			{
				uint32_t codepoint;
				uint8_t state = UTF8_ACCEPT;
				std::size_t bytes = 0;  // number of bytes written to string_buffer

				for (std::size_t i = 0; i < s.size(); ++i)
				{
					const auto byte = static_cast<uint8_t>(s[i]);

					switch (decode(state, codepoint, byte))
					{
					case UTF8_ACCEPT:  // decode found a new code point
					{
						switch (codepoint)
						{
						case 0x08: // backspace
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = 'b';
							break;
						}

						case 0x09: // SDKtal tab
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = 't';
							break;
						}

						case 0x0A: // newline
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = 'n';
							break;
						}

						case 0x0C: // formfeed
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = 'f';
							break;
						}

						case 0x0D: // carriage return
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = 'r';
							break;
						}

						case 0x22: // quotation mark
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = '\"';
							break;
						}

						case 0x5C: // reverse solidus
						{
							string_buffer[bytes++] = '\\';
							string_buffer[bytes++] = '\\';
							break;
						}

						default:
						{
							// escape control characters (0x00..0x1F) or, if
							// ensure_ascii parameter is used, non-ASCII characters
							if ((codepoint <= 0x1F) or (ensure_ascii and (codepoint >= 0x7F)))
							{
								if (codepoint <= 0xFFFF)
								{
									std::snprintf(string_buffer.data() + bytes, 7, "\\u%04x",
										static_cast<uint16_t>(codepoint));
									bytes += 6;
								}
								else
								{
									std::snprintf(string_buffer.data() + bytes, 13, "\\u%04x\\u%04x",
										static_cast<uint16_t>(0xD7C0 + (codepoint >> 10)),
										static_cast<uint16_t>(0xDC00 + (codepoint & 0x3FF)));
									bytes += 12;
								}
							}
							else
							{
								// copy byte to buffer (all previous bytes
								// been copied have in default case above)
								string_buffer[bytes++] = s[i];
							}
							break;
						}
						}

						// write buffer and reset index; there must be 13 bytes
						// left, as this is the maximal number of bytes to be
						// written ("\uxxxx\uxxxx\0") for one code point
						if (string_buffer.size() - bytes < 13)
						{
							o->write_characters(string_buffer.data(), bytes);
							bytes = 0;
						}
						break;
					}

					case UTF8_REJECT:  // decode found invalid UTF-8 byte
					{
						std::string sn(3, '\0');
						snprintf(&sn[0], sn.size(), "%.2X", byte);
						JSON_THROW(type_error::create(316, "invalid UTF-8 byte at index " + std::to_string(i) + ": 0x" + sn));
					}

					default:  // decode found yet incomplete multi-byte code point
					{
						if (not ensure_ascii)
						{
							// code point will not be escaped - copy byte to buffer
							string_buffer[bytes++] = s[i];
						}
						break;
					}
					}
				}

				if (JSON_LIKELY(state == UTF8_ACCEPT))
				{
					// write buffer
					if (bytes > 0)
					{
						o->write_characters(string_buffer.data(), bytes);
					}
				}
				else
				{
					// we finish reading, but do not accept: string was incomplete
					std::string sn(3, '\0');
					snprintf(&sn[0], sn.size(), "%.2X", static_cast<uint8_t>(s.back()));
					JSON_THROW(type_error::create(316, "incomplete UTF-8 string; last byte: 0x" + sn));
				}
			}

			/*!
			@brief dump an integer

			Dump a given integer to output stream @a o. Works internally with
			@a number_buffer.

			@param[in] x  integer number (signed or unsigned) to dump
			@tparam NumberType either @a number_integer_t or @a number_unsigned_t
			*/
			template<typename NumberType, detail::enable_if_t<
				std::is_same<NumberType, number_unsigned_t>::value or
				std::is_same<NumberType, number_integer_t>::value,
				int> = 0>
				void dump_integer(NumberType x)
			{
				// special case for "0"
				if (x == 0)
				{
					o->write_character('0');
					return;
				}

				const bool is_negative = not (x >= 0);  // see issue #755
				std::size_t i = 0;

				while (x != 0)
				{
					// spare 1 byte for '\0'
					assert(i < number_buffer.size() - 1);

					const auto digit = std::labs(static_cast<long>(x % 10));
					number_buffer[i++] = static_cast<char>('0' + digit);
					x /= 10;
				}

				if (is_negative)
				{
					// make sure there is capacity for the '-'
					assert(i < number_buffer.size() - 2);
					number_buffer[i++] = '-';
				}

				std::reverse(number_buffer.begin(), number_buffer.begin() + i);
				o->write_characters(number_buffer.data(), i);
			}

			/*!
			@brief dump a floating-point number

			Dump a given floating-point number to output stream @a o. Works internally
			with @a number_buffer.

			@param[in] x  floating-point number to dump
			*/
			void dump_float(number_float_t x)
			{
				// NaN / inf
				if (not std::isfinite(x))
				{
					o->write_characters("null", 4);
					return;
				}

				// If number_float_t is an IEEE-754 single or double precision number,
				// use the Grisu2 algorithm to produce short numbers which are
				// guaranteed to round-trip, using strtof and strtod, resp.
				//
				// NB: The test below works if <long double> == <double>.
				static constexpr bool is_ieee_single_or_double
					= (std::numeric_limits<number_float_t>::is_iec559 and std::numeric_limits<number_float_t>::digits == 24 and std::numeric_limits<number_float_t>::max_exponent == 128) or
					(std::numeric_limits<number_float_t>::is_iec559 and std::numeric_limits<number_float_t>::digits == 53 and std::numeric_limits<number_float_t>::max_exponent == 1024);

				dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());
			}

			void dump_float(number_float_t x, std::true_type /*is_ieee_single_or_double*/)
			{
				char* begin = number_buffer.data();
				char* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);

				o->write_characters(begin, static_cast<size_t>(end - begin));
			}

			void dump_float(number_float_t x, std::false_type /*is_ieee_single_or_double*/)
			{
				// get number of digits for a float -> text -> float round-trip
				static constexpr auto d = std::numeric_limits<number_float_t>::max_digits10;

				// the actual conversion
				std::ptrdiff_t len = snprintf(number_buffer.data(), number_buffer.size(), "%.*g", d, x);

				// negative value indicates an error
				assert(len > 0);
				// check if buffer was large enough
				assert(static_cast<std::size_t>(len) < number_buffer.size());

				// erase thousands separator
				if (thousands_sep != '\0')
				{
					const auto end = std::remove(number_buffer.begin(),
						number_buffer.begin() + len, thousands_sep);
					std::fill(end, number_buffer.end(), '\0');
					assert((end - number_buffer.begin()) <= len);
					len = (end - number_buffer.begin());
				}

				// convert decimal point to '.'
				if (decimal_point != '\0' and decimal_point != '.')
				{
					const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
					if (dec_pos != number_buffer.end())
					{
						*dec_pos = '.';
					}
				}

				o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));

				// determine if need to append ".0"
				const bool value_is_int_like =
					std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
						[](char c)
				{
					return (c == '.' or c == 'e');
				});

				if (value_is_int_like)
				{
					o->write_characters(".0", 2);
				}
			}

			/*!
			@brief check whether a string is UTF-8 encoded

			The function checks each byte of a string whether it is UTF-8 encoded. The
			result of the check is stored in the @a state parameter. The function must
			be called initially with state 0 (accept). State 1 means the string must
			be rejected, because the current byte is not allowed. If the string is
			completely processed, but the state is non-zero, the string ended
			prematurely; that is, the last byte indicated more bytes should have
			followed.

			@param[in,out] state  the state of the decoding
			@param[in,out] codep  codepoint (valid only if resulting state is UTF8_ACCEPT)
			@param[in] byte       next byte to decode
			@return               new state

			@note The function has been edited: a std::array is used.

			@copyright Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
			@sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
			*/
			static uint8_t decode(uint8_t& state, uint32_t& codep, const uint8_t byte) noexcept
			{
				static const std::array<uint8_t, 400> utf8d =
				{
					{
						0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1F
						0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3F
						0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5F
						0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7F
						1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9F
						7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // A0..BF
						8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // C0..DF
						0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // E0..EF
						0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // F0..FF
						0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0
						1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2
						1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4
						1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6
						1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s7..s8
					}
				};

				const uint8_t type = utf8d[byte];

				codep = (state != UTF8_ACCEPT)
					? (byte & 0x3fu) | (codep << 6)
					: static_cast<uint32_t>(0xff >> type) & (byte);

				state = utf8d[256u + state * 16u + type];
				return state;
			}

		private:
			/// the output of the serializer
			output_adapter_t<char> o = nullptr;

			/// a (hopefully) large enough character buffer
			std::array<char, 64> number_buffer{ {} };

			/// the locale
			const std::lconv* loc = nullptr;
			/// the locale's thousand separator character
			const char thousands_sep = '\0';
			/// the locale's decimal point character
			const char decimal_point = '\0';

			/// string buffer
			std::array<char, 512> string_buffer{ {} };

			/// the indentation character
			const char indent_char;
			/// the indentation string
			string_t indent_string;
		};
	}
}

// #include <nlohmann/detail/json_ref.hpp>


#include <initializer_list>
#include <utility>

namespace nlohmann
{
	namespace detail
	{
		template<typename BasicJsonType>
		class json_ref
		{
		public:
			using value_type = BasicJsonType;

			json_ref(value_type&& value)
				: owned_value(std::move(value)), value_ref(&owned_value), is_rvalue(true)
			{}

			json_ref(const value_type& value)
				: value_ref(const_cast<value_type*>(&value)), is_rvalue(false)
			{}

			json_ref(std::initializer_list<json_ref> init)
				: owned_value(init), value_ref(&owned_value), is_rvalue(true)
			{}

			template<class... Args>
			json_ref(Args&& ... args)
				: owned_value(std::forward<Args>(args)...), value_ref(&owned_value), is_rvalue(true)
			{}

			// class should be movable only
			json_ref(json_ref&&) = default;
			json_ref(const json_ref&) = delete;
			json_ref& operator=(const json_ref&) = delete;

			value_type moved_or_copied() const
			{
				if (is_rvalue)
				{
					return std::move(*value_ref);
				}
				return *value_ref;
			}

			value_type const& operator*() const
			{
				return *static_cast<value_type const*>(value_ref);
			}

			value_type const* operator->() const
			{
				return static_cast<value_type const*>(value_ref);
			}

		private:
			mutable value_type owned_value = nullptr;
			value_type* value_ref = nullptr;
			const bool is_rvalue;
		};
	}
}

// #include <nlohmann/detail/json_pointer.hpp>


#include <cassert> // assert
#include <numeric> // accumulate
#include <string> // string
#include <vector> // vector

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/value_t.hpp>


namespace nlohmann
{
	template<typename BasicJsonType>
	class json_pointer
	{
		// allow basic_json to access private members
		NLOHMANN_BASIC_JSON_TPL_DECLARATION
			friend class basic_json;

	public:
		/*!
		@brief create JSON pointer

		Create a JSON pointer according to the syntax described in
		[Section 3 of RFC6901](https://tools.ietf.org/html/rfc6901#section-3).

		@param[in] s  string representing the JSON pointer; if omitted, the empty
					  string is assumed which references the whole JSON value

		@throw parse_error.107 if the given JSON pointer @a s is nonempty and does
							   not begin with a slash (`/`); see example below

		@throw parse_error.108 if a tilde (`~`) in the given JSON pointer @a s is
		not followed by `0` (representing `~`) or `1` (representing `/`); see
		example below

		@liveexample{The example shows the construction several valid JSON pointers
		as well as the exceptional behavior.,json_pointer}

		@since version 2.0.0
		*/
		explicit json_pointer(const std::string& s = "")
			: reference_tokens(split(s))
		{}

		/*!
		@brief return a string representation of the JSON pointer

		@invariant For each JSON pointer `ptr`, it holds:
		@code {.cpp}
		ptr == json_pointer(ptr.to_string());
		@endcode

		@return a string representation of the JSON pointer

		@liveexample{The example shows the result of `to_string`.,
		json_pointer__to_string}

		@since version 2.0.0
		*/
		std::string to_string() const noexcept
		{
			return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
				std::string{},
				[](const std::string & a, const std::string & b)
			{
				return a + "/" + escape(b);
			});
		}

		/// @copydoc to_string()
		operator std::string() const
		{
			return to_string();
		}

		/*!
		@param[in] s  reference token to be converted into an array index

		@return integer representation of @a s

		@throw out_of_range.404 if string @a s could not be converted to an integer
		*/
		static int array_index(const std::string& s)
		{
			std::size_t processed_chars = 0;
			const int res = std::stoi(s, &processed_chars);

			// check if the string was completely read
			if (JSON_UNLIKELY(processed_chars != s.size()))
			{
				JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + s + "'"));
			}

			return res;
		}

	private:
		/*!
		@brief remove and return last reference pointer
		@throw out_of_range.405 if JSON pointer has no parent
		*/
		std::string pop_back()
		{
			if (JSON_UNLIKELY(is_root()))
			{
				JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
			}

			auto last = reference_tokens.back();
			reference_tokens.pop_back();
			return last;
		}

		/// return whether pointer points to the root document
		bool is_root() const
		{
			return reference_tokens.empty();
		}

		json_pointer top() const
		{
			if (JSON_UNLIKELY(is_root()))
			{
				JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent"));
			}

			json_pointer result = *this;
			result.reference_tokens = { reference_tokens[0] };
			return result;
		}

		/*!
		@brief create and return a reference to the pointed to value

		@complexity Linear in the number of reference tokens.

		@throw parse_error.109 if array index is not a number
		@throw type_error.313 if value cannot be unflattened
		*/
		BasicJsonType& get_and_create(BasicJsonType& j) const
		{
			using size_type = typename BasicJsonType::size_type;
			auto result = &j;

			// in case no reference tokens exist, return a reference to the JSON value
			// j which will be overwritten by a primitive value
			for (const auto& reference_token : reference_tokens)
			{
				switch (result->m_type)
				{
				case detail::value_t::null:
				{
					if (reference_token == "0")
					{
						// start a new array if reference token is 0
						result = &result->operator[](0);
					}
					else
					{
						// start a new object otherwise
						result = &result->operator[](reference_token);
					}
					break;
				}

				case detail::value_t::object:
				{
					// create an entry in the object
					result = &result->operator[](reference_token);
					break;
				}

				case detail::value_t::array:
				{
					// create an entry in the array
					JSON_TRY
					{
						result = &result->operator[](static_cast<size_type>(array_index(reference_token)));
					}
						JSON_CATCH(std::invalid_argument&)
					{
						JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
					}
					break;
				}

				/*
				The following code is only reached if there exists a reference
				token _and_ the current value is primitive. In this case, we have
				an error situation, because primitive values may only occur as
				single value; that is, with an empty list of reference tokens.
				*/
				default:
					JSON_THROW(detail::type_error::create(313, "invalid value to unflatten"));
				}
			}

			return *result;
		}

		/*!
		@brief return a reference to the pointed to value

		@note This version does not throw if a value is not present, but tries to
			  create nested values instead. For instance, calling this function
			  with pointer `"/this/that"` on a null value is equivalent to calling
			  `operator[]("this").operator[]("that")` on that value, effectively
			  changing the null value to an object.

		@param[in] ptr  a JSON value

		@return reference to the JSON value pointed to by the JSON pointer

		@complexity Linear in the length of the JSON pointer.

		@throw parse_error.106   if an array index begins with '0'
		@throw parse_error.109   if an array index was not a number
		@throw out_of_range.404  if the JSON pointer can not be resolved
		*/
		BasicJsonType& get_unchecked(BasicJsonType* ptr) const
		{
			using size_type = typename BasicJsonType::size_type;
			for (const auto& reference_token : reference_tokens)
			{
				// convert null values to arrays or objects before continuing
				if (ptr->m_type == detail::value_t::null)
				{
					// check if reference token is a number
					const bool nums =
						std::all_of(reference_token.begin(), reference_token.end(),
							[](const char x)
					{
						return (x >= '0' and x <= '9');
					});

					// change value to array for numbers or "-" or to object otherwise
					*ptr = (nums or reference_token == "-")
						? detail::value_t::array
						: detail::value_t::object;
				}

				switch (ptr->m_type)
				{
				case detail::value_t::object:
				{
					// use unchecked object access
					ptr = &ptr->operator[](reference_token);
					break;
				}

				case detail::value_t::array:
				{
					// error condition (cf. RFC 6901, Sect. 4)
					if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
					{
						JSON_THROW(detail::parse_error::create(106, 0,
							"array index '" + reference_token +
							"' must not begin with '0'"));
					}

					if (reference_token == "-")
					{
						// explicitly treat "-" as index beyond the end
						ptr = &ptr->operator[](ptr->m_value.array->size());
					}
					else
					{
						// convert array index to number; unchecked access
						JSON_TRY
						{
							ptr = &ptr->operator[](
								static_cast<size_type>(array_index(reference_token)));
						}
							JSON_CATCH(std::invalid_argument&)
						{
							JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
						}
					}
					break;
				}

				default:
					JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
				}
			}

			return *ptr;
		}

		/*!
		@throw parse_error.106   if an array index begins with '0'
		@throw parse_error.109   if an array index was not a number
		@throw out_of_range.402  if the array index '-' is used
		@throw out_of_range.404  if the JSON pointer can not be resolved
		*/
		BasicJsonType& get_checked(BasicJsonType* ptr) const
		{
			using size_type = typename BasicJsonType::size_type;
			for (const auto& reference_token : reference_tokens)
			{
				switch (ptr->m_type)
				{
				case detail::value_t::object:
				{
					// note: at performs range check
					ptr = &ptr->at(reference_token);
					break;
				}

				case detail::value_t::array:
				{
					if (JSON_UNLIKELY(reference_token == "-"))
					{
						// "-" always fails the range check
						JSON_THROW(detail::out_of_range::create(402,
							"array index '-' (" + std::to_string(ptr->m_value.array->size()) +
							") is out of range"));
					}

					// error condition (cf. RFC 6901, Sect. 4)
					if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
					{
						JSON_THROW(detail::parse_error::create(106, 0,
							"array index '" + reference_token +
							"' must not begin with '0'"));
					}

					// note: at performs range check
					JSON_TRY
					{
						ptr = &ptr->at(static_cast<size_type>(array_index(reference_token)));
					}
						JSON_CATCH(std::invalid_argument&)
					{
						JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
					}
					break;
				}

				default:
					JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
				}
			}

			return *ptr;
		}

		/*!
		@brief return a const reference to the pointed to value

		@param[in] ptr  a JSON value

		@return const reference to the JSON value pointed to by the JSON
		pointer

		@throw parse_error.106   if an array index begins with '0'
		@throw parse_error.109   if an array index was not a number
		@throw out_of_range.402  if the array index '-' is used
		@throw out_of_range.404  if the JSON pointer can not be resolved
		*/
		const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
		{
			using size_type = typename BasicJsonType::size_type;
			for (const auto& reference_token : reference_tokens)
			{
				switch (ptr->m_type)
				{
				case detail::value_t::object:
				{
					// use unchecked object access
					ptr = &ptr->operator[](reference_token);
					break;
				}

				case detail::value_t::array:
				{
					if (JSON_UNLIKELY(reference_token == "-"))
					{
						// "-" cannot be used for const access
						JSON_THROW(detail::out_of_range::create(402,
							"array index '-' (" + std::to_string(ptr->m_value.array->size()) +
							") is out of range"));
					}

					// error condition (cf. RFC 6901, Sect. 4)
					if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
					{
						JSON_THROW(detail::parse_error::create(106, 0,
							"array index '" + reference_token +
							"' must not begin with '0'"));
					}

					// use unchecked array access
					JSON_TRY
					{
						ptr = &ptr->operator[](
							static_cast<size_type>(array_index(reference_token)));
					}
						JSON_CATCH(std::invalid_argument&)
					{
						JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
					}
					break;
				}

				default:
					JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
				}
			}

			return *ptr;
		}

		/*!
		@throw parse_error.106   if an array index begins with '0'
		@throw parse_error.109   if an array index was not a number
		@throw out_of_range.402  if the array index '-' is used
		@throw out_of_range.404  if the JSON pointer can not be resolved
		*/
		const BasicJsonType& get_checked(const BasicJsonType* ptr) const
		{
			using size_type = typename BasicJsonType::size_type;
			for (const auto& reference_token : reference_tokens)
			{
				switch (ptr->m_type)
				{
				case detail::value_t::object:
				{
					// note: at performs range check
					ptr = &ptr->at(reference_token);
					break;
				}

				case detail::value_t::array:
				{
					if (JSON_UNLIKELY(reference_token == "-"))
					{
						// "-" always fails the range check
						JSON_THROW(detail::out_of_range::create(402,
							"array index '-' (" + std::to_string(ptr->m_value.array->size()) +
							") is out of range"));
					}

					// error condition (cf. RFC 6901, Sect. 4)
					if (JSON_UNLIKELY(reference_token.size() > 1 and reference_token[0] == '0'))
					{
						JSON_THROW(detail::parse_error::create(106, 0,
							"array index '" + reference_token +
							"' must not begin with '0'"));
					}

					// note: at performs range check
					JSON_TRY
					{
						ptr = &ptr->at(static_cast<size_type>(array_index(reference_token)));
					}
						JSON_CATCH(std::invalid_argument&)
					{
						JSON_THROW(detail::parse_error::create(109, 0, "array index '" + reference_token + "' is not a number"));
					}
					break;
				}

				default:
					JSON_THROW(detail::out_of_range::create(404, "unresolved reference token '" + reference_token + "'"));
				}
			}

			return *ptr;
		}

		/*!
		@brief split the string input to reference tokens

		@note This function is only called by the json_pointer constructor.
			  All exceptions below are documented there.

		@throw parse_error.107  if the pointer is not empty or begins with '/'
		@throw parse_error.108  if character '~' is not followed by '0' or '1'
		*/
		static std::vector<std::string> split(const std::string& reference_string)
		{
			std::vector<std::string> result;

			// special case: empty reference string -> no reference tokens
			if (reference_string.empty())
			{
				return result;
			}

			// check if nonempty reference string begins with slash
			if (JSON_UNLIKELY(reference_string[0] != '/'))
			{
				JSON_THROW(detail::parse_error::create(107, 1,
					"JSON pointer must be empty or begin with '/' - was: '" +
					reference_string + "'"));
			}

			// extract the reference tokens:
			// - slash: position of the last read slash (or end of string)
			// - start: position after the previous slash
			for (
				// search for the first slash after the first character
				std::size_t slash = reference_string.find_first_of('/', 1),
				// set the beginning of the first reference token
				start = 1;
				// we can stop if start == string::npos+1 = 0
				start != 0;
				// set the beginning of the next reference token
				// (will eventually be 0 if slash == std::string::npos)
				start = slash + 1,
				// find next slash
				slash = reference_string.find_first_of('/', start))
			{
				// use the text between the beginning of the reference token
				// (start) and the last slash (slash).
				auto reference_token = reference_string.substr(start, slash - start);

				// check reference tokens are properly escaped
				for (std::size_t pos = reference_token.find_first_of('~');
					pos != std::string::npos;
					pos = reference_token.find_first_of('~', pos + 1))
				{
					assert(reference_token[pos] == '~');

					// ~ must be followed by 0 or 1
					if (JSON_UNLIKELY(pos == reference_token.size() - 1 or
						(reference_token[pos + 1] != '0' and
							reference_token[pos + 1] != '1')))
					{
						JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'"));
					}
				}

				// finally, store the reference token
				unescape(reference_token);
				result.push_back(reference_token);
			}

			return result;
		}

		/*!
		@brief replace all occurrences of a substring by another string

		@param[in,out] s  the string to manipulate; changed so that all
					   occurrences of @a f are replaced with @a t
		@param[in]     f  the substring to replace with @a t
		@param[in]     t  the string to replace @a f

		@pre The search string @a f must not be empty. **This precondition is
		enforced with an assertion.**

		@since version 2.0.0
		*/
		static void replace_substring(std::string& s, const std::string& f,
			const std::string& t)
		{
			assert(not f.empty());
			for (auto pos = s.find(f);                // find first occurrence of f
				pos != std::string::npos;         // make sure f was found
				s.replace(pos, f.size(), t),      // replace with t, and
				pos = s.find(f, pos + t.size()))  // find next occurrence of f
			{
			}
		}

		/// escape "~"" to "~0" and "/" to "~1"
		static std::string escape(std::string s)
		{
			replace_substring(s, "~", "~0");
			replace_substring(s, "/", "~1");
			return s;
		}

		/// unescape "~1" to tilde and "~0" to slash (order is important!)
		static void unescape(std::string& s)
		{
			replace_substring(s, "~1", "/");
			replace_substring(s, "~0", "~");
		}

		/*!
		@param[in] reference_string  the reference string to the current value
		@param[in] value             the value to consider
		@param[in,out] result        the result object to insert values to

		@note Empty objects or arrays are flattened to `null`.
		*/
		static void flatten(const std::string& reference_string,
			const BasicJsonType& value,
			BasicJsonType& result)
		{
			switch (value.m_type)
			{
			case detail::value_t::array:
			{
				if (value.m_value.array->empty())
				{
					// flatten empty array as null
					result[reference_string] = nullptr;
				}
				else
				{
					// iterate array and use index as reference string
					for (std::size_t i = 0; i < value.m_value.array->size(); ++i)
					{
						flatten(reference_string + "/" + std::to_string(i),
							value.m_value.array->operator[](i), result);
					}
				}
				break;
			}

			case detail::value_t::object:
			{
				if (value.m_value.object->empty())
				{
					// flatten empty object as null
					result[reference_string] = nullptr;
				}
				else
				{
					// iterate object and use keys as reference string
					for (const auto& element : *value.m_value.object)
					{
						flatten(reference_string + "/" + escape(element.first), element.second, result);
					}
				}
				break;
			}

			default:
			{
				// add primitive value with its reference string
				result[reference_string] = value;
				break;
			}
			}
		}

		/*!
		@param[in] value  flattened JSON

		@return unflattened JSON

		@throw parse_error.109 if array index is not a number
		@throw type_error.314  if value is not an object
		@throw type_error.315  if object values are not primitive
		@throw type_error.313  if value cannot be unflattened
		*/
		static BasicJsonType
			unflatten(const BasicJsonType& value)
		{
			if (JSON_UNLIKELY(not value.is_object()))
			{
				JSON_THROW(detail::type_error::create(314, "only objects can be unflattened"));
			}

			BasicJsonType result;

			// iterate the JSON object values
			for (const auto& element : *value.m_value.object)
			{
				if (JSON_UNLIKELY(not element.second.is_primitive()))
				{
					JSON_THROW(detail::type_error::create(315, "values in object must be primitive"));
				}

				// assign value to reference pointed to by JSON pointer; Note that if
				// the JSON pointer is "" (i.e., points to the whole value), function
				// get_and_create returns a reference to result itself. An assignment
				// will then create a primitive value.
				json_pointer(element.first).get_and_create(result) = element.second;
			}

			return result;
		}

		friend bool operator==(json_pointer const& lhs,
			json_pointer const& rhs) noexcept
		{
			return (lhs.reference_tokens == rhs.reference_tokens);
		}

		friend bool operator!=(json_pointer const& lhs,
			json_pointer const& rhs) noexcept
		{
			return not (lhs == rhs);
		}

		/// the reference tokens
		std::vector<std::string> reference_tokens;
	};
}

// #include <nlohmann/adl_serializer.hpp>


#include <utility>

// #include <nlohmann/detail/conversions/from_json.hpp>

// #include <nlohmann/detail/conversions/to_json.hpp>


namespace nlohmann
{
	template<typename, typename>
	struct adl_serializer
	{
		/*!
		@brief convert a JSON value to any value type

		This function is usually called by the `get()` function of the
		@ref basic_json class (either explicit or via conversion operators).

		@param[in] j         JSON value to read from
		@param[in,out] val  value to write to
		*/
		template<typename BasicJsonType, typename ValueType>
		static auto from_json(BasicJsonType&& j, ValueType& val) noexcept(
			noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val))) -> decltype(
				::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void()
				)
		{
			::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
		}

		/*!
		@brief convert any value type to a JSON value

		This function is usually called by the constructors of the @ref basic_json
		class.

		@param[in,out] j  JSON value to write to
		@param[in] val     value to read from
		*/
		template <typename BasicJsonType, typename ValueType>
		static auto to_json(BasicJsonType& j, ValueType&& val) noexcept(
			noexcept(::nlohmann::to_json(j, std::forward<ValueType>(val))))
			-> decltype(::nlohmann::to_json(j, std::forward<ValueType>(val)),
				void())
		{
			::nlohmann::to_json(j, std::forward<ValueType>(val));
		}
	};
}


/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
namespace nlohmann
{

	/*!
	@brief a class to store JSON values

	@tparam ObjectType type for JSON objects (`std::map` by default; will be used
	in @ref object_t)
	@tparam ArrayType type for JSON arrays (`std::vector` by default; will be used
	in @ref array_t)
	@tparam StringType type for JSON strings and object keys (`std::string` by
	default; will be used in @ref string_t)
	@tparam BooleanType type for JSON booleans (`bool` by default; will be used
	in @ref boolean_t)
	@tparam NumberIntegerType type for JSON integer numbers (`int64_t` by
	default; will be used in @ref number_integer_t)
	@tparam NumberUnsignedType type for JSON unsigned integer numbers (@c
	`uint64_t` by default; will be used in @ref number_unsigned_t)
	@tparam NumberFloatType type for JSON floating-point numbers (`double` by
	default; will be used in @ref number_float_t)
	@tparam AllocatorType type of the allocator to use (`std::allocator` by
	default)
	@tparam JSONSerializer the serializer to resolve internal calls to `to_json()`
	and `from_json()` (@ref adl_serializer by default)

	@requirement The class satisfies the following concept requirements:
	- Basic
	 - [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible):
	   JSON values can be default constructed. The result will be a JSON null
	   value.
	 - [MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible):
	   A JSON value can be constructed from an rvalue argument.
	 - [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible):
	   A JSON value can be copy-constructed from an lvalue expression.
	 - [MoveAssignable](https://en.cppreference.com/w/cpp/named_req/MoveAssignable):
	   A JSON value van be assigned from an rvalue argument.
	 - [CopyAssignable](https://en.cppreference.com/w/cpp/named_req/CopyAssignable):
	   A JSON value can be copy-assigned from an lvalue expression.
	 - [Destructible](https://en.cppreference.com/w/cpp/named_req/Destructible):
	   JSON values can be destructed.
	- Layout
	 - [StandardLayoutType](https://en.cppreference.com/w/cpp/named_req/StandardLayoutType):
	   JSON values have
	   [standard layout](https://en.cppreference.com/w/cpp/language/data_members#Standard_layout):
	   All non-static data members are private and standard layout types, the
	   class has no virtual functions or (virtual) base classes.
	- Library-wide
	 - [EqualityComparable](https://en.cppreference.com/w/cpp/named_req/EqualityComparable):
	   JSON values can be compared with `==`, see @ref
	   operator==(const_reference,const_reference).
	 - [LessThanComparable](https://en.cppreference.com/w/cpp/named_req/LessThanComparable):
	   JSON values can be compared with `<`, see @ref
	   operator<(const_reference,const_reference).
	 - [Swappable](https://en.cppreference.com/w/cpp/named_req/Swappable):
	   Any JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of
	   other compatible types, using unqualified function call @ref swap().
	 - [NullablePointer](https://en.cppreference.com/w/cpp/named_req/NullablePointer):
	   JSON values can be compared against `std::nullptr_t` objects which are used
	   to model the `null` value.
	- Container
	 - [Container](https://en.cppreference.com/w/cpp/named_req/Container):
	   JSON values can be used like STL containers and provide iterator access.
	 - [ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer);
	   JSON values can be used like STL containers and provide reverse iterator
	   access.

	@invariant The member variables @a m_value and @a m_type have the following
	relationship:
	- If `m_type == value_t::object`, then `m_value.object != nullptr`.
	- If `m_type == value_t::array`, then `m_value.array != nullptr`.
	- If `m_type == value_t::string`, then `m_value.string != nullptr`.
	The invariants are checked by member function assert_invariant().

	@internal
	@note ObjectType trick from http://stackoverflow.com/a/9860911
	@endinternal

	@see [RFC 7159: The JavaScript Object Notation (JSON) Data Interchange
	Format](http://rfc7159.net/rfc7159)

	@since version 1.0.0

	@nosubgrouping
	*/
	NLOHMANN_BASIC_JSON_TPL_DECLARATION
		class basic_json
	{
	private:
		template<detail::value_t> friend struct detail::external_constructor;
		friend ::nlohmann::json_pointer<basic_json>;
		friend ::nlohmann::detail::parser<basic_json>;
		friend ::nlohmann::detail::serializer<basic_json>;
		template<typename BasicJsonType>
		friend class ::nlohmann::detail::iter_impl;
		template<typename BasicJsonType, typename CharType>
		friend class ::nlohmann::detail::binary_writer;
		template<typename BasicJsonType, typename SAX>
		friend class ::nlohmann::detail::binary_reader;
		template<typename BasicJsonType>
		friend class ::nlohmann::detail::json_sax_dom_parser;
		template<typename BasicJsonType>
		friend class ::nlohmann::detail::json_sax_dom_callback_parser;

		/// workaround type for MSVC
		using basic_json_t = NLOHMANN_BASIC_JSON_TPL;

		// convenience aliases for types residing in namespace detail;
		using lexer = ::nlohmann::detail::lexer<basic_json>;
		using parser = ::nlohmann::detail::parser<basic_json>;

		using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
		template<typename BasicJsonType>
		using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
		template<typename BasicJsonType>
		using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
		template<typename Iterator>
		using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
		template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;

		template<typename CharType>
		using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;

		using binary_reader = ::nlohmann::detail::binary_reader<basic_json>;
		template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;

		using serializer = ::nlohmann::detail::serializer<basic_json>;

	public:
		using value_t = detail::value_t;
		/// JSON Pointer, see @ref nlohmann::json_pointer
		using json_pointer = ::nlohmann::json_pointer<basic_json>;
		template<typename T, typename SFINAE>
		using json_serializer = JSONSerializer<T, SFINAE>;
		/// helper type for initializer lists of basic_json values
		using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;

		using input_format_t = detail::input_format_t;
		/// SAX interface type, see @ref nlohmann::json_sax
		using json_sax_t = json_sax<basic_json>;

		////////////////
		// exceptions //
		////////////////

		/// @name exceptions
		/// Classes to implement user-defined exceptions.
		/// @{

		/// @copydoc detail::exception
		using exception = detail::exception;
		/// @copydoc detail::parse_error
		using parse_error = detail::parse_error;
		/// @copydoc detail::invalid_iterator
		using invalid_iterator = detail::invalid_iterator;
		/// @copydoc detail::type_error
		using type_error = detail::type_error;
		/// @copydoc detail::out_of_range
		using out_of_range = detail::out_of_range;
		/// @copydoc detail::other_error
		using other_error = detail::other_error;

		/// @}


		/////////////////////
		// container types //
		/////////////////////

		/// @name container types
		/// The canonic container types to use @ref basic_json like any other STL
		/// container.
		/// @{

		/// the type of elements in a basic_json container
		using value_type = basic_json;

		/// the type of an element reference
		using reference = value_type & ;
		/// the type of an element const reference
		using const_reference = const value_type&;

		/// a type to represent differences between iterators
		using difference_type = std::ptrdiff_t;
		/// a type to represent container sizes
		using size_type = std::size_t;

		/// the allocator type
		using allocator_type = AllocatorType<basic_json>;

		/// the type of an element pointer
		using pointer = typename std::allocator_traits<allocator_type>::pointer;
		/// the type of an element const pointer
		using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;

		/// an iterator for a basic_json container
		using iterator = iter_impl<basic_json>;
		/// a const iterator for a basic_json container
		using const_iterator = iter_impl<const basic_json>;
		/// a reverse iterator for a basic_json container
		using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
		/// a const reverse iterator for a basic_json container
		using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;

		/// @}


		/*!
		@brief returns the allocator associated with the container
		*/
		static allocator_type get_allocator()
		{
			return allocator_type();
		}

		/*!
		@brief returns version information on the library

		This function returns a JSON object with information about the library,
		including the version number and information on the platform and compiler.

		@return JSON object holding version information
		key         | description
		----------- | ---------------
		`compiler`  | Information on the used compiler. It is an object with the following keys: `c++` (the used C++ standard), `family` (the compiler family; possible values are `clang`, `icc`, `gcc`, `ilecpp`, `msvc`, `pgcpp`, `sunpro`, and `unknown`), and `version` (the compiler version).
		`copyright` | The copyright line for the library as string.
		`name`      | The name of the library as string.
		`platform`  | The used platform as string. Possible values are `win32`, `linux`, `apple`, `unix`, and `unknown`.
		`url`       | The URL of the project as string.
		`version`   | The version of the library. It is an object with the following keys: `major`, `minor`, and `patch` as defined by [Semantic Versioning](http://semver.org), and `string` (the version string).

		@liveexample{The following code shows an example output of the `meta()`
		function.,meta}

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@complexity Constant.

		@since 2.1.0
		*/
		static basic_json meta()
		{
			basic_json result;

			result["copyright"] = "(C) 2013-2017 Niels Lohmann";
			result["name"] = "JSON for Modern C++";
			result["url"] = "https://github.com/nlohmann/json";
			result["version"]["string"] =
				std::to_string(NLOHMANN_JSON_VERSION_MAJOR) + "." +
				std::to_string(NLOHMANN_JSON_VERSION_MINOR) + "." +
				std::to_string(NLOHMANN_JSON_VERSION_PATCH);
			result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
			result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
			result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;

#ifdef _WIN32
			result["platform"] = "win32";
#elif defined __linux__
			result["platform"] = "linux";
#elif defined __APPLE__
			result["platform"] = "apple";
#elif defined __unix__
			result["platform"] = "unix";
#else
			result["platform"] = "unknown";
#endif

#if defined(__ICC) || defined(__INTEL_COMPILER)
			result["compiler"] = { {"family", "icc"}, {"version", __INTEL_COMPILER} };
#elif defined(__clang__)
			result["compiler"] = { {"family", "clang"}, {"version", __clang_version__} };
#elif defined(__GNUC__) || defined(__GNUG__)
			result["compiler"] = { {"family", "gcc"}, {"version", std::to_string(__GNUC__) + "." + std::to_string(__GNUC_MINOR__) + "." + std::to_string(__GNUC_PATCHLEVEL__)} };
#elif defined(__HP_cc) || defined(__HP_aCC)
			result["compiler"] = "hp"
#elif defined(__IBMCPP__)
			result["compiler"] = { {"family", "ilecpp"}, {"version", __IBMCPP__} };
#elif defined(_MSC_VER)
			result["compiler"] = { {"family", "msvc"}, {"version", _MSC_VER} };
#elif defined(__PGI)
			result["compiler"] = { {"family", "pgcpp"}, {"version", __PGI} };
#elif defined(__SUNPRO_CC)
			result["compiler"] = { {"family", "sunpro"}, {"version", __SUNPRO_CC} };
#else
			result["compiler"] = { {"family", "unknown"}, {"version", "unknown"} };
#endif

#ifdef __cplusplus
			result["compiler"]["c++"] = std::to_string(__cplusplus);
#else
			result["compiler"]["c++"] = "unknown";
#endif
			return result;
		}


		///////////////////////////
		// JSON value data types //
		///////////////////////////

		/// @name JSON value data types
		/// The data types to store a JSON value. These types are derived from
		/// the template arguments passed to class @ref basic_json.
		/// @{

#if defined(JSON_HAS_CPP_14)
	// Use transparent comparator if possible, combined with perfect forwarding
	// on find() and count() calls prevents unnecessary string construction.
		using object_comparator_t = std::less<>;
#else
		using object_comparator_t = std::less<StringType>;
#endif

		/*!
		@brief a type for an object

		[RFC 7159](http://rfc7159.net/rfc7159) describes JSON objects as follows:
		> An object is an unordered collection of zero or more name/value pairs,
		> where a name is a string and a value is a string, number, boolean, null,
		> object, or array.

		To store objects in C++, a type is defined by the template parameters
		described below.

		@tparam ObjectType  the container to store objects (e.g., `std::map` or
		`std::unordered_map`)
		@tparam StringType the type of the keys or names (e.g., `std::string`).
		The comparison function `std::less<StringType>` is used to order elements
		inside the container.
		@tparam AllocatorType the allocator to use for objects (e.g.,
		`std::allocator`)

		#### Default type

		With the default values for @a ObjectType (`std::map`), @a StringType
		(`std::string`), and @a AllocatorType (`std::allocator`), the default
		value for @a object_t is:

		@code {.cpp}
		std::map<
		  std::string, // key_type
		  basic_json, // value_type
		  std::less<std::string>, // key_compare
		  std::allocator<std::pair<const std::string, basic_json>> // allocator_type
		>
		@endcode

		#### Behavior

		The choice of @a object_t influences the behavior of the JSON class. With
		the default type, objects have the following behavior:

		- When all names are unique, objects will be interoperable in the sense
		  that all software implementations receiving that object will agree on
		  the name-value mappings.
		- When the names within an object are not unique, it is unspecified which
		  one of the values for a given key will be chosen. For instance,
		  `{"key": 2, "key": 1}` could be equal to either `{"key": 1}` or
		  `{"key": 2}`.
		- Internally, name/value pairs are stored in lexicographical order of the
		  names. Objects will also be serialized (see @ref dump) in this order.
		  For instance, `{"b": 1, "a": 2}` and `{"a": 2, "b": 1}` will be stored
		  and serialized as `{"a": 2, "b": 1}`.
		- When comparing objects, the order of the name/value pairs is irrelevant.
		  This makes objects interoperable in the sense that they will not be
		  affected by these differences. For instance, `{"b": 1, "a": 2}` and
		  `{"a": 2, "b": 1}` will be treated as equal.

		#### Limits

		[RFC 7159](http://rfc7159.net/rfc7159) specifies:
		> An implementation may set limits on the maximum depth of nesting.

		In this class, the object's limit of nesting is not explicitly constrained.
		However, a maximum depth of nesting may be introduced by the compiler or
		runtime environment. A theoretical limit can be queried by calling the
		@ref max_size function of a JSON object.

		#### Storage

		Objects are stored as pointers in a @ref basic_json type. That is, for any
		access to object values, a pointer of type `object_t*` must be
		dereferenced.

		@sa @ref array_t -- type for an array value

		@since version 1.0.0

		@note The order name/value pairs are added to the object is *not*
		preserved by the library. Therefore, iterating an object may return
		name/value pairs in a different order than they were originally stored. In
		fact, keys will be traversed in alphabetical order as `std::map` with
		`std::less` is used by default. Please note this behavior conforms to [RFC
		7159](http://rfc7159.net/rfc7159), because any order implements the
		specified "unordered" nature of JSON objects.
		*/
		using object_t = ObjectType<StringType,
			basic_json,
			object_comparator_t,
			AllocatorType<std::pair<const StringType,
			basic_json>>>;

		/*!
		@brief a type for an array

		[RFC 7159](http://rfc7159.net/rfc7159) describes JSON arrays as follows:
		> An array is an ordered sequence of zero or more values.

		To store objects in C++, a type is defined by the template parameters
		explained below.

		@tparam ArrayType  container type to store arrays (e.g., `std::vector` or
		`std::list`)
		@tparam AllocatorType allocator to use for arrays (e.g., `std::allocator`)

		#### Default type

		With the default values for @a ArrayType (`std::vector`) and @a
		AllocatorType (`std::allocator`), the default value for @a array_t is:

		@code {.cpp}
		std::vector<
		  basic_json, // value_type
		  std::allocator<basic_json> // allocator_type
		>
		@endcode

		#### Limits

		[RFC 7159](http://rfc7159.net/rfc7159) specifies:
		> An implementation may set limits on the maximum depth of nesting.

		In this class, the array's limit of nesting is not explicitly constrained.
		However, a maximum depth of nesting may be introduced by the compiler or
		runtime environment. A theoretical limit can be queried by calling the
		@ref max_size function of a JSON array.

		#### Storage

		Arrays are stored as pointers in a @ref basic_json type. That is, for any
		access to array values, a pointer of type `array_t*` must be dereferenced.

		@sa @ref object_t -- type for an object value

		@since version 1.0.0
		*/
		using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;

		/*!
		@brief a type for a string

		[RFC 7159](http://rfc7159.net/rfc7159) describes JSON strings as follows:
		> A string is a sequence of zero or more Unicode characters.

		To store objects in C++, a type is defined by the template parameter
		described below. Unicode values are split by the JSON class into
		byte-sized characters during deserialization.

		@tparam StringType  the container to store strings (e.g., `std::string`).
		Note this container is used for keys/names in objects, see @ref object_t.

		#### Default type

		With the default values for @a StringType (`std::string`), the default
		value for @a string_t is:

		@code {.cpp}
		std::string
		@endcode

		#### Encoding

		Strings are stored in UTF-8 encoding. Therefore, functions like
		`std::string::size()` or `std::string::length()` return the number of
		bytes in the string rather than the number of characters or glyphs.

		#### String comparison

		[RFC 7159](http://rfc7159.net/rfc7159) states:
		> Software implementations are typically required to test names of object
		> members for equality. Implementations that transform the textual
		> representation into sequences of Unicode code units and then perform the
		> comparison numerically, code unit by code unit, are interoperable in the
		> sense that implementations will agree in all cases on equality or
		> inequality of two strings. For example, implementations that compare
		> strings with escaped characters unconverted may incorrectly find that
		> `"a\\b"` and `"a\u005Cb"` are not equal.

		This implementation is interoperable as it does compare strings code unit
		by code unit.

		#### Storage

		String values are stored as pointers in a @ref basic_json type. That is,
		for any access to string values, a pointer of type `string_t*` must be
		dereferenced.

		@since version 1.0.0
		*/
		using string_t = StringType;

		/*!
		@brief a type for a boolean

		[RFC 7159](http://rfc7159.net/rfc7159) implicitly describes a boolean as a
		type which differentiates the two literals `true` and `false`.

		To store objects in C++, a type is defined by the template parameter @a
		BooleanType which chooses the type to use.

		#### Default type

		With the default values for @a BooleanType (`bool`), the default value for
		@a boolean_t is:

		@code {.cpp}
		bool
		@endcode

		#### Storage

		Boolean values are stored directly inside a @ref basic_json type.

		@since version 1.0.0
		*/
		using boolean_t = BooleanType;

		/*!
		@brief a type for a number (integer)

		[RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
		> The representation of numbers is similar to that used in most
		> programming languages. A number is represented in base 10 using decimal
		> digits. It contains an integer component that may be prefixed with an
		> optional minus sign, which may be followed by a fraction part and/or an
		> exponent part. Leading zeros are not allowed. (...) Numeric values that
		> cannot be represented in the grammar below (such as Infinity and NaN)
		> are not permitted.

		This description includes both integer and floating-point numbers.
		However, C++ allows more precise storage if it is known whether the number
		is a signed integer, an unsigned integer or a floating-point number.
		Therefore, three different types, @ref number_integer_t, @ref
		number_unsigned_t and @ref number_float_t are used.

		To store integer numbers in C++, a type is defined by the template
		parameter @a NumberIntegerType which chooses the type to use.

		#### Default type

		With the default values for @a NumberIntegerType (`int64_t`), the default
		value for @a number_integer_t is:

		@code {.cpp}
		int64_t
		@endcode

		#### Default behavior

		- The restrictions about leading zeros is not enforced in C++. Instead,
		  leading zeros in integer literals lead to an interpretation as octal
		  number. Internally, the value will be stored as decimal number. For
		  instance, the C++ integer literal `010` will be serialized to `8`.
		  During deserialization, leading zeros yield an error.
		- Not-a-number (NaN) values will be serialized to `null`.

		#### Limits

		[RFC 7159](http://rfc7159.net/rfc7159) specifies:
		> An implementation may set limits on the range and precision of numbers.

		When the default type is used, the maximal integer number that can be
		stored is `9223372036854775807` (INT64_MAX) and the minimal integer number
		that can be stored is `-9223372036854775808` (INT64_MIN). Integer numbers
		that are out of range will yield over/underflow when used in a
		constructor. During deserialization, too large or small integer numbers
		will be automatically be stored as @ref number_unsigned_t or @ref
		number_float_t.

		[RFC 7159](http://rfc7159.net/rfc7159) further states:
		> Note that when such software is used, numbers that are integers and are
		> in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
		> that implementations will agree exactly on their numeric values.

		As this range is a subrange of the exactly supported range [INT64_MIN,
		INT64_MAX], this class's integer type is interoperable.

		#### Storage

		Integer number values are stored directly inside a @ref basic_json type.

		@sa @ref number_float_t -- type for number values (floating-point)

		@sa @ref number_unsigned_t -- type for number values (unsigned integer)

		@since version 1.0.0
		*/
		using number_integer_t = NumberIntegerType;

		/*!
		@brief a type for a number (unsigned)

		[RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
		> The representation of numbers is similar to that used in most
		> programming languages. A number is represented in base 10 using decimal
		> digits. It contains an integer component that may be prefixed with an
		> optional minus sign, which may be followed by a fraction part and/or an
		> exponent part. Leading zeros are not allowed. (...) Numeric values that
		> cannot be represented in the grammar below (such as Infinity and NaN)
		> are not permitted.

		This description includes both integer and floating-point numbers.
		However, C++ allows more precise storage if it is known whether the number
		is a signed integer, an unsigned integer or a floating-point number.
		Therefore, three different types, @ref number_integer_t, @ref
		number_unsigned_t and @ref number_float_t are used.

		To store unsigned integer numbers in C++, a type is defined by the
		template parameter @a NumberUnsignedType which chooses the type to use.

		#### Default type

		With the default values for @a NumberUnsignedType (`uint64_t`), the
		default value for @a number_unsigned_t is:

		@code {.cpp}
		uint64_t
		@endcode

		#### Default behavior

		- The restrictions about leading zeros is not enforced in C++. Instead,
		  leading zeros in integer literals lead to an interpretation as octal
		  number. Internally, the value will be stored as decimal number. For
		  instance, the C++ integer literal `010` will be serialized to `8`.
		  During deserialization, leading zeros yield an error.
		- Not-a-number (NaN) values will be serialized to `null`.

		#### Limits

		[RFC 7159](http://rfc7159.net/rfc7159) specifies:
		> An implementation may set limits on the range and precision of numbers.

		When the default type is used, the maximal integer number that can be
		stored is `18446744073709551615` (UINT64_MAX) and the minimal integer
		number that can be stored is `0`. Integer numbers that are out of range
		will yield over/underflow when used in a constructor. During
		deserialization, too large or small integer numbers will be automatically
		be stored as @ref number_integer_t or @ref number_float_t.

		[RFC 7159](http://rfc7159.net/rfc7159) further states:
		> Note that when such software is used, numbers that are integers and are
		> in the range \f$[-2^{53}+1, 2^{53}-1]\f$ are interoperable in the sense
		> that implementations will agree exactly on their numeric values.

		As this range is a subrange (when considered in conjunction with the
		number_integer_t type) of the exactly supported range [0, UINT64_MAX],
		this class's integer type is interoperable.

		#### Storage

		Integer number values are stored directly inside a @ref basic_json type.

		@sa @ref number_float_t -- type for number values (floating-point)
		@sa @ref number_integer_t -- type for number values (integer)

		@since version 2.0.0
		*/
		using number_unsigned_t = NumberUnsignedType;

		/*!
		@brief a type for a number (floating-point)

		[RFC 7159](http://rfc7159.net/rfc7159) describes numbers as follows:
		> The representation of numbers is similar to that used in most
		> programming languages. A number is represented in base 10 using decimal
		> digits. It contains an integer component that may be prefixed with an
		> optional minus sign, which may be followed by a fraction part and/or an
		> exponent part. Leading zeros are not allowed. (...) Numeric values that
		> cannot be represented in the grammar below (such as Infinity and NaN)
		> are not permitted.

		This description includes both integer and floating-point numbers.
		However, C++ allows more precise storage if it is known whether the number
		is a signed integer, an unsigned integer or a floating-point number.
		Therefore, three different types, @ref number_integer_t, @ref
		number_unsigned_t and @ref number_float_t are used.

		To store floating-point numbers in C++, a type is defined by the template
		parameter @a NumberFloatType which chooses the type to use.

		#### Default type

		With the default values for @a NumberFloatType (`double`), the default
		value for @a number_float_t is:

		@code {.cpp}
		double
		@endcode

		#### Default behavior

		- The restrictions about leading zeros is not enforced in C++. Instead,
		  leading zeros in floating-point literals will be ignored. Internally,
		  the value will be stored as decimal number. For instance, the C++
		  floating-point literal `01.2` will be serialized to `1.2`. During
		  deserialization, leading zeros yield an error.
		- Not-a-number (NaN) values will be serialized to `null`.

		#### Limits

		[RFC 7159](http://rfc7159.net/rfc7159) states:
		> This specification allows implementations to set limits on the range and
		> precision of numbers accepted. Since software that implements IEEE
		> 754-2008 binary64 (double precision) numbers is generally available and
		> widely used, good interoperability can be achieved by implementations
		> that expect no more precision or range than these provide, in the sense
		> that implementations will approximate JSON numbers within the expected
		> precision.

		This implementation does exactly follow this approach, as it uses double
		precision floating-point numbers. Note values smaller than
		`-1.79769313486232e+308` and values greater than `1.79769313486232e+308`
		will be stored as NaN internally and be serialized to `null`.

		#### Storage

		Floating-point number values are stored directly inside a @ref basic_json
		type.

		@sa @ref number_integer_t -- type for number values (integer)

		@sa @ref number_unsigned_t -- type for number values (unsigned integer)

		@since version 1.0.0
		*/
		using number_float_t = NumberFloatType;

		/// @}

	private:

		/// helper for exception-safe object creation
		template<typename T, typename... Args>
		static T* create(Args&& ... args)
		{
			AllocatorType<T> alloc;
			using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;

			auto deleter = [&](T * object)
			{
				AllocatorTraits::deallocate(alloc, object, 1);
			};
			std::unique_ptr<T, decltype(deleter)> object(AllocatorTraits::allocate(alloc, 1), deleter);
			AllocatorTraits::construct(alloc, object.get(), std::forward<Args>(args)...);
			assert(object != nullptr);
			return object.release();
		}

		////////////////////////
		// JSON value storage //
		////////////////////////

		/*!
		@brief a JSON value

		The actual storage for a JSON value of the @ref basic_json class. This
		union combines the different storage types for the JSON value types
		defined in @ref value_t.

		JSON type | value_t type    | used type
		--------- | --------------- | ------------------------
		object    | object          | pointer to @ref object_t
		array     | array           | pointer to @ref array_t
		string    | string          | pointer to @ref string_t
		boolean   | boolean         | @ref boolean_t
		number    | number_integer  | @ref number_integer_t
		number    | number_unsigned | @ref number_unsigned_t
		number    | number_float    | @ref number_float_t
		null      | null            | *no value is stored*

		@note Variable-length types (objects, arrays, and strings) are stored as
		pointers. The size of the union should not exceed 64 bits if the default
		value types are used.

		@since version 1.0.0
		*/
		union json_value
		{
			/// object (stored with pointer to save storage)
			object_t* object;
			/// array (stored with pointer to save storage)
			array_t* array;
			/// string (stored with pointer to save storage)
			string_t* string;
			/// boolean
			boolean_t boolean;
			/// number (integer)
			number_integer_t number_integer;
			/// number (unsigned integer)
			number_unsigned_t number_unsigned;
			/// number (floating-point)
			number_float_t number_float;

			/// default constructor (for null values)
			json_value() = default;
			/// constructor for booleans
			json_value(boolean_t v) noexcept : boolean(v) {}
			/// constructor for numbers (integer)
			json_value(number_integer_t v) noexcept : number_integer(v) {}
			/// constructor for numbers (unsigned)
			json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
			/// constructor for numbers (floating-point)
			json_value(number_float_t v) noexcept : number_float(v) {}
			/// constructor for empty values of a given type
			json_value(value_t t)
			{
				switch (t)
				{
				case value_t::object:
				{
					object = create<object_t>();
					break;
				}

				case value_t::array:
				{
					array = create<array_t>();
					break;
				}

				case value_t::string:
				{
					string = create<string_t>("");
					break;
				}

				case value_t::boolean:
				{
					boolean = boolean_t(false);
					break;
				}

				case value_t::number_integer:
				{
					number_integer = number_integer_t(0);
					break;
				}

				case value_t::number_unsigned:
				{
					number_unsigned = number_unsigned_t(0);
					break;
				}

				case value_t::number_float:
				{
					number_float = number_float_t(0.0);
					break;
				}

				case value_t::null:
				{
					object = nullptr;  // silence warning, see #821
					break;
				}

				default:
				{
					object = nullptr;  // silence warning, see #821
					if (JSON_UNLIKELY(t == value_t::null))
					{
						JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.3.0")); // LCOV_EXCL_LINE
					}
					break;
				}
				}
			}

			/// constructor for strings
			json_value(const string_t& value)
			{
				string = create<string_t>(value);
			}

			/// constructor for rvalue strings
			json_value(string_t&& value)
			{
				string = create<string_t>(std::move(value));
			}

			/// constructor for objects
			json_value(const object_t& value)
			{
				object = create<object_t>(value);
			}

			/// constructor for rvalue objects
			json_value(object_t&& value)
			{
				object = create<object_t>(std::move(value));
			}

			/// constructor for arrays
			json_value(const array_t& value)
			{
				array = create<array_t>(value);
			}

			/// constructor for rvalue arrays
			json_value(array_t&& value)
			{
				array = create<array_t>(std::move(value));
			}

			void destroy(value_t t) noexcept
			{
				switch (t)
				{
				case value_t::object:
				{
					AllocatorType<object_t> alloc;
					std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
					std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
					break;
				}

				case value_t::array:
				{
					AllocatorType<array_t> alloc;
					std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
					std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
					break;
				}

				case value_t::string:
				{
					AllocatorType<string_t> alloc;
					std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
					std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
					break;
				}

				default:
				{
					break;
				}
				}
			}
		};

		/*!
		@brief checks the class invariants

		This function asserts the class invariants. It needs to be called at the
		end of every constructor to make sure that created objects respect the
		invariant. Furthermore, it has to be called each time the type of a JSON
		value is changed, because the invariant expresses a relationship between
		@a m_type and @a m_value.
		*/
		void assert_invariant() const noexcept
		{
			assert(m_type != value_t::object or m_value.object != nullptr);
			assert(m_type != value_t::array or m_value.array != nullptr);
			assert(m_type != value_t::string or m_value.string != nullptr);
		}

	public:
		//////////////////////////
		// JSON parser callback //
		//////////////////////////

		/*!
		@brief parser event types

		The parser callback distinguishes the following events:
		- `object_start`: the parser read `{` and started to process a JSON object
		- `key`: the parser read a key of a value in an object
		- `object_end`: the parser read `}` and finished processing a JSON object
		- `array_start`: the parser read `[` and started to process a JSON array
		- `array_end`: the parser read `]` and finished processing a JSON array
		- `value`: the parser finished reading a JSON value

		@image html callback_events.png "Example when certain parse events are triggered"

		@sa @ref parser_callback_t for more information and examples
		*/
		using parse_event_t = typename parser::parse_event_t;

		/*!
		@brief per-element parser callback type

		With a parser callback function, the result of parsing a JSON text can be
		influenced. When passed to @ref parse, it is called on certain events
		(passed as @ref parse_event_t via parameter @a event) with a set recursion
		depth @a depth and context JSON value @a parsed. The return value of the
		callback function is a boolean indicating whether the element that emitted
		the callback shall be kept or not.

		We distinguish six scenarios (determined by the event type) in which the
		callback function can be called. The following table describes the values
		of the parameters @a depth, @a event, and @a parsed.

		parameter @a event | description | parameter @a depth | parameter @a parsed
		------------------ | ----------- | ------------------ | -------------------
		parse_event_t::object_start | the parser read `{` and started to process a JSON object | depth of the parent of the JSON object | a JSON value with type discarded
		parse_event_t::key | the parser read a key of a value in an object | depth of the currently parsed JSON object | a JSON string containing the key
		parse_event_t::object_end | the parser read `}` and finished processing a JSON object | depth of the parent of the JSON object | the parsed JSON object
		parse_event_t::array_start | the parser read `[` and started to process a JSON array | depth of the parent of the JSON array | a JSON value with type discarded
		parse_event_t::array_end | the parser read `]` and finished processing a JSON array | depth of the parent of the JSON array | the parsed JSON array
		parse_event_t::value | the parser finished reading a JSON value | depth of the value | the parsed JSON value

		@image html callback_events.png "Example when certain parse events are triggered"

		Discarding a value (i.e., returning `false`) has different effects
		depending on the context in which function was called:

		- Discarded values in structured types are skipped. That is, the parser
		  will behave as if the discarded value was never read.
		- In case a value outside a structured type is skipped, it is replaced
		  with `null`. This case happens if the top-level element is skipped.

		@param[in] depth  the depth of the recursion during parsing

		@param[in] event  an event of type parse_event_t indicating the context in
		the callback function has been called

		@param[in,out] parsed  the current intermediate parse result; note that
		writing to this value has no effect for parse_event_t::key events

		@return Whether the JSON value which called the function during parsing
		should be kept (`true`) or not (`false`). In the latter case, it is either
		skipped completely or replaced by an empty discarded object.

		@sa @ref parse for examples

		@since version 1.0.0
		*/
		using parser_callback_t = typename parser::parser_callback_t;

		//////////////////
		// constructors //
		//////////////////

		/// @name constructors and destructors
		/// Constructors of class @ref basic_json, copy/move constructor, copy
		/// assignment, static functions creating objects, and the destructor.
		/// @{

		/*!
		@brief create an empty value with a given type

		Create an empty JSON value with a given type. The value will be default
		initialized with an empty value which depends on the type:

		Value type  | initial value
		----------- | -------------
		null        | `null`
		boolean     | `false`
		string      | `""`
		number      | `0`
		object      | `{}`
		array       | `[]`

		@param[in] v  the type of the value to create

		@complexity Constant.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@liveexample{The following code shows the constructor for different @ref
		value_t values,basic_json__value_t}

		@sa @ref clear() -- restores the postcondition of this constructor

		@since version 1.0.0
		*/
		basic_json(const value_t v)
			: m_type(v), m_value(v)
		{
			assert_invariant();
		}

		/*!
		@brief create a null object

		Create a `null` JSON value. It either takes a null pointer as parameter
		(explicitly creating `null`) or no parameter (implicitly creating `null`).
		The passed null pointer itself is not read -- it is only used to choose
		the right constructor.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this constructor never throws
		exceptions.

		@liveexample{The following code shows the constructor with and without a
		null pointer parameter.,basic_json__nullptr_t}

		@since version 1.0.0
		*/
		basic_json(std::nullptr_t = nullptr) noexcept
			: basic_json(value_t::null)
		{
			assert_invariant();
		}

		/*!
		@brief create a JSON value

		This is a "catch all" constructor for all compatible JSON types; that is,
		types for which a `to_json()` method exists. The constructor forwards the
		parameter @a val to that method (to `json_serializer<U>::to_json` method
		with `U = uncvref_t<CompatibleType>`, to be exact).

		Template type @a CompatibleType includes, but is not limited to, the
		following types:
		- **arrays**: @ref array_t and all kinds of compatible containers such as
		  `std::vector`, `std::deque`, `std::list`, `std::forward_list`,
		  `std::array`, `std::valarray`, `std::set`, `std::unordered_set`,
		  `std::multiset`, and `std::unordered_multiset` with a `value_type` from
		  which a @ref basic_json value can be constructed.
		- **objects**: @ref object_t and all kinds of compatible associative
		  containers such as `std::map`, `std::unordered_map`, `std::multimap`,
		  and `std::unordered_multimap` with a `key_type` compatible to
		  @ref string_t and a `value_type` from which a @ref basic_json value can
		  be constructed.
		- **strings**: @ref string_t, string literals, and all compatible string
		  containers can be used.
		- **numbers**: @ref number_integer_t, @ref number_unsigned_t,
		  @ref number_float_t, and all convertible number types such as `int`,
		  `size_t`, `int64_t`, `float` or `double` can be used.
		- **boolean**: @ref boolean_t / `bool` can be used.

		See the examples below.

		@tparam CompatibleType a type such that:
		- @a CompatibleType is not derived from `std::istream`,
		- @a CompatibleType is not @ref basic_json (to avoid hijacking copy/move
			 constructors),
		- @a CompatibleType is not a different @ref basic_json type (i.e. with different template arguments)
		- @a CompatibleType is not a @ref basic_json nested type (e.g.,
			 @ref json_pointer, @ref iterator, etc ...)
		- @ref @ref json_serializer<U> has a
			 `to_json(basic_json_t&, CompatibleType&&)` method

		@tparam U = `uncvref_t<CompatibleType>`

		@param[in] val the value to be forwarded to the respective constructor

		@complexity Usually linear in the size of the passed @a val, also
					depending on the implementation of the called `to_json()`
					method.

		@exceptionsafety Depends on the called constructor. For types directly
		supported by the library (i.e., all types for which no `to_json()` function
		was provided), strong guarantee holds: if an exception is thrown, there are
		no changes to any JSON value.

		@liveexample{The following code shows the constructor with several
		compatible types.,basic_json__CompatibleType}

		@since version 2.1.0
		*/
		template <typename CompatibleType,
			typename U = detail::uncvref_t<CompatibleType>,
			detail::enable_if_t<
			not detail::is_basic_json<U>::value and detail::is_compatible_type<basic_json_t, U>::value, int> = 0>
			basic_json(CompatibleType && val) noexcept(noexcept(
				JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),
					std::forward<CompatibleType>(val))))
		{
			JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
			assert_invariant();
		}

		/*!
		@brief create a JSON value from an existing one

		This is a constructor for existing @ref basic_json types.
		It does not hijack copy/move constructors, since the parameter has different
		template arguments than the current ones.

		The constructor tries to convert the internal @ref m_value of the parameter.

		@tparam BasicJsonType a type such that:
		- @a BasicJsonType is a @ref basic_json type.
		- @a BasicJsonType has different template arguments than @ref basic_json_t.

		@param[in] val the @ref basic_json value to be converted.

		@complexity Usually linear in the size of the passed @a val, also
					depending on the implementation of the called `to_json()`
					method.

		@exceptionsafety Depends on the called constructor. For types directly
		supported by the library (i.e., all types for which no `to_json()` function
		was provided), strong guarantee holds: if an exception is thrown, there are
		no changes to any JSON value.

		@since version 3.2.0
		*/
		template <typename BasicJsonType,
			detail::enable_if_t<
			detail::is_basic_json<BasicJsonType>::value and not std::is_same<basic_json, BasicJsonType>::value, int> = 0>
			basic_json(const BasicJsonType& val)
		{
			using other_boolean_t = typename BasicJsonType::boolean_t;
			using other_number_float_t = typename BasicJsonType::number_float_t;
			using other_number_integer_t = typename BasicJsonType::number_integer_t;
			using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
			using other_string_t = typename BasicJsonType::string_t;
			using other_object_t = typename BasicJsonType::object_t;
			using other_array_t = typename BasicJsonType::array_t;

			switch (val.type())
			{
			case value_t::boolean:
				JSONSerializer<other_boolean_t>::to_json(*this, val.template get<other_boolean_t>());
				break;
			case value_t::number_float:
				JSONSerializer<other_number_float_t>::to_json(*this, val.template get<other_number_float_t>());
				break;
			case value_t::number_integer:
				JSONSerializer<other_number_integer_t>::to_json(*this, val.template get<other_number_integer_t>());
				break;
			case value_t::number_unsigned:
				JSONSerializer<other_number_unsigned_t>::to_json(*this, val.template get<other_number_unsigned_t>());
				break;
			case value_t::string:
				JSONSerializer<other_string_t>::to_json(*this, val.template get_ref<const other_string_t&>());
				break;
			case value_t::object:
				JSONSerializer<other_object_t>::to_json(*this, val.template get_ref<const other_object_t&>());
				break;
			case value_t::array:
				JSONSerializer<other_array_t>::to_json(*this, val.template get_ref<const other_array_t&>());
				break;
			case value_t::null:
				*this = nullptr;
				break;
			case value_t::discarded:
				m_type = value_t::discarded;
				break;
			}
			assert_invariant();
		}

		/*!
		@brief create a container (array or object) from an initializer list

		Creates a JSON value of type array or object from the passed initializer
		list @a init. In case @a type_deduction is `true` (default), the type of
		the JSON value to be created is deducted from the initializer list @a init
		according to the following rules:

		1. If the list is empty, an empty JSON object value `{}` is created.
		2. If the list consists of pairs whose first element is a string, a JSON
		   object value is created where the first elements of the pairs are
		   treated as keys and the second elements are as values.
		3. In all other cases, an array is created.

		The rules aim to create the best fit between a C++ initializer list and
		JSON values. The rationale is as follows:

		1. The empty initializer list is written as `{}` which is exactly an empty
		   JSON object.
		2. C++ has no way of describing mapped types other than to list a list of
		   pairs. As JSON requires that keys must be of type string, rule 2 is the
		   weakest constraint one can pose on initializer lists to interpret them
		   as an object.
		3. In all other cases, the initializer list could not be interpreted as
		   JSON object type, so interpreting it as JSON array type is safe.

		With the rules described above, the following JSON values cannot be
		expressed by an initializer list:

		- the empty array (`[]`): use @ref array(initializer_list_t)
		  with an empty initializer list in this case
		- arrays whose elements satisfy rule 2: use @ref
		  array(initializer_list_t) with the same initializer list
		  in this case

		@note When used without parentheses around an empty initializer list, @ref
		basic_json() is called instead of this function, yielding the JSON null
		value.

		@param[in] init  initializer list with JSON values

		@param[in] type_deduction internal parameter; when set to `true`, the type
		of the JSON value is deducted from the initializer list @a init; when set
		to `false`, the type provided via @a manual_type is forced. This mode is
		used by the functions @ref array(initializer_list_t) and
		@ref object(initializer_list_t).

		@param[in] manual_type internal parameter; when @a type_deduction is set
		to `false`, the created JSON value will use the provided type (only @ref
		value_t::array and @ref value_t::object are valid); when @a type_deduction
		is set to `true`, this parameter has no effect

		@throw type_error.301 if @a type_deduction is `false`, @a manual_type is
		`value_t::object`, but @a init contains an element which is not a pair
		whose first element is a string. In this case, the constructor could not
		create an object. If @a type_deduction would have be `true`, an array
		would have been created. See @ref object(initializer_list_t)
		for an example.

		@complexity Linear in the size of the initializer list @a init.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@liveexample{The example below shows how JSON values are created from
		initializer lists.,basic_json__list_init_t}

		@sa @ref array(initializer_list_t) -- create a JSON array
		value from an initializer list
		@sa @ref object(initializer_list_t) -- create a JSON object
		value from an initializer list

		@since version 1.0.0
		*/
		basic_json(initializer_list_t init,
			bool type_deduction = true,
			value_t manual_type = value_t::array)
		{
			// check if each element is an array with two elements whose first
			// element is a string
			bool is_an_object = std::all_of(init.begin(), init.end(),
				[](const detail::json_ref<basic_json>& element_ref)
			{
				return (element_ref->is_array() and element_ref->size() == 2 and (*element_ref)[0].is_string());
			});

			// adjust type if type deduction is not wanted
			if (not type_deduction)
			{
				// if array is wanted, do not create an object though possible
				if (manual_type == value_t::array)
				{
					is_an_object = false;
				}

				// if object is wanted but impossible, throw an exception
				if (JSON_UNLIKELY(manual_type == value_t::object and not is_an_object))
				{
					JSON_THROW(type_error::create(301, "cannot create object from initializer list"));
				}
			}

			if (is_an_object)
			{
				// the initializer list is a list of pairs -> create object
				m_type = value_t::object;
				m_value = value_t::object;

				std::for_each(init.begin(), init.end(), [this](const detail::json_ref<basic_json>& element_ref)
				{
					auto element = element_ref.moved_or_copied();
					m_value.object->emplace(
						std::move(*((*element.m_value.array)[0].m_value.string)),
						std::move((*element.m_value.array)[1]));
				});
			}
			else
			{
				// the initializer list describes an array -> create array
				m_type = value_t::array;
				m_value.array = create<array_t>(init.begin(), init.end());
			}

			assert_invariant();
		}

		/*!
		@brief explicitly create an array from an initializer list

		Creates a JSON array value from a given initializer list. That is, given a
		list of values `a, b, c`, creates the JSON value `[a, b, c]`. If the
		initializer list is empty, the empty array `[]` is created.

		@note This function is only needed to express two edge cases that cannot
		be realized with the initializer list constructor (@ref
		basic_json(initializer_list_t, bool, value_t)). These cases
		are:
		1. creating an array whose elements are all pairs whose first element is a
		string -- in this case, the initializer list constructor would create an
		object, taking the first elements as keys
		2. creating an empty array -- passing the empty initializer list to the
		initializer list constructor yields an empty object

		@param[in] init  initializer list with JSON values to create an array from
		(optional)

		@return JSON array value

		@complexity Linear in the size of @a init.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@liveexample{The following code shows an example for the `array`
		function.,array}

		@sa @ref basic_json(initializer_list_t, bool, value_t) --
		create a JSON value from an initializer list
		@sa @ref object(initializer_list_t) -- create a JSON object
		value from an initializer list

		@since version 1.0.0
		*/
		static basic_json array(initializer_list_t init = {})
		{
			return basic_json(init, false, value_t::array);
		}

		/*!
		@brief explicitly create an object from an initializer list

		Creates a JSON object value from a given initializer list. The initializer
		lists elements must be pairs, and their first elements must be strings. If
		the initializer list is empty, the empty object `{}` is created.

		@note This function is only added for symmetry reasons. In contrast to the
		related function @ref array(initializer_list_t), there are
		no cases which can only be expressed by this function. That is, any
		initializer list @a init can also be passed to the initializer list
		constructor @ref basic_json(initializer_list_t, bool, value_t).

		@param[in] init  initializer list to create an object from (optional)

		@return JSON object value

		@throw type_error.301 if @a init is not a list of pairs whose first
		elements are strings. In this case, no object can be created. When such a
		value is passed to @ref basic_json(initializer_list_t, bool, value_t),
		an array would have been created from the passed initializer list @a init.
		See example below.

		@complexity Linear in the size of @a init.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@liveexample{The following code shows an example for the `object`
		function.,object}

		@sa @ref basic_json(initializer_list_t, bool, value_t) --
		create a JSON value from an initializer list
		@sa @ref array(initializer_list_t) -- create a JSON array
		value from an initializer list

		@since version 1.0.0
		*/
		static basic_json object(initializer_list_t init = {})
		{
			return basic_json(init, false, value_t::object);
		}

		/*!
		@brief construct an array with count copies of given value

		Constructs a JSON array value by creating @a cnt copies of a passed value.
		In case @a cnt is `0`, an empty array is created.

		@param[in] cnt  the number of JSON copies of @a val to create
		@param[in] val  the JSON value to copy

		@post `std::distance(begin(),end()) == cnt` holds.

		@complexity Linear in @a cnt.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@liveexample{The following code shows examples for the @ref
		basic_json(size_type\, const basic_json&)
		constructor.,basic_json__size_type_basic_json}

		@since version 1.0.0
		*/
		basic_json(size_type cnt, const basic_json& val)
			: m_type(value_t::array)
		{
			m_value.array = create<array_t>(cnt, val);
			assert_invariant();
		}

		/*!
		@brief construct a JSON container given an iterator range

		Constructs the JSON value with the contents of the range `[first, last)`.
		The semantics depends on the different types a JSON value can have:
		- In case of a null type, invalid_iterator.206 is thrown.
		- In case of other primitive types (number, boolean, or string), @a first
		  must be `begin()` and @a last must be `end()`. In this case, the value is
		  copied. Otherwise, invalid_iterator.204 is thrown.
		- In case of structured types (array, object), the constructor behaves as
		  similar versions for `std::vector` or `std::map`; that is, a JSON array
		  or object is constructed from the values in the range.

		@tparam InputIT an input iterator type (@ref iterator or @ref
		const_iterator)

		@param[in] first begin of the range to copy from (included)
		@param[in] last end of the range to copy from (excluded)

		@pre Iterators @a first and @a last must be initialized. **This
			 precondition is enforced with an assertion (see warning).** If
			 assertions are switched off, a violation of this precondition yields
			 undefined behavior.

		@pre Range `[first, last)` is valid. Usually, this precondition cannot be
			 checked efficiently. Only certain edge cases are detected; see the
			 description of the exceptions below. A violation of this precondition
			 yields undefined behavior.

		@warning A precondition is enforced with a runtime assertion that will
				 result in calling `std::abort` if this precondition is not met.
				 Assertions can be disabled by defining `NDEBUG` at compile time.
				 See https://en.cppreference.com/w/cpp/error/assert for more
				 information.

		@throw invalid_iterator.201 if iterators @a first and @a last are not
		compatible (i.e., do not belong to the same JSON value). In this case,
		the range `[first, last)` is undefined.
		@throw invalid_iterator.204 if iterators @a first and @a last belong to a
		primitive type (number, boolean, or string), but @a first does not point
		to the first element any more. In this case, the range `[first, last)` is
		undefined. See example code below.
		@throw invalid_iterator.206 if iterators @a first and @a last belong to a
		null value. In this case, the range `[first, last)` is undefined.

		@complexity Linear in distance between @a first and @a last.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@liveexample{The example below shows several ways to create JSON values by
		specifying a subrange with iterators.,basic_json__InputIt_InputIt}

		@since version 1.0.0
		*/
		template<class InputIT, typename std::enable_if<
			std::is_same<InputIT, typename basic_json_t::iterator>::value or
			std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int>::type = 0>
			basic_json(InputIT first, InputIT last)
		{
			assert(first.m_object != nullptr);
			assert(last.m_object != nullptr);

			// make sure iterator fits the current value
			if (JSON_UNLIKELY(first.m_object != last.m_object))
			{
				JSON_THROW(invalid_iterator::create(201, "iterators are not compatible"));
			}

			// copy type from first iterator
			m_type = first.m_object->m_type;

			// check if iterator range is complete for primitive values
			switch (m_type)
			{
			case value_t::boolean:
			case value_t::number_float:
			case value_t::number_integer:
			case value_t::number_unsigned:
			case value_t::string:
			{
				if (JSON_UNLIKELY(not first.m_it.primitive_iterator.is_begin()
					or not last.m_it.primitive_iterator.is_end()))
				{
					JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
				}
				break;
			}

			default:
				break;
			}

			switch (m_type)
			{
			case value_t::number_integer:
			{
				m_value.number_integer = first.m_object->m_value.number_integer;
				break;
			}

			case value_t::number_unsigned:
			{
				m_value.number_unsigned = first.m_object->m_value.number_unsigned;
				break;
			}

			case value_t::number_float:
			{
				m_value.number_float = first.m_object->m_value.number_float;
				break;
			}

			case value_t::boolean:
			{
				m_value.boolean = first.m_object->m_value.boolean;
				break;
			}

			case value_t::string:
			{
				m_value = *first.m_object->m_value.string;
				break;
			}

			case value_t::object:
			{
				m_value.object = create<object_t>(first.m_it.object_iterator,
					last.m_it.object_iterator);
				break;
			}

			case value_t::array:
			{
				m_value.array = create<array_t>(first.m_it.array_iterator,
					last.m_it.array_iterator);
				break;
			}

			default:
				JSON_THROW(invalid_iterator::create(206, "cannot construct with iterators from " +
					std::string(first.m_object->type_name())));
			}

			assert_invariant();
		}


		///////////////////////////////////////
		// other constructors and destructor //
		///////////////////////////////////////

		/// @private
		basic_json(const detail::json_ref<basic_json>& ref)
			: basic_json(ref.moved_or_copied())
		{}

		/*!
		@brief copy constructor

		Creates a copy of a given JSON value.

		@param[in] other  the JSON value to copy

		@post `*this == other`

		@complexity Linear in the size of @a other.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes to any JSON value.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is linear.
		- As postcondition, it holds: `other == basic_json(other)`.

		@liveexample{The following code shows an example for the copy
		constructor.,basic_json__basic_json}

		@since version 1.0.0
		*/
		basic_json(const basic_json& other)
			: m_type(other.m_type)
		{
			// check of passed value is valid
			other.assert_invariant();

			switch (m_type)
			{
			case value_t::object:
			{
				m_value = *other.m_value.object;
				break;
			}

			case value_t::array:
			{
				m_value = *other.m_value.array;
				break;
			}

			case value_t::string:
			{
				m_value = *other.m_value.string;
				break;
			}

			case value_t::boolean:
			{
				m_value = other.m_value.boolean;
				break;
			}

			case value_t::number_integer:
			{
				m_value = other.m_value.number_integer;
				break;
			}

			case value_t::number_unsigned:
			{
				m_value = other.m_value.number_unsigned;
				break;
			}

			case value_t::number_float:
			{
				m_value = other.m_value.number_float;
				break;
			}

			default:
				break;
			}

			assert_invariant();
		}

		/*!
		@brief move constructor

		Move constructor. Constructs a JSON value with the contents of the given
		value @a other using move semantics. It "steals" the resources from @a
		other and leaves it as JSON null value.

		@param[in,out] other  value to move to this object

		@post `*this` has the same value as @a other before the call.
		@post @a other is a JSON null value.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this constructor never throws
		exceptions.

		@requirement This function helps `basic_json` satisfying the
		[MoveConstructible](https://en.cppreference.com/w/cpp/named_req/MoveConstructible)
		requirements.

		@liveexample{The code below shows the move constructor explicitly called
		via std::move.,basic_json__moveconstructor}

		@since version 1.0.0
		*/
		basic_json(basic_json&& other) noexcept
			: m_type(std::move(other.m_type)),
			m_value(std::move(other.m_value))
		{
			// check that passed value is valid
			other.assert_invariant();

			// invalidate payload
			other.m_type = value_t::null;
			other.m_value = {};

			assert_invariant();
		}

		/*!
		@brief copy assignment

		Copy assignment operator. Copies a JSON value via the "copy and swap"
		strategy: It is expressed in terms of the copy constructor, destructor,
		and the `swap()` member function.

		@param[in] other  value to copy from

		@complexity Linear.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is linear.

		@liveexample{The code below shows and example for the copy assignment. It
		creates a copy of value `a` which is then swapped with `b`. Finally\, the
		copy of `a` (which is the null value after the swap) is
		destroyed.,basic_json__copyassignment}

		@since version 1.0.0
		*/
		reference& operator=(basic_json other) noexcept (
			std::is_nothrow_move_constructible<value_t>::value and
			std::is_nothrow_move_assignable<value_t>::value and
			std::is_nothrow_move_constructible<json_value>::value and
			std::is_nothrow_move_assignable<json_value>::value
			)
		{
			// check that passed value is valid
			other.assert_invariant();

			using std::swap;
			swap(m_type, other.m_type);
			swap(m_value, other.m_value);

			assert_invariant();
			return *this;
		}

		/*!
		@brief destructor

		Destroys the JSON value and frees all allocated memory.

		@complexity Linear.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is linear.
		- All stored elements are destroyed and all memory is freed.

		@since version 1.0.0
		*/
		~basic_json() noexcept
		{
			assert_invariant();
			m_value.destroy(m_type);
		}

		/// @}

	public:
		///////////////////////
		// object inspection //
		///////////////////////

		/// @name object inspection
		/// Functions to inspect the type of a JSON value.
		/// @{

		/*!
		@brief serialization

		Serialization function for JSON values. The function tries to mimic
		Python's `json.dumps()` function, and currently supports its @a indent
		and @a ensure_ascii parameters.

		@param[in] indent If indent is nonnegative, then array elements and object
		members will be pretty-printed with that indent level. An indent level of
		`0` will only insert newlines. `-1` (the default) selects the most compact
		representation.
		@param[in] indent_char The character to use for indentation if @a indent is
		greater than `0`. The default is ` ` (space).
		@param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
		in the output are escaped with `\uXXXX` sequences, and the result consists
		of ASCII characters only.

		@return string containing the serialization of the JSON value

		@throw type_error.316 if a string stored inside the JSON value is not
							  UTF-8 encoded

		@complexity Linear.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@liveexample{The following example shows the effect of different @a indent\,
		@a indent_char\, and @a ensure_ascii parameters to the result of the
		serialization.,dump}

		@see https://docs.python.org/2/library/json.html#json.dump

		@since version 1.0.0; indentation character @a indent_char, option
			   @a ensure_ascii and exceptions added in version 3.0.0
		*/
		string_t dump(const int indent = -1, const char indent_char = ' ',
			const bool ensure_ascii = false) const
		{
			string_t result;
			serializer s(detail::output_adapter<char, string_t>(result), indent_char);

			if (indent >= 0)
			{
				s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
			}
			else
			{
				s.dump(*this, false, ensure_ascii, 0);
			}

			return result;
		}

		/*!
		@brief return the type of the JSON value (explicit)

		Return the type of the JSON value as a value from the @ref value_t
		enumeration.

		@return the type of the JSON value
				Value type                | return value
				------------------------- | -------------------------
				null                      | value_t::null
				boolean                   | value_t::boolean
				string                    | value_t::string
				number (integer)          | value_t::number_integer
				number (unsigned integer) | value_t::number_unsigned
				number (floating-point)   | value_t::number_float
				object                    | value_t::object
				array                     | value_t::array
				discarded                 | value_t::discarded

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `type()` for all JSON
		types.,type}

		@sa @ref operator value_t() -- return the type of the JSON value (implicit)
		@sa @ref type_name() -- return the type as string

		@since version 1.0.0
		*/
		constexpr value_t type() const noexcept
		{
			return m_type;
		}

		/*!
		@brief return whether type is primitive

		This function returns true if and only if the JSON type is primitive
		(string, number, boolean, or null).

		@return `true` if type is primitive (string, number, boolean, or null),
		`false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_primitive()` for all JSON
		types.,is_primitive}

		@sa @ref is_structured() -- returns whether JSON value is structured
		@sa @ref is_null() -- returns whether JSON value is `null`
		@sa @ref is_string() -- returns whether JSON value is a string
		@sa @ref is_boolean() -- returns whether JSON value is a boolean
		@sa @ref is_number() -- returns whether JSON value is a number

		@since version 1.0.0
		*/
		constexpr bool is_primitive() const noexcept
		{
			return is_null() or is_string() or is_boolean() or is_number();
		}

		/*!
		@brief return whether type is structured

		This function returns true if and only if the JSON type is structured
		(array or object).

		@return `true` if type is structured (array or object), `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_structured()` for all JSON
		types.,is_structured}

		@sa @ref is_primitive() -- returns whether value is primitive
		@sa @ref is_array() -- returns whether value is an array
		@sa @ref is_object() -- returns whether value is an object

		@since version 1.0.0
		*/
		constexpr bool is_structured() const noexcept
		{
			return is_array() or is_object();
		}

		/*!
		@brief return whether value is null

		This function returns true if and only if the JSON value is null.

		@return `true` if type is null, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_null()` for all JSON
		types.,is_null}

		@since version 1.0.0
		*/
		constexpr bool is_null() const noexcept
		{
			return (m_type == value_t::null);
		}

		/*!
		@brief return whether value is a boolean

		This function returns true if and only if the JSON value is a boolean.

		@return `true` if type is boolean, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_boolean()` for all JSON
		types.,is_boolean}

		@since version 1.0.0
		*/
		constexpr bool is_boolean() const noexcept
		{
			return (m_type == value_t::boolean);
		}

		/*!
		@brief return whether value is a number

		This function returns true if and only if the JSON value is a number. This
		includes both integer (signed and unsigned) and floating-point values.

		@return `true` if type is number (regardless whether integer, unsigned
		integer or floating-type), `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_number()` for all JSON
		types.,is_number}

		@sa @ref is_number_integer() -- check if value is an integer or unsigned
		integer number
		@sa @ref is_number_unsigned() -- check if value is an unsigned integer
		number
		@sa @ref is_number_float() -- check if value is a floating-point number

		@since version 1.0.0
		*/
		constexpr bool is_number() const noexcept
		{
			return is_number_integer() or is_number_float();
		}

		/*!
		@brief return whether value is an integer number

		This function returns true if and only if the JSON value is a signed or
		unsigned integer number. This excludes floating-point values.

		@return `true` if type is an integer or unsigned integer number, `false`
		otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_number_integer()` for all
		JSON types.,is_number_integer}

		@sa @ref is_number() -- check if value is a number
		@sa @ref is_number_unsigned() -- check if value is an unsigned integer
		number
		@sa @ref is_number_float() -- check if value is a floating-point number

		@since version 1.0.0
		*/
		constexpr bool is_number_integer() const noexcept
		{
			return (m_type == value_t::number_integer or m_type == value_t::number_unsigned);
		}

		/*!
		@brief return whether value is an unsigned integer number

		This function returns true if and only if the JSON value is an unsigned
		integer number. This excludes floating-point and signed integer values.

		@return `true` if type is an unsigned integer number, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_number_unsigned()` for all
		JSON types.,is_number_unsigned}

		@sa @ref is_number() -- check if value is a number
		@sa @ref is_number_integer() -- check if value is an integer or unsigned
		integer number
		@sa @ref is_number_float() -- check if value is a floating-point number

		@since version 2.0.0
		*/
		constexpr bool is_number_unsigned() const noexcept
		{
			return (m_type == value_t::number_unsigned);
		}

		/*!
		@brief return whether value is a floating-point number

		This function returns true if and only if the JSON value is a
		floating-point number. This excludes signed and unsigned integer values.

		@return `true` if type is a floating-point number, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_number_float()` for all
		JSON types.,is_number_float}

		@sa @ref is_number() -- check if value is number
		@sa @ref is_number_integer() -- check if value is an integer number
		@sa @ref is_number_unsigned() -- check if value is an unsigned integer
		number

		@since version 1.0.0
		*/
		constexpr bool is_number_float() const noexcept
		{
			return (m_type == value_t::number_float);
		}

		/*!
		@brief return whether value is an object

		This function returns true if and only if the JSON value is an object.

		@return `true` if type is object, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_object()` for all JSON
		types.,is_object}

		@since version 1.0.0
		*/
		constexpr bool is_object() const noexcept
		{
			return (m_type == value_t::object);
		}

		/*!
		@brief return whether value is an array

		This function returns true if and only if the JSON value is an array.

		@return `true` if type is array, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_array()` for all JSON
		types.,is_array}

		@since version 1.0.0
		*/
		constexpr bool is_array() const noexcept
		{
			return (m_type == value_t::array);
		}

		/*!
		@brief return whether value is a string

		This function returns true if and only if the JSON value is a string.

		@return `true` if type is string, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_string()` for all JSON
		types.,is_string}

		@since version 1.0.0
		*/
		constexpr bool is_string() const noexcept
		{
			return (m_type == value_t::string);
		}

		/*!
		@brief return whether value is discarded

		This function returns true if and only if the JSON value was discarded
		during parsing with a callback function (see @ref parser_callback_t).

		@note This function will always be `false` for JSON values after parsing.
		That is, discarded values can only occur during parsing, but will be
		removed when inside a structured value or replaced by null in other cases.

		@return `true` if type is discarded, `false` otherwise.

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies `is_discarded()` for all JSON
		types.,is_discarded}

		@since version 1.0.0
		*/
		constexpr bool is_discarded() const noexcept
		{
			return (m_type == value_t::discarded);
		}

		/*!
		@brief return the type of the JSON value (implicit)

		Implicitly return the type of the JSON value as a value from the @ref
		value_t enumeration.

		@return the type of the JSON value

		@complexity Constant.

		@exceptionsafety No-throw guarantee: this member function never throws
		exceptions.

		@liveexample{The following code exemplifies the @ref value_t operator for
		all JSON types.,operator__value_t}

		@sa @ref type() -- return the type of the JSON value (explicit)
		@sa @ref type_name() -- return the type as string

		@since version 1.0.0
		*/
		constexpr operator value_t() const noexcept
		{
			return m_type;
		}

		/// @}

	private:
		//////////////////
		// value access //
		//////////////////

		/// get a boolean (explicit)
		boolean_t get_impl(boolean_t* /*unused*/) const
		{
			if (JSON_LIKELY(is_boolean()))
			{
				return m_value.boolean;
			}

			JSON_THROW(type_error::create(302, "type must be boolean, but is " + std::string(type_name())));
		}

		/// get a pointer to the value (object)
		object_t* get_impl_ptr(object_t* /*unused*/) noexcept
		{
			return is_object() ? m_value.object : nullptr;
		}

		/// get a pointer to the value (object)
		constexpr const object_t* get_impl_ptr(const object_t* /*unused*/) const noexcept
		{
			return is_object() ? m_value.object : nullptr;
		}

		/// get a pointer to the value (array)
		array_t* get_impl_ptr(array_t* /*unused*/) noexcept
		{
			return is_array() ? m_value.array : nullptr;
		}

		/// get a pointer to the value (array)
		constexpr const array_t* get_impl_ptr(const array_t* /*unused*/) const noexcept
		{
			return is_array() ? m_value.array : nullptr;
		}

		/// get a pointer to the value (string)
		string_t* get_impl_ptr(string_t* /*unused*/) noexcept
		{
			return is_string() ? m_value.string : nullptr;
		}

		/// get a pointer to the value (string)
		constexpr const string_t* get_impl_ptr(const string_t* /*unused*/) const noexcept
		{
			return is_string() ? m_value.string : nullptr;
		}

		/// get a pointer to the value (boolean)
		boolean_t* get_impl_ptr(boolean_t* /*unused*/) noexcept
		{
			return is_boolean() ? &m_value.boolean : nullptr;
		}

		/// get a pointer to the value (boolean)
		constexpr const boolean_t* get_impl_ptr(const boolean_t* /*unused*/) const noexcept
		{
			return is_boolean() ? &m_value.boolean : nullptr;
		}

		/// get a pointer to the value (integer number)
		number_integer_t* get_impl_ptr(number_integer_t* /*unused*/) noexcept
		{
			return is_number_integer() ? &m_value.number_integer : nullptr;
		}

		/// get a pointer to the value (integer number)
		constexpr const number_integer_t* get_impl_ptr(const number_integer_t* /*unused*/) const noexcept
		{
			return is_number_integer() ? &m_value.number_integer : nullptr;
		}

		/// get a pointer to the value (unsigned number)
		number_unsigned_t* get_impl_ptr(number_unsigned_t* /*unused*/) noexcept
		{
			return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
		}

		/// get a pointer to the value (unsigned number)
		constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* /*unused*/) const noexcept
		{
			return is_number_unsigned() ? &m_value.number_unsigned : nullptr;
		}

		/// get a pointer to the value (floating-point number)
		number_float_t* get_impl_ptr(number_float_t* /*unused*/) noexcept
		{
			return is_number_float() ? &m_value.number_float : nullptr;
		}

		/// get a pointer to the value (floating-point number)
		constexpr const number_float_t* get_impl_ptr(const number_float_t* /*unused*/) const noexcept
		{
			return is_number_float() ? &m_value.number_float : nullptr;
		}

		/*!
		@brief helper function to implement get_ref()

		This function helps to implement get_ref() without code duplication for
		const and non-const overloads

		@tparam ThisType will be deduced as `basic_json` or `const basic_json`

		@throw type_error.303 if ReferenceType does not match underlying value
		type of the current JSON
		*/
		template<typename ReferenceType, typename ThisType>
		static ReferenceType get_ref_impl(ThisType& obj)
		{
			// delegate the call to get_ptr<>()
			auto ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();

			if (JSON_LIKELY(ptr != nullptr))
			{
				return *ptr;
			}

			JSON_THROW(type_error::create(303, "incompatible ReferenceType for get_ref, actual type is " + std::string(obj.type_name())));
		}

	public:
		/// @name value access
		/// Direct access to the stored value of a JSON value.
		/// @{

		/*!
		@brief get special-case overload

		This overloads avoids a lot of template boilerplate, it can be seen as the
		identity method

		@tparam BasicJsonType == @ref basic_json

		@return a copy of *this

		@complexity Constant.

		@since version 2.1.0
		*/
		template<typename BasicJsonType, detail::enable_if_t<
			std::is_same<typename std::remove_const<BasicJsonType>::type, basic_json_t>::value,
			int> = 0>
			basic_json get() const
		{
			return *this;
		}

		/*!
		@brief get special-case overload

		This overloads converts the current @ref basic_json in a different
		@ref basic_json type

		@tparam BasicJsonType == @ref basic_json

		@return a copy of *this, converted into @tparam BasicJsonType

		@complexity Depending on the implementation of the called `from_json()`
					method.

		@since version 3.2.0
		*/
		template<typename BasicJsonType, detail::enable_if_t<
			not std::is_same<BasicJsonType, basic_json>::value and
			detail::is_basic_json<BasicJsonType>::value, int> = 0>
			BasicJsonType get() const
		{
			return *this;
		}

		/*!
		@brief get a value (explicit)

		Explicit type conversion between the JSON value and a compatible value
		which is [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
		and [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
		The value is converted by calling the @ref json_serializer<ValueType>
		`from_json()` method.

		The function is equivalent to executing
		@code {.cpp}
		ValueType ret;
		JSONSerializer<ValueType>::from_json(*this, ret);
		return ret;
		@endcode

		This overloads is chosen if:
		- @a ValueType is not @ref basic_json,
		- @ref json_serializer<ValueType> has a `from_json()` method of the form
		  `void from_json(const basic_json&, ValueType&)`, and
		- @ref json_serializer<ValueType> does not have a `from_json()` method of
		  the form `ValueType from_json(const basic_json&)`

		@tparam ValueTypeCV the provided value type
		@tparam ValueType the returned value type

		@return copy of the JSON value, converted to @a ValueType

		@throw what @ref json_serializer<ValueType> `from_json()` method throws

		@liveexample{The example below shows several conversions from JSON values
		to other types. There a few things to note: (1) Floating-point numbers can
		be converted to integers\, (2) A JSON array can be converted to a standard
		`std::vector<short>`\, (3) A JSON object can be converted to C++
		associative containers such as `std::unordered_map<std::string\,
		json>`.,get__ValueType_const}

		@since version 2.1.0
		*/
		template<typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
			detail::enable_if_t <
			not detail::is_basic_json<ValueType>::value and
			detail::has_from_json<basic_json_t, ValueType>::value and
			not detail::has_non_default_from_json<basic_json_t, ValueType>::value,
			int> = 0>
			ValueType get() const noexcept(noexcept(
				JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
		{
			// we cannot static_assert on ValueTypeCV being non-const, because
			// there is support for get<const basic_json_t>(), which is why we
			// still need the uncvref
			static_assert(not std::is_reference<ValueTypeCV>::value,
				"get() cannot be used with reference types, you might want to use get_ref()");
			static_assert(std::is_default_constructible<ValueType>::value,
				"types must be DefaultConstructible when used with get()");

			ValueType ret;
			JSONSerializer<ValueType>::from_json(*this, ret);
			return ret;
		}

		/*!
		@brief get a value (explicit); special case

		Explicit type conversion between the JSON value and a compatible value
		which is **not** [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
		and **not** [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
		The value is converted by calling the @ref json_serializer<ValueType>
		`from_json()` method.

		The function is equivalent to executing
		@code {.cpp}
		return JSONSerializer<ValueTypeCV>::from_json(*this);
		@endcode

		This overloads is chosen if:
		- @a ValueType is not @ref basic_json and
		- @ref json_serializer<ValueType> has a `from_json()` method of the form
		  `ValueType from_json(const basic_json&)`

		@note If @ref json_serializer<ValueType> has both overloads of
		`from_json()`, this one is chosen.

		@tparam ValueTypeCV the provided value type
		@tparam ValueType the returned value type

		@return copy of the JSON value, converted to @a ValueType

		@throw what @ref json_serializer<ValueType> `from_json()` method throws

		@since version 2.1.0
		*/
		template<typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>,
			detail::enable_if_t<not std::is_same<basic_json_t, ValueType>::value and
			detail::has_non_default_from_json<basic_json_t, ValueType>::value,
			int> = 0>
			ValueType get() const noexcept(noexcept(
				JSONSerializer<ValueTypeCV>::from_json(std::declval<const basic_json_t&>())))
		{
			static_assert(not std::is_reference<ValueTypeCV>::value,
				"get() cannot be used with reference types, you might want to use get_ref()");
			return JSONSerializer<ValueTypeCV>::from_json(*this);
		}

		/*!
		@brief get a value (explicit)

		Explicit type conversion between the JSON value and a compatible value.
		The value is filled into the input parameter by calling the @ref json_serializer<ValueType>
		`from_json()` method.

		The function is equivalent to executing
		@code {.cpp}
		ValueType v;
		JSONSerializer<ValueType>::from_json(*this, v);
		@endcode

		This overloads is chosen if:
		- @a ValueType is not @ref basic_json,
		- @ref json_serializer<ValueType> has a `from_json()` method of the form
		  `void from_json(const basic_json&, ValueType&)`, and

		@tparam ValueType the input parameter type.

		@return the input parameter, allowing chaining calls.

		@throw what @ref json_serializer<ValueType> `from_json()` method throws

		@liveexample{The example below shows several conversions from JSON values
		to other types. There a few things to note: (1) Floating-point numbers can
		be converted to integers\, (2) A JSON array can be converted to a standard
		`std::vector<short>`\, (3) A JSON object can be converted to C++
		associative containers such as `std::unordered_map<std::string\,
		json>`.,get_to}

		@since version 3.3.0
		*/
		template<typename ValueType,
			detail::enable_if_t <
			not detail::is_basic_json<ValueType>::value and
			detail::has_from_json<basic_json_t, ValueType>::value,
			int> = 0>
			ValueType & get_to(ValueType& v) const noexcept(noexcept(
				JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))
		{
			JSONSerializer<ValueType>::from_json(*this, v);
			return v;
		}


		/*!
		@brief get a pointer value (implicit)

		Implicit pointer access to the internally stored JSON value. No copies are
		made.

		@warning Writing data to the pointee of the result yields an undefined
		state.

		@tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
		object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
		@ref number_unsigned_t, or @ref number_float_t. Enforced by a static
		assertion.

		@return pointer to the internally stored JSON value if the requested
		pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

		@complexity Constant.

		@liveexample{The example below shows how pointers to internal values of a
		JSON value can be requested. Note that no type conversions are made and a
		`nullptr` is returned if the value and the requested pointer type does not
		match.,get_ptr}

		@since version 1.0.0
		*/
		template<typename PointerType, typename std::enable_if<
			std::is_pointer<PointerType>::value, int>::type = 0>
			auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
		{
			// delegate the call to get_impl_ptr<>()
			return get_impl_ptr(static_cast<PointerType>(nullptr));
		}

		/*!
		@brief get a pointer value (implicit)
		@copydoc get_ptr()
		*/
		template<typename PointerType, typename std::enable_if<
			std::is_pointer<PointerType>::value and
			std::is_const<typename std::remove_pointer<PointerType>::type>::value, int>::type = 0>
			constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
		{
			// delegate the call to get_impl_ptr<>() const
			return get_impl_ptr(static_cast<PointerType>(nullptr));
		}

		/*!
		@brief get a pointer value (explicit)

		Explicit pointer access to the internally stored JSON value. No copies are
		made.

		@warning The pointer becomes invalid if the underlying JSON object
		changes.

		@tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
		object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
		@ref number_unsigned_t, or @ref number_float_t.

		@return pointer to the internally stored JSON value if the requested
		pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

		@complexity Constant.

		@liveexample{The example below shows how pointers to internal values of a
		JSON value can be requested. Note that no type conversions are made and a
		`nullptr` is returned if the value and the requested pointer type does not
		match.,get__PointerType}

		@sa @ref get_ptr() for explicit pointer-member access

		@since version 1.0.0
		*/
		template<typename PointerType, typename std::enable_if<
			std::is_pointer<PointerType>::value, int>::type = 0>
			auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
		{
			// delegate the call to get_ptr
			return get_ptr<PointerType>();
		}

		/*!
		@brief get a pointer value (explicit)
		@copydoc get()
		*/
		template<typename PointerType, typename std::enable_if<
			std::is_pointer<PointerType>::value, int>::type = 0>
			constexpr auto get() const noexcept -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
		{
			// delegate the call to get_ptr
			return get_ptr<PointerType>();
		}

		/*!
		@brief get a reference value (implicit)

		Implicit reference access to the internally stored JSON value. No copies
		are made.

		@warning Writing data to the referee of the result yields an undefined
		state.

		@tparam ReferenceType reference type; must be a reference to @ref array_t,
		@ref object_t, @ref string_t, @ref boolean_t, @ref number_integer_t, or
		@ref number_float_t. Enforced by static assertion.

		@return reference to the internally stored JSON value if the requested
		reference type @a ReferenceType fits to the JSON value; throws
		type_error.303 otherwise

		@throw type_error.303 in case passed type @a ReferenceType is incompatible
		with the stored JSON value; see example below

		@complexity Constant.

		@liveexample{The example shows several calls to `get_ref()`.,get_ref}

		@since version 1.1.0
		*/
		template<typename ReferenceType, typename std::enable_if<
			std::is_reference<ReferenceType>::value, int>::type = 0>
			ReferenceType get_ref()
		{
			// delegate call to get_ref_impl
			return get_ref_impl<ReferenceType>(*this);
		}

		/*!
		@brief get a reference value (implicit)
		@copydoc get_ref()
		*/
		template<typename ReferenceType, typename std::enable_if<
			std::is_reference<ReferenceType>::value and
			std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int>::type = 0>
			ReferenceType get_ref() const
		{
			// delegate call to get_ref_impl
			return get_ref_impl<ReferenceType>(*this);
		}

		/*!
		@brief get a value (implicit)

		Implicit type conversion between the JSON value and a compatible value.
		The call is realized by calling @ref get() const.

		@tparam ValueType non-pointer type compatible to the JSON value, for
		instance `int` for JSON integer numbers, `bool` for JSON booleans, or
		`std::vector` types for JSON arrays. The character type of @ref string_t
		as well as an initializer list of this type is excluded to avoid
		ambiguities as these types implicitly convert to `std::string`.

		@return copy of the JSON value, converted to type @a ValueType

		@throw type_error.302 in case passed type @a ValueType is incompatible
		to the JSON value type (e.g., the JSON value is of type boolean, but a
		string is requested); see example below

		@complexity Linear in the size of the JSON value.

		@liveexample{The example below shows several conversions from JSON values
		to other types. There a few things to note: (1) Floating-point numbers can
		be converted to integers\, (2) A JSON array can be converted to a standard
		`std::vector<short>`\, (3) A JSON object can be converted to C++
		associative containers such as `std::unordered_map<std::string\,
		json>`.,operator__ValueType}

		@since version 1.0.0
		*/
		template < typename ValueType, typename std::enable_if <
			not std::is_pointer<ValueType>::value and
			not std::is_same<ValueType, detail::json_ref<basic_json>>::value and
			not std::is_same<ValueType, typename string_t::value_type>::value and
			not detail::is_basic_json<ValueType>::value

#ifndef _MSC_VER  // fix for issue #167 operator<< ambiguity under VS2015
			and not std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>::value
#if defined(JSON_HAS_CPP_17) && defined(_MSC_VER) and _MSC_VER <= 1914
			and not std::is_same<ValueType, typename std::string_view>::value
#endif
#endif
			and detail::is_detected<detail::get_template_function, const basic_json_t&, ValueType>::value
			, int >::type = 0 >
			operator ValueType() const
		{
			// delegate the call to get<>() const
			return get<ValueType>();
		}

		/// @}


		////////////////////
		// element access //
		////////////////////

		/// @name element access
		/// Access to the JSON value.
		/// @{

		/*!
		@brief access specified array element with bounds checking

		Returns a reference to the element at specified location @a idx, with
		bounds checking.

		@param[in] idx  index of the element to access

		@return reference to the element at index @a idx

		@throw type_error.304 if the JSON value is not an array; in this case,
		calling `at` with an index makes no sense. See example below.
		@throw out_of_range.401 if the index @a idx is out of range of the array;
		that is, `idx >= size()`. See example below.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Constant.

		@since version 1.0.0

		@liveexample{The example below shows how array elements can be read and
		written using `at()`. It also demonstrates the different exceptions that
		can be thrown.,at__size_type}
		*/
		reference at(size_type idx)
		{
			// at only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				JSON_TRY
				{
					return m_value.array->at(idx);
				}
					JSON_CATCH(std::out_of_range&)
				{
					// create better exception explanation
					JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
				}
			}
			else
			{
				JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
			}
		}

		/*!
		@brief access specified array element with bounds checking

		Returns a const reference to the element at specified location @a idx,
		with bounds checking.

		@param[in] idx  index of the element to access

		@return const reference to the element at index @a idx

		@throw type_error.304 if the JSON value is not an array; in this case,
		calling `at` with an index makes no sense. See example below.
		@throw out_of_range.401 if the index @a idx is out of range of the array;
		that is, `idx >= size()`. See example below.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Constant.

		@since version 1.0.0

		@liveexample{The example below shows how array elements can be read using
		`at()`. It also demonstrates the different exceptions that can be thrown.,
		at__size_type_const}
		*/
		const_reference at(size_type idx) const
		{
			// at only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				JSON_TRY
				{
					return m_value.array->at(idx);
				}
					JSON_CATCH(std::out_of_range&)
				{
					// create better exception explanation
					JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
				}
			}
			else
			{
				JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
			}
		}

		/*!
		@brief access specified object element with bounds checking

		Returns a reference to the element at with specified key @a key, with
		bounds checking.

		@param[in] key  key of the element to access

		@return reference to the element at key @a key

		@throw type_error.304 if the JSON value is not an object; in this case,
		calling `at` with a key makes no sense. See example below.
		@throw out_of_range.403 if the key @a key is is not stored in the object;
		that is, `find(key) == end()`. See example below.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Logarithmic in the size of the container.

		@sa @ref operator[](const typename object_t::key_type&) for unchecked
		access by reference
		@sa @ref value() for access by value with a default value

		@since version 1.0.0

		@liveexample{The example below shows how object elements can be read and
		written using `at()`. It also demonstrates the different exceptions that
		can be thrown.,at__object_t_key_type}
		*/
		reference at(const typename object_t::key_type& key)
		{
			// at only works for objects
			if (JSON_LIKELY(is_object()))
			{
				JSON_TRY
				{
					return m_value.object->at(key);
				}
					JSON_CATCH(std::out_of_range&)
				{
					// create better exception explanation
					JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
				}
			}
			else
			{
				JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
			}
		}

		/*!
		@brief access specified object element with bounds checking

		Returns a const reference to the element at with specified key @a key,
		with bounds checking.

		@param[in] key  key of the element to access

		@return const reference to the element at key @a key

		@throw type_error.304 if the JSON value is not an object; in this case,
		calling `at` with a key makes no sense. See example below.
		@throw out_of_range.403 if the key @a key is is not stored in the object;
		that is, `find(key) == end()`. See example below.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Logarithmic in the size of the container.

		@sa @ref operator[](const typename object_t::key_type&) for unchecked
		access by reference
		@sa @ref value() for access by value with a default value

		@since version 1.0.0

		@liveexample{The example below shows how object elements can be read using
		`at()`. It also demonstrates the different exceptions that can be thrown.,
		at__object_t_key_type_const}
		*/
		const_reference at(const typename object_t::key_type& key) const
		{
			// at only works for objects
			if (JSON_LIKELY(is_object()))
			{
				JSON_TRY
				{
					return m_value.object->at(key);
				}
					JSON_CATCH(std::out_of_range&)
				{
					// create better exception explanation
					JSON_THROW(out_of_range::create(403, "key '" + key + "' not found"));
				}
			}
			else
			{
				JSON_THROW(type_error::create(304, "cannot use at() with " + std::string(type_name())));
			}
		}

		/*!
		@brief access specified array element

		Returns a reference to the element at specified location @a idx.

		@note If @a idx is beyond the range of the array (i.e., `idx >= size()`),
		then the array is silently filled up with `null` values to make `idx` a
		valid reference to the last stored element.

		@param[in] idx  index of the element to access

		@return reference to the element at index @a idx

		@throw type_error.305 if the JSON value is not an array or null; in that
		cases, using the [] operator with an index makes no sense.

		@complexity Constant if @a idx is in the range of the array. Otherwise
		linear in `idx - size()`.

		@liveexample{The example below shows how array elements can be read and
		written using `[]` operator. Note the addition of `null`
		values.,operatorarray__size_type}

		@since version 1.0.0
		*/
		reference operator[](size_type idx)
		{
			// implicitly convert null value to an empty array
			if (is_null())
			{
				m_type = value_t::array;
				m_value.array = create<array_t>();
				assert_invariant();
			}

			// operator[] only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				// fill up array with null values if given idx is outside range
				if (idx >= m_value.array->size())
				{
					m_value.array->insert(m_value.array->end(),
						idx - m_value.array->size() + 1,
						basic_json());
				}

				return m_value.array->operator[](idx);
			}

			JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
		}

		/*!
		@brief access specified array element

		Returns a const reference to the element at specified location @a idx.

		@param[in] idx  index of the element to access

		@return const reference to the element at index @a idx

		@throw type_error.305 if the JSON value is not an array; in that case,
		using the [] operator with an index makes no sense.

		@complexity Constant.

		@liveexample{The example below shows how array elements can be read using
		the `[]` operator.,operatorarray__size_type_const}

		@since version 1.0.0
		*/
		const_reference operator[](size_type idx) const
		{
			// const operator[] only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				return m_value.array->operator[](idx);
			}

			JSON_THROW(type_error::create(305, "cannot use operator[] with a numeric argument with " + std::string(type_name())));
		}

		/*!
		@brief access specified object element

		Returns a reference to the element at with specified key @a key.

		@note If @a key is not found in the object, then it is silently added to
		the object and filled with a `null` value to make `key` a valid reference.
		In case the value was `null` before, it is converted to an object.

		@param[in] key  key of the element to access

		@return reference to the element at key @a key

		@throw type_error.305 if the JSON value is not an object or null; in that
		cases, using the [] operator with a key makes no sense.

		@complexity Logarithmic in the size of the container.

		@liveexample{The example below shows how object elements can be read and
		written using the `[]` operator.,operatorarray__key_type}

		@sa @ref at(const typename object_t::key_type&) for access by reference
		with range checking
		@sa @ref value() for access by value with a default value

		@since version 1.0.0
		*/
		reference operator[](const typename object_t::key_type& key)
		{
			// implicitly convert null value to an empty object
			if (is_null())
			{
				m_type = value_t::object;
				m_value.object = create<object_t>();
				assert_invariant();
			}

			// operator[] only works for objects
			if (JSON_LIKELY(is_object()))
			{
				return m_value.object->operator[](key);
			}

			JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
		}

		/*!
		@brief read-only access specified object element

		Returns a const reference to the element at with specified key @a key. No
		bounds checking is performed.

		@warning If the element with key @a key does not exist, the behavior is
		undefined.

		@param[in] key  key of the element to access

		@return const reference to the element at key @a key

		@pre The element with key @a key must exist. **This precondition is
			 enforced with an assertion.**

		@throw type_error.305 if the JSON value is not an object; in that case,
		using the [] operator with a key makes no sense.

		@complexity Logarithmic in the size of the container.

		@liveexample{The example below shows how object elements can be read using
		the `[]` operator.,operatorarray__key_type_const}

		@sa @ref at(const typename object_t::key_type&) for access by reference
		with range checking
		@sa @ref value() for access by value with a default value

		@since version 1.0.0
		*/
		const_reference operator[](const typename object_t::key_type& key) const
		{
			// const operator[] only works for objects
			if (JSON_LIKELY(is_object()))
			{
				assert(m_value.object->find(key) != m_value.object->end());
				return m_value.object->find(key)->second;
			}

			JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
		}

		/*!
		@brief access specified object element

		Returns a reference to the element at with specified key @a key.

		@note If @a key is not found in the object, then it is silently added to
		the object and filled with a `null` value to make `key` a valid reference.
		In case the value was `null` before, it is converted to an object.

		@param[in] key  key of the element to access

		@return reference to the element at key @a key

		@throw type_error.305 if the JSON value is not an object or null; in that
		cases, using the [] operator with a key makes no sense.

		@complexity Logarithmic in the size of the container.

		@liveexample{The example below shows how object elements can be read and
		written using the `[]` operator.,operatorarray__key_type}

		@sa @ref at(const typename object_t::key_type&) for access by reference
		with range checking
		@sa @ref value() for access by value with a default value

		@since version 1.1.0
		*/
		template<typename T>
		reference operator[](T* key)
		{
			// implicitly convert null to object
			if (is_null())
			{
				m_type = value_t::object;
				m_value = value_t::object;
				assert_invariant();
			}

			// at only works for objects
			if (JSON_LIKELY(is_object()))
			{
				return m_value.object->operator[](key);
			}

			JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
		}

		/*!
		@brief read-only access specified object element

		Returns a const reference to the element at with specified key @a key. No
		bounds checking is performed.

		@warning If the element with key @a key does not exist, the behavior is
		undefined.

		@param[in] key  key of the element to access

		@return const reference to the element at key @a key

		@pre The element with key @a key must exist. **This precondition is
			 enforced with an assertion.**

		@throw type_error.305 if the JSON value is not an object; in that case,
		using the [] operator with a key makes no sense.

		@complexity Logarithmic in the size of the container.

		@liveexample{The example below shows how object elements can be read using
		the `[]` operator.,operatorarray__key_type_const}

		@sa @ref at(const typename object_t::key_type&) for access by reference
		with range checking
		@sa @ref value() for access by value with a default value

		@since version 1.1.0
		*/
		template<typename T>
		const_reference operator[](T* key) const
		{
			// at only works for objects
			if (JSON_LIKELY(is_object()))
			{
				assert(m_value.object->find(key) != m_value.object->end());
				return m_value.object->find(key)->second;
			}

			JSON_THROW(type_error::create(305, "cannot use operator[] with a string argument with " + std::string(type_name())));
		}

		/*!
		@brief access specified object element with default value

		Returns either a copy of an object's element at the specified key @a key
		or a given default value if no element with key @a key exists.

		The function is basically equivalent to executing
		@code {.cpp}
		try {
			return at(key);
		} catch(out_of_range) {
			return default_value;
		}
		@endcode

		@note Unlike @ref at(const typename object_t::key_type&), this function
		does not throw if the given key @a key was not found.

		@note Unlike @ref operator[](const typename object_t::key_type& key), this
		function does not implicitly add an element to the position defined by @a
		key. This function is furthermore also applicable to const objects.

		@param[in] key  key of the element to access
		@param[in] default_value  the value to return if @a key is not found

		@tparam ValueType type compatible to JSON values, for instance `int` for
		JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
		JSON arrays. Note the type of the expected value at @a key and the default
		value @a default_value must be compatible.

		@return copy of the element at key @a key or @a default_value if @a key
		is not found

		@throw type_error.306 if the JSON value is not an object; in that case,
		using `value()` with a key makes no sense.

		@complexity Logarithmic in the size of the container.

		@liveexample{The example below shows how object elements can be queried
		with a default value.,basic_json__value}

		@sa @ref at(const typename object_t::key_type&) for access by reference
		with range checking
		@sa @ref operator[](const typename object_t::key_type&) for unchecked
		access by reference

		@since version 1.0.0
		*/
		template<class ValueType, typename std::enable_if<
			std::is_convertible<basic_json_t, ValueType>::value, int>::type = 0>
			ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
		{
			// at only works for objects
			if (JSON_LIKELY(is_object()))
			{
				// if key is found, return value and given default value otherwise
				const auto it = find(key);
				if (it != end())
				{
					return *it;
				}

				return default_value;
			}

			JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
		}

		/*!
		@brief overload for a default value of type const char*
		@copydoc basic_json::value(const typename object_t::key_type&, ValueType) const
		*/
		string_t value(const typename object_t::key_type& key, const char* default_value) const
		{
			return value(key, string_t(default_value));
		}

		/*!
		@brief access specified object element via JSON Pointer with default value

		Returns either a copy of an object's element at the specified key @a key
		or a given default value if no element with key @a key exists.

		The function is basically equivalent to executing
		@code {.cpp}
		try {
			return at(ptr);
		} catch(out_of_range) {
			return default_value;
		}
		@endcode

		@note Unlike @ref at(const json_pointer&), this function does not throw
		if the given key @a key was not found.

		@param[in] ptr  a JSON pointer to the element to access
		@param[in] default_value  the value to return if @a ptr found no value

		@tparam ValueType type compatible to JSON values, for instance `int` for
		JSON integer numbers, `bool` for JSON booleans, or `std::vector` types for
		JSON arrays. Note the type of the expected value at @a key and the default
		value @a default_value must be compatible.

		@return copy of the element at key @a key or @a default_value if @a key
		is not found

		@throw type_error.306 if the JSON value is not an object; in that case,
		using `value()` with a key makes no sense.

		@complexity Logarithmic in the size of the container.

		@liveexample{The example below shows how object elements can be queried
		with a default value.,basic_json__value_ptr}

		@sa @ref operator[](const json_pointer&) for unchecked access by reference

		@since version 2.0.2
		*/
		template<class ValueType, typename std::enable_if<
			std::is_convertible<basic_json_t, ValueType>::value, int>::type = 0>
			ValueType value(const json_pointer& ptr, const ValueType& default_value) const
		{
			// at only works for objects
			if (JSON_LIKELY(is_object()))
			{
				// if pointer resolves a value, return it or use default value
				JSON_TRY
				{
					return ptr.get_checked(this);
				}
					JSON_INTERNAL_CATCH(out_of_range&)
				{
					return default_value;
				}
			}

			JSON_THROW(type_error::create(306, "cannot use value() with " + std::string(type_name())));
		}

		/*!
		@brief overload for a default value of type const char*
		@copydoc basic_json::value(const json_pointer&, ValueType) const
		*/
		string_t value(const json_pointer& ptr, const char* default_value) const
		{
			return value(ptr, string_t(default_value));
		}

		/*!
		@brief access the first element

		Returns a reference to the first element in the container. For a JSON
		container `c`, the expression `c.front()` is equivalent to `*c.begin()`.

		@return In case of a structured type (array or object), a reference to the
		first element is returned. In case of number, string, or boolean values, a
		reference to the value is returned.

		@complexity Constant.

		@pre The JSON value must not be `null` (would throw `std::out_of_range`)
		or an empty array or object (undefined behavior, **guarded by
		assertions**).
		@post The JSON value remains unchanged.

		@throw invalid_iterator.214 when called on `null` value

		@liveexample{The following code shows an example for `front()`.,front}

		@sa @ref back() -- access the last element

		@since version 1.0.0
		*/
		reference front()
		{
			return *begin();
		}

		/*!
		@copydoc basic_json::front()
		*/
		const_reference front() const
		{
			return *cbegin();
		}

		/*!
		@brief access the last element

		Returns a reference to the last element in the container. For a JSON
		container `c`, the expression `c.back()` is equivalent to
		@code {.cpp}
		auto tmp = c.end();
		--tmp;
		return *tmp;
		@endcode

		@return In case of a structured type (array or object), a reference to the
		last element is returned. In case of number, string, or boolean values, a
		reference to the value is returned.

		@complexity Constant.

		@pre The JSON value must not be `null` (would throw `std::out_of_range`)
		or an empty array or object (undefined behavior, **guarded by
		assertions**).
		@post The JSON value remains unchanged.

		@throw invalid_iterator.214 when called on a `null` value. See example
		below.

		@liveexample{The following code shows an example for `back()`.,back}

		@sa @ref front() -- access the first element

		@since version 1.0.0
		*/
		reference back()
		{
			auto tmp = end();
			--tmp;
			return *tmp;
		}

		/*!
		@copydoc basic_json::back()
		*/
		const_reference back() const
		{
			auto tmp = cend();
			--tmp;
			return *tmp;
		}

		/*!
		@brief remove element given an iterator

		Removes the element specified by iterator @a pos. The iterator @a pos must
		be valid and dereferenceable. Thus the `end()` iterator (which is valid,
		but is not dereferenceable) cannot be used as a value for @a pos.

		If called on a primitive type other than `null`, the resulting JSON value
		will be `null`.

		@param[in] pos iterator to the element to remove
		@return Iterator following the last removed element. If the iterator @a
		pos refers to the last element, the `end()` iterator is returned.

		@tparam IteratorType an @ref iterator or @ref const_iterator

		@post Invalidates iterators and references at or after the point of the
		erase, including the `end()` iterator.

		@throw type_error.307 if called on a `null` value; example: `"cannot use
		erase() with null"`
		@throw invalid_iterator.202 if called on an iterator which does not belong
		to the current JSON value; example: `"iterator does not fit current
		value"`
		@throw invalid_iterator.205 if called on a primitive type with invalid
		iterator (i.e., any iterator which is not `begin()`); example: `"iterator
		out of range"`

		@complexity The complexity depends on the type:
		- objects: amortized constant
		- arrays: linear in distance between @a pos and the end of the container
		- strings: linear in the length of the string
		- other types: constant

		@liveexample{The example shows the result of `erase()` for different JSON
		types.,erase__IteratorType}

		@sa @ref erase(IteratorType, IteratorType) -- removes the elements in
		the given range
		@sa @ref erase(const typename object_t::key_type&) -- removes the element
		from an object at the given key
		@sa @ref erase(const size_type) -- removes the element from an array at
		the given index

		@since version 1.0.0
		*/
		template<class IteratorType, typename std::enable_if<
			std::is_same<IteratorType, typename basic_json_t::iterator>::value or
			std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int>::type
			= 0>
			IteratorType erase(IteratorType pos)
		{
			// make sure iterator fits the current value
			if (JSON_UNLIKELY(this != pos.m_object))
			{
				JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
			}

			IteratorType result = end();

			switch (m_type)
			{
			case value_t::boolean:
			case value_t::number_float:
			case value_t::number_integer:
			case value_t::number_unsigned:
			case value_t::string:
			{
				if (JSON_UNLIKELY(not pos.m_it.primitive_iterator.is_begin()))
				{
					JSON_THROW(invalid_iterator::create(205, "iterator out of range"));
				}

				if (is_string())
				{
					AllocatorType<string_t> alloc;
					std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
					std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
					m_value.string = nullptr;
				}

				m_type = value_t::null;
				assert_invariant();
				break;
			}

			case value_t::object:
			{
				result.m_it.object_iterator = m_value.object->erase(pos.m_it.object_iterator);
				break;
			}

			case value_t::array:
			{
				result.m_it.array_iterator = m_value.array->erase(pos.m_it.array_iterator);
				break;
			}

			default:
				JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
			}

			return result;
		}

		/*!
		@brief remove elements given an iterator range

		Removes the element specified by the range `[first; last)`. The iterator
		@a first does not need to be dereferenceable if `first == last`: erasing
		an empty range is a no-op.

		If called on a primitive type other than `null`, the resulting JSON value
		will be `null`.

		@param[in] first iterator to the beginning of the range to remove
		@param[in] last iterator past the end of the range to remove
		@return Iterator following the last removed element. If the iterator @a
		second refers to the last element, the `end()` iterator is returned.

		@tparam IteratorType an @ref iterator or @ref const_iterator

		@post Invalidates iterators and references at or after the point of the
		erase, including the `end()` iterator.

		@throw type_error.307 if called on a `null` value; example: `"cannot use
		erase() with null"`
		@throw invalid_iterator.203 if called on iterators which does not belong
		to the current JSON value; example: `"iterators do not fit current value"`
		@throw invalid_iterator.204 if called on a primitive type with invalid
		iterators (i.e., if `first != begin()` and `last != end()`); example:
		`"iterators out of range"`

		@complexity The complexity depends on the type:
		- objects: `log(size()) + std::distance(first, last)`
		- arrays: linear in the distance between @a first and @a last, plus linear
		  in the distance between @a last and end of the container
		- strings: linear in the length of the string
		- other types: constant

		@liveexample{The example shows the result of `erase()` for different JSON
		types.,erase__IteratorType_IteratorType}

		@sa @ref erase(IteratorType) -- removes the element at a given position
		@sa @ref erase(const typename object_t::key_type&) -- removes the element
		from an object at the given key
		@sa @ref erase(const size_type) -- removes the element from an array at
		the given index

		@since version 1.0.0
		*/
		template<class IteratorType, typename std::enable_if<
			std::is_same<IteratorType, typename basic_json_t::iterator>::value or
			std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int>::type
			= 0>
			IteratorType erase(IteratorType first, IteratorType last)
		{
			// make sure iterator fits the current value
			if (JSON_UNLIKELY(this != first.m_object or this != last.m_object))
			{
				JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value"));
			}

			IteratorType result = end();

			switch (m_type)
			{
			case value_t::boolean:
			case value_t::number_float:
			case value_t::number_integer:
			case value_t::number_unsigned:
			case value_t::string:
			{
				if (JSON_LIKELY(not first.m_it.primitive_iterator.is_begin()
					or not last.m_it.primitive_iterator.is_end()))
				{
					JSON_THROW(invalid_iterator::create(204, "iterators out of range"));
				}

				if (is_string())
				{
					AllocatorType<string_t> alloc;
					std::allocator_traits<decltype(alloc)>::destroy(alloc, m_value.string);
					std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_value.string, 1);
					m_value.string = nullptr;
				}

				m_type = value_t::null;
				assert_invariant();
				break;
			}

			case value_t::object:
			{
				result.m_it.object_iterator = m_value.object->erase(first.m_it.object_iterator,
					last.m_it.object_iterator);
				break;
			}

			case value_t::array:
			{
				result.m_it.array_iterator = m_value.array->erase(first.m_it.array_iterator,
					last.m_it.array_iterator);
				break;
			}

			default:
				JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
			}

			return result;
		}

		/*!
		@brief remove element from a JSON object given a key

		Removes elements from a JSON object with the key value @a key.

		@param[in] key value of the elements to remove

		@return Number of elements removed. If @a ObjectType is the default
		`std::map` type, the return value will always be `0` (@a key was not
		found) or `1` (@a key was found).

		@post References and iterators to the erased elements are invalidated.
		Other references and iterators are not affected.

		@throw type_error.307 when called on a type other than JSON object;
		example: `"cannot use erase() with null"`

		@complexity `log(size()) + count(key)`

		@liveexample{The example shows the effect of `erase()`.,erase__key_type}

		@sa @ref erase(IteratorType) -- removes the element at a given position
		@sa @ref erase(IteratorType, IteratorType) -- removes the elements in
		the given range
		@sa @ref erase(const size_type) -- removes the element from an array at
		the given index

		@since version 1.0.0
		*/
		size_type erase(const typename object_t::key_type& key)
		{
			// this erase only works for objects
			if (JSON_LIKELY(is_object()))
			{
				return m_value.object->erase(key);
			}

			JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
		}

		/*!
		@brief remove element from a JSON array given an index

		Removes element from a JSON array at the index @a idx.

		@param[in] idx index of the element to remove

		@throw type_error.307 when called on a type other than JSON object;
		example: `"cannot use erase() with null"`
		@throw out_of_range.401 when `idx >= size()`; example: `"array index 17
		is out of range"`

		@complexity Linear in distance between @a idx and the end of the container.

		@liveexample{The example shows the effect of `erase()`.,erase__size_type}

		@sa @ref erase(IteratorType) -- removes the element at a given position
		@sa @ref erase(IteratorType, IteratorType) -- removes the elements in
		the given range
		@sa @ref erase(const typename object_t::key_type&) -- removes the element
		from an object at the given key

		@since version 1.0.0
		*/
		void erase(const size_type idx)
		{
			// this erase only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				if (JSON_UNLIKELY(idx >= size()))
				{
					JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
				}

				m_value.array->erase(m_value.array->begin() + static_cast<difference_type>(idx));
			}
			else
			{
				JSON_THROW(type_error::create(307, "cannot use erase() with " + std::string(type_name())));
			}
		}

		/// @}


		////////////
		// lookup //
		////////////

		/// @name lookup
		/// @{

		/*!
		@brief find an element in a JSON object

		Finds an element in a JSON object with key equivalent to @a key. If the
		element is not found or the JSON value is not an object, end() is
		returned.

		@note This method always returns @ref end() when executed on a JSON type
			  that is not an object.

		@param[in] key key value of the element to search for.

		@return Iterator to an element with key equivalent to @a key. If no such
		element is found or the JSON value is not an object, past-the-end (see
		@ref end()) iterator is returned.

		@complexity Logarithmic in the size of the JSON object.

		@liveexample{The example shows how `find()` is used.,find__key_type}

		@since version 1.0.0
		*/
		template<typename KeyT>
		iterator find(KeyT&& key)
		{
			auto result = end();

			if (is_object())
			{
				result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
			}

			return result;
		}

		/*!
		@brief find an element in a JSON object
		@copydoc find(KeyT&&)
		*/
		template<typename KeyT>
		const_iterator find(KeyT&& key) const
		{
			auto result = cend();

			if (is_object())
			{
				result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));
			}

			return result;
		}

		/*!
		@brief returns the number of occurrences of a key in a JSON object

		Returns the number of elements with key @a key. If ObjectType is the
		default `std::map` type, the return value will always be `0` (@a key was
		not found) or `1` (@a key was found).

		@note This method always returns `0` when executed on a JSON type that is
			  not an object.

		@param[in] key key value of the element to count

		@return Number of elements with key @a key. If the JSON value is not an
		object, the return value will be `0`.

		@complexity Logarithmic in the size of the JSON object.

		@liveexample{The example shows how `count()` is used.,count}

		@since version 1.0.0
		*/
		template<typename KeyT>
		size_type count(KeyT&& key) const
		{
			// return 0 for all nonobject types
			return is_object() ? m_value.object->count(std::forward<KeyT>(key)) : 0;
		}

		/// @}


		///////////////
		// iterators //
		///////////////

		/// @name iterators
		/// @{

		/*!
		@brief returns an iterator to the first element

		Returns an iterator to the first element.

		@image html range-begin-end.svg "Illustration from cppreference.com"

		@return iterator to the first element

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.

		@liveexample{The following code shows an example for `begin()`.,begin}

		@sa @ref cbegin() -- returns a const iterator to the beginning
		@sa @ref end() -- returns an iterator to the end
		@sa @ref cend() -- returns a const iterator to the end

		@since version 1.0.0
		*/
		iterator begin() noexcept
		{
			iterator result(this);
			result.set_begin();
			return result;
		}

		/*!
		@copydoc basic_json::cbegin()
		*/
		const_iterator begin() const noexcept
		{
			return cbegin();
		}

		/*!
		@brief returns a const iterator to the first element

		Returns a const iterator to the first element.

		@image html range-begin-end.svg "Illustration from cppreference.com"

		@return const iterator to the first element

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.
		- Has the semantics of `const_cast<const basic_json&>(*this).begin()`.

		@liveexample{The following code shows an example for `cbegin()`.,cbegin}

		@sa @ref begin() -- returns an iterator to the beginning
		@sa @ref end() -- returns an iterator to the end
		@sa @ref cend() -- returns a const iterator to the end

		@since version 1.0.0
		*/
		const_iterator cbegin() const noexcept
		{
			const_iterator result(this);
			result.set_begin();
			return result;
		}

		/*!
		@brief returns an iterator to one past the last element

		Returns an iterator to one past the last element.

		@image html range-begin-end.svg "Illustration from cppreference.com"

		@return iterator one past the last element

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.

		@liveexample{The following code shows an example for `end()`.,end}

		@sa @ref cend() -- returns a const iterator to the end
		@sa @ref begin() -- returns an iterator to the beginning
		@sa @ref cbegin() -- returns a const iterator to the beginning

		@since version 1.0.0
		*/
		iterator end() noexcept
		{
			iterator result(this);
			result.set_end();
			return result;
		}

		/*!
		@copydoc basic_json::cend()
		*/
		const_iterator end() const noexcept
		{
			return cend();
		}

		/*!
		@brief returns a const iterator to one past the last element

		Returns a const iterator to one past the last element.

		@image html range-begin-end.svg "Illustration from cppreference.com"

		@return const iterator one past the last element

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.
		- Has the semantics of `const_cast<const basic_json&>(*this).end()`.

		@liveexample{The following code shows an example for `cend()`.,cend}

		@sa @ref end() -- returns an iterator to the end
		@sa @ref begin() -- returns an iterator to the beginning
		@sa @ref cbegin() -- returns a const iterator to the beginning

		@since version 1.0.0
		*/
		const_iterator cend() const noexcept
		{
			const_iterator result(this);
			result.set_end();
			return result;
		}

		/*!
		@brief returns an iterator to the reverse-beginning

		Returns an iterator to the reverse-beginning; that is, the last element.

		@image html range-rbegin-rend.svg "Illustration from cppreference.com"

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
		requirements:
		- The complexity is constant.
		- Has the semantics of `reverse_iterator(end())`.

		@liveexample{The following code shows an example for `rbegin()`.,rbegin}

		@sa @ref crbegin() -- returns a const reverse iterator to the beginning
		@sa @ref rend() -- returns a reverse iterator to the end
		@sa @ref crend() -- returns a const reverse iterator to the end

		@since version 1.0.0
		*/
		reverse_iterator rbegin() noexcept
		{
			return reverse_iterator(end());
		}

		/*!
		@copydoc basic_json::crbegin()
		*/
		const_reverse_iterator rbegin() const noexcept
		{
			return crbegin();
		}

		/*!
		@brief returns an iterator to the reverse-end

		Returns an iterator to the reverse-end; that is, one before the first
		element.

		@image html range-rbegin-rend.svg "Illustration from cppreference.com"

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
		requirements:
		- The complexity is constant.
		- Has the semantics of `reverse_iterator(begin())`.

		@liveexample{The following code shows an example for `rend()`.,rend}

		@sa @ref crend() -- returns a const reverse iterator to the end
		@sa @ref rbegin() -- returns a reverse iterator to the beginning
		@sa @ref crbegin() -- returns a const reverse iterator to the beginning

		@since version 1.0.0
		*/
		reverse_iterator rend() noexcept
		{
			return reverse_iterator(begin());
		}

		/*!
		@copydoc basic_json::crend()
		*/
		const_reverse_iterator rend() const noexcept
		{
			return crend();
		}

		/*!
		@brief returns a const reverse iterator to the last element

		Returns a const iterator to the reverse-beginning; that is, the last
		element.

		@image html range-rbegin-rend.svg "Illustration from cppreference.com"

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
		requirements:
		- The complexity is constant.
		- Has the semantics of `const_cast<const basic_json&>(*this).rbegin()`.

		@liveexample{The following code shows an example for `crbegin()`.,crbegin}

		@sa @ref rbegin() -- returns a reverse iterator to the beginning
		@sa @ref rend() -- returns a reverse iterator to the end
		@sa @ref crend() -- returns a const reverse iterator to the end

		@since version 1.0.0
		*/
		const_reverse_iterator crbegin() const noexcept
		{
			return const_reverse_iterator(cend());
		}

		/*!
		@brief returns a const reverse iterator to one before the first

		Returns a const reverse iterator to the reverse-end; that is, one before
		the first element.

		@image html range-rbegin-rend.svg "Illustration from cppreference.com"

		@complexity Constant.

		@requirement This function helps `basic_json` satisfying the
		[ReversibleContainer](https://en.cppreference.com/w/cpp/named_req/ReversibleContainer)
		requirements:
		- The complexity is constant.
		- Has the semantics of `const_cast<const basic_json&>(*this).rend()`.

		@liveexample{The following code shows an example for `crend()`.,crend}

		@sa @ref rend() -- returns a reverse iterator to the end
		@sa @ref rbegin() -- returns a reverse iterator to the beginning
		@sa @ref crbegin() -- returns a const reverse iterator to the beginning

		@since version 1.0.0
		*/
		const_reverse_iterator crend() const noexcept
		{
			return const_reverse_iterator(cbegin());
		}

	public:
		/*!
		@brief wrapper to access iterator member functions in range-based for

		This function allows to access @ref iterator::key() and @ref
		iterator::value() during range-based for loops. In these loops, a
		reference to the JSON values is returned, so there is no access to the
		underlying iterator.

		For loop without iterator_wrapper:

		@code{cpp}
		for (auto it = j_object.begin(); it != j_object.end(); ++it)
		{
			std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
		}
		@endcode

		Range-based for loop without iterator proxy:

		@code{cpp}
		for (auto it : j_object)
		{
			// "it" is of type json::reference and has no key() member
			std::cout << "value: " << it << '\n';
		}
		@endcode

		Range-based for loop with iterator proxy:

		@code{cpp}
		for (auto it : json::iterator_wrapper(j_object))
		{
			std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
		}
		@endcode

		@note When iterating over an array, `key()` will return the index of the
			  element as string (see example).

		@param[in] ref  reference to a JSON value
		@return iteration proxy object wrapping @a ref with an interface to use in
				range-based for loops

		@liveexample{The following code shows how the wrapper is used,iterator_wrapper}

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Constant.

		@note The name of this function is not yet final and may change in the
		future.

		@deprecated This stream operator is deprecated and will be removed in
					future 4.0.0 of the library. Please use @ref items() instead;
					that is, replace `json::iterator_wrapper(j)` with `j.items()`.
		*/
		JSON_DEPRECATED
			static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept
		{
			return ref.items();
		}

		/*!
		@copydoc iterator_wrapper(reference)
		*/
		JSON_DEPRECATED
			static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept
		{
			return ref.items();
		}

		/*!
		@brief helper to access iterator member functions in range-based for

		This function allows to access @ref iterator::key() and @ref
		iterator::value() during range-based for loops. In these loops, a
		reference to the JSON values is returned, so there is no access to the
		underlying iterator.

		For loop without `items()` function:

		@code{cpp}
		for (auto it = j_object.begin(); it != j_object.end(); ++it)
		{
			std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
		}
		@endcode

		Range-based for loop without `items()` function:

		@code{cpp}
		for (auto it : j_object)
		{
			// "it" is of type json::reference and has no key() member
			std::cout << "value: " << it << '\n';
		}
		@endcode

		Range-based for loop with `items()` function:

		@code{cpp}
		for (auto it : j_object.items())
		{
			std::cout << "key: " << it.key() << ", value:" << it.value() << '\n';
		}
		@endcode

		@note When iterating over an array, `key()` will return the index of the
			  element as string (see example). For primitive types (e.g., numbers),
			  `key()` returns an empty string.

		@return iteration proxy object wrapping @a ref with an interface to use in
				range-based for loops

		@liveexample{The following code shows how the function is used.,items}

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Constant.

		@since version 3.1.0.
		*/
		iteration_proxy<iterator> items() noexcept
		{
			return iteration_proxy<iterator>(*this);
		}

		/*!
		@copydoc items()
		*/
		iteration_proxy<const_iterator> items() const noexcept
		{
			return iteration_proxy<const_iterator>(*this);
		}

		/// @}


		//////////////
		// capacity //
		//////////////

		/// @name capacity
		/// @{

		/*!
		@brief checks whether the container is empty.

		Checks if a JSON value has no elements (i.e. whether its @ref size is `0`).

		@return The return value depends on the different types and is
				defined as follows:
				Value type  | return value
				----------- | -------------
				null        | `true`
				boolean     | `false`
				string      | `false`
				number      | `false`
				object      | result of function `object_t::empty()`
				array       | result of function `array_t::empty()`

		@liveexample{The following code uses `empty()` to check if a JSON
		object contains any elements.,empty}

		@complexity Constant, as long as @ref array_t and @ref object_t satisfy
		the Container concept; that is, their `empty()` functions have constant
		complexity.

		@iterators No changes.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@note This function does not return whether a string stored as JSON value
		is empty - it returns whether the JSON container itself is empty which is
		false in the case of a string.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.
		- Has the semantics of `begin() == end()`.

		@sa @ref size() -- returns the number of elements

		@since version 1.0.0
		*/
		bool empty() const noexcept
		{
			switch (m_type)
			{
			case value_t::null:
			{
				// null values are empty
				return true;
			}

			case value_t::array:
			{
				// delegate call to array_t::empty()
				return m_value.array->empty();
			}

			case value_t::object:
			{
				// delegate call to object_t::empty()
				return m_value.object->empty();
			}

			default:
			{
				// all other types are nonempty
				return false;
			}
			}
		}

		/*!
		@brief returns the number of elements

		Returns the number of elements in a JSON value.

		@return The return value depends on the different types and is
				defined as follows:
				Value type  | return value
				----------- | -------------
				null        | `0`
				boolean     | `1`
				string      | `1`
				number      | `1`
				object      | result of function object_t::size()
				array       | result of function array_t::size()

		@liveexample{The following code calls `size()` on the different value
		types.,size}

		@complexity Constant, as long as @ref array_t and @ref object_t satisfy
		the Container concept; that is, their size() functions have constant
		complexity.

		@iterators No changes.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@note This function does not return the length of a string stored as JSON
		value - it returns the number of elements in the JSON value which is 1 in
		the case of a string.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.
		- Has the semantics of `std::distance(begin(), end())`.

		@sa @ref empty() -- checks whether the container is empty
		@sa @ref max_size() -- returns the maximal number of elements

		@since version 1.0.0
		*/
		size_type size() const noexcept
		{
			switch (m_type)
			{
			case value_t::null:
			{
				// null values are empty
				return 0;
			}

			case value_t::array:
			{
				// delegate call to array_t::size()
				return m_value.array->size();
			}

			case value_t::object:
			{
				// delegate call to object_t::size()
				return m_value.object->size();
			}

			default:
			{
				// all other types have size 1
				return 1;
			}
			}
		}

		/*!
		@brief returns the maximum possible number of elements

		Returns the maximum number of elements a JSON value is able to hold due to
		system or library implementation limitations, i.e. `std::distance(begin(),
		end())` for the JSON value.

		@return The return value depends on the different types and is
				defined as follows:
				Value type  | return value
				----------- | -------------
				null        | `0` (same as `size()`)
				boolean     | `1` (same as `size()`)
				string      | `1` (same as `size()`)
				number      | `1` (same as `size()`)
				object      | result of function `object_t::max_size()`
				array       | result of function `array_t::max_size()`

		@liveexample{The following code calls `max_size()` on the different value
		types. Note the output is implementation specific.,max_size}

		@complexity Constant, as long as @ref array_t and @ref object_t satisfy
		the Container concept; that is, their `max_size()` functions have constant
		complexity.

		@iterators No changes.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@requirement This function helps `basic_json` satisfying the
		[Container](https://en.cppreference.com/w/cpp/named_req/Container)
		requirements:
		- The complexity is constant.
		- Has the semantics of returning `b.size()` where `b` is the largest
		  possible JSON value.

		@sa @ref size() -- returns the number of elements

		@since version 1.0.0
		*/
		size_type max_size() const noexcept
		{
			switch (m_type)
			{
			case value_t::array:
			{
				// delegate call to array_t::max_size()
				return m_value.array->max_size();
			}

			case value_t::object:
			{
				// delegate call to object_t::max_size()
				return m_value.object->max_size();
			}

			default:
			{
				// all other types have max_size() == size()
				return size();
			}
			}
		}

		/// @}


		///////////////
		// modifiers //
		///////////////

		/// @name modifiers
		/// @{

		/*!
		@brief clears the contents

		Clears the content of a JSON value and resets it to the default value as
		if @ref basic_json(value_t) would have been called with the current value
		type from @ref type():

		Value type  | initial value
		----------- | -------------
		null        | `null`
		boolean     | `false`
		string      | `""`
		number      | `0`
		object      | `{}`
		array       | `[]`

		@post Has the same effect as calling
		@code {.cpp}
		*this = basic_json(type());
		@endcode

		@liveexample{The example below shows the effect of `clear()` to different
		JSON types.,clear}

		@complexity Linear in the size of the JSON value.

		@iterators All iterators, pointers and references related to this container
				   are invalidated.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@sa @ref basic_json(value_t) -- constructor that creates an object with the
			same value than calling `clear()`

		@since version 1.0.0
		*/
		void clear() noexcept
		{
			switch (m_type)
			{
			case value_t::number_integer:
			{
				m_value.number_integer = 0;
				break;
			}

			case value_t::number_unsigned:
			{
				m_value.number_unsigned = 0;
				break;
			}

			case value_t::number_float:
			{
				m_value.number_float = 0.0;
				break;
			}

			case value_t::boolean:
			{
				m_value.boolean = false;
				break;
			}

			case value_t::string:
			{
				m_value.string->clear();
				break;
			}

			case value_t::array:
			{
				m_value.array->clear();
				break;
			}

			case value_t::object:
			{
				m_value.object->clear();
				break;
			}

			default:
				break;
			}
		}

		/*!
		@brief add an object to an array

		Appends the given element @a val to the end of the JSON value. If the
		function is called on a JSON null value, an empty array is created before
		appending @a val.

		@param[in] val the value to add to the JSON array

		@throw type_error.308 when called on a type other than JSON array or
		null; example: `"cannot use push_back() with number"`

		@complexity Amortized constant.

		@liveexample{The example shows how `push_back()` and `+=` can be used to
		add elements to a JSON array. Note how the `null` value was silently
		converted to a JSON array.,push_back}

		@since version 1.0.0
		*/
		void push_back(basic_json&& val)
		{
			// push_back only works for null objects or arrays
			if (JSON_UNLIKELY(not(is_null() or is_array())))
			{
				JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
			}

			// transform null object into an array
			if (is_null())
			{
				m_type = value_t::array;
				m_value = value_t::array;
				assert_invariant();
			}

			// add element to array (move semantics)
			m_value.array->push_back(std::move(val));
			// invalidate object
			val.m_type = value_t::null;
		}

		/*!
		@brief add an object to an array
		@copydoc push_back(basic_json&&)
		*/
		reference operator+=(basic_json&& val)
		{
			push_back(std::move(val));
			return *this;
		}

		/*!
		@brief add an object to an array
		@copydoc push_back(basic_json&&)
		*/
		void push_back(const basic_json& val)
		{
			// push_back only works for null objects or arrays
			if (JSON_UNLIKELY(not(is_null() or is_array())))
			{
				JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
			}

			// transform null object into an array
			if (is_null())
			{
				m_type = value_t::array;
				m_value = value_t::array;
				assert_invariant();
			}

			// add element to array
			m_value.array->push_back(val);
		}

		/*!
		@brief add an object to an array
		@copydoc push_back(basic_json&&)
		*/
		reference operator+=(const basic_json& val)
		{
			push_back(val);
			return *this;
		}

		/*!
		@brief add an object to an object

		Inserts the given element @a val to the JSON object. If the function is
		called on a JSON null value, an empty object is created before inserting
		@a val.

		@param[in] val the value to add to the JSON object

		@throw type_error.308 when called on a type other than JSON object or
		null; example: `"cannot use push_back() with number"`

		@complexity Logarithmic in the size of the container, O(log(`size()`)).

		@liveexample{The example shows how `push_back()` and `+=` can be used to
		add elements to a JSON object. Note how the `null` value was silently
		converted to a JSON object.,push_back__object_t__value}

		@since version 1.0.0
		*/
		void push_back(const typename object_t::value_type& val)
		{
			// push_back only works for null objects or objects
			if (JSON_UNLIKELY(not(is_null() or is_object())))
			{
				JSON_THROW(type_error::create(308, "cannot use push_back() with " + std::string(type_name())));
			}

			// transform null object into an object
			if (is_null())
			{
				m_type = value_t::object;
				m_value = value_t::object;
				assert_invariant();
			}

			// add element to array
			m_value.object->insert(val);
		}

		/*!
		@brief add an object to an object
		@copydoc push_back(const typename object_t::value_type&)
		*/
		reference operator+=(const typename object_t::value_type& val)
		{
			push_back(val);
			return *this;
		}

		/*!
		@brief add an object to an object

		This function allows to use `push_back` with an initializer list. In case

		1. the current value is an object,
		2. the initializer list @a init contains only two elements, and
		3. the first element of @a init is a string,

		@a init is converted into an object element and added using
		@ref push_back(const typename object_t::value_type&). Otherwise, @a init
		is converted to a JSON value and added using @ref push_back(basic_json&&).

		@param[in] init  an initializer list

		@complexity Linear in the size of the initializer list @a init.

		@note This function is required to resolve an ambiguous overload error,
			  because pairs like `{"key", "value"}` can be both interpreted as
			  `object_t::value_type` or `std::initializer_list<basic_json>`, see
			  https://github.com/nlohmann/json/issues/235 for more information.

		@liveexample{The example shows how initializer lists are treated as
		objects when possible.,push_back__initializer_list}
		*/
		void push_back(initializer_list_t init)
		{
			if (is_object() and init.size() == 2 and (*init.begin())->is_string())
			{
				basic_json&& key = init.begin()->moved_or_copied();
				push_back(typename object_t::value_type(
					std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
			}
			else
			{
				push_back(basic_json(init));
			}
		}

		/*!
		@brief add an object to an object
		@copydoc push_back(initializer_list_t)
		*/
		reference operator+=(initializer_list_t init)
		{
			push_back(init);
			return *this;
		}

		/*!
		@brief add an object to an array

		Creates a JSON value from the passed parameters @a args to the end of the
		JSON value. If the function is called on a JSON null value, an empty array
		is created before appending the value created from @a args.

		@param[in] args arguments to forward to a constructor of @ref basic_json
		@tparam Args compatible types to create a @ref basic_json object

		@throw type_error.311 when called on a type other than JSON array or
		null; example: `"cannot use emplace_back() with number"`

		@complexity Amortized constant.

		@liveexample{The example shows how `push_back()` can be used to add
		elements to a JSON array. Note how the `null` value was silently converted
		to a JSON array.,emplace_back}

		@since version 2.0.8
		*/
		template<class... Args>
		void emplace_back(Args&& ... args)
		{
			// emplace_back only works for null objects or arrays
			if (JSON_UNLIKELY(not(is_null() or is_array())))
			{
				JSON_THROW(type_error::create(311, "cannot use emplace_back() with " + std::string(type_name())));
			}

			// transform null object into an array
			if (is_null())
			{
				m_type = value_t::array;
				m_value = value_t::array;
				assert_invariant();
			}

			// add element to array (perfect forwarding)
			m_value.array->emplace_back(std::forward<Args>(args)...);
		}

		/*!
		@brief add an object to an object if key does not exist

		Inserts a new element into a JSON object constructed in-place with the
		given @a args if there is no element with the key in the container. If the
		function is called on a JSON null value, an empty object is created before
		appending the value created from @a args.

		@param[in] args arguments to forward to a constructor of @ref basic_json
		@tparam Args compatible types to create a @ref basic_json object

		@return a pair consisting of an iterator to the inserted element, or the
				already-existing element if no insertion happened, and a bool
				denoting whether the insertion took place.

		@throw type_error.311 when called on a type other than JSON object or
		null; example: `"cannot use emplace() with number"`

		@complexity Logarithmic in the size of the container, O(log(`size()`)).

		@liveexample{The example shows how `emplace()` can be used to add elements
		to a JSON object. Note how the `null` value was silently converted to a
		JSON object. Further note how no value is added if there was already one
		value stored with the same key.,emplace}

		@since version 2.0.8
		*/
		template<class... Args>
		std::pair<iterator, bool> emplace(Args&& ... args)
		{
			// emplace only works for null objects or arrays
			if (JSON_UNLIKELY(not(is_null() or is_object())))
			{
				JSON_THROW(type_error::create(311, "cannot use emplace() with " + std::string(type_name())));
			}

			// transform null object into an object
			if (is_null())
			{
				m_type = value_t::object;
				m_value = value_t::object;
				assert_invariant();
			}

			// add element to array (perfect forwarding)
			auto res = m_value.object->emplace(std::forward<Args>(args)...);
			// create result iterator and set iterator to the result of emplace
			auto it = begin();
			it.m_it.object_iterator = res.first;

			// return pair of iterator and boolean
			return { it, res.second };
		}

		/// Helper for insertion of an iterator
		/// @note: This uses std::distance to support GCC 4.8,
		///        see https://github.com/nlohmann/json/pull/1257
		template<typename... Args>
		iterator insert_iterator(const_iterator pos, Args&& ... args)
		{
			iterator result(this);
			assert(m_value.array != nullptr);

			auto insert_pos = std::distance(m_value.array->begin(), pos.m_it.array_iterator);
			m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);
			result.m_it.array_iterator = m_value.array->begin() + insert_pos;

			// This could have been written as:
			// result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, cnt, val);
			// but the return value of insert is missing in GCC 4.8, so it is written this way instead.

			return result;
		}

		/*!
		@brief inserts element

		Inserts element @a val before iterator @a pos.

		@param[in] pos iterator before which the content will be inserted; may be
		the end() iterator
		@param[in] val element to insert
		@return iterator pointing to the inserted @a val.

		@throw type_error.309 if called on JSON values other than arrays;
		example: `"cannot use insert() with string"`
		@throw invalid_iterator.202 if @a pos is not an iterator of *this;
		example: `"iterator does not fit current value"`

		@complexity Constant plus linear in the distance between @a pos and end of
		the container.

		@liveexample{The example shows how `insert()` is used.,insert}

		@since version 1.0.0
		*/
		iterator insert(const_iterator pos, const basic_json& val)
		{
			// insert only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				// check if iterator pos fits to this JSON value
				if (JSON_UNLIKELY(pos.m_object != this))
				{
					JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
				}

				// insert to array and return iterator
				return insert_iterator(pos, val);
			}

			JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
		}

		/*!
		@brief inserts element
		@copydoc insert(const_iterator, const basic_json&)
		*/
		iterator insert(const_iterator pos, basic_json&& val)
		{
			return insert(pos, val);
		}

		/*!
		@brief inserts elements

		Inserts @a cnt copies of @a val before iterator @a pos.

		@param[in] pos iterator before which the content will be inserted; may be
		the end() iterator
		@param[in] cnt number of copies of @a val to insert
		@param[in] val element to insert
		@return iterator pointing to the first element inserted, or @a pos if
		`cnt==0`

		@throw type_error.309 if called on JSON values other than arrays; example:
		`"cannot use insert() with string"`
		@throw invalid_iterator.202 if @a pos is not an iterator of *this;
		example: `"iterator does not fit current value"`

		@complexity Linear in @a cnt plus linear in the distance between @a pos
		and end of the container.

		@liveexample{The example shows how `insert()` is used.,insert__count}

		@since version 1.0.0
		*/
		iterator insert(const_iterator pos, size_type cnt, const basic_json& val)
		{
			// insert only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				// check if iterator pos fits to this JSON value
				if (JSON_UNLIKELY(pos.m_object != this))
				{
					JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
				}

				// insert to array and return iterator
				return insert_iterator(pos, cnt, val);
			}

			JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
		}

		/*!
		@brief inserts elements

		Inserts elements from range `[first, last)` before iterator @a pos.

		@param[in] pos iterator before which the content will be inserted; may be
		the end() iterator
		@param[in] first begin of the range of elements to insert
		@param[in] last end of the range of elements to insert

		@throw type_error.309 if called on JSON values other than arrays; example:
		`"cannot use insert() with string"`
		@throw invalid_iterator.202 if @a pos is not an iterator of *this;
		example: `"iterator does not fit current value"`
		@throw invalid_iterator.210 if @a first and @a last do not belong to the
		same JSON value; example: `"iterators do not fit"`
		@throw invalid_iterator.211 if @a first or @a last are iterators into
		container for which insert is called; example: `"passed iterators may not
		belong to container"`

		@return iterator pointing to the first element inserted, or @a pos if
		`first==last`

		@complexity Linear in `std::distance(first, last)` plus linear in the
		distance between @a pos and end of the container.

		@liveexample{The example shows how `insert()` is used.,insert__range}

		@since version 1.0.0
		*/
		iterator insert(const_iterator pos, const_iterator first, const_iterator last)
		{
			// insert only works for arrays
			if (JSON_UNLIKELY(not is_array()))
			{
				JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
			}

			// check if iterator pos fits to this JSON value
			if (JSON_UNLIKELY(pos.m_object != this))
			{
				JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
			}

			// check if range iterators belong to the same JSON object
			if (JSON_UNLIKELY(first.m_object != last.m_object))
			{
				JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
			}

			if (JSON_UNLIKELY(first.m_object == this))
			{
				JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container"));
			}

			// insert to array and return iterator
			return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
		}

		/*!
		@brief inserts elements

		Inserts elements from initializer list @a ilist before iterator @a pos.

		@param[in] pos iterator before which the content will be inserted; may be
		the end() iterator
		@param[in] ilist initializer list to insert the values from

		@throw type_error.309 if called on JSON values other than arrays; example:
		`"cannot use insert() with string"`
		@throw invalid_iterator.202 if @a pos is not an iterator of *this;
		example: `"iterator does not fit current value"`

		@return iterator pointing to the first element inserted, or @a pos if
		`ilist` is empty

		@complexity Linear in `ilist.size()` plus linear in the distance between
		@a pos and end of the container.

		@liveexample{The example shows how `insert()` is used.,insert__ilist}

		@since version 1.0.0
		*/
		iterator insert(const_iterator pos, initializer_list_t ilist)
		{
			// insert only works for arrays
			if (JSON_UNLIKELY(not is_array()))
			{
				JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
			}

			// check if iterator pos fits to this JSON value
			if (JSON_UNLIKELY(pos.m_object != this))
			{
				JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value"));
			}

			// insert to array and return iterator
			return insert_iterator(pos, ilist.begin(), ilist.end());
		}

		/*!
		@brief inserts elements

		Inserts elements from range `[first, last)`.

		@param[in] first begin of the range of elements to insert
		@param[in] last end of the range of elements to insert

		@throw type_error.309 if called on JSON values other than objects; example:
		`"cannot use insert() with string"`
		@throw invalid_iterator.202 if iterator @a first or @a last does does not
		point to an object; example: `"iterators first and last must point to
		objects"`
		@throw invalid_iterator.210 if @a first and @a last do not belong to the
		same JSON value; example: `"iterators do not fit"`

		@complexity Logarithmic: `O(N*log(size() + N))`, where `N` is the number
		of elements to insert.

		@liveexample{The example shows how `insert()` is used.,insert__range_object}

		@since version 3.0.0
		*/
		void insert(const_iterator first, const_iterator last)
		{
			// insert only works for objects
			if (JSON_UNLIKELY(not is_object()))
			{
				JSON_THROW(type_error::create(309, "cannot use insert() with " + std::string(type_name())));
			}

			// check if range iterators belong to the same JSON object
			if (JSON_UNLIKELY(first.m_object != last.m_object))
			{
				JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
			}

			// passed iterators must belong to objects
			if (JSON_UNLIKELY(not first.m_object->is_object()))
			{
				JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
			}

			m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
		}

		/*!
		@brief updates a JSON object from another object, overwriting existing keys

		Inserts all values from JSON object @a j and overwrites existing keys.

		@param[in] j  JSON object to read values from

		@throw type_error.312 if called on JSON values other than objects; example:
		`"cannot use update() with string"`

		@complexity O(N*log(size() + N)), where N is the number of elements to
					insert.

		@liveexample{The example shows how `update()` is used.,update}

		@sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

		@since version 3.0.0
		*/
		void update(const_reference j)
		{
			// implicitly convert null value to an empty object
			if (is_null())
			{
				m_type = value_t::object;
				m_value.object = create<object_t>();
				assert_invariant();
			}

			if (JSON_UNLIKELY(not is_object()))
			{
				JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
			}
			if (JSON_UNLIKELY(not j.is_object()))
			{
				JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(j.type_name())));
			}

			for (auto it = j.cbegin(); it != j.cend(); ++it)
			{
				m_value.object->operator[](it.key()) = it.value();
			}
		}

		/*!
		@brief updates a JSON object from another object, overwriting existing keys

		Inserts all values from from range `[first, last)` and overwrites existing
		keys.

		@param[in] first begin of the range of elements to insert
		@param[in] last end of the range of elements to insert

		@throw type_error.312 if called on JSON values other than objects; example:
		`"cannot use update() with string"`
		@throw invalid_iterator.202 if iterator @a first or @a last does does not
		point to an object; example: `"iterators first and last must point to
		objects"`
		@throw invalid_iterator.210 if @a first and @a last do not belong to the
		same JSON value; example: `"iterators do not fit"`

		@complexity O(N*log(size() + N)), where N is the number of elements to
					insert.

		@liveexample{The example shows how `update()` is used__range.,update}

		@sa https://docs.python.org/3.6/library/stdtypes.html#dict.update

		@since version 3.0.0
		*/
		void update(const_iterator first, const_iterator last)
		{
			// implicitly convert null value to an empty object
			if (is_null())
			{
				m_type = value_t::object;
				m_value.object = create<object_t>();
				assert_invariant();
			}

			if (JSON_UNLIKELY(not is_object()))
			{
				JSON_THROW(type_error::create(312, "cannot use update() with " + std::string(type_name())));
			}

			// check if range iterators belong to the same JSON object
			if (JSON_UNLIKELY(first.m_object != last.m_object))
			{
				JSON_THROW(invalid_iterator::create(210, "iterators do not fit"));
			}

			// passed iterators must belong to objects
			if (JSON_UNLIKELY(not first.m_object->is_object()
				or not last.m_object->is_object()))
			{
				JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects"));
			}

			for (auto it = first; it != last; ++it)
			{
				m_value.object->operator[](it.key()) = it.value();
			}
		}

		/*!
		@brief exchanges the values

		Exchanges the contents of the JSON value with those of @a other. Does not
		invoke any move, copy, or swap operations on individual elements. All
		iterators and references remain valid. The past-the-end iterator is
		invalidated.

		@param[in,out] other JSON value to exchange the contents with

		@complexity Constant.

		@liveexample{The example below shows how JSON values can be swapped with
		`swap()`.,swap__reference}

		@since version 1.0.0
		*/
		void swap(reference other) noexcept (
			std::is_nothrow_move_constructible<value_t>::value and
			std::is_nothrow_move_assignable<value_t>::value and
			std::is_nothrow_move_constructible<json_value>::value and
			std::is_nothrow_move_assignable<json_value>::value
			)
		{
			std::swap(m_type, other.m_type);
			std::swap(m_value, other.m_value);
			assert_invariant();
		}

		/*!
		@brief exchanges the values

		Exchanges the contents of a JSON array with those of @a other. Does not
		invoke any move, copy, or swap operations on individual elements. All
		iterators and references remain valid. The past-the-end iterator is
		invalidated.

		@param[in,out] other array to exchange the contents with

		@throw type_error.310 when JSON value is not an array; example: `"cannot
		use swap() with string"`

		@complexity Constant.

		@liveexample{The example below shows how arrays can be swapped with
		`swap()`.,swap__array_t}

		@since version 1.0.0
		*/
		void swap(array_t& other)
		{
			// swap only works for arrays
			if (JSON_LIKELY(is_array()))
			{
				std::swap(*(m_value.array), other);
			}
			else
			{
				JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
			}
		}

		/*!
		@brief exchanges the values

		Exchanges the contents of a JSON object with those of @a other. Does not
		invoke any move, copy, or swap operations on individual elements. All
		iterators and references remain valid. The past-the-end iterator is
		invalidated.

		@param[in,out] other object to exchange the contents with

		@throw type_error.310 when JSON value is not an object; example:
		`"cannot use swap() with string"`

		@complexity Constant.

		@liveexample{The example below shows how objects can be swapped with
		`swap()`.,swap__object_t}

		@since version 1.0.0
		*/
		void swap(object_t& other)
		{
			// swap only works for objects
			if (JSON_LIKELY(is_object()))
			{
				std::swap(*(m_value.object), other);
			}
			else
			{
				JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
			}
		}

		/*!
		@brief exchanges the values

		Exchanges the contents of a JSON string with those of @a other. Does not
		invoke any move, copy, or swap operations on individual elements. All
		iterators and references remain valid. The past-the-end iterator is
		invalidated.

		@param[in,out] other string to exchange the contents with

		@throw type_error.310 when JSON value is not a string; example: `"cannot
		use swap() with boolean"`

		@complexity Constant.

		@liveexample{The example below shows how strings can be swapped with
		`swap()`.,swap__string_t}

		@since version 1.0.0
		*/
		void swap(string_t& other)
		{
			// swap only works for strings
			if (JSON_LIKELY(is_string()))
			{
				std::swap(*(m_value.string), other);
			}
			else
			{
				JSON_THROW(type_error::create(310, "cannot use swap() with " + std::string(type_name())));
			}
		}

		/// @}

	public:
		//////////////////////////////////////////
		// lexicographical comparison operators //
		//////////////////////////////////////////

		/// @name lexicographical comparison operators
		/// @{

		/*!
		@brief comparison: equal

		Compares two JSON values for equality according to the following rules:
		- Two JSON values are equal if (1) they are from the same type and (2)
		  their stored values are the same according to their respective
		  `operator==`.
		- Integer and floating-point numbers are automatically converted before
		  comparison. Note than two NaN values are always treated as unequal.
		- Two JSON null values are equal.

		@note Floating-point inside JSON values numbers are compared with
		`json::number_float_t::operator==` which is `double::operator==` by
		default. To compare floating-point while respecting an epsilon, an alternative
		[comparison function](https://github.com/mariokonrad/marnav/blob/master/src/marnav/math/floatingpoint.hpp#L34-#L39)
		could be used, for instance
		@code {.cpp}
		template<typename T, typename = typename std::enable_if<std::is_floating_point<T>::value, T>::type>
		inline bool is_same(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept
		{
			return std::abs(a - b) <= epsilon;
		}
		@endcode

		@note NaN values never compare equal to themselves or to other NaN values.

		@param[in] lhs  first JSON value to consider
		@param[in] rhs  second JSON value to consider
		@return whether the values @a lhs and @a rhs are equal

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@complexity Linear.

		@liveexample{The example demonstrates comparing several JSON
		types.,operator__equal}

		@since version 1.0.0
		*/
		friend bool operator==(const_reference lhs, const_reference rhs) noexcept
		{
			const auto lhs_type = lhs.type();
			const auto rhs_type = rhs.type();

			if (lhs_type == rhs_type)
			{
				switch (lhs_type)
				{
				case value_t::array:
					return (*lhs.m_value.array == *rhs.m_value.array);

				case value_t::object:
					return (*lhs.m_value.object == *rhs.m_value.object);

				case value_t::null:
					return true;

				case value_t::string:
					return (*lhs.m_value.string == *rhs.m_value.string);

				case value_t::boolean:
					return (lhs.m_value.boolean == rhs.m_value.boolean);

				case value_t::number_integer:
					return (lhs.m_value.number_integer == rhs.m_value.number_integer);

				case value_t::number_unsigned:
					return (lhs.m_value.number_unsigned == rhs.m_value.number_unsigned);

				case value_t::number_float:
					return (lhs.m_value.number_float == rhs.m_value.number_float);

				default:
					return false;
				}
			}
			else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
			{
				return (static_cast<number_float_t>(lhs.m_value.number_integer) == rhs.m_value.number_float);
			}
			else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
			{
				return (lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_integer));
			}
			else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
			{
				return (static_cast<number_float_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_float);
			}
			else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
			{
				return (lhs.m_value.number_float == static_cast<number_float_t>(rhs.m_value.number_unsigned));
			}
			else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
			{
				return (static_cast<number_integer_t>(lhs.m_value.number_unsigned) == rhs.m_value.number_integer);
			}
			else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
			{
				return (lhs.m_value.number_integer == static_cast<number_integer_t>(rhs.m_value.number_unsigned));
			}

			return false;
		}

		/*!
		@brief comparison: equal
		@copydoc operator==(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator==(const_reference lhs, const ScalarType rhs) noexcept
		{
			return (lhs == basic_json(rhs));
		}

		/*!
		@brief comparison: equal
		@copydoc operator==(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator==(const ScalarType lhs, const_reference rhs) noexcept
		{
			return (basic_json(lhs) == rhs);
		}

		/*!
		@brief comparison: not equal

		Compares two JSON values for inequality by calculating `not (lhs == rhs)`.

		@param[in] lhs  first JSON value to consider
		@param[in] rhs  second JSON value to consider
		@return whether the values @a lhs and @a rhs are not equal

		@complexity Linear.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@liveexample{The example demonstrates comparing several JSON
		types.,operator__notequal}

		@since version 1.0.0
		*/
		friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
		{
			return not (lhs == rhs);
		}

		/*!
		@brief comparison: not equal
		@copydoc operator!=(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator!=(const_reference lhs, const ScalarType rhs) noexcept
		{
			return (lhs != basic_json(rhs));
		}

		/*!
		@brief comparison: not equal
		@copydoc operator!=(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator!=(const ScalarType lhs, const_reference rhs) noexcept
		{
			return (basic_json(lhs) != rhs);
		}

		/*!
		@brief comparison: less than

		Compares whether one JSON value @a lhs is less than another JSON value @a
		rhs according to the following rules:
		- If @a lhs and @a rhs have the same type, the values are compared using
		  the default `<` operator.
		- Integer and floating-point numbers are automatically converted before
		  comparison
		- In case @a lhs and @a rhs have different types, the values are ignored
		  and the order of the types is considered, see
		  @ref operator<(const value_t, const value_t).

		@param[in] lhs  first JSON value to consider
		@param[in] rhs  second JSON value to consider
		@return whether @a lhs is less than @a rhs

		@complexity Linear.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@liveexample{The example demonstrates comparing several JSON
		types.,operator__less}

		@since version 1.0.0
		*/
		friend bool operator<(const_reference lhs, const_reference rhs) noexcept
		{
			const auto lhs_type = lhs.type();
			const auto rhs_type = rhs.type();

			if (lhs_type == rhs_type)
			{
				switch (lhs_type)
				{
				case value_t::array:
					return (*lhs.m_value.array) < (*rhs.m_value.array);

				case value_t::object:
					return *lhs.m_value.object < *rhs.m_value.object;

				case value_t::null:
					return false;

				case value_t::string:
					return *lhs.m_value.string < *rhs.m_value.string;

				case value_t::boolean:
					return lhs.m_value.boolean < rhs.m_value.boolean;

				case value_t::number_integer:
					return lhs.m_value.number_integer < rhs.m_value.number_integer;

				case value_t::number_unsigned:
					return lhs.m_value.number_unsigned < rhs.m_value.number_unsigned;

				case value_t::number_float:
					return lhs.m_value.number_float < rhs.m_value.number_float;

				default:
					return false;
				}
			}
			else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_float)
			{
				return static_cast<number_float_t>(lhs.m_value.number_integer) < rhs.m_value.number_float;
			}
			else if (lhs_type == value_t::number_float and rhs_type == value_t::number_integer)
			{
				return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_integer);
			}
			else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_float)
			{
				return static_cast<number_float_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_float;
			}
			else if (lhs_type == value_t::number_float and rhs_type == value_t::number_unsigned)
			{
				return lhs.m_value.number_float < static_cast<number_float_t>(rhs.m_value.number_unsigned);
			}
			else if (lhs_type == value_t::number_integer and rhs_type == value_t::number_unsigned)
			{
				return lhs.m_value.number_integer < static_cast<number_integer_t>(rhs.m_value.number_unsigned);
			}
			else if (lhs_type == value_t::number_unsigned and rhs_type == value_t::number_integer)
			{
				return static_cast<number_integer_t>(lhs.m_value.number_unsigned) < rhs.m_value.number_integer;
			}

			// We only reach this line if we cannot compare values. In that case,
			// we compare types. Note we have to call the operator explicitly,
			// because MSVC has problems otherwise.
			return operator<(lhs_type, rhs_type);
		}

		/*!
		@brief comparison: less than
		@copydoc operator<(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator<(const_reference lhs, const ScalarType rhs) noexcept
		{
			return (lhs < basic_json(rhs));
		}

		/*!
		@brief comparison: less than
		@copydoc operator<(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator<(const ScalarType lhs, const_reference rhs) noexcept
		{
			return (basic_json(lhs) < rhs);
		}

		/*!
		@brief comparison: less than or equal

		Compares whether one JSON value @a lhs is less than or equal to another
		JSON value by calculating `not (rhs < lhs)`.

		@param[in] lhs  first JSON value to consider
		@param[in] rhs  second JSON value to consider
		@return whether @a lhs is less than or equal to @a rhs

		@complexity Linear.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@liveexample{The example demonstrates comparing several JSON
		types.,operator__greater}

		@since version 1.0.0
		*/
		friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
		{
			return not (rhs < lhs);
		}

		/*!
		@brief comparison: less than or equal
		@copydoc operator<=(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator<=(const_reference lhs, const ScalarType rhs) noexcept
		{
			return (lhs <= basic_json(rhs));
		}

		/*!
		@brief comparison: less than or equal
		@copydoc operator<=(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator<=(const ScalarType lhs, const_reference rhs) noexcept
		{
			return (basic_json(lhs) <= rhs);
		}

		/*!
		@brief comparison: greater than

		Compares whether one JSON value @a lhs is greater than another
		JSON value by calculating `not (lhs <= rhs)`.

		@param[in] lhs  first JSON value to consider
		@param[in] rhs  second JSON value to consider
		@return whether @a lhs is greater than to @a rhs

		@complexity Linear.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@liveexample{The example demonstrates comparing several JSON
		types.,operator__lessequal}

		@since version 1.0.0
		*/
		friend bool operator>(const_reference lhs, const_reference rhs) noexcept
		{
			return not (lhs <= rhs);
		}

		/*!
		@brief comparison: greater than
		@copydoc operator>(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator>(const_reference lhs, const ScalarType rhs) noexcept
		{
			return (lhs > basic_json(rhs));
		}

		/*!
		@brief comparison: greater than
		@copydoc operator>(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator>(const ScalarType lhs, const_reference rhs) noexcept
		{
			return (basic_json(lhs) > rhs);
		}

		/*!
		@brief comparison: greater than or equal

		Compares whether one JSON value @a lhs is greater than or equal to another
		JSON value by calculating `not (lhs < rhs)`.

		@param[in] lhs  first JSON value to consider
		@param[in] rhs  second JSON value to consider
		@return whether @a lhs is greater than or equal to @a rhs

		@complexity Linear.

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@liveexample{The example demonstrates comparing several JSON
		types.,operator__greaterequal}

		@since version 1.0.0
		*/
		friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
		{
			return not (lhs < rhs);
		}

		/*!
		@brief comparison: greater than or equal
		@copydoc operator>=(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator>=(const_reference lhs, const ScalarType rhs) noexcept
		{
			return (lhs >= basic_json(rhs));
		}

		/*!
		@brief comparison: greater than or equal
		@copydoc operator>=(const_reference, const_reference)
		*/
		template<typename ScalarType, typename std::enable_if<
			std::is_scalar<ScalarType>::value, int>::type = 0>
			friend bool operator>=(const ScalarType lhs, const_reference rhs) noexcept
		{
			return (basic_json(lhs) >= rhs);
		}

		/// @}

		///////////////////
		// serialization //
		///////////////////

		/// @name serialization
		/// @{

		/*!
		@brief serialize to stream

		Serialize the given JSON value @a j to the output stream @a o. The JSON
		value will be serialized using the @ref dump member function.

		- The indentation of the output can be controlled with the member variable
		  `width` of the output stream @a o. For instance, using the manipulator
		  `std::setw(4)` on @a o sets the indentation level to `4` and the
		  serialization result is the same as calling `dump(4)`.

		- The indentation character can be controlled with the member variable
		  `fill` of the output stream @a o. For instance, the manipulator
		  `std::setfill('\\t')` sets indentation to use a tab character rather than
		  the default space character.

		@param[in,out] o  stream to serialize to
		@param[in] j  JSON value to serialize

		@return the stream @a o

		@throw type_error.316 if a string stored inside the JSON value is not
							  UTF-8 encoded

		@complexity Linear.

		@liveexample{The example below shows the serialization with different
		parameters to `width` to adjust the indentation level.,operator_serialize}

		@since version 1.0.0; indentation character added in version 3.0.0
		*/
		friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
		{
			// read width member and use it as indentation parameter if nonzero
			const bool pretty_print = (o.width() > 0);
			const auto indentation = (pretty_print ? o.width() : 0);

			// reset width to 0 for subsequent calls to this stream
			o.width(0);

			// do the actual serialization
			serializer s(detail::output_adapter<char>(o), o.fill());
			s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
			return o;
		}

		/*!
		@brief serialize to stream
		@deprecated This stream operator is deprecated and will be removed in
					future 4.0.0 of the library. Please use
					@ref operator<<(std::ostream&, const basic_json&)
					instead; that is, replace calls like `j >> o;` with `o << j;`.
		@since version 1.0.0; deprecated since version 3.0.0
		*/
		JSON_DEPRECATED
			friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
		{
			return o << j;
		}

		/// @}


		/////////////////////
		// deserialization //
		/////////////////////

		/// @name deserialization
		/// @{

		/*!
		@brief deserialize from a compatible input

		This function reads from a compatible input. Examples are:
		- an array of 1-byte values
		- strings with character/literal type with size of 1 byte
		- input streams
		- container with contiguous storage of 1-byte values. Compatible container
		  types include `std::vector`, `std::string`, `std::array`,
		  `std::valarray`, and `std::initializer_list`. Furthermore, C-style
		  arrays can be used with `std::begin()`/`std::end()`. User-defined
		  containers can be used as long as they implement random-access iterators
		  and a contiguous storage.

		@pre Each element of the container has a size of 1 byte. Violating this
		precondition yields undefined behavior. **This precondition is enforced
		with a static assertion.**

		@pre The container storage is contiguous. Violating this precondition
		yields undefined behavior. **This precondition is enforced with an
		assertion.**
		@pre Each element of the container has a size of 1 byte. Violating this
		precondition yields undefined behavior. **This precondition is enforced
		with a static assertion.**

		@warning There is no way to enforce all preconditions at compile-time. If
				 the function is called with a noncompliant container and with
				 assertions switched off, the behavior is undefined and will most
				 likely yield segmentation violation.

		@param[in] i  input to read from
		@param[in] cb  a parser callback function of type @ref parser_callback_t
		which is used to control the deserialization by filtering unwanted values
		(optional)

		@return result of the deserialization

		@throw parse_error.101 if a parse error occurs; example: `""unexpected end
		of input; expected string literal""`
		@throw parse_error.102 if to_unicode fails or surrogate error
		@throw parse_error.103 if to_unicode fails

		@complexity Linear in the length of the input. The parser is a predictive
		LL(1) parser. The complexity can be higher if the parser callback function
		@a cb has a super-linear complexity.

		@note A UTF-8 byte order mark is silently ignored.

		@liveexample{The example below demonstrates the `parse()` function reading
		from an array.,parse__array__parser_callback_t}

		@liveexample{The example below demonstrates the `parse()` function with
		and without callback function.,parse__string__parser_callback_t}

		@liveexample{The example below demonstrates the `parse()` function with
		and without callback function.,parse__istream__parser_callback_t}

		@liveexample{The example below demonstrates the `parse()` function reading
		from a contiguous container.,parse__contiguouscontainer__parser_callback_t}

		@since version 2.0.3 (contiguous containers)
		*/
		static basic_json parse(detail::input_adapter&& i,
			const parser_callback_t cb = nullptr,
			const bool allow_exceptions = true)
		{
			basic_json result;
			parser(i, cb, allow_exceptions).parse(true, result);
			return result;
		}

		static bool accept(detail::input_adapter&& i)
		{
			return parser(i).accept(true);
		}

		/*!
		@brief generate SAX events

		The SAX event lister must follow the interface of @ref json_sax.

		This function reads from a compatible input. Examples are:
		- an array of 1-byte values
		- strings with character/literal type with size of 1 byte
		- input streams
		- container with contiguous storage of 1-byte values. Compatible container
		  types include `std::vector`, `std::string`, `std::array`,
		  `std::valarray`, and `std::initializer_list`. Furthermore, C-style
		  arrays can be used with `std::begin()`/`std::end()`. User-defined
		  containers can be used as long as they implement random-access iterators
		  and a contiguous storage.

		@pre Each element of the container has a size of 1 byte. Violating this
		precondition yields undefined behavior. **This precondition is enforced
		with a static assertion.**

		@pre The container storage is contiguous. Violating this precondition
		yields undefined behavior. **This precondition is enforced with an
		assertion.**
		@pre Each element of the container has a size of 1 byte. Violating this
		precondition yields undefined behavior. **This precondition is enforced
		with a static assertion.**

		@warning There is no way to enforce all preconditions at compile-time. If
				 the function is called with a noncompliant container and with
				 assertions switched off, the behavior is undefined and will most
				 likely yield segmentation violation.

		@param[in] i  input to read from
		@param[in,out] sax  SAX event listener
		@param[in] format  the format to parse (JSON, CBOR, MessagePack, or UBJSON)
		@param[in] strict  whether the input has to be consumed completely

		@return return value of the last processed SAX event

		@throw parse_error.101 if a parse error occurs; example: `""unexpected end
		of input; expected string literal""`
		@throw parse_error.102 if to_unicode fails or surrogate error
		@throw parse_error.103 if to_unicode fails

		@complexity Linear in the length of the input. The parser is a predictive
		LL(1) parser. The complexity can be higher if the SAX consumer @a sax has
		a super-linear complexity.

		@note A UTF-8 byte order mark is silently ignored.

		@liveexample{The example below demonstrates the `sax_parse()` function
		reading from string and processing the events with a user-defined SAX
		event consumer.,sax_parse}

		@since version 3.2.0
		*/
		template <typename SAX>
		static bool sax_parse(detail::input_adapter&& i, SAX* sax,
			input_format_t format = input_format_t::json,
			const bool strict = true)
		{
			assert(sax);
			switch (format)
			{
			case input_format_t::json:
				return parser(std::move(i)).sax_parse(sax, strict);
			default:
				return detail::binary_reader<basic_json, SAX>(std::move(i)).sax_parse(format, sax, strict);
			}
		}

		/*!
		@brief deserialize from an iterator range with contiguous storage

		This function reads from an iterator range of a container with contiguous
		storage of 1-byte values. Compatible container types include
		`std::vector`, `std::string`, `std::array`, `std::valarray`, and
		`std::initializer_list`. Furthermore, C-style arrays can be used with
		`std::begin()`/`std::end()`. User-defined containers can be used as long
		as they implement random-access iterators and a contiguous storage.

		@pre The iterator range is contiguous. Violating this precondition yields
		undefined behavior. **This precondition is enforced with an assertion.**
		@pre Each element in the range has a size of 1 byte. Violating this
		precondition yields undefined behavior. **This precondition is enforced
		with a static assertion.**

		@warning There is no way to enforce all preconditions at compile-time. If
				 the function is called with noncompliant iterators and with
				 assertions switched off, the behavior is undefined and will most
				 likely yield segmentation violation.

		@tparam IteratorType iterator of container with contiguous storage
		@param[in] first  begin of the range to parse (included)
		@param[in] last  end of the range to parse (excluded)
		@param[in] cb  a parser callback function of type @ref parser_callback_t
		which is used to control the deserialization by filtering unwanted values
		(optional)
		@param[in] allow_exceptions  whether to throw exceptions in case of a
		parse error (optional, true by default)

		@return result of the deserialization

		@throw parse_error.101 in case of an unexpected token
		@throw parse_error.102 if to_unicode fails or surrogate error
		@throw parse_error.103 if to_unicode fails

		@complexity Linear in the length of the input. The parser is a predictive
		LL(1) parser. The complexity can be higher if the parser callback function
		@a cb has a super-linear complexity.

		@note A UTF-8 byte order mark is silently ignored.

		@liveexample{The example below demonstrates the `parse()` function reading
		from an iterator range.,parse__iteratortype__parser_callback_t}

		@since version 2.0.3
		*/
		template<class IteratorType, typename std::enable_if<
			std::is_base_of<
			std::random_access_iterator_tag,
			typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
			static basic_json parse(IteratorType first, IteratorType last,
				const parser_callback_t cb = nullptr,
				const bool allow_exceptions = true)
		{
			basic_json result;
			parser(detail::input_adapter(first, last), cb, allow_exceptions).parse(true, result);
			return result;
		}

		template<class IteratorType, typename std::enable_if<
			std::is_base_of<
			std::random_access_iterator_tag,
			typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
			static bool accept(IteratorType first, IteratorType last)
		{
			return parser(detail::input_adapter(first, last)).accept(true);
		}

		template<class IteratorType, class SAX, typename std::enable_if<
			std::is_base_of<
			std::random_access_iterator_tag,
			typename std::iterator_traits<IteratorType>::iterator_category>::value, int>::type = 0>
			static bool sax_parse(IteratorType first, IteratorType last, SAX* sax)
		{
			return parser(detail::input_adapter(first, last)).sax_parse(sax);
		}

		/*!
		@brief deserialize from stream
		@deprecated This stream operator is deprecated and will be removed in
					version 4.0.0 of the library. Please use
					@ref operator>>(std::istream&, basic_json&)
					instead; that is, replace calls like `j << i;` with `i >> j;`.
		@since version 1.0.0; deprecated since version 3.0.0
		*/
		JSON_DEPRECATED
			friend std::istream& operator<<(basic_json& j, std::istream& i)
		{
			return operator>>(i, j);
		}

		/*!
		@brief deserialize from stream

		Deserializes an input stream to a JSON value.

		@param[in,out] i  input stream to read a serialized JSON value from
		@param[in,out] j  JSON value to write the deserialized input to

		@throw parse_error.101 in case of an unexpected token
		@throw parse_error.102 if to_unicode fails or surrogate error
		@throw parse_error.103 if to_unicode fails

		@complexity Linear in the length of the input. The parser is a predictive
		LL(1) parser.

		@note A UTF-8 byte order mark is silently ignored.

		@liveexample{The example below shows how a JSON value is constructed by
		reading a serialization from a stream.,operator_deserialize}

		@sa parse(std::istream&, const parser_callback_t) for a variant with a
		parser callback function to filter values while parsing

		@since version 1.0.0
		*/
		friend std::istream& operator>>(std::istream& i, basic_json& j)
		{
			parser(detail::input_adapter(i)).parse(false, j);
			return i;
		}

		/// @}

		///////////////////////////
		// convenience functions //
		///////////////////////////

		/*!
		@brief return the type as string

		Returns the type name as string to be used in error messages - usually to
		indicate that a function was called on a wrong JSON type.

		@return a string representation of a the @a m_type member:
				Value type  | return value
				----------- | -------------
				null        | `"null"`
				boolean     | `"boolean"`
				string      | `"string"`
				number      | `"number"` (for all number types)
				object      | `"object"`
				array       | `"array"`
				discarded   | `"discarded"`

		@exceptionsafety No-throw guarantee: this function never throws exceptions.

		@complexity Constant.

		@liveexample{The following code exemplifies `type_name()` for all JSON
		types.,type_name}

		@sa @ref type() -- return the type of the JSON value
		@sa @ref operator value_t() -- return the type of the JSON value (implicit)

		@since version 1.0.0, public since 2.1.0, `const char*` and `noexcept`
		since 3.0.0
		*/
		const char* type_name() const noexcept
		{
			{
				switch (m_type)
				{
				case value_t::null:
					return "null";
				case value_t::object:
					return "object";
				case value_t::array:
					return "array";
				case value_t::string:
					return "string";
				case value_t::boolean:
					return "boolean";
				case value_t::discarded:
					return "discarded";
				default:
					return "number";
				}
			}
		}


	private:
		//////////////////////
		// member variables //
		//////////////////////

		/// the type of the current element
		value_t m_type = value_t::null;

		/// the value of the current element
		json_value m_value = {};

		//////////////////////////////////////////
		// binary serialization/deserialization //
		//////////////////////////////////////////

		/// @name binary serialization/deserialization support
		/// @{

	public:
		/*!
		@brief create a CBOR serialization of a given JSON value

		Serializes a given JSON value @a j to a byte vector using the CBOR (Concise
		Binary Object Representation) serialization format. CBOR is a binary
		serialization format which aims to be more compact than JSON itself, yet
		more efficient to parse.

		The library uses the following mapping from JSON values types to
		CBOR types according to the CBOR specification (RFC 7049):

		JSON value type | value/range                                | CBOR type                          | first byte
		--------------- | ------------------------------------------ | ---------------------------------- | ---------------
		null            | `null`                                     | Null                               | 0xF6
		boolean         | `true`                                     | True                               | 0xF5
		boolean         | `false`                                    | False                              | 0xF4
		number_integer  | -9223372036854775808..-2147483649          | Negative integer (8 bytes follow)  | 0x3B
		number_integer  | -2147483648..-32769                        | Negative integer (4 bytes follow)  | 0x3A
		number_integer  | -32768..-129                               | Negative integer (2 bytes follow)  | 0x39
		number_integer  | -128..-25                                  | Negative integer (1 byte follow)   | 0x38
		number_integer  | -24..-1                                    | Negative integer                   | 0x20..0x37
		number_integer  | 0..23                                      | Integer                            | 0x00..0x17
		number_integer  | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
		number_integer  | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
		number_integer  | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
		number_integer  | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
		number_unsigned | 0..23                                      | Integer                            | 0x00..0x17
		number_unsigned | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18
		number_unsigned | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19
		number_unsigned | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A
		number_unsigned | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B
		number_float    | *any value*                                | Double-Precision Float             | 0xFB
		string          | *length*: 0..23                            | UTF-8 string                       | 0x60..0x77
		string          | *length*: 23..255                          | UTF-8 string (1 byte follow)       | 0x78
		string          | *length*: 256..65535                       | UTF-8 string (2 bytes follow)      | 0x79
		string          | *length*: 65536..4294967295                | UTF-8 string (4 bytes follow)      | 0x7A
		string          | *length*: 4294967296..18446744073709551615 | UTF-8 string (8 bytes follow)      | 0x7B
		array           | *size*: 0..23                              | array                              | 0x80..0x97
		array           | *size*: 23..255                            | array (1 byte follow)              | 0x98
		array           | *size*: 256..65535                         | array (2 bytes follow)             | 0x99
		array           | *size*: 65536..4294967295                  | array (4 bytes follow)             | 0x9A
		array           | *size*: 4294967296..18446744073709551615   | array (8 bytes follow)             | 0x9B
		object          | *size*: 0..23                              | map                                | 0xA0..0xB7
		object          | *size*: 23..255                            | map (1 byte follow)                | 0xB8
		object          | *size*: 256..65535                         | map (2 bytes follow)               | 0xB9
		object          | *size*: 65536..4294967295                  | map (4 bytes follow)               | 0xBA
		object          | *size*: 4294967296..18446744073709551615   | map (8 bytes follow)               | 0xBB

		@note The mapping is **complete** in the sense that any JSON value type
			  can be converted to a CBOR value.

		@note If NaN or Infinity are stored inside a JSON number, they are
			  serialized properly. This behavior differs from the @ref dump()
			  function which serializes NaN or Infinity to `null`.

		@note The following CBOR types are not used in the conversion:
			  - byte strings (0x40..0x5F)
			  - UTF-8 strings terminated by "break" (0x7F)
			  - arrays terminated by "break" (0x9F)
			  - maps terminated by "break" (0xBF)
			  - date/time (0xC0..0xC1)
			  - bignum (0xC2..0xC3)
			  - decimal fraction (0xC4)
			  - bigfloat (0xC5)
			  - tagged items (0xC6..0xD4, 0xD8..0xDB)
			  - expected conversions (0xD5..0xD7)
			  - simple values (0xE0..0xF3, 0xF8)
			  - undefined (0xF7)
			  - half and single-precision floats (0xF9-0xFA)
			  - break (0xFF)

		@param[in] j  JSON value to serialize
		@return MessagePack serialization as byte vector

		@complexity Linear in the size of the JSON value @a j.

		@liveexample{The example shows the serialization of a JSON value to a byte
		vector in CBOR format.,to_cbor}

		@sa http://cbor.io
		@sa @ref from_cbor(detail::input_adapter, const bool strict) for the
			analogous deserialization
		@sa @ref to_msgpack(const basic_json&) for the related MessagePack format
		@sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
				 related UBJSON format

		@since version 2.0.9
		*/
		static std::vector<uint8_t> to_cbor(const basic_json& j)
		{
			std::vector<uint8_t> result;
			to_cbor(j, result);
			return result;
		}

		static void to_cbor(const basic_json& j, detail::output_adapter<uint8_t> o)
		{
			binary_writer<uint8_t>(o).write_cbor(j);
		}

		static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
		{
			binary_writer<char>(o).write_cbor(j);
		}

		/*!
		@brief create a MessagePack serialization of a given JSON value

		Serializes a given JSON value @a j to a byte vector using the MessagePack
		serialization format. MessagePack is a binary serialization format which
		aims to be more compact than JSON itself, yet more efficient to parse.

		The library uses the following mapping from JSON values types to
		MessagePack types according to the MessagePack specification:

		JSON value type | value/range                       | MessagePack type | first byte
		--------------- | --------------------------------- | ---------------- | ----------
		null            | `null`                            | nil              | 0xC0
		boolean         | `true`                            | true             | 0xC3
		boolean         | `false`                           | false            | 0xC2
		number_integer  | -9223372036854775808..-2147483649 | int64            | 0xD3
		number_integer  | -2147483648..-32769               | int32            | 0xD2
		number_integer  | -32768..-129                      | int16            | 0xD1
		number_integer  | -128..-33                         | int8             | 0xD0
		number_integer  | -32..-1                           | negative fixint  | 0xE0..0xFF
		number_integer  | 0..127                            | positive fixint  | 0x00..0x7F
		number_integer  | 128..255                          | uint 8           | 0xCC
		number_integer  | 256..65535                        | uint 16          | 0xCD
		number_integer  | 65536..4294967295                 | uint 32          | 0xCE
		number_integer  | 4294967296..18446744073709551615  | uint 64          | 0xCF
		number_unsigned | 0..127                            | positive fixint  | 0x00..0x7F
		number_unsigned | 128..255                          | uint 8           | 0xCC
		number_unsigned | 256..65535                        | uint 16          | 0xCD
		number_unsigned | 65536..4294967295                 | uint 32          | 0xCE
		number_unsigned | 4294967296..18446744073709551615  | uint 64          | 0xCF
		number_float    | *any value*                       | float 64         | 0xCB
		string          | *length*: 0..31                   | fixstr           | 0xA0..0xBF
		string          | *length*: 32..255                 | str 8            | 0xD9
		string          | *length*: 256..65535              | str 16           | 0xDA
		string          | *length*: 65536..4294967295       | str 32           | 0xDB
		array           | *size*: 0..15                     | fixarray         | 0x90..0x9F
		array           | *size*: 16..65535                 | array 16         | 0xDC
		array           | *size*: 65536..4294967295         | array 32         | 0xDD
		object          | *size*: 0..15                     | fix map          | 0x80..0x8F
		object          | *size*: 16..65535                 | map 16           | 0xDE
		object          | *size*: 65536..4294967295         | map 32           | 0xDF

		@note The mapping is **complete** in the sense that any JSON value type
			  can be converted to a MessagePack value.

		@note The following values can **not** be converted to a MessagePack value:
			  - strings with more than 4294967295 bytes
			  - arrays with more than 4294967295 elements
			  - objects with more than 4294967295 elements

		@note The following MessagePack types are not used in the conversion:
			  - bin 8 - bin 32 (0xC4..0xC6)
			  - ext 8 - ext 32 (0xC7..0xC9)
			  - float 32 (0xCA)
			  - fixext 1 - fixext 16 (0xD4..0xD8)

		@note Any MessagePack output created @ref to_msgpack can be successfully
			  parsed by @ref from_msgpack.

		@note If NaN or Infinity are stored inside a JSON number, they are
			  serialized properly. This behavior differs from the @ref dump()
			  function which serializes NaN or Infinity to `null`.

		@param[in] j  JSON value to serialize
		@return MessagePack serialization as byte vector

		@complexity Linear in the size of the JSON value @a j.

		@liveexample{The example shows the serialization of a JSON value to a byte
		vector in MessagePack format.,to_msgpack}

		@sa http://msgpack.org
		@sa @ref from_msgpack(const std::vector<uint8_t>&, const size_t) for the
			analogous deserialization
		@sa @ref to_cbor(const basic_json& for the related CBOR format
		@sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
				 related UBJSON format

		@since version 2.0.9
		*/
		static std::vector<uint8_t> to_msgpack(const basic_json& j)
		{
			std::vector<uint8_t> result;
			to_msgpack(j, result);
			return result;
		}

		static void to_msgpack(const basic_json& j, detail::output_adapter<uint8_t> o)
		{
			binary_writer<uint8_t>(o).write_msgpack(j);
		}

		static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
		{
			binary_writer<char>(o).write_msgpack(j);
		}

		/*!
		@brief create a UBJSON serialization of a given JSON value

		Serializes a given JSON value @a j to a byte vector using the UBJSON
		(Universal Binary JSON) serialization format. UBJSON aims to be more compact
		than JSON itself, yet more efficient to parse.

		The library uses the following mapping from JSON values types to
		UBJSON types according to the UBJSON specification:

		JSON value type | value/range                       | UBJSON type | marker
		--------------- | --------------------------------- | ----------- | ------
		null            | `null`                            | null        | `Z`
		boolean         | `true`                            | true        | `T`
		boolean         | `false`                           | false       | `F`
		number_integer  | -9223372036854775808..-2147483649 | int64       | `L`
		number_integer  | -2147483648..-32769               | int32       | `l`
		number_integer  | -32768..-129                      | int16       | `I`
		number_integer  | -128..127                         | int8        | `i`
		number_integer  | 128..255                          | uint8       | `U`
		number_integer  | 256..32767                        | int16       | `I`
		number_integer  | 32768..2147483647                 | int32       | `l`
		number_integer  | 2147483648..9223372036854775807   | int64       | `L`
		number_unsigned | 0..127                            | int8        | `i`
		number_unsigned | 128..255                          | uint8       | `U`
		number_unsigned | 256..32767                        | int16       | `I`
		number_unsigned | 32768..2147483647                 | int32       | `l`
		number_unsigned | 2147483648..9223372036854775807   | int64       | `L`
		number_float    | *any value*                       | float64     | `D`
		string          | *with shortest length indicator*  | string      | `S`
		array           | *see notes on optimized format*   | array       | `[`
		object          | *see notes on optimized format*   | map         | `{`

		@note The mapping is **complete** in the sense that any JSON value type
			  can be converted to a UBJSON value.

		@note The following values can **not** be converted to a UBJSON value:
			  - strings with more than 9223372036854775807 bytes (theoretical)
			  - unsigned integer numbers above 9223372036854775807

		@note The following markers are not used in the conversion:
			  - `Z`: no-op values are not created.
			  - `C`: single-byte strings are serialized with `S` markers.

		@note Any UBJSON output created @ref to_ubjson can be successfully parsed
			  by @ref from_ubjson.

		@note If NaN or Infinity are stored inside a JSON number, they are
			  serialized properly. This behavior differs from the @ref dump()
			  function which serializes NaN or Infinity to `null`.

		@note The optimized formats for containers are supported: Parameter
			  @a use_size adds size information to the beginning of a container and
			  removes the closing marker. Parameter @a use_type further checks
			  whether all elements of a container have the same type and adds the
			  type marker to the beginning of the container. The @a use_type
			  parameter must only be used together with @a use_size = true. Note
			  that @a use_size = true alone may result in larger representations -
			  the benefit of this parameter is that the receiving side is
			  immediately informed on the number of elements of the container.

		@param[in] j  JSON value to serialize
		@param[in] use_size  whether to add size annotations to container types
		@param[in] use_type  whether to add type annotations to container types
							 (must be combined with @a use_size = true)
		@return UBJSON serialization as byte vector

		@complexity Linear in the size of the JSON value @a j.

		@liveexample{The example shows the serialization of a JSON value to a byte
		vector in UBJSON format.,to_ubjson}

		@sa http://ubjson.org
		@sa @ref from_ubjson(detail::input_adapter, const bool strict) for the
			analogous deserialization
		@sa @ref to_cbor(const basic_json& for the related CBOR format
		@sa @ref to_msgpack(const basic_json&) for the related MessagePack format

		@since version 3.1.0
		*/
		static std::vector<uint8_t> to_ubjson(const basic_json& j,
			const bool use_size = false,
			const bool use_type = false)
		{
			std::vector<uint8_t> result;
			to_ubjson(j, result, use_size, use_type);
			return result;
		}

		static void to_ubjson(const basic_json& j, detail::output_adapter<uint8_t> o,
			const bool use_size = false, const bool use_type = false)
		{
			binary_writer<uint8_t>(o).write_ubjson(j, use_size, use_type);
		}

		static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
			const bool use_size = false, const bool use_type = false)
		{
			binary_writer<char>(o).write_ubjson(j, use_size, use_type);
		}

		/*!
		@brief create a JSON value from an input in CBOR format

		Deserializes a given input @a i to a JSON value using the CBOR (Concise
		Binary Object Representation) serialization format.

		The library maps CBOR types to JSON value types as follows:

		CBOR type              | JSON value type | first byte
		---------------------- | --------------- | ----------
		Integer                | number_unsigned | 0x00..0x17
		Unsigned integer       | number_unsigned | 0x18
		Unsigned integer       | number_unsigned | 0x19
		Unsigned integer       | number_unsigned | 0x1A
		Unsigned integer       | number_unsigned | 0x1B
		Negative integer       | number_integer  | 0x20..0x37
		Negative integer       | number_integer  | 0x38
		Negative integer       | number_integer  | 0x39
		Negative integer       | number_integer  | 0x3A
		Negative integer       | number_integer  | 0x3B
		Negative integer       | number_integer  | 0x40..0x57
		UTF-8 string           | string          | 0x60..0x77
		UTF-8 string           | string          | 0x78
		UTF-8 string           | string          | 0x79
		UTF-8 string           | string          | 0x7A
		UTF-8 string           | string          | 0x7B
		UTF-8 string           | string          | 0x7F
		array                  | array           | 0x80..0x97
		array                  | array           | 0x98
		array                  | array           | 0x99
		array                  | array           | 0x9A
		array                  | array           | 0x9B
		array                  | array           | 0x9F
		map                    | object          | 0xA0..0xB7
		map                    | object          | 0xB8
		map                    | object          | 0xB9
		map                    | object          | 0xBA
		map                    | object          | 0xBB
		map                    | object          | 0xBF
		False                  | `false`         | 0xF4
		True                   | `true`          | 0xF5
		Nill                   | `null`          | 0xF6
		Half-Precision Float   | number_float    | 0xF9
		Single-Precision Float | number_float    | 0xFA
		Double-Precision Float | number_float    | 0xFB

		@warning The mapping is **incomplete** in the sense that not all CBOR
				 types can be converted to a JSON value. The following CBOR types
				 are not supported and will yield parse errors (parse_error.112):
				 - byte strings (0x40..0x5F)
				 - date/time (0xC0..0xC1)
				 - bignum (0xC2..0xC3)
				 - decimal fraction (0xC4)
				 - bigfloat (0xC5)
				 - tagged items (0xC6..0xD4, 0xD8..0xDB)
				 - expected conversions (0xD5..0xD7)
				 - simple values (0xE0..0xF3, 0xF8)
				 - undefined (0xF7)

		@warning CBOR allows map keys of any type, whereas JSON only allows
				 strings as keys in object values. Therefore, CBOR maps with keys
				 other than UTF-8 strings are rejected (parse_error.113).

		@note Any CBOR output created @ref to_cbor can be successfully parsed by
			  @ref from_cbor.

		@param[in] i  an input in CBOR format convertible to an input adapter
		@param[in] strict  whether to expect the input to be consumed until EOF
						   (true by default)
		@param[in] allow_exceptions  whether to throw exceptions in case of a
		parse error (optional, true by default)

		@return deserialized JSON value

		@throw parse_error.110 if the given input ends prematurely or the end of
		file was not reached when @a strict was set to true
		@throw parse_error.112 if unsupported features from CBOR were
		used in the given input @a v or if the input is not valid CBOR
		@throw parse_error.113 if a string was expected as map key, but not found

		@complexity Linear in the size of the input @a i.

		@liveexample{The example shows the deserialization of a byte vector in CBOR
		format to a JSON value.,from_cbor}

		@sa http://cbor.io
		@sa @ref to_cbor(const basic_json&) for the analogous serialization
		@sa @ref from_msgpack(detail::input_adapter, const bool, const bool) for the
			related MessagePack format
		@sa @ref from_ubjson(detail::input_adapter, const bool, const bool) for the
			related UBJSON format

		@since version 2.0.9; parameter @a start_index since 2.1.1; changed to
			   consume input adapters, removed start_index parameter, and added
			   @a strict parameter since 3.0.0; added @allow_exceptions parameter
			   since 3.2.0
		*/
		static basic_json from_cbor(detail::input_adapter&& i,
			const bool strict = true,
			const bool allow_exceptions = true)
		{
			basic_json result;
			detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
			const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::cbor, &sdp, strict);
			return res ? result : basic_json(value_t::discarded);
		}

		/*!
		@copydoc from_cbor(detail::input_adapter, const bool, const bool)
		*/
		template<typename A1, typename A2,
			detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
			static basic_json from_cbor(A1 && a1, A2 && a2,
				const bool strict = true,
				const bool allow_exceptions = true)
		{
			basic_json result;
			detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
			const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::cbor, &sdp, strict);
			return res ? result : basic_json(value_t::discarded);
		}

		/*!
		@brief create a JSON value from an input in MessagePack format

		Deserializes a given input @a i to a JSON value using the MessagePack
		serialization format.

		The library maps MessagePack types to JSON value types as follows:

		MessagePack type | JSON value type | first byte
		---------------- | --------------- | ----------
		positive fixint  | number_unsigned | 0x00..0x7F
		fixmap           | object          | 0x80..0x8F
		fixarray         | array           | 0x90..0x9F
		fixstr           | string          | 0xA0..0xBF
		nil              | `null`          | 0xC0
		false            | `false`         | 0xC2
		true             | `true`          | 0xC3
		float 32         | number_float    | 0xCA
		float 64         | number_float    | 0xCB
		uint 8           | number_unsigned | 0xCC
		uint 16          | number_unsigned | 0xCD
		uint 32          | number_unsigned | 0xCE
		uint 64          | number_unsigned | 0xCF
		int 8            | number_integer  | 0xD0
		int 16           | number_integer  | 0xD1
		int 32           | number_integer  | 0xD2
		int 64           | number_integer  | 0xD3
		str 8            | string          | 0xD9
		str 16           | string          | 0xDA
		str 32           | string          | 0xDB
		array 16         | array           | 0xDC
		array 32         | array           | 0xDD
		map 16           | object          | 0xDE
		map 32           | object          | 0xDF
		negative fixint  | number_integer  | 0xE0-0xFF

		@warning The mapping is **incomplete** in the sense that not all
				 MessagePack types can be converted to a JSON value. The following
				 MessagePack types are not supported and will yield parse errors:
				  - bin 8 - bin 32 (0xC4..0xC6)
				  - ext 8 - ext 32 (0xC7..0xC9)
				  - fixext 1 - fixext 16 (0xD4..0xD8)

		@note Any MessagePack output created @ref to_msgpack can be successfully
			  parsed by @ref from_msgpack.

		@param[in] i  an input in MessagePack format convertible to an input
					  adapter
		@param[in] strict  whether to expect the input to be consumed until EOF
						   (true by default)
		@param[in] allow_exceptions  whether to throw exceptions in case of a
		parse error (optional, true by default)

		@return deserialized JSON value

		@throw parse_error.110 if the given input ends prematurely or the end of
		file was not reached when @a strict was set to true
		@throw parse_error.112 if unsupported features from MessagePack were
		used in the given input @a i or if the input is not valid MessagePack
		@throw parse_error.113 if a string was expected as map key, but not found

		@complexity Linear in the size of the input @a i.

		@liveexample{The example shows the deserialization of a byte vector in
		MessagePack format to a JSON value.,from_msgpack}

		@sa http://msgpack.org
		@sa @ref to_msgpack(const basic_json&) for the analogous serialization
		@sa @ref from_cbor(detail::input_adapter, const bool, const bool) for the
			related CBOR format
		@sa @ref from_ubjson(detail::input_adapter, const bool, const bool) for
			the related UBJSON format

		@since version 2.0.9; parameter @a start_index since 2.1.1; changed to
			   consume input adapters, removed start_index parameter, and added
			   @a strict parameter since 3.0.0; added @allow_exceptions parameter
			   since 3.2.0
		*/
		static basic_json from_msgpack(detail::input_adapter&& i,
			const bool strict = true,
			const bool allow_exceptions = true)
		{
			basic_json result;
			detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
			const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::msgpack, &sdp, strict);
			return res ? result : basic_json(value_t::discarded);
		}

		/*!
		@copydoc from_msgpack(detail::input_adapter, const bool, const bool)
		*/
		template<typename A1, typename A2,
			detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
			static basic_json from_msgpack(A1 && a1, A2 && a2,
				const bool strict = true,
				const bool allow_exceptions = true)
		{
			basic_json result;
			detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
			const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::msgpack, &sdp, strict);
			return res ? result : basic_json(value_t::discarded);
		}

		/*!
		@brief create a JSON value from an input in UBJSON format

		Deserializes a given input @a i to a JSON value using the UBJSON (Universal
		Binary JSON) serialization format.

		The library maps UBJSON types to JSON value types as follows:

		UBJSON type | JSON value type                         | marker
		----------- | --------------------------------------- | ------
		no-op       | *no value, next value is read*          | `N`
		null        | `null`                                  | `Z`
		false       | `false`                                 | `F`
		true        | `true`                                  | `T`
		float32     | number_float                            | `d`
		float64     | number_float                            | `D`
		uint8       | number_unsigned                         | `U`
		int8        | number_integer                          | `i`
		int16       | number_integer                          | `I`
		int32       | number_integer                          | `l`
		int64       | number_integer                          | `L`
		string      | string                                  | `S`
		char        | string                                  | `C`
		array       | array (optimized values are supported)  | `[`
		object      | object (optimized values are supported) | `{`

		@note The mapping is **complete** in the sense that any UBJSON value can
			  be converted to a JSON value.

		@param[in] i  an input in UBJSON format convertible to an input adapter
		@param[in] strict  whether to expect the input to be consumed until EOF
						   (true by default)
		@param[in] allow_exceptions  whether to throw exceptions in case of a
		parse error (optional, true by default)

		@return deserialized JSON value

		@throw parse_error.110 if the given input ends prematurely or the end of
		file was not reached when @a strict was set to true
		@throw parse_error.112 if a parse error occurs
		@throw parse_error.113 if a string could not be parsed successfully

		@complexity Linear in the size of the input @a i.

		@liveexample{The example shows the deserialization of a byte vector in
		UBJSON format to a JSON value.,from_ubjson}

		@sa http://ubjson.org
		@sa @ref to_ubjson(const basic_json&, const bool, const bool) for the
				 analogous serialization
		@sa @ref from_cbor(detail::input_adapter, const bool, const bool) for the
			related CBOR format
		@sa @ref from_msgpack(detail::input_adapter, const bool, const bool) for
			the related MessagePack format

		@since version 3.1.0; added @allow_exceptions parameter since 3.2.0
		*/
		static basic_json from_ubjson(detail::input_adapter&& i,
			const bool strict = true,
			const bool allow_exceptions = true)
		{
			basic_json result;
			detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
			const bool res = binary_reader(detail::input_adapter(i)).sax_parse(input_format_t::ubjson, &sdp, strict);
			return res ? result : basic_json(value_t::discarded);
		}

		/*!
		@copydoc from_ubjson(detail::input_adapter, const bool, const bool)
		*/
		template<typename A1, typename A2,
			detail::enable_if_t<std::is_constructible<detail::input_adapter, A1, A2>::value, int> = 0>
			static basic_json from_ubjson(A1 && a1, A2 && a2,
				const bool strict = true,
				const bool allow_exceptions = true)
		{
			basic_json result;
			detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);
			const bool res = binary_reader(detail::input_adapter(std::forward<A1>(a1), std::forward<A2>(a2))).sax_parse(input_format_t::ubjson, &sdp, strict);
			return res ? result : basic_json(value_t::discarded);
		}

		/// @}

		//////////////////////////
		// JSON Pointer support //
		//////////////////////////

		/// @name JSON Pointer functions
		/// @{

		/*!
		@brief access specified element via JSON Pointer

		Uses a JSON pointer to retrieve a reference to the respective JSON value.
		No bound checking is performed. Similar to @ref operator[](const typename
		object_t::key_type&), `null` values are created in arrays and objects if
		necessary.

		In particular:
		- If the JSON pointer points to an object key that does not exist, it
		  is created an filled with a `null` value before a reference to it
		  is returned.
		- If the JSON pointer points to an array index that does not exist, it
		  is created an filled with a `null` value before a reference to it
		  is returned. All indices between the current maximum and the given
		  index are also filled with `null`.
		- The special value `-` is treated as a synonym for the index past the
		  end.

		@param[in] ptr  a JSON pointer

		@return reference to the element pointed to by @a ptr

		@complexity Constant.

		@throw parse_error.106   if an array index begins with '0'
		@throw parse_error.109   if an array index was not a number
		@throw out_of_range.404  if the JSON pointer can not be resolved

		@liveexample{The behavior is shown in the example.,operatorjson_pointer}

		@since version 2.0.0
		*/
		reference operator[](const json_pointer& ptr)
		{
			return ptr.get_unchecked(this);
		}

		/*!
		@brief access specified element via JSON Pointer

		Uses a JSON pointer to retrieve a reference to the respective JSON value.
		No bound checking is performed. The function does not change the JSON
		value; no `null` values are created. In particular, the the special value
		`-` yields an exception.

		@param[in] ptr  JSON pointer to the desired element

		@return const reference to the element pointed to by @a ptr

		@complexity Constant.

		@throw parse_error.106   if an array index begins with '0'
		@throw parse_error.109   if an array index was not a number
		@throw out_of_range.402  if the array index '-' is used
		@throw out_of_range.404  if the JSON pointer can not be resolved

		@liveexample{The behavior is shown in the example.,operatorjson_pointer_const}

		@since version 2.0.0
		*/
		const_reference operator[](const json_pointer& ptr) const
		{
			return ptr.get_unchecked(this);
		}

		/*!
		@brief access specified element via JSON Pointer

		Returns a reference to the element at with specified JSON pointer @a ptr,
		with bounds checking.

		@param[in] ptr  JSON pointer to the desired element

		@return reference to the element pointed to by @a ptr

		@throw parse_error.106 if an array index in the passed JSON pointer @a ptr
		begins with '0'. See example below.

		@throw parse_error.109 if an array index in the passed JSON pointer @a ptr
		is not a number. See example below.

		@throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
		is out of range. See example below.

		@throw out_of_range.402 if the array index '-' is used in the passed JSON
		pointer @a ptr. As `at` provides checked access (and no elements are
		implicitly inserted), the index '-' is always invalid. See example below.

		@throw out_of_range.403 if the JSON pointer describes a key of an object
		which cannot be found. See example below.

		@throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
		See example below.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Constant.

		@since version 2.0.0

		@liveexample{The behavior is shown in the example.,at_json_pointer}
		*/
		reference at(const json_pointer& ptr)
		{
			return ptr.get_checked(this);
		}

		/*!
		@brief access specified element via JSON Pointer

		Returns a const reference to the element at with specified JSON pointer @a
		ptr, with bounds checking.

		@param[in] ptr  JSON pointer to the desired element

		@return reference to the element pointed to by @a ptr

		@throw parse_error.106 if an array index in the passed JSON pointer @a ptr
		begins with '0'. See example below.

		@throw parse_error.109 if an array index in the passed JSON pointer @a ptr
		is not a number. See example below.

		@throw out_of_range.401 if an array index in the passed JSON pointer @a ptr
		is out of range. See example below.

		@throw out_of_range.402 if the array index '-' is used in the passed JSON
		pointer @a ptr. As `at` provides checked access (and no elements are
		implicitly inserted), the index '-' is always invalid. See example below.

		@throw out_of_range.403 if the JSON pointer describes a key of an object
		which cannot be found. See example below.

		@throw out_of_range.404 if the JSON pointer @a ptr can not be resolved.
		See example below.

		@exceptionsafety Strong guarantee: if an exception is thrown, there are no
		changes in the JSON value.

		@complexity Constant.

		@since version 2.0.0

		@liveexample{The behavior is shown in the example.,at_json_pointer_const}
		*/
		const_reference at(const json_pointer& ptr) const
		{
			return ptr.get_checked(this);
		}

		/*!
		@brief return flattened JSON value

		The function creates a JSON object whose keys are JSON pointers (see [RFC
		6901](https://tools.ietf.org/html/rfc6901)) and whose values are all
		primitive. The original JSON value can be restored using the @ref
		unflatten() function.

		@return an object that maps JSON pointers to primitive values

		@note Empty objects and arrays are flattened to `null` and will not be
			  reconstructed correctly by the @ref unflatten() function.

		@complexity Linear in the size the JSON value.

		@liveexample{The following code shows how a JSON object is flattened to an
		object whose keys consist of JSON pointers.,flatten}

		@sa @ref unflatten() for the reverse function

		@since version 2.0.0
		*/
		basic_json flatten() const
		{
			basic_json result(value_t::object);
			json_pointer::flatten("", *this, result);
			return result;
		}

		/*!
		@brief unflatten a previously flattened JSON value

		The function restores the arbitrary nesting of a JSON value that has been
		flattened before using the @ref flatten() function. The JSON value must
		meet certain constraints:
		1. The value must be an object.
		2. The keys must be JSON pointers (see
		   [RFC 6901](https://tools.ietf.org/html/rfc6901))
		3. The mapped values must be primitive JSON types.

		@return the original JSON from a flattened version

		@note Empty objects and arrays are flattened by @ref flatten() to `null`
			  values and can not unflattened to their original type. Apart from
			  this example, for a JSON value `j`, the following is always true:
			  `j == j.flatten().unflatten()`.

		@complexity Linear in the size the JSON value.

		@throw type_error.314  if value is not an object
		@throw type_error.315  if object values are not primitive

		@liveexample{The following code shows how a flattened JSON object is
		unflattened into the original nested JSON object.,unflatten}

		@sa @ref flatten() for the reverse function

		@since version 2.0.0
		*/
		basic_json unflatten() const
		{
			return json_pointer::unflatten(*this);
		}

		/// @}

		//////////////////////////
		// JSON Patch functions //
		//////////////////////////

		/// @name JSON Patch functions
		/// @{

		/*!
		@brief applies a JSON patch

		[JSON Patch](http://jsonpatch.com) defines a JSON document structure for
		expressing a sequence of operations to apply to a JSON) document. With
		this function, a JSON Patch is applied to the current JSON value by
		executing all operations from the patch.

		@param[in] json_patch  JSON patch document
		@return patched document

		@note The application of a patch is atomic: Either all operations succeed
			  and the patched document is returned or an exception is thrown. In
			  any case, the original value is not changed: the patch is applied
			  to a copy of the value.

		@throw parse_error.104 if the JSON patch does not consist of an array of
		objects

		@throw parse_error.105 if the JSON patch is malformed (e.g., mandatory
		attributes are missing); example: `"operation add must have member path"`

		@throw out_of_range.401 if an array index is out of range.

		@throw out_of_range.403 if a JSON pointer inside the patch could not be
		resolved successfully in the current JSON value; example: `"key baz not
		found"`

		@throw out_of_range.405 if JSON pointer has no parent ("add", "remove",
		"move")

		@throw other_error.501 if "test" operation was unsuccessful

		@complexity Linear in the size of the JSON value and the length of the
		JSON patch. As usually only a fraction of the JSON value is affected by
		the patch, the complexity can usually be neglected.

		@liveexample{The following code shows how a JSON patch is applied to a
		value.,patch}

		@sa @ref diff -- create a JSON patch by comparing two JSON values

		@sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)
		@sa [RFC 6901 (JSON Pointer)](https://tools.ietf.org/html/rfc6901)

		@since version 2.0.0
		*/
		basic_json patch(const basic_json& json_patch) const
		{
			// make a working copy to apply the patch to
			basic_json result = *this;

			// the valid JSON Patch operations
			enum class patch_operations { add, remove, replace, move, copy, test, invalid };

			const auto get_op = [](const std::string & op)
			{
				if (op == "add")
				{
					return patch_operations::add;
				}
				if (op == "remove")
				{
					return patch_operations::remove;
				}
				if (op == "replace")
				{
					return patch_operations::replace;
				}
				if (op == "move")
				{
					return patch_operations::move;
				}
				if (op == "copy")
				{
					return patch_operations::copy;
				}
				if (op == "test")
				{
					return patch_operations::test;
				}

				return patch_operations::invalid;
			};

			// wrapper for "add" operation; add value at ptr
			const auto operation_add = [&result](json_pointer & ptr, basic_json val)
			{
				// adding to the root of the target document means replacing it
				if (ptr.is_root())
				{
					result = val;
				}
				else
				{
					// make sure the top element of the pointer exists
					json_pointer top_pointer = ptr.top();
					if (top_pointer != ptr)
					{
						result.at(top_pointer);
					}

					// get reference to parent of JSON pointer ptr
					const auto last_path = ptr.pop_back();
					basic_json& parent = result[ptr];

					switch (parent.m_type)
					{
					case value_t::null:
					case value_t::object:
					{
						// use operator[] to add value
						parent[last_path] = val;
						break;
					}

					case value_t::array:
					{
						if (last_path == "-")
						{
							// special case: append to back
							parent.push_back(val);
						}
						else
						{
							const auto idx = json_pointer::array_index(last_path);
							if (JSON_UNLIKELY(static_cast<size_type>(idx) > parent.size()))
							{
								// avoid undefined behavior
								JSON_THROW(out_of_range::create(401, "array index " + std::to_string(idx) + " is out of range"));
							}
							else
							{
								// default case: insert add offset
								parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
							}
						}
						break;
					}

					// LCOV_EXCL_START
					default:
					{
						// if there exists a parent it cannot be primitive
						assert(false);
					}
					// LCOV_EXCL_STOP
					}
				}
			};

			// wrapper for "remove" operation; remove value at ptr
			const auto operation_remove = [&result](json_pointer & ptr)
			{
				// get reference to parent of JSON pointer ptr
				const auto last_path = ptr.pop_back();
				basic_json& parent = result.at(ptr);

				// remove child
				if (parent.is_object())
				{
					// perform range check
					auto it = parent.find(last_path);
					if (JSON_LIKELY(it != parent.end()))
					{
						parent.erase(it);
					}
					else
					{
						JSON_THROW(out_of_range::create(403, "key '" + last_path + "' not found"));
					}
				}
				else if (parent.is_array())
				{
					// note erase performs range check
					parent.erase(static_cast<size_type>(json_pointer::array_index(last_path)));
				}
			};

			// type check: top level value must be an array
			if (JSON_UNLIKELY(not json_patch.is_array()))
			{
				JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
			}

			// iterate and apply the operations
			for (const auto& val : json_patch)
			{
				// wrapper to get a value for an operation
				const auto get_value = [&val](const std::string & op,
					const std::string & member,
					bool string_type) -> basic_json &
				{
					// find value
					auto it = val.m_value.object->find(member);

					// context-sensitive error message
					const auto error_msg = (op == "op") ? "operation" : "operation '" + op + "'";

					// check if desired value is present
					if (JSON_UNLIKELY(it == val.m_value.object->end()))
					{
						JSON_THROW(parse_error::create(105, 0, error_msg + " must have member '" + member + "'"));
					}

					// check if result is of type string
					if (JSON_UNLIKELY(string_type and not it->second.is_string()))
					{
						JSON_THROW(parse_error::create(105, 0, error_msg + " must have string member '" + member + "'"));
					}

					// no error: return value
					return it->second;
				};

				// type check: every element of the array must be an object
				if (JSON_UNLIKELY(not val.is_object()))
				{
					JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects"));
				}

				// collect mandatory members
				const std::string op = get_value("op", "op", true);
				const std::string path = get_value(op, "path", true);
				json_pointer ptr(path);

				switch (get_op(op))
				{
				case patch_operations::add:
				{
					operation_add(ptr, get_value("add", "value", false));
					break;
				}

				case patch_operations::remove:
				{
					operation_remove(ptr);
					break;
				}

				case patch_operations::replace:
				{
					// the "path" location must exist - use at()
					result.at(ptr) = get_value("replace", "value", false);
					break;
				}

				case patch_operations::move:
				{
					const std::string from_path = get_value("move", "from", true);
					json_pointer from_ptr(from_path);

					// the "from" location must exist - use at()
					basic_json v = result.at(from_ptr);

					// The move operation is functionally identical to a
					// "remove" operation on the "from" location, followed
					// immediately by an "add" operation at the target
					// location with the value that was just removed.
					operation_remove(from_ptr);
					operation_add(ptr, v);
					break;
				}

				case patch_operations::copy:
				{
					const std::string from_path = get_value("copy", "from", true);
					const json_pointer from_ptr(from_path);

					// the "from" location must exist - use at()
					basic_json v = result.at(from_ptr);

					// The copy is functionally identical to an "add"
					// operation at the target location using the value
					// specified in the "from" member.
					operation_add(ptr, v);
					break;
				}

				case patch_operations::test:
				{
					bool success = false;
					JSON_TRY
					{
						// check if "value" matches the one at "path"
						// the "path" location must exist - use at()
						success = (result.at(ptr) == get_value("test", "value", false));
					}
						JSON_INTERNAL_CATCH(out_of_range&)
					{
						// ignore out of range errors: success remains false
					}

					// throw an exception if test fails
					if (JSON_UNLIKELY(not success))
					{
						JSON_THROW(other_error::create(501, "unsuccessful: " + val.dump()));
					}

					break;
				}

				case patch_operations::invalid:
				{
					// op must be "add", "remove", "replace", "move", "copy", or
					// "test"
					JSON_THROW(parse_error::create(105, 0, "operation value '" + op + "' is invalid"));
				}
				}
			}

			return result;
		}

		/*!
		@brief creates a diff as a JSON patch

		Creates a [JSON Patch](http://jsonpatch.com) so that value @a source can
		be changed into the value @a target by calling @ref patch function.

		@invariant For two JSON values @a source and @a target, the following code
		yields always `true`:
		@code {.cpp}
		source.patch(diff(source, target)) == target;
		@endcode

		@note Currently, only `remove`, `add`, and `replace` operations are
			  generated.

		@param[in] source  JSON value to compare from
		@param[in] target  JSON value to compare against
		@param[in] path    helper value to create JSON pointers

		@return a JSON patch to convert the @a source to @a target

		@complexity Linear in the lengths of @a source and @a target.

		@liveexample{The following code shows how a JSON patch is created as a
		diff for two JSON values.,diff}

		@sa @ref patch -- apply a JSON patch
		@sa @ref merge_patch -- apply a JSON Merge Patch

		@sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)

		@since version 2.0.0
		*/
		static basic_json diff(const basic_json& source, const basic_json& target,
			const std::string& path = "")
		{
			// the patch
			basic_json result(value_t::array);

			// if the values are the same, return empty patch
			if (source == target)
			{
				return result;
			}

			if (source.type() != target.type())
			{
				// different types: replace value
				result.push_back(
					{
						{"op", "replace"}, {"path", path}, {"value", target}
					});
			}
			else
			{
				switch (source.type())
				{
				case value_t::array:
				{
					// first pass: traverse common elements
					std::size_t i = 0;
					while (i < source.size() and i < target.size())
					{
						// recursive call to compare array values at index i
						auto temp_diff = diff(source[i], target[i], path + "/" + std::to_string(i));
						result.insert(result.end(), temp_diff.begin(), temp_diff.end());
						++i;
					}

					// i now reached the end of at least one array
					// in a second pass, traverse the remaining elements

					// remove my remaining elements
					const auto end_index = static_cast<difference_type>(result.size());
					while (i < source.size())
					{
						// add operations in reverse order to avoid invalid
						// indices
						result.insert(result.begin() + end_index, object(
							{
								{"op", "remove"},
								{"path", path + "/" + std::to_string(i)}
							}));
						++i;
					}

					// add other remaining elements
					while (i < target.size())
					{
						result.push_back(
							{
								{"op", "add"},
								{"path", path + "/" + std::to_string(i)},
								{"value", target[i]}
							});
						++i;
					}

					break;
				}

				case value_t::object:
				{
					// first pass: traverse this object's elements
					for (auto it = source.cbegin(); it != source.cend(); ++it)
					{
						// escape the key name to be used in a JSON patch
						const auto key = json_pointer::escape(it.key());

						if (target.find(it.key()) != target.end())
						{
							// recursive call to compare object values at key it
							auto temp_diff = diff(it.value(), target[it.key()], path + "/" + key);
							result.insert(result.end(), temp_diff.begin(), temp_diff.end());
						}
						else
						{
							// found a key that is not in o -> remove it
							result.push_back(object(
								{
									{"op", "remove"}, {"path", path + "/" + key}
								}));
						}
					}

					// second pass: traverse other object's elements
					for (auto it = target.cbegin(); it != target.cend(); ++it)
					{
						if (source.find(it.key()) == source.end())
						{
							// found a key that is not in this -> add it
							const auto key = json_pointer::escape(it.key());
							result.push_back(
								{
									{"op", "add"}, {"path", path + "/" + key},
									{"value", it.value()}
								});
						}
					}

					break;
				}

				default:
				{
					// both primitive type: replace value
					result.push_back(
						{
							{"op", "replace"}, {"path", path}, {"value", target}
						});
					break;
				}
				}
			}

			return result;
		}

		/// @}

		////////////////////////////////
		// JSON Merge Patch functions //
		////////////////////////////////

		/// @name JSON Merge Patch functions
		/// @{

		/*!
		@brief applies a JSON Merge Patch

		The merge patch format is primarily intended for use with the HTTP PATCH
		method as a means of describing a set of modifications to a target
		resource's content. This function applies a merge patch to the current
		JSON value.

		The function implements the following algorithm from Section 2 of
		[RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396):

		```
		define MergePatch(Target, Patch):
		  if Patch is an Object:
			if Target is not an Object:
			  Target = {} // Ignore the contents and set it to an empty Object
			for each Name/Value pair in Patch:
			  if Value is null:
				if Name exists in Target:
				  remove the Name/Value pair from Target
			  else:
				Target[Name] = MergePatch(Target[Name], Value)
			return Target
		  else:
			return Patch
		```

		Thereby, `Target` is the current object; that is, the patch is applied to
		the current value.

		@param[in] patch  the patch to apply

		@complexity Linear in the lengths of @a patch.

		@liveexample{The following code shows how a JSON Merge Patch is applied to
		a JSON document.,merge_patch}

		@sa @ref patch -- apply a JSON patch
		@sa [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396)

		@since version 3.0.0
		*/
		void merge_patch(const basic_json& patch)
		{
			if (patch.is_object())
			{
				if (not is_object())
				{
					*this = object();
				}
				for (auto it = patch.begin(); it != patch.end(); ++it)
				{
					if (it.value().is_null())
					{
						erase(it.key());
					}
					else
					{
						operator[](it.key()).merge_patch(it.value());
					}
				}
			}
			else
			{
				*this = patch;
			}
		}

		/// @}
	};
} // namespace nlohmann

///////////////////////
// nonmember support //
///////////////////////

// specialization of std::swap, and std::hash
namespace std
{

	/// hash value for JSON objects
	template<>
	struct hash<nlohmann::json>
	{
		/*!
		@brief return a hash value for a JSON object

		@since version 1.0.0
		*/
		std::size_t operator()(const nlohmann::json& j) const
		{
			// a naive hashing via the string representation
			const auto& h = hash<nlohmann::json::string_t>();
			return h(j.dump());
		}
	};

	/// specialization for std::less<value_t>
	/// @note: do not remove the space after '<',
	///        see https://github.com/nlohmann/json/pull/679
	template<>
	struct less< ::nlohmann::detail::value_t>
	{
		/*!
		@brief compare two value_t enum values
		@since version 3.0.0
		*/
		bool operator()(nlohmann::detail::value_t lhs,
			nlohmann::detail::value_t rhs) const noexcept
		{
			return nlohmann::detail::operator<(lhs, rhs);
		}
	};

	/*!
	@brief exchanges the values of two JSON objects

	@since version 1.0.0
	*/
	template<>
	inline void swap<nlohmann::json>(nlohmann::json& j1, nlohmann::json& j2) noexcept(
		is_nothrow_move_constructible<nlohmann::json>::value and
		is_nothrow_move_assignable<nlohmann::json>::value
		)
	{
		j1.swap(j2);
	}

} // namespace std

/*!
@brief user-defined string literal for JSON values

This operator implements a user-defined string literal for JSON objects. It
can be used by adding `"_json"` to a string literal and returns a JSON object
if no parse error occurred.

@param[in] s  a string representation of a JSON object
@param[in] n  the length of string @a s
@return a JSON object

@since version 1.0.0
*/
inline nlohmann::json operator "" _json(const char* s, std::size_t n)
{
	return nlohmann::json::parse(s, s + n);
}

/*!
@brief user-defined string literal for JSON pointer

This operator implements a user-defined string literal for JSON Pointers. It
can be used by adding `"_json_pointer"` to a string literal and returns a JSON pointer
object if no parse error occurred.

@param[in] s  a string representation of a JSON Pointer
@param[in] n  the length of string @a s
@return a JSON pointer object

@since version 2.0.0
*/
inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
{
	return nlohmann::json::json_pointer(std::string(s, n));
}

// #include <nlohmann/detail/macro_unscope.hpp>


// restore GCC/clang diagnostic settings
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic pop
#endif
#if defined(__clang__)
#pragma GCC diagnostic pop
#endif

// clean up
#undef JSON_INTERNAL_CATCH
#undef JSON_CATCH
#undef JSON_THROW
#undef JSON_TRY
#undef JSON_LIKELY
#undef JSON_UNLIKELY
#undef JSON_DEPRECATED
#undef JSON_HAS_CPP_14
#undef JSON_HAS_CPP_17
#undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
#undef NLOHMANN_BASIC_JSON_TPL


#endif#pragma once

```

`CSGO SDK/Libraries/minhook-master/README.md`:

```md
# MinHook

[![License](https://img.shields.io/badge/License-BSD%202--Clause-orange.svg)](https://opensource.org/licenses/BSD-2-Clause)

The Minimalistic x86/x64 API Hooking Library for Windows

http://www.codeproject.com/KB/winsdk/LibMinHook.aspx

### Donation please

I need some funds to continue developing this library. All contributions gratefully accepted.

<a href='https://pledgie.com/campaigns/27314'><img alt='Click here to lend your support to: MinHook - Help me continue to develop this library and make a donation at pledgie.com !' src='https://pledgie.com/campaigns/27314.png?skin_name=chrome' border='0' ></a>

### Version history

- **v1.3.3 - 8 Jan 2017**
  * Added a helper function ```MH_CreateHookApiEx```. (Thanks to asm256)
  * Support Visual Studio 2017 RC.

- **v1.3.2.1 - 9 Nov 2015**  (Nuget package only)
  * Fixed an insufficient support for Visual Studio 2015.

- **v1.3.2 - 1 Nov 2015**
  * Support Visual Studio 2015.
  * Support MinGW.

- **v1.3.2-beta3 - 21 Jul 2015**  (Nuget package only)
  * Support MinGW. (Experimental)

- **v1.3.2-beta2 - 18 May 2015**
  * Fixed some subtle bugs. (Thanks to RaMMicHaeL)
  * Added a helper function ```MH_StatusToString```. (Thanks to Jan Klass)

- **v1.3.2-beta - 12 May 2015**
  * Fixed a possible thread deadlock in x64 mode. (Thanks to Aleh Kazakevich)
  * Reduced the footprint a little more.
  * Support Visual Studio 2015 RC. (Experimental)

- **v1.3.1.1 - 7 Apr 2015**  (Nuget package only)
  * Support for WDK8.0 and 8.1.

- **v1.3.1 - 19 Mar 2015**
  * No major changes from v1.3.1-beta.

- **v1.3.1-beta - 11 Mar 2015**
  * Added a helper function ```MH_CreateHookApi```. (Thanks to uniskz).
  * Fixed a false memory leak reported by some tools.
  * Fixed a degradated compatibility issue. 

- **v1.3 - 13 Sep 2014**
  * No major changes from v1.3-beta3.

- **v1.3-beta3 - 31 Jul 2014**

  * Fixed some small bugs.
  * Improved the memory management.

- **v1.3-beta2 - 21 Jul 2014**

  * Changed the parameters to Windows-friendly types. (void* to LPVOID)
  * Fixed some small bugs.
  * Reorganized the source files.
  * Reduced the footprint a little more.

- **v1.3-beta - 17 Jul 2014**

  * Rewrote in plain C to reduce the footprint and memory usage. (suggested by Andrey Unis)
  * Simplified the overall code base to make it more readable and maintainable.
  * Changed the license from 3-clause to 2-clause BSD License.

- **v1.2 - 28 Sep 2013**
 
  * Removed boost dependency ([jarredholman](https://github.com/jarredholman/minhook)).
  * Fixed a small bug in the GetRelativeBranchDestination function ([pillbug99](http://www.codeproject.com/Messages/4058892/Small-Bug-Found.aspx)).
  * Added the ```MH_RemoveHook``` function, which removes a hook created with the ```MH_CreateHook``` function.
  * Added the following functions to enable or disable multiple hooks in one go: ```MH_QueueEnableHook```, ```MH_QueueDisableHook```, ```MH_ApplyQueued```. This is the preferred way of handling multiple hooks as every call to `MH_EnableHook` or `MH_DisableHook` suspends and resumes all threads.
  * Made the functions ```MH_EnableHook``` and ```MH_DisableHook``` enable/disable all created hooks when the ```MH_ALL_HOOKS``` parameter is passed. This, too, is an efficient way of handling multiple hooks.
  * If the target function is too small to be patched with a jump, MinHook tries to place the jump above the function. If that fails as well, the ```MH_CreateHook``` function returns ```MH_ERROR_UNSUPPORTED_FUNCTION```. This fixes an issue of hooking the LoadLibraryExW function on Windows 7 x64 ([reported by Obble](http://www.codeproject.com/Messages/4578613/Re-Bug-LoadLibraryExW-hook-fails-on-windows-2008-r.aspx)).

- **v1.1 - 26 Nov 2009**

  * Changed the interface to create a hook and a trampoline function in one go to prevent the detour function from being called before the trampoline function is created. ([reported by xliqz](http://www.codeproject.com/Messages/3280374/Unsafe.aspx))
  * Shortened the function names from ```MinHook_*``` to ```MH_*``` to make them handier.

- **v1.0 - 22 Nov 2009**
 
  * Initial release.

```

`CSGO SDK/Libraries/minhook-master/build/MinGW/Makefile`:

```
WINDRES:=$(CROSS_PREFIX)windres
DLLTOOL:=$(CROSS_PREFIX)dlltool
AR:=$(CROSS_PREFIX)ar
CC:=$(CROSS_PREFIX)gcc
CCLD:=$(CC)
SRCS:=$(wildcard src/*.c src/hde/*.c)
OBJS:=$(SRCS:%.c=%.o)
DEPS:=$(SRCS:%.c=%.d)
INCS:=-Isrc -Iinclude
CFLAGS:=-masm=intel -Wall -Werror -std=c11
LDFLAGS:=-Wl,-enable-stdcall-fixup -s -static-libgcc

all: MinHook.dll libMinHook.dll.a libMinHook.a

-include $(DEPS)

libMinHook.a: $(OBJS)
	$(AR) r $@ $^
libMinHook.dll.a: MinHook.dll dll_resources/MinHook.def
	$(DLLTOOL) --dllname MinHook.dll --def dll_resources/MinHook.def --output-lib $@
MinHook.dll: $(OBJS) dll_resources/MinHook.res dll_resources/MinHook.def
	$(CCLD) -o $@ -shared $(LDFLAGS) $^

.rc.res:
	$(WINDRES) -o $@ --input-format=rc --output-format=coff $<
.c.o:
	$(CC) -o $@ -c -MMD -MP $(INCS) $(CFLAGS) $<

clean:
	rm -f $(OBJS) $(DEPS) MinHook.dll libMinHook.dll.a libMinHook.a dll_resources/MinHook.res

.PHONY: clean
.SUFFIXES: .rc .res

```

`CSGO SDK/Libraries/minhook-master/build/MinGW/make.bat`:

```bat
windres -i ../../dll_resources/MinHook.rc -o MinHook_rc.o && dllwrap --driver-name g++ -o MinHook.dll -masm=intel --def ../../dll_resources/MinHook.def -Wl,-enable-stdcall-fixup -Wall MinHook_rc.o ../../src/*.c ../../src/HDE/*.c -I../../include -I../../src -Werror -std=c++11 -s -static-libgcc -static-libstdc++|| pause
```

`CSGO SDK/Libraries/minhook-master/build/VC10/MinHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{027FAC75-3FDB-4044-8DD0-BC297BD4C461}</ProjectGuid>
    <RootNamespace>MinHook</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName).x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName).x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>
      </DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>
      </DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>
      </DebugInformationFormat>
      <MinimalRebuild>false</MinimalRebuild>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <NoEntryPoint>true</NoEntryPoint>
      <MergeSections>.CRT=.text</MergeSections>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>
      </DebugInformationFormat>
      <MinimalRebuild>false</MinimalRebuild>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <NoEntryPoint>true</NoEntryPoint>
      <MergeSections>.CRT=.text</MergeSections>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="..\..\dll_resources\MinHook.def" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\..\dll_resources\MinHook.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC10/MinHookVC10.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libMinHook", "libMinHook.vcxproj", "{F142A341-5EE0-442D-A15F-98AE9B48DBAE}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MinHook", "MinHook.vcxproj", "{027FAC75-3FDB-4044-8DD0-BC297BD4C461}"
	ProjectSection(ProjectDependencies) = postProject
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE} = {F142A341-5EE0-442D-A15F-98AE9B48DBAE}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|Win32.ActiveCfg = Debug|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|Win32.Build.0 = Debug|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|x64.ActiveCfg = Debug|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|x64.Build.0 = Debug|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|Win32.ActiveCfg = Release|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|Win32.Build.0 = Release|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|x64.ActiveCfg = Release|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|x64.Build.0 = Release|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|Win32.ActiveCfg = Debug|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|Win32.Build.0 = Debug|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|x64.ActiveCfg = Debug|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|x64.Build.0 = Debug|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|Win32.ActiveCfg = Release|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|Win32.Build.0 = Release|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|x64.ActiveCfg = Release|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`CSGO SDK/Libraries/minhook-master/build/VC10/libMinHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F142A341-5EE0-442D-A15F-98AE9B48DBAE}</ProjectGuid>
    <RootNamespace>libMinHook</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName).x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName).x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>
      </DebugInformationFormat>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>
      </DebugInformationFormat>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>
      </DebugInformationFormat>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>
      </DebugInformationFormat>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\src\buffer.c" />
    <ClCompile Include="..\..\src\HDE\hde32.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde64.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\..\src\hook.c" />
    <ClCompile Include="..\..\src\trampoline.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\include\MinHook.h" />
    <ClInclude Include="..\..\src\buffer.h" />
    <ClInclude Include="..\..\src\HDE\hde32.h" />
    <ClInclude Include="..\..\src\HDE\hde64.h" />
    <ClInclude Include="..\..\src\HDE\pstdint.h" />
    <ClInclude Include="..\..\src\HDE\table32.h" />
    <ClInclude Include="..\..\src\HDE\table64.h" />
    <ClInclude Include="..\..\src\trampoline.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC10/libMinHook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="..\..\src\buffer.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\hook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\trampoline.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde32.c">
      <Filter>HDE</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde64.c">
      <Filter>HDE</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\src\trampoline.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\buffer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\MinHook.h" />
    <ClInclude Include="..\..\src\HDE\hde32.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\hde64.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\pstdint.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\table32.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\table64.h">
      <Filter>HDE</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{9d24b740-be2e-4cfd-b9a4-340a50946ee9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{76381bc7-2863-4cc5-aede-926ec2c506e4}</UniqueIdentifier>
    </Filter>
    <Filter Include="HDE">
      <UniqueIdentifier>{56ddb326-6179-430d-ae19-e13bfd767bfa}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC11/MinHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{027FAC75-3FDB-4044-8DD0-BC297BD4C461}</ProjectGuid>
    <RootNamespace>MinHook</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v110_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v110_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v110_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v110_xp</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName).x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName).x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MinimalRebuild>false</MinimalRebuild>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <NoEntryPoint>true</NoEntryPoint>
      <MergeSections>.CRT=.text</MergeSections>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MinimalRebuild>false</MinimalRebuild>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <NoEntryPoint>true</NoEntryPoint>
      <MergeSections>.CRT=.text</MergeSections>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="..\..\dll_resources\MinHook.def" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\..\dll_resources\MinHook.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC11/MinHookVC11.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libMinHook", "libMinHook.vcxproj", "{F142A341-5EE0-442D-A15F-98AE9B48DBAE}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MinHook", "MinHook.vcxproj", "{027FAC75-3FDB-4044-8DD0-BC297BD4C461}"
	ProjectSection(ProjectDependencies) = postProject
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE} = {F142A341-5EE0-442D-A15F-98AE9B48DBAE}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|Win32.ActiveCfg = Debug|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|Win32.Build.0 = Debug|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|x64.ActiveCfg = Debug|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|x64.Build.0 = Debug|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|Win32.ActiveCfg = Release|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|Win32.Build.0 = Release|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|x64.ActiveCfg = Release|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|x64.Build.0 = Release|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|Win32.ActiveCfg = Debug|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|Win32.Build.0 = Debug|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|x64.ActiveCfg = Debug|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|x64.Build.0 = Debug|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|Win32.ActiveCfg = Release|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|Win32.Build.0 = Release|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|x64.ActiveCfg = Release|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`CSGO SDK/Libraries/minhook-master/build/VC11/libMinHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F142A341-5EE0-442D-A15F-98AE9B48DBAE}</ProjectGuid>
    <RootNamespace>libMinHook</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v110_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v110_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v110_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v110_xp</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName).x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName).x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\src\buffer.c" />
    <ClCompile Include="..\..\src\HDE\hde32.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde64.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\..\src\hook.c" />
    <ClCompile Include="..\..\src\trampoline.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\include\MinHook.h" />
    <ClInclude Include="..\..\src\buffer.h" />
    <ClInclude Include="..\..\src\HDE\hde32.h" />
    <ClInclude Include="..\..\src\HDE\hde64.h" />
    <ClInclude Include="..\..\src\HDE\pstdint.h" />
    <ClInclude Include="..\..\src\HDE\table32.h" />
    <ClInclude Include="..\..\src\HDE\table64.h" />
    <ClInclude Include="..\..\src\trampoline.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC11/libMinHook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="..\..\src\buffer.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\hook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\trampoline.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde32.c">
      <Filter>HDE</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde64.c">
      <Filter>HDE</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\src\trampoline.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\buffer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\MinHook.h" />
    <ClInclude Include="..\..\src\HDE\hde32.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\hde64.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\pstdint.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\table32.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\table64.h">
      <Filter>HDE</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{9d24b740-be2e-4cfd-b9a4-340a50946ee9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{76381bc7-2863-4cc5-aede-926ec2c506e4}</UniqueIdentifier>
    </Filter>
    <Filter Include="HDE">
      <UniqueIdentifier>{56ddb326-6179-430d-ae19-e13bfd767bfa}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC12/MinHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{027FAC75-3FDB-4044-8DD0-BC297BD4C461}</ProjectGuid>
    <RootNamespace>MinHook</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v120_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v120_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v120_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v120_xp</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName).x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName).x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MinimalRebuild>false</MinimalRebuild>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <NoEntryPoint>true</NoEntryPoint>
      <MergeSections>.CRT=.text</MergeSections>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MinimalRebuild>false</MinimalRebuild>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <NoEntryPoint>true</NoEntryPoint>
      <MergeSections>.CRT=.text</MergeSections>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="..\..\dll_resources\MinHook.def" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\..\dll_resources\MinHook.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC12/MinHookVC12.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.30501.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libMinHook", "libMinHook.vcxproj", "{F142A341-5EE0-442D-A15F-98AE9B48DBAE}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MinHook", "MinHook.vcxproj", "{027FAC75-3FDB-4044-8DD0-BC297BD4C461}"
	ProjectSection(ProjectDependencies) = postProject
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE} = {F142A341-5EE0-442D-A15F-98AE9B48DBAE}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|Win32.ActiveCfg = Debug|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|Win32.Build.0 = Debug|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|x64.ActiveCfg = Debug|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|x64.Build.0 = Debug|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|Win32.ActiveCfg = Release|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|Win32.Build.0 = Release|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|x64.ActiveCfg = Release|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|x64.Build.0 = Release|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|Win32.ActiveCfg = Debug|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|Win32.Build.0 = Debug|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|x64.ActiveCfg = Debug|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|x64.Build.0 = Debug|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|Win32.ActiveCfg = Release|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|Win32.Build.0 = Release|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|x64.ActiveCfg = Release|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`CSGO SDK/Libraries/minhook-master/build/VC12/libMinHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F142A341-5EE0-442D-A15F-98AE9B48DBAE}</ProjectGuid>
    <RootNamespace>libMinHook</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v120_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v120_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v120_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v120_xp</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName).x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName).x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <CompileAs>CompileAsC</CompileAs>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\src\buffer.c" />
    <ClCompile Include="..\..\src\HDE\hde32.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde64.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\..\src\hook.c" />
    <ClCompile Include="..\..\src\trampoline.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\include\MinHook.h" />
    <ClInclude Include="..\..\src\buffer.h" />
    <ClInclude Include="..\..\src\HDE\hde32.h" />
    <ClInclude Include="..\..\src\HDE\hde64.h" />
    <ClInclude Include="..\..\src\HDE\pstdint.h" />
    <ClInclude Include="..\..\src\HDE\table32.h" />
    <ClInclude Include="..\..\src\HDE\table64.h" />
    <ClInclude Include="..\..\src\trampoline.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC12/libMinHook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="..\..\src\buffer.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\hook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\trampoline.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde32.c">
      <Filter>HDE</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde64.c">
      <Filter>HDE</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\src\trampoline.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\buffer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\MinHook.h" />
    <ClInclude Include="..\..\src\HDE\hde32.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\hde64.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\pstdint.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\table32.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\table64.h">
      <Filter>HDE</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{9d24b740-be2e-4cfd-b9a4-340a50946ee9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{76381bc7-2863-4cc5-aede-926ec2c506e4}</UniqueIdentifier>
    </Filter>
    <Filter Include="HDE">
      <UniqueIdentifier>{56ddb326-6179-430d-ae19-e13bfd767bfa}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC14/MinHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{027FAC75-3FDB-4044-8DD0-BC297BD4C461}</ProjectGuid>
    <RootNamespace>MinHook</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName).x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName).x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MinimalRebuild>false</MinimalRebuild>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <NoEntryPoint>true</NoEntryPoint>
      <MergeSections>.CRT=.text</MergeSections>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MinimalRebuild>false</MinimalRebuild>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <NoEntryPoint>true</NoEntryPoint>
      <MergeSections>.CRT=.text</MergeSections>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="..\..\dll_resources\MinHook.def" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\..\dll_resources\MinHook.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC14/MinHookVC14.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.22823.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libMinHook", "libMinHook.vcxproj", "{F142A341-5EE0-442D-A15F-98AE9B48DBAE}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MinHook", "MinHook.vcxproj", "{027FAC75-3FDB-4044-8DD0-BC297BD4C461}"
	ProjectSection(ProjectDependencies) = postProject
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE} = {F142A341-5EE0-442D-A15F-98AE9B48DBAE}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|Win32.ActiveCfg = Debug|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|Win32.Build.0 = Debug|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|x64.ActiveCfg = Debug|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|x64.Build.0 = Debug|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|Win32.ActiveCfg = Release|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|Win32.Build.0 = Release|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|x64.ActiveCfg = Release|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|x64.Build.0 = Release|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|Win32.ActiveCfg = Debug|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|Win32.Build.0 = Debug|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|x64.ActiveCfg = Debug|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|x64.Build.0 = Debug|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|Win32.ActiveCfg = Release|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|Win32.Build.0 = Release|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|x64.ActiveCfg = Release|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`CSGO SDK/Libraries/minhook-master/build/VC14/libMinHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F142A341-5EE0-442D-A15F-98AE9B48DBAE}</ProjectGuid>
    <RootNamespace>libMinHook</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v140_xp</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName).x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName).x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <CompileAs>CompileAsC</CompileAs>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\src\buffer.c" />
    <ClCompile Include="..\..\src\HDE\hde32.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde64.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\..\src\hook.c" />
    <ClCompile Include="..\..\src\trampoline.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\include\MinHook.h" />
    <ClInclude Include="..\..\src\buffer.h" />
    <ClInclude Include="..\..\src\HDE\hde32.h" />
    <ClInclude Include="..\..\src\HDE\hde64.h" />
    <ClInclude Include="..\..\src\HDE\pstdint.h" />
    <ClInclude Include="..\..\src\HDE\table32.h" />
    <ClInclude Include="..\..\src\HDE\table64.h" />
    <ClInclude Include="..\..\src\trampoline.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC14/libMinHook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="..\..\src\buffer.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\hook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\trampoline.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde32.c">
      <Filter>HDE</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde64.c">
      <Filter>HDE</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\src\trampoline.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\buffer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\MinHook.h" />
    <ClInclude Include="..\..\src\HDE\hde32.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\hde64.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\pstdint.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\table32.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\table64.h">
      <Filter>HDE</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{9d24b740-be2e-4cfd-b9a4-340a50946ee9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{76381bc7-2863-4cc5-aede-926ec2c506e4}</UniqueIdentifier>
    </Filter>
    <Filter Include="HDE">
      <UniqueIdentifier>{56ddb326-6179-430d-ae19-e13bfd767bfa}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC15/MinHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{027FAC75-3FDB-4044-8DD0-BC297BD4C461}</ProjectGuid>
    <RootNamespace>MinHook</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v141_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v141_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v141_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v141_xp</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName).x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName).x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX64</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MinimalRebuild>false</MinimalRebuild>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x86.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <NoEntryPoint>true</NoEntryPoint>
      <MergeSections>.CRT=.text</MergeSections>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <MinimalRebuild>false</MinimalRebuild>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>$(SolutionDir)..\..\dll_resources\MinHook.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX64</TargetMachine>
      <AdditionalDependencies>$(SolutionDir)lib\$(Configuration)\libMinHook.x64.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <NoEntryPoint>true</NoEntryPoint>
      <MergeSections>.CRT=.text</MergeSections>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="..\..\dll_resources\MinHook.def" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="..\..\dll_resources\MinHook.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`CSGO SDK/Libraries/minhook-master/build/VC15/MinHookVC15.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.25123.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libMinHook", "libMinHook.vcxproj", "{F142A341-5EE0-442D-A15F-98AE9B48DBAE}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MinHook", "MinHook.vcxproj", "{027FAC75-3FDB-4044-8DD0-BC297BD4C461}"
	ProjectSection(ProjectDependencies) = postProject
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE} = {F142A341-5EE0-442D-A15F-98AE9B48DBAE}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|Win32.ActiveCfg = Debug|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|Win32.Build.0 = Debug|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|x64.ActiveCfg = Debug|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|x64.Build.0 = Debug|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|Win32.ActiveCfg = Release|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|Win32.Build.0 = Release|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|x64.ActiveCfg = Release|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|x64.Build.0 = Release|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|Win32.ActiveCfg = Debug|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|Win32.Build.0 = Debug|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|x64.ActiveCfg = Debug|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|x64.Build.0 = Debug|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|Win32.ActiveCfg = Release|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|Win32.Build.0 = Release|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|x64.ActiveCfg = Release|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`CSGO SDK/Libraries/minhook-master/build/VC15/libMinHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F142A341-5EE0-442D-A15F-98AE9B48DBAE}</ProjectGuid>
    <RootNamespace>libMinHook</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v141_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v141_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v141_xp</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
    <PlatformToolset>v141_xp</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.40219.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)lib\$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(ProjectName).x86</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(ProjectName).x64</TargetName>
    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(ProjectName).x64</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <CompileAs>CompileAsC</CompileAs>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
    </Midl>
    <ClCompile>
      <Optimization>MinSpace</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;STRICT;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>false</MinimalRebuild>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>None</DebugInformationFormat>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
    </ClCompile>
    <Lib />
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\..\src\buffer.c" />
    <ClCompile Include="..\..\src\HDE\hde32.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde64.c">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </ClCompile>
    <ClCompile Include="..\..\src\hook.c" />
    <ClCompile Include="..\..\src\trampoline.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\include\MinHook.h" />
    <ClInclude Include="..\..\src\buffer.h" />
    <ClInclude Include="..\..\src\HDE\hde32.h" />
    <ClInclude Include="..\..\src\HDE\hde64.h" />
    <ClInclude Include="..\..\src\HDE\pstdint.h" />
    <ClInclude Include="..\..\src\HDE\table32.h" />
    <ClInclude Include="..\..\src\HDE\table64.h" />
    <ClInclude Include="..\..\src\trampoline.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`CSGO SDK/Libraries/minhook-master/build/VC15/libMinHook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="..\..\src\buffer.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\hook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\trampoline.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde32.c">
      <Filter>HDE</Filter>
    </ClCompile>
    <ClCompile Include="..\..\src\HDE\hde64.c">
      <Filter>HDE</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\..\src\trampoline.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\buffer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\..\include\MinHook.h" />
    <ClInclude Include="..\..\src\HDE\hde32.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\hde64.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\pstdint.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\table32.h">
      <Filter>HDE</Filter>
    </ClInclude>
    <ClInclude Include="..\..\src\HDE\table64.h">
      <Filter>HDE</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{9d24b740-be2e-4cfd-b9a4-340a50946ee9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{76381bc7-2863-4cc5-aede-926ec2c506e4}</UniqueIdentifier>
    </Filter>
    <Filter Include="HDE">
      <UniqueIdentifier>{56ddb326-6179-430d-ae19-e13bfd767bfa}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`CSGO SDK/Libraries/minhook-master/build/VC9/MinHook.vcproj`:

```vcproj
<?xml version="1.0" encoding="shift_jis"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9.00"
	Name="MinHook"
	ProjectGUID="{027FAC75-3FDB-4044-8DD0-BC297BD4C461}"
	RootNamespace="MinHook"
	Keyword="Win32Proj"
	TargetFrameworkVersion="196613"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="$(SolutionDir)bin\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\$(ProjectName)"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS"
				MinimalRebuild="false"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				DebugInformationFormat="4"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\$(ProjectName).x86.dll"
				LinkIncremental="2"
				ModuleDefinitionFile="$(SolutionDir)..\..\dll_resources\MinHook.def"
				GenerateDebugInformation="false"
				SubSystem="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="$(SolutionDir)bin\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\$(ProjectName)"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS"
				MinimalRebuild="false"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\$(ProjectName).x64.dll"
				LinkIncremental="2"
				ModuleDefinitionFile="$(SolutionDir)..\..\dll_resources\MinHook.def"
				GenerateDebugInformation="false"
				SubSystem="2"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)bin\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\$(ProjectName)"
			ConfigurationType="2"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="1"
				EnableIntrinsicFunctions="true"
				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS"
				MinimalRebuild="false"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\$(ProjectName).x86.dll"
				LinkIncremental="1"
				ModuleDefinitionFile="$(SolutionDir)..\..\dll_resources\MinHook.def"
				GenerateDebugInformation="false"
				SubSystem="2"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				ResourceOnlyDLL="true"
				MergeSections=".CRT=.text"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="$(SolutionDir)bin\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\$(ProjectName)"
			ConfigurationType="2"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="1"
				EnableIntrinsicFunctions="true"
				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;MINHOOK_EXPORTS"
				MinimalRebuild="false"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\$(ProjectName).x64.dll"
				LinkIncremental="1"
				ModuleDefinitionFile="$(SolutionDir)..\..\dll_resources\MinHook.def"
				GenerateDebugInformation="false"
				SubSystem="2"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				ResourceOnlyDLL="true"
				MergeSections=".CRT=.text"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<File
			RelativePath="..\..\dll_resources\MinHook.def"
			>
		</File>
		<File
			RelativePath="..\..\dll_resources\MinHook.rc"
			>
		</File>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`CSGO SDK/Libraries/minhook-master/build/VC9/MinHookVC9.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 10.00
# Visual Studio 2008
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libMinHook", "libMinHook.vcproj", "{F142A341-5EE0-442D-A15F-98AE9B48DBAE}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MinHook", "MinHook.vcproj", "{027FAC75-3FDB-4044-8DD0-BC297BD4C461}"
	ProjectSection(ProjectDependencies) = postProject
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE} = {F142A341-5EE0-442D-A15F-98AE9B48DBAE}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|Win32.ActiveCfg = Debug|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|Win32.Build.0 = Debug|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|x64.ActiveCfg = Debug|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Debug|x64.Build.0 = Debug|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|Win32.ActiveCfg = Release|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|Win32.Build.0 = Release|Win32
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|x64.ActiveCfg = Release|x64
		{F142A341-5EE0-442D-A15F-98AE9B48DBAE}.Release|x64.Build.0 = Release|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|Win32.ActiveCfg = Debug|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|Win32.Build.0 = Debug|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|x64.ActiveCfg = Debug|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Debug|x64.Build.0 = Debug|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|Win32.ActiveCfg = Release|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|Win32.Build.0 = Release|Win32
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|x64.ActiveCfg = Release|x64
		{027FAC75-3FDB-4044-8DD0-BC297BD4C461}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`CSGO SDK/Libraries/minhook-master/build/VC9/libMinHook.vcproj`:

```vcproj
<?xml version="1.0" encoding="shift_jis"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9.00"
	Name="libMinHook"
	ProjectGUID="{F142A341-5EE0-442D-A15F-98AE9B48DBAE}"
	RootNamespace="libMinHook"
	Keyword="Win32Proj"
	TargetFrameworkVersion="196613"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="$(SolutionDir)lib\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\$(ProjectName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories=""
				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;STRICT"
				MinimalRebuild="false"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				DebugInformationFormat="0"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).x86.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="$(SolutionDir)lib\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\$(ProjectName)"
			ConfigurationType="4"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				WholeProgramOptimization="false"
				AdditionalIncludeDirectories=""
				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;STRICT"
				MinimalRebuild="false"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				DebugInformationFormat="0"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).x64.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)lib\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\$(ProjectName)"
			ConfigurationType="4"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="1"
				InlineFunctionExpansion="2"
				EnableIntrinsicFunctions="true"
				WholeProgramOptimization="true"
				AdditionalIncludeDirectories=""
				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;STRICT"
				MinimalRebuild="false"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				AssemblerOutput="2"
				WarningLevel="3"
				DebugInformationFormat="0"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).x86.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="$(SolutionDir)lib\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)\$(ProjectName)"
			ConfigurationType="4"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="1"
				InlineFunctionExpansion="2"
				EnableIntrinsicFunctions="true"
				WholeProgramOptimization="true"
				AdditionalIncludeDirectories=""
				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;STRICT"
				MinimalRebuild="false"
				RuntimeLibrary="0"
				EnableFunctionLevelLinking="true"
				UsePrecompiledHeader="0"
				AssemblerOutput="2"
				WarningLevel="3"
				DebugInformationFormat="0"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLibrarianTool"
				OutputFile="$(OutDir)\$(ProjectName).x64.lib"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath="..\..\src\buffer.c"
				>
			</File>
			<File
				RelativePath="..\..\src\hook.c"
				>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="2"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|x64"
					>
					<Tool
						Name="VCCLCompilerTool"
						Optimization="2"
					/>
				</FileConfiguration>
			</File>
			<File
				RelativePath="..\..\src\trampoline.c"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath="..\..\src\buffer.h"
				>
			</File>
			<File
				RelativePath="..\..\src\trampoline.h"
				>
			</File>
		</Filter>
		<Filter
			Name="HDE"
			>
			<File
				RelativePath="..\..\src\HDE\hde32.c"
				>
				<FileConfiguration
					Name="Debug|x64"
					ExcludedFromBuild="true"
					>
					<Tool
						Name="VCCLCompilerTool"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|x64"
					ExcludedFromBuild="true"
					>
					<Tool
						Name="VCCLCompilerTool"
					/>
				</FileConfiguration>
			</File>
			<File
				RelativePath="..\..\src\HDE\hde32.h"
				>
			</File>
			<File
				RelativePath="..\..\src\HDE\hde64.c"
				>
				<FileConfiguration
					Name="Debug|Win32"
					ExcludedFromBuild="true"
					>
					<Tool
						Name="VCCLCompilerTool"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|Win32"
					ExcludedFromBuild="true"
					>
					<Tool
						Name="VCCLCompilerTool"
					/>
				</FileConfiguration>
			</File>
			<File
				RelativePath="..\..\src\HDE\hde64.h"
				>
			</File>
			<File
				RelativePath="..\..\src\HDE\pstdint.h"
				>
			</File>
			<File
				RelativePath="..\..\src\HDE\table32.h"
				>
			</File>
			<File
				RelativePath="..\..\src\HDE\table64.h"
				>
			</File>
		</Filter>
		<File
			RelativePath="..\..\include\MinHook.h"
			>
		</File>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`CSGO SDK/Libraries/minhook-master/dll_resources/MinHook.def`:

```def
EXPORTS
    MH_Initialize
    MH_Uninitialize

    MH_CreateHook
    MH_CreateHookApi
    MH_CreateHookApiEx
    MH_RemoveHook
    MH_EnableHook
    MH_DisableHook
    MH_QueueEnableHook
    MH_QueueDisableHook
    MH_ApplyQueued
    MH_StatusToString

```

`CSGO SDK/Libraries/minhook-master/dll_resources/MinHook.rc`:

```rc
1 VERSIONINFO
 FILEVERSION 1,3,3,0
 PRODUCTVERSION 1,3,3,0
 FILEFLAGSMASK 0x17L
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x4L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Tsuda Kageyu"
            VALUE "FileDescription", "MinHook - The Minimalistic API Hook Library for x64/x86"
            VALUE "FileVersion", "1.3.3.0"
            VALUE "InternalName", "MinHookD"
            VALUE "LegalCopyright", "Copyright (C) 2009-2017 Tsuda Kageyu. All rights reserved."
            VALUE "LegalTrademarks", "Tsuda Kageyu"
            VALUE "ProductName", "MinHook DLL"
            VALUE "ProductVersion", "1.3.3.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

```

`CSGO SDK/Libraries/minhook-master/include/MinHook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a Hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget    [in]  A pointer to the target function, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    //   ppTarget   [out] A pointer to the target function, which will be used
    //                    with other functions.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif


```

`CSGO SDK/Libraries/minhook-master/src/buffer.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>
#include "buffer.h"

// Size of each memory block. (= page size of VirtualAlloc)
#define MEMORY_BLOCK_SIZE 0x1000

// Max range for seeking a memory block. (= 1024MB)
#define MAX_MEMORY_RANGE 0x40000000

// Memory protection flags to check the executable address.
#define PAGE_EXECUTE_FLAGS \
    (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)

// Memory slot.
typedef struct _MEMORY_SLOT
{
    union
    {
        struct _MEMORY_SLOT *pNext;
        UINT8 buffer[MEMORY_SLOT_SIZE];
    };
} MEMORY_SLOT, *PMEMORY_SLOT;

// Memory block info. Placed at the head of each block.
typedef struct _MEMORY_BLOCK
{
    struct _MEMORY_BLOCK *pNext;
    PMEMORY_SLOT pFree;         // First element of the free slot list.
    UINT usedCount;
} MEMORY_BLOCK, *PMEMORY_BLOCK;

//-------------------------------------------------------------------------
// Global Variables:
//-------------------------------------------------------------------------

// First element of the memory block list.
PMEMORY_BLOCK g_pMemoryBlocks;

//-------------------------------------------------------------------------
VOID InitializeBuffer(VOID)
{
    // Nothing to do for now.
}

//-------------------------------------------------------------------------
VOID UninitializeBuffer(VOID)
{
    PMEMORY_BLOCK pBlock = g_pMemoryBlocks;
    g_pMemoryBlocks = NULL;

    while (pBlock)
    {
        PMEMORY_BLOCK pNext = pBlock->pNext;
        VirtualFree(pBlock, 0, MEM_RELEASE);
        pBlock = pNext;
    }
}

//-------------------------------------------------------------------------
#if defined(_M_X64) || defined(__x86_64__)
static LPVOID FindPrevFreeRegion(LPVOID pAddress, LPVOID pMinAddr, DWORD dwAllocationGranularity)
{
    ULONG_PTR tryAddr = (ULONG_PTR)pAddress;

    // Round down to the allocation granularity.
    tryAddr -= tryAddr % dwAllocationGranularity;

    // Start from the previous allocation granularity multiply.
    tryAddr -= dwAllocationGranularity;

    while (tryAddr >= (ULONG_PTR)pMinAddr)
    {
        MEMORY_BASIC_INFORMATION mbi;
        if (VirtualQuery((LPVOID)tryAddr, &mbi, sizeof(mbi)) == 0)
            break;

        if (mbi.State == MEM_FREE)
            return (LPVOID)tryAddr;

        if ((ULONG_PTR)mbi.AllocationBase < dwAllocationGranularity)
            break;

        tryAddr = (ULONG_PTR)mbi.AllocationBase - dwAllocationGranularity;
    }

    return NULL;
}
#endif

//-------------------------------------------------------------------------
#if defined(_M_X64) || defined(__x86_64__)
static LPVOID FindNextFreeRegion(LPVOID pAddress, LPVOID pMaxAddr, DWORD dwAllocationGranularity)
{
    ULONG_PTR tryAddr = (ULONG_PTR)pAddress;

    // Round down to the allocation granularity.
    tryAddr -= tryAddr % dwAllocationGranularity;

    // Start from the next allocation granularity multiply.
    tryAddr += dwAllocationGranularity;

    while (tryAddr <= (ULONG_PTR)pMaxAddr)
    {
        MEMORY_BASIC_INFORMATION mbi;
        if (VirtualQuery((LPVOID)tryAddr, &mbi, sizeof(mbi)) == 0)
            break;

        if (mbi.State == MEM_FREE)
            return (LPVOID)tryAddr;

        tryAddr = (ULONG_PTR)mbi.BaseAddress + mbi.RegionSize;

        // Round up to the next allocation granularity.
        tryAddr += dwAllocationGranularity - 1;
        tryAddr -= tryAddr % dwAllocationGranularity;
    }

    return NULL;
}
#endif

//-------------------------------------------------------------------------
static PMEMORY_BLOCK GetMemoryBlock(LPVOID pOrigin)
{
    PMEMORY_BLOCK pBlock;
#if defined(_M_X64) || defined(__x86_64__)
    ULONG_PTR minAddr;
    ULONG_PTR maxAddr;

    SYSTEM_INFO si;
    GetSystemInfo(&si);
    minAddr = (ULONG_PTR)si.lpMinimumApplicationAddress;
    maxAddr = (ULONG_PTR)si.lpMaximumApplicationAddress;

    // pOrigin ± 512MB
    if ((ULONG_PTR)pOrigin > MAX_MEMORY_RANGE && minAddr < (ULONG_PTR)pOrigin - MAX_MEMORY_RANGE)
        minAddr = (ULONG_PTR)pOrigin - MAX_MEMORY_RANGE;

    if (maxAddr > (ULONG_PTR)pOrigin + MAX_MEMORY_RANGE)
        maxAddr = (ULONG_PTR)pOrigin + MAX_MEMORY_RANGE;

    // Make room for MEMORY_BLOCK_SIZE bytes.
    maxAddr -= MEMORY_BLOCK_SIZE - 1;
#endif

    // Look the registered blocks for a reachable one.
    for (pBlock = g_pMemoryBlocks; pBlock != NULL; pBlock = pBlock->pNext)
    {
#if defined(_M_X64) || defined(__x86_64__)
        // Ignore the blocks too far.
        if ((ULONG_PTR)pBlock < minAddr || (ULONG_PTR)pBlock >= maxAddr)
            continue;
#endif
        // The block has at least one unused slot.
        if (pBlock->pFree != NULL)
            return pBlock;
    }

#if defined(_M_X64) || defined(__x86_64__)
    // Alloc a new block above if not found.
    {
        LPVOID pAlloc = pOrigin;
        while ((ULONG_PTR)pAlloc >= minAddr)
        {
            pAlloc = FindPrevFreeRegion(pAlloc, (LPVOID)minAddr, si.dwAllocationGranularity);
            if (pAlloc == NULL)
                break;

            pBlock = (PMEMORY_BLOCK)VirtualAlloc(
                pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (pBlock != NULL)
                break;
        }
    }

    // Alloc a new block below if not found.
    if (pBlock == NULL)
    {
        LPVOID pAlloc = pOrigin;
        while ((ULONG_PTR)pAlloc <= maxAddr)
        {
            pAlloc = FindNextFreeRegion(pAlloc, (LPVOID)maxAddr, si.dwAllocationGranularity);
            if (pAlloc == NULL)
                break;

            pBlock = (PMEMORY_BLOCK)VirtualAlloc(
                pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (pBlock != NULL)
                break;
        }
    }
#else
    // In x86 mode, a memory block can be placed anywhere.
    pBlock = (PMEMORY_BLOCK)VirtualAlloc(
        NULL, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
#endif

    if (pBlock != NULL)
    {
        // Build a linked list of all the slots.
        PMEMORY_SLOT pSlot = (PMEMORY_SLOT)pBlock + 1;
        pBlock->pFree = NULL;
        pBlock->usedCount = 0;
        do
        {
            pSlot->pNext = pBlock->pFree;
            pBlock->pFree = pSlot;
            pSlot++;
        } while ((ULONG_PTR)pSlot - (ULONG_PTR)pBlock <= MEMORY_BLOCK_SIZE - MEMORY_SLOT_SIZE);

        pBlock->pNext = g_pMemoryBlocks;
        g_pMemoryBlocks = pBlock;
    }

    return pBlock;
}

//-------------------------------------------------------------------------
LPVOID AllocateBuffer(LPVOID pOrigin)
{
    PMEMORY_SLOT  pSlot;
    PMEMORY_BLOCK pBlock = GetMemoryBlock(pOrigin);
    if (pBlock == NULL)
        return NULL;

    // Remove an unused slot from the list.
    pSlot = pBlock->pFree;
    pBlock->pFree = pSlot->pNext;
    pBlock->usedCount++;
#ifdef _DEBUG
    // Fill the slot with INT3 for debugging.
    memset(pSlot, 0xCC, sizeof(MEMORY_SLOT));
#endif
    return pSlot;
}

//-------------------------------------------------------------------------
VOID FreeBuffer(LPVOID pBuffer)
{
    PMEMORY_BLOCK pBlock = g_pMemoryBlocks;
    PMEMORY_BLOCK pPrev = NULL;
    ULONG_PTR pTargetBlock = ((ULONG_PTR)pBuffer / MEMORY_BLOCK_SIZE) * MEMORY_BLOCK_SIZE;

    while (pBlock != NULL)
    {
        if ((ULONG_PTR)pBlock == pTargetBlock)
        {
            PMEMORY_SLOT pSlot = (PMEMORY_SLOT)pBuffer;
#ifdef _DEBUG
            // Clear the released slot for debugging.
            memset(pSlot, 0x00, sizeof(*pSlot));
#endif
            // Restore the released slot to the list.
            pSlot->pNext = pBlock->pFree;
            pBlock->pFree = pSlot;
            pBlock->usedCount--;

            // Free if unused.
            if (pBlock->usedCount == 0)
            {
                if (pPrev)
                    pPrev->pNext = pBlock->pNext;
                else
                    g_pMemoryBlocks = pBlock->pNext;

                VirtualFree(pBlock, 0, MEM_RELEASE);
            }

            break;
        }

        pPrev = pBlock;
        pBlock = pBlock->pNext;
    }
}

//-------------------------------------------------------------------------
BOOL IsExecutableAddress(LPVOID pAddress)
{
    MEMORY_BASIC_INFORMATION mi;
    VirtualQuery(pAddress, &mi, sizeof(mi));

    return (mi.State == MEM_COMMIT && (mi.Protect & PAGE_EXECUTE_FLAGS));
}

```

`CSGO SDK/Libraries/minhook-master/src/buffer.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

// Size of each memory slot.
#if defined(_M_X64) || defined(__x86_64__)
    #define MEMORY_SLOT_SIZE 64
#else
    #define MEMORY_SLOT_SIZE 32
#endif

VOID   InitializeBuffer(VOID);
VOID   UninitializeBuffer(VOID);
LPVOID AllocateBuffer(LPVOID pOrigin);
VOID   FreeBuffer(LPVOID pBuffer);
BOOL   IsExecutableAddress(LPVOID pAddress);

```

`CSGO SDK/Libraries/minhook-master/src/hde/hde32.c`:

```c
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#if defined(_M_IX86) || defined(__i386__)

#include "hde32.h"
#include "table32.h"

unsigned int hde32_disasm(const void *code, hde32s *hs)
{
    uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde32_table, m_mod, m_reg, m_rm, disp_size = 0;

    // Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
    memset((LPBYTE)hs, 0, sizeof(hde32s));
#else
    __stosb((LPBYTE)hs, 0, sizeof(hde32s));
#endif

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde32_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde32_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde32_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde32_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde32_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde32_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde32_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde32_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4 && !(pref & PRE_67)) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (pref & PRE_66) {
            hs->flags |= F_IMM16;
            hs->imm.imm16 = *(uint16_t *)p;
            p += 2;
        } else {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        }
    }

    if (cflags & C_IMM16) {
        if (hs->flags & F_IMM32) {
            hs->flags |= F_IMM16;
            hs->disp.disp16 = *(uint16_t *)p;
        } else if (hs->flags & F_IMM16) {
            hs->flags |= F_2IMM16;
            hs->disp.disp16 = *(uint16_t *)p;
        } else {
            hs->flags |= F_IMM16;
            hs->imm.imm16 = *(uint16_t *)p;
        }
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

#endif // defined(_M_IX86) || defined(__i386__)

```

`CSGO SDK/Libraries/minhook-master/src/hde/hde32.h`:

```h
/*
 * Hacker Disassembler Engine 32
 * Copyright (c) 2006-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde32.h: C/C++ header file
 *
 */

#ifndef _HDE32_H_
#define _HDE32_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_DISP8         0x00000020
#define F_DISP16        0x00000040
#define F_DISP32        0x00000080
#define F_RELATIVE      0x00000100
#define F_2IMM16        0x00000800
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_ANY    0x3f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde32s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde32_disasm(const void *code, hde32s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE32_H_ */

```

`CSGO SDK/Libraries/minhook-master/src/hde/hde64.c`:

```c
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#if defined(_M_X64) || defined(__x86_64__)

#include "hde64.h"
#include "table64.h"

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    // Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
    memset((LPBYTE)hs, 0, sizeof(hde64s));
#else
    __stosb((LPBYTE)hs, 0, sizeof(hde64s));
#endif

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

#endif // defined(_M_X64) || defined(__x86_64__)

```

`CSGO SDK/Libraries/minhook-master/src/hde/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`CSGO SDK/Libraries/minhook-master/src/hde/pstdint.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#include <windows.h>

// Integer types for HDE.
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

```

`CSGO SDK/Libraries/minhook-master/src/hde/table32.h`:

```h
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xf1
#define DELTA_FPU_MODRM    0xf8
#define DELTA_PREFIXES     0x130
#define DELTA_OP_LOCK_OK   0x1a1
#define DELTA_OP2_LOCK_OK  0x1b9
#define DELTA_OP_ONLY_MEM  0x1cb
#define DELTA_OP2_ONLY_MEM 0x1da

unsigned char hde32_table[] = {
  0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,
  0xa8,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xac,0xaa,0xb2,0xaa,0x9f,0x9f,
  0x9f,0x9f,0xb5,0xa3,0xa3,0xa4,0xaa,0xaa,0xba,0xaa,0x96,0xaa,0xa8,0xaa,0xc3,
  0xc3,0x96,0x96,0xb7,0xae,0xd6,0xbd,0xa3,0xc5,0xa3,0xa3,0x9f,0xc3,0x9c,0xaa,
  0xaa,0xac,0xaa,0xbf,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0x90,
  0x82,0x7d,0x97,0x59,0x59,0x59,0x59,0x59,0x7f,0x59,0x59,0x60,0x7d,0x7f,0x7f,
  0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x9a,0x88,0x7d,
  0x59,0x50,0x50,0x50,0x50,0x59,0x59,0x59,0x59,0x61,0x94,0x61,0x9e,0x59,0x59,
  0x85,0x59,0x92,0xa3,0x60,0x60,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,
  0x59,0x59,0x9f,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xcc,0x01,0xbc,0x03,0xf0,
  0x10,0x10,0x10,0x10,0x50,0x50,0x50,0x50,0x14,0x20,0x20,0x20,0x20,0x01,0x01,
  0x01,0x01,0xc4,0x02,0x10,0x00,0x00,0x00,0x00,0x01,0x01,0xc0,0xc2,0x10,0x11,
  0x02,0x03,0x11,0x03,0x03,0x04,0x00,0x00,0x14,0x00,0x02,0x00,0x00,0xc6,0xc8,
  0x02,0x02,0x02,0x02,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xca,
  0x01,0x01,0x01,0x00,0x06,0x00,0x04,0x00,0xc0,0xc2,0x01,0x01,0x03,0x01,0xff,
  0xff,0x01,0x00,0x03,0xc4,0xc4,0xc6,0x03,0x01,0x01,0x01,0xff,0x03,0x03,0x03,
  0xc8,0x40,0x00,0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,
  0x00,0x00,0x00,0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,
  0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xff,0xff,0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x7f,0x00,0x00,0xff,0x4a,0x4a,0x4a,0x4a,0x4b,0x52,0x4a,0x4a,0x4a,0x4a,0x4f,
  0x4c,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x55,0x45,0x40,0x4a,0x4a,0x4a,
  0x45,0x59,0x4d,0x46,0x4a,0x5d,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
  0x4a,0x4a,0x4a,0x4a,0x4a,0x61,0x63,0x67,0x4e,0x4a,0x4a,0x6b,0x6d,0x4a,0x4a,
  0x45,0x6d,0x4a,0x4a,0x44,0x45,0x4a,0x4a,0x00,0x00,0x00,0x02,0x0d,0x06,0x06,
  0x06,0x06,0x0e,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x00,0x06,0x06,0x02,0x06,
  0x00,0x0a,0x0a,0x07,0x07,0x06,0x02,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x00,0x00,0x00,0x0e,0x05,0x06,0x06,0x06,0x01,0x06,0x00,0x00,0x08,
  0x00,0x10,0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,
  0x86,0x00,0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,
  0xf8,0xbb,0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,
  0xc4,0xff,0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,
  0x13,0x09,0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,
  0xb2,0xff,0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,
  0xe7,0x08,0x00,0xf0,0x02,0x00
};

```

`CSGO SDK/Libraries/minhook-master/src/hde/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`CSGO SDK/Libraries/minhook-master/src/hook.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>
#include <tlhelp32.h>
#include <limits.h>

#include "../include/MinHook.h"
#include "buffer.h"
#include "trampoline.h"

#ifndef ARRAYSIZE
    #define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
#endif

// Initial capacity of the HOOK_ENTRY buffer.
#define INITIAL_HOOK_CAPACITY   32

// Initial capacity of the thread IDs buffer.
#define INITIAL_THREAD_CAPACITY 128

// Special hook position values.
#define INVALID_HOOK_POS UINT_MAX
#define ALL_HOOKS_POS    UINT_MAX

// Freeze() action argument defines.
#define ACTION_DISABLE      0
#define ACTION_ENABLE       1
#define ACTION_APPLY_QUEUED 2

// Thread access rights for suspending/resuming threads.
#define THREAD_ACCESS \
    (THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION | THREAD_SET_CONTEXT)

// Hook information.
typedef struct _HOOK_ENTRY
{
    LPVOID pTarget;             // Address of the target function.
    LPVOID pDetour;             // Address of the detour or relay function.
    LPVOID pTrampoline;         // Address of the trampoline function.
    UINT8  backup[8];           // Original prologue of the target function.

    UINT8  patchAbove  : 1;     // Uses the hot patch area.
    UINT8  isEnabled   : 1;     // Enabled.
    UINT8  queueEnable : 1;     // Queued for enabling/disabling when != isEnabled.

    UINT   nIP : 4;             // Count of the instruction boundaries.
    UINT8  oldIPs[8];           // Instruction boundaries of the target function.
    UINT8  newIPs[8];           // Instruction boundaries of the trampoline function.
} HOOK_ENTRY, *PHOOK_ENTRY;

// Suspended threads for Freeze()/Unfreeze().
typedef struct _FROZEN_THREADS
{
    LPDWORD pItems;         // Data heap
    UINT    capacity;       // Size of allocated data heap, items
    UINT    size;           // Actual number of data items
} FROZEN_THREADS, *PFROZEN_THREADS;

//-------------------------------------------------------------------------
// Global Variables:
//-------------------------------------------------------------------------

// Spin lock flag for EnterSpinLock()/LeaveSpinLock().
volatile LONG g_isLocked = FALSE;

// Private heap handle. If not NULL, this library is initialized.
HANDLE g_hHeap = NULL;

// Hook entries.
struct
{
    PHOOK_ENTRY pItems;     // Data heap
    UINT        capacity;   // Size of allocated data heap, items
    UINT        size;       // Actual number of data items
} g_hooks;

//-------------------------------------------------------------------------
// Returns INVALID_HOOK_POS if not found.
static UINT FindHookEntry(LPVOID pTarget)
{
    UINT i;
    for (i = 0; i < g_hooks.size; ++i)
    {
        if ((ULONG_PTR)pTarget == (ULONG_PTR)g_hooks.pItems[i].pTarget)
            return i;
    }

    return INVALID_HOOK_POS;
}

//-------------------------------------------------------------------------
static PHOOK_ENTRY AddHookEntry()
{
    if (g_hooks.pItems == NULL)
    {
        g_hooks.capacity = INITIAL_HOOK_CAPACITY;
        g_hooks.pItems = (PHOOK_ENTRY)HeapAlloc(
            g_hHeap, 0, g_hooks.capacity * sizeof(HOOK_ENTRY));
        if (g_hooks.pItems == NULL)
            return NULL;
    }
    else if (g_hooks.size >= g_hooks.capacity)
    {
        PHOOK_ENTRY p = (PHOOK_ENTRY)HeapReAlloc(
            g_hHeap, 0, g_hooks.pItems, (g_hooks.capacity * 2) * sizeof(HOOK_ENTRY));
        if (p == NULL)
            return NULL;

        g_hooks.capacity *= 2;
        g_hooks.pItems = p;
    }

    return &g_hooks.pItems[g_hooks.size++];
}

//-------------------------------------------------------------------------
static void DeleteHookEntry(UINT pos)
{
    if (pos < g_hooks.size - 1)
        g_hooks.pItems[pos] = g_hooks.pItems[g_hooks.size - 1];

    g_hooks.size--;

    if (g_hooks.capacity / 2 >= INITIAL_HOOK_CAPACITY && g_hooks.capacity / 2 >= g_hooks.size)
    {
        PHOOK_ENTRY p = (PHOOK_ENTRY)HeapReAlloc(
            g_hHeap, 0, g_hooks.pItems, (g_hooks.capacity / 2) * sizeof(HOOK_ENTRY));
        if (p == NULL)
            return;

        g_hooks.capacity /= 2;
        g_hooks.pItems = p;
    }
}

//-------------------------------------------------------------------------
static DWORD_PTR FindOldIP(PHOOK_ENTRY pHook, DWORD_PTR ip)
{
    UINT i;

    if (pHook->patchAbove && ip == ((DWORD_PTR)pHook->pTarget - sizeof(JMP_REL)))
        return (DWORD_PTR)pHook->pTarget;

    for (i = 0; i < pHook->nIP; ++i)
    {
        if (ip == ((DWORD_PTR)pHook->pTrampoline + pHook->newIPs[i]))
            return (DWORD_PTR)pHook->pTarget + pHook->oldIPs[i];
    }

#if defined(_M_X64) || defined(__x86_64__)
    // Check relay function.
    if (ip == (DWORD_PTR)pHook->pDetour)
        return (DWORD_PTR)pHook->pTarget;
#endif

    return 0;
}

//-------------------------------------------------------------------------
static DWORD_PTR FindNewIP(PHOOK_ENTRY pHook, DWORD_PTR ip)
{
    UINT i;
    for (i = 0; i < pHook->nIP; ++i)
    {
        if (ip == ((DWORD_PTR)pHook->pTarget + pHook->oldIPs[i]))
            return (DWORD_PTR)pHook->pTrampoline + pHook->newIPs[i];
    }

    return 0;
}

//-------------------------------------------------------------------------
static void ProcessThreadIPs(HANDLE hThread, UINT pos, UINT action)
{
    // If the thread suspended in the overwritten area,
    // move IP to the proper address.

    CONTEXT c;
#if defined(_M_X64) || defined(__x86_64__)
    DWORD64 *pIP = &c.Rip;
#else
    DWORD   *pIP = &c.Eip;
#endif
    UINT count;

    c.ContextFlags = CONTEXT_CONTROL;
    if (!GetThreadContext(hThread, &c))
        return;

    if (pos == ALL_HOOKS_POS)
    {
        pos = 0;
        count = g_hooks.size;
    }
    else
    {
        count = pos + 1;
    }

    for (; pos < count; ++pos)
    {
        PHOOK_ENTRY pHook = &g_hooks.pItems[pos];
        BOOL        enable;
        DWORD_PTR   ip;

        switch (action)
        {
        case ACTION_DISABLE:
            enable = FALSE;
            break;

        case ACTION_ENABLE:
            enable = TRUE;
            break;

        default: // ACTION_APPLY_QUEUED
            enable = pHook->queueEnable;
            break;
        }
        if (pHook->isEnabled == enable)
            continue;

        if (enable)
            ip = FindNewIP(pHook, *pIP);
        else
            ip = FindOldIP(pHook, *pIP);

        if (ip != 0)
        {
            *pIP = ip;
            SetThreadContext(hThread, &c);
        }
    }
}

//-------------------------------------------------------------------------
static VOID EnumerateThreads(PFROZEN_THREADS pThreads)
{
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hSnapshot != INVALID_HANDLE_VALUE)
    {
        THREADENTRY32 te;
        te.dwSize = sizeof(THREADENTRY32);
        if (Thread32First(hSnapshot, &te))
        {
            do
            {
                if (te.dwSize >= (FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(DWORD))
                    && te.th32OwnerProcessID == GetCurrentProcessId()
                    && te.th32ThreadID != GetCurrentThreadId())
                {
                    if (pThreads->pItems == NULL)
                    {
                        pThreads->capacity = INITIAL_THREAD_CAPACITY;
                        pThreads->pItems
                            = (LPDWORD)HeapAlloc(g_hHeap, 0, pThreads->capacity * sizeof(DWORD));
                        if (pThreads->pItems == NULL)
                            break;
                    }
                    else if (pThreads->size >= pThreads->capacity)
                    {
                        LPDWORD p = (LPDWORD)HeapReAlloc(
                            g_hHeap, 0, pThreads->pItems, (pThreads->capacity * 2) * sizeof(DWORD));
                        if (p == NULL)
                            break;

                        pThreads->capacity *= 2;
                        pThreads->pItems = p;
                    }
                    pThreads->pItems[pThreads->size++] = te.th32ThreadID;
                }

                te.dwSize = sizeof(THREADENTRY32);
            } while (Thread32Next(hSnapshot, &te));
        }
        CloseHandle(hSnapshot);
    }
}

//-------------------------------------------------------------------------
static VOID Freeze(PFROZEN_THREADS pThreads, UINT pos, UINT action)
{
    pThreads->pItems   = NULL;
    pThreads->capacity = 0;
    pThreads->size     = 0;
    EnumerateThreads(pThreads);

    if (pThreads->pItems != NULL)
    {
        UINT i;
        for (i = 0; i < pThreads->size; ++i)
        {
            HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads->pItems[i]);
            if (hThread != NULL)
            {
                SuspendThread(hThread);
                ProcessThreadIPs(hThread, pos, action);
                CloseHandle(hThread);
            }
        }
    }
}

//-------------------------------------------------------------------------
static VOID Unfreeze(PFROZEN_THREADS pThreads)
{
    if (pThreads->pItems != NULL)
    {
        UINT i;
        for (i = 0; i < pThreads->size; ++i)
        {
            HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads->pItems[i]);
            if (hThread != NULL)
            {
                ResumeThread(hThread);
                CloseHandle(hThread);
            }
        }

        HeapFree(g_hHeap, 0, pThreads->pItems);
    }
}

//-------------------------------------------------------------------------
static MH_STATUS EnableHookLL(UINT pos, BOOL enable)
{
    PHOOK_ENTRY pHook = &g_hooks.pItems[pos];
    DWORD  oldProtect;
    SIZE_T patchSize    = sizeof(JMP_REL);
    LPBYTE pPatchTarget = (LPBYTE)pHook->pTarget;

    if (pHook->patchAbove)
    {
        pPatchTarget -= sizeof(JMP_REL);
        patchSize    += sizeof(JMP_REL_SHORT);
    }

    if (!VirtualProtect(pPatchTarget, patchSize, PAGE_EXECUTE_READWRITE, &oldProtect))
        return MH_ERROR_MEMORY_PROTECT;

    if (enable)
    {
        PJMP_REL pJmp = (PJMP_REL)pPatchTarget;
        pJmp->opcode = 0xE9;
        pJmp->operand = (UINT32)((LPBYTE)pHook->pDetour - (pPatchTarget + sizeof(JMP_REL)));

        if (pHook->patchAbove)
        {
            PJMP_REL_SHORT pShortJmp = (PJMP_REL_SHORT)pHook->pTarget;
            pShortJmp->opcode = 0xEB;
            pShortJmp->operand = (UINT8)(0 - (sizeof(JMP_REL_SHORT) + sizeof(JMP_REL)));
        }
    }
    else
    {
        if (pHook->patchAbove)
            memcpy(pPatchTarget, pHook->backup, sizeof(JMP_REL) + sizeof(JMP_REL_SHORT));
        else
            memcpy(pPatchTarget, pHook->backup, sizeof(JMP_REL));
    }

    VirtualProtect(pPatchTarget, patchSize, oldProtect, &oldProtect);

    // Just-in-case measure.
    FlushInstructionCache(GetCurrentProcess(), pPatchTarget, patchSize);

    pHook->isEnabled   = enable;
    pHook->queueEnable = enable;

    return MH_OK;
}

//-------------------------------------------------------------------------
static MH_STATUS EnableAllHooksLL(BOOL enable)
{
    MH_STATUS status = MH_OK;
    UINT i, first = INVALID_HOOK_POS;

    for (i = 0; i < g_hooks.size; ++i)
    {
        if (g_hooks.pItems[i].isEnabled != enable)
        {
            first = i;
            break;
        }
    }

    if (first != INVALID_HOOK_POS)
    {
        FROZEN_THREADS threads;
        Freeze(&threads, ALL_HOOKS_POS, enable ? ACTION_ENABLE : ACTION_DISABLE);

        for (i = first; i < g_hooks.size; ++i)
        {
            if (g_hooks.pItems[i].isEnabled != enable)
            {
                status = EnableHookLL(i, enable);
                if (status != MH_OK)
                    break;
            }
        }

        Unfreeze(&threads);
    }

    return status;
}

//-------------------------------------------------------------------------
static VOID EnterSpinLock(VOID)
{
    SIZE_T spinCount = 0;

    // Wait until the flag is FALSE.
    while (InterlockedCompareExchange(&g_isLocked, TRUE, FALSE) != FALSE)
    {
        // No need to generate a memory barrier here, since InterlockedCompareExchange()
        // generates a full memory barrier itself.

        // Prevent the loop from being too busy.
        if (spinCount < 32)
            Sleep(0);
        else
            Sleep(1);

        spinCount++;
    }
}

//-------------------------------------------------------------------------
static VOID LeaveSpinLock(VOID)
{
    // No need to generate a memory barrier here, since InterlockedExchange()
    // generates a full memory barrier itself.

    InterlockedExchange(&g_isLocked, FALSE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_Initialize(VOID)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap == NULL)
    {
        g_hHeap = HeapCreate(0, 0, 0);
        if (g_hHeap != NULL)
        {
            // Initialize the internal function buffer.
            InitializeBuffer();
        }
        else
        {
            status = MH_ERROR_MEMORY_ALLOC;
        }
    }
    else
    {
        status = MH_ERROR_ALREADY_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_Uninitialize(VOID)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        status = EnableAllHooksLL(FALSE);
        if (status == MH_OK)
        {
            // Free the internal function buffer.

            // HeapFree is actually not required, but some tools detect a false
            // memory leak without HeapFree.

            UninitializeBuffer();

            HeapFree(g_hHeap, 0, g_hooks.pItems);
            HeapDestroy(g_hHeap);

            g_hHeap = NULL;

            g_hooks.pItems   = NULL;
            g_hooks.capacity = 0;
            g_hooks.size     = 0;
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        if (IsExecutableAddress(pTarget) && IsExecutableAddress(pDetour))
        {
            UINT pos = FindHookEntry(pTarget);
            if (pos == INVALID_HOOK_POS)
            {
                LPVOID pBuffer = AllocateBuffer(pTarget);
                if (pBuffer != NULL)
                {
                    TRAMPOLINE ct;

                    ct.pTarget     = pTarget;
                    ct.pDetour     = pDetour;
                    ct.pTrampoline = pBuffer;
                    if (CreateTrampolineFunction(&ct))
                    {
                        PHOOK_ENTRY pHook = AddHookEntry();
                        if (pHook != NULL)
                        {
                            pHook->pTarget     = ct.pTarget;
#if defined(_M_X64) || defined(__x86_64__)
                            pHook->pDetour     = ct.pRelay;
#else
                            pHook->pDetour     = ct.pDetour;
#endif
                            pHook->pTrampoline = ct.pTrampoline;
                            pHook->patchAbove  = ct.patchAbove;
                            pHook->isEnabled   = FALSE;
                            pHook->queueEnable = FALSE;
                            pHook->nIP         = ct.nIP;
                            memcpy(pHook->oldIPs, ct.oldIPs, ARRAYSIZE(ct.oldIPs));
                            memcpy(pHook->newIPs, ct.newIPs, ARRAYSIZE(ct.newIPs));

                            // Back up the target function.

                            if (ct.patchAbove)
                            {
                                memcpy(
                                    pHook->backup,
                                    (LPBYTE)pTarget - sizeof(JMP_REL),
                                    sizeof(JMP_REL) + sizeof(JMP_REL_SHORT));
                            }
                            else
                            {
                                memcpy(pHook->backup, pTarget, sizeof(JMP_REL));
                            }

                            if (ppOriginal != NULL)
                                *ppOriginal = pHook->pTrampoline;
                        }
                        else
                        {
                            status = MH_ERROR_MEMORY_ALLOC;
                        }
                    }
                    else
                    {
                        status = MH_ERROR_UNSUPPORTED_FUNCTION;
                    }

                    if (status != MH_OK)
                    {
                        FreeBuffer(pBuffer);
                    }
                }
                else
                {
                    status = MH_ERROR_MEMORY_ALLOC;
                }
            }
            else
            {
                status = MH_ERROR_ALREADY_CREATED;
            }
        }
        else
        {
            status = MH_ERROR_NOT_EXECUTABLE;
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        UINT pos = FindHookEntry(pTarget);
        if (pos != INVALID_HOOK_POS)
        {
            if (g_hooks.pItems[pos].isEnabled)
            {
                FROZEN_THREADS threads;
                Freeze(&threads, pos, ACTION_DISABLE);

                status = EnableHookLL(pos, FALSE);

                Unfreeze(&threads);
            }

            if (status == MH_OK)
            {
                FreeBuffer(g_hooks.pItems[pos].pTrampoline);
                DeleteHookEntry(pos);
            }
        }
        else
        {
            status = MH_ERROR_NOT_CREATED;
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
static MH_STATUS EnableHook(LPVOID pTarget, BOOL enable)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        if (pTarget == MH_ALL_HOOKS)
        {
            status = EnableAllHooksLL(enable);
        }
        else
        {
            FROZEN_THREADS threads;
            UINT pos = FindHookEntry(pTarget);
            if (pos != INVALID_HOOK_POS)
            {
                if (g_hooks.pItems[pos].isEnabled != enable)
                {
                    Freeze(&threads, pos, ACTION_ENABLE);

                    status = EnableHookLL(pos, enable);

                    Unfreeze(&threads);
                }
                else
                {
                    status = enable ? MH_ERROR_ENABLED : MH_ERROR_DISABLED;
                }
            }
            else
            {
                status = MH_ERROR_NOT_CREATED;
            }
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget)
{
    return EnableHook(pTarget, TRUE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget)
{
    return EnableHook(pTarget, FALSE);
}

//-------------------------------------------------------------------------
static MH_STATUS QueueHook(LPVOID pTarget, BOOL queueEnable)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        if (pTarget == MH_ALL_HOOKS)
        {
            UINT i;
            for (i = 0; i < g_hooks.size; ++i)
                g_hooks.pItems[i].queueEnable = queueEnable;
        }
        else
        {
            UINT pos = FindHookEntry(pTarget);
            if (pos != INVALID_HOOK_POS)
            {
                g_hooks.pItems[pos].queueEnable = queueEnable;
            }
            else
            {
                status = MH_ERROR_NOT_CREATED;
            }
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget)
{
    return QueueHook(pTarget, TRUE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget)
{
    return QueueHook(pTarget, FALSE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_ApplyQueued(VOID)
{
    MH_STATUS status = MH_OK;
    UINT i, first = INVALID_HOOK_POS;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        for (i = 0; i < g_hooks.size; ++i)
        {
            if (g_hooks.pItems[i].isEnabled != g_hooks.pItems[i].queueEnable)
            {
                first = i;
                break;
            }
        }

        if (first != INVALID_HOOK_POS)
        {
            FROZEN_THREADS threads;
            Freeze(&threads, ALL_HOOKS_POS, ACTION_APPLY_QUEUED);

            for (i = first; i < g_hooks.size; ++i)
            {
                PHOOK_ENTRY pHook = &g_hooks.pItems[i];
                if (pHook->isEnabled != pHook->queueEnable)
                {
                    status = EnableHookLL(i, pHook->queueEnable);
                    if (status != MH_OK)
                        break;
                }
            }

            Unfreeze(&threads);
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHookApiEx(
    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour,
    LPVOID *ppOriginal, LPVOID *ppTarget)
{
    HMODULE hModule;
    LPVOID  pTarget;

    hModule = GetModuleHandleW(pszModule);
    if (hModule == NULL)
        return MH_ERROR_MODULE_NOT_FOUND;

    pTarget = (LPVOID)GetProcAddress(hModule, pszProcName);
    if (pTarget == NULL)
        return MH_ERROR_FUNCTION_NOT_FOUND;

    if(ppTarget != NULL)
        *ppTarget = pTarget;

    return MH_CreateHook(pTarget, pDetour, ppOriginal);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHookApi(
    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal)
{
   return MH_CreateHookApiEx(pszModule, pszProcName, pDetour, ppOriginal, NULL);
}

//-------------------------------------------------------------------------
const char * WINAPI MH_StatusToString(MH_STATUS status)
{
#define MH_ST2STR(x)    \
    case x:             \
        return #x;

    switch (status) {
        MH_ST2STR(MH_UNKNOWN)
        MH_ST2STR(MH_OK)
        MH_ST2STR(MH_ERROR_ALREADY_INITIALIZED)
        MH_ST2STR(MH_ERROR_NOT_INITIALIZED)
        MH_ST2STR(MH_ERROR_ALREADY_CREATED)
        MH_ST2STR(MH_ERROR_NOT_CREATED)
        MH_ST2STR(MH_ERROR_ENABLED)
        MH_ST2STR(MH_ERROR_DISABLED)
        MH_ST2STR(MH_ERROR_NOT_EXECUTABLE)
        MH_ST2STR(MH_ERROR_UNSUPPORTED_FUNCTION)
        MH_ST2STR(MH_ERROR_MEMORY_ALLOC)
        MH_ST2STR(MH_ERROR_MEMORY_PROTECT)
        MH_ST2STR(MH_ERROR_MODULE_NOT_FOUND)
        MH_ST2STR(MH_ERROR_FUNCTION_NOT_FOUND)
    }

#undef MH_ST2STR

    return "(unknown)";
}

```

`CSGO SDK/Libraries/minhook-master/src/trampoline.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>

#ifndef ARRAYSIZE
    #define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
#endif

#if defined(_M_X64) || defined(__x86_64__)
    #include "./hde/hde64.h"
    typedef hde64s HDE;
    #define HDE_DISASM(code, hs) hde64_disasm(code, hs)
#else
    #include "./hde/hde32.h"
    typedef hde32s HDE;
    #define HDE_DISASM(code, hs) hde32_disasm(code, hs)
#endif

#include "trampoline.h"
#include "buffer.h"

// Maximum size of a trampoline function.
#if defined(_M_X64) || defined(__x86_64__)
    #define TRAMPOLINE_MAX_SIZE (MEMORY_SLOT_SIZE - sizeof(JMP_ABS))
#else
    #define TRAMPOLINE_MAX_SIZE MEMORY_SLOT_SIZE
#endif

//-------------------------------------------------------------------------
static BOOL IsCodePadding(LPBYTE pInst, UINT size)
{
    UINT i;

    if (pInst[0] != 0x00 && pInst[0] != 0x90 && pInst[0] != 0xCC)
        return FALSE;

    for (i = 1; i < size; ++i)
    {
        if (pInst[i] != pInst[0])
            return FALSE;
    }
    return TRUE;
}

//-------------------------------------------------------------------------
BOOL CreateTrampolineFunction(PTRAMPOLINE ct)
{
#if defined(_M_X64) || defined(__x86_64__)
    CALL_ABS call = {
        0xFF, 0x15, 0x00000002, // FF15 00000002: CALL [RIP+8]
        0xEB, 0x08,             // EB 08:         JMP +10
        0x0000000000000000ULL   // Absolute destination address
    };
    JMP_ABS jmp = {
        0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6]
        0x0000000000000000ULL   // Absolute destination address
    };
    JCC_ABS jcc = {
        0x70, 0x0E,             // 7* 0E:         J** +16
        0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6]
        0x0000000000000000ULL   // Absolute destination address
    };
#else
    CALL_REL call = {
        0xE8,                   // E8 xxxxxxxx: CALL +5+xxxxxxxx
        0x00000000              // Relative destination address
    };
    JMP_REL jmp = {
        0xE9,                   // E9 xxxxxxxx: JMP +5+xxxxxxxx
        0x00000000              // Relative destination address
    };
    JCC_REL jcc = {
        0x0F, 0x80,             // 0F8* xxxxxxxx: J** +6+xxxxxxxx
        0x00000000              // Relative destination address
    };
#endif

    UINT8     oldPos   = 0;
    UINT8     newPos   = 0;
    ULONG_PTR jmpDest  = 0;     // Destination address of an internal jump.
    BOOL      finished = FALSE; // Is the function completed?
#if defined(_M_X64) || defined(__x86_64__)
    UINT8     instBuf[16];
#endif

    ct->patchAbove = FALSE;
    ct->nIP        = 0;

    do
    {
        HDE       hs;
        UINT      copySize;
        LPVOID    pCopySrc;
        ULONG_PTR pOldInst = (ULONG_PTR)ct->pTarget     + oldPos;
        ULONG_PTR pNewInst = (ULONG_PTR)ct->pTrampoline + newPos;

        copySize = HDE_DISASM((LPVOID)pOldInst, &hs);
        if (hs.flags & F_ERROR)
            return FALSE;

        pCopySrc = (LPVOID)pOldInst;
        if (oldPos >= sizeof(JMP_REL))
        {
            // The trampoline function is long enough.
            // Complete the function with the jump to the target function.
#if defined(_M_X64) || defined(__x86_64__)
            jmp.address = pOldInst;
#else
            jmp.operand = (UINT32)(pOldInst - (pNewInst + sizeof(jmp)));
#endif
            pCopySrc = &jmp;
            copySize = sizeof(jmp);

            finished = TRUE;
        }
#if defined(_M_X64) || defined(__x86_64__)
        else if ((hs.modrm & 0xC7) == 0x05)
        {
            // Instructions using RIP relative addressing. (ModR/M = 00???101B)

            // Modify the RIP relative address.
            PUINT32 pRelAddr;

            // Avoid using memcpy to reduce the footprint.
#ifndef _MSC_VER
            memcpy(instBuf, (LPBYTE)pOldInst, copySize);
#else
            __movsb(instBuf, (LPBYTE)pOldInst, copySize);
#endif
            pCopySrc = instBuf;

            // Relative address is stored at (instruction length - immediate value length - 4).
            pRelAddr = (PUINT32)(instBuf + hs.len - ((hs.flags & 0x3C) >> 2) - 4);
            *pRelAddr
                = (UINT32)((pOldInst + hs.len + (INT32)hs.disp.disp32) - (pNewInst + hs.len));

            // Complete the function if JMP (FF /4).
            if (hs.opcode == 0xFF && hs.modrm_reg == 4)
                finished = TRUE;
        }
#endif
        else if (hs.opcode == 0xE8)
        {
            // Direct relative CALL
            ULONG_PTR dest = pOldInst + hs.len + (INT32)hs.imm.imm32;
#if defined(_M_X64) || defined(__x86_64__)
            call.address = dest;
#else
            call.operand = (UINT32)(dest - (pNewInst + sizeof(call)));
#endif
            pCopySrc = &call;
            copySize = sizeof(call);
        }
        else if ((hs.opcode & 0xFD) == 0xE9)
        {
            // Direct relative JMP (EB or E9)
            ULONG_PTR dest = pOldInst + hs.len;

            if (hs.opcode == 0xEB) // isShort jmp
                dest += (INT8)hs.imm.imm8;
            else
                dest += (INT32)hs.imm.imm32;

            // Simply copy an internal jump.
            if ((ULONG_PTR)ct->pTarget <= dest
                && dest < ((ULONG_PTR)ct->pTarget + sizeof(JMP_REL)))
            {
                if (jmpDest < dest)
                    jmpDest = dest;
            }
            else
            {
#if defined(_M_X64) || defined(__x86_64__)
                jmp.address = dest;
#else
                jmp.operand = (UINT32)(dest - (pNewInst + sizeof(jmp)));
#endif
                pCopySrc = &jmp;
                copySize = sizeof(jmp);

                // Exit the function If it is not in the branch
                finished = (pOldInst >= jmpDest);
            }
        }
        else if ((hs.opcode & 0xF0) == 0x70
            || (hs.opcode & 0xFC) == 0xE0
            || (hs.opcode2 & 0xF0) == 0x80)
        {
            // Direct relative Jcc
            ULONG_PTR dest = pOldInst + hs.len;

            if ((hs.opcode & 0xF0) == 0x70      // Jcc
                || (hs.opcode & 0xFC) == 0xE0)  // LOOPNZ/LOOPZ/LOOP/JECXZ
                dest += (INT8)hs.imm.imm8;
            else
                dest += (INT32)hs.imm.imm32;

            // Simply copy an internal jump.
            if ((ULONG_PTR)ct->pTarget <= dest
                && dest < ((ULONG_PTR)ct->pTarget + sizeof(JMP_REL)))
            {
                if (jmpDest < dest)
                    jmpDest = dest;
            }
            else if ((hs.opcode & 0xFC) == 0xE0)
            {
                // LOOPNZ/LOOPZ/LOOP/JCXZ/JECXZ to the outside are not supported.
                return FALSE;
            }
            else
            {
                UINT8 cond = ((hs.opcode != 0x0F ? hs.opcode : hs.opcode2) & 0x0F);
#if defined(_M_X64) || defined(__x86_64__)
                // Invert the condition in x64 mode to simplify the conditional jump logic.
                jcc.opcode  = 0x71 ^ cond;
                jcc.address = dest;
#else
                jcc.opcode1 = 0x80 | cond;
                jcc.operand = (UINT32)(dest - (pNewInst + sizeof(jcc)));
#endif
                pCopySrc = &jcc;
                copySize = sizeof(jcc);
            }
        }
        else if ((hs.opcode & 0xFE) == 0xC2)
        {
            // RET (C2 or C3)

            // Complete the function if not in a branch.
            finished = (pOldInst >= jmpDest);
        }

        // Can't alter the instruction length in a branch.
        if (pOldInst < jmpDest && copySize != hs.len)
            return FALSE;

        // Trampoline function is too large.
        if ((newPos + copySize) > TRAMPOLINE_MAX_SIZE)
            return FALSE;

        // Trampoline function has too many instructions.
        if (ct->nIP >= ARRAYSIZE(ct->oldIPs))
            return FALSE;

        ct->oldIPs[ct->nIP] = oldPos;
        ct->newIPs[ct->nIP] = newPos;
        ct->nIP++;

        // Avoid using memcpy to reduce the footprint.
#ifndef _MSC_VER
        memcpy((LPBYTE)ct->pTrampoline + newPos, pCopySrc, copySize);
#else
        __movsb((LPBYTE)ct->pTrampoline + newPos, pCopySrc, copySize);
#endif
        newPos += copySize;
        oldPos += hs.len;
    }
    while (!finished);

    // Is there enough place for a long jump?
    if (oldPos < sizeof(JMP_REL)
        && !IsCodePadding((LPBYTE)ct->pTarget + oldPos, sizeof(JMP_REL) - oldPos))
    {
        // Is there enough place for a short jump?
        if (oldPos < sizeof(JMP_REL_SHORT)
            && !IsCodePadding((LPBYTE)ct->pTarget + oldPos, sizeof(JMP_REL_SHORT) - oldPos))
        {
            return FALSE;
        }

        // Can we place the long jump above the function?
        if (!IsExecutableAddress((LPBYTE)ct->pTarget - sizeof(JMP_REL)))
            return FALSE;

        if (!IsCodePadding((LPBYTE)ct->pTarget - sizeof(JMP_REL), sizeof(JMP_REL)))
            return FALSE;

        ct->patchAbove = TRUE;
    }

#if defined(_M_X64) || defined(__x86_64__)
    // Create a relay function.
    jmp.address = (ULONG_PTR)ct->pDetour;

    ct->pRelay = (LPBYTE)ct->pTrampoline + newPos;
    memcpy(ct->pRelay, &jmp, sizeof(jmp));
#endif

    return TRUE;
}

```

`CSGO SDK/Libraries/minhook-master/src/trampoline.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#pragma pack(push, 1)

// Structs for writing x86/x64 instructions.

// 8-bit relative jump.
typedef struct _JMP_REL_SHORT
{
    UINT8  opcode;      // EB xx: JMP +2+xx
    UINT8  operand;
} JMP_REL_SHORT, *PJMP_REL_SHORT;

// 32-bit direct relative jump/call.
typedef struct _JMP_REL
{
    UINT8  opcode;      // E9/E8 xxxxxxxx: JMP/CALL +5+xxxxxxxx
    UINT32 operand;     // Relative destination address
} JMP_REL, *PJMP_REL, CALL_REL;

// 64-bit indirect absolute jump.
typedef struct _JMP_ABS
{
    UINT8  opcode0;     // FF25 00000000: JMP [+6]
    UINT8  opcode1;
    UINT32 dummy;
    UINT64 address;     // Absolute destination address
} JMP_ABS, *PJMP_ABS;

// 64-bit indirect absolute call.
typedef struct _CALL_ABS
{
    UINT8  opcode0;     // FF15 00000002: CALL [+6]
    UINT8  opcode1;
    UINT32 dummy0;
    UINT8  dummy1;      // EB 08:         JMP +10
    UINT8  dummy2;
    UINT64 address;     // Absolute destination address
} CALL_ABS;

// 32-bit direct relative conditional jumps.
typedef struct _JCC_REL
{
    UINT8  opcode0;     // 0F8* xxxxxxxx: J** +6+xxxxxxxx
    UINT8  opcode1;
    UINT32 operand;     // Relative destination address
} JCC_REL;

// 64bit indirect absolute conditional jumps that x64 lacks.
typedef struct _JCC_ABS
{
    UINT8  opcode;      // 7* 0E:         J** +16
    UINT8  dummy0;
    UINT8  dummy1;      // FF25 00000000: JMP [+6]
    UINT8  dummy2;
    UINT32 dummy3;
    UINT64 address;     // Absolute destination address
} JCC_ABS;

#pragma pack(pop)

typedef struct _TRAMPOLINE
{
    LPVOID pTarget;         // [In] Address of the target function.
    LPVOID pDetour;         // [In] Address of the detour function.
    LPVOID pTrampoline;     // [In] Buffer address for the trampoline and relay function.

#if defined(_M_X64) || defined(__x86_64__)
    LPVOID pRelay;          // [Out] Address of the relay function.
#endif
    BOOL   patchAbove;      // [Out] Should use the hot patch area?
    UINT   nIP;             // [Out] Number of the instruction boundaries.
    UINT8  oldIPs[8];       // [Out] Instruction boundaries of the target function.
    UINT8  newIPs[8];       // [Out] Instruction boundaries of the trampoline function.
} TRAMPOLINE, *PTRAMPOLINE;

BOOL CreateTrampolineFunction(PTRAMPOLINE ct);

```

`CSGO SDK/Menu/Elements.cpp`:

```cpp
#include <filesystem>
#include "Elements.h"
#include "Framework/GUI.h"
#include "../Features/Miscellaneous/KitParser.hpp"
#include "../Features/Miscellaneous/SkinChanger.hpp"
#include "../Utils/Config.hpp"
#include "../Features/Visuals/EventLogger.hpp"
#include "../source.hpp"

namespace Menu {

	void DrawMenu() {
		if (GUI::Form::BeginWindow(XorStr("AutismWare")) || GUI::ctx->setup) {
			static int current_weapon = 0;
			static int rage_current_group = 0;
			static int current_group = 0;

			if (GUI::Form::BeginTab(0, XorStr("A")) || GUI::ctx->setup) {

				CVariables::RAGE* rbot = nullptr;
				GUI::Group::BeginGroup(XorStr("Aimbot"), Vector2D(50, 100));
				GUI::Controls::Checkbox(XorStr("Enabled##rage"), &g_Vars.rage.enabled);
				GUI::Controls::Hotkey(XorStr("Enabled key##rage"), &g_Vars.rage.key);

				{
					GUI::Controls::Dropdown(XorStr("Group"), { XorStr("Default"),
						XorStr("Pistols"),
						XorStr("Heavy pistols"),
						XorStr("Rifles"),
						XorStr("AWP"),
						XorStr("Scout"),
						XorStr("Auto snipers"),
						XorStr("Sub machines"),
						XorStr("Heavys"),
						XorStr("Shotguns") }, &rage_current_group);


					switch (rage_current_group - 1) {
					case WEAPONGROUP_PISTOL:
						rbot = &g_Vars.rage_pistols;
						break;
					case WEAPONGROUP_HEAVYPISTOL:
						rbot = &g_Vars.rage_heavypistols;
						break;
					case WEAPONGROUP_SUBMACHINE + 1:
						rbot = &g_Vars.rage_smgs;
						break;
					case WEAPONGROUP_RIFLE:
						rbot = &g_Vars.rage_rifles;
						break;
					case WEAPONGROUP_SHOTGUN + 1:
						rbot = &g_Vars.rage_shotguns;
						break;
					case WEAPONGROUP_SNIPER:
						rbot = &g_Vars.rage_awp;
						break;
					case WEAPONGROUP_SNIPER + 1:
						rbot = &g_Vars.rage_scout;
						break;
					case WEAPONGROUP_HEAVY + 1:
						rbot = &g_Vars.rage_heavys;
						break;
					case WEAPONGROUP_AUTOSNIPER + 1:
						rbot = &g_Vars.rage_autosnipers;
						break;
					default:
						rbot = &g_Vars.rage_default;
						break;
					}

					GUI::Controls::Checkbox(XorStr("Override weapon group") + std::string(XorStr("#") + std::to_string(rage_current_group)), &rbot->active);

					if (rbot->active || GUI::ctx->setup) {
						GUI::Controls::Dropdown(XorStr("Target selection") + std::string(XorStr("#") + std::to_string(rage_current_group)), {
							XorStr("Highest damage"),
							XorStr("Nearest to crosshair"),
							XorStr("Lowest health"),
							XorStr("Lowest distance"),
							XorStr("Lowest latency"), },
							&rbot->target_selection);

						std::vector<MultiItem_t> hitboxes = {
							{ XorStr("Head"), &rbot->hitboxes_head },
							{ XorStr("Chest"), &rbot->hitboxes_chest },
							{ XorStr("Stomach"), &rbot->hitboxes_stomach },
							{ XorStr("Pelvis"), &rbot->hitboxes_pelvis },
							{ XorStr("Arms"), &rbot->hitboxes_arms },
							{ XorStr("Legs"), &rbot->hitboxes_legs },
							{ XorStr("Feet"), &rbot->hitboxes_feets },
						};
						GUI::Controls::MultiDropdown(XorStr("Hitboxes") + std::string(XorStr("#") + std::to_string(rage_current_group)), hitboxes);

						std::vector<MultiItem_t> mp_safety_hitboxes = {
							{ XorStr("Head"), &rbot->mp_hitboxes_head },
							{ XorStr("Chest"), &rbot->mp_hitboxes_chest },
							{ XorStr("Stomach"), &rbot->mp_hitboxes_stomach },
							{ XorStr("Legs"), &rbot->mp_hitboxes_legs },
							{ XorStr("Feet"), &rbot->mp_hitboxes_feets },
						};

						if (!mp_safety_hitboxes.empty())
							GUI::Controls::MultiDropdown(XorStr("Multipoints") + std::string(XorStr("#") + std::to_string(rage_current_group)), mp_safety_hitboxes);

						//if( GUI::Controls::Checkbox( XorStr( "Static pointscale" ) + std::string( XorStr( "#" ) + std::to_string( rage_current_group ) ), &rbot->static_point_scale ) || GUI::ctx->setup ) {

						GUI::Controls::Slider(XorStr("Head scale##687687675") + std::string(XorStr("#") + std::to_string(rage_current_group)), &rbot->point_scale, 0.f, 100.0f, rbot->point_scale <= 0 ? XorStr("Auto") : XorStr("%.0f%%"));
						GUI::Controls::Slider(XorStr("Body scale##68776678") + std::string(XorStr("#") + std::to_string(rage_current_group)), &rbot->body_point_scale, 0.f, 100.0f, rbot->body_point_scale <= 0 ? XorStr("Auto") : XorStr("%.0f%%"));



						GUI::Controls::Checkbox(XorStr("Automatic fire"), &g_Vars.rage.auto_fire);
						GUI::Controls::Checkbox(XorStr("Automatic penetration") + std::string(XorStr("#") + std::to_string(rage_current_group)), &rbot->autowall);
						GUI::Controls::Checkbox(XorStr("Silent aim"), &g_Vars.rage.silent_aim);

						GUI::Controls::Slider(XorStr("Hit chance") + std::string(XorStr("#") + std::to_string(rage_current_group)), &rbot->hitchance, 0.f, 100.f, XorStr("%.0f%%"));

						GUI::Controls::Slider(XorStr("Minimum damage") + std::string(XorStr("#") + std::to_string(rage_current_group)), &rbot->min_damage_visible, 1.f, 130.f, rbot->min_damage_visible > 100 ? (std::string(XorStr("HP+")).append(std::string(std::to_string(rbot->min_damage_visible - 100)))) : XorStr("%dhp"));

						std::vector<MultiItem_t> ovrhitboxes = {
						{ XorStr("Head"), &rbot->hitboxes_ovr_head },
						{ XorStr("Chest"), &rbot->hitboxes_ovr_chest },
						{ XorStr("Stomach"), &rbot->hitboxes_ovr_stomach },
						{ XorStr("Pelvis"), &rbot->hitboxes_ovr_pelvis },
						{ XorStr("Arms"), &rbot->hitboxes_ovr_arms },
						{ XorStr("Legs"), &rbot->hitboxes_ovr_legs },
						{ XorStr("Feet"), &rbot->hitboxes_ovr_feets },
						};

						GUI::Controls::MultiDropdown(XorStr("Hitbox override") + std::string(XorStr("#") + std::to_string(rage_current_group)), ovrhitboxes);
						GUI::Controls::Hotkey(XorStr("Hitbox override#key") + std::string(XorStr("#") + std::to_string(rage_current_group)), &g_Vars.rage.hitbox_override_bind);


						if (GUI::Controls::Checkbox(XorStr("Minimum damage override") + std::string(XorStr("#") + std::to_string(rage_current_group)), &rbot->min_damage_override) || GUI::ctx->setup) {
							GUI::Controls::Hotkey(XorStr("Minimum dmg override key#key") + std::string(XorStr("#") + std::to_string(rage_current_group)), &g_Vars.rage.key_dmg_override);
							GUI::Controls::Slider(XorStr("Dmg override amount##slider") + std::string(XorStr("#") + std::to_string(rage_current_group)), &rbot->min_damage_override_amount, 1.f, 130.f, rbot->min_damage_override_amount > 100 ? (std::string(XorStr("HP+")).append(std::string(std::to_string(rbot->min_damage_override_amount - 100)))) : XorStr("%dhp"));
						}
					}
				}

				GUI::Group::EndGroup();

				GUI::Group::BeginGroup(XorStr("Accuracy"), Vector2D(50, 100)); {

					if (GUI::Controls::Checkbox(XorStr("Extended backtrack") + std::string(XorStr("#") + std::to_string(rage_current_group)), &g_Vars.misc.extended_backtrack)) {
						GUI::Controls::Hotkey(XorStr("Extended backtrack qswdecxvrftgbyhnujmiko,l") + std::string(XorStr("#") + std::to_string(rage_current_group)), &g_Vars.misc.extended_backtrack_key);
						GUI::Controls::Slider(XorStr("Extended backtrack##amt") + std::string(XorStr("#") + std::to_string(rage_current_group)), &g_Vars.misc.extended_backtrack_time, 0.f, 1.f, XorStr("%.2fs"), 0.1f);
					}

					//if( !g_Vars.misc.anti_untrusted || GUI::ctx->setup )


					GUI::Controls::Checkbox(XorStr("Auto stop"), &rbot->autostop_check);

					GUI::Controls::Checkbox(XorStr("Automatic scope") + std::string(XorStr("#") + std::to_string(rage_current_group)), &rbot->autoscope);

					GUI::Controls::Checkbox(XorStr("Prefer baim") + std::string(XorStr("#") + std::to_string(rage_current_group)), &rbot->prefer_body);

					GUI::Controls::Checkbox(XorStr("Knife bot"), &g_Vars.misc.knife_bot);
					if (g_Vars.misc.knife_bot || GUI::ctx->setup)
						GUI::Controls::Dropdown(XorStr("Knifebot type##Knife bot type"), { XorStr("Default"), XorStr("Backstab"), XorStr("Quick") }, &g_Vars.misc.knife_bot_type);

					GUI::Controls::Checkbox(XorStr("Zeus bot"), &g_Vars.misc.zeus_bot);
					if (g_Vars.misc.zeus_bot || GUI::ctx->setup)
						GUI::Controls::Slider(XorStr("Zeus bot hitchance"), &g_Vars.misc.zeus_bot_hitchance, 1.f, 80.f, XorStr("%.0f%%"));

				} GUI::Group::EndGroup();

			}

			if (GUI::Form::BeginTab(1, XorStr("B")) || GUI::ctx->setup)
			{
				GUI::Group::BeginGroup(("Antiaim"), Vector2D(50, 100));
				{
					CVariables::ANTIAIM_STATE* settings = &g_Vars.antiaim_stand;
					// enable AA.
					if (GUI::Controls::Checkbox(("Enabled##aa"), &g_Vars.antiaim.enabled))
						// yaw / pitch / fake.
						GUI::Controls::Dropdown(("Pitch"), { ("Off"), ("Down"), ("Up"), ("Zero") }, &settings->pitch);
					GUI::Controls::Dropdown(("Yaw"), { ("Off"), ("Backwards"), ("180z"), "Jitter" }, &settings->base_yaw);


					if (settings->base_yaw > 0)
						GUI::Controls::Slider(("Yaw addition"), &g_Vars.antiaim.yaw_addition, -180, 180);

					if (settings->base_yaw == 3)
					{
						GUI::Controls::Dropdown(("Jitter mode"), { ("Random"), ("Center") }, &settings->jitter_mode);
						GUI::Controls::Slider(("Jitter amount"), &g_Vars.antiaim.random_jitter, -360, 360);
					}

					GUI::Controls::Dropdown(("Fake yaw"), { ("Off"), ("Default"), ("Flicker") }, & settings->fake_yaw);
					GUI::Controls::Dropdown(("Body yaw"), { ("Off"), ("Twist"), ("Static"), ("Break Logic") }, &settings->yaw);

					if (settings->yaw > 0 && settings->yaw != 3) {
						GUI::Controls::Slider(("Delta"), &g_Vars.antiaim.break_lby, -179, 179);
					}

					if (settings->base_yaw == 0) {}

					GUI::Controls::Checkbox(("Freestanding"), &g_Vars.antiaim.freestand);

					GUI::Controls::Checkbox(("Draw angles"), &g_Vars.antiaim.draw_angles);

					if (GUI::Controls::Checkbox(("Manual"), &g_Vars.antiaim.manual) || GUI::ctx->setup) {
						GUI::Controls::ColorPicker(("Manual color"), &g_Vars.antiaim.manual_color);
						GUI::Controls::Label(("Left"));
						GUI::Controls::Hotkey(("Left key##key"), &g_Vars.antiaim.manual_left_bind, false);

						GUI::Controls::Label(("Right"));
						GUI::Controls::Hotkey(("Right key##key"), &g_Vars.antiaim.manual_right_bind, false);

						GUI::Controls::Label(("Back"));
						GUI::Controls::Hotkey(("Back key##key"), &g_Vars.antiaim.manual_back_bind, false);
					}

					// distortion.
					if (GUI::Controls::Checkbox(("Distortion###sse"), &g_Vars.antiaim.distort)) {
						// manual aa is on, show this.
						if (g_Vars.antiaim.manual)
							GUI::Controls::Checkbox(("Manual override"), &g_Vars.antiaim.distort_manual_aa);
						GUI::Controls::Checkbox(("Spin"), &g_Vars.antiaim.distort_spin);
						GUI::Controls::Slider(("Speed"), &g_Vars.antiaim.distort_speed, 1.f, 10.f, ("%.1f"));
						GUI::Controls::Slider(("Range"), &g_Vars.antiaim.distort_range, 0.f, 360.f);

						std::vector<MultiItem_t> distort_disablers = {
							{ ("Fakewalking"), &g_Vars.antiaim.distort_disable_fakewalk },
						{ ("Running"), &g_Vars.antiaim.distort_disable_run },
						{ ("Airborne"), &g_Vars.antiaim.distort_disable_air },
						};

						GUI::Controls::MultiDropdown(("Distortion disablers"), distort_disablers);
					}

					if (GUI::Controls::Checkbox(("Fake-walk"), &g_Vars.misc.slow_walk)) {
						GUI::Controls::Hotkey(("Fake-walk key#Key"), &g_Vars.misc.slow_walk_bind);
					}


				}
				GUI::Group::EndGroup();

				GUI::Group::BeginGroup(XorStr("Fake lag"), Vector2D(50, 50)); {
					GUI::Controls::Checkbox(XorStr("Enabled##fakeKURWAlag"), &g_Vars.fakelag.enabled);

					std::vector<MultiItem_t> fakelag_cond = {
						{ XorStr("Moving"), &g_Vars.fakelag.when_moving },
						{ XorStr("In air"), &g_Vars.fakelag.when_air },
						{ XorStr("On Peek"), &g_Vars.fakelag.trigger_on_peek },
						{ XorStr("LBY Update"), &g_Vars.fakelag.lby_update },
						{ XorStr("Break LC"), &g_Vars.fakelag.break_lag_compensation },
					};
					GUI::Controls::MultiDropdown(XorStr("Conditions"), fakelag_cond);
					GUI::Controls::Dropdown(XorStr("Type"), { XorStr("Maximum"), XorStr("Dynamic"), XorStr("Fluctuate") }, &g_Vars.fakelag.choke_type);
					GUI::Controls::Slider(XorStr("Limit"), &g_Vars.fakelag.choke, 2, 14);
					GUI::Controls::Slider(XorStr("Alternate Limit"), &g_Vars.fakelag.alternative_choke, 2, 14);

					g_Vars.fakelag.trigger_duck = false;
					g_Vars.fakelag.trigger_weapon_activity = false; //g_Vars.fakelag.trigger_shooting =
					g_Vars.fakelag.trigger_reloading = false;

					GUI::Controls::Slider(XorStr("Variance"), &g_Vars.fakelag.variance, 0.0f, 100.0f, XorStr("%.0f %%"));

				}
				GUI::Group::EndGroup();

				GUI::Group::BeginGroup(XorStr("Exploits"), Vector2D(50, 50)); {

					GUI::Controls::Checkbox(XorStr("Move exploit"), &g_Vars.misc.move_exploit);
					GUI::Controls::Hotkey(XorStr("Move exploit key"), &g_Vars.misc.move_exploit_key);

				}
				GUI::Group::EndGroup();
			}

			if (GUI::Form::BeginTab(2, XorStr("C")) || GUI::ctx->setup) {

				GUI::Group::BeginGroup(XorStr("General"), Vector2D(50, 50));
				{
					GUI::Controls::Checkbox(XorStr("Enabled"), &g_Vars.esp.esp_enable);
					g_Vars.esp.team_check = true;

					GUI::Controls::Checkbox(XorStr("Dormant"), &g_Vars.esp.fade_esp);
					//GUI::Controls::ColorPicker( XorStr( "dormant clr" ), &g_Vars.esp.dormant_color );

					GUI::Controls::Checkbox(XorStr("Box"), &g_Vars.esp.box);
					GUI::Controls::ColorPicker(XorStr("Box color"), &g_Vars.esp.box_color);

					if (GUI::Controls::Checkbox(XorStr("Offscreen"), &g_Vars.esp.offscren_enabled) || GUI::ctx->setup) {
						GUI::Controls::ColorPicker(XorStr("Offscreen color"), &g_Vars.esp.offscreen_color);
						GUI::Controls::Slider(XorStr("Offscreen distance"), &g_Vars.esp.offscren_distance, 10, 100.f, XorStr("%.0f%%"));
						GUI::Controls::Slider(XorStr("Offscreen size"), &g_Vars.esp.offscren_size, 4, 16.f, XorStr("%.0fpx"));
					}

					GUI::Controls::Dropdown(XorStr("Selection"), { XorStr("Enemy"), XorStr("Team") }, &g_Vars.esp.selection);

					// enemy
					if (g_Vars.esp.selection == 0)
					{
						GUI::Controls::Checkbox(XorStr("Name"), &g_Vars.esp.draw_name);
						GUI::Controls::ColorPicker(XorStr("Name color"), &g_Vars.esp.name_color);

						GUI::Controls::Checkbox(XorStr("Health"), &g_Vars.esp.health);
						GUI::Controls::Checkbox(XorStr("Health color override"), &g_Vars.esp.health_override);
						GUI::Controls::ColorPicker(XorStr("Health color override color##Health"), &g_Vars.esp.health_color);

						GUI::Controls::Checkbox(XorStr("Skeleton"), &g_Vars.esp.skeleton);
						GUI::Controls::ColorPicker(XorStr("Skeleton color##Skelet Color"), &g_Vars.esp.skeleton_color);

						GUI::Controls::Checkbox(XorStr("Ammo"), &g_Vars.esp.draw_ammo_bar);
						GUI::Controls::ColorPicker(XorStr("Ammo color##color"), &g_Vars.esp.ammo_color);

						GUI::Controls::Checkbox(XorStr("LBY timer"), &g_Vars.esp.draw_lby_bar);
						GUI::Controls::ColorPicker(XorStr("LBY timer color##color"), &g_Vars.esp.lby_color);

						GUI::Controls::Checkbox(XorStr("Weapon"), &g_Vars.esp.weapon);
						GUI::Controls::ColorPicker(XorStr("Weapon color##color"), &g_Vars.esp.weapon_color);

						GUI::Controls::Checkbox(XorStr("Weapon icon"), &g_Vars.esp.weapon_icon);
						GUI::Controls::ColorPicker(XorStr("Weapon icon color##color"), &g_Vars.esp.weapon_icon_color);
					}
					else
					{
						GUI::Controls::Checkbox(XorStr("Name"), &g_Vars.esp.draw_name_team);
						GUI::Controls::ColorPicker(XorStr("Name color"), &g_Vars.esp.name_color_team);

						GUI::Controls::Checkbox(XorStr("Health"), &g_Vars.esp.health_team);
						GUI::Controls::Checkbox(XorStr("Health color override"), &g_Vars.esp.health_override_team);
						GUI::Controls::ColorPicker(XorStr("Health color override color##Health"), &g_Vars.esp.health_color_team);

						GUI::Controls::Checkbox(XorStr("Skeleton"), &g_Vars.esp.skeleton_team);
						GUI::Controls::ColorPicker(XorStr("Skeleton color##Skelet Color"), &g_Vars.esp.skeleton_color_team);

						GUI::Controls::Checkbox(XorStr("Ammo"), &g_Vars.esp.draw_ammo_bar_team);
						GUI::Controls::ColorPicker(XorStr("Ammo color##color"), &g_Vars.esp.ammo_color_team);

						GUI::Controls::Checkbox(XorStr("Weapon"), &g_Vars.esp.weapon_team);
						GUI::Controls::ColorPicker(XorStr("Weapon color##color"), &g_Vars.esp.weapon_color_team);

						GUI::Controls::Checkbox(XorStr("Weapon icon"), &g_Vars.esp.weapon_icon_team);
						GUI::Controls::ColorPicker(XorStr("Weapon icon color##color"), &g_Vars.esp.weapon_icon_color_team);
					}

					std::vector<MultiItem_t> flags = {
						{ XorStr("Zoom"), &g_Vars.esp.draw_scoped },
						{ XorStr("Flashed"), &g_Vars.esp.draw_flashed },
						{ XorStr("Money"), &g_Vars.esp.draw_money },
						{ XorStr("Kevlar"), &g_Vars.esp.draw_armor },
						{ XorStr("Bomb"), &g_Vars.esp.draw_bombc4 },
						{ XorStr("Defusing"), &g_Vars.esp.draw_defusing },
						{ XorStr("Distance"), &g_Vars.esp.draw_distance },
						{ XorStr("Grenade pin"), &g_Vars.esp.draw_grenade_pin },
						{ XorStr("Resolver mode"), &g_Vars.esp.draw_resolver },
					};

					GUI::Controls::MultiDropdown(XorStr("Flags"), flags);

					std::vector<MultiItem_t> hitmarkers = {
						{ XorStr("World"), &g_Vars.esp.visualize_hitmarker_world },
						{ XorStr("Screen"), &g_Vars.esp.vizualize_hitmarker },
					};

					GUI::Controls::MultiDropdown(XorStr("Hitmarkers"), hitmarkers);
					GUI::Controls::Checkbox(XorStr("Hitsound"), &g_Vars.misc.hitsound);
					GUI::Controls::Dropdown(XorStr("Hitsound type"), { XorStr("Default"), XorStr("Custom") }, &g_Vars.misc.hitsound_type);

					if (g_Vars.misc.hitsound_type || GUI::ctx->setup) {
						const auto GetScripts = []() {
							std::string dir = GetDocumentsDirectory().append(XorStr("\\ams\\"));
							for (auto& file_path : std::filesystem::directory_iterator(dir)) {
								if (!file_path.path().string().empty()) {
									if (file_path.path().string().find(XorStr(".wav")) != std::string::npos) {
										g_Vars.globals.m_hitsounds.emplace_back(file_path.path().string().erase(0, dir.length()));
									}
								}
							}
						};

						if (g_Vars.globals.m_hitsounds.empty()) {
							GetScripts();
						}

						if (g_Vars.globals.m_hitsounds.empty()) {
							GUI::Controls::Dropdown(XorStr("Custom hitsounds"), { XorStr("None: Documents\\ams\\*.wav") }, &g_Vars.misc.hitsound_custom);
						}
						else {
							GUI::Controls::Dropdown(XorStr("Custom hitsounds"), g_Vars.globals.m_hitsounds, &g_Vars.misc.hitsound_custom);
							GUI::Controls::Slider(XorStr("Sound volume"), &g_Vars.misc.hitsound_volume, 1.f, 100.f, XorStr("%.0f%%"));
						}

						GUI::Controls::Button(XorStr("Refresh sounds"), [&]() -> void {
							g_Vars.globals.m_hitsounds.clear();

							GetScripts();
							});
					}

					GUI::Group::EndGroup();
				}

				GUI::Group::BeginGroup(XorStr("Player models"), Vector2D(50, 50));
				{
					std::vector<std::string> materials = {
						XorStr("Off"), XorStr("Flat"), XorStr("Material"), XorStr("Ghost"), XorStr("Outline")
					};

					GUI::Controls::Dropdown(XorStr("Selection"), { XorStr("Enemy"), XorStr("Team"), XorStr("Local") }, & g_Vars.esp.chams_type);

					if (g_Vars.esp.chams_type == 0) 
					{
						GUI::Controls::Checkbox(XorStr("Enable"), &g_Vars.esp.chams_enemy);
						GUI::Controls::Checkbox(XorStr("Visible chams"), &g_Vars.esp.enemy_chams_vis);
						GUI::Controls::ColorPicker(XorStr("Visible chams color##Local color"), &g_Vars.esp.enemy_chams_color_vis);

						GUI::Controls::Checkbox(XorStr("Behind wall chams"), &g_Vars.esp.enemy_chams_xqz);
						GUI::Controls::ColorPicker(XorStr("Behind wall chams color##Local color"), &g_Vars.esp.enemy_chams_color_xqz);

						GUI::Controls::Dropdown(XorStr("Enemy chams material"), {
							XorStr("Off"), XorStr("Flat"), XorStr("Material"), XorStr("Ghost"), XorStr("Outline"), XorStr("Shiny")
							}, &g_Vars.esp.enemy_chams_mat);

						if (g_Vars.esp.enemy_chams_mat == 5) {
							GUI::Controls::Slider(XorStr("Enemy pearlescence"), &g_Vars.esp.chams_enemy_pearlescence, 0.f, 100.f, XorStr("%0.0f"));
							GUI::Controls::ColorPicker(XorStr("clacoenemycascans"), &g_Vars.esp.chams_enemy_pearlescence_color);
							GUI::Controls::Slider(XorStr("Enemy shine"), &g_Vars.esp.chams_enemy_shine, 0.f, 100.f, XorStr("%0.0f"));
						}

						GUI::Controls::Checkbox(XorStr("Glow"), &g_Vars.esp.glow_enemy);
						GUI::Controls::ColorPicker(XorStr("Glow color#Enemy glow"), &g_Vars.esp.glow_enemy_color);

						if (GUI::Controls::Checkbox(XorStr("Add glow#Enemy"), &g_Vars.esp.chams_enemy_outline) || GUI::ctx->setup) {
							GUI::Controls::ColorPicker(XorStr("Add glow color#Enemy"), &g_Vars.esp.chams_enemy_outline_color);
							GUI::Controls::Checkbox(XorStr("Wireframe#Enemy"), &g_Vars.esp.chams_enemy_outline_wireframe);

							GUI::Controls::Slider(XorStr("Glow strength#Enemy"), &g_Vars.esp.chams_enemy_outline_value, 1.f, 100.f, XorStr("%0.0f"));
						}

						if (GUI::Controls::Checkbox(XorStr("Backtrack chams"), &g_Vars.esp.chams_history) || GUI::ctx->setup) {
							GUI::Controls::ColorPicker(XorStr("Backtrack chams color##Local color"), &g_Vars.esp.chams_history_color);

							GUI::Controls::Dropdown(XorStr("Backtrack chams material"), materials, &g_Vars.esp.chams_history_mat);
						}
						if (GUI::Controls::Checkbox(XorStr("Shot chams"), &g_Vars.esp.hitmatrix) || GUI::ctx->setup) {
							GUI::Controls::ColorPicker(XorStr("Shot chams color##Local color"), &g_Vars.esp.hitmatrix_color);

							GUI::Controls::Slider(XorStr("Expire time##chams"), &g_Vars.esp.hitmatrix_time, 1.f, 10.f, XorStr("%0.0f seconds"));
						}

						if (GUI::Controls::Checkbox(XorStr("Shot capsules"), &g_Vars.esp.draw_hitboxes)) {
							GUI::Controls::ColorPicker(XorStr("Shot capsules color"), &g_Vars.esp.hitboxes_color);
						}
					}
					else if (g_Vars.esp.chams_type == 1)
					{
						GUI::Controls::Checkbox(XorStr("Enable"), &g_Vars.esp.chams_teammate);
						GUI::Controls::Checkbox(XorStr("Visible chams"), &g_Vars.esp.team_chams_vis);
						GUI::Controls::ColorPicker(XorStr("Visible chams color##Local color"), &g_Vars.esp.team_chams_color_vis);

						GUI::Controls::Checkbox(XorStr("Behind wall chams"), &g_Vars.esp.team_chams_xqz);
						GUI::Controls::ColorPicker(XorStr("Behind wall chams color##Local color"), &g_Vars.esp.team_chams_color_xqz);

						GUI::Controls::Dropdown(XorStr("Team chams material"), {
							XorStr("Off"), XorStr("Flat"), XorStr("Material"), XorStr("Ghost"), XorStr("Outline"), XorStr("Shiny")
							}, & g_Vars.esp.team_chams_mat);

						if (g_Vars.esp.team_chams_mat == 5) {
							GUI::Controls::Slider(XorStr("Team pearlescence"), &g_Vars.esp.chams_team_pearlescence, 0.f, 100.f, XorStr("%0.0f"));
							GUI::Controls::ColorPicker(XorStr("clacoenemycascans"), &g_Vars.esp.chams_team_pearlescence_color);
							GUI::Controls::Slider(XorStr("Team shine"), &g_Vars.esp.chams_team_shine, 0.f, 100.f, XorStr("%0.0f"));
						}

						GUI::Controls::Checkbox(XorStr("Glow"), &g_Vars.esp.glow_team);
						GUI::Controls::ColorPicker(XorStr("Glow color#Team glow"), &g_Vars.esp.glow_team_color);

						if (GUI::Controls::Checkbox(XorStr("Add glow#Team"), &g_Vars.esp.chams_teammate_outline) || GUI::ctx->setup) {
							GUI::Controls::ColorPicker(XorStr("Add glow color#Team"), &g_Vars.esp.chams_teammate_outline_color);
							GUI::Controls::Checkbox(XorStr("Wireframe#Team"), &g_Vars.esp.chams_teammate_outline_wireframe);

							GUI::Controls::Slider(XorStr("Glow strength#Team"), &g_Vars.esp.chams_teammate_outline_value, 1.f, 100.f, XorStr("%0.0f"));
						}
					}
					else if (g_Vars.esp.chams_type == 2)
					{
						GUI::Controls::Checkbox(XorStr("Enable"), &g_Vars.esp.chams_local);
						GUI::Controls::ColorPicker(XorStr("Chams color##Local color"), &g_Vars.esp.chams_local_color);

						if (GUI::Controls::Checkbox(XorStr("Glow"), &g_Vars.esp.glow_local) || GUI::ctx->setup) {
							GUI::Controls::ColorPicker(XorStr("Local glow color##Local color"), &g_Vars.esp.glow_local_color);
						}

						GUI::Controls::Dropdown(XorStr("Chams material"), {
							XorStr("Off"), XorStr("Flat"), XorStr("Material"), XorStr("Ghost"), XorStr("Outline"), XorStr("Shiny")
							}, &g_Vars.esp.chams_local_mat);

						if (g_Vars.esp.chams_local_mat == 5) {
							GUI::Controls::Slider(XorStr("Pearlescence"), &g_Vars.esp.chams_local_pearlescence, 0.f, 100.f, XorStr("%0.0f"));
							GUI::Controls::ColorPicker(XorStr("clacolacscascans"), &g_Vars.esp.chams_local_pearlescence_color);
							GUI::Controls::Slider(XorStr("Shine"), &g_Vars.esp.chams_local_shine, 0.f, 100.f, XorStr("%0.0f"));
						}

						if (GUI::Controls::Checkbox(XorStr("Add glow#Local"), &g_Vars.esp.chams_local_outline) || GUI::ctx->setup) {
							GUI::Controls::ColorPicker(XorStr("Add glow color#Local"), &g_Vars.esp.chams_local_outline_color);
							GUI::Controls::Checkbox(XorStr("Wireframe#Local"), &g_Vars.esp.chams_local_outline_wireframe);

							GUI::Controls::Slider(XorStr("Glow strength#Local"), &g_Vars.esp.chams_local_outline_value, 1.f, 100.f, XorStr("%0.0f"));
						}

						GUI::Controls::Checkbox(XorStr("Transparency in scope"), &g_Vars.esp.blur_in_scoped);
						GUI::Controls::Slider(XorStr("Transparency##Transparency In Scope"), &g_Vars.esp.blur_in_scoped_value, 0.0f, 100.f, XorStr("%0.f%%"));

						if (GUI::Controls::Checkbox(XorStr("Attachment chams"), &g_Vars.esp.chams_attachments) || GUI::ctx->setup) {
							GUI::Controls::ColorPicker(XorStr("Attachment chams color"), &g_Vars.esp.attachments_chams_color);
							GUI::Controls::Dropdown(XorStr("Attachment chams material"), materials, &g_Vars.esp.attachments_chams_mat);

							if (GUI::Controls::Checkbox(XorStr("Add glow attachment#Attachment"), &g_Vars.esp.chams_attachments_outline) || GUI::ctx->setup) {
								GUI::Controls::ColorPicker(XorStr("Add glow attachment color#Attachment"), &g_Vars.esp.chams_attachments_outline_color);
								GUI::Controls::Checkbox(XorStr("Wireframe attachment#Attachment"), &g_Vars.esp.chams_attachments_outline_wireframe);

								GUI::Controls::Slider(XorStr("Attachment glow strength#Attachment"), &g_Vars.esp.chams_attachments_outline_value, 1.f, 100.f, XorStr("%0.0f"));
							}
						}

						if (GUI::Controls::Checkbox(XorStr("Weapon chams"), &g_Vars.esp.chams_weapon) || GUI::ctx->setup) {
							GUI::Controls::ColorPicker(XorStr("Weapon chams color"), &g_Vars.esp.weapon_chams_color);
							GUI::Controls::Dropdown(XorStr("Weapon chams material"), materials, &g_Vars.esp.weapon_chams_mat);

							if (GUI::Controls::Checkbox(XorStr("Add glow weapon#Weapon"), &g_Vars.esp.chams_weapon_outline) || GUI::ctx->setup) {
								GUI::Controls::ColorPicker(XorStr("Add glow weapon color#Weapon"), &g_Vars.esp.chams_weapon_outline_color);
								GUI::Controls::Checkbox(XorStr("Wireframe weapon#Weapon"), &g_Vars.esp.chams_weapon_outline_wireframe);

								GUI::Controls::Slider(XorStr("Weapon glow strength#Weapon"), &g_Vars.esp.chams_weapon_outline_value, 1.f, 100.f, XorStr("%0.0f"));
							}
						}

						if (GUI::Controls::Checkbox(XorStr("Hand chams"), &g_Vars.esp.chams_hands) || GUI::ctx->setup) {
							GUI::Controls::ColorPicker(XorStr("Hand chams color"), &g_Vars.esp.hands_chams_color);
							GUI::Controls::Dropdown(XorStr("Hand chams material"), materials, &g_Vars.esp.hands_chams_mat);

							if (GUI::Controls::Checkbox(XorStr("Add glow hand#Hand"), &g_Vars.esp.chams_hands_outline) || GUI::ctx->setup) {
								GUI::Controls::ColorPicker(XorStr("Add glow hand color#Hand"), &g_Vars.esp.chams_hands_outline_color);
								GUI::Controls::Checkbox(XorStr("Wireframe hand#Hand"), &g_Vars.esp.chams_hands_outline_wireframe);

								GUI::Controls::Slider(XorStr("Hand glow strength#Hand"), &g_Vars.esp.chams_hands_outline_value, 1.f, 100.f, XorStr("%0.0f"));
							}
						}
					}

					GUI::Group::EndGroup();
				}

				GUI::Group::BeginGroup(XorStr("Other ESP"), Vector2D(50, 50));
				{
					if (GUI::Controls::Checkbox(XorStr("Anim layer info"), &g_Vars.esp.draw_layer_info)) {
						GUI::Controls::Dropdown(XorStr("Layer"), {
							XorStr("1"),
							XorStr("2"),
							XorStr("3"),
							XorStr("4"),
							XorStr("5"),
							XorStr("6"),
							XorStr("7"),
							XorStr("8"),
							XorStr("9"),
							XorStr("10"),
							XorStr("11"),
							XorStr("12"),
							XorStr("13"), }, &g_Vars.esp.layer);
					}


					if (GUI::Controls::Checkbox(XorStr("Preserve killfeed"), &g_Vars.esp.preserve_killfeed)) {
						// note - alpha;
						// maybe make a dropdown, with options such as:
						// "extend", "preserve" where if u have extend 
						// you can choose how long, and if u have preserve
						// just force this to FLT_MAX or smth? idk.
						g_Vars.esp.preserve_killfeed_time = 300.f;
					}

					GUI::Controls::Checkbox(XorStr("Visualize damage"), &g_Vars.esp.visualize_damage);
					GUI::Controls::Checkbox(XorStr("Disable post processing"), &g_Vars.esp.remove_post_proccesing);
					GUI::Controls::Checkbox(XorStr("Taser range"), &g_Vars.esp.zeus_distance);
					GUI::Controls::ColorPicker(XorStr("Taser range color"), &g_Vars.esp.zeus_distance_color);
					GUI::Controls::Checkbox(XorStr("Keybind list"), &g_Vars.esp.keybind_window_enabled);
					GUI::Controls::Checkbox(XorStr("Spectator list"), &g_Vars.esp.spec_window_enabled);

					GUI::Controls::Checkbox(XorStr("Radar"), &g_Vars.misc.ingame_radar);
					GUI::Controls::Checkbox(XorStr("Penetration crosshair"), &g_Vars.esp.autowall_crosshair);
					GUI::Controls::Checkbox(XorStr("Force crosshair"), &g_Vars.esp.force_sniper_crosshair);

					GUI::Controls::Checkbox(XorStr("Client bullet impacts"), &g_Vars.misc.impacts_spoof);
					GUI::Controls::ColorPicker(XorStr("Client bullet impacts color"), &g_Vars.esp.client_impacts);

					GUI::Controls::Checkbox(XorStr("Server bullet impacts"), &g_Vars.misc.server_impacts_spoof);
					GUI::Controls::ColorPicker(XorStr("Server bullet impacts color"), &g_Vars.esp.server_impacts);

					GUI::Controls::Checkbox(XorStr("Bomb"), &g_Vars.esp.draw_c4_bar);
					GUI::Controls::ColorPicker(XorStr("Bomb color"), &g_Vars.esp.c4_color);

					std::vector<MultiItem_t> wwweaponnnnn_n = {
						{ XorStr("Text"), &g_Vars.esp.dropped_weapons },
						{ XorStr("Ammo"), &g_Vars.esp.dropped_weapons_ammo },
					};

					GUI::Controls::MultiDropdown(XorStr("Dropped weapons"), wwweaponnnnn_n);
					GUI::Controls::ColorPicker(XorStr("Dropped weapons color"), &g_Vars.esp.dropped_weapons_color);

					GUI::Controls::Checkbox(XorStr("Grenades"), &g_Vars.esp.nades);

					if (GUI::Controls::Checkbox(XorStr("Grenade prediction"), &g_Vars.esp.NadePred) || GUI::ctx->setup) {
						GUI::Controls::ColorPicker(XorStr("Grenade prediction color"), &g_Vars.esp.nade_pred_color);
					}

					GUI::Controls::Slider(XorStr("Override FOV"), &g_Vars.esp.world_fov, 0.f, 200.f, XorStr("%.0f degress"));
					GUI::Controls::Slider(XorStr("Override Viewmodel FOV "), &g_Vars.misc.viewmodel_fov, 0.f, 200.f, XorStr("%.0f degress"));

					if (GUI::Controls::Checkbox(XorStr("Aspect ratio"), &g_Vars.esp.aspect_ratio) || GUI::ctx->setup) {
						GUI::Controls::Slider(XorStr("Aspect ratio value"), &g_Vars.esp.aspect_ratio_value, 0.02f, 5.f, XorStr("%.2f"), 0.01f);
					}

					GUI::Group::EndGroup();
				}

				GUI::Group::BeginGroup(XorStr("Effects"), Vector2D(50, 50));
				{
					std::vector<MultiItem_t> world_adj = {
						{ XorStr("Nightmode"), &g_Vars.esp.night_mode },
						{ XorStr("Fullbright"), &g_Vars.esp.fullbright },
						{ XorStr("Skybox color"), &g_Vars.esp.skybox },
					};

					GUI::Controls::MultiDropdown(XorStr("World adjustment"), world_adj);
					if (g_Vars.esp.night_mode || GUI::ctx->setup) {
						GUI::Controls::Slider(XorStr("World brightness"), &g_Vars.esp.world_adjustement_value, 1.f, 100.0f, XorStr("%.0f%%"));
						GUI::Controls::Slider(XorStr("Prop brightness"), &g_Vars.esp.prop_adjustement_value, 1.f, 100.0f, XorStr("%.0f%%"));
						GUI::Controls::Slider(XorStr("Prop transparency"), &g_Vars.esp.transparent_props, 0.f, 100.0f, XorStr("%.0f%%"));
					}

					GUI::Controls::Dropdown(XorStr("Skybox changer"), {
						XorStr("Default"),
						XorStr("cs_baggage_skybox_"),
						XorStr("cs_tibet"),
						XorStr("embassy"),
						XorStr("italy"),
						XorStr("jungle"),
						XorStr("nukeblank"),
						XorStr("office"),
						XorStr("sky_csgo_cloudy01"),
						XorStr("sky_csgo_night02"),
						XorStr("sky_csgo_night02b"),
						XorStr("sky_dust"),
						XorStr("sky_venice"),
						XorStr("vertigo"),
						XorStr("vietnam"),
						XorStr("sky_descent")
						}, &g_Vars.esp.sky_changer);

					if (g_Vars.esp.skybox || GUI::ctx->setup)
						GUI::Controls::ColorPicker(XorStr("Skybox color#color"), &g_Vars.esp.skybox_modulation);

					std::vector<MultiItem_t> removals = {
						{ XorStr("Smoke effects"), &g_Vars.esp.remove_smoke },
						{ XorStr("Flashbang effects"), &g_Vars.esp.remove_flash },
						{ XorStr("Scope effects"), &g_Vars.esp.remove_scope },
						{ XorStr("Scope zoom"), &g_Vars.esp.remove_scope_zoom },
						{ XorStr("Scope blur"), &g_Vars.esp.remove_scope_blur },
						{ XorStr("Recoil shake"), &g_Vars.esp.remove_recoil_shake },
						{ XorStr("Recoil punch"), &g_Vars.esp.remove_recoil_punch },
						{ XorStr("View bob"), &g_Vars.esp.remove_bob },
					};

					GUI::Controls::MultiDropdown(XorStr("Removals"), removals);

					if (g_Vars.esp.remove_scope || GUI::ctx->setup) {
						GUI::Controls::Dropdown(XorStr("Scope effect type"), { XorStr("Static") }, &g_Vars.esp.remove_scope_type);
					}

					GUI::Controls::Checkbox(XorStr("Thirdperson"), &g_Vars.misc.third_person);
					GUI::Controls::Hotkey(XorStr("Thirdperson key"), &g_Vars.misc.third_person_bind);
					if (g_Vars.misc.third_person || GUI::ctx->setup) {
						GUI::Controls::Checkbox(XorStr("Disable on grenade"), &g_Vars.misc.third_person_on_grenade);
						GUI::Controls::Slider(XorStr("Distance"), &g_Vars.misc.third_person_dist, 0, 250, XorStr("%.0f"));
					}

					if (GUI::Controls::Checkbox(XorStr("Bullet tracers"), &g_Vars.esp.beam_enabled) || GUI::ctx->setup) {
						GUI::Controls::Dropdown(XorStr("Bullet tracers type"), { XorStr("Line"), XorStr("Beam") }, &g_Vars.esp.beam_type);
					}

					GUI::Controls::Checkbox(XorStr("Ambient lightning"), &g_Vars.esp.ambient_ligtning);
					GUI::Controls::ColorPicker(XorStr("Ambient lightning color"), &g_Vars.esp.ambient_ligtning_color);


					GUI::Controls::Checkbox(XorStr("Skip occlusion"), &g_Vars.esp.skip_occulusion);
					GUI::Controls::Checkbox(XorStr("Remove sleeve rendering"), &g_Vars.esp.remove_sleeves);

					GUI::Group::EndGroup();
				}

			}

			static bool on_cfg_load_gloves, on_cfg_load_knives;
			if (GUI::Form::BeginTab(4, XorStr("D")) || GUI::ctx->setup) {
				GUI::Group::BeginGroup(XorStr("General"), Vector2D(50, 50));
				{
					GUI::Controls::Checkbox(XorStr("Auto jump"), &g_Vars.misc.autojump);
					GUI::Controls::Checkbox(XorStr("Auto strafe"), &g_Vars.misc.autostrafer);

					GUI::Controls::Checkbox(XorStr("Auto peek"), &g_Vars.misc.autopeek);
					if (g_Vars.misc.autopeek || GUI::ctx->setup) {
						GUI::Controls::Hotkey(XorStr("Auto peek key##key"), &g_Vars.misc.autopeek_bind);
						GUI::Controls::Checkbox(XorStr("Auto peek visualise"), &g_Vars.misc.autopeek_visualise);
						GUI::Controls::ColorPicker(XorStr("Auto peek color ##Auto"), &g_Vars.misc.autopeek_color);
					}

					GUI::Controls::Checkbox(XorStr("Instant stop in air"), &g_Vars.misc.instant_stop);
					//GUI::Controls::Hotkey( XorStr( "Instant stop in air key" ), &g_Vars.misc.instant_stop_key );

					GUI::Controls::Checkbox(XorStr("Directional strafe"), &g_Vars.misc.autostrafer_wasd);
					GUI::Controls::Checkbox(XorStr("Edge jump"), &g_Vars.misc.edgejump);
					GUI::Controls::Hotkey(XorStr("Edge jump key"), &g_Vars.misc.edgejump_bind);
					GUI::Controls::Checkbox(XorStr("Money revealer"), &g_Vars.misc.money_revealer);
					GUI::Controls::Checkbox(XorStr("Unlock inventory"), &g_Vars.misc.unlock_inventory);
					GUI::Controls::Checkbox(XorStr("Auto accept"), &g_Vars.misc.auto_accept);
					GUI::Controls::Checkbox(XorStr("Fast stop"), &g_Vars.misc.quickstop);
					GUI::Controls::Checkbox(XorStr("Accurate walk"), &g_Vars.misc.accurate_walk);
					GUI::Controls::Checkbox(XorStr("Slide walk"), &g_Vars.misc.slide_walk);
					GUI::Controls::Checkbox(XorStr("Infinite stamina"), &g_Vars.misc.fastduck);

					std::vector<std::string> first_weapon_str = {
						XorStr("None"),
						XorStr("SCAR-20 / G3SG1"),
						XorStr("SSG-08"),
						XorStr("AWP"),
					};

					std::vector<std::string> second_weapon_str = {
						XorStr("None"),
						XorStr("Dualies"),
						XorStr("Desert Eagle / R8 Revolver"),
					};

					std::vector<MultiItem_t> other_weapon_conditions = {
						{ XorStr("Armor"), &g_Vars.misc.autobuy_armor },
						{ XorStr("Flashbang"), &g_Vars.misc.autobuy_flashbang },
						{ XorStr("HE Grenade"), &g_Vars.misc.autobuy_hegrenade },
						{ XorStr("Molotov"), &g_Vars.misc.autobuy_molotovgrenade },
						{ XorStr("Smoke"), &g_Vars.misc.autobuy_smokegreanade },
						{ XorStr("Decoy"), &g_Vars.misc.autobuy_decoy },
						{ XorStr("Taser"), &g_Vars.misc.autobuy_zeus },
						{ XorStr("Defuse kit"), &g_Vars.misc.autobuy_defusekit },
					};

					GUI::Controls::Checkbox(XorStr("Buy bot"), &g_Vars.misc.autobuy_enabled);
					if (g_Vars.misc.autobuy_enabled || GUI::ctx->setup) {
						GUI::Controls::Dropdown(XorStr("Primary weapon"), first_weapon_str, &g_Vars.misc.autobuy_first_weapon);
						GUI::Controls::Dropdown(XorStr("Secondary Weapon"), second_weapon_str, &g_Vars.misc.autobuy_second_weapon);
						GUI::Controls::MultiDropdown(XorStr("Utility"), other_weapon_conditions);
					}

					g_Vars.misc.chat_spammer = false;

					GUI::Group::EndGroup();
				}

				GUI::Group::BeginGroup(XorStr("Cheat settings"), Vector2D(50, 50));
				{
					GUI::Controls::Checkbox(XorStr("Watermark"), &g_Vars.misc.watermark);
					GUI::Controls::Label(XorStr("Menu key"));
					GUI::Controls::Hotkey(XorStr("Menu key#MenuKey"), &g_Vars.menu.key, false);

					GUI::Controls::Label(XorStr("Menu accent color"));
					GUI::Controls::ColorPicker(XorStr("Menu accent color#MenuColor"), &g_Vars.menu.ascent);

					GUI::Controls::Checkbox(XorStr("Override log color"), &g_Vars.misc.print_color);

					if (g_Vars.misc.print_color)
						GUI::Controls::ColorPicker(XorStr("Log accent color#LogColor"), &g_Vars.misc.log_color);

					GUI::Controls::Checkbox(XorStr("Show ping in shot logs"), &g_Vars.misc.log_ping);

					std::vector<MultiItem_t> m_indicators = {
					{ XorStr("Exploits"), &g_Vars.esp.indicator_exploits },
					{ XorStr("Damage override"), &g_Vars.esp.indicator_dmg },
					{ XorStr("Prefer baim"), &g_Vars.esp.indicator_baim },
					{ XorStr("LBY"), &g_Vars.esp.indicator_lby },
					{ XorStr("LC"), &g_Vars.esp.indicator_breaklc },
					};

					GUI::Controls::MultiDropdown(XorStr("Indicators"), m_indicators);

					GUI::Controls::Checkbox(XorStr("Clan-tag"), &g_Vars.misc.clantag_changer);

					std::vector<MultiItem_t> notifications = {
						{ XorStr("Bomb"), &g_Vars.esp.event_bomb },
					{ XorStr("Damage dealt"), &g_Vars.esp.event_dmg },
					{ XorStr("Damage taken"), &g_Vars.esp.event_harm },
					{ XorStr("Purchases"), &g_Vars.esp.event_buy },
					{ XorStr("Misses"), &g_Vars.esp.event_resolver },
					};
					GUI::Controls::MultiDropdown(XorStr("Notifications"), notifications);

					GUI::Group::EndGroup();
				}

				GUI::Group::BeginGroup(XorStr("Configs"), Vector2D(50, 100));
				{
					static int selected_cfg;
					static std::vector<std::string> cfg_list;
					static bool initialise_configs = true;
					bool reinit = false;
					if (initialise_configs || (GetTickCount() % 1000) == 0) {
						cfg_list = ConfigManager::GetConfigs();
						initialise_configs = false;
						reinit = true;
					}

					static std::string config_name;
					GUI::Controls::Textbox(XorStr("Config name"), &config_name, 26);
					GUI::Controls::Listbox(XorStr("Config selection"),
						(cfg_list.empty() ? std::vector<std::string>{XorStr("No configs")} : cfg_list), &selected_cfg, false, 6);

					if (reinit) {
						if (selected_cfg >= cfg_list.size())
							selected_cfg = cfg_list.size() - 1;

						if (selected_cfg < 0)
							selected_cfg = 0;
					}

					if (!cfg_list.empty()) {
						static bool confirm_save = false;
						GUI::Controls::Button(!confirm_save ? XorStr("Save config#save") : XorStr("Are you sure?#save"), [&]() {
							if (selected_cfg <= cfg_list.size() && selected_cfg >= 0) {
								if (!confirm_save) {
									confirm_save = true;
									return;
								}

								if (confirm_save) {
									ConfigManager::SaveConfig(cfg_list.at(selected_cfg));

									confirm_save = false;

									GUI::ctx->SliderInfo.LastChangeTime.clear();
									GUI::ctx->SliderInfo.PreviewAnimation.clear();
									GUI::ctx->SliderInfo.PreviousAmount.clear();
									GUI::ctx->SliderInfo.ShouldChangeValue.clear();
									GUI::ctx->SliderInfo.ValueTimer.clear();
									GUI::ctx->SliderInfo.ValueAnimation.clear();
								}
							}
							}, true);

						GUI::Controls::Button(XorStr("Load config"), [&]() {
							if (selected_cfg <= cfg_list.size() && selected_cfg >= 0) {
								ConfigManager::ResetConfig();

								ConfigManager::LoadConfig(cfg_list.at(selected_cfg));
								g_Vars.m_global_skin_changer.m_update_skins = true;
								g_Vars.m_global_skin_changer.m_update_gloves = true;

								GUI::ctx->SliderInfo.LastChangeTime.clear();
								GUI::ctx->SliderInfo.PreviewAnimation.clear();
								GUI::ctx->SliderInfo.PreviousAmount.clear();
								GUI::ctx->SliderInfo.ShouldChangeValue.clear();
								GUI::ctx->SliderInfo.ValueTimer.clear();
								GUI::ctx->SliderInfo.ValueAnimation.clear();

								on_cfg_load_knives = on_cfg_load_gloves = true;

								//g_Vars.menu.ascent = FloatColor( 0.51764705882, 0.45882352941, 0.90196078431, 1.0f );

								/*g_Vars.globals.m_hitsounds.clear( );

								std::string dir = GetDocumentsDirectory( ).append( XorStr( "\\json\\" ) );
								for( auto& file_path : std::filesystem::directory_iterator( dir ) ) {
									if( !file_path.path( ).string( ).empty( ) ) {
										if( file_path.path( ).string( ).find( ".wav" ) != std::string::npos ) {
											g_Vars.globals.m_hitsounds.emplace_back( file_path.path( ).string( ).erase( 0, dir.length( ) ) );
										}
									}
								}*/
							}
							});

						static bool confirm_delete = false;
						GUI::Controls::Button(!confirm_delete ? XorStr("Delete config#delete") : XorStr("Are you sure?#delete"), [&]() {
							if (selected_cfg <= cfg_list.size() && selected_cfg >= 0) {
								if (!confirm_delete) {
									confirm_delete = true;
									return;
								}

								if (confirm_delete) {
									ConfigManager::RemoveConfig(cfg_list.at(selected_cfg));
									cfg_list = ConfigManager::GetConfigs();
									confirm_delete = false;
								}
							}
							}, true);
					}

					GUI::Controls::Button(XorStr("Create config"), [&]() {
						if (config_name.empty())
							return;

						ConfigManager::CreateConfig(config_name);
						cfg_list = ConfigManager::GetConfigs();
						});

					GUI::Controls::Button(XorStr("Open config directory"), [&]() {
						ConfigManager::OpenConfigFolder();
						});

					GUI::Controls::Button(XorStr("Reset config"), [&]() {
						ConfigManager::ResetConfig();
						});

					GUI::Group::EndGroup();
				}
			}
			/*
			if (GUI::Form::BeginTab(5, XorStr("E"))) {
				static int weapon_id;
				GUI::Group::BeginGroup(XorStr("General"), Vector2D(50, 100)); {
					GUI::Controls::Checkbox(XorStr("Enabled##Skins"), &g_Vars.m_global_skin_changer.m_active);

					static std::vector<std::string> weapons;
					for (int i = 0; i < weapon_skins.size(); ++i) {
						auto whatevertheFUCK = weapon_skins[i];
						std::string ha{ whatevertheFUCK.display_name };

						// get rid of weapon_
						if (ha[0] == 'w' && ha[1] == 'e' && ha[6] == '_')
							ha.erase(0, 7);

						// get rid of knife_				
						if (ha[0] == 'k' && ha[1] == 'n' && ha[5] == '_')
							ha.erase(0, 6);

						weapons.push_back(ha.data());
					}
					if (!weapons.empty()) {
						GUI::Controls::Listbox(XorStr("Weapon skin"), weapons, &weapon_id, true, 13);
					}

					weapons.clear();

					if (GUI::Controls::Checkbox(XorStr("Override knife model##knife"), &g_Vars.m_global_skin_changer.m_knife_changer)) {
						if (k_knife_names.at(g_Vars.m_global_skin_changer.m_knife_vector_idx).definition_index != g_Vars.m_global_skin_changer.m_knife_idx) {
							auto it = std::find_if(k_knife_names.begin(), k_knife_names.end(), [&](const WeaponName_t& a) {
								return a.definition_index == g_Vars.m_global_skin_changer.m_knife_idx;
								});

							if (on_cfg_load_knives) {
								if (it != k_knife_names.end())
									g_Vars.m_global_skin_changer.m_knife_vector_idx = std::distance(k_knife_names.begin(), it);

								on_cfg_load_knives = false;
							}
						}

						std::vector<std::string> knifes;
						static bool init_knife_names = false;
						for (int i = 0; i < k_knife_names.size(); ++i) {
							auto whatevertheFUCK = k_knife_names[i];
							knifes.push_back(whatevertheFUCK.name);
						}

						if (!knifes.empty()) {
							GUI::Controls::Dropdown(XorStr("Knife models"), knifes, &g_Vars.m_global_skin_changer.m_knife_vector_idx);
							g_Vars.m_global_skin_changer.m_knife_idx = k_knife_names[g_Vars.m_global_skin_changer.m_knife_vector_idx].definition_index;
						}

						knifes.clear();
					}

					if (GUI::Controls::Checkbox(XorStr("Override glove model##glove"), &g_Vars.m_global_skin_changer.m_glove_changer)) {

						if (k_glove_names.at(g_Vars.m_global_skin_changer.m_gloves_vector_idx).definition_index != g_Vars.m_global_skin_changer.m_gloves_idx) {
							auto it = std::find_if(k_glove_names.begin(), k_glove_names.end(), [&](const WeaponName_t& a) {
								return a.definition_index == g_Vars.m_global_skin_changer.m_gloves_idx;
								});

							if (on_cfg_load_gloves) {
								if (it != k_glove_names.end())
									g_Vars.m_global_skin_changer.m_gloves_vector_idx = std::distance(k_glove_names.begin(), it);
								on_cfg_load_gloves = false;
							}
						}

						static std::vector<std::string> gloves;
						for (int i = 0; i < k_glove_names.size(); ++i) {
							auto whatevertheFUCK = k_glove_names[i];
							gloves.push_back(whatevertheFUCK.name);
						}

						static int bruh = g_Vars.m_global_skin_changer.m_gloves_vector_idx;
						if (!gloves.empty()) {
							GUI::Controls::Dropdown(XorStr("Glove model"), gloves, &g_Vars.m_global_skin_changer.m_gloves_vector_idx);
							g_Vars.m_global_skin_changer.m_gloves_idx = k_glove_names[g_Vars.m_global_skin_changer.m_gloves_vector_idx].definition_index;
						}

						if (bruh != g_Vars.m_global_skin_changer.m_gloves_vector_idx) {
							g_Vars.m_global_skin_changer.m_update_skins = true;
							g_Vars.m_global_skin_changer.m_update_gloves = true;

							bruh = g_Vars.m_global_skin_changer.m_gloves_vector_idx;
						}

						gloves.clear();
					}

					GUI::Group::EndGroup();
				}

				GUI::Group::BeginGroup(XorStr("Weapon options"), Vector2D(50, 100)); {
					auto& current_weapon = weapon_skins[weapon_id];
					auto idx = current_weapon.id;

					auto& skin_data = g_Vars.m_skin_changer;
					CVariables::skin_changer_data* skin = nullptr;
					for (size_t i = 0u; i < skin_data.Size(); ++i) {
						skin = skin_data[i];
						if (skin->m_definition_index == idx) {
							break;
						}
					}

					if (skin) {
						GUI::Controls::Checkbox(XorStr("Filter paint kits"), &skin->m_filter_paint_kits);

						if (skin->m_filter_paint_kits) {
							auto& kit = current_weapon.m_kits[skin->m_paint_kit_index];
							if (kit.id != skin->m_paint_kit) {
								auto it = std::find_if(current_weapon.m_kits.begin(), current_weapon.m_kits.end(), [skin](paint_kit& a) {
									return a.id == skin->m_paint_kit;
									});

								if (it != current_weapon.m_kits.end())
									skin->m_paint_kit_index = std::distance(current_weapon.m_kits.begin(), it);
							}
						}

						static int bruh1 = skin->m_paint_kit_index;
						static int bruh2 = skin->m_paint_kit_no_filter;

						if (skin->m_filter_paint_kits) {
							static std::vector<std::string> paint_kits;

							for (int i = 0; i < current_weapon.m_kits.size(); ++i) {
								auto whatevertheFUCK = current_weapon.m_kits[i];
								paint_kits.push_back(whatevertheFUCK.name.data());
							}

							if (!paint_kits.empty()) {
								GUI::Controls::Listbox(XorStr("Paint kits"), paint_kits, &skin->m_paint_kit_index, true, 13);
							}

							paint_kits.clear();
						}
						else {
							if (!g_Vars.globals.m_vecPaintKits.empty()) {
								GUI::Controls::Listbox(XorStr("Paint kits"), g_Vars.globals.m_vecPaintKits, &skin->m_paint_kit_no_filter, true, 13);
							}
						}

						if ((bruh1 != skin->m_paint_kit_index) || (bruh2 != skin->m_paint_kit_no_filter)) {
							g_Vars.m_global_skin_changer.m_update_skins = true;
							if (current_weapon.glove)
								g_Vars.m_global_skin_changer.m_update_gloves = true;

							bruh1 = skin->m_paint_kit_index;
							bruh2 = skin->m_paint_kit_no_filter;
						}

						skin->m_paint_kit = skin->m_filter_paint_kits ? current_weapon.m_kits[skin->m_paint_kit_index].id : skin->m_paint_kit_no_filter;

						skin->m_enabled = true;

						GUI::Controls::Slider(XorStr("Wear"), &skin->m_wear, 0.00000001f, 1.00f, XorStr("%.5f%%"));
						GUI::Controls::Slider(XorStr("Seed"), &skin->m_seed, 1, 1000, XorStr("%.0f"));
					}

					GUI::Group::EndGroup();
				}
			}*/

			GUI::Form::EndWindow();
		}
	}
	void Draw() {
		DrawMenu();
	}
}

```

`CSGO SDK/Menu/Elements.h`:

```h
#pragma once

namespace Menu {
	void Draw();
}
```

`CSGO SDK/Menu/Framework/Button/Button.cpp`:

```cpp
#include "../gui.h"
#include <algorithm>
#include "../../../source.hpp"

void GUI::Controls::Button(const std::string& name, std::function< void() > callback, bool use_unique_id) {
	Vector2D CursorPos = PopCursorPos();
	Vector2D DrawPos = ctx->pos + CursorPos;
	Vector2D DrawSize = Vector2D(std::min((int)ctx->ParentSize.x - 90, 270), 24);

	DrawPos.x += 20;

	bool hovered = InputSys::Get()->IsInBox(DrawPos, DrawSize) && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize);

	if (ctx->FocusedID == GUI::Hash(name)) {
		Render::DirectX::gradient_v(DrawPos, DrawSize, { 30, 30, 30 }, { 20, 20, 20 });
	}
	else {
		if (hovered)
			Render::DirectX::gradient_v(DrawPos, DrawSize, { 45, 45, 45 }, { 35, 35, 35 });
		else
			Render::DirectX::gradient_v(DrawPos, DrawSize, { 35, 35, 35 }, { 25, 25, 25 });
	}

	Render::DirectX::rect(DrawPos, DrawSize, { 10, 10, 10 });
	Render::DirectX::rect(DrawPos + 1, DrawSize - 2, { 50, 50, 50 });

	Vector2D text_size = Render::DirectX::Fonts::menu_bold.measure_size(GUI::SplitStr(name, '#')[0].data());
	Render::DirectX::Fonts::menu_bold.draw_text(GUI::SplitStr(name, '#')[0].data(), DrawPos + ((DrawSize / 2) - (text_size / 2)), { 220, 220, 220 }, 4);

	if (ctx->FocusedID == 0) {
		if (hovered && InputHelper::Pressed(VK_LBUTTON)) {
			ctx->FocusedID = GUI::Hash(name);
		}
	}
	else if (ctx->FocusedID == GUI::Hash(name)) {
		if (!InputHelper::Down(VK_LBUTTON)) {
			ctx->FocusedID = 0;

			if (hovered) {
				callback();
			}
		}
	}

	GUI::PushCursorPos(CursorPos + Vector2D(0, DrawSize.y + GUI::ObjectPadding()));
}

```

`CSGO SDK/Menu/Framework/Button/Button.h`:

```h
#pragma once
#include <functional>

namespace GUI::Controls {
	void Button(const std::string& name, std::function< void() > callback, bool use_unique_id = false);
}

```

`CSGO SDK/Menu/Framework/Checkbox/Checkbox.cpp`:

```cpp
#include "../gui.h"
#include "../../../source.hpp"

std::unordered_map<size_t, float> uAnimation;

bool GUI::Controls::Checkbox(const std::string& name, bool* value, bool unsafe) {
	Vector2D CursorPos = PopCursorPos();
	Vector2D DrawPos = ctx->pos + CursorPos;
	Vector2D DrawSize = Vector2D(8, 8);

	Render::DirectX::rect(DrawPos, DrawSize - 1, Color(10, 10, 10));

	Render::DirectX::Fonts::menu.draw_text(GUI::SplitStr(name, '#')[0].data(), DrawPos + Vector2D(20, -3), unsafe ? Color(180, 180, 100) : Color(200, 200, 200), 0);

	bool hovered = InputSys::Get()->IsInBox(DrawPos, DrawSize - 1) && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize);
	bool hovered_text = InputSys::Get()->IsInBox(DrawPos + Vector2D(0, -3), Render::DirectX::Fonts::menu.measure_size(GUI::SplitStr(name, '#')[0].data()) + Vector2D(20, 0)) && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize);

	if (!(*value)) {
		if (hovered || hovered_text)
			Render::DirectX::gradient_v(DrawPos + 1, DrawSize - 2, Color(83, 83, 83), Color(58, 58, 58));
		else
			Render::DirectX::gradient_v(DrawPos + 1, DrawSize - 2, Color(75, 75, 75), Color(51, 51, 51));
	}
	else {
		Render::DirectX::gradient_v(DrawPos + 1, DrawSize - 2, g_Vars.menu.ascent.ToRegularColor(), g_Vars.menu.ascent.ToRegularColor() * 0.75f);
	}

	if (ctx->FocusedID == 0) {
		if ((hovered || hovered_text) && InputHelper::Pressed(VK_LBUTTON))
			ctx->FocusedID = GUI::Hash(name);
	}
	else if (ctx->FocusedID == GUI::Hash(name)) {
		if (!InputHelper::Down(VK_LBUTTON)) {
			ctx->FocusedID = 0;

			if ((hovered || hovered_text))
				*value ^= 1;
		}
	}

	GUI::PushCursorPos(CursorPos + Vector2D(0, DrawSize.y + GUI::ObjectPadding()));
	return *value || ctx->setup;
}

```

`CSGO SDK/Menu/Framework/Checkbox/Checkbox.h`:

```h
#pragma once

namespace GUI::Controls {
	bool Checkbox(const std::string& name, bool* value, bool unsafe = false);
}

```

`CSGO SDK/Menu/Framework/ColorPicker/ColorPicker.cpp`:

```cpp
#include "../gui.h"
#include "../../../source.hpp"

#include "../../../Features/Visuals/EventLogger.hpp"

void GUI::Controls::ColorPicker(const std::string& name, FloatColor* var_name) {
	Vector2D CursorPos = GetLastCursorPos();
	Vector2D DrawPos = ctx->pos + CursorPos;

	DrawPos.x += ctx->ParentSize.x - 63;

	Render::DirectX::rect(DrawPos, Vector2D(16, 8), Color(10, 10, 10));

	Render::DirectX::gradient_v(DrawPos + 1, Vector2D(16, 8) - 1, var_name->ToRegularColor().OverrideAlpha(255), var_name->ToRegularColor().OverrideAlpha(255) * 0.9f);

	bool hovered = InputSys::Get()->IsInBox(DrawPos, Vector2D(16, 8)) && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize);

	if (ctx->FocusedID == 0) {
		if (hovered) {
			if (InputHelper::Pressed(VK_LBUTTON))
				ctx->FocusedID = GUI::Hash(name);
			else if (InputHelper::Pressed(VK_RBUTTON))
				ctx->FocusedID = GUI::Hash(name) + 69;
		}
	}
	else if (ctx->FocusedID == GUI::Hash(name)) {
		if (hovered) {
			ctx->ColorPickerInfo.ActionCringe = 0;
			ctx->ColorPickerInfo.HashedID = GUI::Hash(name);
			ctx->ColorPickerInfo.Pos = DrawPos + Vector2D(-1, 14);
			ctx->ColorPickerInfo.Size = 180;
			ctx->ColorPickerInfo.Value = var_name;
		}
	}
	else if (ctx->FocusedID == GUI::Hash(name) + 69) {
		if (hovered) {
			ctx->ColorPickerInfo.ActionCringe = 1;
			ctx->ColorPickerInfo.HashedID = GUI::Hash(name) + 69;
			ctx->ColorPickerInfo.Pos = DrawPos + Vector2D(-1, 14);
			ctx->ColorPickerInfo.Size = 100;
			ctx->ColorPickerInfo.Value = var_name;
		}
	}
}
```

`CSGO SDK/Menu/Framework/ColorPicker/ColorPicker.h`:

```h
#pragma once

namespace GUI::Controls {
	void ColorPicker(const std::string& id, FloatColor* value);
}

```

`CSGO SDK/Menu/Framework/Dropdown/Dropdown.cpp`:

```cpp
#include "../gui.h"
#include <algorithm>
#include "../../../source.hpp"

void line(Vector2D pos, bool nigger = false) {
	for (auto i = 5; i >= 2; --i) {
		auto offset = 5 - i;
		Render::DirectX::line(Vector2D(pos.x + offset, pos.y + offset), Vector2D(pos.x + offset + std::clamp(i - offset, 0, 5), pos.y + offset), nigger ? Color(0, 0, 0) : Color(151, 151, 151));
	}
}

bool GUI::Controls::Dropdown(const std::string& name, std::vector< std::string > options, int* var_name, int max_items) {
	Vector2D CursorPos = PopCursorPos();
	Vector2D DrawPos = ctx->pos + CursorPos;
	Vector2D DrawSize = Vector2D(std::min((int)ctx->ParentSize.x - 90, 270), 19);

	if (*var_name < 0)
		*var_name = 0;
	else if (*var_name >= options.size())
		*var_name = options.size() - 1;

	DrawPos.x += 20;

	if (!GUI::SplitStr(name, '#')[0].empty()) {
		Render::DirectX::Fonts::menu.draw_text(GUI::SplitStr(name, '#')[0].data(), DrawPos + Vector2D(0, -3), Color(203, 203, 203), 4);

		DrawPos.y += 11;
	}

	bool hovered = InputSys::Get()->IsInBox(DrawPos, DrawSize) && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize);

	if (hovered || ctx->DropdownInfo.HashedID == GUI::Hash(name))
		Render::DirectX::gradient_v(DrawPos, DrawSize, { 41, 41, 41 }, { 46, 46, 46 });
	else
		Render::DirectX::gradient_v(DrawPos, DrawSize, { 31, 31, 31 }, { 36, 36, 36 });

	line(DrawPos + DrawSize - Vector2D(9, 6) - Vector2D(0, 6), true);
	line(DrawPos + DrawSize - Vector2D(9, 6) + Vector2D(0, 1) - Vector2D(0, 6));

	Render::DirectX::rect(DrawPos, DrawSize, { 10, 10, 10 });
	Render::DirectX::Fonts::menu.draw_text(options[*var_name], DrawPos + Vector2D(10, 4), { 150, 150, 150 }, 0);

	if (ctx->FocusedID == 0) {
		if (hovered && InputHelper::Pressed(VK_LBUTTON))
			ctx->FocusedID = GUI::Hash(name);
	}
	else if (ctx->FocusedID == GUI::Hash(name)) {
		if (hovered) {
			ctx->DropdownInfo.Elements = options;
			ctx->DropdownInfo.Size = DrawSize.x;
			ctx->DropdownInfo.Option = var_name;
			ctx->DropdownInfo.Pos = DrawPos + Vector2D(0, DrawSize.y + 3);
			ctx->DropdownInfo.HashedID = GUI::Hash(name);
		}
	}

	GUI::PushCursorPos(CursorPos + Vector2D(0, DrawSize.y + GUI::ObjectPadding() + (GUI::SplitStr(name, '#')[0].empty() ? 0 : 12)));
	return 69 + GUI::Hash(XorStr("fuck you"));
}

```

`CSGO SDK/Menu/Framework/Dropdown/Dropdown.h`:

```h
#pragma once

namespace GUI::Controls {
	bool Dropdown(const std::string& name, std::vector< std::string > values, int* var_name, int max_items = 10);
}

```

`CSGO SDK/Menu/Framework/Form/Form.cpp`:

```cpp
#include "../gui.h"
#include "../../../source.hpp"
#include <iomanip>

#pragma warning(disable : 4018)

bool TitleBarHovered;
std::string FormName;

void retard() {
	if (GUI::ctx->FocusedID != 0)
		GUI::ctx->FocusedID = 0;

	if (GUI::ctx->DropdownInfo.HashedID != 0)
		GUI::ctx->DropdownInfo.HashedID = 0;

	if (GUI::ctx->ColorPickerInfo.HashedID != 0)
		GUI::ctx->ColorPickerInfo.HashedID = 0;

	if (GUI::ctx->MultiDropdownInfo.HashedID != 0)
		GUI::ctx->MultiDropdownInfo.HashedID = 0;

	if (GUI::ctx->dragging)
		GUI::ctx->dragging = false;

	if (GUI::ctx->typing)
		GUI::ctx->typing = false;
}

bool GUI::Form::BeginWindow(std::string name) {

	static bool bReset = true;
	if (ctx->animation <= 0.0f) {
		if (bReset) {
			retard();
			bReset = false;
		}

		return false;
	}

	bReset = true;

	if (ctx->FocusedID == 0)
		ctx->typing = false;

	TitleBarHovered = InputSys::Get()->IsInBox(ctx->pos, Vector2D(ctx->size.x, 25));
	bool bResizeHovered = InputSys::Get()->IsInBox((ctx->pos + Vector2D(0, 20)) + ctx->size - 15, Vector2D(15, 15));

	if (ctx->FocusedID == 0) {
		static Vector2D prev_mouse_pos;
		static Vector2D mouse_delta;

		mouse_delta = prev_mouse_pos - InputSys::Get()->GetMousePosition();

		if (!g_Vars.globals.m_bDraggingKeyBind && !g_Vars.globals.m_bDraggingSpecList && !ctx->dragging_scrollbar) {
			if (!ctx->dragging && InputSys::Get()->IsKeyDown(VK_LBUTTON) && TitleBarHovered)
				ctx->dragging = true;
			else if (ctx->dragging && InputSys::Get()->IsKeyDown(VK_LBUTTON))
				ctx->pos -= mouse_delta;
			else if (ctx->dragging && !InputSys::Get()->IsKeyDown(VK_LBUTTON))
				ctx->dragging = false;

			if (!ctx->resizing && InputSys::Get()->IsKeyDown(VK_LBUTTON) && bResizeHovered)
				ctx->resizing = true;
			else if (ctx->resizing && InputSys::Get()->IsKeyDown(VK_LBUTTON)) {
				bool check1 = false;
				bool check2 = false;

				if ((ctx->size.x - mouse_delta.x) > 648) {
					ctx->size.x -= mouse_delta.x;
				}
				else { check1 = true; }

				if ((ctx->size.y - mouse_delta.y) > 548) {
					ctx->size.y -= mouse_delta.y;
				}
				else { check2 = true; }

				if (check1 && check2) {
					if (!bResizeHovered)
						ctx->resizing = false;
				}
			}
			else if (ctx->resizing && !InputSys::Get()->IsKeyDown(VK_LBUTTON))
				ctx->resizing = false;
		}
		else {
			if (!g_Vars.esp.keybind_window_enabled) {
				g_Vars.globals.m_bDraggingKeyBind = false;
			}

			if (!g_Vars.esp.spectator_list) {
				g_Vars.globals.m_bDraggingSpecList = false;
			}
		}

		prev_mouse_pos = InputSys::Get()->GetMousePosition();
	}

	// let's grab screensize, this is not calling a game func so this should never cause issues.
	const auto screen = Render::GetScreenSize();

	// let's clamp
	ctx->size.x = std::clamp<int>(ctx->size.x, 648, screen.x);
	ctx->size.y = std::clamp<int>(ctx->size.y, 538, screen.y);

	ctx->pos.x = std::clamp<int>(ctx->pos.x, 0, screen.x - ctx->size.x);
	ctx->pos.y = std::clamp<int>(ctx->pos.y, 0, screen.y - ctx->size.y);

	// swap cursor pos stack
	std::stack< Vector2D >().swap(ctx->CursorPosStack);

	// start menu alpha animation
	alpha_mod = ctx->animation;

	static Color menu_outline[6] = {
		Color(60, 60, 60),
		Color(40, 40, 40),
		Color(40, 40, 40),
		Color(40, 40, 40),
		Color(60, 60, 60),
		Color(10, 10, 10)
	};

	for (int i = 1; i < 7; ++i) {
		Render::DirectX::rect(ctx->pos - i, (ctx->size - 1) + (i * 2), menu_outline[i - 1].OverrideAlpha(255));
	}

	D3DVIEWPORT9 tab_inner = { ctx->pos.x, ctx->pos.y, ctx->size.x, ctx->size.y };
	D3DVIEWPORT9 old_viewport = Render::DirectX::get_viewport();

	Render::DirectX::set_viewport(tab_inner);
	Render::DirectX::rect_fill(Vector2D(ctx->pos.x + 75, ctx->pos.y), ctx->size, Color(20, 20, 20));
	Render::DirectX::Textures::background->Draw(Vector2D(ctx->pos.x + 74, ctx->pos.y - 4), Color(255, 255, 255));
	Render::DirectX::set_viewport(old_viewport);

	auto rainbow = [](Vector2D pos, bool dark) {
		Render::DirectX::gradient_h(pos + 1, Vector2D(ctx->size.x / 2, 1), Color(55, 177, 218), Color(202, 70, 205));
		Render::DirectX::gradient_h(Vector2D(pos.x + ctx->size.x / 2, pos.y + 1), Vector2D((ctx->size.x / 2) - 1, 1), Color(202, 70, 205), Color(204, 227, 53));

		if (dark) {
			Render::DirectX::rect_fill(pos + 1, Vector2D(ctx->size.x - 1, 1), Color(0, 0, 0, 100));
			Render::DirectX::rect_fill(pos + Vector2D(1, 2), Vector2D(ctx->size.x - 1, 1), Color(0, 0, 0, 100));
		}
	};

	// top side bar stuff
	Render::DirectX::rect_fill(ctx->pos, Vector2D(75, 4), Color(20, 20, 20));
	Render::DirectX::rect_fill(ctx->pos + Vector2D(0, 4), Vector2D(73, ctx->ActiveTab == 0 ? 20 : 23), Color(12, 12, 12));
	Render::DirectX::rect_fill(ctx->pos + Vector2D(73, 4), Vector2D(1, 22), Color(0, 0, 0));
	Render::DirectX::rect_fill(ctx->pos + Vector2D(74, 4), Vector2D(1, 22), Color(48, 48, 48));

	rainbow(ctx->pos, false);
	rainbow(ctx->pos + Vector2D(0, 1), true);

	for (int i = 0; i < ctx->Tabs.size(); ++i) {
		Vector2D tab_size = Render::DirectX::Fonts::menu_icon.measure_size(ctx->Tabs[i]);
		Vector2D tab_pos = ctx->pos + Vector2D(0, 23 + (76 * i));

		if (ctx->Tabs[i].find('C') != std::string::npos) {
			//tab_pos.x -= 4;
		}

		if (ctx->ActiveTab != i) {
			bool cut_bottom = ctx->ActiveTab == i + 1;

			Render::DirectX::rect_fill(ctx->pos + Vector2D(0, 27 + (76 * i)), Vector2D(73, cut_bottom ? 73 : 76), Color(12, 12, 12));
			Render::DirectX::rect_fill(ctx->pos + Vector2D(73, 26 + (76 * i)), Vector2D(1, 76), Color(0, 0, 0));
			Render::DirectX::rect_fill(ctx->pos + Vector2D(74, 26 + (76 * i)), Vector2D(1, 76), Color(48, 48, 48));

			Render::DirectX::Fonts::menu_icon.draw_text(ctx->Tabs[i], tab_pos + Vector2D(38, 38) - Vector2D(tab_size.x / 2, tab_size.y / 2), Color(90, 90, 90), font_dropshadow);
		}

		if (ctx->ActiveTab == i) {
			D3DVIEWPORT9 tab_inner2 = { ctx->pos.x, ctx->pos.y + 26 + (76 * i), 75.f, 76.f };
			Render::DirectX::set_viewport(tab_inner2);
			Render::DirectX::rect_fill(ctx->pos + Vector2D(0, 25 + (76 * i)), Vector2D(75, 76), Color(20, 20, 20));
			Render::DirectX::Textures::background->Draw(ctx->pos + Vector2D(0, 22 + (76 * i)), Color(255, 255, 255));
			Render::DirectX::set_viewport(old_viewport);

			Render::DirectX::rect_fill(ctx->pos + Vector2D(0, 24 + (76 * i)), Vector2D(73, 1), Color(0, 0, 0));
			Render::DirectX::rect_fill(ctx->pos + Vector2D(0, 25 + (76 * i)), Vector2D(75, 1), Color(48, 48, 48));

			Render::DirectX::rect_fill(ctx->pos + Vector2D(0, 101 + (76 * i)), Vector2D(75, 1), Color(48, 48, 48));
			Render::DirectX::rect_fill(ctx->pos + Vector2D(0, 102 + (76 * i)), Vector2D(73, 1), Color(0, 0, 0));

			Render::DirectX::Fonts::menu_icon.draw_text(ctx->Tabs[i], tab_pos + Vector2D(38, 38) - Vector2D(tab_size.x / 2, tab_size.y / 2), Color(210, 210, 210), font_dropshadow);
		}
		else {
			if (InputSys::Get()->IsInBox(tab_pos, Vector2D(75, 77))) {
				Render::DirectX::Fonts::menu_icon.draw_text(ctx->Tabs[i], tab_pos + Vector2D(38, 38) - Vector2D(tab_size.x / 2, tab_size.y / 2), Color(150, 150, 150), font_dropshadow);

				if (InputHelper::Pressed(VK_LBUTTON))
					ctx->ActiveTab = i;
			}
		}
	}

	// bottom side bar stuff
	float size_delta = fabs((ctx->pos + Vector2D(73, 26 + (76 * ctx->Tabs.size()))).y - (ctx->pos.y + ctx->size.y));
	Render::DirectX::rect_fill(ctx->pos + Vector2D(0, 27 + (76 * ctx->Tabs.size())), Vector2D(73, size_delta - 1), Color(12, 12, 12));
	Render::DirectX::rect_fill(ctx->pos + Vector2D(73, 26 + (76 * ctx->Tabs.size())), Vector2D(1, size_delta), Color(0, 0, 0));
	Render::DirectX::rect_fill(ctx->pos + Vector2D(74, 26 + (76 * ctx->Tabs.size())), Vector2D(1, size_delta), Color(48, 48, 48));

	ctx->Tabs.clear();

	// at what (x, y) relative to the menu's initial cursor position (0,0) we should draw the menu elements
	GUI::PushCursorPos(Vector2D(104, 24));

	return true;
}

void GUI::Form::EndWindow() {
	if (ctx->DropdownInfo.HashedID != 0) {
		Vector2D pos = ctx->DropdownInfo.Pos;
		int width = ctx->DropdownInfo.Size;

		for (int i = 0; i < ctx->DropdownInfo.Elements.size(); i++) {
			Vector2D option_pos = pos + Vector2D(0, 20 * i);
			Vector2D option_size = Vector2D(width, 20);

			if (InputSys::Get()->IsInBox(option_pos, option_size)) {
				Render::DirectX::rect_fill(option_pos, option_size, { 25, 25, 25 });
				if (InputHelper::Pressed(VK_LBUTTON)) {
					*ctx->DropdownInfo.Option = i;
					ctx->DropdownInfo.HashedID = 0;
					ctx->FocusedID = 0;
				}
			}
			else {
				Render::DirectX::rect_fill(option_pos, option_size, { 35, 35, 35 });
			}

			if (*ctx->DropdownInfo.Option != i)
				Render::DirectX::Fonts::menu.draw_text(ctx->DropdownInfo.Elements[i], option_pos + Vector2D(10, 4), Color(200, 200, 200), 0);
			else
				Render::DirectX::Fonts::menu_bold.draw_text(ctx->DropdownInfo.Elements[i], option_pos + Vector2D(10, 4), g_Vars.menu.ascent.ToRegularColor(), 0);
		}

		Render::DirectX::rect(ctx->DropdownInfo.Pos, Vector2D(ctx->DropdownInfo.Size, 20 * ctx->DropdownInfo.Elements.size()), { 10, 10, 10 });

		if (InputHelper::Pressed(VK_LBUTTON)) {
			ctx->DropdownInfo.HashedID = 0;
			ctx->FocusedID = 0;
		}
	}

	if (ctx->MultiDropdownInfo.HashedID != 0) {
		Vector2D pos = ctx->MultiDropdownInfo.Pos;
		int width = ctx->MultiDropdownInfo.Size;

		for (int i = 0; i < ctx->MultiDropdownInfo.Elements.size(); i++) {
			Vector2D option_pos = pos + Vector2D(0, 20 * i);
			Vector2D option_size = Vector2D(width, 20);

			if (InputSys::Get()->IsInBox(option_pos, option_size)) {
				Render::DirectX::rect_fill(option_pos, option_size, { 25, 25, 25 });
				if (InputHelper::Pressed(VK_LBUTTON)) {
					*ctx->MultiDropdownInfo.Elements.at(i).value ^= 1;
				}
			}
			else {
				Render::DirectX::rect_fill(option_pos, option_size, { 35, 35, 35 });
			}

			if (!*ctx->MultiDropdownInfo.Elements.at(i).value)
				Render::DirectX::Fonts::menu.draw_text(ctx->MultiDropdownInfo.Elements.at(i).name, option_pos + Vector2D(10, 4), Color(200, 200, 200), 0);
			else
				Render::DirectX::Fonts::menu_bold.draw_text(ctx->MultiDropdownInfo.Elements.at(i).name, option_pos + Vector2D(10, 4), g_Vars.menu.ascent.ToRegularColor(), 0);
		}

		Render::DirectX::rect(pos, Vector2D(ctx->MultiDropdownInfo.Size, 20 * ctx->MultiDropdownInfo.Elements.size()), { 10, 10, 10 });

		if (InputHelper::Pressed(VK_LBUTTON) && !InputSys::Get()->IsInBox(pos, Vector2D(ctx->MultiDropdownInfo.Size, 20 * ctx->MultiDropdownInfo.Elements.size()))) {
			ctx->MultiDropdownInfo.HashedID = 0;
			ctx->FocusedID = 0;
		}
	}

	static float ColorPickerHue = -1.f;
	static std::map<size_t, float> ColorPickerAlpha;
	if (ctx->ColorPickerInfo.HashedID != 0 && ctx->animation >= 1.0f) {
		size_t id = ctx->ColorPickerInfo.HashedID;
		// context menu, copy, paste
		if (ctx->ColorPickerInfo.ActionCringe == 1) {
			Vector2D DrawPos = Vector2D((int)ctx->ColorPickerInfo.Pos.x, (int)ctx->ColorPickerInfo.Pos.y);
			Vector2D PastePos = DrawPos + Vector2D(0, 20);

			// copy
			if (InputSys::Get()->IsInBox(DrawPos, Vector2D(85, 20))) {
				Render::DirectX::rect_fill(DrawPos, Vector2D(85, 20), { 25, 25, 25 });
				if (InputHelper::Pressed(VK_LBUTTON)) {
					std::stringstream color_hex;

					color_hex << "#";
					color_hex << std::hex << std::setw(2) << std::setfill('0') << std::uppercase << +(*ctx->ColorPickerInfo.Value).ToRegularColor().r();
					color_hex << std::hex << std::setw(2) << std::setfill('0') << std::uppercase << +(*ctx->ColorPickerInfo.Value).ToRegularColor().g();
					color_hex << std::hex << std::setw(2) << std::setfill('0') << std::uppercase << +(*ctx->ColorPickerInfo.Value).ToRegularColor().b();
					color_hex << std::hex << std::setw(2) << std::setfill('0') << std::uppercase << +(*ctx->ColorPickerInfo.Value).ToRegularColor().a();

					if (OpenClipboard(nullptr)) {
						EmptyClipboard();
						HGLOBAL clipboard_buffer = GlobalAlloc(GMEM_DDESHARE, color_hex.str().size() + 1);
						char* buffer = (char*)GlobalLock(clipboard_buffer);
						strcpy(buffer, color_hex.str().c_str());

						GlobalUnlock(clipboard_buffer);
						SetClipboardData(CF_TEXT, clipboard_buffer);
						CloseClipboard();
					}

					ctx->FocusedID = ctx->ColorPickerInfo.HashedID = 0;
				}
			}
			else {
				Render::DirectX::rect_fill(DrawPos, Vector2D(85, 20), { 35, 35, 35 });
			}

			// paste
			if (InputSys::Get()->IsInBox(PastePos, Vector2D(85, 20))) {
				Render::DirectX::rect_fill(PastePos, Vector2D(85, 20), { 25, 25, 25 });
				if (InputHelper::Pressed(VK_LBUTTON)) {
					ColorPickerHue = -1.f;

					// bruh this better be the right format...
					if (IsClipboardFormatAvailable(CF_TEXT)) {
						if (OpenClipboard(nullptr)) {
							std::string input((char*)GetClipboardData(CF_TEXT));
							if (!input.empty()) {
								bool bIsValidHexColor = input.at(0) == '#';

								for (int i = 0; i < input.length(); ++i) {
									auto n = input[i];

									if (n == 'g' || n == 'h' || n == 'i' ||
										n == 'j' || n == 'k' || n == 'l' ||
										n == 'm' || n == 'n' || n == 'o' ||
										n == 'p' || n == 'q' || n == 'r' ||
										n == 's' || n == 't' || n == 'u' ||
										n == 'v' || n == 'w' || n == 'x' ||
										n == 'y' || n == 'z' || n == 'G' ||
										n == 'H' || n == 'I' || n == 'J' ||
										n == 'K' || n == 'L' || n == 'M' ||
										n == 'N' || n == 'O' || n == 'P' ||
										n == 'Q' || n == 'R' || n == 'S' ||
										n == 'T' || n == 'U' || n == 'V' ||
										n == 'W' || n == 'X' || n == 'Y' ||
										n == 'Z' || n == ' ')
									{
										bIsValidHexColor = false;
									}
								}


								if (input.length() > 9)
									bIsValidHexColor = false;

								//	check if we have a hex color copied in our clipboard
								if (bIsValidHexColor) {
									int component_r = std::stoi(input.substr(1, 2), 0, 16);
									int component_g = std::stoi(input.substr(3, 2), 0, 16);
									int component_b = std::stoi(input.substr(5, 2), 0, 16);
									int component_a = input.size() > 7 ? std::stoi(input.substr(7, 2), 0, 16) : 255;

									Color colPaste = Color(component_r, component_g, component_b, component_a);

									(*ctx->ColorPickerInfo.Value).SetColor(colPaste);
								}
							}
							CloseClipboard();
						}
					}

					ctx->FocusedID = ctx->ColorPickerInfo.HashedID = 0;
				}
			}
			else {
				Render::DirectX::rect_fill(PastePos, Vector2D(85, 20), { 35, 35, 35 });
			}

			Render::DirectX::Fonts::menu.draw_text(XorStr("Copy"), DrawPos + Vector2D(10, 4), Color(200, 200, 200), 0);
			Render::DirectX::Fonts::menu.draw_text(XorStr("Paste"), PastePos + Vector2D(10, 4), Color(200, 200, 200), 0);

			Render::DirectX::rect(DrawPos, Vector2D(85, 40), { 10, 10, 10 });

			if (InputHelper::Pressed(VK_LBUTTON)) {
				ctx->FocusedID = ctx->ColorPickerInfo.HashedID = 0;
			}

		}
		// regular picker
		else {
			if (ColorPickerAlpha.find(ctx->ColorPickerInfo.HashedID) == ColorPickerAlpha.end()) {
				ColorPickerAlpha.insert({ ctx->ColorPickerInfo.HashedID, 0.f });
			}

			Vector2D DrawPos = Vector2D((int)ctx->ColorPickerInfo.Pos.x, (int)ctx->ColorPickerInfo.Pos.y);

			Color::Hsv_t v1 = Color::RGBtoHSV((*ctx->ColorPickerInfo.Value).ToRegularColor());

			float NewHue;

			if (ColorPickerHue == -1.f) {
				NewHue = v1.Hue;
				ColorPickerHue = NewHue;
			}
			else {
				NewHue = ColorPickerHue;
			}

			float NewSaturation = v1.Saturation;
			float NewValue = v1.Value;
			ColorPickerAlpha.at(ctx->ColorPickerInfo.HashedID) = ((*ctx->ColorPickerInfo.Value).ToRegularColor()).a();

			int MaxHeight = (ctx->ColorPickerInfo.Size);
			Vector2D DrawSize = Vector2D(ctx->ColorPickerInfo.Size, MaxHeight);

			Render::DirectX::rect_fill(DrawPos, DrawSize, Color(40, 40, 40, 255));
			Render::DirectX::rect(DrawPos, DrawSize, Color(60, 60, 60, 255));
			Render::DirectX::rect(DrawPos - 1, DrawSize + 2, Color(10, 10, 10, 255));

			Vector2D ColorDrawPos(DrawPos + 5);
			Vector2D ColorDrawSize(Vector2D(DrawSize.x - 30, DrawSize.y - 25));

			Vector2D AlphaDrawPos(ColorDrawPos + Vector2D(0, ColorDrawSize.y + 4));
			Vector2D AlphaDrawSize = Vector2D(ColorDrawSize.x, 11);

			Vector2D ContextDrawPos(AlphaDrawPos + Vector2D(0, AlphaDrawSize.y + 4));
			Vector2D ContextDrawSize(AlphaDrawSize);

			Vector2D HueDrawPos(ColorDrawPos + Vector2D(ColorDrawSize.x + 4, -1));
			Vector2D HueDrawSize = Vector2D(16, ColorDrawSize.y);

			static Vector2D ColorPreviewPos;

			bool HoveredMain = InputSys::Get()->IsInBox(DrawPos, DrawSize);
			bool HoveredPicker = InputSys::Get()->IsInBox(ColorDrawPos, ColorDrawSize);
			bool HoveredAlpha = InputSys::Get()->IsInBox(AlphaDrawPos, AlphaDrawSize);
			bool HoveredHue = InputSys::Get()->IsInBox(HueDrawPos, HueDrawSize);

			// alpha bar
			if (!ctx->ColorPickerInfo.PickingAlpha && !ctx->ColorPickerInfo.PickingHue && !ctx->ColorPickerInfo.PickingColor && !ctx->ColorPickerInfo.CopyingColor && !ctx->ColorPickerInfo.PastingColor) {
				if (HoveredAlpha && InputHelper::Pressed(VK_LBUTTON)) {
					ctx->ColorPickerInfo.PickingAlpha = true;
				}
			}
			else if (ctx->ColorPickerInfo.PickingAlpha) {
				if (InputHelper::Down(VK_LBUTTON)) {
					float FinalValue = std::clamp<float>(GUI::MapNumber(std::clamp<float>(
						Vector2D(InputSys::Get()->GetMousePosition() - AlphaDrawPos).x, 0, AlphaDrawSize.x),
						0, AlphaDrawSize.x, 0, 255), 0, 255);

					ColorPickerAlpha.at(ctx->ColorPickerInfo.HashedID) = FinalValue;
				}
				else {
					ctx->ColorPickerInfo.PickingAlpha = false;
				}
			}

			Render::DirectX::rect_fill(AlphaDrawPos, AlphaDrawSize, ((*ctx->ColorPickerInfo.Value).ToRegularColor()).OverrideAlpha(255, true));
			Render::DirectX::rect(AlphaDrawPos, AlphaDrawSize, Color(10, 10, 10, 255));

			// hue bar
			if (!ctx->ColorPickerInfo.PickingHue && !ctx->ColorPickerInfo.PickingAlpha && !ctx->ColorPickerInfo.PickingColor && !ctx->ColorPickerInfo.CopyingColor && !ctx->ColorPickerInfo.PastingColor) {
				if (HoveredHue && InputHelper::Pressed(VK_LBUTTON)) {
					ctx->ColorPickerInfo.PickingHue = true;
				}
			}
			else if (ctx->ColorPickerInfo.PickingHue) {
				if (InputHelper::Down(VK_LBUTTON)) {
					NewHue = ((InputSys::Get()->GetMousePosition().y - (HueDrawPos.y)) / HueDrawSize.y) * 360.f;

					NewHue = std::clamp<float>(NewHue, 0.f, 359.f);
					ColorPickerHue = NewHue;
				}
				else {
					ctx->ColorPickerInfo.PickingHue = false;
				}
			}

			for (int i = 0; i < HueDrawSize.y; i++) {
				float Hue = ((float)i / HueDrawSize.y) * 360.f;
				Color HueColor = Color::HSVtoRGB(Hue, 1, 1);

				Render::DirectX::line(HueDrawPos + Vector2D(0, i + 1), HueDrawPos + Vector2D(HueDrawSize.x, i + 1), HueColor.OverrideAlpha(255));
			}

			Render::DirectX::rect(HueDrawPos + Vector2D(0, 1), HueDrawSize, Color(10, 10, 10, 255));

			// main picker
			if (!ctx->ColorPickerInfo.PickingColor && !ctx->ColorPickerInfo.PickingHue && !ctx->ColorPickerInfo.PickingAlpha && !ctx->ColorPickerInfo.CopyingColor && !ctx->ColorPickerInfo.PastingColor) {
				if (HoveredPicker && InputHelper::Pressed(VK_LBUTTON)) {
					ctx->ColorPickerInfo.PickingColor = true;
				}
			}
			else if (ctx->ColorPickerInfo.PickingColor) {
				if (InputHelper::Down(VK_LBUTTON)) {
					Vector2D CursorDelta = InputSys::Get()->GetMousePosition() - ColorDrawPos;

					float s = (float)CursorDelta.x / (ColorDrawSize.x);
					float v = 1.f - (float)CursorDelta.y / (ColorDrawSize.y);

					// xd
					ColorPreviewPos = InputSys::Get()->GetMousePosition();

					NewSaturation = s;
					NewValue = v;
				}
				else {
					ctx->ColorPickerInfo.PickingColor = false;
				}
			}

			(*ctx->ColorPickerInfo.Value).SetColor(Color::HSVtoRGB(NewHue, std::clamp<float>(NewSaturation, 0.0f, 1.0f), std::clamp<float>(NewValue, 0.0f, 1.0f))
				.OverrideAlpha(ColorPickerAlpha.at(ctx->ColorPickerInfo.HashedID)));

			Render::DirectX::gradient_h(ColorDrawPos, ColorDrawSize + Vector2D(0, 1), Color(255, 255, 255),
				Color::HSVtoRGB(NewHue, 1, 1).OverrideAlpha(255));

			Render::DirectX::gradient_v(ColorDrawPos, ColorDrawSize + 1, Color(0, 0, 0, 0), Color(0, 0, 0, 255));
			Render::DirectX::rect(ColorDrawPos, ColorDrawSize, Color(10, 10, 10, 255));

			// the rects that signify what each part of the colorpicker is at

			// alpha
			float AlphaAdditive = (AlphaDrawSize.x * (ColorPickerAlpha.at(ctx->ColorPickerInfo.HashedID) / 255.f));

			Render::DirectX::rect_fill(AlphaDrawPos + Vector2D((AlphaAdditive - 3) < 0 ? 0 : AlphaAdditive - 3, 1), Vector2D(3, AlphaDrawSize.y - 2), Color(255, 255, 255, 180));
			Render::DirectX::rect(AlphaDrawPos + Vector2D((AlphaAdditive - 3) < 0 ? 0 : AlphaAdditive - 3, 1), Vector2D(3, AlphaDrawSize.y - 2), Color(10, 10, 10, 255));

			// actual color
			auto viewport = Render::DirectX::get_viewport();
			D3DVIEWPORT9 color_limit = { ColorDrawPos.x, ColorDrawPos.y, ColorDrawSize.x, ColorDrawSize.y, 0.f, 1.0f };
			Render::DirectX::set_viewport(color_limit);
			{
				Render::DirectX::rect_fill(ColorPreviewPos, Vector2D(3, 3), Color(255, 255, 255, 180));
				Render::DirectX::rect(ColorPreviewPos, Vector2D(3, 3), Color(10, 10, 10, 255));
			}
			Render::DirectX::set_viewport(viewport);

			// hue
			float HueAdditive = (HueDrawSize.y * (NewHue / 360.f));

			Render::DirectX::rect_fill(HueDrawPos + Vector2D(1, (HueAdditive - 3) < 0 ? 1 : HueAdditive - 2), Vector2D(HueDrawSize.x - 2, 3), Color(255, 255, 255, 180));
			Render::DirectX::rect(HueDrawPos + Vector2D(1, (HueAdditive - 3) < 0 ? 1 : HueAdditive - 2), Vector2D(HueDrawSize.x - 2, 3), Color(10, 10, 10, 255));

			if (InputHelper::Pressed(VK_LBUTTON) && !HoveredMain) {
				ctx->ColorPickerInfo.HashedID = ctx->FocusedID = 0;
			}
		}
	}
	else {
		ColorPickerHue = -1.f;
	}

	// end menu alpha animation
	alpha_mod = -1.f;
}

bool GUI::Form::BeginTab(int icon, std::string name) {
	ctx->Tabs.push_back(name.data());

	ctx->CurrentTab = name;
	return (ctx->ActiveTab == ctx->Tabs.size() - 1) || ctx->setup;
}
```

`CSGO SDK/Menu/Framework/Form/Form.h`:

```h
#pragma once

namespace GUI::Form {
	bool BeginWindow(std::string name);
	void EndWindow();

	bool BeginTab(int icon, std::string name);
}

```

`CSGO SDK/Menu/Framework/GUI.cpp`:

```cpp
#include "gui.h"
#include "../../source.hpp"

Vector2D last_cursor_pos;

Vector2D GUI::PopCursorPos() {
	if (ctx->CursorPosStack.empty())
		return Vector2D();

	Vector2D ret = ctx->CursorPosStack.top();
	ctx->CursorPosStack.pop();
	last_cursor_pos = ret;
	return ret;
}

Vector2D GUI::GetLastCursorPos() {
	return last_cursor_pos;
}

void GUI::PushCursorPos(const Vector2D& cursor_pos) {
	ctx->CursorPosStack.push(cursor_pos);
}

size_t GUI::Hash(const std::string& name) {
	return std::hash< std::string >()(name);
}

float GUI::AnimationInterval(float interval) {
	return (1.0f / interval) * Interfaces::m_pGlobalVars->frametime;
}

float GUI::MapNumber(float input, float input_min, float input_max, float output_min, float output_max) {
	return (input - input_min) / (input_max - input_min) * (output_max - output_min) + output_min;
}

std::vector<std::string> GUI::SplitStr(const std::string& str, char separator) {
	std::vector<std::string> output;
	std::string::size_type prev_pos = 0, pos = 0;

	while ((pos = str.find(separator, pos)) != std::string::npos) {
		std::string substring(str.substr(prev_pos, pos - prev_pos));
		output.push_back(substring);

		prev_pos = pos++;
	}

	output.push_back(str.substr(prev_pos, pos - prev_pos));
	return output;
}

```

`CSGO SDK/Menu/Framework/GUI.h`:

```h
#pragma once
#include <stack>

#include "../../Utils/InputSys.hpp"
#include "../../SDK/sdk.hpp"
#include "../Helpers/InputHelper.h"

/* Prototypes */
struct MultiItem_t {
	std::string name;
	bool* value;
};

/* Context structs */
struct DropdownInfo_t {
	size_t HashedID;

	std::map<size_t, float> uScroll;

	std::vector<std::string> Elements;
	int* Option;

	int MaxItems;

	bool out_anim;
	bool DraggingScroll;

	float Size = 0.f;
	Vector2D Pos = { 0, 0 };
};

struct MultiDropdownInfo_t {
	size_t HashedID;

	std::map<size_t, float> uScroll;

	std::vector<MultiItem_t> Elements;

	int MaxItems;
	bool DraggingScroll;

	float Size = 0.f;
	Vector2D Pos = { 0, 0 };
};

struct HotkeyInfo_t {
	size_t id;
	bool open = false;

	Vector2D Pos = { 0, 0 };
};

struct ColorPickerInfo_t {
	size_t HashedID;

	FloatColor* Value;

	bool PickingAlpha = false;
	bool PickingColor = false;
	bool PickingHue = false;

	bool CopyingColor = false;
	bool PastingColor = false;

	int ActionCringe;

	int Size = 0.f;
	Vector2D Pos = { 0, 0 };
};

struct SliderInfo_t {
	std::map<size_t, float> ValueAnimation;
	std::map<size_t, float> ValueTimer;

	std::map<size_t, float> PreviewAnimation;
	std::map<size_t, float> PreviousAmount;

	std::map<size_t, float> LastChangeTime;

	std::map<size_t, std::pair<float, bool>> ShouldChangeValue;
};

/* "Object" structs */
struct MenuContext_t {
	Vector2D pos = { 100, 100 };

	// 660, 550
	Vector2D size = { 648, 548 };

	Vector2D NextGroupPos;
	std::stack< Vector2D > CursorPosStack;

	std::vector< std::string > Tabs;
	int ActiveTab = 0;

	DropdownInfo_t DropdownInfo;
	MultiDropdownInfo_t MultiDropdownInfo;
	ColorPickerInfo_t ColorPickerInfo;
	HotkeyInfo_t HotkeyInfo;
	SliderInfo_t SliderInfo;

	Vector2D ParentPos;
	Vector2D ParentSize;

	std::string parent;
	size_t FocusedID = 0;

	std::string CurrentTab;
	std::string CurrentSubTab;
	std::string CurrentGroup;
	std::string CurrentWeaponGroup;

	bool dragging = false;
	bool resizing = false;
	//bool setup = true;
	bool setup = false;
	bool typing = false;
	bool hovered_listbox = false;
	bool dragging_scrollbar = false;

	float animation = 0.f;
};

namespace GUI {
	inline MenuContext_t* ctx = new MenuContext_t();

	// modify this if you'd like to change the spacing between each object
	inline int ObjectPadding() {
		constexpr int spacing{ 10 };

		return spacing /*+ 1*/;
	};

	Vector2D PopCursorPos();
	Vector2D GetLastCursorPos();
	void PushCursorPos(const Vector2D& cursor_pos);

	size_t Hash(const std::string& name);

	float AnimationInterval(float interval = 0.035f);

	template < typename T = float >
	inline float Approach(float a, float b, float multiplier) {
		return (a + static_cast<T>(multiplier * (b - a)));
	}

	float MapNumber(float input, float input_min, float input_max, float output_min, float output_max);
	std::vector<std::string> SplitStr(const std::string& str, char separator);
}

#include "form/form.h"
#include "group/group.h"
#include "checkbox/checkbox.h"
#include "button/button.h"
#include "label/label.h"
#include "slider/slider.h"
#include "dropdown/dropdown.h"
#include "colorpicker/colorpicker.h"
#include "hotkey/hotkey.h"
#include "multidropdown/multidropdown.h"
#include "Listbox/Listbox.h"
#include "Textbox/Textbox.h"
```

`CSGO SDK/Menu/Framework/Group/Group.cpp`:

```cpp
#include "../gui.h"
#include <algorithm>
#include "../../../source.hpp"

D3DVIEWPORT9 o_vp;
Vector2D gp;
Vector2D gs;
int id;

std::string name;

std::map<int, int> scrolling;

Vector2D override_size = { -1, -1 };

void GUI::Group::BeginGroup(const std::string& name, const Vector2D& size) {
	size_t id = GUI::Hash(name);
	::name = GUI::SplitStr(name, '#')[0].data();
	::id = id;

	if (scrolling.find(id) == scrolling.end()) {
		scrolling.insert({ id, 0 });
	}

	Vector2D cursor_pos = PopCursorPos();
	Vector2D group_size;

	float width_percent = (float)size.x / 100.f;
	float height_percent = (float)size.y / 100.f;

	int width_available = ctx->size.x - 154;
	int height_available = ctx->size.y - 63;

	if (cursor_pos.x == 104 && width_percent == 1.0f)
		width_available += 20;

	group_size.x = width_available * width_percent;

	if (cursor_pos.y == 24 && height_percent == 1.0f)
		height_available += 20;

	group_size.y = height_available * height_percent;

	if (override_size.x != -1)
		group_size.x = override_size.x;

	if (override_size.y != -1)
		group_size.y = override_size.y;

	if ((cursor_pos.y - 20 + group_size.y) > ctx->size.y - 37) {
		cursor_pos.x += group_size.x + 20;
		cursor_pos.y = 24;

		PushCursorPos(cursor_pos);
		Group::BeginGroup(name, size);
	}
	else {
		Vector2D draw_pos = ctx->pos + cursor_pos;

		Render::DirectX::rect_fill(draw_pos, group_size, { 17, 17, 17 });
		Render::DirectX::rect(draw_pos, group_size, { 10, 10, 10 });
		Render::DirectX::rect(draw_pos + 1, group_size - 2, { 48, 48, 48 });
		gp = draw_pos;
		gs = group_size;

		Vector2D text_size = Render::DirectX::Fonts::menu_bold.measure_size(GUI::SplitStr(name, '#')[0].data());

		Render::DirectX::rect_fill(draw_pos + Vector2D(11, 0), Vector2D(6 + text_size.x, 2), { 17, 17, 17 });
		// fake group resize thingy xD

		//Render::DirectX::Fonts::menu_bold.draw_text(name, draw_pos + point(14, -5), { 203, 203, 203 }, 4);

		//Render::DirectX::rect(draw_pos, draw_pos + 10, color(255, 0, 0));

		o_vp = Render::DirectX::get_viewport();
		D3DVIEWPORT9 meme = { draw_pos.x, draw_pos.y + 5, group_size.x, group_size.y - 7, 0.f, 1.f };
		Render::DirectX::set_viewport(meme);


		PushCursorPos(cursor_pos + Vector2D(22, 23 + scrolling[id]));

		ctx->parent = "root." + ctx->Tabs[ctx->ActiveTab] + "." + name;
		ctx->NextGroupPos = cursor_pos + Vector2D(0, group_size.y + 20);

		ctx->ParentPos = draw_pos;
		ctx->ParentSize = group_size;
	}
}

void GUI::Group::EndGroup() {
	Vector2D v1 = PopCursorPos();
	int max_height = (int)v1.y - ((int)gp.y - (int)ctx->pos.y) - scrolling[id];
	int VisibleHeight = gs.y + 5;
	PushCursorPos(v1);

	int scrollbar_height, scrollbar_pos;

	if (max_height > VisibleHeight) {
		scrollbar_height = ((float)gs.y / (float)max_height) * gs.y;
		scrollbar_pos = std::min(std::max((-(float)scrolling[id] / (float)max_height) * (float)gs.y, 2.f), gs.y - scrollbar_height - 2.f);

		bool ScrollBarHovered = InputSys::Get()->IsInBox(gp + Vector2D(gs.x - 6, scrollbar_pos), Vector2D(4, scrollbar_height));

		// dont scroll if there is a listbox that we're about to scroll in
		if (!ctx->hovered_listbox && !ctx->MultiDropdownInfo.DraggingScroll && !ctx->DropdownInfo.DraggingScroll) {
			if (ctx->FocusedID == 0 || ctx->FocusedID == id) {
				bool bHoveredMain = InputSys::Get()->IsInBox(gp, gs - Vector2D(6, 0));
				bool bHoveredScroll = InputSys::Get()->IsInBox(gp + Vector2D(gs.x - 6, scrollbar_pos), Vector2D(4, scrollbar_height));

				if (bHoveredMain || bHoveredScroll || ctx->FocusedID == id) {
					// Ayy, I'm runnin' to the money, you know how I'm comin'
					// Monday 'til Sunday night, be thumbin', thumbin', thumbin'
					// (...)
					// I told her throw that ass back so I can bust it like a bubble
					// South Memphis nigga in this bitch, yeah, you know you in trouble
					// Ain't nuthin but a P thang, baby
					// Young iced - out nigga going crazy
					if (ctx->FocusedID != id && InputHelper::Down(VK_LBUTTON) && bHoveredScroll) {
						ctx->FocusedID = id;
					}
					else if (ctx->FocusedID == id) {
						if (InputHelper::Down(VK_LBUTTON)) {
							const auto scale = [](int in, int bmin, int bmax, int lmin, int lmax) {
								return float((lmax - lmin) * (in - bmin)) / float(bmax - bmin) + lmin;
							};

							// i think not perfect
							auto pizdo = std::max(float(float(gs.y * (gs.y - 12 * 2))
								/ float(-max_height + (gs.y - 12 * 2))), 30.f);

							scrolling[id] += scale(InputHelper::MouseDelta.y, 0, gs.y - pizdo, 0, max_height);
						}
						else {
							ctx->FocusedID = 0;
						}
					}

					if (ctx->FocusedID != id) {
						if (InputSys::Get()->GetScrollMouse() > 0) {
							scrolling[id] = scrolling[id] + 15;
						}
						else if (InputSys::Get()->GetScrollMouse() < 0) {
							scrolling[id] = scrolling[id] - 15;
						}
					}
				}

				ctx->dragging_scrollbar = ctx->FocusedID == id;

				scrolling[id] = std::clamp<float>(scrolling[id], -max_height + (int)gs.y, 0);
			}
		}
	}
	else {
		scrolling[id] = 0;
	}

	PushCursorPos(ctx->NextGroupPos);
	ctx->NextGroupPos = Vector2D(0, 0);
	Render::DirectX::set_viewport(o_vp);
	Render::DirectX::Fonts::menu_bold.draw_text(name, gp + Vector2D(14, -5), { 203, 203, 203 }, 4);

	if (max_height > VisibleHeight) {
		Render::DirectX::rect_fill(gp + Vector2D(gs.x - 7, 2), Vector2D(6, gs.y - 3), Color(45, 45, 45));

		Render::DirectX::rect_fill(gp + Vector2D(gs.x - 6, scrollbar_pos), Vector2D(4, scrollbar_height + 1),
			(InputSys::Get()->IsInBox(gp + Vector2D(gs.x - 6, scrollbar_pos), Vector2D(4, scrollbar_height + 1)) || ctx->FocusedID == id) ? Color(80, 80, 80) : Color(65, 65, 65));

		// bottom
		Vector2D GradientSize = Vector2D(gs.x - 9, 20);
		Vector2D GradientPos = gp + Vector2D(2, gs.y - GradientSize.y - 1);

		// bottom arrow facing down
		if (scrolling[id] >= (-max_height + (int)gs.y) + 10) {
			Render::DirectX::gradient_v(GradientPos, GradientSize, Color(17, 17, 17, 0), { 17, 17, 17 });

			Render::DirectX::rect_fill(gp + gs - Vector2D(17, 10), Vector2D(5, 1), Color(0, 0, 0));
			Render::DirectX::rect_fill(gp + gs - Vector2D(17, 9), Vector2D(5, 1), Color(204, 204, 204));
			Render::DirectX::rect_fill(gp + gs - Vector2D(16, 8), Vector2D(3, 1), Color(204, 204, 204));
			Render::DirectX::rect_fill(gp + gs - Vector2D(15, 7), Vector2D(1, 1), Color(204, 204, 204));
		}

		// top arrow facing up
		if (scrolling[id] <= -10) {
			// top
			GradientPos = gp + Vector2D(2, 5);
			Render::DirectX::gradient_v(GradientPos, GradientSize, { 17, 17, 17 }, Color(17, 17, 17, 0));

			Render::DirectX::rect_fill(gp + Vector2D(gs.x - 20, 7) + Vector2D(5, 0), Vector2D(1, 1), Color(204, 204, 204));
			Render::DirectX::rect_fill(gp + Vector2D(gs.x - 20, 7) + Vector2D(4, 1), Vector2D(3, 1), Color(204, 204, 204));
			Render::DirectX::rect_fill(gp + Vector2D(gs.x - 20, 7) + Vector2D(3, 2), Vector2D(5, 1), Color(204, 204, 204));
			Render::DirectX::rect_fill(gp + Vector2D(gs.x - 20, 7) + Vector2D(3, 3), Vector2D(5, 1), Color(0, 0, 0));
		}
	}
}

void GUI::Group::SetNextSize(const Vector2D& size) {
	override_size = size;
}

void GUI::Group::PopLastSize() {
	override_size = { -1, -1 };
}
```

`CSGO SDK/Menu/Framework/Group/Group.h`:

```h
#pragma once

namespace GUI::Group {
	void BeginGroup(const std::string& name, const Vector2D& size);
	void EndGroup();

	void SetNextSize(const Vector2D& size);
	void PopLastSize();
}

```

`CSGO SDK/Menu/Framework/Hotkey/Hotkey.cpp`:

```cpp
#include "../gui.h"
#include "../../../source.hpp"
#include "../../../Features/Visuals/EventLogger.hpp"

std::string GetKeyName(const int VirtualKey) {
	auto Code = MapVirtualKeyA(VirtualKey, MAPVK_VK_TO_VSC);

	int Result;
	char Buffer[128];

	switch (VirtualKey) {
	case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN:
	case VK_RCONTROL: case VK_RMENU:
	case VK_LWIN: case VK_RWIN: case VK_APPS:
	case VK_PRIOR: case VK_NEXT:
	case VK_END: case VK_HOME:
	case VK_INSERT: case VK_DELETE:
	case VK_DIVIDE:
	case VK_NUMLOCK:
		Code |= KF_EXTENDED;
	default:
		Result = GetKeyNameTextA(Code << 16, Buffer, 128);
	}

	if (Result == 0 || VirtualKey == VK_CAPITAL) {
		switch (VirtualKey) {
		case VK_XBUTTON1:
			return XorStr("[M4]");
		case VK_XBUTTON2:
			return XorStr("[M5]");
		case VK_LBUTTON:
			return XorStr("[M1]");
		case VK_MBUTTON:
			return XorStr("[M3]");
		case VK_RBUTTON:
			return XorStr("[M2]");
		case VK_CAPITAL:
			return XorStr("[CAPS]");
		default:
			return XorStr("[-]");
		}
	}

	auto transformer = std::string(Buffer);
	std::transform(transformer.begin(), transformer.end(), transformer.begin(), ::toupper);

	return XorStr("[") + transformer + XorStr("]");
}

std::unordered_map<size_t, float> uHoverAnimationHotkey;
std::unordered_map<size_t, float> uActiveAnimationHotkey;
void GUI::Controls::Hotkey(const std::string& name, KeyBind_t* var_name, bool type_selection) {
	Vector2D CursorPos = GetLastCursorPos();
	Vector2D DrawPos = ctx->pos + CursorPos;

	DrawPos.x += ctx->ParentSize.x - 55;

	DrawPos.x += 8;
	DrawPos.y -= 2;

	float w = Render::DirectX::Fonts::menu_pixel.measure_size(GetKeyName((*var_name).key)).x;
	Render::DirectX::Fonts::menu_pixel.draw_text(GetKeyName((*var_name).key), DrawPos - Vector2D(1, 0) - Vector2D(w, 0), Color(0, 0, 0, 75), 0);
	Render::DirectX::Fonts::menu_pixel.draw_text(GetKeyName((*var_name).key), DrawPos - Vector2D(0, 1) - Vector2D(w, 0), Color(0, 0, 0, 75), 0);
	Render::DirectX::Fonts::menu_pixel.draw_text(GetKeyName((*var_name).key), DrawPos + Vector2D(1, 0) - Vector2D(w, 0), Color(0, 0, 0, 75), 0);
	Render::DirectX::Fonts::menu_pixel.draw_text(GetKeyName((*var_name).key), DrawPos + Vector2D(0, 1) - Vector2D(w, 0), Color(0, 0, 0, 75), 0);

	Render::DirectX::Fonts::menu_pixel.draw_text(GetKeyName((*var_name).key), DrawPos - Vector2D(w, 0), ctx->FocusedID == GUI::Hash(name) ? Color(255, 0, 0) : Color(107, 107, 107), 0);

	bool hovered = InputSys::Get()->IsInBox(DrawPos - Vector2D(w, 0), Vector2D(w, 8)) && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize);

	if (ctx->FocusedID == 0) {
		if (hovered && InputHelper::Released(VK_LBUTTON)) {
			ctx->FocusedID = GUI::Hash(name);
		}

		if (type_selection) {
			if (hovered && InputHelper::Pressed(VK_RBUTTON)) {
				ctx->FocusedID = GUI::Hash(name + XorStr("_type"));
			}
		}

		if (hovered && InputHelper::Pressed(VK_MBUTTON)) {
			if (OpenClipboard(nullptr)) {
				EmptyClipboard();
				HGLOBAL clipboard_buffer = GlobalAlloc(GMEM_DDESHARE, GUI::SplitStr(name, '#')[0].size() + 1);
				char* buffer = (char*)GlobalLock(clipboard_buffer);
				strcpy(buffer, GUI::SplitStr(name, '#')[0].data());

				GlobalUnlock(clipboard_buffer);
				SetClipboardData(CF_TEXT, clipboard_buffer);
				CloseClipboard();

				//g_EventLog.PushEvent( XorStr( "copied name to clipboard" ), FloatColor( 1.f, 1.f, 1.f ) );
			}
		}

	}
	else if (ctx->FocusedID == GUI::Hash(name + XorStr("_type"))) {
		ctx->DropdownInfo.Elements = { XorStr("Always on"), XorStr("On hotkey"), XorStr("Toggle"), XorStr("Off hotkey") };
		ctx->DropdownInfo.Option = &var_name->cond;
		ctx->DropdownInfo.Size = 100;
		ctx->DropdownInfo.MaxItems = 4;
		ctx->DropdownInfo.Pos = DrawPos + Vector2D(0, 10);
		ctx->DropdownInfo.HashedID = GUI::Hash(name + XorStr("_type"));
	}
	else if (ctx->FocusedID == GUI::Hash(name)) {
		if (!hovered && InputHelper::Pressed(VK_LBUTTON)) {
			ctx->FocusedID = 0;
		}

		for (int i = 0; i < 255; i++) {
			if (InputHelper::Released(i)) {
				ctx->FocusedID = 0;
				(*var_name).key = (i);

				if (i == VK_ESCAPE) {
					(*var_name).key = (0);
				}

				// either always break (which makes sense lol) or only break if i == 16 (SHIFT), but since idk if there are more keys that are multiple
				// I'll just keep it like this.
				break;
			}
		}
	}
}

```

`CSGO SDK/Menu/Framework/Hotkey/Hotkey.h`:

```h
#pragma once

namespace GUI::Controls {
	void Hotkey(const std::string& name, KeyBind_t* var_name, bool type_selection = true);
}

```

`CSGO SDK/Menu/Framework/Label/Label.cpp`:

```cpp
#include "../gui.h"

bool GUI::Controls::Label(const std::string& name, bool unsafe) {
	Vector2D CursorPos = PopCursorPos();
	Vector2D DrawPos = ctx->pos + CursorPos;

	DrawPos.x += 20;
	Render::DirectX::Fonts::menu.draw_text(GUI::SplitStr(name, '#')[0].data(), DrawPos - Vector2D(0, 5), unsafe ? Color(180, 180, 100) : Color(200, 200, 200), 4);

	GUI::PushCursorPos(CursorPos + Vector2D(0, 8 + GUI::ObjectPadding()));
	return (name.size() > 0);
}

```

`CSGO SDK/Menu/Framework/Label/Label.h`:

```h
#pragma once

namespace GUI::Controls {
	bool Label(const std::string& name, bool unsafe = false);
}

```

`CSGO SDK/Menu/Framework/Listbox/Listbox.cpp`:

```cpp
#include "../GUI.h"
#include "../../../source.hpp"

#pragma warning(disable : 4018)

std::map< int, float > iSlider;

std::map< int, std::string > szText;

std::map<size_t, float> LastShiftHoldTime;

/// FIXING THE SCROLLBAR OF THIS IS A TODO LMFAO
bool GUI::Controls::Listbox(const std::string& id, std::vector<std::string> elements, int* option, bool bSearchBar, int iSizeInElements) {
	Vector2D CursorPos = GUI::PopCursorPos();
	Vector2D DrawPos = ctx->pos + CursorPos;

	std::map< size_t, std::vector<std::string> > vecFoundElements;
	std::map< int, int > iPos;

	if (iSlider.find(GUI::Hash(id)) == iSlider.end()) {
		iSlider.insert({ GUI::Hash(id), 0.f });
	}

	if (LastShiftHoldTime.find(GUI::Hash(id)) == LastShiftHoldTime.end()) {
		LastShiftHoldTime.insert({ GUI::Hash(id), 0.f });
	}

	if (vecFoundElements.find(GUI::Hash(id)) == vecFoundElements.end()) {
		vecFoundElements.insert({ GUI::Hash(id), { "" } });
	}

	if (szText.find(GUI::Hash(id)) == szText.end()) {
		szText.insert({ GUI::Hash(id), "" });
	}

	if (iPos.find(GUI::Hash(id)) == iPos.end()) {
		iPos.insert({ GUI::Hash(id), -20 });
	}

	DrawPos.x += 20;
	if (bSearchBar) {
		DrawPos.y += 19;
	}

	int iWidth = std::min((int)ctx->ParentSize.x - 90, 270);

	const int kurwa = 20;

	bool bHoveredSearch = InputSys::Get()->IsInBox(DrawPos - Vector2D(0, 18), Vector2D(iWidth, 19)) && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize) && bSearchBar;
	bool bHovered = InputSys::Get()->IsInBox(DrawPos, Vector2D(iWidth, kurwa * iSizeInElements)) && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize);

	Render::DirectX::rect_fill(DrawPos, Vector2D(iWidth, kurwa * iSizeInElements), Color(35, 35, 35));

	D3DVIEWPORT9 clip = { DrawPos.x, DrawPos.y + 1, iWidth, (kurwa * iSizeInElements) - 2, 0.f, 1.0f };
	Render::DirectX::set_scissor_rect(clip);

	bool bDrawBottomArrow = false;
	bool bDrawTopArrow = false;
	for (int i = 0; i < elements.size(); i++) {
		std::string transformed_elements(elements.at(i));
		std::transform(transformed_elements.begin(), transformed_elements.end(), transformed_elements.begin(), ::tolower);

		std::string transformed_text(szText[GUI::Hash(id)]);
		std::transform(transformed_text.begin(), transformed_text.end(), transformed_text.begin(), ::tolower);

		if ((transformed_elements.find(transformed_text) == std::string::npos) && transformed_text.size() > 0) {
			continue;
		}
		else {
			vecFoundElements[GUI::Hash(id)].push_back(elements.at(i));
			iPos[GUI::Hash(id)] += kurwa;
		}

		bool scrollbar = vecFoundElements[GUI::Hash(id)].size() > iSizeInElements;

		Vector2D OptionPos = DrawPos + Vector2D(0, iPos[GUI::Hash(id)] + iSlider[GUI::Hash(id)]);
		Vector2D OptionSize = Vector2D(iWidth - (scrollbar ? 6 : 0), kurwa);

		// add and subtract 20 for tolerance - we do this cos the "scroll" is a float
		// and not an int (for the epic smooth easing effect) - just clip the elements,
		// drawing 2 more elements wont affect performance that much.
		bool bInBoundsTop = OptionPos.y >= (DrawPos.y - kurwa);
		bool bInBoundsBottom = OptionPos.y + OptionSize.y <= (DrawPos.y + kurwa) + kurwa * (iSizeInElements - 1);

		bool bIsInBounds = bInBoundsTop && bInBoundsBottom;

		if (!bInBoundsBottom) { bDrawBottomArrow = true; };
		if (!bInBoundsTop) { bDrawTopArrow = true; };

		if (bHovered && bIsInBounds) {
			if (InputSys::Get()->IsInBox(OptionPos, OptionSize - Vector2D(6, 0)) && !bHoveredSearch && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize) && ctx->FocusedID == 0) {
				Render::DirectX::rect_fill(OptionPos, OptionSize, Color(45, 45, 45));

				if (InputHelper::Pressed(VK_LBUTTON)) {
					*option = i;
				}
			}
		}

		if (bIsInBounds) {
			if (*option != i) {
				Render::DirectX::Fonts::menu.draw_text(elements[i].c_str(), OptionPos + Vector2D(10, 4), Color(200, 200, 200), 0);
			}
			else {
				Render::DirectX::rect_fill(OptionPos, OptionSize, Color(26, 26, 26));
				Render::DirectX::Fonts::menu.draw_text(elements[i].c_str(), OptionPos + Vector2D(10, 4), g_Vars.menu.ascent.ToRegularColor().OverrideAlpha(255 * ctx->animation), 0);
			}
		}
	}
	Render::DirectX::reset_scissor_rect();

	if (bDrawBottomArrow && (vecFoundElements[GUI::Hash(id)].size() > iSizeInElements)) {
		Render::DirectX::rect_fill(DrawPos + Vector2D(iWidth, (kurwa * iSizeInElements) - 2) - Vector2D(17, 10), Vector2D(5, 1), Color(0, 0, 0));
		Render::DirectX::rect_fill(DrawPos + Vector2D(iWidth, (kurwa * iSizeInElements) - 2) - Vector2D(17, 9), Vector2D(5, 1), Color(204, 204, 204));
		Render::DirectX::rect_fill(DrawPos + Vector2D(iWidth, (kurwa * iSizeInElements) - 2) - Vector2D(16, 8), Vector2D(3, 1), Color(204, 204, 204));
		Render::DirectX::rect_fill(DrawPos + Vector2D(iWidth, (kurwa * iSizeInElements) - 2) - Vector2D(15, 7), Vector2D(1, 1), Color(204, 204, 204));
	}

	// top arrow facing up
	if (bDrawTopArrow && iSlider[GUI::Hash(id)] <= -20) {
		Render::DirectX::rect_fill(DrawPos + Vector2D(iWidth - 20, 7) + Vector2D(5, 0), Vector2D(1, 1), Color(204, 204, 204));
		Render::DirectX::rect_fill(DrawPos + Vector2D(iWidth - 20, 7) + Vector2D(4, 1), Vector2D(3, 1), Color(204, 204, 204));
		Render::DirectX::rect_fill(DrawPos + Vector2D(iWidth - 20, 7) + Vector2D(3, 2), Vector2D(5, 1), Color(204, 204, 204));
		Render::DirectX::rect_fill(DrawPos + Vector2D(iWidth - 20, 7) + Vector2D(3, 3), Vector2D(5, 1), Color(0, 0, 0));
	}

	int scrollbar_height = -1;
	int scrollbar_pos = -1;

	if (vecFoundElements[GUI::Hash(id)].size() > iSizeInElements) {
		scrollbar_height = ((float)(kurwa * (iSizeInElements + 1)) / (float)(kurwa * (vecFoundElements[GUI::Hash(id)].size() + 1))) * (kurwa * (iSizeInElements + 1));
		scrollbar_pos = std::min(std::max((-(float)iSlider[GUI::Hash(id)] / (float)(kurwa * vecFoundElements[GUI::Hash(id)].size())) * (float)(kurwa * iSizeInElements), 2.f), (kurwa * iSizeInElements) - scrollbar_height - 2.f);
	}

	// listbox
	if ((bHovered || ctx->FocusedID == GUI::Hash(id + "s")) && vecFoundElements[GUI::Hash(id)].size() > iSizeInElements && (scrollbar_height != -1 && scrollbar_pos != -1)) {
		if (ctx->FocusedID == 0) {
			if (InputSys::Get()->GetScrollMouse() > 0) {
				iSlider[GUI::Hash(id)] = iSlider[GUI::Hash(id)] + kurwa;
			}
			else if (InputSys::Get()->GetScrollMouse() < 0) {
				iSlider[GUI::Hash(id)] = iSlider[GUI::Hash(id)] - kurwa;
			}
		}

		bool bHoveredScroll = InputSys::Get()->IsInBox(DrawPos + Vector2D(iWidth - 5, scrollbar_pos + 1), Vector2D(4, scrollbar_height));

		static float prev_mouse = 0.f;

		const auto diff = prev_mouse - InputSys::Get()->GetMousePosition().y;

		if (ctx->FocusedID == 0) {
			if (bHoveredScroll && InputHelper::Down(VK_LBUTTON)) {
				ctx->FocusedID = GUI::Hash(id + "s");
			}
		}
		else if (ctx->FocusedID == GUI::Hash(id + "s")) {
			if (InputHelper::Down(VK_LBUTTON)) {
				//iSlider[ GUI::Hash( id ) ] += ( diff / 2 ) * ( fabs( ( kurwa * vecFoundElements[ GUI::Hash( id ) ].size( ) ) - scrollbar_height ) / iSizeInElements );

				const auto scale = [](int in, int bmin, int bmax, int lmin, int lmax) {
					return float((lmax - lmin) * (in - bmin)) / float(bmax - bmin) + lmin;
				};

				// i think not perfect
				auto gs = kurwa * iSizeInElements;
				auto pizdo = std::max(float(float(gs * (gs - 12 * 2))
					/ float((kurwa * vecFoundElements[GUI::Hash(id)].size()) + (gs - 12 * 2))), 30.f);

				iSlider[GUI::Hash(id)] += scale(InputHelper::MouseDelta.y, 0, gs - pizdo, 0, (kurwa * vecFoundElements[GUI::Hash(id)].size()));
			}
			else {
				prev_mouse = 0.f;
				ctx->FocusedID = 0;
			}
		}

		prev_mouse = InputSys::Get()->GetMousePosition().y;

		ctx->hovered_listbox = true;
		iSlider[GUI::Hash(id)] = std::clamp<int>(iSlider[GUI::Hash(id)], ((kurwa * (vecFoundElements[GUI::Hash(id)].size() - 1)) * -1) + (int)(kurwa * iSizeInElements), 0);
	}
	else {
		ctx->hovered_listbox = false;
	}

	if (vecFoundElements[GUI::Hash(id)].size() > iSizeInElements && (scrollbar_height != -1 && scrollbar_pos != -1)) {
		Render::DirectX::rect_fill(DrawPos + Vector2D(iWidth - 6, 1), Vector2D(6, (kurwa * iSizeInElements) - 1), Color(45, 45, 45));
		Render::DirectX::rect_fill(DrawPos + Vector2D(iWidth - 5, scrollbar_pos + 1), Vector2D(4, scrollbar_height), (InputSys::Get()->IsInBox(DrawPos + Vector2D(iWidth - 5, scrollbar_pos + 1), Vector2D(4, scrollbar_height)) || ctx->FocusedID == GUI::Hash(id + "s")) ? Color(80, 80, 80) : Color(65, 65, 65));
	}

	// search
	if (bSearchBar) {
		Render::DirectX::rect_fill(DrawPos - Vector2D(0, 18), Vector2D(iWidth, 19), Color(25, 25, 25, 255 * ctx->animation));

		if (ctx->FocusedID == 0) {
			if (ctx->typing)
				ctx->typing = false;

			if (bHoveredSearch && InputSys::Get()->IsKeyDown(VK_LBUTTON))
				ctx->FocusedID = GUI::Hash(id + XorStr("search"));
		}
		else if (ctx->FocusedID == GUI::Hash(id + XorStr("search"))) {
			if (!ctx->typing)
				ctx->typing = true;

			if (InputSys::Get()->WasKeyPressed(VK_LBUTTON) && !bHoveredSearch) {
				ctx->FocusedID = 0;
			}

			for (int i = 0; i < 255; i++) {
				if (InputHelper::Pressed(i)) {
					if (i != VK_BACK) {
						if (i == VK_ESCAPE || i == VK_RETURN) {
							ctx->FocusedID = 0;
						}
						else if (i >= 'A' && i <= 'Z') {
							szText[GUI::Hash(id)] += ((InputSys::Get()->IsKeyDown(VK_SHIFT)) || GetKeyState(VK_CAPITAL)) ? i : i + 32;
							iSlider[GUI::Hash(id)] = 0;
						}
						else if (i >= '0' && i <= '9' || i == ' ') {
							szText[GUI::Hash(id)] += i;
							iSlider[GUI::Hash(id)] = 0;
						}
					}
					else {
						szText[GUI::Hash(id)] = szText[GUI::Hash(id)].substr(0, szText[GUI::Hash(id)].size() - 1);
						iSlider[GUI::Hash(id)] = 0;
					}
				}

				// left control + backspace = delete every fucking thing
				if (InputHelper::Down(VK_LCONTROL) && GetAsyncKeyState(VK_BACK)) {
					szText[GUI::Hash(id)] = szText[GUI::Hash(id)].substr(0, szText[GUI::Hash(id)].size() - 1);
					iSlider[GUI::Hash(id)] = 0;
				}
			}

			// if we arent holding backspace store the time
			if (!GetAsyncKeyState(VK_BACK)) {
				LastShiftHoldTime[GUI::Hash(id)] = Interfaces::m_pGlobalVars->curtime;
			}

			// the delta between the current time and last "non held shift" time exceeds 500ms,
			// this means that we've been holding shift for 500ms. let's erase.
			if (Interfaces::m_pGlobalVars->curtime - LastShiftHoldTime[GUI::Hash(id)] > 0.5f) {
				szText[GUI::Hash(id)] = szText[GUI::Hash(id)].substr(0, szText[GUI::Hash(id)].size() - 1);
				iSlider[GUI::Hash(id)] = 0;
			}
		}

		D3DVIEWPORT9 clip = { DrawPos.x, DrawPos.y - kurwa, Vector2D(iWidth, kurwa).x, Vector2D(iWidth, kurwa).y - 2, 0.f, 1.0f };
		Render::DirectX::set_scissor_rect(clip); {
			Render::DirectX::Fonts::menu.draw_text((szText[GUI::Hash(id)] + (ctx->FocusedID == GUI::Hash(id + XorStr("search")) ? '_' : ' ')).c_str(), DrawPos - Vector2D(-4, 15), Color(200, 200, 200), 0);
		}
		Render::DirectX::reset_scissor_rect();
	}

	if (bSearchBar) {
		Render::DirectX::rect(DrawPos - Vector2D(0, 18), Vector2D(iWidth, kurwa * iSizeInElements) + Vector2D(0, 18), Color(10, 10, 10));
		Render::DirectX::rect(DrawPos - Vector2D(0, 18), Vector2D(iWidth, 19), Color(10, 10, 10));
		Render::DirectX::rect(DrawPos - Vector2D(0, 18) + 1, Vector2D(iWidth, 19) - 2, Color(50, 50, 50));
		Render::DirectX::rect(DrawPos - Vector2D(0, 18) + 2, Vector2D(iWidth, 19) - 4, Color(16, 16, 16));
	}
	else {
		Render::DirectX::rect(DrawPos, Vector2D(iWidth, kurwa * iSizeInElements), Color(10, 10, 10));
	}

	GUI::PushCursorPos(CursorPos + Vector2D(0, (kurwa * iSizeInElements) + (bSearchBar ? (GUI::ObjectPadding() + kurwa) : GUI::ObjectPadding())));
	return ctx->FocusedID == GUI::Hash(id);
}

#if defined(DEV) || defined(BETA_MODE) || defined(DEBUG_MODE) || defined(LUA_SCRIPTING)
// HAHAHHAHAHAHAHAHHAHAH
bool GUI::Controls::Luabox(const std::string& id, std::vector<std::string> elements, int* option, bool bSearchBar, int iSizeInElements) {
	Vector2D CursorPos = GUI::PopCursorPos();
	Vector2D DrawPos = ctx->pos + CursorPos;

	GUI::PushCursorPos(CursorPos + Vector2D(0, (20 * iSizeInElements) + (bSearchBar ? (GUI::ObjectPadding() + 20) : GUI::ObjectPadding())));
	return ctx->FocusedID == GUI::Hash(id);
}
#endif
```

`CSGO SDK/Menu/Framework/Listbox/Listbox.h`:

```h
#pragma once

namespace GUI::Controls {
	bool Listbox(const std::string& id, std::vector<std::string> elements, int* option, bool bSearchBar, int iSizeInElements);
	bool Luabox(const std::string& id, std::vector<std::string> elements, int* option, bool bSearchBar, int iSizeInElements);
}
```

`CSGO SDK/Menu/Framework/MultiDropdown/MultiDropdown.cpp`:

```cpp
#include "../gui.h"
#include <algorithm>
#include "../../../source.hpp"

void _line(Vector2D pos, bool nigger = false) {
	for (auto i = 5; i >= 2; --i) {
		auto offset = 5 - i;
		Render::DirectX::line(Vector2D(pos.x + offset, pos.y + offset), Vector2D(pos.x + offset + std::clamp(i - offset, 0, 5), pos.y + offset), nigger ? Color(0, 0, 0) : Color(151, 151, 151));
	}
}

bool GUI::Controls::MultiDropdown(const std::string& name, std::vector< MultiItem_t > options, int max_items) {
	Vector2D CursorPos = PopCursorPos();
	Vector2D DrawPos = ctx->pos + CursorPos;
	Vector2D DrawSize = Vector2D(std::min((int)ctx->ParentSize.x - 90, 270), 19);

	DrawPos.x += 20;

	Render::DirectX::Fonts::menu.draw_text(GUI::SplitStr(name, '#')[0].data(), DrawPos + Vector2D(1, -3), Color(203, 203, 203), 4);

	DrawPos.y += 11;

	bool hovered = InputSys::Get()->IsInBox(DrawPos, DrawSize) && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize);

	if (hovered || ctx->MultiDropdownInfo.HashedID == GUI::Hash(name))
		Render::DirectX::gradient_v(DrawPos, DrawSize, { 41, 41, 41 }, { 46, 46, 46 });
	else
		Render::DirectX::gradient_v(DrawPos, DrawSize, { 31, 31, 31 }, { 36, 36, 36 });

	_line(DrawPos + DrawSize - Vector2D(9, 6) - Vector2D(0, 6), true);
	_line(DrawPos + DrawSize - Vector2D(9, 6) + Vector2D(0, 1) - Vector2D(0, 6));

	bool too_long = false;
	char buf[128] = { 0 };
	for (int i = 0; i < options.size(); i++) {
		auto& it = options.at(i).value;

		if (!*it)
			continue;

		strcat(buf, options.at(i).name.data());

		if (i != options.size() - 1)
			strcat(buf, (", "));

		auto max_text_width = DrawSize.x - (25 + Render::DirectX::Fonts::menu.measure_size(XorStr("...")).x);
		if (Render::DirectX::Fonts::menu.measure_size(buf).x > max_text_width) {
			// remove last character until string width is okay
			if (max_text_width >= 1) {
				while (Render::DirectX::Fonts::menu.measure_size(buf).x > max_text_width || buf[strlen(buf) - 1] == ',' || buf[strlen(buf) - 1] == ' ') {
					buf[strlen(buf) - 1] = '\0';
				}
			}

			too_long = true;
			break;
		}
	}

	if (too_long)
		strcat(buf, XorStr("..."));

	if (strlen(buf) == 0)
		strcat(buf, XorStr("-"));

	if (buf[strlen(buf) - 1] == ' ')
		buf[strlen(buf) - 2] = '\0';

	if (buf[strlen(buf) - 1] == ' ')
		buf[strlen(buf) - 2] = '\0';


	Render::DirectX::rect(DrawPos, DrawSize, { 10, 10, 10 });
	Render::DirectX::Fonts::menu.draw_text(buf, DrawPos + Vector2D(10, 4), { 150, 150, 150 }, 0);

	if (ctx->FocusedID == 0) {
		if (hovered && InputHelper::Pressed(VK_LBUTTON))
			ctx->FocusedID = GUI::Hash(name);
	}
	else if (ctx->FocusedID == GUI::Hash(name)) {
		if (hovered) {
			ctx->MultiDropdownInfo.Elements = options;
			ctx->MultiDropdownInfo.Size = DrawSize.x;
			ctx->MultiDropdownInfo.Pos = DrawPos + Vector2D(0, DrawSize.y + 3);
			ctx->MultiDropdownInfo.HashedID = GUI::Hash(name);
		}
	}

	GUI::PushCursorPos(CursorPos + Vector2D(0, DrawSize.y + GUI::ObjectPadding() + 12));
	return true;
}

```

`CSGO SDK/Menu/Framework/MultiDropdown/MultiDropdown.h`:

```h
#pragma once

namespace GUI::Controls {
	bool MultiDropdown(const std::string& name, std::vector< MultiItem_t > values, int max_items = 10);
}

```

`CSGO SDK/Menu/Framework/Slider/Slider.cpp`:

```cpp
#include <algorithm>
#include "../gui.h"
#include "../../../source.hpp"

bool GUI::Controls::Slider(const std::string& name, float* var_name, float min, float max, const std::string& display, float increment) {
	Vector2D CursorPos = PopCursorPos();
	Vector2D DrawPos = ctx->pos + CursorPos;
	Vector2D DrawSize(std::min((int)ctx->ParentSize.x - 90, 270), 6);

	DrawPos.x += 20;

	Render::DirectX::Fonts::menu.draw_text(GUI::SplitStr(name, '#')[0].data(), DrawPos + Vector2D(0, -3), Color(203, 203, 203), 4);

	DrawPos.y += 11;

	bool hovered = InputSys::Get()->IsInBox(DrawPos, DrawSize + Vector2D(0, 1)) && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize);

	if (hovered && ctx->FocusedID != GUI::Hash(name))
		Render::DirectX::gradient_v(DrawPos + 1, DrawSize - 1, { 57, 57, 57 }, { 73, 73, 73 });
	else
		Render::DirectX::gradient_v(DrawPos + 1, DrawSize - 1, { 52, 52, 52 }, { 68, 68, 68 });

	float width = GUI::MapNumber(*var_name, min, max, 0, DrawSize.x);
	Render::DirectX::gradient_v(DrawPos + 1, Vector2D(width + 1, DrawSize.y) - 1, g_Vars.menu.ascent.ToRegularColor(), g_Vars.menu.ascent.ToRegularColor() * 0.75f);

	Render::DirectX::rect(DrawPos, DrawSize, { 10, 10, 10 });

	char buf[32];
	sprintf_s(buf, display.c_str(), *var_name);

	Vector2D tooltip_size = Render::DirectX::Fonts::menu_bold.measure_size(buf);
	Render::DirectX::Fonts::menu_bold.draw_text(buf, DrawPos + Vector2D(width - (tooltip_size.x / 2), DrawSize.y - 6), Color(203, 203, 203), 8);

	if (ctx->FocusedID == 0) {
		if (hovered && InputHelper::Pressed(VK_LBUTTON))
			ctx->FocusedID = GUI::Hash(name);
	}
	else if (ctx->FocusedID == GUI::Hash(name)) {
		if (InputHelper::Down(VK_LBUTTON)) {
			float offset = std::clamp<float>(Vector2D(InputSys::Get()->GetMousePosition() - DrawPos).x, 0, DrawSize.x);
			*var_name = GUI::MapNumber(offset, 0, DrawSize.x, min, max);
		}
		else {
			ctx->FocusedID = 0;
		}
	}

	PushCursorPos(CursorPos + Vector2D(0, DrawSize.y + 12 + GUI::ObjectPadding()));
	return ctx->FocusedID == GUI::Hash(name);
}

bool GUI::Controls::Slider(const std::string& name, int* var_name, int min, int max, const std::string& display, int increment) {
	Vector2D CursorPos = PopCursorPos();
	Vector2D DrawPos = ctx->pos + CursorPos;
	Vector2D DrawSize(std::min((int)ctx->ParentSize.x - 90, 270), 6);

	DrawPos.x += 20;

	Render::DirectX::Fonts::menu.draw_text(GUI::SplitStr(name, '#')[0].data(), DrawPos + Vector2D(0, -3), Color(203, 203, 203), 4);

	DrawPos.y += 11;

	bool hovered = InputSys::Get()->IsInBox(DrawPos, DrawSize + Vector2D(0, 1)) && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize);

	if (hovered && ctx->FocusedID != GUI::Hash(name))
		Render::DirectX::gradient_v(DrawPos + 1, DrawSize - 1, { 57, 57, 57 }, { 73, 73, 73 });
	else
		Render::DirectX::gradient_v(DrawPos + 1, DrawSize - 1, { 52, 52, 52 }, { 68, 68, 68 });

	int width = GUI::MapNumber(*var_name, min, max, 0, DrawSize.x);
	Render::DirectX::gradient_v(DrawPos + 1, Vector2D(width + 1, DrawSize.y) - 1, g_Vars.menu.ascent.ToRegularColor(), g_Vars.menu.ascent.ToRegularColor() * 0.75f);

	Render::DirectX::rect(DrawPos, DrawSize, { 10, 10, 10 });

	char buf[32];
	sprintf_s(buf, display.c_str(), *var_name);

	Vector2D tooltip_size = Render::DirectX::Fonts::menu_bold.measure_size(buf);
	Render::DirectX::Fonts::menu_bold.draw_text(buf, DrawPos + Vector2D(width - (tooltip_size.x / 2), DrawSize.y - 6), Color(203, 203, 203), 8);

	if (ctx->FocusedID == 0) {
		if (hovered && InputHelper::Pressed(VK_LBUTTON))
			ctx->FocusedID = GUI::Hash(name);
	}
	else if (ctx->FocusedID == GUI::Hash(name)) {
		if (InputHelper::Down(VK_LBUTTON)) {
			int offset = std::floor<int>(std::clamp<int>(Vector2D(InputSys::Get()->GetMousePosition() - DrawPos).x, 0, DrawSize.x));
			*var_name = (GUI::MapNumber(offset, 0, DrawSize.x, min, max));
		}
		else {
			ctx->FocusedID = 0;
		}
	}

	PushCursorPos(CursorPos + Vector2D(0, DrawSize.y + 12 + GUI::ObjectPadding()));
	return ctx->FocusedID == GUI::Hash(name);
}
```

`CSGO SDK/Menu/Framework/Slider/Slider.h`:

```h
#pragma once

namespace GUI::Controls {
	bool Slider(const std::string& name, float* var_name, float min, float max, const std::string& display = "%.1f", float increment = 1.f);
	bool Slider(const std::string& name, int* var_name, int min, int max, const std::string& display = "%d", int increment = 1);
	//int Slider( const std::string &name, int *var_name, int min, int max, const std::string &display = "%.0f" );
}

```

`CSGO SDK/Menu/Framework/Textbox/Textbox.cpp`:

```cpp
#include <algorithm>
#include "../gui.h"
#include "../../../source.hpp"

std::map< int, std::string > _szText;
std::map<size_t, float> _LastShiftHoldTime;

bool GUI::Controls::Textbox(const std::string& name, std::string* input, int max_text) {
	Vector2D CursorPos = PopCursorPos();
	Vector2D DrawPos = ctx->pos + CursorPos;

	Vector2D DrawSize(std::min((int)ctx->ParentSize.x - 90, 270), 18);

	if (_szText.find(GUI::Hash(name)) == _szText.end()) {
		_szText.insert({ GUI::Hash(name), "" });
	}

	if (_LastShiftHoldTime.find(GUI::Hash(name)) == _LastShiftHoldTime.end()) {
		_LastShiftHoldTime.insert({ GUI::Hash(name), 0.f });
	}

	DrawPos.x += 20;

	Render::DirectX::Fonts::menu.draw_text(name, DrawPos + Vector2D(1, -3), Color(203, 203, 203), 4);

	DrawPos.y += 11;

	int iWidth = DrawSize.x;
	bool bHoveredSearch = InputSys::Get()->IsInBox(DrawPos, Vector2D(iWidth, DrawSize.y)) && InputSys::Get()->IsInBox(ctx->ParentPos, ctx->ParentSize);

	// search
	Render::DirectX::rect_fill(DrawPos, Vector2D(iWidth + 1, DrawSize.y), Color(25, 25, 25, 255 * ctx->animation));

	if (ctx->FocusedID == 0) {
		if (ctx->typing)
			ctx->typing = false;

		if (bHoveredSearch && InputSys::Get()->IsKeyDown(VK_LBUTTON))
			ctx->FocusedID = GUI::Hash(name);
	}
	else if (ctx->FocusedID == GUI::Hash(name)) {
		if (!ctx->typing)
			ctx->typing = true;

		if (InputSys::Get()->WasKeyPressed(VK_LBUTTON) && !bHoveredSearch) {
			ctx->FocusedID = 0;
		}

		for (int i = 0; i < 255; i++) {
			if (InputHelper::Pressed(i)) {
				if (i != VK_BACK) {
					if (i == VK_ESCAPE || i == VK_RETURN) {
						ctx->FocusedID = 0;
					}
					else if (i >= 'A' && i <= 'Z') {
						_szText[GUI::Hash(name)] += ((InputSys::Get()->IsKeyDown(VK_SHIFT)) || GetKeyState(VK_CAPITAL)) ? i : i + 32;
					}
					else if (i >= '0' && i <= '9' || i == ' ') {
						_szText[GUI::Hash(name)] += i;
					}
				}
				else {
					_szText[GUI::Hash(name)] = _szText[GUI::Hash(name)].substr(0, _szText[GUI::Hash(name)].size() - 1);
				}
			}

			// left control + backspace = delete every fucking thing
			if (InputHelper::Down(VK_LCONTROL) && GetAsyncKeyState(VK_BACK)) {
				_szText[GUI::Hash(name)] = _szText[GUI::Hash(name)].substr(0, _szText[GUI::Hash(name)].size() - 1);
			}
		}

		// if we arent holding backspace store the time
		if (!GetAsyncKeyState(VK_BACK)) {
			_LastShiftHoldTime[GUI::Hash(name)] = Interfaces::m_pGlobalVars->curtime;
		}

		// the delta between the current time and last "non held shift" time exceeds 500ms,
		// this means that we've been holding shift for 500ms. let's erase.
		if (Interfaces::m_pGlobalVars->curtime - _LastShiftHoldTime[GUI::Hash(name)] > 0.5f) {
			_szText[GUI::Hash(name)] = _szText[GUI::Hash(name)].substr(0, _szText[GUI::Hash(name)].size() - 1);
		}
	}

	D3DVIEWPORT9 clip = { DrawPos.x, DrawPos.y + 1, Vector2D(iWidth, DrawSize.y).x, Vector2D(iWidth, DrawSize.y).y - 2, 0.f, 1.0f };

	Render::DirectX::rect(DrawPos, Vector2D(iWidth, DrawSize.y), Color(10, 10, 10));
	Render::DirectX::rect(DrawPos + 1, Vector2D(iWidth, DrawSize.y) - 2, Color(60, 60, 60));
	Render::DirectX::rect(DrawPos + 2, Vector2D(iWidth, DrawSize.y) - 4, Color(16, 16, 16));

	_szText[GUI::Hash(name)] = _szText[GUI::Hash(name)].substr(0, max_text);
	*input = _szText[GUI::Hash(name)];

	Render::DirectX::set_scissor_rect(clip); {
		Render::DirectX::Fonts::menu.draw_text((_szText[GUI::Hash(name)] + (ctx->FocusedID == GUI::Hash(name) ? '_' : ' ')).c_str(), DrawPos + Vector2D(5, 3), Color(200, 200, 200), 0);
	}
	Render::DirectX::reset_scissor_rect();

	PushCursorPos(CursorPos + Vector2D(0, DrawSize.y + Render::DirectX::Fonts::menu.measure_size(name).y + GUI::ObjectPadding()));
	return ctx->FocusedID == GUI::Hash(name);
}
```

`CSGO SDK/Menu/Framework/Textbox/Textbox.h`:

```h
#pragma once

namespace GUI::Controls {
	bool Textbox(const std::string& name, std::string* input, int max_text = 24);
}

```

`CSGO SDK/Menu/Helpers/Easing.h`:

```h
#pragma once

namespace Easing {
#define M_PI       3.14159265358979323846   // pi

	__forceinline double InSine(const double t) {
		return sin(1.5707963 * t);
	}

	__forceinline double OutSine(double t) {
		return 1 + sin(1.5707963 * (--t));
	}

	__forceinline double InOutSine(const double t) {
		return 0.5 * (1 + sin(3.1415926 * (t - 0.5)));
	}

	__forceinline double InQuad(const double t) {
		return t * t;
	}

	__forceinline double OutQuad(const double t) {
		return t * (2 - t);
	}

	__forceinline double InOutQuad(const double t) {
		return t < 0.5 ? 2 * t * t : t * (4 - 2 * t) - 1;
	}

	__forceinline double InCubic(const double t) {
		return t * t * t;
	}

	__forceinline double OutCubic(double t) {
		return 1 + (--t) * t * t;
	}

	__forceinline double InOutCubic(double t) {
		return t < 0.5 ? 4 * t * t * t : 1 + (--t) * (2 * (--t)) * (2 * t);
	}

	__forceinline double InQuart(double t) {
		t *= t;
		return t * t;
	}

	__forceinline double OutQuart(double t) {
		t = (--t) * t;
		return 1 - t * t;
	}

	__forceinline double InOutQuart(double t) {
		if (t < 0.5) {
			t *= t;
			return 8 * t * t;
		}
		else {
			t = (--t) * t;
			return 1 - 8 * t * t;
		}
	}

	__forceinline double InQuint(const double t) {
		const double t2 = t * t;
		return t * t2 * t2;
	}

	__forceinline double OutQuint(double t) {
		const double t2 = (--t) * t;
		return 1 + t * t2 * t2;
	}

	__forceinline double InOutQuint(double t) {
		double t2;
		if (t < 0.5) {
			t2 = t * t;
			return 16 * t * t2 * t2;
		}
		else {
			t2 = (--t) * t;
			return 1 + 16 * t * t2 * t2;
		}
	}

	__forceinline double InExpo(const double t) {
		return (pow(2, 8 * t) - 1) / 255;
	}

	__forceinline double OutExpo(const double t) {
		return 1 - pow(2, -8 * t);
	}

	__forceinline double InOutExpo(const double t) {
		if (t < 0.5) {
			return (pow(2, 16 * t) - 1) / 510;
		}
		else {
			return 1 - 0.5 * pow(2, -16 * (t - 0.5));
		}
	}

	__forceinline double InCirc(const double t) {
		return 1 - sqrt(1 - t);
	}

	__forceinline double OutCirc(const double t) {
		return sqrt(t);
	}

	__forceinline double InOutCirc(const double t) {
		if (t < 0.5) {
			return (1 - sqrt(1 - 2 * t)) * 0.5;
		}
		else {
			return (1 + sqrt(2 * t - 1)) * 0.5;
		}
	}

	__forceinline double InBack(const double t) {
		return t * t * (2.70158 * t - 1.70158);
	}

	__forceinline double OutBack(double t) {
		return 1 + (--t) * t * (2.70158 * t + 1.70158);
	}

	__forceinline double InOutBack(double t) {
		if (t < 0.5) {
			return t * t * (7 * t - 2.5) * 2;
		}
		else {
			return 1 + (--t) * t * 2 * (7 * t + 2.5);
		}
	}

	__forceinline double InElastic(const double t) {
		const double t2 = t * t;
		return t2 * t2 * sin(t * M_PI * 4.5);
	}

	__forceinline double OutElastic(const double t) {
		const double t2 = (t - 1) * (t - 1);
		return 1 - t2 * t2 * cos(t * M_PI * 4.5);
	}

	__forceinline double InOutElastic(const double t) {
		double t2;
		if (t < 0.45) {
			t2 = t * t;
			return 8 * t2 * t2 * sin(t * M_PI * 9);
		}
		else if (t < 0.55) {
			return 0.5 + 0.75 * sin(t * M_PI * 4);
		}
		else {
			t2 = (t - 1) * (t - 1);
			return 1 - 8 * t2 * t2 * sin(t * M_PI * 9);
		}
	}

	__forceinline double InBounce(const double t) {
		return pow(2, 6 * (t - 1)) * abs(sin(t * M_PI * 3.5));
	}

	__forceinline double OutBounce(const double t) {
		return 1 - pow(2, -6 * t) * abs(cos(t * M_PI * 3.5));
	}

	__forceinline double InOutBounce(const double t) {
		if (t < 0.5) {
			return 8 * pow(2, 8 * (t - 1)) * abs(sin(t * M_PI * 7));
		}
		else {
			return 1 - 8 * pow(2, -8 * t) * abs(sin(t * M_PI * 7));
		}
	}
}
```

`CSGO SDK/Menu/Helpers/InputHelper.cpp`:

```cpp
#include "InputHelper.h"
#include "../../source.hpp"

#include <Windows.h>

void InputHelper::Update() {
	if (GetForegroundWindow() == Interfaces::hWindow) {
		for (int i = 0; i < 256; i++) {
			PrevKeyState[i] = KeyState[i];
			KeyState[i] = GetAsyncKeyState(i);
		}
	}

	static HWND window;
	if (!window)
		window = FindWindowA(XorStr("Valve001"), 0);

	POINT mouse;
	GetCursorPos(&mouse);
	ScreenToClient(window, &mouse);

	MouseDelta = MousePos - Vector2D(mouse.x, mouse.y);

	MousePos = Vector2D(mouse.x, mouse.y);
}

bool InputHelper::Down(int key) {
	return KeyState[key] && PrevKeyState[key];
}

bool InputHelper::Pressed(int key) {
	return KeyState[key] && !PrevKeyState[key];
}

bool InputHelper::Released(int key) {
	return !KeyState[key] && PrevKeyState[key];
}
```

`CSGO SDK/Menu/Helpers/InputHelper.h`:

```h
#pragma once
#include "../../SDK/Valve/vector2d.hpp"

namespace InputHelper {
	inline bool KeyState[256];
	inline bool PrevKeyState[256];

	inline int Scroll;

	inline Vector2D MousePos;
	inline Vector2D MouseDelta;

	void Update();
	bool Pressed(int key);
	bool Down(int key);
	bool Released(int key);
}
```

`CSGO SDK/Renderer/Render.cpp`:

```cpp
#define NOMINMAX
#include "render.hpp"
#include <algorithm>
#include <mutex>

#include <unordered_map>
#include "../source.hpp"

#include "../Utils/XorStr.hpp"

#include "Textures/titlebar.h"
#include "Textures/weaponicons.h"

#pragma region DirectXRenderer

IDirect3DDevice9* Render::DirectX::device;
IDirect3DStateBlock9* Render::DirectX::state_block;
IDirect3DVertexDeclaration9* Render::DirectX::vert_dec;
IDirect3DVertexShader9* Render::DirectX::vert_shader;
IDirect3DVertexBuffer9* Render::DirectX::vert_buf;

bool Render::DirectX::initialized;
std::vector<font*> Render::DirectX::font_arr;

void Render::DirectX::set_render_states() {
	device->SetVertexShader(nullptr);
	device->SetPixelShader(nullptr);
	device->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
	device->SetRenderState(D3DRS_LIGHTING, FALSE);
	device->SetRenderState(D3DRS_FOGENABLE, FALSE);
	device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	device->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);

	device->SetRenderState(D3DRS_ZENABLE, FALSE);
	device->SetRenderState(D3DRS_SCISSORTESTENABLE, TRUE);
	device->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	device->SetRenderState(D3DRS_STENCILENABLE, FALSE);

	device->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
	device->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, FALSE);

	device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	device->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	device->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, TRUE);
	device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	device->SetRenderState(D3DRS_SRCBLENDALPHA, D3DBLEND_INVDESTALPHA);
	device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	device->SetRenderState(D3DRS_DESTBLENDALPHA, D3DBLEND_ONE);

	device->SetRenderState(D3DRS_SRGBWRITEENABLE, FALSE);
	device->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN |
		D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA);
}

void LoadFontFromResource(char* arr, const size_t size) {
	DWORD n_fonts;
	AddFontMemResourceEx(arr, size, nullptr, &n_fonts);
}

void Render::DirectX::init(IDirect3DDevice9* dev) {
	device = dev;

	LoadFontFromResource(menuicons, sizeof(menuicons));

	font_arr.push_back(&Fonts::menu);
	font_arr.push_back(&Fonts::menu_bold);
	font_arr.push_back(&Fonts::menu_small);
	font_arr.push_back(&Fonts::menu_pixel);
	font_arr.push_back(&Fonts::menu_icon);

	for (auto font : font_arr) {
		font->setup(device);
		font->init();
	}

	Textures::background->setup(device, background_texture, sizeof(background_texture), 2000, 2000);

	initialized = true;
}

void Render::DirectX::invalidate() {
	for (auto font : font_arr) {
		font->invalidate();
	}

	Textures::background->invalidate();
	Textures::logo->invalidate();
}

void Render::DirectX::restore(IDirect3DDevice9* dev) {
	device = dev;

	for (auto font : font_arr) {
		font->setup(device);
		font->init();
	}

	Textures::background->setup(device, background_texture, sizeof(background_texture), 2000, 2000);
}

void Render::DirectX::set_viewport(D3DVIEWPORT9 vp) {
	device->SetViewport(&vp);
}

D3DVIEWPORT9 Render::DirectX::get_viewport() {
	D3DVIEWPORT9 vp;
	device->GetViewport(&vp);
	return vp;
}

void Render::DirectX::set_scissor_rect(D3DVIEWPORT9 vp) {
	RECT rec;
	rec.left = static_cast<LONG>(vp.X);
	rec.top = static_cast<LONG>(vp.Y);
	rec.right = static_cast<LONG>(vp.X + vp.Width);
	rec.bottom = static_cast<LONG>(vp.Y + vp.Height);

	device->SetRenderState(D3DRS_SCISSORTESTENABLE, TRUE);
	device->SetScissorRect(&rec);
}

D3DVIEWPORT9 Render::DirectX::get_scissor_rect() {
	RECT rec;
	device->GetScissorRect(&rec);

	D3DVIEWPORT9 vp = { rec.left, rec.top, rec.right, rec.bottom, 0.f, 1.0f };
	return vp;
}

void Render::DirectX::reset_scissor_rect() {
	RECT rec;
	rec.left = static_cast<LONG>(0);
	rec.top = static_cast<LONG>(0);
	rec.right = static_cast<LONG>(Render::GetScreenSize().x);
	rec.bottom = static_cast<LONG>(Render::GetScreenSize().y);

	device->SetScissorRect(&rec);
	device->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
}

struct vertice {
	float x, y, z, rhw;
	DWORD c;
};

void Render::DirectX::rect(Vector2D pos, Vector2D size, Color c) {
	vertice verts[5] = {
		{ int(pos.x), int(pos.y), 0.01f, 0.01f, c.ToARGB() },
		{ int(pos.x + size.x), int(pos.y), 0.01f, 0.01f, c.ToARGB() },
		{ int(pos.x + size.x), int(pos.y + size.y), 0.01f, 0.01f, c.ToARGB() },
		{ int(pos.x), int(pos.y + size.y), 0.01f, 0.01f, c.ToARGB() },
		{ int(pos.x), int(pos.y), 0.01f, 0.01f, c.ToARGB() }
	};

	device->SetTexture(0, nullptr);
	device->DrawPrimitiveUP(D3DPT_LINESTRIP, 4, &verts, 20);
}

void Render::DirectX::rect_fill(Vector2D pos, Vector2D size, Color c) {
	vertice verts[4] = {
		{ int(pos.x), int(pos.y), 0.01f, 0.01f, c.ToARGB() },
		{ int(pos.x + size.x), int(pos.y), 0.01f, 0.01f, c.ToARGB() },
		{ int(pos.x), int(pos.y + size.y), 0.01f, 0.01f, c.ToARGB() },
		{ int(pos.x + size.x), int(pos.y + size.y), 0.01f, 0.01f, c.ToARGB() }
	};

	device->SetTexture(0, nullptr);
	device->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &verts, 20);
}

void Render::DirectX::triangle(Vector2D pos1, Vector2D pos2, Vector2D pos3, Color c) {
	vertice verts[4] = {
		{ int(pos1.x), int(pos1.y), 0.01f, 0.01f, c.ToARGB() },
		{ int(pos2.x), int(pos2.y), 0.01f, 0.01f, c.ToARGB() },
		{ int(pos3.x), int(pos3.y), 0.01f, 0.01f, c.ToARGB() },
		{ int(pos1.x), int(pos1.y), 0.01f, 0.01f, c.ToARGB() },
	};

	device->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
	device->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, TRUE);
	device->SetTexture(0, nullptr);
	device->DrawPrimitiveUP(D3DPT_LINESTRIP, 3, &verts, 20);
	device->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
	device->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, FALSE);
}

void Render::DirectX::triangle_filled(Vector2D pos1, Vector2D pos2, Vector2D pos3, Color c) {
	vertice verts[3] = {
		{ int(pos1.x), int(pos1.y), 0.01f, 0.01f, c.ToARGB() },
		{ int(pos2.x), int(pos2.y), 0.01f, 0.01f, c.ToARGB() },
		{ int(pos3.x), int(pos3.y), 0.01f, 0.01f, c.ToARGB() },
	};

	device->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
	device->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, TRUE);
	device->SetTexture(0, nullptr);
	device->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 1, &verts, 20);
	device->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
	device->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, FALSE);
}

void Render::DirectX::polygon_gradient(Vector2D pos1, Vector2D pos2, Vector2D pos3, Vector2D pos4, Color c_a, Color c_b) {
	vertice verts[4] = {
		{ int(pos1.x), int(pos1.y), 0.01f, 0.01f, c_a.ToARGB() },
		{ int(pos2.x), int(pos2.y), 0.01f, 0.01f, c_a.ToARGB() },
		{ int(pos3.x), int(pos3.y), 0.01f, 0.01f, c_b.ToARGB() },
		{ int(pos4.x), int(pos4.y), 0.01f, 0.01f, c_b.ToARGB() },
	};

	device->SetTexture(0, nullptr);
	device->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &verts, 20);
}

void Render::DirectX::gradient_v(Vector2D pos, Vector2D size, Color c_a, Color c_b) {
	vertice verts[4] = {
		{ int(pos.x), int(pos.y), 0.01f, 0.01f, c_a.ToARGB() },
		{ int(pos.x + size.x), int(pos.y), 0.01f, 0.01f, c_a.ToARGB() },
		{ int(pos.x), int(pos.y + size.y), 0.01f, 0.01f, c_b.ToARGB() },
		{ int(pos.x + size.x), int(pos.y + size.y), 0.01f, 0.01f, c_b.ToARGB() }
	};

	device->SetTexture(0, nullptr);
	device->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &verts, 20);
}

void Render::DirectX::gradient_multi_color(Vector2D pos, Vector2D size, Color c_a, Color c_b, Color c_c, Color c_d) {
	vertice verts[5] = {
		{ int(pos.x), int(pos.y), 0.01f, 0.01f, c_a.ToARGB() },
		{ int(pos.x + size.x), int(pos.y), 0.01f, 0.01f, c_b.ToARGB() },
		{ int(pos.x + size.x), int(pos.y + size.y), 0.01f, 0.01f, c_c.ToARGB() },
		{ int(pos.x), int(pos.y + size.y), 0.01f, 0.01f, c_d.ToARGB() },
		{ int(pos.x), int(pos.y), 0.01f, 0.01f, c_a.ToARGB() }
	};

	device->SetTexture(0, nullptr);
	device->DrawPrimitiveUP(D3DPT_LINESTRIP, 4, &verts, 20);
}

void Render::DirectX::gradient_multi_color_filled(Vector2D pos, Vector2D size, Color c_a, Color c_b, Color c_c, Color c_d) {
	vertice verts[4] = {
		{ int(pos.x), int(pos.y), 0.01f, 0.01f, c_a.ToARGB() },
		{ int(pos.x + size.x), int(pos.y), 0.01f, 0.01f, c_b.ToARGB() },
		{ int(pos.x), int(pos.y + size.y), 0.01f, 0.01f, c_c.ToARGB() },
		{ int(pos.x + size.x), int(pos.y + size.y), 0.01f, 0.01f, c_d.ToARGB() }
	};

	device->SetTexture(0, nullptr);
	device->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &verts, 20);
}

void Render::DirectX::gradient_h(Vector2D pos, Vector2D size, Color c_a, Color c_b) {
	vertice verts[4] = {
		{ int(pos.x), int(pos.y), 0.01f, 0.01f, c_a.ToARGB() },
		{ int(pos.x + size.x), int(pos.y), 0.01f, 0.01f, c_b.ToARGB() },
		{ int(pos.x), int(pos.y + size.y), 0.01f, 0.01f, c_a.ToARGB() },
		{ int(pos.x + size.x), int(pos.y + size.y), 0.01f, 0.01f, c_b.ToARGB() }
	};

	device->SetTexture(0, nullptr);
	device->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, &verts, 20);
}

void Render::DirectX::line(Vector2D a, Vector2D b, Color c) {
	vertice verts[2] = {
		{ (int)a.x, (int)a.y, 0.01f, 0.01f, c.ToARGB() },
		{ (int)b.x, (int)b.y, 0.01f, 0.01f, c.ToARGB() }
	};

	device->SetTexture(0, nullptr);
	device->DrawPrimitiveUP(D3DPT_LINELIST, 1, &verts, 20);
}

void Render::DirectX::arc(Vector2D center, float radius, float multiplier, Color c, bool antialias) {
	const auto d3d_col = c.ToARGB();
	const float pi = D3DX_PI * multiplier;
	const auto step_angle = pi / 180;
	const auto segments = 64;
	const auto verts = (vertice*)_malloca(sizeof(vertice) * (segments + 2));

	if (verts == nullptr)
		return;

	for (auto i = 0; i < segments + 2; i++) {
		verts[i].x = (center.x - radius * std::cos(i * (2 * pi / segments)));
		verts[i].y = (center.y - radius * std::sin(i * (2 * pi / segments)));
		verts[i].z = 0;
		verts[i].rhw = 1;
		verts[i].c = d3d_col;
	}

	for (auto i = 0; i < segments + 2; i++) {
		verts[i].x = center.x + std::cos(step_angle) * (verts[i].x - center.x) - std::sin(step_angle) * (verts[i].y - center.y);
		verts[i].y = center.y + std::sin(step_angle) * (verts[i].x - center.x) + std::cos(step_angle) * (verts[i].y - center.y);
	}

	device->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, antialias);
	device->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, antialias);

	device->SetTexture(0, nullptr);
	device->DrawPrimitiveUP(D3DPT_LINESTRIP, segments, verts, 20);

	device->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
	device->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, FALSE);
}

void Render::DirectX::circle_filled(Vector2D center, float radius, int rotate, int type, bool smoothing, int resolution, Color c) {
	device->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
	device->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, TRUE);

	std::vector<vertice> circle(resolution + 2);
	float angle = rotate * D3DX_PI / 180;
	float pi;

	if (type == 0) pi = D3DX_PI;        // Full circle
	if (type == 1) pi = D3DX_PI / 2;      // 1/2 circle
	if (type == 2) pi = D3DX_PI / 4;   // 1/4 circle

	circle[0].x = center.x;
	circle[0].y = center.y;
	circle[0].z = 0;
	circle[0].rhw = 1;
	circle[0].c = c.ToARGB();

	for (int i = 1; i < resolution + 2; i++) {
		circle[i].x = (float)(center.x - radius * cos(pi * ((i - 1) / (resolution / 2.0f))));
		circle[i].y = (float)(center.y - radius * sin(pi * ((i - 1) / (resolution / 2.0f))));
		circle[i].z = 0;
		circle[i].rhw = 1;
		circle[i].c = c.ToARGB();
	}

	// Rotate matrix
	int _res = resolution + 2;

	// Want smoke? blow me Nigga
	for (int i = 0; i < _res; i++) {
		circle[i].x = center.x + cos(angle) * (circle[i].x - center.x) - sin(angle) * (circle[i].y - center.y);
		circle[i].y = center.y + sin(angle) * (circle[i].x - center.x) - cos(angle) * (circle[i].y - center.y);
	}

	device->CreateVertexBuffer((resolution + 2) * sizeof(vertice), D3DUSAGE_WRITEONLY, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &vert_buf, NULL);

	void* pVertices;
	vert_buf->Lock(0, (resolution + 2) * sizeof(vertice), (void**)&pVertices, 0);
	memcpy(pVertices, &circle[0], (resolution + 2) * sizeof(vertice));
	vert_buf->Unlock();

	device->SetTexture(0, NULL);
	device->SetPixelShader(NULL);
	device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	device->SetStreamSource(0, vert_buf, 0, sizeof(vertice));
	device->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
	device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, resolution);

	if (vert_buf != NULL)
		vert_buf->Release();

	device->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
	device->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, FALSE);
}

void Render::DirectX::circle_gradient(Vector2D center, float radius, int rotate, int type, int resolution, Color color, Color color2) {
	LPDIRECT3DVERTEXBUFFER9 g_pVB2;

	std::vector<vertice> circle(resolution + 2);

	float angle = rotate * D3DX_PI / 180, pi = D3DX_PI;

	circle[0].x = center.x;
	circle[0].y = center.y;
	circle[0].z = 0;
	circle[0].rhw = 1;
	circle[0].c = color2.ToARGB();

	for (int i = 1; i < resolution + 2; i++)
	{
		circle[i].x = (float)(center.x - radius * cos(pi * ((i - 1) / (resolution / 2.0f))));
		circle[i].y = (float)(center.y - radius * sin(pi * ((i - 1) / (resolution / 2.0f))));
		circle[i].z = 0;
		circle[i].rhw = 1;
		circle[i].c = color.ToARGB();
	}

	// Rotate matrix 
	int _res = resolution + 2;
	for (int i = 0; i < _res; i++)
	{
		circle[i].x = center.x + cos(angle) * (circle[i].x - center.x) - sin(angle) * (circle[i].y - center.y);
		circle[i].y = center.y + sin(angle) * (circle[i].x - center.x) + cos(angle) * (circle[i].y - center.y);
	}

	device->CreateVertexBuffer((resolution + 2) * sizeof(vertice), D3DUSAGE_WRITEONLY, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &g_pVB2, NULL);

	VOID* pVertices;
	g_pVB2->Lock(0, (resolution + 2) * sizeof(vertice), (void**)&pVertices, 0);
	memcpy(pVertices, &circle[0], (resolution + 2) * sizeof(vertice));
	g_pVB2->Unlock();

	device->SetTexture(0, NULL);
	device->SetPixelShader(NULL);
	device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	device->SetStreamSource(0, g_pVB2, 0, sizeof(vertice));
	device->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
	device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, resolution);
	if (g_pVB2 != NULL)
		g_pVB2->Release();
}

void Render::DirectX::begin() {
	device->CreateStateBlock(D3DSBT_PIXELSTATE, &state_block);

	state_block->Capture();
	device->GetVertexDeclaration(&vert_dec);
	device->GetVertexShader(&vert_shader);

	set_render_states();
}

void Render::DirectX::end() {
	state_block->Apply();
	state_block->Release();

	device->SetVertexDeclaration(vert_dec);
	device->SetVertexShader(vert_shader);
}
#pragma endregion

#pragma region EngineRender

// ctor.
Render::Engine::Font::Font(const std::string& name, int s, int w, int flags) {
	m_handle = Interfaces::m_pSurface->CreateFont_();
	Interfaces::m_pSurface->SetFontGlyphSet(m_handle, name.data(), s, w, 0, 0, flags);
	m_size = size(XorStr("A"));
}

// ctor.
Render::Engine::Font::Font(HFont font) {
	m_handle = font;
	m_size = size(XorStr("A"));
}

void Render::Engine::Font::string(int x, int y, Color color, const std::string& text, StringFlags_t flags /*= Render::DirectX::ALIGN_LEFT */) {
	wstring(x, y, color, Math::MultiByteToWide(text), flags);
}

//void Render::Engine::Font::string( int x, int y, Color color, const std::stringstream& text, StringFlags_t flags /*= Render::DirectX::ALIGN_LEFT */ ) {
//	wstring( x, y, color, Math::MultiByteToWide( text.str( ) ), flags );
//}

void Render::Engine::Font::wstring(int x, int y, Color color, const std::wstring& text, StringFlags_t flags /*= Render::DirectX::ALIGN_LEFT */) {
	int w, h;

	Interfaces::m_pSurface->GetTextSize(m_handle, text.c_str(), w, h);
	Interfaces::m_pSurface->DrawSetTextFont(m_handle);
	Interfaces::m_pSurface->DrawSetTextColor(color);

	if (flags & Render::Engine::ALIGN_RIGHT)
		x -= w;

	if (flags & Render::Engine::ALIGN_CENTER)
		x -= w / 2;

	Interfaces::m_pSurface->DrawSetTextPos(x, y);
	Interfaces::m_pSurface->DrawPrintText(text.c_str(), (int)text.size());
}

Render::Engine::FontSize_t Render::Engine::Font::size(const std::string& text) {
	return wsize(Math::MultiByteToWide(text));
}

Render::Engine::FontSize_t Render::Engine::Font::wsize(const std::wstring& text) {
	FontSize_t res;
	Interfaces::m_pSurface->GetTextSize(m_handle, text.data(), res.m_width, res.m_height);
	return res;
}

namespace Render::Engine {
	Font esp;
	Font pixel;
	Font pixel_reg;
	Font console;
	Font hud;
	Font segoe;
	Font cs;
	Font cs_large;
	Font damage;
	Font icon;
	Font indi;
	Font watermark;

	int m_width;
	int m_height;
}

void Render::Engine::Initialise() {
	LoadFontFromResource(weaponicons, sizeof(weaponicons));

	esp = Font(XorStr("Verdana"), 12, FW_NORMAL, FONTFLAG_ANTIALIAS | FONTFLAG_DROPSHADOW);
	segoe = Font(XorStr("Small Fonts"), 8, FW_NORMAL, FONTFLAG_OUTLINE);
	pixel = Font(XorStr("Small Fonts"), 8, FW_NORMAL, FONTFLAG_OUTLINE);
	pixel_reg = Font(XorStr("Small Fonts"), 8, FW_NORMAL, FONTFLAG_OUTLINE);
	console = Font(XorStr("Lucida Console"), 10, FW_DONTCARE, FONTFLAG_DROPSHADOW);
	hud = Font(XorStr("Lucida Console"), 10, FW_DONTCARE, FONTFLAG_DROPSHADOW);
	cs = Font(XorStr("WeaponIcons"), 14, FW_NORMAL, FONTFLAG_ANTIALIAS | FONTFLAG_DROPSHADOW);
	cs_large = Font(XorStr("WeaponIcons"), 22, FW_NORMAL, FONTFLAG_ANTIALIAS | FONTFLAG_DROPSHADOW);
	damage = Font(XorStr("Segoe UI"), 26, FW_THIN, FONTFLAG_ANTIALIAS | FONTFLAG_DROPSHADOW);
	indi = Font(XorStr("Verdana"), 26, FW_BOLD, FONTFLAG_ANTIALIAS | FONTFLAG_DROPSHADOW);
	watermark = Font(XorStr("Verdana"), 12, FW_NORMAL, FONTFLAG_ANTIALIAS | FONTFLAG_DROPSHADOW);

	Interfaces::m_pEngine->GetScreenSize(m_width, m_height);
}

bool Render::Engine::WorldToScreen(const Vector& world, Vector2D& screen) {
	float w;
	static ptrdiff_t ptrViewMatrix;
	if (!ptrViewMatrix) {
		ptrViewMatrix = static_cast<ptrdiff_t>(Memory::Scan(XorStr("client.dll"), XorStr("0F 10 05 ? ? ? ? 8D 85 ? ? ? ? B9")));
		ptrViewMatrix += 0x3;
		ptrViewMatrix = *reinterpret_cast<uintptr_t*>(ptrViewMatrix);
		ptrViewMatrix += 176;
	}

	const VMatrix& matrix = *(VMatrix*)ptrViewMatrix;

	// check if it's in view first.
	// note - dex; w is below 0 when world position is around -90 / +90 from the player's camera on the y axis.
	w = matrix[3][0] * world.x + matrix[3][1] * world.y + matrix[3][2] * world.z + matrix[3][3];
	if (w < 0.001f)
		return false;

	// calculate x and y.
	screen.x = matrix[0][0] * world.x + matrix[0][1] * world.y + matrix[0][2] * world.z + matrix[0][3];
	screen.y = matrix[1][0] * world.x + matrix[1][1] * world.y + matrix[1][2] * world.z + matrix[1][3];

	screen /= w;

	// calculate screen position.
	screen.x = (m_width / 2) + (screen.x * m_width) / 2;
	screen.y = (m_height / 2) - (screen.y * m_height) / 2;

	return true;
}

void Render::Engine::Line(Vector2D v0, Vector2D v1, Color color) {
	Interfaces::m_pSurface->DrawSetColor(color);
	Interfaces::m_pSurface->DrawLine(v0.x, v0.y, v1.x, v1.y);
}

void Render::Engine::Polygon(int count, Vertex_t* vertices, const Color& col) {
	static int texture_id;

	if (!Interfaces::m_pSurface->IsTextureIDValid(texture_id))
		texture_id = Interfaces::m_pSurface->CreateNewTextureID();

	Interfaces::m_pSurface->DrawSetColor(col.RGBA[0], col.RGBA[1], col.RGBA[2], col.RGBA[3]);
	Interfaces::m_pSurface->DrawSetTexture(texture_id);
	Interfaces::m_pSurface->DrawTexturedPolygon(count, vertices);
}

void Render::Engine::FilledTriangle(const Vector2D& pos1, const Vector2D& pos2, const Vector2D& pos3, const Color& col) {
	static Vertex_t triangle_vert[3];

	triangle_vert[0].Init(pos1);
	triangle_vert[1].Init(pos2);
	triangle_vert[2].Init(pos3);

	Polygon(3, triangle_vert, col);
}

void Render::Engine::WorldCircle(Vector origin, float radius, Color color, Color colorFill) {
	std::vector<Vector> Points3D;
	float step = static_cast<float>(M_PI) * 2.0f / 256;

	for (float a = 0; a < (M_PI * 2.0f); a += step) {
		Vector start(radius * cosf(a) + origin.x, radius * sinf(a) + origin.y, origin.z);
		Vector end(radius * cosf(a + step) + origin.x, radius * sinf(a + step) + origin.y, origin.z);

		Vector2D out, out1, pos3d;

		if (Render::Engine::WorldToScreen(end, out1) && Render::Engine::WorldToScreen(start, out)) {
			if (colorFill.a() && Render::Engine::WorldToScreen(origin, pos3d)) {
				FilledTriangle(out, out1, pos3d, colorFill);
			}

			Line(out, out1, color);
		}
	}
}

void Render::Engine::Line(int x0, int y0, int x1, int y1, Color color) {
	Interfaces::m_pSurface->DrawSetColor(color);
	Interfaces::m_pSurface->DrawLine(x0, y0, x1, y1);
}

void Render::Engine::Rect(int x, int y, int w, int h, Color color) {
	Interfaces::m_pSurface->DrawSetColor(color);
	Interfaces::m_pSurface->DrawOutlinedRect(x, y, x + w, y + h);
}

void Render::Engine::RectFilled(int x, int y, int w, int h, Color color) {
	Interfaces::m_pSurface->DrawSetColor(color);
	Interfaces::m_pSurface->DrawFilledRect(x, y, x + w, y + h);
}

void Render::Engine::RectFilled(Vector2D pos, Vector2D size, Color color) {
	Render::Engine::RectFilled(pos.x, pos.y, size.x, size.y, color);
}

void Render::Engine::RectOutlined(int x, int y, int w, int h, Color color, Color color2) {
	Rect(x, y, w, h, color);
	Rect(x - 1, y - 1, w + 2, h + 2, color2);
	Rect(x + 1, y + 1, w - 2, h - 2, color2);
}

// thanks nitro
void Render::Engine::CircleFilled(int x, int y, float radius, int segments, Color color)
{
	static int texture = Interfaces::m_pSurface->CreateNewTextureID(true);

	Interfaces::m_pSurface->DrawSetTextureRGBA(texture, Color::White().RGBA, 1, 1);
	Interfaces::m_pSurface->DrawSetColor(color);
	Interfaces::m_pSurface->DrawSetTexture(texture);

	std::vector< Vertex_t > vertices{ };

	float step = (M_PI * 2.f) / segments;
	for (float i{ 0.f }; i < (M_PI * 2.f); i += step)
		vertices.emplace_back(Vector2D{ x + (radius * std::cos(i)), y + (radius * std::sin(i)) });

	Interfaces::m_pSurface->DrawTexturedPolygon(vertices.size(), vertices.data());

	Interfaces::m_pSurface->DrawSetColor(color);
	Interfaces::m_pSurface->DrawOutlinedCircle(x, y, radius, segments);
}

void Render::Engine::Gradient(int x, int y, int w, int h, Color color, Color color2, bool horizontal)
{
	Interfaces::m_pSurface->DrawSetColor(color);
	Interfaces::m_pSurface->DrawFilledRectFade(x, y, x + w, y + h, color.a(), color.a(), horizontal);

	Interfaces::m_pSurface->DrawSetColor(color2);
	Interfaces::m_pSurface->DrawFilledRectFade(x, y, x + w, y + h, color2.a(), color2.a(), horizontal);
}

#pragma endregion

Vector2D Render::GetScreenSize() {
	return Vector2D(Render::Engine::m_width, Render::Engine::m_height);
}
```

`CSGO SDK/Renderer/Render.hpp`:

```hpp
#pragma once
#include <string>
#include <sstream>

#include "../SDK/sdk.hpp"
#include "../SDK/Valve/vector4d.hpp"

#include "Wrapper/font/font.h"
#include "Wrapper/sprite/sprite.h"

#include <d3d9.h>
#include <d3dx9.h>
#pragma comment(lib, "d3dx9.lib")

using TextureID = void*;
using ColorU32 = uint32_t;
using Rect2D = Vector4D;
using FontHandle = std::size_t;

struct IDirect3DDevice9;

enum text_flags : int {
	CENTER_X = (1 << 0),
	CENTER_Y = (1 << 1),
	ALIGN_RIGHT = (1 << 2),
	ALIGN_BOTTOM = (1 << 3),
	DROP_SHADOW = (1 << 4),
	OUTLINED = (1 << 5),
};

enum : uint32_t {
	FONT_VERDANA = 0,
	FONT_MENU_BOLD = FONT_VERDANA,
	FONT_MENU = FONT_VERDANA,
	FONT_CSGO_ICONS,
	FONT_VERDANA_30_BOLD,
	FONT_VERDANA_25_REGULAR,
	FONT_VISITOR,
	FONT_PORTER,
	FONT_CSGO_ICONS2,
	FONT_VERDANA_40_BOLD,
};

namespace Render {
	namespace DirectX {
		extern IDirect3DDevice9* device;
		extern IDirect3DStateBlock9* state_block;
		extern IDirect3DVertexDeclaration9* vert_dec;
		extern IDirect3DVertexShader9* vert_shader;
		extern IDirect3DVertexBuffer9* vert_buf;
		extern std::vector<font*> font_arr;

		namespace Fonts {
			inline font menu(XorStr("Verdana"), 12, 500, true);
			inline font menu_small(XorStr("Small Fonts"), 9, 500);
			inline font menu_pixel(XorStr("Small Fonts"), 9, 500);
			inline font menu_bold(XorStr("Verdana"), 12, 700, true);
			inline font menu_icon(XorStr("fonteditor"), 50, 500, true);
		}

		namespace Textures {
			inline c_sprite* background = new c_sprite();
			inline c_sprite* logo = new c_sprite();
		}

		extern bool initialized;

		void set_render_states();

		void init(IDirect3DDevice9* p_device);

		void invalidate();

		void restore(IDirect3DDevice9* p_device);

		void set_viewport(D3DVIEWPORT9 vp);
		D3DVIEWPORT9 get_viewport();

		void set_scissor_rect(D3DVIEWPORT9 vp);
		D3DVIEWPORT9 get_scissor_rect();
		void reset_scissor_rect();

		// drawing functions

		void rect(Vector2D pos, Vector2D size, Color c);
		void rect_fill(Vector2D pos, Vector2D size, Color c);;

		void triangle(Vector2D pos1, Vector2D pos2, Vector2D pos3, Color c);
		void triangle_filled(Vector2D pos1, Vector2D pos2, Vector2D pos3, Color c);

		void polygon_gradient(Vector2D pos1, Vector2D pos2, Vector2D pos3, Vector2D pos4, Color c_a, Color c_b);

		void gradient_v(Vector2D pos, Vector2D size, Color c_a, Color c_b);
		void gradient_h(Vector2D pos, Vector2D size, Color c_a, Color c_b);

		void gradient_multi_color_filled(Vector2D pos, Vector2D size, Color c_a, Color c_b, Color c_c, Color c_d);
		void gradient_multi_color(Vector2D pos, Vector2D size, Color c_a, Color c_b, Color c_c, Color c_d);

		void line(Vector2D a, Vector2D b, Color c);

		void circle_filled(Vector2D center, float radius, int rotate, int type, bool smoothing, int resolution, Color c);
		void arc(Vector2D center, float radius, float multiplier, Color c, bool antialias = true);
		void circle_gradient(Vector2D center, float radius, int rotate, int type, int resolution, Color c, Color c1);

		void begin();
		void end();
	}

	namespace Engine {
		struct FontSize_t {
			int m_width;
			int m_height;
		};

		enum StringFlags_t {
			ALIGN_LEFT = 0,
			ALIGN_RIGHT,
			ALIGN_CENTER
		};

		class Font {
		public:
			HFont      m_handle;
			FontSize_t m_size;

		public:
			__forceinline Font() : m_handle{ }, m_size{ } {};

			Font(const std::string& name, int s, int w, int flags);
			Font(HFont font);

			void string(int x, int y, Color color, const std::string& text, StringFlags_t flags = ALIGN_LEFT);
			//void string( int x, int y, Color color, const std::stringstream& text, StringFlags_t flags = ALIGN_LEFT );
			void wstring(int x, int y, Color color, const std::wstring& text, StringFlags_t flags = ALIGN_LEFT);
			FontSize_t size(const std::string& text);
			FontSize_t wsize(const std::wstring& text);
		};

		extern Font esp;
		extern Font pixel;
		extern Font pixel_reg;
		extern Font console;
		extern Font hud;
		extern Font segoe;
		extern Font cs;
		extern Font cs_large;
		extern Font damage;
		extern Font icon;
		extern Font indi;
		extern Font watermark;

		extern int m_width;
		extern int m_height;

		void Initialise();
		bool WorldToScreen(const Vector& world, Vector2D& screen);
		void Line(Vector2D v0, Vector2D v1, Color color);
		void Polygon(int count, Vertex_t* vertices, const Color& col);
		void FilledTriangle(const Vector2D& pos1, const Vector2D& pos2, const Vector2D& pos3, const Color& col);
		void WorldCircle(Vector origin, float radius, Color color, Color colorFill = { });
		void Line(int x0, int y0, int x1, int y1, Color color);
		void Rect(int x, int y, int w, int h, Color color);
		void RectFilled(int x, int y, int w, int h, Color color);
		void RectFilled(Vector2D pos, Vector2D size, Color color);
		void RectOutlined(int x, int y, int w, int h, Color color, Color color2);
		void CircleFilled(int x, int y, float radius, int segments, Color color);
		void Gradient(int x, int y, int w, int h, Color color, Color color2, bool horizontal = false);
	}

	Vector2D GetScreenSize();
};


```

`CSGO SDK/Renderer/Textures/titlebar.h`:

```h
#pragma once

inline static char menuicons[ ] = {
	0x00, 0x01, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x80, 0x00, 0x03, 0x00, 0x20,
	0x4F, 0x53, 0x2F, 0x32, 0x56, 0xD3, 0x75, 0x81, 0x00, 0x00, 0x00, 0xAC,
	0x00, 0x00, 0x00, 0x60, 0x63, 0x6D, 0x61, 0x70, 0x08, 0x17, 0x05, 0xF3,
	0x00, 0x00, 0x01, 0x0C, 0x00, 0x00, 0x01, 0x42, 0x67, 0x6C, 0x79, 0x66,
	0x8F, 0xB5, 0x8C, 0x16, 0x00, 0x00, 0x02, 0x50, 0x00, 0x00, 0x0B, 0x18,
	0x68, 0x65, 0x61, 0x64, 0x1A, 0x1D, 0x09, 0x17, 0x00, 0x00, 0x0D, 0x68,
	0x00, 0x00, 0x00, 0x36, 0x68, 0x68, 0x65, 0x61, 0x07, 0x36, 0x02, 0xE1,
	0x00, 0x00, 0x0D, 0xA0, 0x00, 0x00, 0x00, 0x24, 0x68, 0x6D, 0x74, 0x78,
	0x19, 0xB3, 0x01, 0x52, 0x00, 0x00, 0x0D, 0xC4, 0x00, 0x00, 0x00, 0x20,
	0x6C, 0x6F, 0x63, 0x61, 0x0C, 0xF8, 0x09, 0xD0, 0x00, 0x00, 0x0D, 0xE4,
	0x00, 0x00, 0x00, 0x12, 0x6D, 0x61, 0x78, 0x70, 0x00, 0x14, 0x01, 0x21,
	0x00, 0x00, 0x0D, 0xF8, 0x00, 0x00, 0x00, 0x20, 0x6E, 0x61, 0x6D, 0x65,
	0x19, 0x52, 0xA5, 0xCC, 0x00, 0x00, 0x0E, 0x18, 0x00, 0x00, 0x01, 0xAD,
	0x70, 0x6F, 0x73, 0x74, 0x00, 0xD8, 0x00, 0x7D, 0x00, 0x00, 0x0F, 0xC8,
	0x00, 0x00, 0x00, 0x32, 0x00, 0x04, 0x03, 0x36, 0x01, 0x90, 0x00, 0x05,
	0x00, 0x00, 0x02, 0x99, 0x02, 0xCC, 0x00, 0x00, 0x00, 0x8F, 0x02, 0x99,
	0x02, 0xCC, 0x00, 0x00, 0x01, 0xEB, 0x00, 0x33, 0x01, 0x09, 0x00, 0x00,
	0x02, 0x00, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x50, 0x66, 0x45, 0x64, 0x00, 0xC0, 0x00, 0x41, 0x00, 0x47,
	0x03, 0x2C, 0xFF, 0x2C, 0x00, 0x5C, 0x03, 0x2C, 0x00, 0xD4, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x1C, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C,
	0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x04, 0x00, 0x20,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x47,
	0xFF, 0xFF, 0x00, 0x00, 0x00, 0x41, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x22, 0x00, 0x00, 0x01, 0x32,
	0x02, 0xAA, 0x00, 0x03, 0x00, 0x07, 0x00, 0x00, 0x37, 0x11, 0x21, 0x11,
	0x27, 0x33, 0x11, 0x23, 0x22, 0x01, 0x10, 0xEE, 0xCC, 0xCC, 0x00, 0x02,
	0xAA, 0xFD, 0x56, 0x22, 0x02, 0x66, 0x00, 0x00, 0x00, 0x08, 0x00, 0x37,
	0x00, 0x32, 0x03, 0x02, 0x02, 0xA9, 0x00, 0x0A, 0x00, 0x1A, 0x00, 0x25,
	0x00, 0x32, 0x00, 0x3D, 0x00, 0x4B, 0x00, 0x74, 0x00, 0xC9, 0x00, 0x00,
	0x01, 0x36, 0x32, 0x16, 0x15, 0x14, 0x23, 0x22, 0x26, 0x35, 0x34, 0x37,
	0x36, 0x33, 0x32, 0x17, 0x16, 0x15, 0x14, 0x07, 0x06, 0x23, 0x22, 0x27,
	0x26, 0x35, 0x34, 0x37, 0x36, 0x33, 0x32, 0x15, 0x14, 0x07, 0x23, 0x22,
	0x35, 0x34, 0x35, 0x36, 0x33, 0x32, 0x17, 0x14, 0x32, 0x15, 0x14, 0x06,
	0x22, 0x35, 0x34, 0x27, 0x36, 0x33, 0x32, 0x15, 0x14, 0x07, 0x06, 0x23,
	0x22, 0x34, 0x05, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 0x33, 0x32,
	0x37, 0x36, 0x35, 0x34, 0x27, 0x26, 0x23, 0x0E, 0x03, 0x07, 0x06, 0x07,
	0x06, 0x14, 0x0E, 0x01, 0x16, 0x33, 0x32, 0x17, 0x16, 0x33, 0x32, 0x37,
	0x36, 0x17, 0x16, 0x36, 0x17, 0x16, 0x37, 0x36, 0x32, 0x27, 0x26, 0x37,
	0x36, 0x35, 0x34, 0x26, 0x2B, 0x01, 0x06, 0x27, 0x3E, 0x01, 0x37, 0x33,
	0x32, 0x1F, 0x01, 0x33, 0x32, 0x17, 0x16, 0x15, 0x14, 0x07, 0x06, 0x0F,
	0x01, 0x17, 0x16, 0x1D, 0x01, 0x14, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x15,
	0x14, 0x17, 0x16, 0x33, 0x32, 0x15, 0x14, 0x07, 0x06, 0x23, 0x22, 0x27,
	0x26, 0x23, 0x22, 0x07, 0x06, 0x15, 0x14, 0x17, 0x16, 0x33, 0x32, 0x36,
	0x33, 0x36, 0x33, 0x32, 0x15, 0x14, 0x06, 0x07, 0x06, 0x15, 0x14, 0x17,
	0x16, 0x15, 0x14, 0x07, 0x06, 0x23, 0x22, 0x27, 0x2E, 0x01, 0x35, 0x34,
	0x37, 0x36, 0x35, 0x34, 0x27, 0x26, 0x35, 0x34, 0x02, 0x99, 0x04, 0x0A,
	0x0B, 0x06, 0x07, 0x0D, 0x1D, 0x03, 0x03, 0x04, 0x10, 0x11, 0x01, 0x03,
	0x02, 0x04, 0x10, 0x12, 0x09, 0x06, 0x14, 0x2B, 0x1E, 0x0B, 0x1E, 0x0E,
	0x06, 0x05, 0x04, 0x01, 0x1C, 0x12, 0x16, 0x05, 0x05, 0x0A, 0x04, 0x07,
	0x08, 0x05, 0xFE, 0xDB, 0x08, 0x16, 0x14, 0x24, 0x16, 0x1A, 0x14, 0x0D,
	0x0D, 0x9C, 0x03, 0x04, 0x03, 0x11, 0x0A, 0x0C, 0x02, 0x06, 0x10, 0x0E,
	0x0A, 0x02, 0x05, 0x05, 0x0A, 0x0D, 0x0E, 0x0B, 0x03, 0x02, 0x0E, 0x0E,
	0x0B, 0x1D, 0x06, 0x07, 0x08, 0x07, 0x17, 0x04, 0x04, 0x07, 0x01, 0x30,
	0x10, 0x02, 0x0D, 0x6F, 0x20, 0x2A, 0x37, 0x06, 0x57, 0x3D, 0x1C, 0x60,
	0x5F, 0x1A, 0x1C, 0x10, 0x0E, 0x53, 0x4E, 0x02, 0x03, 0x03, 0x08, 0x08,
	0x0D, 0x10, 0x04, 0x08, 0x09, 0x18, 0x0B, 0x0C, 0x05, 0x02, 0x0B, 0x0A,
	0x1B, 0x25, 0x10, 0x07, 0x0E, 0x0F, 0x15, 0x02, 0x0C, 0x03, 0x06, 0x0D,
	0x12, 0x19, 0x0D, 0x0F, 0x01, 0x02, 0x12, 0x24, 0x29, 0x49, 0x61, 0x22,
	0x14, 0x05, 0x06, 0x0C, 0x11, 0x02, 0x07, 0x09, 0x0E, 0x08, 0x10, 0x11,
	0x08, 0x03, 0x18, 0x06, 0x0F, 0x12, 0x0A, 0x04, 0x02, 0x06, 0x0F, 0x12,
	0x0A, 0x03, 0x28, 0x06, 0x0D, 0x0B, 0x01, 0x0C, 0x02, 0x3B, 0x0E, 0x07,
	0x01, 0x01, 0x08, 0x1E, 0x06, 0x0A, 0x22, 0x05, 0x0E, 0x06, 0x04, 0x0A,
	0x18, 0xB9, 0x09, 0x11, 0x0D, 0x0B, 0x15, 0x06, 0x09, 0x13, 0x0C, 0xB6,
	0x05, 0x01, 0x03, 0x03, 0x07, 0x05, 0x0E, 0x02, 0x01, 0x20, 0x07, 0x09,
	0x05, 0x20, 0x1C, 0x01, 0x04, 0x08, 0x08, 0x17, 0x03, 0x06, 0x10, 0x0F,
	0x0D, 0x0D, 0x0D, 0x01, 0x05, 0x0F, 0x30, 0x05, 0x08, 0x1D, 0x0E, 0x02,
	0x32, 0x19, 0x0A, 0x0B, 0x08, 0x06, 0x0A, 0x0C, 0x04, 0x04, 0x10, 0x1E,
	0x10, 0x0C, 0x07, 0x07, 0x03, 0x01, 0x01, 0x11, 0x0A, 0x08, 0x04, 0x09,
	0x31, 0x1B, 0x19, 0x1E, 0x09, 0x09, 0x10, 0x07, 0x03, 0x04, 0x0C, 0x0C,
	0x01, 0x01, 0x03, 0x09, 0x30, 0x11, 0x13, 0x0D, 0x08, 0x05, 0x0B, 0x02,
	0x0B, 0x0D, 0x1A, 0x56, 0x1D, 0x1A, 0x12, 0x0B, 0x1D, 0x23, 0x10, 0x18,
	0x39, 0x4D, 0x31, 0x51, 0x00, 0x03, 0x00, 0x06, 0xFF, 0xAC, 0x03, 0x45,
	0x02, 0xEB, 0x00, 0x0C, 0x00, 0x3F, 0x00, 0x66, 0x00, 0x00, 0x01, 0x35,
	0x33, 0x15, 0x33, 0x15, 0x23, 0x15, 0x23, 0x35, 0x22, 0x31, 0x35, 0x13,
	0x22, 0x23, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x07,
	0x3B, 0x01, 0x15, 0x2B, 0x01, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x22, 0x33,
	0x35, 0x33, 0x15, 0x33, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x35, 0x23,
	0x35, 0x33, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x27, 0x26, 0x23,
	0x15, 0x23, 0x35, 0x33, 0x15, 0x32, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x17,
	0x33, 0x15, 0x23, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x23, 0x15, 0x23, 0x35,
	0x22, 0x27, 0x2E, 0x01, 0x2F, 0x01, 0x2B, 0x01, 0x35, 0x3B, 0x01, 0x37,
	0x3E, 0x01, 0x37, 0x36, 0x37, 0x01, 0x99, 0x18, 0x2F, 0x2F, 0x18, 0x30,
	0x32, 0x0A, 0x0B, 0x13, 0x0C, 0x45, 0x7D, 0x28, 0x15, 0x21, 0x02, 0x03,
	0x01, 0x13, 0x14, 0x14, 0x12, 0x02, 0x01, 0x06, 0xBB, 0x88, 0x10, 0x1E,
	0x19, 0x12, 0x22, 0x2D, 0x5A, 0x7C, 0x12, 0x06, 0x2A, 0x2A, 0x02, 0x16,
	0x0D, 0x25, 0x9C, 0x3B, 0x0D, 0x0F, 0x0B, 0x0B, 0x16, 0x15, 0x16, 0x21,
	0x6C, 0xA6, 0x1A, 0x05, 0x01, 0x2C, 0x2C, 0x03, 0x0F, 0xAA, 0x76, 0x1D,
	0x15, 0x19, 0x16, 0x15, 0x7E, 0xB4, 0x0C, 0x03, 0x0D, 0x1D, 0x1D, 0x0B,
	0x08, 0x17, 0xB2, 0x72, 0x1C, 0x0E, 0x01, 0x4F, 0x37, 0x37, 0x16, 0x33,
	0x33, 0x16, 0x01, 0x5F, 0x02, 0x02, 0x0B, 0x53, 0x3D, 0x1F, 0x59, 0x1A,
	0x12, 0x0C, 0x16, 0x12, 0x0A, 0x76, 0xC0, 0x08, 0x2F, 0x2F, 0x03, 0x0E,
	0x1F, 0x90, 0x60, 0x21, 0x19, 0x16, 0x23, 0x4E, 0x19, 0x4D, 0x6D, 0x06,
	0x02, 0x02, 0x01, 0x2C, 0x69, 0x2C, 0x05, 0x12, 0xA5, 0x66, 0x1D, 0x20,
	0x17, 0x23, 0x79, 0xB9, 0x14, 0x05, 0x2F, 0x2F, 0x03, 0x0E, 0xBC, 0x81,
	0x20, 0x17, 0x36, 0x73, 0xA6, 0x0D, 0x03, 0x01, 0x00, 0x0A, 0x00, 0x00,
	0xFF, 0x2B, 0x03, 0xAC, 0x02, 0xC5, 0x00, 0x10, 0x00, 0x29, 0x00, 0x2E,
	0x00, 0x33, 0x00, 0x38, 0x00, 0x3D, 0x00, 0x42, 0x00, 0x47, 0x00, 0x4C,
	0x00, 0x51, 0x00, 0x00, 0x01, 0x26, 0x07, 0x26, 0x27, 0x16, 0x1D, 0x02,
	0x33, 0x36, 0x37, 0x3E, 0x01, 0x35, 0x34, 0x26, 0x27, 0x36, 0x33, 0x32,
	0x17, 0x1E, 0x01, 0x17, 0x16, 0x15, 0x14, 0x07, 0x06, 0x0F, 0x01, 0x23,
	0x22, 0x27, 0x2E, 0x01, 0x35, 0x34, 0x37, 0x3E, 0x01, 0x03, 0x2F, 0x01,
	0x37, 0x1F, 0x01, 0x33, 0x15, 0x07, 0x27, 0x11, 0x37, 0x17, 0x15, 0x23,
	0x01, 0x17, 0x07, 0x23, 0x35, 0x01, 0x3F, 0x01, 0x17, 0x07, 0x01, 0x0F,
	0x01, 0x27, 0x37, 0x13, 0x1F, 0x01, 0x07, 0x27, 0x01, 0x27, 0x37, 0x33,
	0x15, 0x02, 0x2D, 0x24, 0x0B, 0x08, 0x1F, 0x01, 0x20, 0x26, 0x24, 0x42,
	0x47, 0x53, 0xEC, 0x1A, 0x25, 0x38, 0x28, 0x53, 0x6B, 0x12, 0x04, 0x45,
	0x35, 0x7C, 0x1A, 0x1E, 0x0F, 0x27, 0x6C, 0x84, 0x21, 0x18, 0x75, 0xC9,
	0x0F, 0x03, 0x5C, 0x12, 0xD9, 0x20, 0x10, 0x10, 0x10, 0x10, 0x20, 0x01,
	0xE2, 0x05, 0x05, 0x87, 0xFD, 0x64, 0x07, 0x10, 0x54, 0x18, 0x02, 0x50,
	0x06, 0x10, 0x54, 0x17, 0x50, 0x0F, 0x04, 0x5C, 0x13, 0xFD, 0x3D, 0x05,
	0x05, 0x87, 0x01, 0xE2, 0x0D, 0x03, 0x03, 0x01, 0x2B, 0x6D, 0x63, 0xED,
	0x04, 0x12, 0x20, 0x78, 0x44, 0x4C, 0x7F, 0x58, 0x06, 0x0C, 0x1A, 0x7B,
	0x58, 0x1B, 0x0F, 0x66, 0x5E, 0x47, 0x22, 0x06, 0x0A, 0x19, 0xA6, 0x66,
	0x47, 0x41, 0x31, 0x5D, 0xFD, 0x97, 0x06, 0x10, 0x54, 0x17, 0x45, 0x87,
	0x05, 0x05, 0x03, 0x90, 0x05, 0x05, 0x87, 0xFE, 0xD3, 0x10, 0x10, 0x20,
	0x01, 0x35, 0x0F, 0x03, 0x5C, 0x12, 0xFD, 0xD5, 0x0F, 0x04, 0x5C, 0x13,
	0x02, 0x31, 0x06, 0x10, 0x54, 0x17, 0xFE, 0xF8, 0x10, 0x10, 0x20, 0x00,
	0x00, 0x06, 0x00, 0x35, 0xFF, 0xE0, 0x03, 0x6A, 0x02, 0xD5, 0x00, 0x0D,
	0x00, 0x4F, 0x00, 0x60, 0x00, 0xC9, 0x00, 0xD8, 0x01, 0x20, 0x00, 0x00,
	0x25, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x17, 0x16, 0x33, 0x32, 0x36,
	0x35, 0x34, 0x27, 0x36, 0x33, 0x32, 0x17, 0x16, 0x33, 0x32, 0x3F, 0x01,
	0x17, 0x16, 0x15, 0x14, 0x07, 0x06, 0x15, 0x14, 0x33, 0x32, 0x14, 0x23,
	0x22, 0x15, 0x14, 0x17, 0x16, 0x15, 0x14, 0x0F, 0x01, 0x27, 0x26, 0x22,
	0x07, 0x06, 0x23, 0x22, 0x27, 0x26, 0x35, 0x34, 0x37, 0x36, 0x35, 0x34,
	0x27, 0x26, 0x23, 0x22, 0x35, 0x34, 0x36, 0x35, 0x3E, 0x01, 0x37, 0x36,
	0x37, 0x36, 0x35, 0x34, 0x27, 0x26, 0x35, 0x34, 0x27, 0x26, 0x23, 0x22,
	0x07, 0x06, 0x15, 0x14, 0x16, 0x33, 0x32, 0x36, 0x35, 0x34, 0x27, 0x2E,
	0x01, 0x27, 0x36, 0x33, 0x32, 0x16, 0x17, 0x16, 0x17, 0x16, 0x33, 0x32,
	0x37, 0x36, 0x33, 0x32, 0x17, 0x16, 0x14, 0x07, 0x06, 0x15, 0x14, 0x17,
	0x1E, 0x01, 0x15, 0x14, 0x06, 0x15, 0x0E, 0x01, 0x07, 0x06, 0x07, 0x06,
	0x15, 0x14, 0x17, 0x16, 0x15, 0x14, 0x06, 0x23, 0x22, 0x27, 0x26, 0x23,
	0x22, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x07, 0x06, 0x23, 0x22, 0x27, 0x2E,
	0x01, 0x27, 0x26, 0x23, 0x22, 0x0F, 0x01, 0x27, 0x26, 0x35, 0x34, 0x37,
	0x36, 0x35, 0x34, 0x27, 0x26, 0x23, 0x22, 0x26, 0x3D, 0x01, 0x3F, 0x01,
	0x3E, 0x01, 0x37, 0x36, 0x35, 0x34, 0x27, 0x26, 0x35, 0x34, 0x37, 0x36,
	0x33, 0x32, 0x17, 0x16, 0x33, 0x32, 0x37, 0x36, 0x35, 0x34, 0x25, 0x26,
	0x23, 0x22, 0x07, 0x06, 0x15, 0x14, 0x17, 0x16, 0x33, 0x32, 0x36, 0x35,
	0x34, 0x27, 0x36, 0x33, 0x32, 0x17, 0x16, 0x33, 0x32, 0x3F, 0x01, 0x17,
	0x1E, 0x01, 0x15, 0x14, 0x06, 0x15, 0x06, 0x15, 0x14, 0x16, 0x1F, 0x01,
	0x15, 0x07, 0x0E, 0x01, 0x15, 0x14, 0x17, 0x16, 0x15, 0x14, 0x07, 0x06,
	0x23, 0x22, 0x27, 0x26, 0x23, 0x22, 0x07, 0x06, 0x23, 0x22, 0x27, 0x26,
	0x2F, 0x01, 0x37, 0x36, 0x35, 0x34, 0x27, 0x2E, 0x01, 0x35, 0x34, 0x36,
	0x35, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x35, 0x34, 0x27, 0x26, 0x35, 0x37,
	0x36, 0x02, 0xEA, 0x10, 0x14, 0x16, 0x20, 0x03, 0x0C, 0x2B, 0x15, 0x1B,
	0x85, 0x16, 0x02, 0x01, 0x18, 0x16, 0x0C, 0x0C, 0x12, 0x14, 0x19, 0x18,
	0x06, 0x01, 0x26, 0x20, 0x20, 0x26, 0x01, 0x06, 0x18, 0x19, 0x14, 0x12,
	0x1D, 0x13, 0x12, 0x07, 0x06, 0x0A, 0x1F, 0x06, 0x08, 0x08, 0x0B, 0x12,
	0x21, 0x01, 0x01, 0x07, 0x11, 0x18, 0x0C, 0x08, 0x08, 0x07, 0xDC, 0x1D,
	0x1D, 0x2F, 0x22, 0x1B, 0x3E, 0x30, 0x2C, 0x3F, 0x02, 0x04, 0x1C, 0x79,
	0x0C, 0x24, 0x1F, 0x14, 0x05, 0x04, 0x06, 0x06, 0x0C, 0x11, 0x17, 0x15,
	0x07, 0x08, 0x1F, 0x1C, 0x16, 0x07, 0x28, 0x1C, 0x0F, 0x01, 0x02, 0x0D,
	0x1F, 0x1B, 0x08, 0x06, 0x0F, 0x15, 0x3E, 0x07, 0x03, 0x1B, 0x15, 0x0B,
	0x07, 0x04, 0x0B, 0x08, 0x03, 0x04, 0x05, 0x04, 0x2A, 0x2F, 0x06, 0x05,
	0x08, 0x0F, 0x0A, 0x05, 0x08, 0x18, 0x1F, 0x21, 0x21, 0x11, 0x0F, 0x09,
	0x08, 0x18, 0x18, 0x12, 0x02, 0x24, 0x17, 0x0F, 0x04, 0x02, 0x11, 0x10,
	0x22, 0x17, 0x0B, 0x08, 0x1A, 0x14, 0x09, 0x03, 0x08, 0x17, 0x01, 0xDC,
	0x13, 0x0E, 0x0B, 0x0E, 0x1E, 0x16, 0x10, 0x13, 0x15, 0x1F, 0x8B, 0x11,
	0x09, 0x0D, 0x10, 0x12, 0x0C, 0x0C, 0x13, 0x16, 0x18, 0x0F, 0x09, 0x01,
	0x03, 0x0A, 0x16, 0x1F, 0x1A, 0x17, 0x11, 0x04, 0x07, 0x13, 0x14, 0x08,
	0x0C, 0x11, 0x13, 0x0A, 0x0C, 0x12, 0x11, 0x0C, 0x04, 0x03, 0x13, 0x0D,
	0x0E, 0x0C, 0x08, 0x21, 0x16, 0x0F, 0x01, 0x01, 0x08, 0x15, 0x16, 0x0F,
	0x06, 0x08, 0x01, 0x03, 0xA4, 0x10, 0x20, 0x15, 0x09, 0x09, 0x21, 0x1E,
	0x15, 0x17, 0x7A, 0x0D, 0x18, 0x16, 0x18, 0x19, 0x0F, 0x0E, 0x13, 0x0D,
	0x17, 0x03, 0x05, 0x1D, 0x4E, 0x1D, 0x05, 0x03, 0x16, 0x0E, 0x13, 0x0E,
	0x0F, 0x19, 0x17, 0x16, 0x15, 0x07, 0x10, 0x0F, 0x09, 0x10, 0x13, 0x06,
	0x05, 0x0A, 0x0D, 0x24, 0x01, 0x07, 0x02, 0x15, 0x08, 0x02, 0x02, 0x0C,
	0x0A, 0x05, 0x05, 0x13, 0x14, 0x06, 0x0C, 0xB6, 0x12, 0x27, 0x1F, 0x28,
	0x2C, 0x40, 0x41, 0x2C, 0x05, 0x0D, 0x16, 0x28, 0xB7, 0x0D, 0x11, 0x1B,
	0x1B, 0x06, 0x08, 0x10, 0x10, 0x20, 0x1C, 0x12, 0x22, 0x0C, 0x0B, 0x18,
	0x06, 0x06, 0x0E, 0x18, 0x03, 0x0D, 0x04, 0x21, 0x11, 0x04, 0x05, 0x0F,
	0x09, 0x05, 0x07, 0x14, 0x18, 0x0A, 0x09, 0x3F, 0x15, 0x11, 0x02, 0x04,
	0x0E, 0x13, 0x20, 0x05, 0x07, 0x08, 0x07, 0x35, 0x09, 0x05, 0x12, 0x15,
	0x20, 0x1E, 0x0C, 0x0A, 0x14, 0x16, 0x09, 0x08, 0x0E, 0x0F, 0x13, 0x1D,
	0x0E, 0x2D, 0x08, 0x05, 0x08, 0x0A, 0x08, 0x04, 0x0C, 0x14, 0x13, 0x08,
	0x09, 0x26, 0x18, 0x13, 0x10, 0x02, 0x08, 0x25, 0x11, 0x06, 0x11, 0x08,
	0x0E, 0x21, 0x19, 0x12, 0x0D, 0x20, 0x15, 0x18, 0x78, 0x0B, 0x16, 0x16,
	0x17, 0x1A, 0x0D, 0x09, 0x09, 0x09, 0x01, 0x06, 0x02, 0x1D, 0x0D, 0x0E,
	0x08, 0x04, 0x07, 0x41, 0x07, 0x05, 0x0C, 0x0A, 0x04, 0x11, 0x19, 0x06,
	0x0D, 0x0A, 0x0B, 0x15, 0x18, 0x19, 0x14, 0x01, 0x06, 0x0B, 0x0C, 0x1B,
	0x13, 0x09, 0x13, 0x06, 0x03, 0x0E, 0x10, 0x02, 0x08, 0x03, 0x15, 0x09,
	0x05, 0x06, 0x0A, 0x0A, 0x09, 0x12, 0x16, 0x0A, 0x02, 0x04, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x35, 0x00, 0x12, 0x03, 0x35, 0x02, 0xB7, 0x00, 0x0D,
	0x00, 0x46, 0x00, 0x00, 0x25, 0x26, 0x23, 0x22, 0x07, 0x06, 0x15, 0x14,
	0x17, 0x16, 0x33, 0x32, 0x36, 0x34, 0x01, 0x36, 0x33, 0x32, 0x17, 0x16,
	0x17, 0x1E, 0x01, 0x1F, 0x02, 0x1E, 0x01, 0x33, 0x32, 0x17, 0x16, 0x33,
	0x32, 0x37, 0x33, 0x32, 0x17, 0x16, 0x33, 0x32, 0x37, 0x36, 0x33, 0x32,
	0x16, 0x17, 0x16, 0x17, 0x16, 0x17, 0x16, 0x15, 0x14, 0x0F, 0x01, 0x27,
	0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x27, 0x26,
	0x35, 0x34, 0x02, 0xED, 0x13, 0x17, 0x17, 0x11, 0x09, 0x11, 0x10, 0x10,
	0x10, 0x27, 0xFD, 0x55, 0x0F, 0x03, 0x04, 0x04, 0x0A, 0x20, 0x1B, 0x71,
	0x2D, 0x17, 0x03, 0x03, 0x1B, 0x22, 0x20, 0x12, 0x14, 0x18, 0x0A, 0x08,
	0x02, 0x0E, 0x13, 0x15, 0x11, 0x14, 0x1E, 0x1E, 0x20, 0x14, 0x13, 0x0E,
	0x16, 0x07, 0x07, 0x07, 0x06, 0x3D, 0x3D, 0x31, 0x62, 0xD0, 0x07, 0x04,
	0x3F, 0x18, 0x13, 0x1A, 0x1A, 0x53, 0x15, 0x12, 0x8F, 0x15, 0x16, 0x09,
	0x0F, 0x17, 0x0C, 0x0D, 0x20, 0x1B, 0x02, 0x0D, 0x29, 0x2C, 0x58, 0x44,
	0x36, 0x61, 0x07, 0x04, 0x2B, 0x2A, 0x20, 0x0E, 0x11, 0x01, 0x0D, 0x0C,
	0x10, 0x11, 0x08, 0x0E, 0x15, 0x1C, 0x1B, 0x04, 0x03, 0x04, 0x09, 0x1E,
	0x1C, 0x09, 0x11, 0x49, 0x14, 0x0A, 0x27, 0x09, 0x04, 0x15, 0x1D, 0x5E,
	0x47, 0x3A, 0x2E, 0x3B, 0x00, 0x01, 0x00, 0x4E, 0xFF, 0xEA, 0x02, 0xDD,
	0x02, 0xAF, 0x00, 0x2B, 0x00, 0x00, 0x01, 0x36, 0x33, 0x32, 0x16, 0x15,
	0x14, 0x06, 0x15, 0x06, 0x07, 0x06, 0x15, 0x14, 0x17, 0x1E, 0x01, 0x17,
	0x1E, 0x01, 0x17, 0x16, 0x23, 0x22, 0x07, 0x22, 0x23, 0x26, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x27, 0x36, 0x27, 0x26, 0x35, 0x34,
	0x3E, 0x01, 0x01, 0x5C, 0x1C, 0x1F, 0x45, 0x63, 0x01, 0x06, 0x32, 0x1B,
	0x10, 0x1A, 0x56, 0x16, 0x26, 0x2F, 0x02, 0x05, 0x52, 0x84, 0x81, 0x94,
	0x57, 0x4D, 0x02, 0x04, 0x2D, 0x24, 0x17, 0x58, 0x1A, 0x12, 0x01, 0x01,
	0x1C, 0x38, 0x11, 0x3E, 0x02, 0xA5, 0x0A, 0x61, 0x47, 0x03, 0x0A, 0x02,
	0x47, 0x2E, 0x17, 0x04, 0x04, 0x07, 0x08, 0x43, 0x19, 0x2B, 0x69, 0x3D,
	0x3D, 0x01, 0x01, 0x3D, 0x3F, 0x63, 0x2C, 0x1C, 0x40, 0x0B, 0x08, 0x05,
	0x04, 0x15, 0x34, 0x50, 0x19, 0x3B, 0x3F, 0x00, 0x00, 0x0B, 0x00, 0x3B,
	0xFF, 0xC7, 0x03, 0x10, 0x02, 0xA4, 0x00, 0x03, 0x00, 0x0E, 0x00, 0x1E,
	0x00, 0x29, 0x00, 0x35, 0x00, 0x40, 0x00, 0x4E, 0x00, 0x77, 0x00, 0xCC,
	0x00, 0xD6, 0x00, 0xE0, 0x00, 0x00, 0x13, 0x37, 0x01, 0x07, 0x03, 0x36,
	0x32, 0x16, 0x15, 0x14, 0x23, 0x22, 0x26, 0x35, 0x34, 0x37, 0x36, 0x33,
	0x32, 0x17, 0x16, 0x15, 0x14, 0x07, 0x06, 0x23, 0x22, 0x27, 0x26, 0x35,
	0x34, 0x37, 0x36, 0x33, 0x32, 0x15, 0x14, 0x07, 0x23, 0x22, 0x35, 0x34,
	0x35, 0x36, 0x33, 0x32, 0x17, 0x14, 0x31, 0x14, 0x06, 0x22, 0x35, 0x34,
	0x27, 0x36, 0x33, 0x32, 0x15, 0x14, 0x07, 0x06, 0x23, 0x22, 0x34, 0x07,
	0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 0x33, 0x32, 0x37, 0x36, 0x35,
	0x34, 0x27, 0x26, 0x23, 0x0E, 0x03, 0x07, 0x06, 0x07, 0x06, 0x14, 0x0E,
	0x01, 0x16, 0x33, 0x32, 0x17, 0x16, 0x33, 0x32, 0x37, 0x36, 0x17, 0x16,
	0x36, 0x17, 0x16, 0x37, 0x36, 0x32, 0x27, 0x26, 0x37, 0x30, 0x35, 0x34,
	0x26, 0x2B, 0x01, 0x06, 0x27, 0x3E, 0x01, 0x37, 0x33, 0x32, 0x1F, 0x01,
	0x33, 0x32, 0x17, 0x16, 0x15, 0x14, 0x07, 0x06, 0x0F, 0x01, 0x17, 0x16,
	0x1D, 0x01, 0x14, 0x0E, 0x01, 0x07, 0x22, 0x06, 0x15, 0x14, 0x17, 0x16,
	0x33, 0x32, 0x15, 0x14, 0x07, 0x06, 0x23, 0x22, 0x27, 0x26, 0x23, 0x22,
	0x07, 0x06, 0x15, 0x14, 0x17, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x36, 0x33,
	0x32, 0x15, 0x14, 0x06, 0x07, 0x06, 0x15, 0x14, 0x17, 0x16, 0x15, 0x14,
	0x07, 0x06, 0x23, 0x22, 0x27, 0x2E, 0x01, 0x35, 0x34, 0x37, 0x36, 0x35,
	0x34, 0x27, 0x26, 0x35, 0x34, 0x02, 0x10, 0x36, 0x33, 0x32, 0x16, 0x10,
	0x06, 0x23, 0x22, 0x02, 0x10, 0x16, 0x33, 0x32, 0x36, 0x10, 0x26, 0x23,
	0x22, 0xA1, 0x18, 0x02, 0x00, 0x18, 0x34, 0x03, 0x08, 0x07, 0x03, 0x05,
	0x0B, 0x15, 0x02, 0x02, 0x02, 0x0B, 0x0C, 0x02, 0x02, 0x01, 0x02, 0x0B,
	0x0C, 0x06, 0x04, 0x0D, 0x1D, 0x15, 0x07, 0x13, 0x08, 0x05, 0x02, 0x04,
	0x12, 0x0C, 0x0F, 0x04, 0x02, 0x08, 0x02, 0x07, 0x05, 0x03, 0xC2, 0x06,
	0x0E, 0x0D, 0x19, 0x0F, 0x12, 0x0D, 0x08, 0x0A, 0x69, 0x02, 0x04, 0x01,
	0x0B, 0x07, 0x07, 0x02, 0x04, 0x0B, 0x09, 0x07, 0x02, 0x04, 0x03, 0x07,
	0x0B, 0x08, 0x07, 0x02, 0x02, 0x09, 0x08, 0x07, 0x14, 0x05, 0x03, 0x06,
	0x05, 0x0F, 0x02, 0x04, 0x06, 0x1F, 0x0B, 0x01, 0x08, 0x4A, 0x14, 0x1D,
	0x24, 0x04, 0x39, 0x2A, 0x11, 0x41, 0x3F, 0x11, 0x12, 0x09, 0x0A, 0x37,
	0x34, 0x01, 0x02, 0x02, 0x05, 0x05, 0x09, 0x0C, 0x04, 0x04, 0x07, 0x10,
	0x06, 0x08, 0x04, 0x01, 0x08, 0x07, 0x12, 0x19, 0x0A, 0x05, 0x0A, 0x09,
	0x0E, 0x02, 0x07, 0x03, 0x04, 0x09, 0x0A, 0x0F, 0x09, 0x0A, 0x01, 0x02,
	0x0C, 0x19, 0x1B, 0x30, 0x42, 0x15, 0x0E, 0x03, 0x04, 0x07, 0x0C, 0x9D,
	0xD5, 0x96, 0x95, 0xD5, 0xD5, 0x95, 0x96, 0xC5, 0xCC, 0x8F, 0x8F, 0xCC,
	0xCC, 0x8F, 0x8F, 0x02, 0x33, 0x17, 0xFD, 0xFD, 0x1A, 0x01, 0x68, 0x05,
	0x08, 0x06, 0x0B, 0x0C, 0x06, 0x02, 0x0F, 0x05, 0x0B, 0x0B, 0x07, 0x03,
	0x01, 0x05, 0x0B, 0x0B, 0x07, 0x03, 0x1C, 0x03, 0x08, 0x07, 0x02, 0x09,
	0x01, 0x29, 0x09, 0x04, 0x01, 0x06, 0x15, 0x04, 0x06, 0x18, 0x04, 0x0A,
	0x03, 0x04, 0x07, 0x12, 0x81, 0x06, 0x0C, 0x08, 0x07, 0x0E, 0x04, 0x06,
	0x0C, 0x08, 0x7F, 0x03, 0x01, 0x02, 0x02, 0x06, 0x03, 0x09, 0x01, 0x01,
	0x16, 0x05, 0x05, 0x05, 0x16, 0x13, 0x01, 0x03, 0x06, 0x05, 0x0F, 0x02,
	0x04, 0x0B, 0x0A, 0x09, 0x09, 0x0A, 0x04, 0x09, 0x22, 0x05, 0x07, 0x13,
	0x0A, 0x02, 0x23, 0x11, 0x07, 0x08, 0x06, 0x03, 0x06, 0x0A, 0x03, 0x02,
	0x0B, 0x15, 0x0C, 0x07, 0x05, 0x05, 0x01, 0x01, 0x0C, 0x06, 0x06, 0x03,
	0x07, 0x21, 0x13, 0x11, 0x14, 0x05, 0x07, 0x0B, 0x04, 0x03, 0x04, 0x08,
	0x07, 0x01, 0x03, 0x06, 0x22, 0x0B, 0x0C, 0x09, 0x05, 0x04, 0x07, 0x03,
	0x07, 0x08, 0x13, 0x3C, 0x13, 0x13, 0x0C, 0x07, 0x15, 0x18, 0x0A, 0x11,
	0x26, 0x36, 0x22, 0x38, 0xFE, 0xD9, 0x01, 0x2F, 0xD7, 0xD7, 0xFE, 0xD1,
	0xD7, 0x02, 0x00, 0xFE, 0xDD, 0xCE, 0xCE, 0x01, 0x23, 0xCD, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x03, 0xDE, 0xAB, 0x3A,
	0x5F, 0x0F, 0x3C, 0xF5, 0x00, 0x0B, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xDB, 0xA8, 0xE3, 0x02, 0x00, 0x00, 0x00, 0x00, 0xDB, 0xA8, 0xE3, 0x02,
	0x00, 0x00, 0xFF, 0x2B, 0x03, 0xAC, 0x02, 0xEB, 0x00, 0x00, 0x00, 0x08,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x03, 0x2C, 0xFF, 0x2C, 0x00, 0x5C, 0x03, 0xAC, 0x00, 0x00, 0x00, 0x00,
	0x03, 0xAC, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x76, 0x00, 0x22,
	0x03, 0x3C, 0x00, 0x37, 0x03, 0x63, 0x00, 0x06, 0x03, 0xAC, 0x00, 0x00,
	0x03, 0xA5, 0x00, 0x35, 0x03, 0x70, 0x00, 0x35, 0x03, 0x35, 0x00, 0x4E,
	0x03, 0xA8, 0x00, 0x3B, 0x00, 0x00, 0x00, 0x14, 0x01, 0x20, 0x01, 0xAC,
	0x02, 0x32, 0x03, 0xB2, 0x04, 0x1A, 0x04, 0x5E, 0x05, 0x8C, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x01, 0x21, 0x00, 0x0B, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C,
	0x00, 0x96, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0A,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x06,
	0x00, 0x0A, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x1B,
	0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x0A,
	0x00, 0x2B, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x1E,
	0x00, 0x35, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x0A,
	0x00, 0x53, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x01, 0x00, 0x14,
	0x00, 0x5D, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x02, 0x00, 0x0C,
	0x00, 0x71, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x03, 0x00, 0x36,
	0x00, 0x7D, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x04, 0x00, 0x14,
	0x00, 0xB3, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x05, 0x00, 0x3C,
	0x00, 0xC7, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x06, 0x00, 0x14,
	0x01, 0x03, 0x66, 0x6F, 0x6E, 0x74, 0x65, 0x64, 0x69, 0x74, 0x6F, 0x72,
	0x4D, 0x65, 0x64, 0x69, 0x75, 0x6D, 0x46, 0x6F, 0x6E, 0x74, 0x45, 0x64,
	0x69, 0x74, 0x6F, 0x72, 0x20, 0x31, 0x2E, 0x30, 0x20, 0x3A, 0x20, 0x66,
	0x6F, 0x6E, 0x74, 0x65, 0x64, 0x69, 0x74, 0x6F, 0x72, 0x66, 0x6F, 0x6E,
	0x74, 0x65, 0x64, 0x69, 0x74, 0x6F, 0x72, 0x56, 0x65, 0x72, 0x73, 0x69,
	0x6F, 0x6E, 0x20, 0x31, 0x2E, 0x30, 0x3B, 0x20, 0x46, 0x6F, 0x6E, 0x74,
	0x45, 0x64, 0x69, 0x74, 0x6F, 0x72, 0x20, 0x28, 0x76, 0x31, 0x2E, 0x30,
	0x29, 0x66, 0x6F, 0x6E, 0x74, 0x65, 0x64, 0x69, 0x74, 0x6F, 0x72, 0x00,
	0x66, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x64, 0x00,
	0x69, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x4D, 0x00, 0x65, 0x00,
	0x64, 0x00, 0x69, 0x00, 0x75, 0x00, 0x6D, 0x00, 0x46, 0x00, 0x6F, 0x00,
	0x6E, 0x00, 0x74, 0x00, 0x45, 0x00, 0x64, 0x00, 0x69, 0x00, 0x74, 0x00,
	0x6F, 0x00, 0x72, 0x00, 0x20, 0x00, 0x31, 0x00, 0x2E, 0x00, 0x30, 0x00,
	0x20, 0x00, 0x3A, 0x00, 0x20, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x6E, 0x00,
	0x74, 0x00, 0x65, 0x00, 0x64, 0x00, 0x69, 0x00, 0x74, 0x00, 0x6F, 0x00,
	0x72, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00,
	0x64, 0x00, 0x69, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x56, 0x00,
	0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x69, 0x00, 0x6F, 0x00, 0x6E, 0x00,
	0x20, 0x00, 0x31, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x3B, 0x00, 0x20, 0x00,
	0x46, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x45, 0x00, 0x64, 0x00,
	0x69, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x20, 0x00, 0x28, 0x00,
	0x76, 0x00, 0x31, 0x00, 0x2E, 0x00, 0x30, 0x00, 0x29, 0x00, 0x66, 0x00,
	0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x65, 0x00, 0x64, 0x00, 0x69, 0x00,
	0x74, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x24, 0x00, 0x25,
	0x00, 0x26, 0x00, 0x27, 0x00, 0x28, 0x00, 0x29, 0x00, 0x2A, 0x00, 0x00
};

inline unsigned char background_texture[ 34780 ] = { 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x07, 0xD0, 0x00, 0x00, 0x07, 0xD0, 0x08, 0x06, 0x00, 0x00, 0x00, 0x9A, 0x38, 0xC4, 0x79, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x2E, 0x23, 0x00, 0x00, 0x2E, 0x23, 0x01, 0x78, 0xA5, 0x3F, 0x76, 0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4D, 0x45, 0x07, 0xE3, 0x01, 0x0E, 0x02, 0x04, 0x19, 0x82, 0x38, 0x24, 0xA5, 0x00, 0x00, 0x20, 0x00, 0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0xEC, 0xDD, 0xB1, 0x8D, 0x84, 0x50, 0x14, 0x04, 0xC1, 0x3E, 0x6C, 0x3C, 0xF2, 0x0F, 0x91, 0x00, 0xB0, 0x76, 0x9D, 0xBB, 0xD3, 0xE4, 0x40, 0x8D, 0xF3, 0x54, 0x12, 0x19, 0xF0, 0xA5, 0xEE, 0x3C, 0xCF, 0xCF, 0xF3, 0x3C, 0xB9, 0xAE, 0xEB, 0xBA, 0xAE, 0xEB, 0xBA, 0xAE, 0xEB, 0xBA, 0xAE, 0xEB, 0xBA, 0xAE, 0xEB, 0xBA, 0xAE, 0xEB, 0xBA, 0xAE, 0xEB, 0xBA, 0xEE, 0x9B, 0xEF, 0xD1, 0xEF, 0xEE, 0xFB, 0xFE, 0x69, 0xC6, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFC, 0x26, 0xFF, 0xFF, 0x40, 0xBF, 0xAE, 0xEB, 0xB3, 0x1F, 0x30, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xBF, 0xC9, 0x87, 0x97, 0x04, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x75, 0x78, 0x49, 0xC0, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xFF, 0x4D, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xC0, 0xAA, 0x33, 0x2E, 0x00, 0x00, 0x20, 0x00, 0x49, 0x44, 0x41, 0x54, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0x4C, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x39, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x99, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x73, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x0D, 0x74, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x35, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x67, 0x1A, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x6B, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xCF, 0x34, 0xD0, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xD6, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x9E, 0x69, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xA7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x3C, 0xD3, 0x40, 0x67, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x4E, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x59, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0xA6, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x06, 0x3A, 0x33, 0x33, 0xF3, 0x97, 0xBD, 0x3B, 0x24, 0x00, 0x00, 0x00, 0x60, 0x10, 0x46, 0xFF, 0xD4, 0xB7, 0x0F, 0x31, 0xDC, 0x52, 0xC0, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x6B, 0xA2, 0x2E, 0xC9, 0x00, 0x00, 0x20, 0x00, 0x49, 0x44, 0x41, 0x54, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x79, 0xA0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xE7, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xEC, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0x63, 0xEF, 0x0E, 0x09, 0x00, 0x00, 0x00, 0x18, 0x84, 0xD1, 0x3F, 0xF5, 0xED, 0x43, 0x0C, 0xB7, 0x14, 0x30, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0xD8, 0xD5, 0xAF, 0x11, 0x00, 0x00, 0x20, 0x00, 0x49, 0x44, 0x41, 0x54, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xE5, 0x81, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x9C, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xB3, 0x07, 0x3A, 0x33, 0x33, 0x33, 0x33, 0x33, 0xF3, 0xDA, 0xBB, 0x43, 0x02, 0x00, 0x00, 0x00, 0x06, 0x61, 0xEF, 0x9F, 0xFA, 0x96, 0x10, 0xC3, 0x2D, 0x05, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x32, 0xB4, 0xE0, 0xAF, 0x00, 0x00, 0x07, 0x4B, 0x49, 0x44, 0x41, 0x54, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC9, 0x03, 0x9D, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x79, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x1E, 0xE8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xE9, 0x29, 0x52, 0xCF, 0x8C, 0xC1, 0x4C, 0x51, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82 };
```

`CSGO SDK/Renderer/Textures/weaponicons.h`:

```h
#pragma once

inline static char weaponicons[] = {
	0x00, 0x01, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x80, 0x00, 0x03, 0x00, 0x60, 0x46, 0x46, 0x54, 0x4D,
	0x80, 0xAE, 0x3A, 0x12, 0x00, 0x00, 0xAD, 0xEC, 0x00, 0x00, 0x00, 0x1C, 0x47, 0x44, 0x45, 0x46,
	0x00, 0x27, 0x00, 0x5E, 0x00, 0x00, 0xAD, 0xC4, 0x00, 0x00, 0x00, 0x26, 0x4F, 0x53, 0x2F, 0x32,
	0x57, 0xFD, 0x75, 0x47, 0x00, 0x00, 0x01, 0x68, 0x00, 0x00, 0x00, 0x60, 0x63, 0x6D, 0x61, 0x70,
	0x7E, 0x82, 0x76, 0xC6, 0x00, 0x00, 0x02, 0xA8, 0x00, 0x00, 0x01, 0x5A, 0x63, 0x76, 0x74, 0x20,
	0x00, 0x22, 0x02, 0x88, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00, 0x04, 0x67, 0x61, 0x73, 0x70,
	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0xAD, 0xBC, 0x00, 0x00, 0x00, 0x08, 0x67, 0x6C, 0x79, 0x66,
	0x5B, 0x8A, 0xDA, 0x4F, 0x00, 0x00, 0x04, 0x7C, 0x00, 0x00, 0xA6, 0xE8, 0x68, 0x65, 0x61, 0x64,
	0x17, 0x9F, 0xE5, 0xB2, 0x00, 0x00, 0x00, 0xEC, 0x00, 0x00, 0x00, 0x36, 0x68, 0x68, 0x65, 0x61,
	0x10, 0xF0, 0x0D, 0x93, 0x00, 0x00, 0x01, 0x24, 0x00, 0x00, 0x00, 0x24, 0x68, 0x6D, 0x74, 0x78,
	0xB6, 0xA9, 0x12, 0x1D, 0x00, 0x00, 0x01, 0xC8, 0x00, 0x00, 0x00, 0xE0, 0x6C, 0x6F, 0x63, 0x61,
	0xAC, 0x62, 0x84, 0x78, 0x00, 0x00, 0x04, 0x08, 0x00, 0x00, 0x00, 0x72, 0x6D, 0x61, 0x78, 0x70,
	0x00, 0x49, 0x02, 0x31, 0x00, 0x00, 0x01, 0x48, 0x00, 0x00, 0x00, 0x20, 0x6E, 0x61, 0x6D, 0x65,
	0x33, 0x1F, 0x05, 0x06, 0x00, 0x00, 0xAB, 0x64, 0x00, 0x00, 0x01, 0xB9, 0x70, 0x6F, 0x73, 0x74,
	0xA5, 0x64, 0x3C, 0xFC, 0x00, 0x00, 0xAD, 0x20, 0x00, 0x00, 0x00, 0x9A, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x1E, 0x5A, 0x64, 0x2F, 0x5F, 0x0F, 0x3C, 0xF5, 0x00, 0x0B, 0x04, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xD2, 0xEB, 0xED, 0xCA, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x1D, 0xB3, 0x6C,
	0x00, 0x4A, 0xFF, 0xF2, 0x0D, 0x2D, 0x03, 0x8D, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x03, 0xC1, 0xFF, 0xC1, 0x00, 0x00, 0x0D, 0x99,
	0x00, 0x00, 0x00, 0x00, 0x0D, 0x2D, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00, 0x38, 0x02, 0x2F,
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x08, 0x20, 0x01, 0x90, 0x00, 0x05,
	0x00, 0x00, 0x02, 0x99, 0x02, 0xCC, 0x00, 0x00, 0x00, 0x8F, 0x02, 0x99, 0x02, 0xCC, 0x00, 0x00,
	0x01, 0xEA, 0x00, 0x33, 0x01, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x50, 0x66, 0x45, 0x64, 0x00, 0x00, 0x00, 0x30, 0x00, 0x71, 0x03, 0xC1, 0xFF, 0xC1,
	0x00, 0x3F, 0x03, 0xC1, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x63,
	0x03, 0x5A, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x04, 0x00, 0x00, 0x00, 0x08, 0xCC, 0x00, 0x53, 0x09, 0x4C, 0x00, 0x5D, 0x08, 0xCC, 0x00, 0x53,
	0x08, 0x65, 0x00, 0x53, 0x08, 0x4C, 0x00, 0x52, 0x09, 0x4C, 0x00, 0x52, 0x08, 0xCC, 0x00, 0x51,
	0x08, 0xCC, 0x00, 0x53, 0x08, 0xCC, 0x00, 0x50, 0x08, 0xCC, 0x00, 0x54, 0x06, 0x80, 0x00, 0x5D,
	0x0A, 0x00, 0x00, 0x4F, 0x05, 0x4C, 0x00, 0x57, 0x05, 0xE5, 0x00, 0x4B, 0x05, 0x00, 0x00, 0x55,
	0x05, 0x00, 0x00, 0x59, 0x09, 0x65, 0x00, 0x53, 0x06, 0x65, 0x00, 0x65, 0x05, 0x99, 0x00, 0x5A,
	0x07, 0x4C, 0x00, 0x5A, 0x05, 0x4C, 0x00, 0x5D, 0x09, 0xB2, 0x00, 0x5A, 0x0A, 0x99, 0x00, 0x5D,
	0x06, 0x19, 0x00, 0x61, 0x08, 0x4C, 0x00, 0x4F, 0x08, 0x4C, 0x00, 0x62, 0x0C, 0x19, 0x00, 0x5D,
	0x09, 0x19, 0x00, 0x5A, 0x0A, 0xB2, 0x00, 0x64, 0x0D, 0x99, 0x00, 0x5B, 0x09, 0x65, 0x00, 0x53,
	0x0A, 0x80, 0x00, 0x53, 0x0B, 0x19, 0x00, 0x56, 0x0B, 0x4C, 0x00, 0x4D, 0x0B, 0x4C, 0x00, 0x4A,
	0x0D, 0x99, 0x00, 0x62, 0x0C, 0x80, 0x00, 0x55, 0x0A, 0xE5, 0x00, 0x62, 0x0A, 0x65, 0x00, 0x5E,
	0x07, 0xE5, 0x00, 0x63, 0x0B, 0x4C, 0x00, 0x60, 0x09, 0x65, 0x00, 0x55, 0x0A, 0x99, 0x00, 0x53,
	0x05, 0x32, 0x00, 0x56, 0x08, 0xCC, 0x00, 0x52, 0x08, 0xCC, 0x00, 0x53, 0x02, 0x00, 0x00, 0x54,
	0x02, 0xE6, 0x00, 0x58, 0x02, 0x1A, 0x00, 0x54, 0x02, 0xCD, 0x00, 0x57, 0x03, 0x9A, 0x00, 0x61,
	0x02, 0x1A, 0x00, 0x51, 0x04, 0x00, 0x00, 0x5E, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x00, 0x1C, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x03, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x1C, 0x00, 0x04, 0x00, 0x38, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x08, 0x00, 0x02,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x39, 0x00, 0x5A, 0x00, 0x71, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x30, 0x00, 0x41, 0x00, 0x61, 0xFF, 0xFF, 0x00, 0x01, 0xFF, 0xD3, 0xFF, 0xCC, 0xFF, 0xC6,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
	0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33,
	0x34, 0x35, 0x36, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x02, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x36, 0x02, 0xA8, 0x04, 0x18, 0x05, 0x6A, 0x06, 0xB2, 0x08, 0xDA, 0x0B, 0x00, 0x0D, 0x1E,
	0x0F, 0x42, 0x11, 0x9E, 0x12, 0xD4, 0x14, 0xB4, 0x15, 0xB2, 0x16, 0x98, 0x17, 0xAC, 0x19, 0x36,
	0x1A, 0x02, 0x1C, 0x40, 0x1D, 0xCE, 0x1F, 0x78, 0x20, 0xD8, 0x23, 0x9E, 0x25, 0xA6, 0x27, 0x3E,
	0x28, 0xD6, 0x2A, 0xA6, 0x2C, 0x7E, 0x2D, 0xB6, 0x2F, 0xC6, 0x31, 0x4A, 0x32, 0xE8, 0x35, 0xAE,
	0x36, 0x8C, 0x38, 0xFC, 0x3B, 0xEA, 0x3C, 0xDC, 0x3F, 0x14, 0x40, 0xEC, 0x41, 0xFA, 0x43, 0x7A,
	0x45, 0x3E, 0x47, 0xAC, 0x49, 0xD0, 0x4A, 0xA2, 0x4B, 0x9A, 0x4D, 0x2C, 0x4D, 0x86, 0x4E, 0x7A,
	0x4F, 0x8A, 0x50, 0x3E, 0x50, 0xEA, 0x51, 0xF6, 0x53, 0x74, 0x00, 0x00, 0x00, 0x01, 0x00, 0x53,
	0x00, 0xDA, 0x08, 0x53, 0x02, 0xA5, 0x00, 0xD6, 0x00, 0x00, 0x01, 0x3E, 0x01, 0x37, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x22, 0x07,
	0x22, 0x26, 0x23, 0x26, 0x06, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x27, 0x2A,
	0x01, 0x23, 0x22, 0x26, 0x35, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27,
	0x2E, 0x01, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x2E, 0x01, 0x27, 0x26,
	0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x06,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x26, 0x36, 0x35,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E,
	0x01, 0x17, 0x1E, 0x01, 0x33, 0x32, 0x16, 0x33, 0x1E, 0x01, 0x17, 0x32, 0x36, 0x33, 0x3A, 0x01,
	0x33, 0x32, 0x36, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x3A, 0x01, 0x33,
	0x1E, 0x01, 0x17, 0x16, 0x36, 0x35, 0x34, 0x26, 0x27, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x15, 0x14,
	0x22, 0x23, 0x2A, 0x01, 0x23, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x33, 0x32, 0x36, 0x33, 0x3E, 0x01,
	0x37, 0x32, 0x36, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37,
	0x31, 0x07, 0xF4, 0x18, 0x30, 0x17, 0x01, 0x08, 0x03, 0x06, 0x0B, 0x05, 0x0E, 0x1F, 0x11, 0x21,
	0x41, 0x24, 0x35, 0x6F, 0x37, 0x17, 0x2E, 0x16, 0x0B, 0x16, 0x0C, 0x0A, 0x16, 0x0A, 0x1D, 0x3A,
	0x1D, 0x17, 0x2F, 0x17, 0x17, 0x35, 0x19, 0x03, 0x08, 0x04, 0x01, 0x04, 0x02, 0x0C, 0x04, 0x0D,
	0x1B, 0x0D, 0x0F, 0x24, 0x10, 0x07, 0x09, 0x02, 0x0E, 0x2B, 0x2E, 0x12, 0x20, 0x0A, 0x04, 0x07,
	0x03, 0x03, 0x05, 0x08, 0x0D, 0x1A, 0x0C, 0x0A, 0x14, 0x0B, 0x18, 0x34, 0x18, 0x0C, 0x19, 0x0C,
	0x0B, 0x1A, 0x0B, 0x0B, 0x18, 0x0B, 0x0F, 0x23, 0x08, 0x09, 0x09, 0x07, 0x03, 0x05, 0x06, 0x07,
	0x10, 0x06, 0x0B, 0x16, 0x10, 0x16, 0x21, 0x0F, 0x16, 0x27, 0x14, 0x08, 0x11, 0x09, 0x06, 0x0B,
	0x07, 0x05, 0x06, 0x04, 0x08, 0x01, 0x01, 0x12, 0x0C, 0x1B, 0x62, 0x37, 0x2B, 0x63, 0x31, 0x16,
	0x2C, 0x17, 0x20, 0x41, 0x21, 0x07, 0x12, 0x07, 0x04, 0x0A, 0x03, 0x07, 0x0F, 0x07, 0x1A, 0x35,
	0x1A, 0x03, 0x04, 0x02, 0x06, 0x0A, 0x06, 0x07, 0x0E, 0x07, 0x16, 0x28, 0x14, 0x1D, 0x39, 0x1D,
	0x09, 0x13, 0x09, 0x01, 0x03, 0x02, 0x07, 0x06, 0x02, 0x01, 0x01, 0x01, 0x01, 0x11, 0x21, 0x11,
	0x08, 0x07, 0x02, 0x05, 0x04, 0x09, 0x04, 0x03, 0x09, 0x08, 0x04, 0x09, 0x04, 0x11, 0x21, 0x11,
	0x18, 0x2F, 0x17, 0x09, 0x14, 0x09, 0x0F, 0x1D, 0x0F, 0x24, 0x4A, 0x25, 0x30, 0x61, 0x31, 0x23,
	0x45, 0x24, 0x02, 0x27, 0x02, 0x05, 0x02, 0x05, 0x07, 0x04, 0x05, 0x0C, 0x06, 0x0E, 0x1C, 0x09,
	0x13, 0x25, 0x0C, 0x10, 0x0D, 0x05, 0x03, 0x01, 0x01, 0x01, 0x01, 0x02, 0x05, 0x09, 0x05, 0x04,
	0x0C, 0x05, 0x06, 0x03, 0x01, 0x07, 0x01, 0x03, 0x08, 0x01, 0x05, 0x0A, 0x05, 0x05, 0x10, 0x01,
	0x01, 0x1B, 0x05, 0x23, 0x51, 0x04, 0x02, 0x08, 0x12, 0x05, 0x0A, 0x06, 0x07, 0x07, 0x01, 0x01,
	0x07, 0x02, 0x02, 0x03, 0x01, 0x02, 0x06, 0x04, 0x02, 0x04, 0x03, 0x02, 0x07, 0x01, 0x0A, 0x04,
	0x05, 0x19, 0x0B, 0x0B, 0x1C, 0x0C, 0x05, 0x0B, 0x02, 0x01, 0x03, 0x07, 0x0B, 0x19, 0x02, 0x02,
	0x16, 0x0E, 0x16, 0x2F, 0x17, 0x0A, 0x15, 0x08, 0x05, 0x0A, 0x04, 0x05, 0x03, 0x08, 0x0F, 0x23,
	0x10, 0x1D, 0x39, 0x1A, 0x3B, 0x56, 0x20, 0x1A, 0x1C, 0x09, 0x04, 0x09, 0x02, 0x03, 0x07, 0x04,
	0x01, 0x03, 0x01, 0x01, 0x04, 0x01, 0x01, 0x02, 0x01, 0x04, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02,
	0x05, 0x02, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x04, 0x01, 0x06, 0x01, 0x02, 0x05, 0x02, 0x08, 0x05,
	0x07, 0x0F, 0x03, 0x01, 0x02, 0x01, 0x01, 0x03, 0x01, 0x07, 0x03, 0x05, 0x09, 0x05, 0x0C, 0x14,
	0x03, 0x05, 0x09, 0x04, 0x03, 0x02, 0x02, 0x00, 0x00, 0x02, 0x00, 0x5D, 0x00, 0xD7, 0x08, 0xDE,
	0x02, 0xAA, 0x01, 0x1B, 0x01, 0x31, 0x00, 0x00, 0x01, 0x2E, 0x03, 0x27, 0x26, 0x22, 0x23, 0x2A,
	0x01, 0x27, 0x2A, 0x01, 0x27, 0x22, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x06,
	0x23, 0x22, 0x23, 0x22, 0x23, 0x2A, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x06,
	0x23, 0x2A, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x23, 0x2A, 0x01, 0x23,
	0x2A, 0x01, 0x23, 0x22, 0x06, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A,
	0x01, 0x23, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01,
	0x23, 0x07, 0x06, 0x33, 0x0E, 0x01, 0x23, 0x06, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x27,
	0x22, 0x06, 0x15, 0x0E, 0x01, 0x23, 0x22, 0x26, 0x23, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A,
	0x01, 0x23, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x27, 0x26, 0x06, 0x23, 0x06, 0x26, 0x27, 0x26, 0x06,
	0x23, 0x2A, 0x01, 0x27, 0x22, 0x06, 0x07, 0x06, 0x16, 0x07, 0x1C, 0x01, 0x15, 0x1C, 0x02, 0x16,
	0x17, 0x1E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x37,
	0x3E, 0x01, 0x37, 0x36, 0x16, 0x33, 0x32, 0x36, 0x37, 0x36, 0x32, 0x17, 0x16, 0x14, 0x33, 0x3A,
	0x01, 0x33, 0x32, 0x36, 0x37, 0x36, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x17, 0x1E, 0x01,
	0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x37, 0x36, 0x16, 0x17, 0x16, 0x36, 0x33,
	0x3A, 0x01, 0x33, 0x32, 0x16, 0x37, 0x36, 0x32, 0x17, 0x1E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A,
	0x01, 0x33, 0x32, 0x14, 0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x33, 0x32, 0x3B,
	0x01, 0x3C, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x36, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33,
	0x36, 0x32, 0x33, 0x3A, 0x02, 0x36, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37,
	0x25, 0x1E, 0x01, 0x07, 0x14, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x33,
	0x3A, 0x01, 0x33, 0x32, 0x36, 0x17, 0x08, 0xDE, 0x37, 0x6D, 0x6D, 0x6D, 0x36, 0x07, 0x0D, 0x07,
	0x16, 0x2C, 0x16, 0x48, 0x90, 0x48, 0x46, 0x8E, 0x46, 0x16, 0x28, 0x14, 0x05, 0x08, 0x04, 0x06,
	0x0C, 0x07, 0x11, 0x10, 0x0F, 0x10, 0x0C, 0x07, 0x0E, 0x02, 0x02, 0x0F, 0x02, 0x07, 0x12, 0x22,
	0x11, 0x06, 0x0D, 0x06, 0x05, 0x04, 0x06, 0x06, 0x09, 0x03, 0x02, 0x01, 0x02, 0x08, 0x10, 0x08,
	0x08, 0x10, 0x08, 0x07, 0x09, 0x07, 0x05, 0x08, 0x03, 0x08, 0x0F, 0x07, 0x09, 0x10, 0x09, 0x02,
	0x03, 0x02, 0x02, 0x02, 0x01, 0x03, 0x07, 0x03, 0x08, 0x07, 0x08, 0x09, 0x12, 0x08, 0x07, 0x0D,
	0x06, 0x02, 0x02, 0x01, 0x0A, 0x02, 0x02, 0x08, 0x02, 0x02, 0x03, 0x01, 0x06, 0x0E, 0x06, 0x09,
	0x11, 0x09, 0x07, 0x04, 0x06, 0x06, 0x0A, 0x05, 0x05, 0x0D, 0x07, 0x0F, 0x17, 0x0E, 0x07, 0x14,
	0x08, 0x20, 0x40, 0x20, 0x0A, 0x10, 0x02, 0x03, 0x02, 0x01, 0x08, 0x02, 0x01, 0x07, 0x02, 0x03,
	0x06, 0x04, 0x10, 0x21, 0x11, 0x12, 0x24, 0x12, 0x08, 0x11, 0x07, 0x06, 0x0E, 0x06, 0x07, 0x0F,
	0x07, 0x07, 0x06, 0x06, 0x04, 0x08, 0x04, 0x02, 0x03, 0x10, 0x21, 0x10, 0x08, 0x02, 0x06, 0x0A,
	0x09, 0x07, 0x10, 0x20, 0x11, 0x06, 0x08, 0x09, 0x02, 0x06, 0x01, 0x03, 0x04, 0x03, 0x0F, 0x20,
	0x0F, 0x01, 0x05, 0x01, 0x06, 0x0D, 0x04, 0x04, 0x0B, 0x05, 0x0A, 0x12, 0x09, 0x03, 0x10, 0x02,
	0x05, 0x0F, 0x07, 0x06, 0x03, 0x07, 0x12, 0x23, 0x12, 0x05, 0x0A, 0x04, 0x01, 0x02, 0x06, 0x02,
	0x0B, 0x0B, 0x01, 0x04, 0x05, 0x0A, 0x06, 0x14, 0x2A, 0x14, 0x45, 0x89, 0x44, 0x3F, 0x7F, 0x80,
	0x80, 0x40, 0x22, 0x43, 0x22, 0x32, 0x60, 0x2E, 0x1F, 0x34, 0x1A, 0xFE, 0xC0, 0x07, 0x06, 0x02,
	0x03, 0x05, 0x0C, 0x18, 0x0C, 0x06, 0x09, 0x08, 0x05, 0x07, 0x0E, 0x07, 0x04, 0x0B, 0x04, 0x01,
	0xC4, 0x09, 0x10, 0x11, 0x11, 0x08, 0x01, 0x01, 0x01, 0x01, 0x0A, 0x0C, 0x22, 0x44, 0x23, 0x04,
	0x08, 0x05, 0x03, 0x01, 0x02, 0x04, 0x09, 0x04, 0x23, 0x45, 0x23, 0x06, 0x0E, 0x0A, 0x01, 0x01,
	0x05, 0x04, 0x02, 0x01, 0x0B, 0x01, 0x01, 0x09, 0x02, 0x02, 0x02, 0x04, 0x01, 0x0B, 0x01, 0x04,
	0x01, 0x02, 0x03, 0x04, 0x01, 0x05, 0x03, 0x03, 0x02, 0x04, 0x06, 0x05, 0x01, 0x01, 0x07, 0x05,
	0x03, 0x02, 0x01, 0x10, 0x09, 0x0D, 0x1C, 0x0D, 0x0C, 0x18, 0x0C, 0x07, 0x0D, 0x0B, 0x0D, 0x05,
	0x02, 0x0F, 0x01, 0x03, 0x03, 0x07, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x04, 0x02, 0x02, 0x03,
	0x04, 0x06, 0x0D, 0x0B, 0x03, 0x01, 0x07, 0x06, 0x01, 0x03, 0x03, 0x04, 0x04, 0x01, 0x02, 0x03,
	0x07, 0x03, 0x03, 0x01, 0x0B, 0x01, 0x12, 0x24, 0x12, 0x07, 0x0E, 0x07, 0x05, 0x01, 0x06, 0x0C,
	0x05, 0x11, 0x22, 0x11, 0x05, 0x01, 0x01, 0x01, 0x05, 0x04, 0x05, 0x18, 0x16, 0x0F, 0x28, 0x17,
	0x08, 0x04, 0x0C, 0x08, 0x02, 0x11, 0x11, 0x05, 0x03, 0x13, 0x02, 0x03, 0x00, 0x02, 0x00, 0x53,
	0x01, 0x00, 0x08, 0x53, 0x02, 0x7F, 0x00, 0xEC, 0x00, 0xFC, 0x00, 0x00, 0x01, 0x0E, 0x01, 0x07,
	0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x2E, 0x02, 0x27, 0x26, 0x27, 0x26, 0x07, 0x0E, 0x01,
	0x07, 0x06, 0x26, 0x23, 0x16, 0x06, 0x15, 0x2E, 0x01, 0x23, 0x1C, 0x01, 0x15, 0x2E, 0x01, 0x27,
	0x14, 0x06, 0x07, 0x2E, 0x01, 0x07, 0x22, 0x26, 0x07, 0x06, 0x26, 0x27, 0x14, 0x06, 0x15, 0x26,
	0x06, 0x27, 0x26, 0x22, 0x07, 0x2E, 0x01, 0x27, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x06,
	0x23, 0x2A, 0x01, 0x23, 0x06, 0x22, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07,
	0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x14, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E,
	0x01, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01,
	0x37, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x32, 0x16, 0x17,
	0x1E, 0x01, 0x37, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x16, 0x17, 0x16, 0x17,
	0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x33, 0x3A,
	0x01, 0x33, 0x32, 0x36, 0x37, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x37, 0x36, 0x37, 0x36, 0x17, 0x32,
	0x16, 0x35, 0x3E, 0x01, 0x37, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16,
	0x17, 0x32, 0x16, 0x33, 0x32, 0x36, 0x37, 0x36, 0x16, 0x17, 0x32, 0x16, 0x17, 0x16, 0x36, 0x37,
	0x3E, 0x01, 0x17, 0x16, 0x32, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x0E, 0x01, 0x07, 0x05, 0x3C, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A,
	0x01, 0x33, 0x06, 0x16, 0x17, 0x2A, 0x01, 0x07, 0x07, 0xEA, 0x2F, 0x5F, 0x30, 0x1F, 0x3E, 0x1E,
	0x2F, 0x5E, 0x2F, 0x31, 0x61, 0x62, 0x60, 0x30, 0x04, 0x07, 0x07, 0x04, 0x03, 0x07, 0x02, 0x03,
	0x06, 0x03, 0x01, 0x01, 0x02, 0x04, 0x03, 0x02, 0x04, 0x02, 0x01, 0x01, 0x06, 0x03, 0x03, 0x01,
	0x05, 0x01, 0x03, 0x02, 0x05, 0x02, 0x04, 0x06, 0x01, 0x05, 0x02, 0x05, 0x01, 0x03, 0x02, 0x05,
	0x05, 0x08, 0x0B, 0x18, 0x0D, 0x0B, 0x16, 0x0C, 0x1E, 0x3E, 0x1F, 0x2B, 0x56, 0x2B, 0x1F, 0x3D,
	0x1F, 0x18, 0x30, 0x18, 0x16, 0x2C, 0x16, 0x1E, 0x38, 0x19, 0x18, 0x29, 0x11, 0x07, 0x0F, 0x01,
	0x1B, 0x08, 0x04, 0x02, 0x01, 0x01, 0x0B, 0x05, 0x09, 0x17, 0x09, 0x08, 0x0E, 0x08, 0x09, 0x0F,
	0x08, 0x18, 0x32, 0x1E, 0x0F, 0x21, 0x10, 0x22, 0x44, 0x20, 0x0A, 0x12, 0x0B, 0x05, 0x0C, 0x05,
	0x11, 0x2C, 0x15, 0x0E, 0x1B, 0x0D, 0x08, 0x11, 0x09, 0x06, 0x08, 0x05, 0x0B, 0x19, 0x0D, 0x16,
	0x22, 0x10, 0x08, 0x05, 0x05, 0x06, 0x07, 0x09, 0x0D, 0x0A, 0x0B, 0x07, 0x08, 0x10, 0x08, 0x02,
	0x03, 0x01, 0x02, 0x05, 0x05, 0x10, 0x1F, 0x0F, 0x05, 0x0A, 0x04, 0x07, 0x10, 0x07, 0x05, 0x09,
	0x03, 0x09, 0x07, 0x08, 0x0A, 0x02, 0x11, 0x05, 0x0C, 0x06, 0x04, 0x0E, 0x03, 0x01, 0x07, 0x02,
	0x04, 0x07, 0x05, 0x07, 0x0D, 0x08, 0x02, 0x04, 0x02, 0x03, 0x09, 0x03, 0x09, 0x0E, 0x0A, 0x02,
	0x05, 0x02, 0x03, 0x05, 0x03, 0x09, 0x16, 0x0A, 0x07, 0x09, 0x09, 0x0D, 0x1A, 0x0D, 0x36, 0x6B,
	0x34, 0x39, 0x6F, 0x32, 0x22, 0x41, 0x20, 0x0C, 0x18, 0x0B, 0x1A, 0x34, 0x1B, 0xFB, 0x66, 0x01,
	0x05, 0x0A, 0x04, 0x0B, 0x16, 0x0B, 0x01, 0x01, 0x01, 0x10, 0x20, 0x11, 0x02, 0x62, 0x0D, 0x18,
	0x06, 0x04, 0x08, 0x04, 0x06, 0x05, 0x02, 0x02, 0x01, 0x08, 0x0F, 0x0A, 0x01, 0x03, 0x02, 0x01,
	0x01, 0x06, 0x01, 0x02, 0x01, 0x02, 0x03, 0x02, 0x01, 0x02, 0x02, 0x04, 0x03, 0x01, 0x02, 0x01,
	0x02, 0x03, 0x02, 0x02, 0x01, 0x06, 0x05, 0x02, 0x04, 0x01, 0x03, 0x02, 0x03, 0x01, 0x02, 0x04,
	0x01, 0x03, 0x05, 0x02, 0x03, 0x01, 0x07, 0x02, 0x05, 0x06, 0x06, 0x01, 0x01, 0x01, 0x01, 0x03,
	0x02, 0x04, 0x01, 0x02, 0x09, 0x04, 0x04, 0x0E, 0x07, 0x0A, 0x17, 0x13, 0x13, 0x2B, 0x19, 0x0B,
	0x15, 0x0D, 0x0C, 0x0E, 0x04, 0x02, 0x0E, 0x05, 0x05, 0x04, 0x02, 0x03, 0x04, 0x03, 0x02, 0x05,
	0x03, 0x03, 0x0C, 0x06, 0x13, 0x1F, 0x08, 0x03, 0x03, 0x01, 0x0B, 0x0A, 0x03, 0x07, 0x01, 0x01,
	0x0B, 0x03, 0x0C, 0x0E, 0x01, 0x05, 0x05, 0x03, 0x0B, 0x01, 0x08, 0x03, 0x07, 0x09, 0x02, 0x03,
	0x0B, 0x0F, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x01, 0x01, 0x04, 0x07, 0x08, 0x10, 0x08, 0x06,
	0x0E, 0x05, 0x06, 0x01, 0x0A, 0x02, 0x04, 0x06, 0x01, 0x02, 0x05, 0x02, 0x06, 0x02, 0x01, 0x03,
	0x07, 0x01, 0x03, 0x08, 0x01, 0x03, 0x03, 0x01, 0x04, 0x01, 0x03, 0x05, 0x02, 0x03, 0x02, 0x02,
	0x05, 0x08, 0x01, 0x05, 0x01, 0x02, 0x03, 0x01, 0x02, 0x05, 0x02, 0x08, 0x06, 0x09, 0x05, 0x02,
	0x02, 0x04, 0x02, 0x08, 0x18, 0x13, 0x14, 0x38, 0x23, 0x17, 0x31, 0x1B, 0x09, 0x13, 0x09, 0x07,
	0x0F, 0x07, 0x82, 0x02, 0x0E, 0x04, 0x07, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x53,
	0x01, 0x08, 0x07, 0xED, 0x02, 0x78, 0x00, 0xD4, 0x00, 0xE1, 0x00, 0x00, 0x01, 0x2E, 0x01, 0x27,
	0x2E, 0x01, 0x07, 0x06, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16,
	0x06, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x2E, 0x01, 0x27, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x26, 0x06, 0x07,
	0x06, 0x26, 0x27, 0x26, 0x06, 0x27, 0x26, 0x22, 0x07, 0x06, 0x26, 0x27, 0x26, 0x06, 0x27, 0x2E,
	0x01, 0x07, 0x06, 0x26, 0x27, 0x26, 0x06, 0x07, 0x06, 0x26, 0x07, 0x0E, 0x01, 0x27, 0x26, 0x06,
	0x07, 0x06, 0x26, 0x27, 0x26, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x07,
	0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x22, 0x27, 0x16, 0x26, 0x07, 0x0E,
	0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x15, 0x06, 0x16, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37,
	0x32, 0x36, 0x33, 0x32, 0x36, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E,
	0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01,
	0x33, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x15, 0x14, 0x36, 0x33, 0x3A, 0x01, 0x33,
	0x3A, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x03, 0x37, 0x3E, 0x01, 0x37, 0x2E, 0x01, 0x27, 0x05,
	0x1E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x17, 0x07, 0xBA, 0x3D, 0x81,
	0x40, 0x0C, 0x11, 0x09, 0x06, 0x0F, 0x03, 0x06, 0x0B, 0x06, 0x0C, 0x18, 0x0A, 0x06, 0x07, 0x01,
	0x01, 0x02, 0x0A, 0x08, 0x0E, 0x07, 0x04, 0x0B, 0x04, 0x0D, 0x1A, 0x0D, 0x28, 0x52, 0x29, 0x1C,
	0x39, 0x1C, 0x0B, 0x17, 0x0C, 0x04, 0x0A, 0x04, 0x07, 0x03, 0x09, 0x08, 0x06, 0x07, 0x08, 0x08,
	0x08, 0x06, 0x08, 0x04, 0x02, 0x0C, 0x05, 0x08, 0x04, 0x09, 0x06, 0x0B, 0x05, 0x03, 0x09, 0x05,
	0x08, 0x07, 0x08, 0x08, 0x05, 0x07, 0x05, 0x0C, 0x05, 0x02, 0x0B, 0x02, 0x07, 0x06, 0x07, 0x08,
	0x05, 0x09, 0x08, 0x04, 0x07, 0x02, 0x07, 0x02, 0x07, 0x0E, 0x07, 0x31, 0x61, 0x31, 0x3A, 0x77,
	0x3A, 0x3C, 0x78, 0x3C, 0x0D, 0x18, 0x0D, 0x05, 0x0E, 0x05, 0x08, 0x07, 0x0A, 0x03, 0x22, 0x07,
	0x0C, 0x10, 0x04, 0x0E, 0x1C, 0x0C, 0x06, 0x06, 0x01, 0x10, 0x11, 0x0A, 0x12, 0x0C, 0x06, 0x0D,
	0x06, 0x17, 0x2E, 0x16, 0x0C, 0x13, 0x0C, 0x0C, 0x16, 0x0B, 0x17, 0x2F, 0x17, 0x38, 0x70, 0x38,
	0x0A, 0x15, 0x0A, 0x05, 0x11, 0x04, 0x0E, 0x16, 0x12, 0x06, 0x0B, 0x05, 0x0B, 0x14, 0x0C, 0x14,
	0x28, 0x16, 0x07, 0x0F, 0x07, 0x0C, 0x18, 0x0A, 0x14, 0x16, 0x05, 0x01, 0x03, 0x01, 0x01, 0x08,
	0x01, 0x04, 0x01, 0x04, 0x03, 0x0B, 0x03, 0x06, 0x04, 0x1E, 0x03, 0x13, 0x24, 0x13, 0x11, 0x24,
	0x12, 0x3A, 0x77, 0x39, 0x2A, 0x55, 0x54, 0x50, 0x26, 0x31, 0x51, 0x28, 0x0D, 0x19, 0x0D, 0xF8,
	0xDD, 0x07, 0x05, 0x04, 0x03, 0x15, 0x08, 0x0C, 0x0C, 0x03, 0x04, 0x29, 0x0E, 0x01, 0xFF, 0x1A,
	0x28, 0x11, 0x03, 0x01, 0x08, 0x05, 0x07, 0x01, 0x02, 0x04, 0x02, 0x06, 0x0B, 0x09, 0x04, 0x05,
	0x08, 0x07, 0x15, 0x01, 0x01, 0x02, 0x01, 0x01, 0x04, 0x02, 0x04, 0x09, 0x04, 0x0E, 0x1A, 0x0B,
	0x08, 0x0A, 0x06, 0x02, 0x04, 0x02, 0x09, 0x01, 0x02, 0x0C, 0x04, 0x03, 0x02, 0x06, 0x05, 0x03,
	0x03, 0x02, 0x0A, 0x03, 0x03, 0x0C, 0x05, 0x07, 0x04, 0x03, 0x08, 0x03, 0x02, 0x0A, 0x02, 0x05,
	0x04, 0x05, 0x04, 0x04, 0x06, 0x04, 0x08, 0x02, 0x01, 0x0E, 0x01, 0x06, 0x05, 0x05, 0x05, 0x01,
	0x04, 0x05, 0x0B, 0x03, 0x01, 0x01, 0x02, 0x02, 0x04, 0x03, 0x07, 0x08, 0x13, 0x0E, 0x03, 0x05,
	0x02, 0x01, 0x01, 0x04, 0x06, 0x03, 0x0F, 0x03, 0x02, 0x03, 0x21, 0x09, 0x19, 0x33, 0x1A, 0x0C,
	0x17, 0x0D, 0x12, 0x1E, 0x08, 0x04, 0x05, 0x03, 0x02, 0x04, 0x02, 0x08, 0x17, 0x0A, 0x05, 0x07,
	0x03, 0x02, 0x04, 0x01, 0x04, 0x05, 0x04, 0x04, 0x0A, 0x03, 0x01, 0x02, 0x04, 0x09, 0x10, 0x04,
	0x02, 0x09, 0x03, 0x08, 0x0F, 0x05, 0x09, 0x04, 0x03, 0x01, 0x02, 0x01, 0x01, 0x0D, 0x06, 0x0C,
	0x26, 0x17, 0x07, 0x0E, 0x06, 0x01, 0x02, 0x02, 0x03, 0x03, 0x04, 0x02, 0x04, 0x08, 0x06, 0x0B,
	0x03, 0x01, 0x01, 0x01, 0x01, 0x05, 0x04, 0x0E, 0x15, 0x1E, 0x13, 0x19, 0x43, 0x24, 0x06, 0x0B,
	0x05, 0x96, 0x0A, 0x10, 0x0C, 0x06, 0x0F, 0x03, 0x04, 0x0C, 0x0D, 0x16, 0x0F, 0x0A, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x52, 0x00, 0x54, 0x07, 0xD3, 0x03, 0x2C, 0x00, 0xBF, 0x00, 0xD8, 0x00, 0x00,
	0x01, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27,
	0x22, 0x26, 0x27, 0x22, 0x26, 0x27, 0x26, 0x06, 0x07, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x27, 0x2E, 0x01, 0x07, 0x22, 0x06, 0x23, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x15, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07,
	0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x23, 0x22, 0x06, 0x17, 0x0E, 0x01, 0x07, 0x06,
	0x26, 0x23, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x17, 0x16, 0x26, 0x07, 0x0E, 0x01,
	0x07, 0x06, 0x16, 0x17, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07,
	0x0E, 0x01, 0x15, 0x06, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x37, 0x3E,
	0x01, 0x37, 0x36, 0x34, 0x35, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x17, 0x16, 0x36,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x17, 0x16, 0x32, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x17,
	0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x36, 0x26, 0x37, 0x3E, 0x01, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x03, 0x17, 0x2E, 0x01, 0x27, 0x05, 0x0E,
	0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x32, 0x36,
	0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x07, 0x07, 0x9D, 0x16, 0x35, 0x1F, 0x2B, 0x69, 0x3B, 0x2C,
	0x5F, 0x32, 0x20, 0x41, 0x21, 0x17, 0x2F, 0x17, 0x07, 0x0E, 0x07, 0x01, 0x07, 0x02, 0x08, 0x2E,
	0x0C, 0x05, 0x0E, 0x04, 0x0B, 0x1B, 0x0D, 0x26, 0x58, 0x28, 0x07, 0x10, 0x07, 0x03, 0x07, 0x04,
	0x04, 0x09, 0x04, 0x07, 0x07, 0x07, 0x0B, 0x17, 0x0B, 0x45, 0x83, 0x3F, 0x0F, 0x1C, 0x0E, 0x03,
	0x01, 0x01, 0x07, 0x02, 0x06, 0x0B, 0x03, 0x04, 0x06, 0x07, 0x0B, 0x0E, 0x03, 0x01, 0x06, 0x06,
	0x08, 0x13, 0x02, 0x03, 0x03, 0x07, 0x05, 0x0A, 0x05, 0x06, 0x08, 0x01, 0x04, 0x02, 0x0A, 0x06,
	0x13, 0x02, 0x02, 0x24, 0x06, 0x06, 0x06, 0x03, 0x02, 0x05, 0x06, 0x06, 0x0F, 0x02, 0x02, 0x05,
	0x02, 0x05, 0x0A, 0x05, 0x04, 0x0F, 0x09, 0x04, 0x0F, 0x02, 0x37, 0x09, 0x05, 0x09, 0x05, 0x08,
	0x11, 0x09, 0x1D, 0x45, 0x22, 0x35, 0x4B, 0x04, 0x01, 0x07, 0x07, 0x02, 0x07, 0x0E, 0x0A, 0x16,
	0x39, 0x1C, 0x08, 0x06, 0x04, 0x09, 0x13, 0x0D, 0x1D, 0x47, 0x24, 0x0C, 0x06, 0x06, 0x08, 0x1B,
	0x0F, 0x1E, 0x4B, 0x1D, 0x10, 0x1A, 0x09, 0x04, 0x0B, 0x0A, 0x07, 0x2F, 0x04, 0x07, 0x08, 0x0B,
	0x06, 0x0D, 0x06, 0x1C, 0x37, 0x1D, 0x32, 0x65, 0x33, 0x41, 0x85, 0x3B, 0x23, 0x45, 0x3E, 0x37,
	0x15, 0x04, 0x20, 0x12, 0xF9, 0xE4, 0x10, 0x24, 0x17, 0x16, 0x1F, 0x14, 0x16, 0x16, 0x08, 0x08,
	0x04, 0x07, 0x07, 0x34, 0x19, 0x0F, 0x1F, 0x0F, 0x1C, 0x2D, 0x06, 0x08, 0x0E, 0x15, 0x01, 0x62,
	0x2A, 0x4D, 0x24, 0x33, 0x52, 0x20, 0x18, 0x29, 0x0A, 0x07, 0x0E, 0x03, 0x01, 0x04, 0x02, 0x01,
	0x01, 0x11, 0x03, 0x0A, 0x0B, 0x02, 0x10, 0x03, 0x0A, 0x0E, 0x05, 0x0F, 0x09, 0x04, 0x01, 0x02,
	0x01, 0x04, 0x01, 0x06, 0x01, 0x03, 0x03, 0x01, 0x03, 0x06, 0x02, 0x11, 0x2E, 0x22, 0x08, 0x10,
	0x08, 0x01, 0x03, 0x03, 0x02, 0x03, 0x01, 0x03, 0x06, 0x05, 0x05, 0x07, 0x02, 0x03, 0x03, 0x0E,
	0x0A, 0x03, 0x06, 0x0A, 0x07, 0x09, 0x01, 0x02, 0x08, 0x07, 0x05, 0x08, 0x0C, 0x01, 0x01, 0x05,
	0x0C, 0x11, 0x01, 0x08, 0x08, 0x12, 0x0A, 0x08, 0x06, 0x06, 0x03, 0x06, 0x07, 0x08, 0x10, 0x08,
	0x12, 0x23, 0x12, 0x10, 0x1F, 0x0E, 0x06, 0x12, 0x07, 0x0E, 0x07, 0x02, 0x02, 0x07, 0x03, 0x05,
	0x0A, 0x05, 0x12, 0x12, 0x09, 0x0D, 0x57, 0x36, 0x07, 0x0D, 0x07, 0x05, 0x12, 0x03, 0x0C, 0x17,
	0x09, 0x16, 0x03, 0x02, 0x01, 0x0B, 0x06, 0x0D, 0x18, 0x0A, 0x18, 0x0D, 0x0B, 0x04, 0x0B, 0x11,
	0x1D, 0x0A, 0x16, 0x02, 0x15, 0x0C, 0x20, 0x11, 0x07, 0x22, 0x03, 0x01, 0x13, 0x05, 0x08, 0x0A,
	0x05, 0x02, 0x04, 0x02, 0x08, 0x0F, 0x05, 0x09, 0x05, 0x05, 0x06, 0x2B, 0x1E, 0x12, 0x2E, 0x37,
	0x3E, 0x22, 0x28, 0x4E, 0x24, 0xBE, 0x12, 0x10, 0x02, 0x02, 0x05, 0x0C, 0x0D, 0x21, 0x16, 0x17,
	0x2D, 0x17, 0x17, 0x2E, 0x02, 0x01, 0x05, 0x0A, 0x33, 0x1D, 0x1E, 0x3E, 0x17, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x52, 0x00, 0x94, 0x08, 0xD3, 0x02, 0xED, 0x01, 0x94, 0x01, 0xAA, 0x00, 0x00,
	0x01, 0x3E, 0x01, 0x37, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x22, 0x23,
	0x1E, 0x01, 0x23, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x23, 0x22, 0x26, 0x23, 0x1E, 0x01, 0x23, 0x22,
	0x26, 0x27, 0x2E, 0x01, 0x27, 0x22, 0x26, 0x23, 0x1E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01,
	0x23, 0x06, 0x22, 0x23, 0x1E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x23,
	0x1E, 0x01, 0x07, 0x22, 0x26, 0x27, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x1E, 0x01, 0x27, 0x2E,
	0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x27, 0x2E, 0x01,
	0x27, 0x26, 0x06, 0x23, 0x22, 0x26, 0x23, 0x1E, 0x01, 0x07, 0x14, 0x06, 0x27, 0x2E, 0x01, 0x27,
	0x2E, 0x01, 0x27, 0x26, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x35, 0x3C,
	0x01, 0x27, 0x34, 0x26, 0x35, 0x34, 0x26, 0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01,
	0x15, 0x14, 0x26, 0x15, 0x06, 0x14, 0x07, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x07, 0x22, 0x06, 0x23,
	0x0E, 0x01, 0x07, 0x14, 0x26, 0x23, 0x22, 0x26, 0x27, 0x26, 0x06, 0x23, 0x22, 0x26, 0x23, 0x26,
	0x22, 0x23, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x22, 0x26, 0x27, 0x34, 0x26, 0x23, 0x22, 0x06,
	0x23, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x15, 0x06, 0x22, 0x23, 0x22, 0x26, 0x23, 0x2A, 0x01, 0x23,
	0x22, 0x06, 0x07, 0x06, 0x26, 0x27, 0x26, 0x06, 0x23, 0x22, 0x06, 0x23, 0x22, 0x06, 0x23, 0x22,
	0x06, 0x23, 0x22, 0x26, 0x27, 0x2E, 0x01, 0x23, 0x26, 0x22, 0x27, 0x22, 0x26, 0x07, 0x0E, 0x01,
	0x23, 0x2A, 0x01, 0x07, 0x06, 0x14, 0x15, 0x14, 0x06, 0x17, 0x1E, 0x01, 0x15, 0x1C, 0x01, 0x17,
	0x16, 0x36, 0x33, 0x3E, 0x01, 0x33, 0x32, 0x16, 0x17, 0x16, 0x32, 0x33, 0x16, 0x32, 0x33, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x33, 0x32, 0x16, 0x33, 0x32, 0x16, 0x33, 0x32, 0x16,
	0x33, 0x32, 0x16, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x33, 0x32, 0x36, 0x33, 0x32, 0x26, 0x37,
	0x36, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x33, 0x3E,
	0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x26, 0x17, 0x3A, 0x01, 0x17, 0x1E, 0x01, 0x33, 0x32, 0x16,
	0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x33, 0x32, 0x36, 0x37, 0x1C, 0x01, 0x33, 0x16, 0x14, 0x15,
	0x16, 0x14, 0x15, 0x14, 0x16, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x33, 0x32, 0x36, 0x35, 0x3C,
	0x01, 0x35, 0x34, 0x36, 0x35, 0x3C, 0x01, 0x35, 0x3C, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36,
	0x33, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x33, 0x32, 0x36, 0x33, 0x32, 0x3E, 0x01, 0x32, 0x37, 0x3A,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x25, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x17, 0x16, 0x06, 0x07, 0x06,
	0x26, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x27, 0x26, 0x36, 0x37, 0x08, 0x9A, 0x0E, 0x1D, 0x0E,
	0x28, 0x52, 0x29, 0x3F, 0x80, 0x40, 0x21, 0x42, 0x21, 0x13, 0x24, 0x14, 0x06, 0x01, 0x0C, 0x07,
	0x06, 0x03, 0x03, 0x09, 0x07, 0x07, 0x10, 0x08, 0x08, 0x05, 0x0E, 0x08, 0x08, 0x03, 0x05, 0x03,
	0x09, 0x08, 0x10, 0x08, 0x05, 0x0A, 0x0C, 0x08, 0x0D, 0x03, 0x02, 0x04, 0x08, 0x08, 0x11, 0x09,
	0x06, 0x04, 0x0E, 0x09, 0x07, 0x03, 0x05, 0x05, 0x0A, 0x09, 0x10, 0x08, 0x06, 0x06, 0x10, 0x09,
	0x07, 0x03, 0x04, 0x04, 0x09, 0x09, 0x10, 0x09, 0x05, 0x04, 0x10, 0x07, 0x06, 0x03, 0x05, 0x06,
	0x09, 0x08, 0x11, 0x08, 0x04, 0x05, 0x01, 0x02, 0x0E, 0x07, 0x08, 0x08, 0x04, 0x01, 0x20, 0x03,
	0x09, 0x14, 0x09, 0x04, 0x09, 0x01, 0x12, 0x03, 0x03, 0x06, 0x03, 0x02, 0x09, 0x05, 0x01, 0x08,
	0x02, 0x08, 0x10, 0x08, 0x11, 0x23, 0x11, 0x09, 0x04, 0x01, 0x01, 0x24, 0x07, 0x01, 0x01, 0x01,
	0x02, 0x04, 0x07, 0x0F, 0x07, 0x10, 0x21, 0x10, 0x06, 0x01, 0x03, 0x08, 0x02, 0x02, 0x01, 0x02,
	0x02, 0x0D, 0x02, 0x09, 0x13, 0x0A, 0x06, 0x0C, 0x06, 0x02, 0x01, 0x01, 0x02, 0x02, 0x05, 0x05,
	0x02, 0x02, 0x02, 0x02, 0x06, 0x0D, 0x06, 0x0F, 0x1D, 0x0F, 0x01, 0x03, 0x02, 0x02, 0x05, 0x04,
	0x02, 0x06, 0x10, 0x21, 0x10, 0x06, 0x04, 0x04, 0x07, 0x05, 0x05, 0x03, 0x0B, 0x03, 0x0A, 0x12,
	0x0A, 0x07, 0x0D, 0x07, 0x04, 0x03, 0x05, 0x07, 0x06, 0x06, 0x05, 0x0B, 0x05, 0x10, 0x1F, 0x10,
	0x17, 0x2F, 0x16, 0x0E, 0x19, 0x0D, 0x03, 0x0E, 0x01, 0x02, 0x08, 0x02, 0x01, 0x05, 0x03, 0x04,
	0x0E, 0x07, 0x03, 0x06, 0x03, 0x01, 0x05, 0x01, 0x04, 0x0D, 0x05, 0x0C, 0x17, 0x0C, 0x1C, 0x39,
	0x1C, 0x05, 0x09, 0x04, 0x07, 0x07, 0x08, 0x03, 0x03, 0x04, 0x08, 0x0E, 0x07, 0x09, 0x11, 0x09,
	0x03, 0x0E, 0x03, 0x03, 0x05, 0x06, 0x05, 0x04, 0x07, 0x10, 0x21, 0x10, 0x07, 0x01, 0x05, 0x08,
	0x02, 0x04, 0x0C, 0x18, 0x0D, 0x08, 0x1B, 0x05, 0x02, 0x09, 0x03, 0x02, 0x02, 0x06, 0x0E, 0x1D,
	0x0F, 0x05, 0x09, 0x04, 0x05, 0x02, 0x06, 0x03, 0x03, 0x01, 0x01, 0x02, 0x01, 0x04, 0x08, 0x04,
	0x10, 0x1F, 0x0F, 0x06, 0x0A, 0x06, 0x03, 0x02, 0x02, 0x03, 0x05, 0x01, 0x01, 0x10, 0x03, 0x01,
	0x0F, 0x01, 0x01, 0x04, 0x09, 0x04, 0x20, 0x3E, 0x20, 0x0A, 0x13, 0x08, 0x04, 0x02, 0x05, 0x2D,
	0x59, 0x2D, 0x43, 0x87, 0x86, 0x88, 0x43, 0x10, 0x20, 0x10, 0x4E, 0x94, 0x43, 0xFE, 0x62, 0x0D,
	0x1A, 0x0E, 0x06, 0x08, 0x02, 0x03, 0x08, 0x09, 0x04, 0x0D, 0x04, 0x08, 0x0F, 0x07, 0x06, 0x0C,
	0x02, 0x05, 0x0C, 0x09, 0x01, 0x82, 0x09, 0x11, 0x09, 0x0A, 0x14, 0x07, 0x0C, 0x16, 0x0C, 0x06,
	0x0C, 0x05, 0x04, 0x06, 0x16, 0x01, 0x0E, 0x05, 0x06, 0x01, 0x01, 0x05, 0x19, 0x0D, 0x07, 0x08,
	0x03, 0x01, 0x01, 0x06, 0x16, 0x04, 0x03, 0x09, 0x07, 0x06, 0x0C, 0x01, 0x06, 0x1B, 0x02, 0x01,
	0x0D, 0x07, 0x09, 0x01, 0x07, 0x18, 0x01, 0x10, 0x06, 0x08, 0x02, 0x08, 0x1B, 0x03, 0x01, 0x0F,
	0x06, 0x08, 0x01, 0x01, 0x01, 0x03, 0x04, 0x0C, 0x05, 0x09, 0x06, 0x04, 0x04, 0x13, 0x09, 0x03,
	0x02, 0x01, 0x05, 0x0D, 0x07, 0x05, 0x0C, 0x06, 0x07, 0x0D, 0x07, 0x05, 0x08, 0x05, 0x01, 0x01,
	0x01, 0x09, 0x0E, 0x1D, 0x0E, 0x1F, 0x3F, 0x20, 0x09, 0x02, 0x09, 0x13, 0x28, 0x13, 0x19, 0x33,
	0x19, 0x06, 0x0C, 0x06, 0x03, 0x02, 0x02, 0x05, 0x0A, 0x06, 0x05, 0x05, 0x01, 0x01, 0x01, 0x04,
	0x06, 0x01, 0x01, 0x09, 0x01, 0x02, 0x01, 0x01, 0x01, 0x02, 0x02, 0x04, 0x02, 0x01, 0x01, 0x04,
	0x02, 0x04, 0x01, 0x06, 0x01, 0x04, 0x0B, 0x01, 0x05, 0x09, 0x0C, 0x03, 0x01, 0x02, 0x01, 0x01,
	0x0B, 0x02, 0x03, 0x02, 0x05, 0x01, 0x01, 0x04, 0x03, 0x01, 0x02, 0x04, 0x06, 0x0B, 0x06, 0x19,
	0x30, 0x1A, 0x0D, 0x18, 0x0D, 0x05, 0x0C, 0x04, 0x06, 0x02, 0x01, 0x01, 0x05, 0x01, 0x02, 0x01,
	0x01, 0x02, 0x01, 0x01, 0x04, 0x02, 0x04, 0x04, 0x0C, 0x01, 0x01, 0x03, 0x02, 0x02, 0x0F, 0x09,
	0x06, 0x01, 0x01, 0x08, 0x02, 0x04, 0x0F, 0x03, 0x08, 0x03, 0x06, 0x05, 0x05, 0x04, 0x01, 0x01,
	0x0D, 0x01, 0x03, 0x01, 0x06, 0x02, 0x01, 0x06, 0x03, 0x02, 0x12, 0x02, 0x02, 0x05, 0x0F, 0x1F,
	0x0F, 0x11, 0x22, 0x11, 0x04, 0x07, 0x04, 0x02, 0x04, 0x04, 0x02, 0x04, 0x07, 0x03, 0x11, 0x22,
	0x11, 0x0F, 0x1E, 0x0F, 0x01, 0x05, 0x01, 0x07, 0x05, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x06, 0x31, 0x28, 0x47, 0x08, 0x07, 0x0B, 0x13, 0x06, 0x02, 0x02, 0x0A, 0x04, 0x0C, 0x12, 0x07,
	0x00, 0x02, 0x00, 0x51, 0x00, 0xE8, 0x08, 0x53, 0x02, 0x98, 0x01, 0x6C, 0x01, 0x78, 0x00, 0x00,
	0x01, 0x16, 0x06, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x1E, 0x01, 0x15, 0x0E, 0x01, 0x27,
	0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x1E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E,
	0x01, 0x27, 0x1E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x1E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x2A, 0x01, 0x07, 0x22, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x1E, 0x01, 0x07,
	0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x1E, 0x01, 0x07, 0x06, 0x22, 0x27, 0x2E,
	0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x16, 0x14, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27,
	0x2E, 0x01, 0x27, 0x26, 0x22, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x23, 0x22, 0x26, 0x27, 0x26,
	0x06, 0x07, 0x06, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x26, 0x06, 0x23, 0x36, 0x26,
	0x37, 0x26, 0x06, 0x15, 0x14, 0x06, 0x27, 0x2E, 0x01, 0x15, 0x14, 0x06, 0x27, 0x26, 0x36, 0x07,
	0x22, 0x16, 0x07, 0x22, 0x36, 0x27, 0x26, 0x16, 0x23, 0x06, 0x26, 0x15, 0x14, 0x06, 0x35, 0x2E,
	0x01, 0x15, 0x14, 0x06, 0x27, 0x26, 0x36, 0x07, 0x06, 0x16, 0x23, 0x06, 0x26, 0x07, 0x22, 0x16,
	0x07, 0x2A, 0x01, 0x07, 0x22, 0x06, 0x23, 0x06, 0x22, 0x23, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x07,
	0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06,
	0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x33,
	0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x1E,
	0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36,
	0x17, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x15, 0x1E, 0x01, 0x33,
	0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x33, 0x32, 0x16, 0x33, 0x32,
	0x16, 0x33, 0x3A, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36,
	0x33, 0x32, 0x36, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x2E, 0x01, 0x27, 0x31, 0x01, 0x06, 0x26,
	0x37, 0x36, 0x16, 0x17, 0x16, 0x06, 0x07, 0x06, 0x37, 0x07, 0x76, 0x0C, 0x0B, 0x0E, 0x05, 0x07,
	0x02, 0x04, 0x06, 0x08, 0x04, 0x05, 0x02, 0x11, 0x05, 0x04, 0x08, 0x03, 0x04, 0x05, 0x09, 0x04,
	0x02, 0x07, 0x04, 0x10, 0x03, 0x05, 0x06, 0x02, 0x04, 0x06, 0x06, 0x04, 0x05, 0x08, 0x05, 0x0C,
	0x05, 0x05, 0x06, 0x02, 0x03, 0x05, 0x08, 0x03, 0x06, 0x02, 0x02, 0x01, 0x04, 0x05, 0x09, 0x04,
	0x06, 0x08, 0x02, 0x03, 0x06, 0x07, 0x01, 0x06, 0x03, 0x04, 0x0A, 0x06, 0x06, 0x05, 0x04, 0x04,
	0x06, 0x09, 0x03, 0x02, 0x01, 0x03, 0x13, 0x05, 0x05, 0x05, 0x03, 0x01, 0x04, 0x01, 0x02, 0x03,
	0x05, 0x02, 0x02, 0x04, 0x0D, 0x05, 0x06, 0x06, 0x04, 0x04, 0x0F, 0x05, 0x0B, 0x14, 0x0A, 0x14,
	0x27, 0x17, 0x35, 0x6F, 0x35, 0x13, 0x26, 0x13, 0x07, 0x0E, 0x07, 0x02, 0x08, 0x02, 0x06, 0x0B,
	0x07, 0x04, 0x0B, 0x05, 0x09, 0x11, 0x09, 0x0A, 0x11, 0x08, 0x03, 0x09, 0x04, 0x03, 0x07, 0x04,
	0x03, 0x0B, 0x01, 0x02, 0x06, 0x03, 0x01, 0x02, 0x01, 0x04, 0x03, 0x04, 0x01, 0x01, 0x06, 0x01,
	0x05, 0x03, 0x04, 0x06, 0x03, 0x03, 0x03, 0x06, 0x03, 0x02, 0x07, 0x02, 0x01, 0x05, 0x08, 0x08,
	0x01, 0x06, 0x04, 0x03, 0x04, 0x04, 0x07, 0x03, 0x03, 0x05, 0x04, 0x01, 0x04, 0x02, 0x01, 0x03,
	0x04, 0x07, 0x03, 0x06, 0x0C, 0x06, 0x0D, 0x18, 0x0D, 0x19, 0x32, 0x19, 0x3A, 0x73, 0x35, 0x20,
	0x3E, 0x21, 0x0B, 0x16, 0x0B, 0x0E, 0x12, 0x08, 0x07, 0x0D, 0x08, 0x08, 0x10, 0x06, 0x06, 0x08,
	0x08, 0x06, 0x0D, 0x05, 0x10, 0x21, 0x10, 0x07, 0x13, 0x09, 0x0B, 0x0F, 0x06, 0x0A, 0x17, 0x0F,
	0x0B, 0x18, 0x0B, 0x07, 0x0D, 0x06, 0x08, 0x0C, 0x06, 0x07, 0x10, 0x09, 0x06, 0x0D, 0x06, 0x0E,
	0x1A, 0x0D, 0x05, 0x0B, 0x05, 0x08, 0x0B, 0x05, 0x0C, 0x16, 0x0D, 0x18, 0x3C, 0x0C, 0x07, 0x0D,
	0x08, 0x0C, 0x10, 0x04, 0x08, 0x1C, 0x18, 0x18, 0x29, 0x14, 0x09, 0x0F, 0x07, 0x02, 0x02, 0x01,
	0x02, 0x06, 0x0C, 0x0A, 0x05, 0x0D, 0x01, 0x0B, 0x04, 0x0C, 0x1A, 0x0C, 0x0C, 0x0C, 0x03, 0x06,
	0x0D, 0x05, 0x03, 0x24, 0x09, 0x1F, 0x3E, 0x1F, 0x3F, 0x7E, 0x3E, 0x05, 0x08, 0x04, 0x0C, 0x15,
	0x08, 0x06, 0x0A, 0x04, 0x01, 0x03, 0x01, 0x03, 0x11, 0x03, 0x06, 0x0D, 0x06, 0x0A, 0x14, 0x08,
	0x20, 0x40, 0x20, 0x2B, 0x55, 0x2A, 0x0E, 0x1B, 0x0E, 0x07, 0x0F, 0x05, 0x16, 0x28, 0x15, 0x11,
	0x23, 0x11, 0x37, 0x6F, 0x37, 0xFC, 0x48, 0x0F, 0x19, 0x10, 0x07, 0x12, 0x03, 0x03, 0x04, 0x03,
	0x03, 0x01, 0x02, 0x58, 0x07, 0x1A, 0x07, 0x02, 0x0A, 0x05, 0x07, 0x06, 0x02, 0x04, 0x0A, 0x06,
	0x08, 0x05, 0x05, 0x03, 0x0A, 0x04, 0x09, 0x06, 0x02, 0x06, 0x13, 0x05, 0x03, 0x02, 0x03, 0x03,
	0x0B, 0x04, 0x07, 0x06, 0x01, 0x06, 0x11, 0x05, 0x04, 0x05, 0x03, 0x03, 0x0B, 0x05, 0x07, 0x04,
	0x01, 0x03, 0x0E, 0x04, 0x04, 0x03, 0x01, 0x01, 0x0D, 0x05, 0x06, 0x08, 0x01, 0x03, 0x10, 0x03,
	0x04, 0x06, 0x04, 0x04, 0x09, 0x06, 0x07, 0x08, 0x01, 0x04, 0x10, 0x05, 0x07, 0x03, 0x03, 0x09,
	0x05, 0x03, 0x05, 0x03, 0x04, 0x01, 0x04, 0x0B, 0x04, 0x05, 0x06, 0x06, 0x05, 0x10, 0x06, 0x06,
	0x01, 0x01, 0x02, 0x0D, 0x04, 0x0A, 0x0E, 0x03, 0x07, 0x0A, 0x0A, 0x03, 0x07, 0x04, 0x01, 0x03,
	0x01, 0x01, 0x02, 0x04, 0x09, 0x03, 0x02, 0x02, 0x0A, 0x03, 0x02, 0x0A, 0x04, 0x02, 0x02, 0x04,
	0x02, 0x05, 0x02, 0x01, 0x05, 0x04, 0x04, 0x0B, 0x02, 0x03, 0x01, 0x01, 0x02, 0x03, 0x02, 0x03,
	0x03, 0x02, 0x04, 0x03, 0x03, 0x07, 0x02, 0x01, 0x05, 0x01, 0x07, 0x01, 0x04, 0x01, 0x02, 0x09,
	0x02, 0x09, 0x09, 0x01, 0x01, 0x02, 0x03, 0x01, 0x02, 0x04, 0x02, 0x01, 0x01, 0x04, 0x01, 0x01,
	0x04, 0x01, 0x05, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x05, 0x03, 0x08, 0x1A, 0x17, 0x0D,
	0x1B, 0x09, 0x03, 0x04, 0x01, 0x01, 0x08, 0x0C, 0x0A, 0x14, 0x08, 0x0A, 0x13, 0x0B, 0x0C, 0x13,
	0x0A, 0x08, 0x0F, 0x08, 0x1B, 0x34, 0x1A, 0x0A, 0x05, 0x04, 0x04, 0x18, 0x09, 0x0D, 0x1A, 0x09,
	0x05, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x0C, 0x05, 0x06, 0x09, 0x02, 0x01, 0x05, 0x01, 0x03,
	0x04, 0x02, 0x05, 0x01, 0x01, 0x07, 0x04, 0x07, 0x12, 0x05, 0x09, 0x19, 0x16, 0x0C, 0x16, 0x0B,
	0x11, 0x20, 0x08, 0x16, 0x25, 0x07, 0x07, 0x0E, 0x0C, 0x06, 0x14, 0x09, 0x03, 0x05, 0x07, 0x02,
	0x06, 0x02, 0x06, 0x0C, 0x05, 0x0C, 0x15, 0x0A, 0x06, 0x0E, 0x09, 0x05, 0x03, 0x01, 0x03, 0x02,
	0x02, 0x08, 0x0C, 0x1B, 0x36, 0x1B, 0x0D, 0x02, 0x01, 0x01, 0x01, 0x01, 0x08, 0x07, 0x04, 0x0A,
	0x06, 0x02, 0x0B, 0x01, 0x02, 0x02, 0x01, 0x01, 0x01, 0x02, 0x06, 0x03, 0x04, 0x15, 0x0C, 0x05,
	0x08, 0x04, 0x02, 0x04, 0x05, 0x16, 0x2B, 0x15, 0x13, 0x24, 0x12, 0x07, 0x0E, 0x07, 0xFE, 0xAF,
	0x0E, 0x20, 0x0B, 0x04, 0x05, 0x08, 0x06, 0x09, 0x05, 0x03, 0x01, 0x00, 0x00, 0x01, 0x00, 0x53,
	0x01, 0x09, 0x08, 0x53, 0x02, 0x77, 0x01, 0x8D, 0x00, 0x00, 0x01, 0x2E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x31, 0x2E, 0x01, 0x27, 0x22, 0x26, 0x27, 0x2E, 0x01, 0x23, 0x30, 0x31, 0x27, 0x26, 0x06,
	0x23, 0x22, 0x06, 0x27, 0x2A, 0x01, 0x23, 0x2E, 0x01, 0x07, 0x22, 0x06, 0x07, 0x17, 0x30, 0x31,
	0x23, 0x2E, 0x01, 0x27, 0x0E, 0x01, 0x07, 0x30, 0x23, 0x22, 0x23, 0x26, 0x06, 0x23, 0x22, 0x26,
	0x23, 0x31, 0x22, 0x23, 0x2E, 0x01, 0x27, 0x16, 0x14, 0x17, 0x23, 0x31, 0x14, 0x06, 0x15, 0x2E,
	0x01, 0x27, 0x06, 0x26, 0x27, 0x22, 0x26, 0x23, 0x14, 0x16, 0x15, 0x22, 0x26, 0x15, 0x30, 0x2B,
	0x01, 0x2E, 0x01, 0x27, 0x0E, 0x01, 0x07, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x27, 0x22, 0x26, 0x27,
	0x0E, 0x01, 0x15, 0x30, 0x31, 0x23, 0x2E, 0x01, 0x27, 0x06, 0x26, 0x07, 0x2E, 0x01, 0x27, 0x16,
	0x14, 0x15, 0x30, 0x39, 0x01, 0x22, 0x26, 0x23, 0x2E, 0x01, 0x27, 0x0E, 0x01, 0x07, 0x22, 0x23,
	0x15, 0x0E, 0x01, 0x07, 0x2E, 0x01, 0x27, 0x1E, 0x01, 0x17, 0x2E, 0x01, 0x23, 0x22, 0x06, 0x15,
	0x2A, 0x01, 0x23, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x26, 0x22, 0x23, 0x1C, 0x01, 0x15, 0x30,
	0x31, 0x15, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x30, 0x15, 0x16, 0x15, 0x14, 0x06, 0x23, 0x06,
	0x22, 0x23, 0x2E, 0x01, 0x27, 0x1E, 0x01, 0x17, 0x2A, 0x01, 0x15, 0x2E, 0x01, 0x23, 0x26, 0x22,
	0x07, 0x2A, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x14, 0x16, 0x17, 0x0E, 0x01, 0x07, 0x22, 0x26, 0x07,
	0x2E, 0x01, 0x27, 0x06, 0x22, 0x27, 0x06, 0x22, 0x07, 0x23, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x15,
	0x22, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x3E, 0x01, 0x35, 0x2E, 0x01, 0x27, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x07, 0x14, 0x16, 0x17, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x26, 0x06, 0x27, 0x06, 0x26,
	0x07, 0x2E, 0x01, 0x27, 0x06, 0x26, 0x07, 0x26, 0x06, 0x07, 0x22, 0x06, 0x07, 0x06, 0x26, 0x07,
	0x26, 0x06, 0x27, 0x0E, 0x01, 0x07, 0x06, 0x14, 0x07, 0x0E, 0x01, 0x07, 0x22, 0x26, 0x23, 0x16,
	0x14, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x37, 0x1E, 0x01, 0x37,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16,
	0x06, 0x07, 0x06, 0x16, 0x07, 0x32, 0x36, 0x37, 0x34, 0x26, 0x35, 0x3E, 0x01, 0x37, 0x3E, 0x01,
	0x27, 0x26, 0x36, 0x37, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x37,
	0x36, 0x32, 0x33, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x37, 0x16, 0x36, 0x37, 0x16, 0x36, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x2A, 0x01, 0x27, 0x07, 0xED, 0x17, 0x2E, 0x16, 0x17, 0x2F, 0x16,
	0x03, 0x06, 0x03, 0x01, 0x02, 0x01, 0x02, 0x05, 0x03, 0x01, 0x07, 0x0E, 0x07, 0x0D, 0x19, 0x0D,
	0x01, 0x03, 0x01, 0x02, 0x04, 0x04, 0x0D, 0x1A, 0x0D, 0x01, 0x01, 0x01, 0x03, 0x01, 0x02, 0x06,
	0x03, 0x01, 0x01, 0x01, 0x04, 0x0B, 0x05, 0x02, 0x05, 0x03, 0x01, 0x01, 0x04, 0x0B, 0x05, 0x01,
	0x01, 0x01, 0x01, 0x03, 0x05, 0x03, 0x05, 0x17, 0x07, 0x02, 0x05, 0x02, 0x01, 0x01, 0x02, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x04, 0x08, 0x04, 0x03, 0x06, 0x03, 0x02, 0x07, 0x02,
	0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x05, 0x0C, 0x06, 0x06, 0x0C, 0x07, 0x01, 0x02, 0x04, 0x01,
	0x01, 0x01, 0x01, 0x02, 0x04, 0x02, 0x01, 0x01, 0x03, 0x04, 0x02, 0x09, 0x0D, 0x09, 0x01, 0x04,
	0x01, 0x03, 0x0A, 0x03, 0x01, 0x01, 0x04, 0x08, 0x03, 0x04, 0x06, 0x03, 0x02, 0x04, 0x02, 0x02,
	0x03, 0x02, 0x02, 0x03, 0x01, 0x03, 0x04, 0x02, 0x01, 0x02, 0x01, 0x01, 0x03, 0x01, 0x09, 0x13,
	0x09, 0x01, 0x04, 0x02, 0x01, 0x01, 0x03, 0x06, 0x04, 0x04, 0x07, 0x04, 0x03, 0x07, 0x04, 0x03,
	0x09, 0x04, 0x01, 0x01, 0x08, 0x10, 0x07, 0x07, 0x0E, 0x07, 0x01, 0x04, 0x01, 0x04, 0x08, 0x03,
	0x01, 0x02, 0x02, 0x02, 0x04, 0x02, 0x02, 0x02, 0x02, 0x02, 0x05, 0x02, 0x0A, 0x14, 0x0A, 0x04,
	0x03, 0x06, 0x0C, 0x06, 0x06, 0x0B, 0x07, 0x07, 0x0E, 0x07, 0x01, 0x01, 0x05, 0x0B, 0x06, 0x12,
	0x28, 0x13, 0x16, 0x2C, 0x16, 0x11, 0x21, 0x11, 0x3A, 0x74, 0x3A, 0x22, 0x44, 0x23, 0x14, 0x28,
	0x14, 0x09, 0x13, 0x09, 0x09, 0x0E, 0x08, 0x16, 0x28, 0x14, 0x08, 0x14, 0x03, 0x03, 0x01, 0x05,
	0x08, 0x03, 0x03, 0x07, 0x03, 0x01, 0x02, 0x06, 0x0E, 0x04, 0x05, 0x03, 0x0D, 0x06, 0x11, 0x08,
	0x0A, 0x13, 0x09, 0x03, 0x05, 0x05, 0x0D, 0x1E, 0x0B, 0x12, 0x24, 0x12, 0x1B, 0x37, 0x1B, 0x1C,
	0x38, 0x1C, 0x2C, 0x57, 0x2B, 0x16, 0x29, 0x14, 0x0C, 0x19, 0x0D, 0x0F, 0x1C, 0x0E, 0x09, 0x0E,
	0x06, 0x0D, 0x18, 0x0B, 0x01, 0x06, 0x02, 0x06, 0x02, 0x02, 0x09, 0x12, 0x09, 0x01, 0x06, 0x0F,
	0x0A, 0x05, 0x0E, 0x01, 0x01, 0x02, 0x03, 0x12, 0x20, 0x11, 0x0F, 0x1D, 0x0E, 0x06, 0x04, 0x01,
	0x1B, 0x37, 0x1C, 0x1F, 0x3E, 0x20, 0x43, 0x86, 0x44, 0x1F, 0x3F, 0x20, 0x13, 0x26, 0x13, 0x10,
	0x1F, 0x10, 0x22, 0x41, 0x1C, 0x07, 0x12, 0x04, 0x19, 0x34, 0x19, 0x01, 0xEF, 0x03, 0x06, 0x07,
	0x07, 0x10, 0x0B, 0x02, 0x03, 0x01, 0x01, 0x01, 0x02, 0x03, 0x01, 0x01, 0x04, 0x07, 0x01, 0x03,
	0x04, 0x01, 0x01, 0x01, 0x03, 0x01, 0x03, 0x01, 0x01, 0x02, 0x01, 0x03, 0x01, 0x01, 0x03, 0x04,
	0x01, 0x01, 0x06, 0x02, 0x02, 0x01, 0x01, 0x03, 0x05, 0x03, 0x0B, 0x08, 0x04, 0x01, 0x02, 0x04,
	0x02, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x01,
	0x03, 0x07, 0x03, 0x02, 0x04, 0x03, 0x05, 0x01, 0x01, 0x03, 0x05, 0x03, 0x02, 0x07, 0x02, 0x02,
	0x01, 0x04, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x0A, 0x01, 0x02, 0x08, 0x02,
	0x01, 0x03, 0x02, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x08, 0x03, 0x02, 0x08, 0x02,
	0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x03, 0x04, 0x02, 0x02, 0x05, 0x02, 0x01, 0x03, 0x04, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x11,
	0x23, 0x11, 0x01, 0x02, 0x01, 0x0A, 0x13, 0x09, 0x06, 0x09, 0x05, 0x04, 0x07, 0x04, 0x02, 0x04,
	0x03, 0x08, 0x03, 0x03, 0x03, 0x01, 0x03, 0x03, 0x04, 0x03, 0x02, 0x07, 0x01, 0x03, 0x01, 0x05,
	0x01, 0x0A, 0x02, 0x02, 0x02, 0x03, 0x0C, 0x02, 0x01, 0x03, 0x06, 0x02, 0x06, 0x0A, 0x0C, 0x18,
	0x0C, 0x04, 0x09, 0x06, 0x01, 0x07, 0x0E, 0x07, 0x04, 0x05, 0x08, 0x16, 0x2F, 0x14, 0x07, 0x04,
	0x03, 0x04, 0x0A, 0x04, 0x0A, 0x13, 0x0A, 0x0A, 0x0B, 0x0B, 0x02, 0x01, 0x01, 0x04, 0x06, 0x06,
	0x02, 0x0B, 0x01, 0x03, 0x03, 0x03, 0x05, 0x10, 0x0A, 0x05, 0x05, 0x02, 0x01, 0x07, 0x03, 0x02,
	0x0B, 0x06, 0x0A, 0x14, 0x0A, 0x07, 0x0C, 0x06, 0x0E, 0x1F, 0x0F, 0x01, 0x03, 0x03, 0x08, 0x02,
	0x0C, 0x16, 0x09, 0x06, 0x0B, 0x09, 0x0E, 0x1C, 0x0D, 0x04, 0x11, 0x04, 0x01, 0x02, 0x0B, 0x04,
	0x03, 0x02, 0x04, 0x01, 0x0F, 0x0D, 0x05, 0x02, 0x01, 0x01, 0x01, 0x05, 0x01, 0x0B, 0x03, 0x0A,
	0x20, 0x17, 0x09, 0x0E, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x50, 0x01, 0x0D, 0x08, 0x54,
	0x02, 0x71, 0x00, 0xF3, 0x00, 0xFF, 0x01, 0x0C, 0x01, 0x19, 0x01, 0x25, 0x01, 0x32, 0x01, 0x3B,
	0x01, 0x44, 0x01, 0x52, 0x01, 0x68, 0x00, 0x00, 0x01, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E,
	0x01, 0x27, 0x26, 0x22, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01,
	0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x06, 0x26, 0x27,
	0x2E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x22,
	0x0E, 0x02, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06,
	0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x33,
	0x32, 0x16, 0x15, 0x1E, 0x01, 0x17, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x07, 0x0E,
	0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x16, 0x17, 0x1E, 0x01, 0x37, 0x32, 0x36,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37,
	0x3E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x32, 0x33, 0x32, 0x36, 0x17, 0x1E,
	0x01, 0x17, 0x1E, 0x01, 0x15, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01,
	0x27, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x07,
	0x3E, 0x01, 0x33, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x35, 0x3E, 0x01, 0x17, 0x32,
	0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x0E, 0x01, 0x07, 0x31, 0x05, 0x06, 0x26, 0x37, 0x36,
	0x16, 0x17, 0x16, 0x06, 0x07, 0x06, 0x3F, 0x01, 0x06, 0x26, 0x37, 0x36, 0x16, 0x17, 0x16, 0x06,
	0x07, 0x06, 0x3F, 0x01, 0x25, 0x06, 0x26, 0x37, 0x36, 0x16, 0x17, 0x16, 0x06, 0x07, 0x06, 0x3F,
	0x01, 0x17, 0x06, 0x26, 0x37, 0x36, 0x16, 0x17, 0x16, 0x06, 0x07, 0x06, 0x37, 0x05, 0x06, 0x26,
	0x37, 0x36, 0x16, 0x17, 0x16, 0x06, 0x07, 0x06, 0x3F, 0x02, 0x06, 0x26, 0x37, 0x36, 0x16, 0x07,
	0x06, 0x36, 0x25, 0x06, 0x26, 0x37, 0x36, 0x16, 0x07, 0x06, 0x36, 0x17, 0x0E, 0x01, 0x27, 0x2E,
	0x01, 0x37, 0x36, 0x16, 0x07, 0x30, 0x37, 0x36, 0x07, 0x25, 0x2E, 0x01, 0x27, 0x1E, 0x01, 0x17,
	0x1E, 0x01, 0x17, 0x3A, 0x01, 0x17, 0x32, 0x16, 0x17, 0x2E, 0x03, 0x27, 0x31, 0x08, 0x19, 0x34,
	0x65, 0x33, 0x1B, 0x33, 0x18, 0x06, 0x0B, 0x05, 0x05, 0x05, 0x06, 0x16, 0x2F, 0x17, 0x22, 0x43,
	0x22, 0x16, 0x27, 0x14, 0x1A, 0x34, 0x18, 0x0C, 0x1A, 0x0C, 0x06, 0x0B, 0x05, 0x07, 0x0F, 0x0B,
	0x07, 0x10, 0x08, 0x0B, 0x08, 0x05, 0x08, 0x1D, 0x0F, 0x19, 0x31, 0x1A, 0x14, 0x27, 0x13, 0x12,
	0x20, 0x13, 0x19, 0x30, 0x19, 0x33, 0x67, 0x67, 0x63, 0x33, 0x25, 0x4A, 0x23, 0x0D, 0x19, 0x0D,
	0x0E, 0x1F, 0x0B, 0x04, 0x08, 0x04, 0x06, 0x0B, 0x04, 0x08, 0x10, 0x08, 0x09, 0x11, 0x0B, 0x0B,
	0x14, 0x0B, 0x19, 0x33, 0x1A, 0x22, 0x47, 0x25, 0x1B, 0x37, 0x1B, 0x1D, 0x39, 0x1C, 0x2F, 0x5F,
	0x2F, 0x19, 0x33, 0x19, 0x0B, 0x16, 0x0A, 0x02, 0x02, 0x03, 0x05, 0x04, 0x18, 0x29, 0x17, 0x1C,
	0x38, 0x1C, 0x30, 0x61, 0x2F, 0x4B, 0x95, 0x47, 0x25, 0x4B, 0x21, 0x0C, 0x18, 0x09, 0x04, 0x1E,
	0x04, 0x0B, 0x17, 0x11, 0x03, 0x04, 0x01, 0x05, 0x0C, 0x06, 0x1E, 0x43, 0x20, 0x30, 0x64, 0x32,
	0x17, 0x31, 0x17, 0x16, 0x2A, 0x15, 0x21, 0x40, 0x21, 0x17, 0x31, 0x17, 0x16, 0x2B, 0x16, 0x05,
	0x0B, 0x05, 0x05, 0x0D, 0x04, 0x04, 0x05, 0x02, 0x05, 0x05, 0x02, 0x05, 0x05, 0x01, 0x08, 0x04,
	0x03, 0x10, 0x02, 0x10, 0x0A, 0x09, 0x0E, 0x23, 0x0B, 0x03, 0x04, 0x02, 0x01, 0x01, 0x01, 0x05,
	0x09, 0x06, 0x07, 0x09, 0x03, 0x04, 0x09, 0x05, 0x05, 0x08, 0x05, 0x03, 0x04, 0x03, 0x03, 0x2D,
	0x01, 0x01, 0x04, 0x05, 0x0B, 0x04, 0x11, 0x23, 0x12, 0x33, 0x67, 0x34, 0x17, 0x2E, 0x18, 0x18,
	0x30, 0x18, 0x1A, 0x34, 0x18, 0x23, 0x40, 0x19, 0x0E, 0x1C, 0x0D, 0x0F, 0x1D, 0x0F, 0xF8, 0x94,
	0x0E, 0x18, 0x13, 0x07, 0x10, 0x01, 0x01, 0x04, 0x02, 0x02, 0x01, 0x49, 0x0E, 0x19, 0x11, 0x08,
	0x10, 0x03, 0x01, 0x04, 0x02, 0x03, 0x02, 0x01, 0x02, 0x03, 0x0E, 0x1A, 0x10, 0x08, 0x11, 0x03,
	0x02, 0x04, 0x02, 0x03, 0x01, 0x02, 0x47, 0x0D, 0x1A, 0x10, 0x07, 0x10, 0x04, 0x03, 0x05, 0x02,
	0x02, 0x01, 0xFD, 0xF7, 0x0D, 0x1A, 0x10, 0x07, 0x0F, 0x04, 0x04, 0x04, 0x03, 0x02, 0x01, 0x01,
	0x3A, 0x0C, 0x1C, 0x0E, 0x0C, 0x1C, 0x0E, 0x03, 0x06, 0x02, 0x0D, 0x0E, 0x19, 0x11, 0x0D, 0x14,
	0x0B, 0x03, 0x06, 0x3D, 0x04, 0x08, 0x04, 0x08, 0x09, 0x03, 0x09, 0x24, 0x0F, 0x02, 0x01, 0x03,
	0x01, 0xD2, 0x03, 0x08, 0x03, 0x32, 0x63, 0x32, 0x21, 0x42, 0x20, 0x0A, 0x13, 0x0A, 0x07, 0x06,
	0x06, 0x2E, 0x5E, 0x5D, 0x5D, 0x30, 0x02, 0x16, 0x04, 0x08, 0x0E, 0x07, 0x18, 0x0E, 0x04, 0x06,
	0x04, 0x03, 0x02, 0x04, 0x09, 0x02, 0x02, 0x05, 0x02, 0x01, 0x04, 0x02, 0x03, 0x05, 0x04, 0x03,
	0x04, 0x03, 0x01, 0x04, 0x05, 0x08, 0x0B, 0x02, 0x02, 0x04, 0x01, 0x09, 0x07, 0x0B, 0x11, 0x04,
	0x08, 0x11, 0x02, 0x01, 0x01, 0x06, 0x05, 0x0F, 0x02, 0x02, 0x05, 0x05, 0x0B, 0x14, 0x10, 0x0C,
	0x18, 0x10, 0x06, 0x0E, 0x07, 0x09, 0x12, 0x0D, 0x05, 0x0A, 0x05, 0x06, 0x0C, 0x05, 0x09, 0x11,
	0x08, 0x08, 0x0D, 0x08, 0x08, 0x0D, 0x07, 0x0E, 0x17, 0x0C, 0x0F, 0x1B, 0x07, 0x06, 0x0E, 0x04,
	0x04, 0x08, 0x04, 0x06, 0x02, 0x03, 0x01, 0x03, 0x01, 0x01, 0x03, 0x10, 0x02, 0x06, 0x0C, 0x04,
	0x02, 0x17, 0x03, 0x03, 0x05, 0x02, 0x04, 0x03, 0x06, 0x09, 0x1F, 0x1E, 0x10, 0x21, 0x16, 0x08,
	0x0F, 0x0A, 0x05, 0x23, 0x05, 0x0C, 0x13, 0x03, 0x0D, 0x02, 0x06, 0x07, 0x05, 0x13, 0x19, 0x0D,
	0x13, 0x1C, 0x0D, 0x06, 0x02, 0x02, 0x01, 0x04, 0x01, 0x02, 0x03, 0x01, 0x01, 0x08, 0x03, 0x03,
	0x04, 0x03, 0x01, 0x01, 0x01, 0x02, 0x0C, 0x03, 0x09, 0x11, 0x09, 0x0E, 0x15, 0x0D, 0x03, 0x09,
	0x03, 0x03, 0x0B, 0x02, 0x10, 0x30, 0x15, 0x0C, 0x12, 0x08, 0x03, 0x07, 0x03, 0x02, 0x0A, 0x01,
	0x03, 0x07, 0x01, 0x01, 0x09, 0x06, 0x04, 0x05, 0x02, 0x03, 0x01, 0x08, 0x01, 0x01, 0x04, 0x02,
	0x03, 0x07, 0x02, 0x01, 0x01, 0x02, 0x04, 0x02, 0x06, 0x0D, 0x06, 0x03, 0x07, 0x02, 0x02, 0x07,
	0x01, 0x01, 0x02, 0x09, 0x0D, 0x20, 0x1C, 0x11, 0x20, 0x11, 0x02, 0x05, 0x02, 0x6D, 0x0F, 0x24,
	0x07, 0x04, 0x08, 0x08, 0x04, 0x08, 0x04, 0x03, 0x01, 0x1B, 0x0E, 0x20, 0x0B, 0x04, 0x07, 0x08,
	0x05, 0x09, 0x04, 0x02, 0x01, 0x01, 0x7C, 0x0E, 0x1F, 0x0B, 0x05, 0x05, 0x08, 0x05, 0x0A, 0x05,
	0x03, 0x01, 0x02, 0x05, 0x0D, 0x1E, 0x0B, 0x05, 0x05, 0x08, 0x05, 0x0A, 0x05, 0x02, 0x01, 0xCC,
	0x0D, 0x1E, 0x0B, 0x04, 0x04, 0x06, 0x06, 0x0A, 0x06, 0x03, 0x01, 0x02, 0x19, 0x0D, 0x1A, 0x0C,
	0x0C, 0x19, 0x0C, 0x03, 0x05, 0x51, 0x0E, 0x20, 0x09, 0x06, 0x16, 0x0B, 0x03, 0x05, 0x09, 0x02,
	0x04, 0x01, 0x01, 0x0F, 0x08, 0x13, 0x19, 0x0D, 0x01, 0x01, 0x02, 0x3F, 0x02, 0x04, 0x02, 0x02,
	0x02, 0x01, 0x01, 0x02, 0x01, 0x01, 0x03, 0x05, 0x01, 0x03, 0x02, 0x03, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x08, 0x00, 0x54, 0x00, 0x86, 0x08, 0x54, 0x02, 0xF5, 0x00, 0x77, 0x00, 0x91, 0x00, 0xAD,
	0x00, 0xCF, 0x01, 0x36, 0x01, 0x50, 0x01, 0x6C, 0x01, 0x8D, 0x00, 0x00, 0x01, 0x2E, 0x03, 0x27,
	0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2A, 0x01, 0x23, 0x2E, 0x01, 0x23, 0x26, 0x22, 0x27, 0x2E,
	0x01, 0x27, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x26, 0x34, 0x35, 0x26, 0x36, 0x37, 0x3E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x07,
	0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x14, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E,
	0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36,
	0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x2E, 0x01, 0x27, 0x26,
	0x1F, 0x01, 0x25, 0x36, 0x37, 0x36, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x07, 0x0E, 0x01, 0x27,
	0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x37, 0x36, 0x06, 0x37, 0x13, 0x0E, 0x01, 0x27,
	0x2E, 0x01, 0x27, 0x2E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E,
	0x01, 0x17, 0x16, 0x06, 0x07, 0x06, 0x3F, 0x02, 0x0E, 0x01, 0x07, 0x06, 0x22, 0x27, 0x2E, 0x01,
	0x27, 0x26, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17,
	0x16, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x37, 0x36, 0x07, 0x25, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27,
	0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06,
	0x26, 0x27, 0x26, 0x34, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x17, 0x1E, 0x01, 0x17,
	0x1E, 0x01, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x27, 0x2E, 0x01, 0x37, 0x3E,
	0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x14, 0x16, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x03, 0x37, 0x2E, 0x01, 0x27, 0x31, 0x25, 0x36,
	0x37, 0x36, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E,
	0x01, 0x27, 0x26, 0x36, 0x37, 0x36, 0x06, 0x37, 0x13, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06,
	0x07, 0x06, 0x3F, 0x02, 0x0E, 0x02, 0x22, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x07, 0x0E, 0x01, 0x07,
	0x37, 0x36, 0x07, 0x03, 0xE8, 0x24, 0x51, 0x54, 0x56, 0x2B, 0x1F, 0x3E, 0x20, 0x0A, 0x15, 0x0A,
	0x03, 0x06, 0x03, 0x04, 0x02, 0x04, 0x06, 0x0E, 0x03, 0x04, 0x09, 0x05, 0x05, 0x07, 0x02, 0x01,
	0x04, 0x02, 0x04, 0x0A, 0x0F, 0x13, 0x32, 0x1C, 0x10, 0x1C, 0x05, 0x03, 0x02, 0x14, 0x09, 0x04,
	0x01, 0x05, 0x08, 0x16, 0x0D, 0x07, 0x1A, 0x0B, 0x08, 0x0C, 0x06, 0x12, 0x22, 0x09, 0x0B, 0x02,
	0x01, 0x05, 0x0B, 0x07, 0x11, 0x08, 0x0A, 0x17, 0x11, 0x12, 0x29, 0x0B, 0x07, 0x0B, 0x01, 0x01,
	0x09, 0x03, 0x04, 0x08, 0x02, 0x03, 0x01, 0x07, 0x07, 0x25, 0x11, 0x13, 0x1E, 0x0E, 0x09, 0x1C,
	0x01, 0x02, 0x01, 0x07, 0x0A, 0x10, 0x04, 0x0C, 0x24, 0x0E, 0x1F, 0x3D, 0x1F, 0x27, 0x4F, 0x27,
	0x44, 0x80, 0x3C, 0x0D, 0x1A, 0x0F, 0x1D, 0x0F, 0x0E, 0xFC, 0xBA, 0x03, 0x08, 0x09, 0x0B, 0x0B,
	0x0F, 0x08, 0x0A, 0x0F, 0x02, 0x02, 0x08, 0x0A, 0x08, 0x0E, 0x07, 0x07, 0x0E, 0x05, 0x05, 0x12,
	0x04, 0x09, 0x13, 0x0A, 0x39, 0x0B, 0x0F, 0x0A, 0x07, 0x0B, 0x06, 0x02, 0x07, 0x05, 0x08, 0x10,
	0x08, 0x09, 0x16, 0x05, 0x03, 0x03, 0x02, 0x02, 0x01, 0x02, 0x01, 0x0D, 0x05, 0x08, 0x04, 0x04,
	0x02, 0x0C, 0x18, 0x0D, 0x0C, 0x1F, 0x08, 0x08, 0x03, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x07,
	0x06, 0x14, 0x07, 0x0D, 0x1A, 0x0D, 0x10, 0x20, 0x0D, 0x04, 0x03, 0x04, 0x0A, 0x17, 0x0B, 0x0D,
	0x0D, 0x1A, 0x07, 0x62, 0x2F, 0x5F, 0x37, 0x1C, 0x37, 0x1C, 0x21, 0x42, 0x21, 0x21, 0x46, 0x1D,
	0x08, 0x11, 0x08, 0x06, 0x04, 0x03, 0x08, 0x21, 0x1D, 0x17, 0x39, 0x0E, 0x0B, 0x07, 0x03, 0x09,
	0x04, 0x03, 0x0B, 0x04, 0x06, 0x0E, 0x0A, 0x08, 0x21, 0x0F, 0x07, 0x0B, 0x04, 0x0A, 0x13, 0x09,
	0x0F, 0x16, 0x04, 0x02, 0x02, 0x01, 0x01, 0x07, 0x12, 0x08, 0x11, 0x09, 0x09, 0x22, 0x19, 0x11,
	0x22, 0x07, 0x08, 0x10, 0x06, 0x07, 0x03, 0x04, 0x07, 0x4D, 0x1D, 0x0E, 0x1A, 0x09, 0x05, 0x01,
	0x02, 0x0B, 0x09, 0x04, 0x07, 0x02, 0x03, 0x13, 0x09, 0x1C, 0x38, 0x1C, 0x27, 0x4F, 0x27, 0x28,
	0x4E, 0x4C, 0x49, 0x23, 0x06, 0x0A, 0x05, 0xFC, 0x98, 0x04, 0x08, 0x08, 0x0A, 0x0B, 0x10, 0x09,
	0x09, 0x0E, 0x03, 0x02, 0x07, 0x0B, 0x07, 0x0F, 0x07, 0x07, 0x0F, 0x04, 0x04, 0x11, 0x04, 0x09,
	0x13, 0x0A, 0x39, 0x0B, 0x0F, 0x09, 0x07, 0x0C, 0x05, 0x03, 0x08, 0x07, 0x07, 0x10, 0x08, 0x0A,
	0x15, 0x05, 0x03, 0x04, 0x01, 0x02, 0x02, 0x01, 0x01, 0x0C, 0x06, 0x08, 0x04, 0x04, 0x02, 0x0C,
	0x18, 0x19, 0x1F, 0x08, 0x08, 0x02, 0x02, 0x01, 0x01, 0x02, 0x01, 0x04, 0x07, 0x05, 0x14, 0x07,
	0x0D, 0x1A, 0x0D, 0x10, 0x20, 0x0D, 0x04, 0x03, 0x04, 0x0A, 0x16, 0x0C, 0x0D, 0x0D, 0x1A, 0x01,
	0xE1, 0x18, 0x20, 0x15, 0x0C, 0x04, 0x04, 0x05, 0x02, 0x01, 0x01, 0x01, 0x01, 0x03, 0x02, 0x05,
	0x08, 0x0F, 0x07, 0x07, 0x02, 0x09, 0x09, 0x12, 0x09, 0x14, 0x23, 0x10, 0x14, 0x15, 0x08, 0x05,
	0x16, 0x11, 0x0A, 0x14, 0x09, 0x16, 0x29, 0x13, 0x09, 0x0E, 0x09, 0x0F, 0x19, 0x0B, 0x05, 0x13,
	0x09, 0x08, 0x16, 0x0B, 0x1F, 0x42, 0x23, 0x2C, 0x5B, 0x2C, 0x19, 0x36, 0x16, 0x11, 0x1F, 0x10,
	0x14, 0x2D, 0x10, 0x10, 0x2A, 0x0D, 0x08, 0x12, 0x0B, 0x09, 0x0E, 0x07, 0x0A, 0x15, 0x0B, 0x0F,
	0x24, 0x0D, 0x11, 0x13, 0x01, 0x01, 0x0D, 0x0C, 0x09, 0x1D, 0x0E, 0x0D, 0x26, 0x0B, 0x12, 0x30,
	0x03, 0x08, 0x02, 0x02, 0x02, 0x07, 0x04, 0x05, 0x08, 0x09, 0x0F, 0x36, 0x22, 0x0B, 0x11, 0x09,
	0x14, 0x0B, 0x09, 0xBB, 0x08, 0x0F, 0x10, 0x02, 0x02, 0x0E, 0x07, 0x08, 0x3B, 0x0B, 0x0A, 0x07,
	0x04, 0x04, 0x08, 0x03, 0x04, 0x07, 0x07, 0x08, 0x1E, 0x06, 0x13, 0x25, 0x12, 0xFE, 0x2F, 0x0A,
	0x02, 0x0C, 0x09, 0x13, 0x0A, 0x04, 0x10, 0x05, 0x05, 0x0B, 0x05, 0x06, 0x06, 0x0C, 0x08, 0x12,
	0x08, 0x07, 0x0F, 0x07, 0x07, 0x0A, 0x04, 0x07, 0x04, 0x03, 0xB8, 0x0B, 0x15, 0x0B, 0x0B, 0x14,
	0x14, 0x2E, 0x16, 0x0F, 0x20, 0x0F, 0x0B, 0x1A, 0x08, 0x07, 0x04, 0x06, 0x0B, 0x17, 0x0B, 0x0D,
	0x1D, 0x10, 0x06, 0x07, 0x04, 0x0D, 0x16, 0x0B, 0x0D, 0x0C, 0x19, 0x4A, 0x1C, 0x2F, 0x0C, 0x06,
	0x0C, 0x03, 0x03, 0x08, 0x02, 0x02, 0x01, 0x0C, 0x03, 0x2F, 0x13, 0x0C, 0x20, 0x0D, 0x1E, 0x2A,
	0x0C, 0x0A, 0x0F, 0x16, 0x12, 0x34, 0x13, 0x09, 0x12, 0x09, 0x07, 0x15, 0x07, 0x0B, 0x16, 0x09,
	0x09, 0x1D, 0x03, 0x01, 0x14, 0x05, 0x11, 0x24, 0x12, 0x1E, 0x3C, 0x21, 0x17, 0x2D, 0x17, 0x28,
	0x53, 0x24, 0x11, 0x21, 0x11, 0x10, 0x3E, 0x0C, 0x09, 0x25, 0x12, 0x12, 0x1C, 0x11, 0x12, 0x23,
	0x13, 0x26, 0x15, 0x14, 0x09, 0x1C, 0x0F, 0x09, 0x14, 0x09, 0x06, 0x2E, 0x10, 0x07, 0x0C, 0x08,
	0x09, 0x04, 0x01, 0x04, 0x04, 0x04, 0x05, 0x0A, 0x05, 0x05, 0x15, 0x1E, 0x24, 0x13, 0x04, 0x09,
	0x04, 0xCF, 0x08, 0x0F, 0x10, 0x02, 0x02, 0x0E, 0x07, 0x08, 0x3B, 0x0B, 0x0A, 0x07, 0x04, 0x04,
	0x08, 0x03, 0x04, 0x07, 0x07, 0x08, 0x1E, 0x06, 0x13, 0x25, 0x12, 0xFE, 0x2F, 0x0A, 0x02, 0x0C,
	0x09, 0x13, 0x0A, 0x04, 0x10, 0x05, 0x05, 0x0B, 0x05, 0x06, 0x06, 0x0C, 0x08, 0x12, 0x08, 0x07,
	0x0F, 0x07, 0x07, 0x0A, 0x04, 0x07, 0x04, 0x03, 0xB8, 0x0B, 0x15, 0x16, 0x14, 0x14, 0x2E, 0x16,
	0x0F, 0x20, 0x0F, 0x0B, 0x1A, 0x08, 0x07, 0x04, 0x06, 0x0B, 0x17, 0x0B, 0x0D, 0x1D, 0x10, 0x06,
	0x07, 0x04, 0x0D, 0x16, 0x0B, 0x0D, 0x0C, 0x19, 0x00, 0x02, 0x00, 0x5D, 0x00, 0x26, 0x06, 0x16,
	0x03, 0x5B, 0x00, 0xC2, 0x00, 0xDE, 0x00, 0x00, 0x01, 0x2E, 0x01, 0x35, 0x3E, 0x01, 0x23, 0x2E,
	0x01, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x22, 0x26, 0x07, 0x0E, 0x01,
	0x07, 0x22, 0x06, 0x27, 0x26, 0x36, 0x23, 0x2A, 0x01, 0x23, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x27,
	0x22, 0x06, 0x23, 0x22, 0x26, 0x23, 0x2E, 0x01, 0x23, 0x2E, 0x01, 0x23, 0x22, 0x26, 0x23, 0x22,
	0x06, 0x23, 0x22, 0x06, 0x07, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x23, 0x22, 0x26, 0x07, 0x06, 0x16,
	0x07, 0x0E, 0x01, 0x07, 0x06, 0x22, 0x23, 0x2A, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x0E, 0x01, 0x07,
	0x06, 0x16, 0x15, 0x14, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x07, 0x06, 0x16, 0x33, 0x32, 0x16, 0x33, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06,
	0x15, 0x14, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x17, 0x14, 0x16, 0x17,
	0x1E, 0x01, 0x33, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x33, 0x2E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x33, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01,
	0x35, 0x34, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x03, 0x33,
	0x32, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x27, 0x01, 0x06, 0x22, 0x23, 0x22, 0x06, 0x27,
	0x2E, 0x01, 0x27, 0x2E, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x36, 0x33, 0x3A, 0x01, 0x33, 0x32,
	0x16, 0x15, 0x14, 0x16, 0x07, 0x06, 0x14, 0x01, 0x03, 0x01, 0x01, 0x0D, 0x04, 0x15, 0x02, 0x02,
	0x08, 0x0B, 0x0B, 0x13, 0x0A, 0x08, 0x0B, 0x0A, 0x08, 0x1F, 0x07, 0x03, 0x02, 0x02, 0x01, 0x0F,
	0x01, 0x04, 0x05, 0x08, 0x07, 0x0D, 0x07, 0x37, 0x6E, 0x37, 0x11, 0x23, 0x11, 0x05, 0x03, 0x03,
	0x07, 0x0C, 0x06, 0x2F, 0x5D, 0x2F, 0x16, 0x2C, 0x16, 0x0C, 0x0A, 0x0A, 0x32, 0x63, 0x32, 0x0F,
	0x17, 0x10, 0x08, 0x17, 0x06, 0x04, 0x14, 0x05, 0x06, 0x22, 0x05, 0x05, 0x08, 0x05, 0x0F, 0x20,
	0x09, 0x06, 0x0E, 0x0D, 0x04, 0x09, 0x03, 0x02, 0x08, 0x02, 0x04, 0x10, 0x03, 0x01, 0x01, 0x0C,
	0x04, 0x05, 0x0A, 0x02, 0x03, 0x05, 0x02, 0x04, 0x17, 0x10, 0x11, 0x24, 0x0B, 0x0B, 0x08, 0x0F,
	0x0A, 0x13, 0x09, 0x12, 0x25, 0x11, 0x1A, 0x1B, 0x06, 0x03, 0x03, 0x07, 0x03, 0x06, 0x0A, 0x06,
	0x10, 0x1B, 0x0C, 0x0A, 0x0A, 0x01, 0x09, 0x0F, 0x07, 0x0E, 0x07, 0x2E, 0x58, 0x2E, 0x24, 0x4A,
	0x25, 0x04, 0x12, 0x03, 0x03, 0x06, 0x03, 0x05, 0x0D, 0x05, 0x04, 0x0B, 0x18, 0x0D, 0x2B, 0x0F,
	0x16, 0x27, 0x14, 0x0B, 0x15, 0x0A, 0x0D, 0x0B, 0x05, 0x08, 0x06, 0x14, 0x0E, 0x0C, 0x1B, 0x11,
	0x21, 0x43, 0x21, 0x33, 0x67, 0x67, 0x67, 0x34, 0x0A, 0x0E, 0x04, 0x07, 0x0D, 0x05, 0x04, 0x10,
	0x02, 0xFD, 0x03, 0x08, 0x22, 0x11, 0x0D, 0x25, 0x0D, 0x0B, 0x09, 0x04, 0x02, 0x01, 0x28, 0x11,
	0x11, 0x21, 0x11, 0x1C, 0x02, 0x02, 0x07, 0x02, 0xEE, 0x0A, 0x14, 0x0B, 0x0B, 0x0D, 0x02, 0x04,
	0x04, 0x0A, 0x0E, 0x03, 0x03, 0x0C, 0x06, 0x05, 0x01, 0x04, 0x04, 0x02, 0x0A, 0x02, 0x01, 0x01,
	0x04, 0x0C, 0x01, 0x01, 0x01, 0x0D, 0x05, 0x01, 0x02, 0x01, 0x01, 0x0F, 0x01, 0x0A, 0x01, 0x03,
	0x06, 0x04, 0x18, 0x04, 0x04, 0x04, 0x1B, 0x04, 0x08, 0x16, 0x10, 0x0C, 0x02, 0x01, 0x06, 0x01,
	0x02, 0x03, 0x02, 0x0F, 0x03, 0x08, 0x13, 0x07, 0x08, 0x0D, 0x0A, 0x09, 0x13, 0x0A, 0x11, 0x07,
	0x05, 0x05, 0x10, 0x0F, 0x0F, 0x0A, 0x01, 0x01, 0x03, 0x04, 0x1C, 0x19, 0x0E, 0x18, 0x0E, 0x06,
	0x0F, 0x06, 0x0C, 0x19, 0x0D, 0x25, 0x4C, 0x26, 0x1D, 0x3C, 0x1E, 0x0B, 0x23, 0x02, 0x01, 0x01,
	0x02, 0x01, 0x03, 0x02, 0x0D, 0x0A, 0x24, 0x0B, 0x0F, 0x1D, 0x0F, 0x1F, 0x3D, 0x1F, 0x1B, 0x2E,
	0x11, 0x0A, 0x11, 0x02, 0x01, 0x03, 0x02, 0x02, 0x02, 0x03, 0x02, 0x0D, 0x16, 0x2C, 0x14, 0x0F,
	0x28, 0x09, 0x09, 0x16, 0x02, 0x0B, 0x13, 0x27, 0x13, 0x10, 0x27, 0x10, 0xFE, 0xCD, 0x12, 0x04,
	0x04, 0x04, 0x05, 0x0B, 0x06, 0x09, 0x07, 0x13, 0x25, 0x12, 0x1A, 0x03, 0x31, 0x13, 0x0F, 0x1F,
	0x0D, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x4F, 0x00, 0x25, 0x09, 0x93, 0x03, 0x5A, 0x00, 0x91,
	0x01, 0x0B, 0x01, 0x2B, 0x01, 0x4A, 0x00, 0x00, 0x01, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x17, 0x1E,
	0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x07, 0x0E, 0x01, 0x17, 0x23, 0x0E,
	0x01, 0x07, 0x06, 0x26, 0x23, 0x06, 0x26, 0x23, 0x22, 0x26, 0x23, 0x22, 0x26, 0x07, 0x0E, 0x01,
	0x07, 0x06, 0x16, 0x17, 0x07, 0x15, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x0F, 0x01,
	0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x15, 0x14, 0x16, 0x17, 0x14, 0x06, 0x07, 0x06,
	0x26, 0x23, 0x22, 0x06, 0x2F, 0x01, 0x2E, 0x01, 0x35, 0x2E, 0x01, 0x27, 0x34, 0x26, 0x27, 0x36,
	0x26, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x26, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x2E, 0x01, 0x35, 0x3E, 0x01, 0x37,
	0x36, 0x16, 0x17, 0x3E, 0x01, 0x37, 0x35, 0x36, 0x16, 0x17, 0x32, 0x16, 0x15, 0x17, 0x32, 0x36,
	0x33, 0x16, 0x32, 0x17, 0x32, 0x36, 0x1F, 0x01, 0x21, 0x35, 0x17, 0x2E, 0x01, 0x35, 0x3E, 0x01,
	0x37, 0x36, 0x16, 0x17, 0x3E, 0x01, 0x33, 0x35, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x32, 0x36,
	0x1F, 0x01, 0x21, 0x35, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x07, 0x0E, 0x01,
	0x17, 0x23, 0x07, 0x06, 0x26, 0x23, 0x22, 0x26, 0x27, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x14,
	0x06, 0x14, 0x16, 0x0F, 0x01, 0x15, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x07, 0x14, 0x16, 0x07, 0x06, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x27, 0x2E, 0x01, 0x27, 0x2E,
	0x01, 0x35, 0x3E, 0x01, 0x35, 0x2E, 0x01, 0x27, 0x35, 0x27, 0x34, 0x26, 0x37, 0x34, 0x36, 0x37,
	0x33, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x37, 0x3E, 0x01,
	0x33, 0x3E, 0x01, 0x27, 0x05, 0x2A, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x16,
	0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x33, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x27,
	0x2E, 0x01, 0x27, 0x23, 0x05, 0x22, 0x26, 0x07, 0x23, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x17, 0x33,
	0x17, 0x1E, 0x01, 0x17, 0x3A, 0x01, 0x17, 0x3E, 0x01, 0x3F, 0x01, 0x27, 0x26, 0x27, 0x26, 0x27,
	0x2A, 0x01, 0x23, 0x04, 0x88, 0x03, 0x09, 0x05, 0x05, 0x0E, 0x09, 0x07, 0x0D, 0x06, 0x04, 0x0B,
	0x01, 0x02, 0x07, 0x02, 0x03, 0x07, 0x01, 0x02, 0x06, 0x01, 0x51, 0x02, 0x03, 0x02, 0x0B, 0x1C,
	0x0B, 0x0F, 0x1D, 0x0F, 0x1A, 0x35, 0x1A, 0x0E, 0x1D, 0x0E, 0x17, 0x21, 0x0F, 0x16, 0x02, 0x02,
	0x0A, 0x1C, 0x3E, 0x1E, 0x13, 0x21, 0x13, 0x16, 0x34, 0x15, 0x17, 0x0A, 0x08, 0x05, 0x08, 0x11,
	0x09, 0x04, 0x06, 0x05, 0x03, 0x07, 0x07, 0x17, 0x41, 0x1A, 0x1F, 0x3E, 0x1C, 0x0C, 0x01, 0x01,
	0x14, 0x20, 0x12, 0x02, 0x02, 0x01, 0x05, 0x02, 0x02, 0x09, 0x01, 0x10, 0x1D, 0x0E, 0x08, 0x10,
	0x09, 0x0D, 0x0F, 0x10, 0x0A, 0x3A, 0x14, 0x0A, 0x03, 0x03, 0x06, 0x15, 0x08, 0x16, 0x17, 0x08,
	0x02, 0x05, 0x02, 0x05, 0x03, 0x0F, 0x19, 0x0E, 0x0E, 0x1D, 0x10, 0x0C, 0x17, 0x0C, 0x04, 0x02,
	0x05, 0x1F, 0x3D, 0x1F, 0x12, 0x25, 0x13, 0x0D, 0x22, 0x0D, 0x08, 0x02, 0x11, 0xD6, 0x01, 0x03,
	0x02, 0x06, 0x04, 0x0F, 0x17, 0x0E, 0x0F, 0x1E, 0x10, 0x0C, 0x18, 0x0C, 0x07, 0x03, 0x01, 0x3F,
	0x80, 0x40, 0x09, 0x02, 0x0E, 0x03, 0x04, 0x09, 0x02, 0x16, 0x2E, 0x06, 0x03, 0x0B, 0x0C, 0x02,
	0x04, 0x01, 0x55, 0x04, 0x16, 0x37, 0x17, 0x1B, 0x36, 0x1C, 0x21, 0x38, 0x1A, 0x0C, 0x18, 0x02,
	0x02, 0x08, 0x04, 0x0B, 0x1F, 0x45, 0x22, 0x27, 0x65, 0x22, 0x11, 0x0C, 0x07, 0x08, 0x0D, 0x0B,
	0x11, 0x16, 0x16, 0x30, 0x17, 0x1E, 0x3C, 0x1D, 0x02, 0x05, 0x0B, 0x05, 0x09, 0x08, 0x02, 0x02,
	0x13, 0x23, 0x12, 0x02, 0x05, 0x01, 0x09, 0x05, 0x02, 0x08, 0x21, 0x0D, 0x0F, 0x26, 0x06, 0x0D,
	0x0A, 0x3A, 0x14, 0x09, 0x01, 0x07, 0x06, 0x15, 0x07, 0x19, 0x1F, 0x07, 0xFD, 0x33, 0x11, 0x23,
	0x11, 0x13, 0x1C, 0x11, 0x07, 0x09, 0x02, 0x06, 0x05, 0x02, 0x06, 0x0C, 0x06, 0x0F, 0x1C, 0x12,
	0x0E, 0x1D, 0x0F, 0x2F, 0x33, 0x04, 0x02, 0x01, 0x08, 0x05, 0x11, 0x0D, 0x35, 0x04, 0x74, 0x0D,
	0x21, 0x0B, 0x04, 0x0D, 0x19, 0x05, 0x02, 0x03, 0x07, 0x03, 0x14, 0x0F, 0x1D, 0x11, 0x0F, 0x1E,
	0x0F, 0x2F, 0x31, 0x03, 0x04, 0x09, 0x05, 0x09, 0x09, 0x0D, 0x19, 0x32, 0x19, 0x03, 0x2E, 0x06,
	0x0A, 0x04, 0x06, 0x04, 0x01, 0x02, 0x03, 0x02, 0x06, 0x04, 0x08, 0x0D, 0x19, 0x0D, 0x08, 0x1F,
	0x0A, 0x1A, 0x36, 0x1A, 0x03, 0x06, 0x02, 0x05, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x05, 0x19,
	0x0F, 0x14, 0x35, 0x19, 0x0A, 0x02, 0x0B, 0x15, 0x02, 0x01, 0x02, 0x02, 0x03, 0x0A, 0x05, 0x0D,
	0x0D, 0x19, 0x10, 0x1C, 0x39, 0x1C, 0x0F, 0x1A, 0x10, 0x14, 0x27, 0x14, 0x11, 0x19, 0x08, 0x0E,
	0x05, 0x03, 0x0C, 0x0F, 0x0B, 0x15, 0x0A, 0x02, 0x05, 0x0A, 0x02, 0x06, 0x02, 0x10, 0x1F, 0x0F,
	0x12, 0x24, 0x12, 0x20, 0x41, 0x21, 0x13, 0x27, 0x13, 0x19, 0x2C, 0x1C, 0x14, 0x07, 0x04, 0x0A,
	0x13, 0x0C, 0x06, 0x06, 0x01, 0x14, 0x29, 0x1C, 0x0D, 0x1C, 0x0D, 0x06, 0x08, 0x01, 0x01, 0x05,
	0x03, 0x06, 0x0C, 0x01, 0x1B, 0x01, 0x03, 0x02, 0x03, 0x02, 0x18, 0x04, 0x01, 0x01, 0x01, 0x03,
	0x0D, 0x03, 0x2E, 0x08, 0x0F, 0x08, 0x07, 0x07, 0x01, 0x02, 0x05, 0x02, 0x03, 0x10, 0x19, 0x01,
	0x03, 0x02, 0x06, 0x0F, 0x09, 0x02, 0x02, 0x0A, 0x01, 0x05, 0x03, 0x07, 0x05, 0x13, 0x1B, 0x16,
	0x0E, 0x31, 0x0B, 0x1E, 0x3C, 0x1E, 0x09, 0x08, 0x04, 0x01, 0x01, 0x01, 0x0A, 0x17, 0x0A, 0x18,
	0x11, 0x06, 0x0D, 0x0D, 0x19, 0x04, 0x0B, 0x04, 0x0C, 0x12, 0x03, 0x02, 0x1A, 0x19, 0x14, 0x35,
	0x19, 0x1A, 0x38, 0x19, 0x23, 0x52, 0x20, 0x0B, 0x03, 0x02, 0x01, 0x03, 0x02, 0x05, 0x14, 0x10,
	0x04, 0x09, 0x04, 0x03, 0x04, 0x09, 0x06, 0x05, 0x0E, 0x19, 0x0E, 0x14, 0x25, 0x13, 0x21, 0x41,
	0x1E, 0x22, 0x4A, 0x24, 0x25, 0x14, 0x09, 0x02, 0x07, 0x1B, 0x08, 0x05, 0x09, 0x17, 0x33, 0x24,
	0xBA, 0x01, 0x01, 0x05, 0x08, 0x05, 0x0B, 0x06, 0x0C, 0x19, 0x0C, 0x06, 0x0B, 0x06, 0x04, 0x0D,
	0x01, 0x01, 0x01, 0x07, 0x17, 0x10, 0x0E, 0x18, 0x0D, 0x09, 0x10, 0x07, 0x07, 0x04, 0x05, 0x07,
	0x0D, 0x0E, 0x0D, 0x1A, 0x0C, 0x14, 0x06, 0x0D, 0x01, 0x02, 0x06, 0x18, 0x12, 0x13, 0x20, 0x09,
	0x08, 0x07, 0x05, 0x00, 0x00, 0x02, 0x00, 0x57, 0x00, 0x24, 0x04, 0xD4, 0x03, 0x5A, 0x00, 0x98,
	0x00, 0xB7, 0x00, 0x00, 0x01, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x23, 0x22, 0x06, 0x23, 0x2A, 0x01,
	0x23, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x03, 0x23,
	0x2A, 0x01, 0x23, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x16, 0x07, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x16, 0x17, 0x16, 0x14, 0x15, 0x14, 0x06, 0x07, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x15, 0x14, 0x16, 0x17, 0x16, 0x36, 0x37,
	0x3E, 0x01, 0x37, 0x32, 0x36, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x35, 0x3E, 0x01, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x34, 0x37, 0x3E, 0x01, 0x17, 0x16, 0x32,
	0x37, 0x36, 0x16, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x34, 0x27, 0x2E, 0x01, 0x37,
	0x3E, 0x01, 0x37, 0x36, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x37, 0x36, 0x16, 0x17, 0x36,
	0x34, 0x37, 0x34, 0x36, 0x35, 0x3E, 0x01, 0x37, 0x34, 0x26, 0x27, 0x01, 0x1C, 0x01, 0x15, 0x14,
	0x26, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x27, 0x26, 0x36, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x32,
	0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x17, 0x16, 0x06, 0x15, 0x04, 0xCE, 0x02, 0x0B, 0x0D, 0x05,
	0x0A, 0x05, 0x04, 0x0C, 0x07, 0x14, 0x2A, 0x15, 0x33, 0x66, 0x33, 0x03, 0x09, 0x02, 0x03, 0x05,
	0x03, 0x0C, 0x17, 0x0C, 0x35, 0x69, 0x6A, 0x69, 0x35, 0x12, 0x25, 0x13, 0x08, 0x0F, 0x07, 0x18,
	0x30, 0x1B, 0x0C, 0x07, 0x06, 0x0A, 0x14, 0x06, 0x0C, 0x09, 0x05, 0x04, 0x0A, 0x01, 0x02, 0x48,
	0x1C, 0x12, 0x08, 0x03, 0x04, 0x08, 0x04, 0x06, 0x0B, 0x05, 0x0B, 0x12, 0x07, 0x05, 0x06, 0x0D,
	0x0D, 0x0E, 0x2E, 0x13, 0x27, 0x4D, 0x27, 0x11, 0x2E, 0x08, 0x01, 0x07, 0x03, 0x02, 0x05, 0x03,
	0x04, 0x02, 0x04, 0x09, 0x05, 0x02, 0x06, 0x02, 0x01, 0x0A, 0x01, 0x02, 0x11, 0x0C, 0x14, 0x10,
	0x0C, 0x16, 0x0B, 0x26, 0x4B, 0x25, 0x16, 0x23, 0x07, 0x03, 0x02, 0x01, 0x01, 0x01, 0x01, 0x04,
	0x09, 0x0E, 0x24, 0x10, 0x0D, 0x1E, 0x0D, 0x32, 0x65, 0x32, 0x0F, 0x09, 0x03, 0x02, 0x3A, 0x08,
	0x03, 0x01, 0x0A, 0x01, 0x01, 0x01, 0x01, 0x05, 0xFE, 0x20, 0x2C, 0x0C, 0x1C, 0x38, 0x1C, 0x0C,
	0x2C, 0x0B, 0x08, 0x02, 0x25, 0x0D, 0x2C, 0x58, 0x2B, 0x04, 0x07, 0x01, 0x05, 0x01, 0x03, 0x30,
	0x09, 0x1E, 0x02, 0x01, 0x01, 0x23, 0x01, 0x02, 0x03, 0x03, 0x01, 0x05, 0x0F, 0x06, 0x02, 0x01,
	0x13, 0x05, 0x07, 0x0F, 0x0C, 0x16, 0x33, 0x17, 0x12, 0x21, 0x11, 0x2A, 0x22, 0x0D, 0x09, 0x16,
	0x10, 0x09, 0x12, 0x08, 0x0C, 0x16, 0x0C, 0x11, 0x25, 0x12, 0x24, 0x49, 0x25, 0x17, 0x31, 0x18,
	0x10, 0x19, 0x0C, 0x0F, 0x05, 0x01, 0x01, 0x05, 0x01, 0x0E, 0x19, 0x04, 0x07, 0x03, 0x02, 0x0C,
	0x02, 0x09, 0x11, 0x09, 0x12, 0x23, 0x12, 0x09, 0x14, 0x0A, 0x08, 0x0F, 0x08, 0x14, 0x38, 0x0D,
	0x09, 0x05, 0x02, 0x01, 0x01, 0x01, 0x09, 0x06, 0x03, 0x16, 0x15, 0x0B, 0x18, 0x0C, 0x08, 0x11,
	0x08, 0x0A, 0x13, 0x05, 0x09, 0x15, 0x03, 0x02, 0x02, 0x1F, 0x0C, 0x06, 0x03, 0x03, 0x06, 0x0C,
	0x06, 0x06, 0x05, 0x06, 0x0B, 0x18, 0x0B, 0x1A, 0x31, 0x19, 0xFE, 0xCC, 0x0A, 0x15, 0x0A, 0x13,
	0x02, 0x05, 0x07, 0x05, 0x1E, 0x07, 0x0C, 0x16, 0x0B, 0x14, 0x03, 0x04, 0x08, 0x1B, 0x09, 0x00,
	0x00, 0x02, 0x00, 0x4B, 0x00, 0x26, 0x05, 0x73, 0x03, 0x5A, 0x00, 0x94, 0x00, 0xA7, 0x00, 0x00,
	0x01, 0x14, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07,
	0x06, 0x16, 0x17, 0x1E, 0x01, 0x15, 0x14, 0x06, 0x23, 0x0E, 0x01, 0x27, 0x22, 0x06, 0x27, 0x2E,
	0x01, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x3E, 0x01, 0x37, 0x22, 0x26, 0x27,
	0x26, 0x36, 0x37, 0x1C, 0x01, 0x15, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36,
	0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x3C, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x26,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x17, 0x32, 0x16, 0x17, 0x16, 0x36, 0x33,
	0x3A, 0x03, 0x33, 0x3A, 0x03, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x37, 0x3E,
	0x01, 0x37, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x06, 0x17, 0x1E, 0x01,
	0x17, 0x05, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x15, 0x14, 0x06, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36,
	0x35, 0x34, 0x36, 0x23, 0x05, 0x73, 0x0A, 0x21, 0x14, 0x28, 0x14, 0x27, 0x4F, 0x27, 0x16, 0x2A,
	0x16, 0x0C, 0x36, 0x02, 0x03, 0x03, 0x03, 0x01, 0x06, 0x12, 0x02, 0x28, 0x51, 0x28, 0x13, 0x29,
	0x13, 0x0B, 0x16, 0x0B, 0x0A, 0x0D, 0x0B, 0x11, 0x19, 0x09, 0x14, 0x1C, 0x0E, 0x08, 0x0F, 0x08,
	0x07, 0x16, 0x02, 0x01, 0x10, 0x0D, 0x06, 0x0D, 0x06, 0x3E, 0x7B, 0x3E, 0x01, 0x03, 0x02, 0x14,
	0x28, 0x0D, 0x0E, 0x0D, 0x06, 0x19, 0x2B, 0x16, 0x0B, 0x18, 0x0C, 0x0B, 0x0F, 0x08, 0x11, 0x04,
	0x28, 0x0B, 0x15, 0x0A, 0x0A, 0x06, 0x01, 0x07, 0x04, 0x04, 0x1C, 0x07, 0x0E, 0x0A, 0x06, 0x06,
	0x0A, 0x0D, 0x0D, 0x07, 0x02, 0x01, 0x0E, 0x02, 0x2B, 0x54, 0x54, 0x54, 0x2A, 0x3A, 0x74, 0x73,
	0x74, 0x3A, 0x26, 0x4C, 0x25, 0x09, 0x11, 0x08, 0x03, 0x01, 0x01, 0x02, 0x0A, 0x05, 0x08, 0x02,
	0x06, 0x06, 0x01, 0x08, 0x07, 0x0F, 0x08, 0x07, 0x02, 0x02, 0x01, 0x04, 0x02, 0xFE, 0x03, 0x28,
	0x4E, 0x28, 0x11, 0x0D, 0x02, 0x11, 0x28, 0x50, 0x28, 0x0D, 0x0F, 0x03, 0x12, 0x02, 0xC1, 0x18,
	0x4D, 0x03, 0x02, 0x03, 0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x04, 0x11, 0x13, 0x28, 0x14,
	0x08, 0x12, 0x08, 0x03, 0x16, 0x05, 0x04, 0x02, 0x01, 0x03, 0x02, 0x03, 0x02, 0x02, 0x07, 0x02,
	0x04, 0x27, 0x0D, 0x1F, 0x44, 0x22, 0x16, 0x28, 0x14, 0x16, 0x32, 0x16, 0x0E, 0x13, 0x08, 0x0F,
	0x08, 0x07, 0x14, 0x16, 0x37, 0x18, 0x01, 0x01, 0x01, 0x20, 0x44, 0x22, 0x11, 0x20, 0x11, 0x10,
	0x29, 0x12, 0x25, 0x5B, 0x17, 0x05, 0x0A, 0x05, 0x06, 0x19, 0x0A, 0x14, 0x29, 0x14, 0x08, 0x11,
	0x08, 0x07, 0x0B, 0x07, 0x08, 0x02, 0x01, 0x01, 0x03, 0x0B, 0x0A, 0x02, 0x01, 0x09, 0x0D, 0x03,
	0x01, 0x01, 0x02, 0x04, 0x03, 0x01, 0x03, 0x01, 0x03, 0x02, 0x04, 0x15, 0x06, 0x1B, 0x34, 0x1A,
	0x7E, 0x10, 0x12, 0x09, 0x3F, 0x0D, 0x10, 0x09, 0x44, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x55,
	0x00, 0x25, 0x04, 0x97, 0x03, 0x5A, 0x00, 0x92, 0x00, 0xC3, 0x00, 0x00, 0x01, 0x2E, 0x01, 0x27,
	0x34, 0x26, 0x27, 0x26, 0x22, 0x23, 0x2A, 0x01, 0x23, 0x06, 0x22, 0x23, 0x2A, 0x01, 0x23, 0x22,
	0x16, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x36, 0x23, 0x2A, 0x01, 0x23,
	0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x27, 0x26, 0x22, 0x23, 0x22, 0x26, 0x07, 0x0E,
	0x01, 0x07, 0x06, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x17, 0x1E, 0x01,
	0x17, 0x1E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x17,
	0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x27, 0x2E, 0x01, 0x27, 0x34,
	0x26, 0x27, 0x2E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x33, 0x16, 0x32, 0x33, 0x1E, 0x01,
	0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x35, 0x34, 0x36, 0x37,
	0x36, 0x16, 0x37, 0x32, 0x36, 0x33, 0x36, 0x32, 0x37, 0x32, 0x36, 0x35, 0x36, 0x34, 0x27, 0x05,
	0x06, 0x14, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x07, 0x06, 0x26, 0x35, 0x34, 0x36, 0x37, 0x3E,
	0x01, 0x17, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x37, 0x36, 0x26, 0x27, 0x2E, 0x01,
	0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x33, 0x16, 0x32, 0x33, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x07,
	0x04, 0x96, 0x01, 0x02, 0x01, 0x01, 0x0A, 0x0C, 0x16, 0x0D, 0x19, 0x32, 0x19, 0x34, 0x68, 0x34,
	0x04, 0x08, 0x02, 0x01, 0x01, 0x04, 0x05, 0x03, 0x1A, 0x35, 0x1A, 0x09, 0x14, 0x09, 0x05, 0x05,
	0x04, 0x0E, 0x1E, 0x0E, 0x3C, 0x78, 0x3C, 0x0F, 0x1D, 0x0F, 0x02, 0x02, 0x02, 0x02, 0x0F, 0x03,
	0x03, 0x0D, 0x03, 0x04, 0x04, 0x04, 0x09, 0x19, 0x0A, 0x09, 0x12, 0x06, 0x0B, 0x1C, 0x03, 0x03,
	0x01, 0x12, 0x11, 0x2C, 0x12, 0x14, 0x0A, 0x05, 0x03, 0x09, 0x05, 0x0A, 0x16, 0x0B, 0x0F, 0x16,
	0x09, 0x09, 0x10, 0x03, 0x01, 0x17, 0x0D, 0x1B, 0x35, 0x1B, 0x30, 0x62, 0x30, 0x09, 0x32, 0x16,
	0x05, 0x19, 0x01, 0x02, 0x01, 0x01, 0x02, 0x05, 0x0A, 0x17, 0x0C, 0x03, 0x1C, 0x05, 0x08, 0x0F,
	0x08, 0x1D, 0x3C, 0x1E, 0x27, 0x4E, 0x26, 0x08, 0x1E, 0x02, 0x01, 0x03, 0x02, 0x01, 0x04, 0x15,
	0x12, 0x0E, 0x22, 0x0F, 0x1F, 0x3F, 0x1F, 0x14, 0x27, 0x14, 0x14, 0x06, 0x01, 0x01, 0xFE, 0x9D,
	0x01, 0x0B, 0x08, 0x17, 0x08, 0x16, 0x29, 0x17, 0x19, 0x61, 0x01, 0x0C, 0x0C, 0x1E, 0x10, 0x03,
	0x03, 0x01, 0x01, 0x21, 0x0B, 0x0A, 0x15, 0x0D, 0x0E, 0x19, 0x03, 0x06, 0x0B, 0x04, 0x08, 0x14,
	0x02, 0x02, 0x0A, 0x0E, 0x18, 0x31, 0x18, 0x02, 0x18, 0x02, 0x08, 0x03, 0x01, 0x02, 0xDE, 0x0F,
	0x1E, 0x10, 0x0A, 0x16, 0x07, 0x06, 0x01, 0x0C, 0x0C, 0x0D, 0x01, 0x02, 0x03, 0x01, 0x02, 0x0D,
	0x02, 0x05, 0x07, 0x05, 0x05, 0x15, 0x09, 0x0F, 0x2A, 0x12, 0x17, 0x42, 0x10, 0x0F, 0x0B, 0x0C,
	0x0D, 0x1A, 0x17, 0x0E, 0x19, 0x0C, 0x1A, 0x33, 0x19, 0x20, 0x40, 0x21, 0x1D, 0x3C, 0x1E, 0x10,
	0x03, 0x03, 0x05, 0x0B, 0x05, 0x0A, 0x13, 0x0A, 0x02, 0x0A, 0x0E, 0x03, 0x0D, 0x06, 0x0D, 0x19,
	0x0C, 0x12, 0x20, 0x10, 0x21, 0x3F, 0x20, 0x08, 0x57, 0x01, 0x01, 0x02, 0x01, 0x01, 0x07, 0x07,
	0x01, 0x04, 0x0C, 0x0A, 0x13, 0x0A, 0x0F, 0x1E, 0x10, 0x13, 0x11, 0x04, 0x04, 0x03, 0x01, 0x01,
	0x01, 0x01, 0x2C, 0x0D, 0x16, 0x2A, 0x15, 0xF1, 0x0A, 0x17, 0x06, 0x03, 0x01, 0x01, 0x01, 0x01,
	0x02, 0x03, 0x03, 0x25, 0x11, 0x23, 0x0E, 0x0E, 0x03, 0x01, 0x28, 0x04, 0x0D, 0x1A, 0x06, 0x06,
	0x0B, 0x05, 0x04, 0x09, 0x01, 0x02, 0x07, 0x06, 0x0A, 0x19, 0x0E, 0x13, 0x04, 0x01, 0x06, 0x13,
	0x03, 0x0E, 0x21, 0x0F, 0x00, 0x03, 0x00, 0x59, 0x00, 0x25, 0x04, 0x8E, 0x03, 0x59, 0x00, 0xCD,
	0x00, 0xD3, 0x01, 0x1C, 0x00, 0x00, 0x01, 0x34, 0x36, 0x27, 0x26, 0x06, 0x37, 0x36, 0x26, 0x23,
	0x06, 0x26, 0x23, 0x22, 0x26, 0x23, 0x14, 0x16, 0x07, 0x06, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x22,
	0x06, 0x35, 0x3C, 0x01, 0x23, 0x0E, 0x01, 0x35, 0x36, 0x22, 0x23, 0x2A, 0x02, 0x26, 0x23, 0x1C,
	0x01, 0x15, 0x26, 0x22, 0x23, 0x14, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x17, 0x16, 0x06,
	0x07, 0x06, 0x14, 0x07, 0x06, 0x14, 0x17, 0x16, 0x32, 0x17, 0x16, 0x06, 0x17, 0x1E, 0x01, 0x17,
	0x1E, 0x01, 0x17, 0x16, 0x06, 0x17, 0x16, 0x06, 0x15, 0x14, 0x06, 0x07, 0x0E, 0x01, 0x17, 0x14,
	0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x15, 0x0E, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x36, 0x17, 0x16, 0x06, 0x17,
	0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x33, 0x32, 0x36, 0x33, 0x32,
	0x16, 0x35, 0x34, 0x26, 0x27, 0x2E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x35, 0x26, 0x36, 0x37, 0x3E, 0x01, 0x33, 0x3A, 0x01, 0x33,
	0x3A, 0x01, 0x17, 0x32, 0x16, 0x35, 0x34, 0x36, 0x27, 0x26, 0x36, 0x35, 0x34, 0x26, 0x35, 0x34,
	0x36, 0x37, 0x36, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x37, 0x36, 0x26,
	0x34, 0x26, 0x37, 0x01, 0x36, 0x16, 0x17, 0x22, 0x26, 0x01, 0x06, 0x26, 0x27, 0x14, 0x06, 0x23,
	0x2A, 0x01, 0x23, 0x22, 0x26, 0x07, 0x06, 0x36, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x35, 0x34,
	0x36, 0x37, 0x3E, 0x01, 0x17, 0x16, 0x06, 0x07, 0x06, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01,
	0x37, 0x32, 0x36, 0x27, 0x26, 0x06, 0x35, 0x2F, 0x01, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x35, 0x34,
	0x36, 0x37, 0x36, 0x16, 0x37, 0x36, 0x17, 0x16, 0x17, 0x1E, 0x01, 0x15, 0x1C, 0x01, 0x17, 0x1C,
	0x01, 0x07, 0x04, 0x8B, 0x03, 0x04, 0x05, 0x09, 0x02, 0x03, 0x24, 0x08, 0x16, 0x2C, 0x16, 0x3B,
	0x76, 0x3B, 0x03, 0x03, 0x03, 0x17, 0x04, 0x18, 0x2F, 0x16, 0x0A, 0x12, 0x06, 0x03, 0x0C, 0x01,
	0x09, 0x0A, 0x31, 0x61, 0x63, 0x62, 0x31, 0x08, 0x11, 0x08, 0x14, 0x05, 0x05, 0x0E, 0x06, 0x04,
	0x06, 0x01, 0x01, 0x04, 0x07, 0x05, 0x01, 0x02, 0x01, 0x01, 0x05, 0x04, 0x03, 0x01, 0x03, 0x07,
	0x13, 0x07, 0x12, 0x23, 0x0C, 0x06, 0x07, 0x01, 0x01, 0x09, 0x0B, 0x03, 0x02, 0x0A, 0x01, 0x0B,
	0x02, 0x04, 0x06, 0x03, 0x04, 0x0E, 0x07, 0x03, 0x04, 0x02, 0x03, 0x02, 0x03, 0x06, 0x05, 0x01,
	0x05, 0x3A, 0x0D, 0x05, 0x03, 0x09, 0x06, 0x10, 0x05, 0x0C, 0x24, 0x0D, 0x1A, 0x34, 0x19, 0x0A,
	0x0E, 0x0A, 0x0A, 0x14, 0x0A, 0x06, 0x12, 0x17, 0x03, 0x0A, 0x08, 0x07, 0x04, 0x04, 0x01, 0x02,
	0x08, 0x02, 0x04, 0x0B, 0x04, 0x04, 0x0A, 0x02, 0x02, 0x07, 0x01, 0x05, 0x01, 0x02, 0x06, 0x07,
	0x39, 0x71, 0x39, 0x18, 0x30, 0x18, 0x03, 0x13, 0x04, 0x08, 0x04, 0x03, 0x02, 0x0B, 0x0B, 0x06,
	0x23, 0x09, 0x0E, 0x1D, 0x0D, 0x1C, 0x37, 0x1C, 0x09, 0x42, 0x02, 0x03, 0x03, 0x01, 0x02, 0xFC,
	0x94, 0x03, 0x05, 0x01, 0x03, 0x04, 0x02, 0x19, 0x01, 0x0C, 0x07, 0x08, 0x0E, 0x12, 0x24, 0x12,
	0x21, 0x40, 0x20, 0x10, 0x01, 0x01, 0x01, 0x0A, 0x01, 0x01, 0x0D, 0x12, 0x04, 0x03, 0x16, 0x06,
	0x0A, 0x06, 0x01, 0x01, 0x12, 0x07, 0x08, 0x12, 0x0C, 0x09, 0x15, 0x0A, 0x06, 0x04, 0x04, 0x02,
	0x0F, 0x06, 0x06, 0x09, 0x12, 0x07, 0x0A, 0x01, 0x08, 0x05, 0x16, 0x2D, 0x16, 0x0E, 0x0B, 0x0B,
	0x0B, 0x04, 0x0F, 0x01, 0x02, 0x03, 0x25, 0x04, 0x12, 0x03, 0x05, 0x04, 0x0A, 0x0F, 0x01, 0x02,
	0x01, 0x01, 0x06, 0x19, 0x06, 0x04, 0x02, 0x02, 0x0C, 0x04, 0x0B, 0x01, 0x01, 0x05, 0x0A, 0x01,
	0x06, 0x0A, 0x06, 0x01, 0x0C, 0x11, 0x0B, 0x0A, 0x15, 0x0A, 0x09, 0x17, 0x0A, 0x0A, 0x05, 0x05,
	0x04, 0x19, 0x06, 0x07, 0x11, 0x07, 0x06, 0x03, 0x01, 0x04, 0x02, 0x04, 0x04, 0x03, 0x09, 0x1C,
	0x10, 0x08, 0x0C, 0x0A, 0x07, 0x0C, 0x05, 0x05, 0x17, 0x05, 0x03, 0x10, 0x03, 0x03, 0x18, 0x03,
	0x06, 0x11, 0x07, 0x0D, 0x1B, 0x0D, 0x05, 0x0F, 0x06, 0x07, 0x10, 0x07, 0x10, 0x26, 0x11, 0x05,
	0x04, 0x04, 0x05, 0x08, 0x05, 0x0B, 0x17, 0x0B, 0x19, 0x0F, 0x07, 0x03, 0x0E, 0x03, 0x02, 0x02,
	0x03, 0x07, 0x08, 0x01, 0x03, 0x06, 0x06, 0x03, 0x06, 0x03, 0x04, 0x0B, 0x04, 0x07, 0x04, 0x0C,
	0x34, 0x0F, 0x08, 0x18, 0x09, 0x09, 0x0F, 0x08, 0x0F, 0x1B, 0x0F, 0x0D, 0x19, 0x0D, 0x0A, 0x18,
	0x0A, 0x09, 0x16, 0x09, 0x06, 0x05, 0x01, 0x01, 0x05, 0x08, 0x14, 0x04, 0x02, 0x30, 0x05, 0x09,
	0x12, 0x09, 0x10, 0x0F, 0x0C, 0x06, 0x04, 0x05, 0x0C, 0x19, 0x36, 0x33, 0x35, 0x1A, 0xFD, 0x19,
	0x01, 0x02, 0x01, 0x01, 0x01, 0x8E, 0x08, 0x02, 0x01, 0x0E, 0x02, 0x01, 0x02, 0x01, 0x13, 0x0C,
	0x0B, 0x13, 0x0C, 0x0B, 0x12, 0x0B, 0x0A, 0x0C, 0x07, 0x05, 0x09, 0x02, 0x03, 0x2E, 0x07, 0x0F,
	0x12, 0x0B, 0x0B, 0x0C, 0x06, 0x04, 0x01, 0x01, 0x12, 0x02, 0x01, 0x02, 0x03, 0x03, 0x02, 0x05,
	0x0D, 0x08, 0x0D, 0x20, 0x0E, 0x06, 0x0E, 0x01, 0x05, 0x06, 0x01, 0x01, 0x02, 0x03, 0x0B, 0x04,
	0x07, 0x03, 0x12, 0x23, 0x12, 0x08, 0x0F, 0x08, 0x00, 0x02, 0x00, 0x53, 0x00, 0x26, 0x08, 0xFB,
	0x03, 0x5A, 0x00, 0x64, 0x00, 0x8C, 0x00, 0x00, 0x01, 0x2F, 0x01, 0x21, 0x07, 0x27, 0x21, 0x27,
	0x07, 0x23, 0x15, 0x23, 0x15, 0x23, 0x35, 0x27, 0x07, 0x35, 0x27, 0x23, 0x15, 0x21, 0x15, 0x23,
	0x35, 0x21, 0x2F, 0x02, 0x15, 0x0F, 0x01, 0x27, 0x07, 0x27, 0x22, 0x06, 0x07, 0x14, 0x16, 0x1F,
	0x02, 0x0F, 0x01, 0x1F, 0x01, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x0F, 0x02, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x0F, 0x01, 0x05, 0x27, 0x37, 0x13, 0x17, 0x3F, 0x01, 0x1F, 0x02, 0x3F, 0x03, 0x3E, 0x01,
	0x3F, 0x01, 0x21, 0x3F, 0x01, 0x35, 0x27, 0x35, 0x33, 0x15, 0x33, 0x15, 0x33, 0x17, 0x37, 0x21,
	0x37, 0x17, 0x21, 0x3F, 0x02, 0x27, 0x01, 0x0F, 0x02, 0x2F, 0x04, 0x2E, 0x01, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x3F, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x16, 0x1F, 0x01, 0x37, 0x2F, 0x01,
	0x34, 0x36, 0x3F, 0x03, 0x1F, 0x02, 0x15, 0x08, 0xF8, 0x08, 0x07, 0xFE, 0x46, 0x0A, 0x0A, 0xFE,
	0xA9, 0x0D, 0x0A, 0x96, 0x2B, 0x1C, 0x0B, 0x0A, 0x08, 0x49, 0xFE, 0xD3, 0xAF, 0xFE, 0xC7, 0x09,
	0x5C, 0x17, 0x1E, 0x13, 0x2B, 0x07, 0x10, 0x08, 0x09, 0x02, 0x04, 0x05, 0x0A, 0x35, 0x03, 0x01,
	0x0B, 0x26, 0x0E, 0x13, 0x04, 0x06, 0x03, 0x02, 0x0A, 0x14, 0x10, 0x1A, 0x0A, 0x09, 0x0E, 0x04,
	0x03, 0x01, 0x35, 0x10, 0x03, 0x49, 0x0A, 0x1A, 0x16, 0x16, 0x25, 0x15, 0x97, 0x16, 0x0E, 0x3A,
	0x02, 0x06, 0x03, 0x06, 0x01, 0x46, 0x03, 0x07, 0x07, 0x1E, 0x31, 0x91, 0x0D, 0x09, 0x01, 0x57,
	0x09, 0x06, 0x01, 0xBF, 0x05, 0x09, 0x04, 0x02, 0xFA, 0x55, 0x15, 0x1D, 0x3F, 0x47, 0x1F, 0x2A,
	0x25, 0x19, 0x04, 0x01, 0x02, 0x03, 0x0A, 0x08, 0x05, 0x13, 0x0D, 0x17, 0x10, 0x09, 0x0B, 0x01,
	0x01, 0x05, 0x06, 0x0B, 0x0A, 0x06, 0x02, 0x06, 0x05, 0x10, 0x24, 0xA4, 0x0A, 0x10, 0x02, 0x03,
	0x2D, 0x1E, 0x09, 0x04, 0x01, 0x06, 0x06, 0x2A, 0x14, 0x17, 0x0D, 0x01, 0x1A, 0x0A, 0x27, 0x05,
	0x06, 0x07, 0x02, 0x0D, 0x19, 0x39, 0x5E, 0x1C, 0x26, 0x02, 0x07, 0x08, 0x05, 0x0A, 0x03, 0x03,
	0x06, 0x15, 0x21, 0x0C, 0x0D, 0x05, 0x09, 0x05, 0x05, 0x0D, 0x0A, 0x19, 0x29, 0x23, 0x4A, 0x27,
	0x27, 0x52, 0x2B, 0x47, 0x03, 0x17, 0x23, 0x01, 0x36, 0x03, 0x03, 0x05, 0x03, 0x0C, 0x08, 0x05,
	0x05, 0x10, 0x8C, 0x05, 0x08, 0x03, 0x03, 0x31, 0x06, 0x18, 0x06, 0x32, 0x15, 0x19, 0x06, 0x06,
	0x03, 0x03, 0x0C, 0x1F, 0x37, 0x35, 0xFE, 0xEC, 0x3C, 0x41, 0x04, 0x03, 0x02, 0x02, 0x10, 0x1D,
	0x09, 0x14, 0x0B, 0x0A, 0x12, 0x09, 0x06, 0x0A, 0x04, 0x06, 0x13, 0x0C, 0x1A, 0x10, 0x08, 0x15,
	0x0C, 0x19, 0x07, 0x0E, 0x1D, 0x0A, 0x12, 0x08, 0x18, 0x23, 0x01, 0x01, 0x09, 0x0E, 0x09, 0x00,
	0x00, 0x02, 0x00, 0x65, 0x00, 0x26, 0x05, 0xF6, 0x03, 0x5F, 0x01, 0x7B, 0x01, 0xB5, 0x00, 0x00,
	0x01, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x15, 0x14, 0x06, 0x33, 0x3A, 0x03, 0x33,
	0x3A, 0x01, 0x33, 0x32, 0x26, 0x37, 0x36, 0x26, 0x35, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x33, 0x32,
	0x36, 0x17, 0x1E, 0x01, 0x15, 0x14, 0x16, 0x15, 0x14, 0x06, 0x17, 0x30, 0x17, 0x16, 0x35, 0x14,
	0x36, 0x17, 0x16, 0x06, 0x17, 0x32, 0x16, 0x15, 0x1C, 0x01, 0x15, 0x26, 0x16, 0x23, 0x32, 0x36,
	0x17, 0x26, 0x16, 0x35, 0x1C, 0x01, 0x15, 0x16, 0x06, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x26, 0x23,
	0x22, 0x26, 0x07, 0x15, 0x30, 0x07, 0x14, 0x06, 0x23, 0x0E, 0x01, 0x07, 0x06, 0x0F, 0x01, 0x14,
	0x26, 0x27, 0x26, 0x06, 0x27, 0x22, 0x26, 0x23, 0x22, 0x06, 0x23, 0x22, 0x06, 0x15, 0x1C, 0x01,
	0x15, 0x1C, 0x01, 0x15, 0x14, 0x26, 0x23, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x15, 0x1C, 0x01, 0x15,
	0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x32, 0x17, 0x16, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x07, 0x06, 0x16, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x07, 0x06, 0x26, 0x23, 0x2A, 0x01,
	0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x27, 0x26, 0x36, 0x35, 0x3C, 0x01, 0x35, 0x0E, 0x01, 0x23,
	0x22, 0x26, 0x35, 0x34, 0x26, 0x35, 0x34, 0x3D, 0x01, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22,
	0x16, 0x15, 0x26, 0x22, 0x27, 0x22, 0x06, 0x23, 0x0E, 0x01, 0x15, 0x14, 0x06, 0x07, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07,
	0x06, 0x32, 0x17, 0x1E, 0x01, 0x15, 0x1C, 0x01, 0x07, 0x06, 0x26, 0x23, 0x22, 0x26, 0x27, 0x2E,
	0x01, 0x27, 0x22, 0x26, 0x23, 0x22, 0x26, 0x27, 0x2A, 0x01, 0x35, 0x14, 0x26, 0x27, 0x26, 0x34,
	0x35, 0x34, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x37,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x35, 0x34, 0x36, 0x35, 0x37,
	0x36, 0x37, 0x3E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x35, 0x34, 0x06,
	0x23, 0x22, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x35, 0x34, 0x26, 0x35,
	0x3C, 0x01, 0x35, 0x34, 0x36, 0x35, 0x3C, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x35,
	0x36, 0x37, 0x32, 0x36, 0x33, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x27, 0x16, 0x36,
	0x17, 0x26, 0x36, 0x33, 0x1E, 0x01, 0x15, 0x14, 0x16, 0x17, 0x16, 0x36, 0x33, 0x3A, 0x01, 0x33,
	0x3A, 0x02, 0x16, 0x3B, 0x01, 0x31, 0x34, 0x26, 0x37, 0x03, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x23,
	0x2A, 0x01, 0x23, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x07, 0x06, 0x27, 0x2E, 0x01, 0x27,
	0x2E, 0x01, 0x35, 0x34, 0x26, 0x27, 0x3C, 0x01, 0x35, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x15, 0x14,
	0x06, 0x15, 0x14, 0x16, 0x32, 0x16, 0x33, 0x26, 0x36, 0x37, 0x32, 0x36, 0x15, 0x34, 0x36, 0x27,
	0x2E, 0x01, 0x35, 0x02, 0xFD, 0x11, 0x1C, 0x11, 0x05, 0x0D, 0x05, 0x04, 0x02, 0x01, 0x01, 0x2D,
	0x5A, 0x5A, 0x5B, 0x2D, 0x25, 0x4C, 0x26, 0x05, 0x03, 0x02, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02,
	0x0D, 0x03, 0x09, 0x12, 0x08, 0x01, 0x06, 0x08, 0x01, 0x02, 0x04, 0x04, 0x0B, 0x02, 0x02, 0x04,
	0x04, 0x01, 0x03, 0x01, 0x0C, 0x04, 0x09, 0x15, 0x08, 0x02, 0x09, 0x01, 0x01, 0x09, 0x07, 0x07,
	0x18, 0x05, 0x03, 0x07, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x0E, 0x05, 0x26, 0x4C, 0x26,
	0x2F, 0x5E, 0x30, 0x03, 0x04, 0x02, 0x0B, 0x06, 0x2E, 0x09, 0x0C, 0x0F, 0x09, 0x04, 0x0D, 0x0C,
	0x02, 0x04, 0x02, 0x02, 0x02, 0x03, 0x09, 0x07, 0x06, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x13,
	0x02, 0x1B, 0x37, 0x1B, 0x0C, 0x16, 0x0B, 0x09, 0x05, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x04,
	0x26, 0x03, 0x0F, 0x1D, 0x0F, 0x13, 0x26, 0x13, 0x09, 0x02, 0x14, 0x29, 0x14, 0x05, 0x07, 0x02,
	0x01, 0x07, 0x05, 0x02, 0x04, 0x05, 0x03, 0x02, 0x01, 0x02, 0x02, 0x04, 0x02, 0x04, 0x04, 0x02,
	0x01, 0x05, 0x01, 0x02, 0x03, 0x01, 0x03, 0x03, 0x03, 0x02, 0x04, 0x09, 0x06, 0x13, 0x02, 0x09,
	0x13, 0x07, 0x16, 0x25, 0x15, 0x10, 0x20, 0x13, 0x05, 0x0B, 0x06, 0x07, 0x16, 0x10, 0x02, 0x02,
	0x07, 0x03, 0x02, 0x06, 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x01, 0x03, 0x0B, 0x11,
	0x07, 0x07, 0x16, 0x07, 0x02, 0x05, 0x03, 0x01, 0x08, 0x10, 0x02, 0x03, 0x01, 0x02, 0x06, 0x01,
	0x01, 0x07, 0x02, 0x02, 0x05, 0x04, 0x05, 0x03, 0x19, 0x07, 0x08, 0x10, 0x06, 0x06, 0x07, 0x04,
	0x02, 0x09, 0x01, 0x03, 0x07, 0x02, 0x02, 0x04, 0x04, 0x03, 0x02, 0x02, 0x04, 0x02, 0x01, 0x01,
	0x01, 0x09, 0x01, 0x04, 0x02, 0x02, 0x06, 0x0C, 0x06, 0x07, 0x1B, 0x02, 0x02, 0x05, 0x02, 0x01,
	0x0B, 0x0A, 0x05, 0x11, 0x03, 0x01, 0x03, 0x15, 0x06, 0x16, 0x29, 0x15, 0x2F, 0x5E, 0x5D, 0x5E,
	0x2F, 0x01, 0x01, 0x02, 0x45, 0x04, 0x05, 0x08, 0x06, 0x15, 0x07, 0x0C, 0x18, 0x0C, 0x02, 0x13,
	0x08, 0x03, 0x12, 0x01, 0x01, 0x08, 0x08, 0x08, 0x0E, 0x14, 0x0B, 0x02, 0x0E, 0x09, 0x02, 0x0D,
	0x03, 0x07, 0x03, 0x07, 0x09, 0x32, 0x3E, 0x39, 0x07, 0x01, 0x03, 0x03, 0x01, 0x08, 0x01, 0x01,
	0x01, 0x04, 0x03, 0x44, 0x09, 0x12, 0x0B, 0x04, 0x07, 0x05, 0x04, 0x05, 0x07, 0x02, 0x12, 0x01,
	0x03, 0x01, 0x05, 0x01, 0x02, 0x01, 0x02, 0x02, 0x0F, 0x01, 0x05, 0x01, 0x08, 0x02, 0x02, 0x03,
	0x04, 0x02, 0x05, 0x01, 0x03, 0x04, 0x01, 0x08, 0x01, 0x05, 0x03, 0x10, 0x02, 0x0B, 0x02, 0x02,
	0x04, 0x02, 0x04, 0x0A, 0x03, 0x03, 0x01, 0x07, 0x02, 0x02, 0x05, 0x02, 0x07, 0x10, 0x07, 0x04,
	0x07, 0x03, 0x08, 0x01, 0x03, 0x04, 0x08, 0x08, 0x03, 0x0C, 0x01, 0x09, 0x02, 0x02, 0x04, 0x04,
	0x09, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x0A, 0x08, 0x0F, 0x07, 0x08, 0x0F, 0x07,
	0x09, 0x01, 0x1F, 0x09, 0x04, 0x0C, 0x08, 0x0A, 0x13, 0x09, 0x06, 0x0D, 0x06, 0x02, 0x06, 0x03,
	0x01, 0x03, 0x08, 0x18, 0x07, 0x0A, 0x09, 0x05, 0x03, 0x09, 0x08, 0x0E, 0x20, 0x0E, 0x2F, 0x5E,
	0x2F, 0x03, 0x11, 0x02, 0x01, 0x01, 0x05, 0x07, 0x1F, 0x08, 0x39, 0x73, 0x39, 0x03, 0x0D, 0x03,
	0x05, 0x08, 0x1A, 0x0B, 0x01, 0x0C, 0x0C, 0x13, 0x08, 0x01, 0x01, 0x20, 0x01, 0x0B, 0x02, 0x06,
	0x06, 0x05, 0x07, 0x10, 0x07, 0x05, 0x06, 0x05, 0x03, 0x0A, 0x03, 0x08, 0x0D, 0x08, 0x03, 0x08,
	0x02, 0x05, 0x0A, 0x05, 0x09, 0x06, 0x03, 0x0C, 0x02, 0x0A, 0x18, 0x05, 0x02, 0x06, 0x02, 0x01,
	0x01, 0x02, 0x01, 0x05, 0x03, 0x01, 0x09, 0x01, 0x07, 0x04, 0x04, 0x09, 0x05, 0x12, 0x1B, 0x10,
	0x07, 0x0E, 0x08, 0x02, 0x04, 0x01, 0x03, 0x02, 0x02, 0x04, 0x09, 0x03, 0x0B, 0x21, 0x10, 0x11,
	0x1D, 0x0D, 0x04, 0x06, 0x03, 0x02, 0x0D, 0x01, 0x09, 0x0D, 0x0A, 0x07, 0x08, 0x02, 0x06, 0x06,
	0x06, 0x04, 0x0B, 0x03, 0x04, 0x0A, 0x04, 0x05, 0x08, 0x08, 0x08, 0x02, 0x02, 0x01, 0x01, 0x0B,
	0x02, 0x01, 0x0A, 0x02, 0x02, 0x09, 0x04, 0x06, 0x15, 0x08, 0x0F, 0x1E, 0x0F, 0x0A, 0x15, 0x07,
	0x04, 0x09, 0x02, 0x01, 0x03, 0x02, 0x01, 0x02, 0x01, 0x02, 0x03, 0x01, 0x06, 0x02, 0x03, 0x02,
	0x04, 0x07, 0x04, 0x03, 0x0F, 0x09, 0x01, 0x01, 0x01, 0x0B, 0x09, 0x01, 0x01, 0x05, 0x03, 0x0F,
	0x01, 0x04, 0x01, 0x01, 0x07, 0x12, 0x05, 0xFE, 0xA1, 0x08, 0x14, 0x04, 0x02, 0x01, 0x0C, 0x15,
	0x07, 0x03, 0x08, 0x04, 0x09, 0x04, 0x03, 0x02, 0x04, 0x09, 0x0B, 0x03, 0x0B, 0x03, 0x03, 0x11,
	0x03, 0x01, 0x03, 0x01, 0x02, 0x1B, 0x07, 0x03, 0x11, 0x04, 0x05, 0x0C, 0x05, 0x02, 0x02, 0x01,
	0x05, 0x05, 0x04, 0x0E, 0x01, 0x04, 0x05, 0x04, 0x04, 0x06, 0x04, 0x00, 0x00, 0x03, 0x00, 0x5A,
	0x00, 0x26, 0x05, 0x2D, 0x03, 0x5A, 0x00, 0xCC, 0x00, 0xDC, 0x01, 0x0E, 0x00, 0x00, 0x01, 0x16,
	0x32, 0x33, 0x3E, 0x01, 0x33, 0x1E, 0x01, 0x3A, 0x01, 0x33, 0x3E, 0x01, 0x37, 0x1E, 0x01, 0x17,
	0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x32, 0x16, 0x17, 0x16, 0x14, 0x07, 0x2A, 0x01, 0x27, 0x06,
	0x16, 0x07, 0x0E, 0x01, 0x23, 0x06, 0x26, 0x07, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x07, 0x0E, 0x01,
	0x07, 0x22, 0x06, 0x23, 0x1E, 0x03, 0x17, 0x1E, 0x01, 0x17, 0x0E, 0x01, 0x07, 0x14, 0x07, 0x06,
	0x15, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x22, 0x06, 0x27, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x27,
	0x2E, 0x02, 0x27, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x0E, 0x02, 0x16, 0x15, 0x14, 0x16, 0x07, 0x0E,
	0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x06, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27,
	0x0E, 0x01, 0x23, 0x22, 0x26, 0x27, 0x3C, 0x01, 0x35, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x2E, 0x01, 0x06, 0x27, 0x26, 0x36, 0x27,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x27, 0x2E, 0x01, 0x37, 0x26, 0x36, 0x37, 0x3E,
	0x01, 0x37, 0x36, 0x16, 0x17, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x33, 0x3E, 0x01, 0x37, 0x36, 0x16,
	0x33, 0x1E, 0x01, 0x17, 0x3A, 0x01, 0x17, 0x05, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x1E, 0x01,
	0x17, 0x3E, 0x01, 0x27, 0x36, 0x26, 0x27, 0x05, 0x26, 0x06, 0x07, 0x14, 0x06, 0x15, 0x0E, 0x01,
	0x07, 0x06, 0x16, 0x17, 0x1E, 0x01, 0x15, 0x22, 0x26, 0x27, 0x26, 0x37, 0x36, 0x35, 0x36, 0x26,
	0x27, 0x34, 0x36, 0x35, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37,
	0x3E, 0x01, 0x37, 0x36, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x02, 0x4B, 0x1B, 0x36, 0x1B, 0x0D, 0x1B,
	0x0D, 0x29, 0x52, 0x52, 0x52, 0x29, 0x02, 0x02, 0x04, 0x09, 0x13, 0x09, 0x04, 0x07, 0x06, 0x05,
	0x02, 0x04, 0x2A, 0x55, 0x2A, 0x07, 0x07, 0x2B, 0x56, 0x2B, 0x04, 0x03, 0x04, 0x02, 0x0C, 0x06,
	0x27, 0x50, 0x26, 0x0D, 0x14, 0x0C, 0x03, 0x05, 0x02, 0x06, 0x0E, 0x07, 0x0B, 0x16, 0x0B, 0x12,
	0x21, 0x22, 0x21, 0x11, 0x06, 0x0F, 0x05, 0x03, 0x06, 0x03, 0x01, 0x01, 0x05, 0x0E, 0x06, 0x05,
	0x07, 0x06, 0x08, 0x0E, 0x07, 0x10, 0x20, 0x10, 0x06, 0x06, 0x02, 0x0F, 0x1E, 0x1E, 0x10, 0x10,
	0x0E, 0x0D, 0x1C, 0x0E, 0x07, 0x0A, 0x05, 0x03, 0x02, 0x02, 0x0B, 0x19, 0x0D, 0x16, 0x2E, 0x17,
	0x13, 0x25, 0x12, 0x0F, 0x22, 0x0F, 0x0F, 0x12, 0x05, 0x07, 0x14, 0x08, 0x07, 0x0F, 0x04, 0x02,
	0x01, 0x01, 0x08, 0x11, 0x03, 0x06, 0x0F, 0x09, 0x02, 0x05, 0x03, 0x2F, 0x5D, 0x2F, 0x05, 0x0A,
	0x04, 0x10, 0x24, 0x06, 0x03, 0x06, 0x07, 0x0A, 0x15, 0x0B, 0x05, 0x0C, 0x06, 0x0B, 0x1B, 0x09,
	0x06, 0x0A, 0x25, 0x2A, 0x14, 0x08, 0x02, 0x01, 0x14, 0x2A, 0x0F, 0x06, 0x01, 0x01, 0x02, 0x09,
	0x08, 0x06, 0x0B, 0x01, 0x01, 0x07, 0x05, 0x04, 0x08, 0x04, 0x07, 0x0C, 0x06, 0x05, 0x0C, 0x05,
	0x0C, 0x18, 0x0B, 0x03, 0x04, 0x02, 0x06, 0x0C, 0x06, 0x03, 0x05, 0x02, 0x42, 0x84, 0x42, 0xFE,
	0x72, 0x02, 0x05, 0x02, 0x01, 0x03, 0x01, 0x02, 0x09, 0x05, 0x03, 0x07, 0x01, 0x01, 0x08, 0x04,
	0x01, 0xE4, 0x11, 0x1D, 0x10, 0x01, 0x04, 0x0D, 0x02, 0x03, 0x08, 0x0B, 0x06, 0x0E, 0x10, 0x17,
	0x09, 0x0A, 0x03, 0x03, 0x01, 0x05, 0x02, 0x01, 0x0D, 0x16, 0x09, 0x0A, 0x0D, 0x01, 0x01, 0x1E,
	0x13, 0x20, 0x42, 0x1E, 0x10, 0x17, 0x04, 0x01, 0x02, 0x08, 0x07, 0x18, 0x0C, 0x03, 0x41, 0x03,
	0x02, 0x01, 0x01, 0x01, 0x05, 0x0B, 0x04, 0x01, 0x01, 0x01, 0x06, 0x0D, 0x04, 0x03, 0x0B, 0x03,
	0x01, 0x01, 0x0F, 0x23, 0x10, 0x01, 0x11, 0x22, 0x10, 0x07, 0x04, 0x01, 0x01, 0x01, 0x01, 0x11,
	0x04, 0x02, 0x06, 0x04, 0x05, 0x07, 0x03, 0x01, 0x36, 0x6C, 0x6B, 0x6C, 0x36, 0x16, 0x2A, 0x16,
	0x03, 0x04, 0x03, 0x06, 0x06, 0x07, 0x05, 0x05, 0x01, 0x01, 0x01, 0x0B, 0x01, 0x07, 0x01, 0x01,
	0x01, 0x06, 0x10, 0x08, 0x2F, 0x5F, 0x5F, 0x2F, 0x30, 0x30, 0x2D, 0x5A, 0x2D, 0x06, 0x10, 0x12,
	0x12, 0x0A, 0x0E, 0x1E, 0x0F, 0x09, 0x0B, 0x05, 0x08, 0x08, 0x02, 0x02, 0x08, 0x06, 0x05, 0x07,
	0x08, 0x05, 0x1B, 0x0F, 0x1C, 0x38, 0x1C, 0x16, 0x2B, 0x16, 0x0F, 0x1E, 0x0F, 0x04, 0x08, 0x09,
	0x08, 0x0D, 0x06, 0x01, 0x02, 0x01, 0x01, 0x01, 0x05, 0x02, 0x07, 0x0D, 0x06, 0x02, 0x0D, 0x11,
	0x19, 0x33, 0x18, 0x20, 0x40, 0x20, 0x0E, 0x1A, 0x0D, 0x16, 0x25, 0x16, 0x14, 0x2D, 0x17, 0x05,
	0x01, 0x05, 0x12, 0x07, 0x06, 0x06, 0x10, 0x06, 0x10, 0x08, 0x0B, 0x15, 0x07, 0x06, 0x0C, 0x09,
	0x08, 0x0C, 0x05, 0x02, 0x04, 0x01, 0x01, 0x05, 0x02, 0x07, 0x0D, 0x06, 0x01, 0x01, 0x06, 0x0C,
	0x05, 0x01, 0x01, 0x05, 0x0C, 0x06, 0x01, 0x24, 0x02, 0x01, 0x02, 0x05, 0x02, 0x05, 0x07, 0x01,
	0x03, 0x06, 0x04, 0x06, 0x04, 0x02, 0xA7, 0x02, 0x0F, 0x01, 0x03, 0x05, 0x03, 0x08, 0x0E, 0x0A,
	0x0F, 0x20, 0x0B, 0x05, 0x0B, 0x09, 0x17, 0x0C, 0x0F, 0x12, 0x11, 0x12, 0x04, 0x05, 0x03, 0x02,
	0x06, 0x02, 0x0D, 0x08, 0x0A, 0x1B, 0x0E, 0x16, 0x1F, 0x06, 0x07, 0x06, 0x0F, 0x08, 0x1D, 0x11,
	0x0D, 0x1C, 0x0B, 0x0B, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x5A, 0x00, 0x27, 0x06, 0xE3,
	0x03, 0x5A, 0x00, 0xD6, 0x00, 0xE6, 0x00, 0xF3, 0x01, 0x06, 0x01, 0x34, 0x00, 0x00, 0x01, 0x14,
	0x16, 0x17, 0x16, 0x06, 0x17, 0x16, 0x06, 0x07, 0x06, 0x16, 0x07, 0x14, 0x06, 0x23, 0x2A, 0x01,
	0x23, 0x2A, 0x03, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x0E, 0x02, 0x07, 0x06, 0x14, 0x07, 0x06, 0x26,
	0x07, 0x0E, 0x01, 0x15, 0x14, 0x06, 0x07, 0x0E, 0x01, 0x23, 0x2A, 0x01, 0x27, 0x2E, 0x01, 0x27,
	0x2E, 0x01, 0x07, 0x06, 0x16, 0x17, 0x16, 0x06, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x22,
	0x16, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x17, 0x1E, 0x01, 0x15, 0x14, 0x06,
	0x07, 0x0E, 0x01, 0x07, 0x06, 0x22, 0x23, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x37,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x37, 0x36, 0x33, 0x36,
	0x16, 0x37, 0x36, 0x26, 0x27, 0x26, 0x06, 0x27, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x33, 0x32, 0x26,
	0x37, 0x3E, 0x01, 0x37, 0x36, 0x32, 0x33, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x37, 0x36, 0x16, 0x33,
	0x32, 0x06, 0x33, 0x32, 0x16, 0x15, 0x14, 0x36, 0x33, 0x32, 0x36, 0x17, 0x1E, 0x01, 0x33, 0x3A,
	0x01, 0x33, 0x32, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x03,
	0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x33, 0x3A, 0x01, 0x17, 0x1E, 0x01, 0x37,
	0x05, 0x36, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x07, 0x06, 0x32, 0x33, 0x3A, 0x01, 0x33,
	0x37, 0x36, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x06, 0x36, 0x33, 0x3A, 0x01, 0x33, 0x17, 0x3A, 0x01,
	0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x27, 0x26, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x17,
	0x01, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x16, 0x17, 0x1E, 0x01, 0x07, 0x06, 0x26, 0x27,
	0x2E, 0x01, 0x27, 0x34, 0x26, 0x23, 0x0E, 0x01, 0x07, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x27, 0x2E, 0x01, 0x07, 0x06, 0xC2,
	0x1C, 0x02, 0x01, 0x01, 0x01, 0x02, 0x07, 0x04, 0x02, 0x04, 0x01, 0x05, 0x06, 0x0A, 0x14, 0x09,
	0x3D, 0x78, 0x78, 0x78, 0x3C, 0x2F, 0x5C, 0x2F, 0x10, 0x05, 0x0F, 0x09, 0x02, 0x01, 0x04, 0x08,
	0x35, 0x10, 0x0D, 0x47, 0x08, 0x17, 0x13, 0x36, 0x17, 0x14, 0x2D, 0x10, 0x12, 0x1B, 0x07, 0x01,
	0x0C, 0x06, 0x03, 0x08, 0x01, 0x03, 0x0B, 0x0B, 0x08, 0x15, 0x0A, 0x0C, 0x17, 0x0C, 0x08, 0x05,
	0x01, 0x01, 0x04, 0x01, 0x02, 0x11, 0x05, 0x08, 0x07, 0x02, 0x02, 0x01, 0x0C, 0x09, 0x0C, 0x07,
	0x04, 0x02, 0x39, 0x11, 0x19, 0x31, 0x19, 0x16, 0x27, 0x0F, 0x10, 0x04, 0x03, 0x08, 0x31, 0x1E,
	0x0A, 0x14, 0x0A, 0x0B, 0x1B, 0x08, 0x04, 0x01, 0x05, 0x04, 0x0A, 0x06, 0x06, 0x08, 0x05, 0x0B,
	0x1D, 0x0C, 0x0E, 0x08, 0x09, 0x09, 0x0D, 0x0C, 0x06, 0x06, 0x06, 0x06, 0x05, 0x0D, 0x05, 0x16,
	0x1B, 0x10, 0x0A, 0x1B, 0x07, 0x0B, 0x15, 0x0C, 0x0D, 0x18, 0x0E, 0x0B, 0x01, 0x07, 0x04, 0x08,
	0x04, 0x0D, 0x18, 0x10, 0x07, 0x1B, 0x04, 0x01, 0x01, 0x02, 0x02, 0x12, 0x03, 0x06, 0x04, 0x04,
	0x09, 0x02, 0x07, 0x06, 0x09, 0x20, 0x08, 0x03, 0x05, 0x04, 0x05, 0x0C, 0x05, 0x13, 0x25, 0x12,
	0x39, 0x70, 0x38, 0x0B, 0x0B, 0x09, 0x11, 0x23, 0x11, 0x33, 0x67, 0x66, 0x67, 0x33, 0x1D, 0x3A,
	0x1D, 0x0D, 0x1C, 0x0B, 0x08, 0x0E, 0x08, 0x06, 0x05, 0x02, 0x01, 0x02, 0x08, 0xFD, 0xDE, 0x05,
	0x2B, 0x09, 0x0C, 0x18, 0x0B, 0x03, 0x16, 0x02, 0x0C, 0x38, 0x03, 0x12, 0x26, 0x12, 0xFE, 0x05,
	0x33, 0x08, 0x12, 0x24, 0x11, 0x01, 0x2E, 0x08, 0x12, 0x24, 0x12, 0x7D, 0x11, 0x24, 0x12, 0x0A,
	0x15, 0x0A, 0x02, 0x12, 0x07, 0x01, 0x11, 0x02, 0x0D, 0x19, 0x0C, 0x08, 0x33, 0x04, 0xFC, 0xC3,
	0x08, 0x0F, 0x09, 0x0D, 0x0D, 0x03, 0x04, 0x09, 0x08, 0x02, 0x09, 0x04, 0x06, 0x05, 0x06, 0x11,
	0x0F, 0x05, 0x1F, 0x02, 0x0C, 0x15, 0x0C, 0x05, 0x09, 0x05, 0x08, 0x0F, 0x0F, 0x16, 0x4B, 0x1A,
	0x16, 0x1B, 0x09, 0x06, 0x01, 0x01, 0x02, 0x06, 0x12, 0x0A, 0x23, 0x06, 0x03, 0x33, 0x16, 0x1D,
	0x16, 0x0A, 0x12, 0x0A, 0x0D, 0x15, 0x0C, 0x06, 0x18, 0x08, 0x04, 0x1D, 0x04, 0x21, 0x21, 0x12,
	0x08, 0x21, 0x07, 0x0C, 0x06, 0x05, 0x04, 0x11, 0x0E, 0x1C, 0x3B, 0x13, 0x10, 0x08, 0x0D, 0x0F,
	0x1E, 0x17, 0x03, 0x25, 0x0A, 0x05, 0x23, 0x05, 0x0E, 0x02, 0x05, 0x03, 0x06, 0x02, 0x02, 0x05,
	0x01, 0x1C, 0x07, 0x0C, 0x17, 0x0C, 0x08, 0x14, 0x07, 0x0C, 0x0D, 0x0F, 0x0D, 0x18, 0x0D, 0x0C,
	0x08, 0x07, 0x0B, 0x0D, 0x0E, 0x16, 0x01, 0x03, 0x02, 0x01, 0x01, 0x13, 0x18, 0x32, 0x1B, 0x3F,
	0x7A, 0x39, 0x12, 0x24, 0x12, 0x16, 0x2C, 0x16, 0x0B, 0x15, 0x0A, 0x08, 0x01, 0x05, 0x03, 0x0D,
	0x04, 0x06, 0x04, 0x02, 0x03, 0x08, 0x09, 0x08, 0x0D, 0x03, 0x01, 0x02, 0x03, 0x01, 0x04, 0x03,
	0x0A, 0x23, 0x01, 0x01, 0x0B, 0x0A, 0x05, 0x08, 0x02, 0x02, 0x06, 0x03, 0x07, 0x04, 0x08, 0x04,
	0x0A, 0x04, 0x0C, 0x06, 0x03, 0x27, 0x02, 0x02, 0x02, 0x08, 0x01, 0x09, 0x06, 0x01, 0x04, 0x04,
	0x01, 0x0B, 0x03, 0x06, 0x0D, 0x04, 0x03, 0x05, 0x06, 0x06, 0x08, 0x02, 0x28, 0x0F, 0x04, 0x02,
	0x02, 0x0B, 0x01, 0x0E, 0x04, 0x0D, 0x03, 0x01, 0x01, 0x07, 0x02, 0x02, 0x04, 0x0C, 0xFE, 0xA1,
	0x05, 0x08, 0x03, 0x03, 0x02, 0x0E, 0x11, 0x18, 0x0E, 0x03, 0x08, 0x03, 0x05, 0x04, 0x05, 0x0F,
	0x23, 0x15, 0x02, 0x08, 0x03, 0x06, 0x03, 0x0C, 0x18, 0x0C, 0x12, 0x0F, 0x0B, 0x10, 0x02, 0x06,
	0x05, 0x13, 0x13, 0x0B, 0x1D, 0x0D, 0x13, 0x07, 0x07, 0x04, 0x11, 0x0F, 0x00, 0x03, 0x00, 0x5D,
	0x00, 0x26, 0x04, 0xE3, 0x03, 0x5A, 0x00, 0xE7, 0x00, 0xF7, 0x01, 0x07, 0x00, 0x00, 0x01, 0x1C,
	0x01, 0x07, 0x06, 0x26, 0x23, 0x22, 0x06, 0x15, 0x14, 0x16, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x16,
	0x17, 0x16, 0x06, 0x17, 0x1E, 0x01, 0x17, 0x22, 0x26, 0x23, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x07,
	0x06, 0x26, 0x23, 0x06, 0x26, 0x27, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x26, 0x07, 0x06,
	0x16, 0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01,
	0x23, 0x22, 0x36, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x27,
	0x26, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26,
	0x06, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x26, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x2B,
	0x01, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x06, 0x23, 0x22, 0x26, 0x27, 0x26, 0x06, 0x27,
	0x2E, 0x01, 0x27, 0x26, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x35, 0x1E,
	0x01, 0x17, 0x1E, 0x01, 0x33, 0x30, 0x17, 0x16, 0x17, 0x16, 0x06, 0x07, 0x06, 0x26, 0x23, 0x22,
	0x26, 0x27, 0x2E, 0x01, 0x27, 0x2A, 0x01, 0x27, 0x31, 0x27, 0x06, 0x36, 0x33, 0x1E, 0x01, 0x17,
	0x1E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x35, 0x36,
	0x34, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01,
	0x33, 0x32, 0x26, 0x37, 0x36, 0x26, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x15, 0x14, 0x06, 0x33,
	0x3A, 0x01, 0x33, 0x32, 0x16, 0x17, 0x05, 0x16, 0x32, 0x33, 0x32, 0x36, 0x27, 0x26, 0x06, 0x23,
	0x22, 0x26, 0x07, 0x0E, 0x01, 0x17, 0x01, 0x22, 0x06, 0x15, 0x1C, 0x01, 0x15, 0x1E, 0x01, 0x17,
	0x3E, 0x01, 0x37, 0x2E, 0x01, 0x23, 0x04, 0xE3, 0x0C, 0x07, 0x27, 0x0A, 0x10, 0x01, 0x04, 0x0D,
	0x22, 0x46, 0x23, 0x0E, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x02, 0x11, 0x22, 0x11, 0x03,
	0x1A, 0x04, 0x09, 0x11, 0x0E, 0x09, 0x14, 0x09, 0x1B, 0x2E, 0x18, 0x0F, 0x04, 0x02, 0x02, 0x01,
	0x03, 0x0A, 0x15, 0x0A, 0x19, 0x31, 0x19, 0x03, 0x01, 0x0F, 0x10, 0x0D, 0x1A, 0x0C, 0x0A, 0x09,
	0x06, 0x02, 0x06, 0x01, 0x03, 0x06, 0x04, 0x08, 0x11, 0x09, 0x02, 0x03, 0x06, 0x07, 0x0D, 0x0A,
	0x0C, 0x38, 0x0F, 0x08, 0x0A, 0x05, 0x09, 0x0D, 0x04, 0x04, 0x16, 0x04, 0x0F, 0x1E, 0x0F, 0x02,
	0x0C, 0x0C, 0x1B, 0x04, 0x0B, 0x11, 0x0A, 0x09, 0x14, 0x09, 0x07, 0x0D, 0x03, 0x08, 0x0B, 0x02,
	0x03, 0x02, 0x02, 0x01, 0x02, 0x01, 0x01, 0x1D, 0x50, 0x9E, 0x4F, 0x08, 0x0F, 0x08, 0x03, 0x03,
	0x01, 0x02, 0x04, 0x05, 0x10, 0x28, 0x12, 0x13, 0x24, 0x12, 0x0E, 0x1C, 0x0D, 0x03, 0x15, 0x01,
	0x01, 0x02, 0x10, 0x09, 0x0B, 0x15, 0x0A, 0x16, 0x27, 0x15, 0x24, 0x48, 0x24, 0x2A, 0x53, 0x2A,
	0x19, 0x33, 0x19, 0x04, 0x01, 0x02, 0x0C, 0x10, 0x24, 0x10, 0x06, 0x09, 0x02, 0x05, 0x03, 0x09,
	0x18, 0x2F, 0x18, 0x03, 0x07, 0x04, 0x05, 0x03, 0x02, 0x02, 0x01, 0x06, 0x0A, 0x39, 0x0B, 0x11,
	0x01, 0x02, 0x12, 0x0B, 0x17, 0x0C, 0x0C, 0x07, 0x07, 0xFE, 0x07, 0x17, 0x2E, 0x19, 0x13, 0x24,
	0x06, 0x06, 0x3B, 0x16, 0x0A, 0x1D, 0x0A, 0x0E, 0x05, 0x0C, 0xFD, 0xC9, 0x09, 0x08, 0x01, 0x02,
	0x02, 0x06, 0x0D, 0x08, 0x04, 0x07, 0x04, 0x02, 0xC8, 0x11, 0x16, 0x0B, 0x07, 0x03, 0x12, 0x0D,
	0x0B, 0x1A, 0x0F, 0x0A, 0x08, 0x04, 0x08, 0x06, 0x0D, 0x07, 0x01, 0x01, 0x32, 0x05, 0x0B, 0x11,
	0x03, 0x03, 0x01, 0x01, 0x07, 0x0F, 0x2D, 0x5C, 0x2D, 0x09, 0x10, 0x09, 0x09, 0x05, 0x05, 0x03,
	0x0F, 0x03, 0x0D, 0x1B, 0x0D, 0x1A, 0x35, 0x1A, 0x02, 0x0A, 0x39, 0x05, 0x1B, 0x36, 0x1C, 0x11,
	0x03, 0x0E, 0x08, 0x03, 0x12, 0x03, 0x0E, 0x1D, 0x0F, 0x25, 0x4B, 0x25, 0x0C, 0x0B, 0x0B, 0x0C,
	0x1B, 0x0A, 0x0C, 0x06, 0x01, 0x01, 0x09, 0x05, 0x09, 0x12, 0x03, 0x03, 0x03, 0x0C, 0x15, 0x0C,
	0x0B, 0x16, 0x0B, 0x02, 0x07, 0x02, 0x03, 0x03, 0x02, 0x04, 0x02, 0x0F, 0x06, 0x0F, 0x1E, 0x0F,
	0x27, 0x51, 0x27, 0x17, 0x2C, 0x16, 0x0E, 0x14, 0x0E, 0x05, 0x0E, 0x0B, 0x01, 0x03, 0x04, 0x03,
	0x01, 0x07, 0x07, 0x03, 0x0A, 0x01, 0x02, 0x01, 0x01, 0x02, 0x01, 0x03, 0x01, 0x0C, 0x01, 0x01,
	0x03, 0x01, 0x02, 0x01, 0x12, 0x05, 0x0B, 0x09, 0x02, 0x02, 0x01, 0x04, 0x02, 0x0E, 0x06, 0x09,
	0x02, 0x02, 0x04, 0x05, 0x0D, 0x02, 0x04, 0x1A, 0x09, 0x0E, 0x1C, 0x15, 0x0A, 0x2A, 0x02, 0x0B,
	0xE9, 0x08, 0x10, 0x1A, 0x1D, 0x02, 0x02, 0x05, 0x07, 0x29, 0x0A, 0x01, 0x33, 0x01, 0x0B, 0x07,
	0x0F, 0x08, 0x10, 0x1E, 0x10, 0x1A, 0x32, 0x19, 0x01, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x5A,
	0x00, 0x24, 0x09, 0x3D, 0x03, 0x5A, 0x01, 0xA3, 0x01, 0xC1, 0x01, 0xD4, 0x01, 0xE4, 0x02, 0x07,
	0x00, 0x00, 0x01, 0x1E, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x17, 0x16, 0x36, 0x33, 0x16,
	0x36, 0x17, 0x1E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x0E, 0x01, 0x27, 0x0E, 0x01, 0x07, 0x06, 0x26,
	0x15, 0x14, 0x06, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x16, 0x15,
	0x16, 0x06, 0x15, 0x14, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x06, 0x26, 0x27, 0x2E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x34, 0x36, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x23, 0x26, 0x06,
	0x07, 0x06, 0x26, 0x23, 0x3E, 0x01, 0x35, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x23, 0x1E, 0x01, 0x17,
	0x1E, 0x01, 0x07, 0x30, 0x07, 0x30, 0x07, 0x06, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17,
	0x16, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E,
	0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x07, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x17,
	0x1E, 0x01, 0x33, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06,
	0x16, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01,
	0x37, 0x36, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07,
	0x0E, 0x03, 0x07, 0x0E, 0x01, 0x35, 0x34, 0x36, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x33, 0x36,
	0x16, 0x37, 0x36, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x17,
	0x32, 0x36, 0x17, 0x32, 0x16, 0x17, 0x16, 0x36, 0x33, 0x32, 0x16, 0x15, 0x1C, 0x01, 0x15, 0x14,
	0x36, 0x35, 0x34, 0x26, 0x37, 0x36, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x26, 0x37, 0x36, 0x16,
	0x15, 0x14, 0x06, 0x33, 0x32, 0x16, 0x35, 0x34, 0x26, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x06, 0x15,
	0x14, 0x36, 0x33, 0x32, 0x26, 0x37, 0x36, 0x16, 0x33, 0x32, 0x36, 0x15, 0x1C, 0x01, 0x33, 0x32,
	0x16, 0x37, 0x36, 0x26, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x06, 0x15, 0x14, 0x16, 0x35, 0x3C, 0x01,
	0x33, 0x3A, 0x01, 0x33, 0x32, 0x06, 0x17, 0x16, 0x36, 0x33, 0x32, 0x34, 0x35, 0x34, 0x16, 0x33,
	0x32, 0x36, 0x17, 0x16, 0x06, 0x33, 0x32, 0x16, 0x37, 0x36, 0x26, 0x33, 0x32, 0x36, 0x14, 0x16,
	0x33, 0x32, 0x34, 0x35, 0x34, 0x36, 0x17, 0x16, 0x06, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x06, 0x15,
	0x14, 0x32, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x34, 0x36, 0x37, 0x3E, 0x01, 0x33, 0x32, 0x36, 0x37, 0x32, 0x16,
	0x17, 0x1E, 0x01, 0x17, 0x05, 0x2A, 0x03, 0x23, 0x2A, 0x01, 0x23, 0x32, 0x06, 0x33, 0x3A, 0x01,
	0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x26, 0x35,
	0x01, 0x14, 0x36, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x37, 0x36, 0x26, 0x27, 0x26, 0x06, 0x23,
	0x22, 0x26, 0x15, 0x25, 0x36, 0x26, 0x23, 0x22, 0x26, 0x07, 0x0E, 0x01, 0x17, 0x1E, 0x01, 0x33,
	0x32, 0x16, 0x37, 0x25, 0x2E, 0x01, 0x27, 0x16, 0x17, 0x16, 0x17, 0x16, 0x06, 0x17, 0x1E, 0x01,
	0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27,
	0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x08, 0xAF, 0x0C, 0x0E, 0x09, 0x01, 0x01, 0x25, 0x05, 0x09,
	0x26, 0x03, 0x04, 0x09, 0x0A, 0x08, 0x1B, 0x0C, 0x0E, 0x14, 0x0F, 0x02, 0x04, 0x09, 0x08, 0x07,
	0x03, 0x06, 0x05, 0x19, 0x06, 0x06, 0x19, 0x05, 0x07, 0x0E, 0x09, 0x12, 0x05, 0x02, 0x02, 0x04,
	0x02, 0x02, 0x05, 0x02, 0x03, 0x04, 0x0A, 0x14, 0x31, 0x03, 0x03, 0x04, 0x01, 0x03, 0x05, 0x03,
	0x0B, 0x04, 0x0F, 0x14, 0x13, 0x06, 0x0F, 0x07, 0x08, 0x10, 0x09, 0x11, 0x26, 0x12, 0x01, 0x02,
	0x0D, 0x19, 0x0E, 0x0D, 0x1E, 0x0E, 0x04, 0x07, 0x03, 0x01, 0x07, 0x02, 0x07, 0x09, 0x05, 0x03,
	0x01, 0x09, 0x12, 0x08, 0x08, 0x11, 0x09, 0x02, 0x0C, 0x09, 0x08, 0x10, 0x08, 0x11, 0x23, 0x11,
	0x05, 0x14, 0x01, 0x02, 0x03, 0x02, 0x05, 0x0B, 0x05, 0x08, 0x11, 0x07, 0x02, 0x04, 0x02, 0x03,
	0x03, 0x0B, 0x13, 0x26, 0x12, 0x10, 0x0F, 0x0F, 0x13, 0x27, 0x14, 0x19, 0x35, 0x17, 0x06, 0x0D,
	0x06, 0x08, 0x0F, 0x06, 0x03, 0x12, 0x03, 0x02, 0x07, 0x04, 0x03, 0x07, 0x03, 0x02, 0x07, 0x02,
	0x06, 0x0B, 0x06, 0x09, 0x11, 0x03, 0x02, 0x05, 0x06, 0x06, 0x18, 0x06, 0x11, 0x20, 0x10, 0x05,
	0x3B, 0x02, 0x05, 0x12, 0x08, 0x14, 0x29, 0x15, 0x08, 0x13, 0x0B, 0x0F, 0x30, 0x13, 0x23, 0x4C,
	0x23, 0x17, 0x2D, 0x15, 0x31, 0x61, 0x31, 0x29, 0x52, 0x52, 0x52, 0x29, 0x11, 0x5A, 0x03, 0x04,
	0x05, 0x02, 0x03, 0x02, 0x2B, 0x15, 0x14, 0x28, 0x14, 0x50, 0x9F, 0x50, 0x27, 0x4E, 0x27, 0x0D,
	0x1F, 0x0D, 0x13, 0x20, 0x0E, 0x10, 0x22, 0x13, 0x08, 0x0F, 0x08, 0x08, 0x11, 0x06, 0x0B, 0x18,
	0x0F, 0x09, 0x11, 0x09, 0x06, 0x0C, 0x06, 0x03, 0x07, 0x03, 0x04, 0x07, 0x04, 0x03, 0x0B, 0x03,
	0x0A, 0x09, 0x05, 0x02, 0x02, 0x03, 0x1F, 0x05, 0x05, 0x0A, 0x05, 0x04, 0x04, 0x02, 0x02, 0x1E,
	0x01, 0x05, 0x02, 0x10, 0x01, 0x04, 0x06, 0x0D, 0x06, 0x04, 0x01, 0x11, 0x03, 0x03, 0x04, 0x02,
	0x01, 0x0F, 0x02, 0x02, 0x0B, 0x07, 0x02, 0x10, 0x01, 0x01, 0x02, 0x02, 0x06, 0x0B, 0x06, 0x07,
	0x01, 0x1A, 0x06, 0x06, 0x0C, 0x07, 0x02, 0x03, 0x01, 0x02, 0x0F, 0x02, 0x07, 0x08, 0x06, 0x02,
	0x0E, 0x02, 0x01, 0x03, 0x03, 0x02, 0x0F, 0x02, 0x02, 0x05, 0x05, 0x07, 0x1A, 0x01, 0x08, 0x09,
	0x1E, 0x02, 0x01, 0x03, 0x02, 0x07, 0x0D, 0x06, 0x09, 0x03, 0x08, 0x02, 0x10, 0x22, 0x10, 0x37,
	0x6E, 0x38, 0x1C, 0x39, 0x1D, 0x04, 0x0A, 0x04, 0x0A, 0x15, 0x07, 0x03, 0x0C, 0x01, 0x01, 0x01,
	0x03, 0x0E, 0x0E, 0x05, 0x0C, 0x05, 0x02, 0x0E, 0x02, 0x09, 0x0A, 0x02, 0xFD, 0xAE, 0x2B, 0x56,
	0x55, 0x56, 0x2B, 0x20, 0x3F, 0x20, 0x01, 0x03, 0x03, 0x04, 0x0A, 0x03, 0x12, 0x25, 0x12, 0x3F,
	0x7E, 0x3F, 0x18, 0x30, 0x18, 0x06, 0x0D, 0x06, 0x07, 0x01, 0xFE, 0x7C, 0x55, 0x0F, 0x0B, 0x15,
	0x0B, 0x0D, 0x0D, 0x05, 0x07, 0x1B, 0x0B, 0x0A, 0x17, 0x0A, 0x16, 0x4E, 0xFD, 0xA3, 0x07, 0x07,
	0x16, 0x0D, 0x1F, 0x0D, 0x0C, 0x0B, 0x07, 0x06, 0x0F, 0x08, 0x0E, 0x29, 0x0B, 0xFE, 0x5A, 0x07,
	0x0E, 0x07, 0x01, 0x03, 0x03, 0x01, 0x01, 0x02, 0x05, 0x0C, 0x1B, 0x0E, 0x11, 0x25, 0x11, 0x11,
	0x23, 0x12, 0x12, 0x18, 0x04, 0x02, 0x04, 0x03, 0x05, 0x03, 0x0F, 0x12, 0x23, 0x12, 0x1C, 0x38,
	0x1D, 0x03, 0x1B, 0x12, 0x38, 0x15, 0x07, 0x0E, 0x07, 0x04, 0x0F, 0x04, 0x02, 0x02, 0x01, 0x03,
	0x0A, 0x0C, 0x1D, 0x0B, 0x09, 0x05, 0x02, 0x06, 0x04, 0x0C, 0x0A, 0x08, 0x08, 0x02, 0x0E, 0x07,
	0x11, 0x02, 0x03, 0x02, 0x01, 0x01, 0x09, 0x03, 0x04, 0x08, 0x02, 0x07, 0x2B, 0x0E, 0x27, 0x4D,
	0x27, 0x12, 0x24, 0x12, 0x07, 0x0F, 0x07, 0x0A, 0x08, 0x03, 0x06, 0x1A, 0x12, 0x1B, 0x12, 0x28,
	0x52, 0x28, 0x06, 0x37, 0x02, 0x06, 0x1D, 0x03, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x03, 0x07,
	0x10, 0x08, 0x07, 0x0F, 0x06, 0x05, 0x02, 0x11, 0x22, 0x11, 0x05, 0x1F, 0x04, 0x03, 0x02, 0x03,
	0x0A, 0x05, 0x28, 0x4E, 0x27, 0x25, 0x4A, 0x25, 0x0B, 0x01, 0x01, 0x01, 0x03, 0x01, 0x02, 0x03,
	0x02, 0x01, 0x05, 0x06, 0x08, 0x0D, 0x08, 0x17, 0x2E, 0x17, 0x23, 0x44, 0x22, 0x0A, 0x12, 0x09,
	0x0A, 0x11, 0x06, 0x05, 0x26, 0x03, 0x04, 0x03, 0x02, 0x01, 0x02, 0x09, 0x02, 0x04, 0x03, 0x05,
	0x0B, 0x09, 0x05, 0x1A, 0x08, 0x04, 0x12, 0x03, 0x08, 0x02, 0x01, 0x04, 0x04, 0x09, 0x12, 0x09,
	0x0E, 0x24, 0x11, 0x08, 0x16, 0x07, 0x05, 0x02, 0x03, 0x08, 0x12, 0x0A, 0x03, 0x20, 0x0A, 0x11,
	0x1F, 0x0F, 0x25, 0x48, 0x24, 0x0D, 0x31, 0x08, 0x0C, 0x10, 0x04, 0x06, 0x09, 0x05, 0x03, 0x12,
	0x08, 0x11, 0x22, 0x12, 0x0E, 0x1D, 0x1D, 0x1D, 0x0F, 0x06, 0x02, 0x1A, 0x25, 0x50, 0x25, 0x26,
	0x4D, 0x27, 0x1B, 0x08, 0x01, 0x01, 0x01, 0x01, 0x01, 0x0B, 0x03, 0x05, 0x0C, 0x0C, 0x0B, 0x0B,
	0x04, 0x02, 0x03, 0x02, 0x03, 0x14, 0x05, 0x0B, 0x20, 0x02, 0x02, 0x02, 0x01, 0x01, 0x02, 0x01,
	0x03, 0x01, 0x04, 0x02, 0x02, 0x01, 0x08, 0x0A, 0x0B, 0x16, 0x0B, 0x02, 0x04, 0x04, 0x02, 0x13,
	0x02, 0x03, 0x03, 0x0D, 0x02, 0x02, 0x03, 0x01, 0x04, 0x09, 0x01, 0x02, 0x04, 0x0A, 0x0A, 0x04,
	0x02, 0x01, 0x0D, 0x02, 0x01, 0x01, 0x02, 0x04, 0x07, 0x06, 0x02, 0x02, 0x01, 0x0E, 0x07, 0x07,
	0x01, 0x03, 0x08, 0x06, 0x04, 0x0E, 0x01, 0x02, 0x02, 0x03, 0x06, 0x07, 0x01, 0x02, 0x02, 0x02,
	0x0D, 0x02, 0x02, 0x02, 0x0D, 0x02, 0x0F, 0x02, 0x04, 0x09, 0x01, 0x03, 0x02, 0x02, 0x0D, 0x16,
	0x07, 0x01, 0x01, 0x01, 0x04, 0x18, 0x08, 0x03, 0x0A, 0x04, 0x06, 0x0D, 0x05, 0x0D, 0x13, 0x04,
	0x02, 0x0C, 0x02, 0x0A, 0x1B, 0x0C, 0x27, 0x0D, 0x06, 0x07, 0xFE, 0x92, 0x1C, 0x02, 0x0E, 0x0B,
	0x0F, 0x12, 0x02, 0x01, 0x01, 0x01, 0x23, 0x88, 0x10, 0x1D, 0x02, 0x03, 0x03, 0x1B, 0x09, 0x08,
	0x05, 0x02, 0x0A, 0x46, 0x01, 0x01, 0x01, 0x26, 0x25, 0x24, 0x27, 0x06, 0x19, 0x04, 0x08, 0x05,
	0x03, 0x03, 0x0E, 0x05, 0x06, 0x0F, 0x08, 0x0A, 0x13, 0x18, 0x09, 0x11, 0x08, 0x0E, 0x0B, 0x02,
	0x03, 0x0A, 0x04, 0x08, 0x0B, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x5D, 0x00, 0x3F, 0x0A, 0x2D,
	0x03, 0x44, 0x01, 0x27, 0x01, 0x4A, 0x01, 0x75, 0x00, 0x00, 0x01, 0x1E, 0x01, 0x27, 0x26, 0x16,
	0x17, 0x26, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x37, 0x3E, 0x01, 0x27, 0x26, 0x36, 0x37,
	0x36, 0x26, 0x27, 0x26, 0x06, 0x07, 0x06, 0x16, 0x07, 0x0E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A,
	0x01, 0x23, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x07, 0x22, 0x06, 0x27, 0x2E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27,
	0x2E, 0x01, 0x23, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x2A,
	0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x06, 0x22, 0x07, 0x0E, 0x01, 0x23, 0x22, 0x06, 0x23, 0x22, 0x26, 0x27,
	0x2A, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x36, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x23, 0x2E,
	0x01, 0x23, 0x22, 0x26, 0x07, 0x06, 0x14, 0x15, 0x14, 0x06, 0x17, 0x1E, 0x01, 0x15, 0x1C, 0x01,
	0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x07, 0x06, 0x16, 0x15, 0x14, 0x16, 0x37, 0x3E, 0x01, 0x37,
	0x3E, 0x02, 0x37, 0x36, 0x37, 0x36, 0x16, 0x17, 0x16, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x17, 0x1E, 0x01, 0x33, 0x32, 0x36, 0x37, 0x36, 0x26, 0x27, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x16, 0x36, 0x33, 0x3A, 0x01, 0x17, 0x1E,
	0x01, 0x37, 0x3E, 0x01, 0x17, 0x16, 0x06, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x34,
	0x37, 0x36, 0x26, 0x37, 0x36, 0x16, 0x17, 0x16, 0x06, 0x37, 0x14, 0x32, 0x37, 0x3E, 0x01, 0x35,
	0x26, 0x36, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x03, 0x33, 0x32, 0x16, 0x37, 0x3E, 0x01, 0x16, 0x06,
	0x33, 0x36, 0x16, 0x37, 0x36, 0x34, 0x35, 0x26, 0x36, 0x35, 0x34, 0x36, 0x27, 0x2E, 0x01, 0x27,
	0x34, 0x36, 0x27, 0x36, 0x16, 0x33, 0x32, 0x16, 0x37, 0x36, 0x26, 0x35, 0x34, 0x36, 0x27, 0x05,
	0x0E, 0x03, 0x07, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x37, 0x06, 0x26, 0x37, 0x3E, 0x01, 0x35, 0x34,
	0x26, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x03, 0x33, 0x0E, 0x01, 0x07, 0x3A, 0x01, 0x23, 0x05, 0x06,
	0x26, 0x27, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x37, 0x36, 0x26, 0x37, 0x36, 0x16,
	0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x27, 0x2E, 0x01, 0x37, 0x36, 0x16, 0x33,
	0x32, 0x36, 0x17, 0x16, 0x06, 0x15, 0x14, 0x16, 0x07, 0x0A, 0x25, 0x01, 0x02, 0x03, 0x03, 0x02,
	0x01, 0x09, 0x2C, 0x0B, 0x0D, 0x1B, 0x0E, 0x0B, 0x11, 0x01, 0x01, 0x01, 0x04, 0x02, 0x04, 0x02,
	0x02, 0x06, 0x04, 0x06, 0x3A, 0x0C, 0x0A, 0x06, 0x01, 0x04, 0x28, 0x15, 0x1E, 0x3A, 0x1D, 0x3A,
	0x74, 0x3A, 0x08, 0x20, 0x05, 0x03, 0x08, 0x04, 0x05, 0x19, 0x07, 0x08, 0x12, 0x06, 0x0A, 0x01,
	0x13, 0x06, 0x0D, 0x08, 0x03, 0x07, 0x03, 0x03, 0x01, 0x04, 0x0C, 0x23, 0x06, 0x02, 0x11, 0x05,
	0x06, 0x11, 0x08, 0x0C, 0x0C, 0x0A, 0x04, 0x0C, 0x03, 0x02, 0x0F, 0x03, 0x04, 0x08, 0x05, 0x0D,
	0x1A, 0x0C, 0x19, 0x32, 0x19, 0x33, 0x65, 0x33, 0x17, 0x34, 0x17, 0x13, 0x1D, 0x0E, 0x0A, 0x15,
	0x0F, 0x12, 0x19, 0x10, 0x07, 0x10, 0x09, 0x0C, 0x17, 0x0C, 0x1B, 0x36, 0x1B, 0x22, 0x44, 0x22,
	0x0D, 0x1B, 0x0D, 0x06, 0x14, 0x04, 0x09, 0x07, 0x08, 0x08, 0x0D, 0x08, 0x16, 0x34, 0x16, 0x37,
	0x6E, 0x37, 0x14, 0x29, 0x0A, 0x04, 0x02, 0x05, 0x07, 0x05, 0x03, 0x05, 0x0E, 0x05, 0x09, 0x17,
	0x0C, 0x88, 0x06, 0x04, 0xB2, 0xDC, 0x61, 0x61, 0x14, 0x1E, 0x46, 0x1B, 0x1A, 0x0A, 0x09, 0x0A,
	0x10, 0x0F, 0x12, 0x11, 0x16, 0x16, 0x43, 0x21, 0x0C, 0x1B, 0x07, 0x06, 0x01, 0x0D, 0x09, 0x06,
	0x04, 0x06, 0x0D, 0x05, 0x05, 0x0C, 0x06, 0x03, 0x09, 0x08, 0x0A, 0x0C, 0x05, 0x09, 0x2B, 0x0B,
	0x13, 0x24, 0x12, 0x10, 0x21, 0x0D, 0x07, 0x11, 0x09, 0x07, 0x08, 0x01, 0x03, 0x1F, 0x07, 0x04,
	0x01, 0x03, 0x04, 0x03, 0x06, 0x08, 0x09, 0x07, 0x11, 0x01, 0x01, 0x01, 0x11, 0x1E, 0x06, 0x06,
	0x04, 0x01, 0x07, 0x0D, 0x31, 0x62, 0x30, 0x32, 0x63, 0x64, 0x63, 0x32, 0x13, 0x28, 0x14, 0x0D,
	0x1B, 0x1E, 0x01, 0x11, 0x0E, 0x20, 0x0E, 0x0C, 0x02, 0x01, 0x05, 0x03, 0x02, 0x05, 0x05, 0x06,
	0x0F, 0x12, 0x28, 0x12, 0x08, 0x2A, 0x05, 0x07, 0x03, 0x05, 0x08, 0xF8, 0xF4, 0x11, 0xB9, 0xD7,
	0xB9, 0x11, 0x02, 0x07, 0x01, 0x02, 0x06, 0x02, 0x0E, 0x03, 0x01, 0x01, 0x02, 0x05, 0x0F, 0x20,
	0x41, 0x21, 0x3E, 0x7D, 0x7D, 0x7D, 0x3E, 0x04, 0x06, 0x05, 0x01, 0x01, 0x02, 0x02, 0x98, 0x09,
	0x41, 0x0F, 0x10, 0x1F, 0x10, 0x0C, 0x1C, 0x04, 0x02, 0x02, 0x03, 0x04, 0x02, 0x08, 0x09, 0x08,
	0x02, 0x03, 0x08, 0x09, 0x07, 0x13, 0x0A, 0x08, 0x11, 0x0B, 0x0A, 0x21, 0x1A, 0x0F, 0x1D, 0x10,
	0x06, 0x2D, 0x04, 0x03, 0x03, 0x04, 0x04, 0x02, 0x82, 0x02, 0x02, 0x04, 0x03, 0x02, 0x01, 0x09,
	0x04, 0x01, 0x0E, 0x13, 0x28, 0x12, 0x0A, 0x15, 0x0A, 0x0B, 0x13, 0x0A, 0x10, 0x09, 0x02, 0x02,
	0x2E, 0x07, 0x1C, 0x01, 0x03, 0x07, 0x05, 0x09, 0x05, 0x05, 0x04, 0x01, 0x01, 0x07, 0x09, 0x1D,
	0x0E, 0x04, 0x09, 0x03, 0x01, 0x02, 0x02, 0x02, 0x06, 0x01, 0x04, 0x0A, 0x0C, 0x06, 0x0B, 0x05,
	0x06, 0x04, 0x01, 0x17, 0x08, 0x03, 0x08, 0x05, 0x03, 0x01, 0x04, 0x03, 0x0E, 0x04, 0x04, 0x04,
	0x23, 0x0D, 0x0A, 0x18, 0x01, 0x01, 0x1B, 0x08, 0x05, 0x01, 0x02, 0x03, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x09, 0x03, 0x04, 0x0D, 0x04, 0x04, 0x0B, 0x03, 0x09, 0x04, 0x01, 0x01, 0x04, 0x17, 0x0A,
	0x19, 0x0B, 0x07, 0x20, 0x05, 0x06, 0x06, 0x0A, 0x0A, 0x13, 0x0A, 0x0C, 0x19, 0x0C, 0x05, 0x1F,
	0x03, 0x07, 0x40, 0x0F, 0x11, 0x24, 0x0B, 0x06, 0x28, 0x03, 0x01, 0x39, 0x45, 0x1F, 0x20, 0x04,
	0x08, 0x04, 0x12, 0x11, 0x3B, 0x17, 0x1B, 0x36, 0x17, 0x1C, 0x46, 0x1C, 0x1D, 0x0E, 0x04, 0x0B,
	0x08, 0x25, 0x04, 0x0A, 0x20, 0x0D, 0x10, 0x20, 0x11, 0x12, 0x23, 0x11, 0x0A, 0x16, 0x06, 0x06,
	0x14, 0x05, 0x09, 0x04, 0x02, 0x02, 0x01, 0x09, 0x05, 0x09, 0x01, 0x01, 0x17, 0x06, 0x0A, 0x06,
	0x08, 0x06, 0x0C, 0x06, 0x07, 0x0F, 0x06, 0x0A, 0x23, 0x08, 0x05, 0x23, 0x04, 0x07, 0x33, 0x0A,
	0x0B, 0x01, 0x01, 0x06, 0x06, 0x0C, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x17, 0x01, 0x05, 0x05,
	0x04, 0x1D, 0x0B, 0x13, 0x27, 0x13, 0x08, 0x13, 0x07, 0x04, 0x0E, 0x01, 0x09, 0x1C, 0x02, 0x05,
	0x02, 0x05, 0x07, 0x09, 0x1B, 0x0B, 0x0A, 0x20, 0x09, 0x9D, 0x05, 0x3B, 0x45, 0x3D, 0x07, 0x03,
	0x02, 0x04, 0x03, 0x05, 0x04, 0x01, 0x21, 0x09, 0x14, 0x26, 0x14, 0x07, 0x40, 0x02, 0x07, 0x01,
	0x7B, 0x13, 0x05, 0x01, 0x03, 0x0E, 0x08, 0x16, 0x08, 0x0A, 0x1A, 0x07, 0x08, 0x07, 0x09, 0x0D,
	0x18, 0x09, 0x08, 0x0C, 0x02, 0x02, 0x0D, 0x08, 0x07, 0x36, 0x02, 0x01, 0x01, 0x04, 0x05, 0x06,
	0x1B, 0x06, 0x09, 0x1B, 0x09, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x61, 0x00, 0x26, 0x05, 0x9E,
	0x03, 0x5A, 0x01, 0x00, 0x01, 0x09, 0x01, 0x16, 0x01, 0x2B, 0x00, 0x00, 0x01, 0x34, 0x06, 0x23,
	0x22, 0x06, 0x27, 0x2E, 0x01, 0x27, 0x36, 0x26, 0x35, 0x34, 0x36, 0x23, 0x36, 0x26, 0x27, 0x26,
	0x06, 0x27, 0x2E, 0x01, 0x23, 0x26, 0x06, 0x23, 0x2A, 0x03, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x06,
	0x07, 0x26, 0x06, 0x22, 0x26, 0x27, 0x26, 0x06, 0x0F, 0x01, 0x06, 0x23, 0x0E, 0x01, 0x07, 0x06,
	0x14, 0x17, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x23, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x16,
	0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x35,
	0x34, 0x36, 0x37, 0x06, 0x16, 0x17, 0x16, 0x36, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x17, 0x1E,
	0x01, 0x17, 0x16, 0x36, 0x33, 0x32, 0x36, 0x37, 0x32, 0x16, 0x37, 0x3E, 0x01, 0x17, 0x16, 0x06,
	0x17, 0x16, 0x06, 0x15, 0x14, 0x06, 0x07, 0x0E, 0x01, 0x15, 0x14, 0x16, 0x15, 0x14, 0x16, 0x17,
	0x1E, 0x01, 0x15, 0x14, 0x16, 0x17, 0x1E, 0x01, 0x15, 0x14, 0x16, 0x15, 0x14, 0x16, 0x17, 0x1E,
	0x01, 0x33, 0x32, 0x16, 0x33, 0x32, 0x36, 0x37, 0x36, 0x16, 0x27, 0x26, 0x36, 0x27, 0x2E, 0x01,
	0x27, 0x26, 0x34, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x37,
	0x36, 0x26, 0x35, 0x34, 0x36, 0x35, 0x3C, 0x01, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x35, 0x34,
	0x36, 0x35, 0x34, 0x36, 0x27, 0x36, 0x32, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x15, 0x1C, 0x01,
	0x15, 0x14, 0x06, 0x07, 0x06, 0x16, 0x17, 0x1E, 0x01, 0x37, 0x36, 0x26, 0x35, 0x3C, 0x01, 0x35,
	0x34, 0x36, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x35, 0x34, 0x2F, 0x01, 0x3E,
	0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x37, 0x36, 0x26, 0x35, 0x05, 0x3C, 0x01, 0x35, 0x3C,
	0x01, 0x35, 0x16, 0x14, 0x05, 0x2E, 0x01, 0x37, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x22, 0x26,
	0x27, 0x37, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x22, 0x26, 0x27, 0x2E, 0x01, 0x35, 0x36, 0x16,
	0x33, 0x32, 0x36, 0x07, 0x16, 0x06, 0x05, 0x98, 0x19, 0x07, 0x0D, 0x4F, 0x08, 0x03, 0x06, 0x03,
	0x03, 0x08, 0x01, 0x0C, 0x05, 0x0D, 0x09, 0x0E, 0x1F, 0x0B, 0x0B, 0x0C, 0x0F, 0x0C, 0x1B, 0x0D,
	0x48, 0x91, 0x90, 0x91, 0x48, 0x31, 0x62, 0x31, 0x13, 0x16, 0x08, 0x05, 0x03, 0x0C, 0x05, 0x06,
	0x0C, 0x0D, 0x07, 0x03, 0x02, 0x01, 0x01, 0x05, 0x01, 0x03, 0x05, 0x0E, 0x1A, 0x0D, 0x09, 0x03,
	0x07, 0x05, 0x18, 0x03, 0x04, 0x05, 0x01, 0x01, 0x01, 0x04, 0x1F, 0x19, 0x16, 0x09, 0x05, 0x08,
	0x05, 0x03, 0x0F, 0x08, 0x06, 0x01, 0x0A, 0x04, 0x07, 0x13, 0x08, 0x12, 0x25, 0x12, 0x08, 0x24,
	0x08, 0x03, 0x04, 0x03, 0x05, 0x0E, 0x06, 0x10, 0x20, 0x10, 0x06, 0x0A, 0x04, 0x04, 0x02, 0x04,
	0x02, 0x01, 0x02, 0x07, 0x0D, 0x0E, 0x01, 0x01, 0x01, 0x02, 0x02, 0x08, 0x0C, 0x04, 0x09, 0x04,
	0x01, 0x05, 0x07, 0x0A, 0x06, 0x06, 0x13, 0x0F, 0x09, 0x13, 0x0A, 0x0B, 0x12, 0x09, 0x09, 0x33,
	0x06, 0x03, 0x04, 0x04, 0x01, 0x04, 0x02, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x04, 0x02, 0x03,
	0x04, 0x02, 0x04, 0x0F, 0x07, 0x07, 0x0C, 0x02, 0x09, 0x17, 0x2F, 0x17, 0x1A, 0x30, 0x14, 0x04,
	0x04, 0x03, 0x08, 0x04, 0x24, 0x48, 0x24, 0x10, 0x0D, 0x01, 0x02, 0x03, 0x06, 0x25, 0x0D, 0x3D,
	0x06, 0x04, 0x04, 0x0A, 0x07, 0x0B, 0x12, 0x09, 0x02, 0x11, 0x04, 0x09, 0x0A, 0x02, 0x02, 0x02,
	0x14, 0x01, 0x11, 0x20, 0x10, 0x09, 0x1B, 0x05, 0x06, 0x06, 0xFA, 0xD9, 0x03, 0x02, 0x64, 0x01,
	0x01, 0x01, 0x02, 0x04, 0x02, 0x03, 0x06, 0x05, 0x0F, 0x02, 0x04, 0x7C, 0x03, 0x03, 0x03, 0x05,
	0x12, 0x0A, 0x0C, 0x02, 0x06, 0x03, 0x16, 0x01, 0x32, 0x09, 0x07, 0x1F, 0x04, 0x02, 0x07, 0x02,
	0xC3, 0x0B, 0x02, 0x06, 0x0B, 0x01, 0x04, 0x01, 0x08, 0x10, 0x08, 0x06, 0x0D, 0x0C, 0x1A, 0x05,
	0x07, 0x05, 0x08, 0x09, 0x11, 0x01, 0x02, 0x11, 0x10, 0x04, 0x05, 0x02, 0x03, 0x06, 0x07, 0x08,
	0x04, 0x05, 0x03, 0x05, 0x03, 0x06, 0x0D, 0x06, 0x07, 0x01, 0x08, 0x07, 0x08, 0x07, 0x07, 0x06,
	0x0C, 0x06, 0x3B, 0x77, 0x3B, 0x18, 0x1D, 0x16, 0x14, 0x0B, 0x16, 0x0A, 0x08, 0x1C, 0x08, 0x08,
	0x2B, 0x04, 0x05, 0x13, 0x02, 0x04, 0x02, 0x04, 0x04, 0x02, 0x09, 0x02, 0x02, 0x04, 0x02, 0x01,
	0x03, 0x02, 0x02, 0x0A, 0x04, 0x03, 0x0A, 0x01, 0x03, 0x2F, 0x05, 0x0C, 0x1C, 0x0D, 0x0F, 0x1D,
	0x10, 0x0E, 0x1F, 0x0E, 0x06, 0x15, 0x02, 0x03, 0x05, 0x0D, 0x20, 0x38, 0x1E, 0x07, 0x10, 0x07,
	0x08, 0x0D, 0x07, 0x0D, 0x24, 0x0A, 0x0D, 0x02, 0x06, 0x03, 0x02, 0x01, 0x02, 0x0D, 0x06, 0x11,
	0x07, 0x02, 0x01, 0x03, 0x01, 0x04, 0x02, 0x03, 0x05, 0x05, 0x06, 0x0F, 0x07, 0x0F, 0x1C, 0x0F,
	0x18, 0x42, 0x18, 0x1C, 0x3B, 0x1E, 0x10, 0x1D, 0x0F, 0x06, 0x15, 0x02, 0x01, 0x02, 0x07, 0x20,
	0x09, 0x0C, 0x06, 0x07, 0x0F, 0x08, 0x01, 0x01, 0x10, 0x0F, 0x1D, 0x0F, 0x1E, 0x3B, 0x1E, 0x20,
	0x47, 0x0C, 0x05, 0x15, 0x12, 0x0C, 0x23, 0x0C, 0x3C, 0x76, 0x3B, 0x0B, 0x09, 0x03, 0x07, 0x11,
	0x12, 0x04, 0x14, 0x02, 0x07, 0x0E, 0x09, 0x02, 0x07, 0x07, 0x04, 0x05, 0x02, 0x09, 0x09, 0x2A,
	0x0A, 0x2B, 0x09, 0x13, 0x09, 0x03, 0x08, 0x03, 0x0A, 0x1F, 0x67, 0x04, 0x09, 0x04, 0x04, 0x07,
	0x04, 0x03, 0x09, 0x02, 0x02, 0x0A, 0x11, 0x04, 0x0C, 0x04, 0x08, 0x01, 0x08, 0x06, 0x03, 0x21,
	0x03, 0x08, 0x03, 0x03, 0x0D, 0x06, 0x08, 0x00, 0x00, 0x04, 0x00, 0x4F, 0x00, 0x3E, 0x07, 0xD5,
	0x03, 0x42, 0x01, 0x08, 0x01, 0x15, 0x01, 0x28, 0x01, 0x2B, 0x00, 0x00, 0x01, 0x3E, 0x01, 0x27,
	0x36, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x03, 0x33, 0x32, 0x36, 0x17, 0x1E, 0x01, 0x17, 0x16,
	0x36, 0x33, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x15, 0x14, 0x06, 0x15, 0x16, 0x06, 0x27, 0x2A, 0x01,
	0x23, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x17, 0x14, 0x06, 0x23, 0x2A, 0x01, 0x27, 0x2E, 0x01, 0x27,
	0x26, 0x06, 0x15, 0x14, 0x06, 0x15, 0x14, 0x16, 0x15, 0x14, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E,
	0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x26, 0x34, 0x35, 0x34, 0x26, 0x27, 0x2E, 0x01, 0x35, 0x2E, 0x01, 0x35, 0x34, 0x26, 0x35,
	0x34, 0x26, 0x27, 0x2E, 0x01, 0x35, 0x34, 0x26, 0x27, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x07, 0x06, 0x26, 0x27, 0x0E, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x06, 0x23, 0x22, 0x16,
	0x15, 0x06, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x30, 0x37, 0x34, 0x27, 0x34, 0x36, 0x27, 0x26, 0x06,
	0x23, 0x06, 0x26, 0x27, 0x26, 0x36, 0x35, 0x34, 0x36, 0x37, 0x36, 0x37, 0x36, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x27, 0x2E, 0x01, 0x23, 0x22, 0x06, 0x23,
	0x06, 0x26, 0x07, 0x06, 0x26, 0x35, 0x3C, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x06, 0x27, 0x26,
	0x06, 0x27, 0x22, 0x26, 0x33, 0x26, 0x06, 0x23, 0x2A, 0x03, 0x23, 0x22, 0x16, 0x15, 0x14, 0x06,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x22, 0x07, 0x3C, 0x01, 0x35, 0x3C, 0x01, 0x35,
	0x3C, 0x01, 0x35, 0x34, 0x16, 0x33, 0x1E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x37, 0x3A,
	0x01, 0x37, 0x32, 0x36, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x26, 0x37, 0x36, 0x16, 0x35, 0x34, 0x36,
	0x37, 0x01, 0x2E, 0x01, 0x27, 0x0E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x2E, 0x01, 0x27, 0x37, 0x2E,
	0x01, 0x07, 0x0E, 0x01, 0x07, 0x14, 0x16, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01,
	0x37, 0x01, 0x26, 0x16, 0x03, 0x94, 0x02, 0x02, 0x01, 0x18, 0x15, 0x15, 0x2D, 0x5B, 0x2D, 0x45,
	0x8B, 0x8B, 0x8B, 0x46, 0x0B, 0x44, 0x07, 0x09, 0x09, 0x08, 0x09, 0x32, 0x0F, 0x14, 0x2C, 0x13,
	0x0B, 0x03, 0x01, 0x01, 0x02, 0x11, 0x18, 0x30, 0x18, 0x0B, 0x15, 0x0B, 0x02, 0x01, 0x01, 0x03,
	0x11, 0x0F, 0x0A, 0x08, 0x08, 0x10, 0x09, 0x03, 0x32, 0x02, 0x07, 0x0E, 0x05, 0x05, 0x09, 0x03,
	0x05, 0x16, 0x19, 0x0D, 0x23, 0x0F, 0x09, 0x15, 0x09, 0x07, 0x19, 0x05, 0x0F, 0x08, 0x05, 0x03,
	0x09, 0x03, 0x01, 0x06, 0x02, 0x02, 0x04, 0x02, 0x02, 0x04, 0x02, 0x01, 0x01, 0x02, 0x0E, 0x15,
	0x1C, 0x1B, 0x16, 0x09, 0x0E, 0x0A, 0x0D, 0x17, 0x0F, 0x22, 0x3C, 0x19, 0x20, 0x0D, 0x03, 0x05,
	0x04, 0x02, 0x05, 0x3F, 0x0D, 0x1C, 0x38, 0x1C, 0x01, 0x01, 0x01, 0x01, 0x02, 0x10, 0x04, 0x0E,
	0x14, 0x05, 0x04, 0x01, 0x03, 0x09, 0x01, 0x03, 0x04, 0x02, 0x01, 0x01, 0x01, 0x04, 0x0B, 0x03,
	0x07, 0x0E, 0x01, 0x01, 0x04, 0x04, 0x03, 0x0E, 0x06, 0x33, 0x66, 0x34, 0x17, 0x3E, 0x12, 0x0A,
	0x13, 0x16, 0x06, 0x01, 0x06, 0x02, 0x01, 0x04, 0x01, 0x03, 0x09, 0x03, 0x3E, 0x7B, 0x79, 0x77,
	0x3B, 0x10, 0x04, 0x07, 0x02, 0x03, 0x06, 0x02, 0x01, 0x06, 0x02, 0x04, 0x14, 0x0F, 0x0D, 0x01,
	0x1F, 0x47, 0x22, 0x48, 0x90, 0x48, 0x29, 0x55, 0x2A, 0x0D, 0x1B, 0x0D, 0x07, 0x01, 0x06, 0x06,
	0x09, 0x97, 0x06, 0x04, 0x01, 0xD6, 0x0D, 0x10, 0x02, 0x05, 0x1D, 0x06, 0x0E, 0x24, 0x14, 0x03,
	0x05, 0x03, 0x7A, 0x11, 0x2D, 0x18, 0x13, 0x0C, 0x01, 0x08, 0x07, 0x05, 0x07, 0x09, 0x0A, 0x11,
	0x08, 0x10, 0x14, 0x0B, 0xFE, 0x1C, 0x01, 0x02, 0x03, 0x35, 0x02, 0x04, 0x04, 0x03, 0x24, 0x06,
	0x0D, 0x11, 0x29, 0x12, 0x13, 0x0A, 0x04, 0x02, 0x01, 0x07, 0x0B, 0x0F, 0x36, 0x0F, 0x0B, 0x07,
	0x01, 0x19, 0x30, 0x18, 0x03, 0x0A, 0x03, 0x11, 0x08, 0x0E, 0x0F, 0x1E, 0x0F, 0x06, 0x03, 0x0B,
	0x11, 0x22, 0x11, 0x12, 0x21, 0x11, 0x10, 0x23, 0x0F, 0x0F, 0x20, 0x10, 0x16, 0x62, 0x0D, 0x08,
	0x05, 0x02, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x06, 0x0A, 0x0D, 0x09, 0x11, 0x09, 0x03, 0x08,
	0x04, 0x06, 0x05, 0x05, 0x07, 0x14, 0x07, 0x10, 0x20, 0x11, 0x07, 0x11, 0x08, 0x08, 0x10, 0x08,
	0x12, 0x21, 0x12, 0x13, 0x25, 0x04, 0x06, 0x30, 0x0A, 0x05, 0x0E, 0x05, 0x07, 0x0B, 0x02, 0x04,
	0x01, 0x18, 0x3B, 0x84, 0x46, 0x09, 0x11, 0x09, 0x04, 0x09, 0x0E, 0x03, 0x0A, 0x04, 0x06, 0x07,
	0x01, 0x01, 0x06, 0x02, 0x02, 0x01, 0x01, 0x01, 0x0F, 0x0F, 0x25, 0x10, 0x21, 0x43, 0x1E, 0x04,
	0x05, 0x04, 0x03, 0x04, 0x09, 0x04, 0x09, 0x10, 0x08, 0x11, 0x21, 0x12, 0x0A, 0x0E, 0x09, 0x05,
	0x1A, 0x01, 0x01, 0x06, 0x0A, 0x05, 0x12, 0x08, 0x11, 0x20, 0x10, 0x03, 0x08, 0x04, 0x08, 0x06,
	0x06, 0x01, 0x01, 0x04, 0x07, 0x01, 0x01, 0x1C, 0x0A, 0x16, 0x2D, 0x16, 0x20, 0x3F, 0x1F, 0x07,
	0x0E, 0x06, 0x10, 0x02, 0x36, 0x6C, 0x37, 0x1F, 0x3D, 0x1F, 0x06, 0x0C, 0x06, 0x05, 0x07, 0x05,
	0x01, 0x01, 0x01, 0x03, 0x07, 0x08, 0x11, 0x09, 0x0D, 0x2C, 0x0B, 0x16, 0x11, 0x08, 0x0A, 0x03,
	0x08, 0xFE, 0x7A, 0x0D, 0x21, 0x12, 0x04, 0x1F, 0x05, 0x0E, 0x12, 0x02, 0x03, 0x05, 0x02, 0x35,
	0x11, 0x17, 0x04, 0x03, 0x04, 0x14, 0x0E, 0x1D, 0x0D, 0x07, 0x09, 0x02, 0x01, 0x07, 0x04, 0x0A,
	0x19, 0x0E, 0xFE, 0x92, 0x05, 0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x62, 0x00, 0x3F, 0x07, 0xDF,
	0x03, 0x48, 0x00, 0x1E, 0x00, 0x3C, 0x00, 0x5A, 0x00, 0x73, 0x01, 0x5E, 0x00, 0x00, 0x01, 0x06,
	0x16, 0x17, 0x1C, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x15, 0x14, 0x06, 0x17, 0x1E, 0x01,
	0x37, 0x3E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x05, 0x34, 0x26,
	0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07,
	0x06, 0x16, 0x17, 0x14, 0x16, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x01, 0x36, 0x26, 0x23, 0x2A,
	0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x27, 0x1C, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01,
	0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x37, 0x2A, 0x01, 0x15, 0x14, 0x06, 0x17,
	0x32, 0x16, 0x07, 0x0E, 0x01, 0x15, 0x1E, 0x01, 0x17, 0x16, 0x32, 0x35, 0x3C, 0x01, 0x35, 0x34,
	0x36, 0x27, 0x05, 0x1E, 0x01, 0x07, 0x06, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22,
	0x26, 0x23, 0x22, 0x06, 0x07, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x1C, 0x01,
	0x07, 0x0E, 0x01, 0x23, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x07, 0x22, 0x06, 0x15,
	0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x22, 0x06, 0x07, 0x22, 0x06, 0x27, 0x2E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x27, 0x26, 0x06, 0x27, 0x22, 0x06,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x35,
	0x3C, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x22, 0x26, 0x07, 0x0E,
	0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x03, 0x23, 0x22, 0x36, 0x35, 0x3C, 0x01, 0x27, 0x34, 0x26,
	0x27, 0x26, 0x36, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x03, 0x33, 0x32, 0x16, 0x37, 0x3E, 0x01, 0x33,
	0x3A, 0x03, 0x33, 0x32, 0x26, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x34, 0x37, 0x3E,
	0x01, 0x17, 0x1E, 0x01, 0x15, 0x14, 0x16, 0x07, 0x0E, 0x01, 0x15, 0x14, 0x06, 0x33, 0x3A, 0x01,
	0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x35, 0x34, 0x06, 0x27,
	0x26, 0x36, 0x35, 0x34, 0x36, 0x37, 0x32, 0x36, 0x17, 0x16, 0x14, 0x15, 0x14, 0x16, 0x17, 0x1E,
	0x01, 0x33, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x06,
	0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x05, 0x5E, 0x08, 0x01, 0x01, 0x01, 0x07, 0x0F, 0x07,
	0x02, 0x0E, 0x01, 0x03, 0x13, 0x1A, 0x17, 0x1A, 0x12, 0x0E, 0x09, 0x1C, 0x0B, 0x07, 0x08, 0x0E,
	0x10, 0x23, 0x0C, 0xFE, 0xF4, 0x0D, 0x11, 0x16, 0x2B, 0x16, 0x0B, 0x15, 0x0B, 0x03, 0x0B, 0x04,
	0x06, 0x0E, 0x04, 0x06, 0x0F, 0x04, 0x06, 0x04, 0x01, 0x0C, 0x10, 0x18, 0x28, 0x19, 0x1B, 0x54,
	0x02, 0x26, 0x06, 0x17, 0x04, 0x0C, 0x19, 0x0D, 0x1A, 0x35, 0x1B, 0x27, 0x4F, 0x27, 0x01, 0x06,
	0x0E, 0x06, 0x1E, 0x3C, 0x1E, 0x20, 0x42, 0x20, 0x0A, 0x16, 0x0B, 0x09, 0x01, 0x2C, 0x0A, 0x08,
	0x01, 0x06, 0x05, 0x0A, 0x02, 0x03, 0x07, 0x01, 0x01, 0x01, 0x01, 0x0D, 0x05, 0x0C, 0x01, 0x2C,
	0x0D, 0x06, 0x16, 0x0D, 0x1F, 0x0E, 0x16, 0x29, 0x16, 0x05, 0x0A, 0x05, 0x03, 0x02, 0x02, 0x02,
	0x07, 0x02, 0x07, 0x10, 0x03, 0x03, 0x04, 0x02, 0x02, 0x04, 0x02, 0x03, 0x03, 0x0D, 0x09, 0x11,
	0x2E, 0x05, 0x03, 0x01, 0x05, 0x02, 0x3C, 0x08, 0x06, 0x0E, 0x01, 0x03, 0x01, 0x03, 0x1F, 0x1C,
	0x19, 0x40, 0x20, 0x0D, 0x1A, 0x0E, 0x06, 0x10, 0x07, 0x0A, 0x10, 0x01, 0x01, 0x05, 0x02, 0x03,
	0x06, 0x03, 0x01, 0x05, 0x02, 0x07, 0x32, 0x10, 0x0B, 0x0A, 0x06, 0x05, 0x11, 0x07, 0x2F, 0x72,
	0x3D, 0x25, 0x4C, 0x25, 0x0C, 0x18, 0x0C, 0x0B, 0x01, 0x07, 0x0A, 0x14, 0x0A, 0x18, 0x31, 0x18,
	0x04, 0x09, 0x04, 0x03, 0x21, 0x01, 0x05, 0x11, 0x0C, 0x0F, 0x1D, 0x0F, 0x2F, 0x5E, 0x5E, 0x5E,
	0x2F, 0x20, 0x01, 0x01, 0x02, 0x02, 0x01, 0x0E, 0x0C, 0x0F, 0x1F, 0x0F, 0x34, 0x69, 0x68, 0x68,
	0x34, 0x17, 0x31, 0x17, 0x1D, 0x37, 0x1E, 0x2D, 0x5A, 0x5A, 0x5A, 0x2D, 0x05, 0x02, 0x02, 0x08,
	0x0F, 0x07, 0x04, 0x0A, 0x0B, 0x0C, 0x03, 0x04, 0x20, 0x09, 0x04, 0x01, 0x01, 0x01, 0x01, 0x05,
	0x02, 0x04, 0x0F, 0x1E, 0x10, 0x35, 0x6A, 0x35, 0x0D, 0x1A, 0x0D, 0x05, 0x12, 0x05, 0x0B, 0x0E,
	0x05, 0x02, 0x01, 0x01, 0x0A, 0x09, 0x06, 0x18, 0x01, 0x01, 0x01, 0x03, 0x03, 0x08, 0x0B, 0x08,
	0x09, 0x06, 0x09, 0x12, 0x08, 0x0D, 0x1B, 0x02, 0x05, 0x0C, 0x19, 0x0C, 0x1B, 0x34, 0x1B, 0x01,
	0x60, 0x0C, 0x24, 0x0F, 0x01, 0x0E, 0x01, 0x02, 0x03, 0x12, 0x01, 0x06, 0x15, 0x08, 0x0A, 0x2C,
	0x19, 0x10, 0x12, 0x0E, 0x0A, 0x07, 0x02, 0x02, 0x06, 0x0E, 0x23, 0x0E, 0x2A, 0x02, 0x02, 0x02,
	0x11, 0x04, 0x06, 0x0C, 0x06, 0x08, 0x18, 0x08, 0x13, 0x21, 0x0A, 0x12, 0x0B, 0x0A, 0x0A, 0x2E,
	0x01, 0x40, 0x09, 0x05, 0x06, 0x02, 0x03, 0x1F, 0x04, 0x1B, 0x0B, 0x05, 0x06, 0x01, 0x07, 0x07,
	0x07, 0x0C, 0x07, 0x0C, 0x17, 0x0B, 0x05, 0x03, 0x0B, 0x15, 0x0A, 0x0B, 0x33, 0x07, 0x79, 0x0B,
	0x47, 0x05, 0x03, 0x02, 0x07, 0x06, 0x02, 0x08, 0x13, 0x0B, 0x08, 0x16, 0x08, 0x13, 0x26, 0x13,
	0x08, 0x15, 0x08, 0x09, 0x02, 0x04, 0x16, 0x12, 0x25, 0x12, 0x0B, 0x02, 0x01, 0x17, 0x05, 0x0C,
	0x18, 0x0D, 0x23, 0x40, 0x16, 0x14, 0x15, 0x02, 0x02, 0x01, 0x02, 0x01, 0x03, 0x03, 0x0C, 0x08,
	0x10, 0x07, 0x0D, 0x19, 0x0D, 0x06, 0x0F, 0x06, 0x11, 0x03, 0x01, 0x05, 0x0A, 0x06, 0x0D, 0x05,
	0x24, 0x42, 0x02, 0x02, 0x03, 0x03, 0x02, 0x02, 0x01, 0x01, 0x0E, 0x0B, 0x08, 0x05, 0x02, 0x04,
	0x08, 0x03, 0x09, 0x13, 0x09, 0x01, 0x05, 0x03, 0x02, 0x09, 0x15, 0x59, 0x14, 0x26, 0x4B, 0x25,
	0x2A, 0x53, 0x29, 0x12, 0x06, 0x03, 0x04, 0x05, 0x04, 0x2E, 0x06, 0x13, 0x26, 0x13, 0x0B, 0x0F,
	0x05, 0x05, 0x1B, 0x0B, 0x0E, 0x15, 0x14, 0x08, 0x14, 0x09, 0x04, 0x09, 0x04, 0x02, 0x04, 0x04,
	0x04, 0x15, 0x0E, 0x03, 0x06, 0x06, 0x0D, 0x0A, 0x05, 0x04, 0x03, 0x0C, 0x04, 0x07, 0x10, 0x01,
	0x04, 0x0A, 0x0A, 0x13, 0x0B, 0x0A, 0x0F, 0x0A, 0x0C, 0x06, 0x01, 0x06, 0x09, 0x13, 0x0A, 0x0D,
	0x1C, 0x14, 0x18, 0x31, 0x18, 0x04, 0x12, 0x00, 0x00, 0x03, 0x00, 0x5D, 0x00, 0x25, 0x0B, 0x9F,
	0x03, 0x5A, 0x01, 0x38, 0x01, 0x48, 0x01, 0x54, 0x00, 0x00, 0x01, 0x32, 0x06, 0x15, 0x14, 0x26,
	0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x22, 0x06, 0x23, 0x2A, 0x01, 0x23,
	0x06, 0x22, 0x23, 0x22, 0x16, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E,
	0x01, 0x27, 0x26, 0x06, 0x07, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x23, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x07, 0x14, 0x22, 0x23, 0x22, 0x06, 0x07, 0x2A, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27,
	0x2E, 0x01, 0x35, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x14, 0x06, 0x07, 0x06, 0x16, 0x17, 0x1E,
	0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07,
	0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x15, 0x14, 0x06, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27,
	0x26, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x0E,
	0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26,
	0x27, 0x26, 0x34, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x33, 0x3A, 0x01, 0x33,
	0x3A, 0x03, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x37, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x17, 0x32, 0x16, 0x17, 0x16, 0x36, 0x37, 0x36, 0x16,
	0x17, 0x1E, 0x01, 0x17, 0x14, 0x36, 0x37, 0x36, 0x16, 0x17, 0x16, 0x36, 0x33, 0x3A, 0x01, 0x33,
	0x3A, 0x01, 0x33, 0x2E, 0x01, 0x27, 0x3A, 0x01, 0x33, 0x32, 0x06, 0x17, 0x16, 0x36, 0x33, 0x3A,
	0x01, 0x33, 0x3A, 0x03, 0x33, 0x3A, 0x01, 0x33, 0x26, 0x34, 0x35, 0x34, 0x26, 0x37, 0x3E, 0x01,
	0x33, 0x3E, 0x01, 0x37, 0x32, 0x06, 0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x06, 0x15,
	0x14, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x36, 0x32, 0x37, 0x3E, 0x01, 0x17, 0x05,
	0x22, 0x06, 0x17, 0x1E, 0x01, 0x33, 0x32, 0x16, 0x37, 0x36, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x25,
	0x1E, 0x01, 0x17, 0x3E, 0x01, 0x37, 0x2A, 0x01, 0x23, 0x1E, 0x01, 0x0B, 0x8F, 0x10, 0x04, 0x08,
	0x06, 0x0D, 0x1C, 0x0E, 0x24, 0x49, 0x25, 0x2A, 0x55, 0x2A, 0x12, 0x23, 0x11, 0x0D, 0x18, 0x0C,
	0x06, 0x0B, 0x06, 0x09, 0x02, 0x03, 0x06, 0x29, 0x10, 0x0B, 0x14, 0x09, 0x03, 0x16, 0x04, 0x0B,
	0x13, 0x0B, 0x28, 0x52, 0x28, 0x0B, 0x02, 0x02, 0x01, 0x06, 0x05, 0x08, 0x02, 0x01, 0x01, 0x02,
	0x01, 0x1A, 0x02, 0x2D, 0x59, 0x2C, 0x29, 0x55, 0x28, 0x0A, 0x15, 0x0A, 0x07, 0x1D, 0x07, 0x0D,
	0x01, 0x1C, 0x37, 0x1B, 0x06, 0x0E, 0x07, 0x04, 0x01, 0x04, 0x06, 0x02, 0x02, 0x08, 0x05, 0x0D,
	0x21, 0x13, 0x0A, 0x13, 0x0E, 0x28, 0x50, 0x26, 0x04, 0x0E, 0x06, 0x05, 0x08, 0x03, 0x08, 0x0E,
	0x05, 0x06, 0x0D, 0x06, 0x16, 0x22, 0x12, 0x08, 0x11, 0x07, 0x05, 0x07, 0x05, 0x0A, 0x20, 0x0C,
	0x16, 0x26, 0x14, 0x06, 0x0A, 0x08, 0x0C, 0x05, 0x07, 0x07, 0x03, 0x04, 0x08, 0x04, 0x05, 0x09,
	0x01, 0x02, 0x04, 0x03, 0x09, 0x0E, 0x1A, 0x0C, 0x14, 0x27, 0x13, 0x09, 0x0A, 0x03, 0x10, 0x1F,
	0x0D, 0x05, 0x0E, 0x0C, 0x06, 0x0C, 0x06, 0x03, 0x1B, 0x05, 0x27, 0x4D, 0x26, 0x2B, 0x57, 0x2B,
	0x42, 0x73, 0x31, 0x1A, 0x35, 0x17, 0x06, 0x0B, 0x07, 0x10, 0x0B, 0x03, 0x05, 0x01, 0x02, 0x03,
	0x02, 0x02, 0x04, 0x03, 0x04, 0x09, 0x2D, 0x1B, 0x37, 0x1B, 0x35, 0x6B, 0x6A, 0x6B, 0x35, 0x0B,
	0x18, 0x0B, 0x05, 0x08, 0x04, 0x0C, 0x08, 0x0D, 0x14, 0x27, 0x14, 0x0B, 0x0F, 0x09, 0x0B, 0x06,
	0x01, 0x03, 0x06, 0x1F, 0x0A, 0x0C, 0x08, 0x0A, 0x0D, 0x0E, 0x0C, 0x09, 0x06, 0x05, 0x04, 0x02,
	0x47, 0x07, 0x11, 0x24, 0x11, 0x0D, 0x1A, 0x0D, 0x36, 0x6D, 0x36, 0x0A, 0x12, 0x0A, 0x01, 0x03,
	0x03, 0x0A, 0x16, 0x0B, 0x10, 0x0C, 0x0A, 0x05, 0x0E, 0x05, 0x27, 0x4E, 0x27, 0x38, 0x6F, 0x71,
	0x70, 0x38, 0x1D, 0x3A, 0x1D, 0x01, 0x06, 0x03, 0x02, 0x0B, 0x06, 0x0B, 0x17, 0x0C, 0x09, 0x02,
	0x0A, 0x1E, 0x04, 0x0E, 0x25, 0x12, 0x4F, 0x9C, 0x4E, 0x17, 0x2F, 0x17, 0x0F, 0x48, 0x0A, 0xF8,
	0xB8, 0x17, 0x07, 0x0B, 0x09, 0x14, 0x0C, 0x0A, 0x49, 0x05, 0x06, 0x04, 0x1D, 0x16, 0x28, 0x15,
	0xFC, 0x5D, 0x05, 0x07, 0x06, 0x3A, 0x7E, 0x40, 0x45, 0x87, 0x44, 0x01, 0x03, 0x02, 0xD5, 0x49,
	0x0B, 0x07, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x06, 0x08, 0x0F, 0x1A, 0x07, 0x05, 0x13, 0x08,
	0x03, 0x04, 0x02, 0x03, 0x05, 0x01, 0x04, 0x04, 0x02, 0x0B, 0x0A, 0x04, 0x04, 0x01, 0x03, 0x09,
	0x09, 0x13, 0x0A, 0x01, 0x01, 0x01, 0x05, 0x02, 0x02, 0x01, 0x01, 0x09, 0x02, 0x03, 0x42, 0x0B,
	0x06, 0x09, 0x06, 0x01, 0x01, 0x01, 0x15, 0x02, 0x0D, 0x25, 0x0D, 0x14, 0x26, 0x13, 0x33, 0x62,
	0x31, 0x19, 0x35, 0x17, 0x0E, 0x29, 0x14, 0x02, 0x08, 0x02, 0x06, 0x0E, 0x07, 0x10, 0x21, 0x10,
	0x14, 0x27, 0x14, 0x43, 0x89, 0x44, 0x04, 0x07, 0x04, 0x03, 0x07, 0x02, 0x06, 0x03, 0x01, 0x02,
	0x0A, 0x0A, 0x03, 0x07, 0x08, 0x04, 0x03, 0x03, 0x18, 0x07, 0x0B, 0x16, 0x0B, 0x10, 0x20, 0x11,
	0x16, 0x2A, 0x16, 0x07, 0x0D, 0x02, 0x04, 0x0C, 0x06, 0x09, 0x15, 0x09, 0x04, 0x12, 0x06, 0x26,
	0x4E, 0x27, 0x0E, 0x26, 0x0D, 0x07, 0x0D, 0x07, 0x04, 0x01, 0x01, 0x02, 0x02, 0x02, 0x04, 0x02,
	0x02, 0x49, 0x28, 0x14, 0x2C, 0x17, 0x06, 0x11, 0x04, 0x08, 0x1A, 0x0C, 0x12, 0x25, 0x11, 0x14,
	0x27, 0x13, 0x14, 0x28, 0x14, 0x1C, 0x4D, 0x01, 0x01, 0x1C, 0x03, 0x05, 0x05, 0x07, 0x04, 0x08,
	0x08, 0x09, 0x13, 0x0D, 0x17, 0x2A, 0x01, 0x0D, 0x08, 0x09, 0x02, 0x01, 0x02, 0x05, 0x0A, 0x08,
	0x14, 0x09, 0x03, 0x06, 0x01, 0x01, 0x08, 0x02, 0x01, 0x01, 0x08, 0x10, 0x06, 0x0C, 0x05, 0x02,
	0x01, 0x05, 0x09, 0x05, 0x05, 0x0F, 0x05, 0x05, 0x1A, 0x01, 0x02, 0x02, 0x0E, 0x08, 0x0D, 0x1A,
	0x0D, 0x04, 0x07, 0x03, 0x01, 0x03, 0x03, 0x04, 0x13, 0x02, 0x0B, 0x07, 0x01, 0x04, 0x02, 0x01,
	0x01, 0x03, 0x03, 0x0F, 0x0F, 0xA2, 0x30, 0x0E, 0x08, 0x01, 0x04, 0x0E, 0x14, 0x29, 0x02, 0x24,
	0x49, 0x24, 0x33, 0x5E, 0x2E, 0x0B, 0x17, 0x00, 0x00, 0x02, 0x00, 0x5A, 0x00, 0x3F, 0x08, 0xA7,
	0x03, 0x40, 0x00, 0xC5, 0x00, 0xDC, 0x00, 0x00, 0x01, 0x17, 0x16, 0x06, 0x17, 0x22, 0x06, 0x23,
	0x06, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x07, 0x27, 0x23, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x07, 0x14, 0x16, 0x07, 0x06, 0x26, 0x27,
	0x2E, 0x01, 0x27, 0x07, 0x06, 0x14, 0x15, 0x0E, 0x01, 0x07, 0x1E, 0x01, 0x1F, 0x01, 0x23, 0x0E,
	0x01, 0x15, 0x17, 0x22, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x34, 0x26, 0x27, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x23, 0x14, 0x16, 0x15, 0x1E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x2E, 0x03, 0x27, 0x0E, 0x01, 0x07,
	0x0E, 0x01, 0x23, 0x0E, 0x01, 0x07, 0x2E, 0x01, 0x2F, 0x01, 0x0E, 0x01, 0x07, 0x2E, 0x01, 0x23,
	0x2E, 0x01, 0x27, 0x2E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x35, 0x33, 0x15, 0x1E,
	0x01, 0x17, 0x3E, 0x01, 0x37, 0x32, 0x1E, 0x02, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x35, 0x36,
	0x37, 0x36, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x03, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x33, 0x36,
	0x16, 0x17, 0x1E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x15, 0x3A, 0x01,
	0x33, 0x32, 0x16, 0x37, 0x3E, 0x01, 0x1F, 0x01, 0x15, 0x25, 0x21, 0x22, 0x06, 0x1D, 0x01, 0x14,
	0x16, 0x33, 0x3A, 0x03, 0x33, 0x32, 0x16, 0x37, 0x36, 0x26, 0x27, 0x2E, 0x01, 0x23, 0x08, 0x9F,
	0x06, 0x02, 0x09, 0x01, 0x18, 0x30, 0x18, 0x14, 0x26, 0x14, 0x22, 0x43, 0x22, 0x18, 0x29, 0x17,
	0x0A, 0x05, 0x04, 0x0C, 0x0D, 0x14, 0x22, 0x15, 0x29, 0x51, 0x29, 0x29, 0x52, 0x29, 0x14, 0x26,
	0x14, 0x01, 0x0D, 0x12, 0x36, 0x15, 0x12, 0x25, 0x11, 0x14, 0x0D, 0x0A, 0x0B, 0x05, 0x01, 0x01,
	0x01, 0x06, 0x06, 0x0D, 0x0A, 0x04, 0x11, 0x25, 0x11, 0x08, 0x0F, 0x07, 0x04, 0x07, 0x03, 0x09,
	0x07, 0x07, 0x03, 0x09, 0x11, 0x0B, 0x25, 0x02, 0x09, 0x09, 0x18, 0x28, 0x17, 0x18, 0x26, 0x0E,
	0x0B, 0x12, 0x1B, 0x04, 0x02, 0x06, 0x01, 0x27, 0x58, 0x30, 0x02, 0x05, 0x04, 0x03, 0x01, 0x1E,
	0x3C, 0x1E, 0x01, 0x03, 0x09, 0x0D, 0x1D, 0x0C, 0x04, 0x07, 0x04, 0x02, 0x32, 0x6A, 0x38, 0x01,
	0x04, 0x02, 0x0F, 0x15, 0x05, 0x02, 0x03, 0x14, 0x09, 0x12, 0x08, 0x05, 0x0C, 0x05, 0xD0, 0x09,
	0x14, 0x0B, 0x14, 0x20, 0x11, 0x29, 0x50, 0x50, 0x51, 0x28, 0x04, 0x07, 0x03, 0x02, 0x09, 0x13,
	0x24, 0x23, 0x1B, 0x22, 0x44, 0x22, 0x2E, 0x5A, 0x5A, 0x5B, 0x2D, 0x2B, 0x55, 0x2B, 0x2A, 0x55,
	0x2B, 0x04, 0x08, 0x04, 0x14, 0x03, 0x02, 0x01, 0x08, 0x01, 0x0F, 0x1C, 0x0E, 0x01, 0x01, 0x16,
	0x2B, 0x16, 0x13, 0x2A, 0x13, 0x27, 0x50, 0x28, 0x08, 0xFD, 0xEE, 0xFD, 0x3F, 0x13, 0x12, 0x13,
	0x12, 0x51, 0xA2, 0xA2, 0xA2, 0x52, 0x0F, 0x38, 0x0B, 0x0E, 0x01, 0x0D, 0x04, 0x0D, 0x09, 0x02,
	0x4A, 0x14, 0x0A, 0x14, 0x0A, 0x05, 0x01, 0x09, 0x11, 0x01, 0x07, 0x16, 0x21, 0x12, 0x07, 0x01,
	0x01, 0x06, 0x16, 0x30, 0x12, 0x0C, 0x07, 0x02, 0x02, 0x05, 0x06, 0x0D, 0x0A, 0x22, 0x0E, 0x04,
	0x16, 0x09, 0x04, 0x0A, 0x04, 0x09, 0x10, 0x1D, 0x15, 0x05, 0x09, 0x03, 0x01, 0x06, 0x03, 0x01,
	0x02, 0x02, 0x04, 0x0D, 0x05, 0x25, 0x52, 0x22, 0x17, 0x23, 0x19, 0x05, 0x0A, 0x05, 0x04, 0x02,
	0x08, 0x08, 0x20, 0x14, 0x12, 0x2C, 0x18, 0x30, 0x18, 0x1D, 0x3C, 0x1D, 0x1C, 0x16, 0x2A, 0x56,
	0x54, 0x55, 0x2A, 0x05, 0x0C, 0x07, 0x07, 0x1B, 0x03, 0x09, 0x01, 0x05, 0x08, 0x04, 0x0A, 0x1A,
	0x0F, 0x03, 0x02, 0x03, 0x2C, 0x5B, 0x2F, 0x20, 0x55, 0x1D, 0x0C, 0x15, 0x0C, 0x08, 0x10, 0x08,
	0x06, 0x06, 0x0D, 0x18, 0x0C, 0x09, 0x17, 0x0E, 0x04, 0x04, 0x01, 0x05, 0x0B, 0x17, 0x0C, 0x09,
	0x19, 0x0A, 0x12, 0x04, 0x03, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03,
	0x01, 0x01, 0x03, 0x01, 0x06, 0x07, 0x16, 0x44, 0x1D, 0x13, 0x27, 0x13, 0x01, 0x06, 0x03, 0x02,
	0x05, 0x02, 0x03, 0x05, 0x0B, 0x02, 0x02, 0x04, 0x05, 0x99, 0x14, 0x13, 0x23, 0x12, 0x13, 0x03,
	0x0E, 0x0B, 0x43, 0x0B, 0x05, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x64, 0x00, 0x21, 0x0A, 0x42,
	0x03, 0x60, 0x00, 0x18, 0x00, 0x2B, 0x01, 0x92, 0x00, 0x00, 0x01, 0x34, 0x26, 0x23, 0x22, 0x16,
	0x17, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x0E, 0x01, 0x17, 0x1E, 0x01, 0x33, 0x32, 0x16, 0x37,
	0x3E, 0x01, 0x37, 0x01, 0x1E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x26, 0x37, 0x34, 0x36, 0x37,
	0x22, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x17, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x07,
	0x06, 0x26, 0x27, 0x26, 0x06, 0x23, 0x22, 0x26, 0x15, 0x14, 0x06, 0x07, 0x06, 0x26, 0x23, 0x2A,
	0x03, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x27, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x35, 0x1C, 0x01,
	0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x07, 0x06, 0x14, 0x17, 0x16, 0x14, 0x17, 0x1E, 0x01, 0x17,
	0x1E, 0x01, 0x07, 0x22, 0x23, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E,
	0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x34, 0x36, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36,
	0x35, 0x0E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x07, 0x0E, 0x01, 0x27,
	0x26, 0x06, 0x07, 0x0E, 0x01, 0x17, 0x1E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x17, 0x16, 0x06, 0x23, 0x0E, 0x01, 0x2E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37,
	0x36, 0x26, 0x27, 0x26, 0x06, 0x27, 0x26, 0x36, 0x37, 0x22, 0x26, 0x27, 0x26, 0x27, 0x35, 0x2A,
	0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x23, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x36, 0x23, 0x22, 0x26, 0x07,
	0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06,
	0x26, 0x27, 0x2E, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x26, 0x37, 0x3E, 0x01,
	0x33, 0x3A, 0x01, 0x33, 0x3A, 0x03, 0x33, 0x3A, 0x01, 0x17, 0x16, 0x32, 0x33, 0x3A, 0x01, 0x33,
	0x3A, 0x01, 0x33, 0x32, 0x26, 0x37, 0x3E, 0x01, 0x33, 0x32, 0x26, 0x37, 0x3E, 0x01, 0x37, 0x32,
	0x33, 0x32, 0x33, 0x32, 0x16, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x27, 0x26, 0x36, 0x17, 0x1E,
	0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x33, 0x32, 0x34, 0x35, 0x34, 0x16, 0x33, 0x3A, 0x01,
	0x15, 0x14, 0x1D, 0x01, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x17, 0x16, 0x36, 0x37,
	0x36, 0x16, 0x33, 0x32, 0x16, 0x37, 0x3E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A,
	0x01, 0x33, 0x32, 0x36, 0x17, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x33, 0x3A, 0x01,
	0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x36, 0x33, 0x32, 0x36, 0x33, 0x3A, 0x01, 0x33,
	0x32, 0x16, 0x15, 0x14, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x05, 0x4D, 0x40, 0x18, 0x0D, 0x0E, 0x02,
	0x07, 0x13, 0x03, 0x07, 0x02, 0x01, 0x12, 0x0F, 0x0C, 0x09, 0x1F, 0x11, 0x0E, 0x1D, 0x0E, 0x14,
	0x08, 0x03, 0x03, 0xB7, 0x01, 0x03, 0x05, 0x0D, 0x1A, 0x0D, 0x07, 0x02, 0x01, 0x01, 0x01, 0x08,
	0x21, 0x07, 0x06, 0x0B, 0x04, 0x8B, 0x01, 0x08, 0x01, 0x05, 0x0C, 0x06, 0x0E, 0x08, 0x08, 0x07,
	0x14, 0x04, 0x08, 0x1B, 0x08, 0x03, 0x1F, 0x0B, 0x10, 0x07, 0x11, 0x07, 0x36, 0x6B, 0x6B, 0x6B,
	0x35, 0x1E, 0x3B, 0x1D, 0x13, 0x15, 0x09, 0x03, 0x06, 0x02, 0x02, 0x09, 0x0B, 0x05, 0x0A, 0x01,
	0x01, 0x04, 0x06, 0x1B, 0x0C, 0x01, 0x08, 0x06, 0x01, 0x02, 0x02, 0x0A, 0x13, 0x09, 0x1C, 0x38,
	0x1C, 0x08, 0x27, 0x07, 0x02, 0x02, 0x01, 0x03, 0x07, 0x04, 0x0C, 0x11, 0x01, 0x04, 0x03, 0x01,
	0x0B, 0x03, 0x02, 0x01, 0x05, 0x09, 0x07, 0x0D, 0x18, 0x0C, 0x0E, 0x1D, 0x0E, 0x07, 0x13, 0x06,
	0x0A, 0x07, 0x09, 0x08, 0x15, 0x04, 0x07, 0x09, 0x06, 0x02, 0x05, 0x06, 0x07, 0x12, 0x05, 0x0D,
	0x11, 0x09, 0x06, 0x05, 0x06, 0x08, 0x07, 0x0D, 0x0B, 0x41, 0x3E, 0x27, 0x0E, 0x21, 0x43, 0x22,
	0x04, 0x0A, 0x04, 0x08, 0x08, 0x0E, 0x0C, 0x1F, 0x0A, 0x08, 0x02, 0x02, 0x05, 0x09, 0x04, 0x03,
	0x01, 0x08, 0x11, 0x07, 0x1E, 0x3A, 0x1D, 0x09, 0x14, 0x09, 0x08, 0x02, 0x05, 0x0D, 0x28, 0x0B,
	0x04, 0x08, 0x0A, 0x11, 0x08, 0x09, 0x05, 0x05, 0x0B, 0x0E, 0x1B, 0x0E, 0x0A, 0x08, 0x07, 0x06,
	0x1E, 0x05, 0x13, 0x26, 0x13, 0x08, 0x0F, 0x07, 0x0D, 0x0B, 0x01, 0x27, 0x4E, 0x27, 0x0B, 0x20,
	0x04, 0x05, 0x2B, 0x0E, 0x0C, 0x03, 0x02, 0x04, 0x08, 0x22, 0x10, 0x2A, 0x54, 0x2A, 0x35, 0x69,
	0x69, 0x69, 0x35, 0x09, 0x10, 0x02, 0x02, 0x05, 0x08, 0x0D, 0x19, 0x0D, 0x1B, 0x35, 0x1A, 0x0B,
	0x05, 0x06, 0x0B, 0x13, 0x0D, 0x07, 0x07, 0x05, 0x06, 0x17, 0x09, 0x0A, 0x0A, 0x09, 0x0A, 0x05,
	0x1D, 0x04, 0x04, 0x13, 0x01, 0x03, 0x1C, 0x05, 0x08, 0x23, 0x15, 0x10, 0x06, 0x01, 0x05, 0x09,
	0x1F, 0x06, 0x05, 0x05, 0x29, 0x53, 0x2A, 0x2E, 0x5C, 0x2E, 0x09, 0x09, 0x05, 0x03, 0x0A, 0x04,
	0x04, 0x0E, 0x05, 0x04, 0x0A, 0x01, 0x01, 0x06, 0x04, 0x03, 0x07, 0x04, 0x4F, 0xA0, 0x50, 0x29,
	0x52, 0x2A, 0x12, 0x30, 0x0C, 0x0C, 0x19, 0x0D, 0x04, 0x0B, 0x07, 0x0B, 0x15, 0x0B, 0x0A, 0x06,
	0x1C, 0x04, 0x07, 0x08, 0x07, 0x19, 0x32, 0x1A, 0x16, 0x34, 0x1D, 0x15, 0x20, 0x41, 0x20, 0x01,
	0xA0, 0x24, 0x01, 0x38, 0x07, 0x04, 0x18, 0x04, 0x08, 0x15, 0x0A, 0x0C, 0x1E, 0x15, 0x12, 0x03,
	0x01, 0x01, 0x03, 0x1D, 0x0F, 0x01, 0x3D, 0x04, 0x1C, 0x18, 0x06, 0x0B, 0x16, 0x0B, 0x04, 0x04,
	0x04, 0x1F, 0x07, 0x81, 0x01, 0x06, 0x09, 0x0B, 0x09, 0x12, 0x01, 0x04, 0x04, 0x01, 0x02, 0x12,
	0x10, 0x07, 0x02, 0x01, 0x03, 0x13, 0x05, 0x09, 0x05, 0x01, 0x04, 0x01, 0x08, 0x11, 0x09, 0x1A,
	0x34, 0x1A, 0x07, 0x09, 0x05, 0x0A, 0x15, 0x0D, 0x16, 0x2A, 0x14, 0x27, 0x50, 0x26, 0x04, 0x03,
	0x06, 0x01, 0x03, 0x06, 0x03, 0x09, 0x12, 0x09, 0x02, 0x10, 0x0B, 0x04, 0x17, 0x05, 0x0D, 0x1A,
	0x0D, 0x2C, 0x5D, 0x2E, 0x06, 0x19, 0x03, 0x02, 0x02, 0x01, 0x01, 0x0B, 0x02, 0x05, 0x0B, 0x02,
	0x02, 0x04, 0x0D, 0x0F, 0x0D, 0x19, 0x06, 0x0B, 0x0C, 0x0E, 0x05, 0x08, 0x03, 0x03, 0x07, 0x06,
	0x10, 0x28, 0x12, 0x0C, 0x0D, 0x0C, 0x0E, 0x09, 0x01, 0x02, 0x07, 0x16, 0x18, 0x3A, 0x73, 0x3A,
	0x08, 0x10, 0x08, 0x0D, 0x2C, 0x09, 0x07, 0x0B, 0x0E, 0x0B, 0x35, 0x0B, 0x03, 0x02, 0x01, 0x04,
	0x03, 0x14, 0x07, 0x13, 0x18, 0x15, 0x09, 0x12, 0x05, 0x0E, 0x0B, 0x05, 0x13, 0x03, 0x03, 0x0F,
	0x1C, 0x0F, 0x05, 0x0C, 0x05, 0x09, 0x07, 0x0E, 0x19, 0x32, 0x19, 0x07, 0x11, 0x0E, 0x16, 0x01,
	0x0C, 0x0B, 0x18, 0x10, 0x17, 0x2F, 0x17, 0x39, 0x71, 0x39, 0x0C, 0x1F, 0x0B, 0x12, 0x07, 0x0C,
	0x08, 0x05, 0x03, 0x04, 0x01, 0x19, 0x05, 0x06, 0x04, 0x01, 0x03, 0x05, 0x07, 0x14, 0x08, 0x0D,
	0x0C, 0x0B, 0x16, 0x20, 0x09, 0x07, 0x1B, 0x0F, 0x0D, 0x1A, 0x0D, 0x05, 0x01, 0x05, 0x0A, 0x07,
	0x02, 0x04, 0x02, 0x0A, 0x0A, 0x0B, 0x07, 0x05, 0x08, 0x03, 0x02, 0x02, 0x01, 0x04, 0x05, 0x05,
	0x03, 0x11, 0x11, 0x21, 0x11, 0x05, 0x10, 0x01, 0x03, 0x03, 0x09, 0x0D, 0x19, 0x0D, 0x19, 0x31,
	0x18, 0x03, 0x01, 0x0B, 0x02, 0x20, 0x1B, 0x0A, 0x00, 0x07, 0x00, 0x5B, 0x00, 0x26, 0x0D, 0x2D,
	0x03, 0x5A, 0x00, 0xBA, 0x00, 0xC5, 0x00, 0xCA, 0x00, 0xDC, 0x00, 0xE7, 0x00, 0xEE, 0x01, 0x11,
	0x00, 0x00, 0x01, 0x25, 0x27, 0x3F, 0x01, 0x27, 0x35, 0x0F, 0x01, 0x27, 0x17, 0x15, 0x07, 0x27,
	0x15, 0x23, 0x35, 0x33, 0x35, 0x27, 0x0F, 0x03, 0x2F, 0x01, 0x37, 0x27, 0x23, 0x0F, 0x02, 0x23,
	0x07, 0x05, 0x2F, 0x01, 0x07, 0x27, 0x07, 0x17, 0x0F, 0x02, 0x27, 0x22, 0x06, 0x0F, 0x02, 0x15,
	0x1F, 0x01, 0x07, 0x15, 0x1E, 0x01, 0x1F, 0x03, 0x07, 0x23, 0x35, 0x2F, 0x03, 0x07, 0x27, 0x23,
	0x07, 0x23, 0x22, 0x06, 0x0F, 0x02, 0x17, 0x07, 0x0E, 0x01, 0x0F, 0x04, 0x1F, 0x01, 0x07, 0x27,
	0x13, 0x3F, 0x01, 0x2F, 0x03, 0x15, 0x07, 0x2F, 0x02, 0x23, 0x0F, 0x01, 0x15, 0x07, 0x17, 0x23,
	0x15, 0x23, 0x35, 0x07, 0x35, 0x07, 0x15, 0x0F, 0x01, 0x2F, 0x01, 0x13, 0x33, 0x1F, 0x01, 0x05,
	0x1F, 0x01, 0x05, 0x27, 0x33, 0x35, 0x37, 0x17, 0x37, 0x35, 0x33, 0x17, 0x3F, 0x03, 0x33, 0x05,
	0x1F, 0x03, 0x07, 0x3F, 0x01, 0x17, 0x35, 0x37, 0x35, 0x3F, 0x01, 0x05, 0x17, 0x15, 0x1F, 0x03,
	0x33, 0x3F, 0x02, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x1F, 0x01, 0x07, 0x17, 0x33, 0x17, 0x37, 0x35,
	0x33, 0x35, 0x21, 0x17, 0x15, 0x07, 0x25, 0x2F, 0x03, 0x07, 0x17, 0x33, 0x37, 0x35, 0x23, 0x07,
	0x33, 0x37, 0x23, 0x15, 0x25, 0x27, 0x21, 0x0F, 0x03, 0x17, 0x25, 0x3F, 0x01, 0x3E, 0x01, 0x35,
	0x34, 0x26, 0x2F, 0x01, 0x05, 0x27, 0x23, 0x0F, 0x01, 0x1F, 0x01, 0x33, 0x3F, 0x01, 0x2F, 0x01,
	0x15, 0x33, 0x2F, 0x02, 0x07, 0x05, 0x27, 0x23, 0x07, 0x0E, 0x01, 0x07, 0x14, 0x16, 0x1F, 0x01,
	0x07, 0x27, 0x2E, 0x01, 0x35, 0x26, 0x36, 0x3F, 0x01, 0x07, 0x0E, 0x01, 0x17, 0x14, 0x16, 0x1F,
	0x01, 0x33, 0x35, 0x37, 0x36, 0x26, 0x2F, 0x01, 0x0D, 0x29, 0xFD, 0xA7, 0x01, 0x0C, 0x01, 0xC1,
	0x50, 0x10, 0x8B, 0x1C, 0x07, 0x1E, 0x17, 0x06, 0x55, 0x03, 0x03, 0x03, 0x06, 0x07, 0x05, 0x01,
	0x02, 0x11, 0x02, 0x05, 0x05, 0x09, 0x08, 0xFE, 0x1B, 0x09, 0x0C, 0x18, 0x03, 0x18, 0x02, 0x02,
	0x04, 0x0C, 0x03, 0x03, 0x04, 0x01, 0x06, 0x02, 0x08, 0x01, 0x11, 0x01, 0x06, 0x05, 0x1D, 0x11,
	0x05, 0xC6, 0x06, 0x15, 0x1E, 0x0A, 0x03, 0x0E, 0x13, 0x7B, 0x29, 0x06, 0x05, 0x07, 0x03, 0x08,
	0x1D, 0x0F, 0x04, 0x04, 0x09, 0x05, 0x0A, 0x03, 0x38, 0x01, 0x07, 0x05, 0x05, 0xB9, 0xA6, 0x04,
	0x03, 0x09, 0x0F, 0x10, 0x2A, 0x0B, 0x02, 0x21, 0x01, 0x84, 0x20, 0x7D, 0x6D, 0x02, 0x4C, 0x25,
	0x7C, 0x9D, 0x01, 0x07, 0x05, 0x02, 0x03, 0x8B, 0x05, 0x04, 0x01, 0x67, 0x04, 0x02, 0x01, 0x22,
	0x01, 0x22, 0x0C, 0x01, 0x23, 0x22, 0x02, 0x58, 0x04, 0x0B, 0x0D, 0x08, 0x01, 0xB5, 0x0D, 0x16,
	0x0D, 0x06, 0x03, 0x09, 0x02, 0x1B, 0x09, 0x03, 0x06, 0x01, 0xE6, 0x05, 0x0E, 0x02, 0x04, 0x03,
	0x11, 0x01, 0x50, 0x08, 0x04, 0x08, 0x04, 0x0A, 0x0E, 0x05, 0x04, 0x02, 0x02, 0x8B, 0x12, 0x4F,
	0xC1, 0x02, 0x4C, 0x05, 0x04, 0xFB, 0xE9, 0x07, 0x05, 0x01, 0x1F, 0x2F, 0x07, 0x59, 0x07, 0x0C,
	0x53, 0x54, 0x04, 0x58, 0xFD, 0x6E, 0x04, 0xFE, 0x88, 0x0F, 0x0C, 0x05, 0x15, 0x08, 0x01, 0xA3,
	0x05, 0x0B, 0x07, 0x08, 0x07, 0x07, 0x0B, 0xFA, 0xAC, 0x05, 0x61, 0x05, 0x04, 0x05, 0x04, 0x63,
	0x03, 0x04, 0x04, 0x6F, 0x7D, 0x02, 0x04, 0x05, 0x72, 0x04, 0xB6, 0x0A, 0x32, 0x0C, 0x05, 0x06,
	0x01, 0x04, 0x05, 0x0C, 0x05, 0x11, 0x09, 0x09, 0x01, 0x03, 0x03, 0x05, 0x16, 0x0C, 0x0B, 0x02,
	0x09, 0x08, 0x10, 0x76, 0x0A, 0x03, 0x01, 0x04, 0x17, 0x02, 0x2D, 0x01, 0x18, 0x01, 0x09, 0x03,
	0x05, 0x01, 0x05, 0x01, 0x05, 0x18, 0x08, 0x02, 0x0B, 0x28, 0x05, 0x02, 0x07, 0x14, 0x04, 0x03,
	0x04, 0x03, 0x12, 0x08, 0x1D, 0x05, 0x04, 0x11, 0x04, 0x05, 0x03, 0x09, 0x21, 0x02, 0x15, 0x02,
	0x07, 0x04, 0x02, 0x03, 0x03, 0x08, 0x05, 0x70, 0x02, 0x09, 0x07, 0x29, 0x17, 0x2B, 0x16, 0x66,
	0x36, 0x07, 0x37, 0x06, 0x45, 0x75, 0x4F, 0x22, 0x03, 0x03, 0x04, 0x02, 0x02, 0x08, 0x37, 0x11,
	0x03, 0x01, 0x04, 0x02, 0x08, 0x04, 0x6F, 0x0A, 0x0B, 0x03, 0x0C, 0x2B, 0x01, 0x21, 0x0C, 0x17,
	0x18, 0x10, 0x08, 0x01, 0x05, 0x02, 0x48, 0x02, 0x0C, 0x18, 0x03, 0x0B, 0x02, 0x44, 0x1C, 0x1B,
	0x4E, 0x3F, 0x47, 0x1A, 0x04, 0x05, 0x05, 0x04, 0x01, 0x5D, 0x04, 0x13, 0x04, 0x03, 0x07, 0x01,
	0x0C, 0x09, 0x01, 0x09, 0x02, 0x0F, 0x02, 0x8C, 0x05, 0x08, 0x06, 0x30, 0x02, 0x0D, 0x17, 0x0C,
	0x55, 0x01, 0x26, 0x05, 0x09, 0x02, 0x02, 0x04, 0x03, 0x08, 0x0A, 0x0E, 0x01, 0x01, 0x05, 0x20,
	0x33, 0x71, 0x07, 0x03, 0x03, 0x01, 0x01, 0x08, 0x05, 0x0A, 0x04, 0x94, 0x06, 0x01, 0x05, 0x24,
	0x06, 0x7C, 0x07, 0xB2, 0x07, 0x11, 0x0D, 0x03, 0x4A, 0x05, 0x09, 0x1E, 0x4D, 0x0D, 0x0D, 0x81,
	0x03, 0x07, 0x0C, 0x07, 0x33, 0x08, 0x03, 0x01, 0x05, 0x06, 0x11, 0x0C, 0x09, 0x10, 0x06, 0x07,
	0xF4, 0x01, 0x01, 0x08, 0x07, 0x03, 0x04, 0x07, 0x07, 0x9A, 0x0E, 0x09, 0x05, 0x02, 0x02, 0xFA,
	0x04, 0x0C, 0x09, 0x0F, 0x08, 0x07, 0x0E, 0x08, 0x0A, 0x04, 0x0D, 0x08, 0x11, 0x09, 0x06, 0x0E,
	0x08, 0x0C, 0x08, 0x08, 0x17, 0x0F, 0x09, 0x0F, 0x08, 0x0B, 0x0F, 0x10, 0x09, 0x15, 0x0B, 0x15,
	0x00, 0x02, 0x00, 0x53, 0xFF, 0xF2, 0x08, 0xFC, 0x03, 0x8D, 0x00, 0x1E, 0x01, 0x29, 0x00, 0x00,
	0x01, 0x07, 0x0E, 0x01, 0x15, 0x17, 0x07, 0x2B, 0x01, 0x07, 0x23, 0x0F, 0x02, 0x0E, 0x01, 0x17,
	0x1E, 0x01, 0x17, 0x33, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x27, 0x23, 0x25, 0x17,
	0x37, 0x33, 0x1F, 0x01, 0x0F, 0x01, 0x23, 0x2F, 0x01, 0x0F, 0x01, 0x23, 0x27, 0x23, 0x27, 0x23,
	0x0E, 0x01, 0x2B, 0x01, 0x2F, 0x01, 0x05, 0x07, 0x23, 0x27, 0x23, 0x07, 0x23, 0x07, 0x14, 0x06,
	0x07, 0x1F, 0x01, 0x1E, 0x01, 0x07, 0x0E, 0x01, 0x1F, 0x01, 0x15, 0x1E, 0x01, 0x17, 0x16, 0x06,
	0x0F, 0x01, 0x2F, 0x01, 0x34, 0x36, 0x3F, 0x01, 0x3E, 0x01, 0x2F, 0x02, 0x26, 0x36, 0x3F, 0x01,
	0x27, 0x07, 0x0E, 0x01, 0x0F, 0x01, 0x0E, 0x01, 0x0F, 0x03, 0x22, 0x26, 0x2F, 0x01, 0x3E, 0x01,
	0x3F, 0x01, 0x3E, 0x01, 0x3F, 0x01, 0x3E, 0x01, 0x35, 0x34, 0x26, 0x27, 0x0F, 0x01, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x0F, 0x01, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x0F, 0x02, 0x06,
	0x26, 0x37, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x2F, 0x02, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x0F, 0x01, 0x1F, 0x01, 0x14, 0x06, 0x07, 0x0E, 0x01, 0x2B,
	0x01, 0x22, 0x26, 0x27, 0x2E, 0x01, 0x2F, 0x01, 0x2E, 0x01, 0x35, 0x26, 0x36, 0x3F, 0x02, 0x3E,
	0x01, 0x33, 0x25, 0x35, 0x3F, 0x02, 0x17, 0x35, 0x23, 0x16, 0x06, 0x23, 0x2F, 0x01, 0x23, 0x07,
	0x23, 0x2E, 0x01, 0x35, 0x34, 0x36, 0x37, 0x33, 0x17, 0x3F, 0x01, 0x36, 0x37, 0x36, 0x33, 0x32,
	0x16, 0x15, 0x37, 0x35, 0x37, 0x17, 0x15, 0x3F, 0x01, 0x33, 0x17, 0x33, 0x35, 0x33, 0x15, 0x33,
	0x15, 0x23, 0x15, 0x23, 0x35, 0x23, 0x17, 0x33, 0x1E, 0x01, 0x1F, 0x01, 0x33, 0x35, 0x33, 0x15,
	0x33, 0x35, 0x33, 0x15, 0x33, 0x35, 0x33, 0x15, 0x33, 0x35, 0x33, 0x15, 0x33, 0x35, 0x33, 0x15,
	0x33, 0x17, 0x15, 0x17, 0x21, 0x3F, 0x01, 0x33, 0x17, 0x33, 0x37, 0x17, 0x37, 0x3E, 0x01, 0x3B,
	0x01, 0x17, 0x04, 0x8B, 0x07, 0x04, 0x04, 0x03, 0x05, 0x16, 0x0E, 0x06, 0x1B, 0x08, 0x06, 0x37,
	0x05, 0x01, 0x04, 0x03, 0x09, 0x06, 0x4B, 0x16, 0x1F, 0x0B, 0x08, 0x36, 0x2F, 0x03, 0x08, 0x0A,
	0x5E, 0x04, 0x13, 0x0E, 0x0F, 0x37, 0x05, 0x05, 0x05, 0x07, 0x31, 0x0A, 0x0A, 0x0E, 0x06, 0x1F,
	0x05, 0x31, 0x04, 0x18, 0x01, 0x05, 0x04, 0x2D, 0x09, 0x03, 0xFE, 0xBE, 0x11, 0x08, 0x06, 0x07,
	0x05, 0x43, 0x09, 0x07, 0x07, 0x08, 0x12, 0x09, 0x08, 0x01, 0x03, 0x02, 0x02, 0x01, 0x01, 0x0D,
	0x0C, 0x02, 0x08, 0x0A, 0x2A, 0x31, 0x1C, 0x02, 0x04, 0x0F, 0x05, 0x02, 0x01, 0x08, 0x09, 0x02,
	0x09, 0x0A, 0x14, 0x53, 0x61, 0x10, 0x2B, 0x1A, 0x47, 0x0C, 0x17, 0x0B, 0x40, 0x6E, 0x4E, 0x05,
	0x07, 0x02, 0x02, 0x01, 0x06, 0x05, 0x15, 0x08, 0x0C, 0x03, 0x17, 0x08, 0x08, 0x0E, 0x0E, 0x3E,
	0x44, 0x10, 0x13, 0x02, 0x05, 0x0F, 0x0B, 0x03, 0x03, 0x11, 0x0F, 0x16, 0x28, 0x13, 0x08, 0x02,
	0x09, 0x51, 0x53, 0x07, 0x05, 0x01, 0x19, 0x0E, 0x19, 0x0A, 0x0A, 0x0F, 0x04, 0x05, 0x21, 0x32,
	0x02, 0x05, 0x04, 0x04, 0x05, 0x01, 0x0E, 0x28, 0x1A, 0x1F, 0x22, 0x03, 0x08, 0x0C, 0x0D, 0x05,
	0x04, 0x04, 0x0B, 0x08, 0x82, 0x06, 0x0C, 0x06, 0x07, 0x0A, 0x05, 0x23, 0x0C, 0x0E, 0x01, 0x02,
	0x02, 0x0E, 0x24, 0x0D, 0x15, 0x07, 0x02, 0xBB, 0x12, 0x1B, 0x1F, 0x2A, 0x11, 0x01, 0x08, 0x09,
	0x0E, 0x02, 0x27, 0x05, 0x0E, 0x05, 0x05, 0x05, 0x04, 0x0A, 0x07, 0x26, 0x02, 0x02, 0x04, 0x05,
	0x06, 0x07, 0x06, 0x0B, 0x15, 0x17, 0x58, 0x6A, 0x22, 0x10, 0x0F, 0x0E, 0x15, 0x15, 0x0D, 0x37,
	0x09, 0x0E, 0x08, 0x08, 0x01, 0x05, 0x24, 0x11, 0x26, 0x10, 0x26, 0x10, 0x27, 0x0F, 0x27, 0x10,
	0x1E, 0x4E, 0x14, 0x01, 0x59, 0x06, 0x09, 0x29, 0x0A, 0x14, 0x0A, 0x2B, 0x01, 0x02, 0x04, 0x03,
	0x1C, 0x07, 0x01, 0xF9, 0x05, 0x05, 0x0B, 0x06, 0x17, 0x06, 0x0E, 0x02, 0x07, 0x64, 0x0A, 0x12,
	0x08, 0x06, 0x08, 0x02, 0x02, 0x0B, 0x08, 0x07, 0x53, 0x4D, 0x05, 0x16, 0x10, 0xB2, 0x01, 0x07,
	0x0A, 0x1A, 0x19, 0x0A, 0x03, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x03, 0x03, 0x02, 0x08, 0x12,
	0x06, 0x06, 0x44, 0x06, 0x08, 0x02, 0x08, 0x02, 0x02, 0x07, 0x05, 0x13, 0x1B, 0x09, 0x33, 0x3A,
	0x11, 0x25, 0x13, 0x04, 0x08, 0x04, 0x07, 0x09, 0x07, 0x19, 0x2D, 0x14, 0x37, 0x0D, 0x14, 0x06,
	0x1C, 0x13, 0x05, 0x09, 0x07, 0x0A, 0x04, 0x04, 0x0B, 0x2F, 0x25, 0x6B, 0x11, 0x18, 0x05, 0x0B,
	0x06, 0x01, 0x03, 0x04, 0x17, 0x18, 0x22, 0x0B, 0x27, 0x0F, 0x12, 0x02, 0x14, 0x0A, 0x19, 0x0E,
	0x10, 0x13, 0x03, 0x02, 0x05, 0x01, 0x05, 0x05, 0x06, 0x0B, 0x04, 0x28, 0x1E, 0x51, 0x32, 0x4F,
	0x67, 0x18, 0x0A, 0x0F, 0x05, 0x1D, 0x1C, 0x02, 0x14, 0x16, 0x36, 0x25, 0x4F, 0x2B, 0x2B, 0x52,
	0x28, 0x3C, 0x02, 0x28, 0x02, 0x03, 0x05, 0x05, 0x04, 0x01, 0x05, 0x17, 0x12, 0x16, 0x21, 0x0B,
	0x1B, 0x0D, 0x13, 0x07, 0x0B, 0x04, 0x04, 0x04, 0x05, 0x05, 0x07, 0x11, 0x0B, 0x90, 0x3C, 0x49,
	0x0E, 0x0D, 0x14, 0x07, 0x15, 0x1D, 0x08, 0x09, 0x0F, 0x08, 0x0D, 0x12, 0x05, 0x01, 0x39, 0x06,
	0x06, 0x05, 0x07, 0x06, 0x07, 0x19, 0x11, 0x11, 0x12, 0x02, 0x05, 0x02, 0x07, 0x04, 0x01, 0x02,
	0x07, 0x06, 0x01, 0x13, 0x03, 0x02, 0x0E, 0x0D, 0x0C, 0x0C, 0x06, 0x04, 0x6D, 0x06, 0x07, 0x0D,
	0x01, 0x04, 0x03, 0x15, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x27, 0x1A,
	0x0B, 0x04, 0x05, 0x09, 0x06, 0x02, 0x04, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x53,
	0x00, 0x0D, 0x0A, 0x10, 0x03, 0x75, 0x01, 0xEF, 0x02, 0x05, 0x02, 0x12, 0x00, 0x00, 0x01, 0x36,
	0x27, 0x26, 0x37, 0x3E, 0x01, 0x17, 0x16, 0x06, 0x17, 0x1E, 0x01, 0x27, 0x34, 0x16, 0x17, 0x16,
	0x36, 0x35, 0x26, 0x36, 0x33, 0x32, 0x36, 0x15, 0x16, 0x06, 0x17, 0x16, 0x36, 0x33, 0x3A, 0x01,
	0x33, 0x32, 0x16, 0x37, 0x34, 0x26, 0x37, 0x36, 0x16, 0x33, 0x16, 0x32, 0x33, 0x32, 0x36, 0x37,
	0x34, 0x16, 0x15, 0x16, 0x14, 0x37, 0x36, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x33, 0x32,
	0x36, 0x15, 0x14, 0x36, 0x33, 0x32, 0x16, 0x37, 0x3E, 0x01, 0x17, 0x16, 0x06, 0x33, 0x3A, 0x01,
	0x33, 0x3A, 0x03, 0x33, 0x32, 0x36, 0x17, 0x32, 0x16, 0x35, 0x34, 0x16, 0x35, 0x3C, 0x01, 0x35,
	0x34, 0x26, 0x37, 0x36, 0x32, 0x15, 0x16, 0x36, 0x17, 0x16, 0x06, 0x15, 0x14, 0x32, 0x17, 0x1E,
	0x01, 0x07, 0x14, 0x06, 0x17, 0x16, 0x36, 0x17, 0x16, 0x06, 0x15, 0x16, 0x36, 0x17, 0x1E, 0x01,
	0x23, 0x22, 0x23, 0x22, 0x23, 0x07, 0x06, 0x15, 0x32, 0x36, 0x17, 0x16, 0x06, 0x07, 0x06, 0x26,
	0x15, 0x14, 0x16, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x37, 0x34, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x3A,
	0x01, 0x33, 0x3A, 0x01, 0x17, 0x16, 0x06, 0x15, 0x14, 0x16, 0x23, 0x06, 0x26, 0x23, 0x22, 0x26,
	0x07, 0x06, 0x36, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x07, 0x06, 0x14, 0x07,
	0x06, 0x26, 0x07, 0x06, 0x16, 0x07, 0x22, 0x26, 0x23, 0x2E, 0x01, 0x34, 0x36, 0x27, 0x34, 0x26,
	0x23, 0x22, 0x34, 0x27, 0x26, 0x06, 0x23, 0x26, 0x06, 0x07, 0x06, 0x16, 0x07, 0x06, 0x14, 0x23,
	0x22, 0x26, 0x23, 0x22, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x07, 0x06,
	0x26, 0x27, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x27, 0x26, 0x06, 0x07, 0x0E, 0x01,
	0x15, 0x1C, 0x01, 0x15, 0x16, 0x36, 0x17, 0x16, 0x06, 0x23, 0x22, 0x06, 0x15, 0x1E, 0x01, 0x17,
	0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x07, 0x0E,
	0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x22, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x22, 0x07, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x07,
	0x0E, 0x01, 0x15, 0x14, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E,
	0x01, 0x27, 0x26, 0x36, 0x37, 0x36, 0x37, 0x36, 0x27, 0x2E, 0x01, 0x23, 0x22, 0x27, 0x23, 0x26,
	0x22, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x26, 0x07, 0x06, 0x16, 0x15, 0x1E, 0x01, 0x07, 0x2A, 0x01,
	0x27, 0x22, 0x26, 0x07, 0x0E, 0x01, 0x15, 0x14, 0x22, 0x23, 0x22, 0x06, 0x15, 0x0E, 0x01, 0x07,
	0x22, 0x06, 0x23, 0x22, 0x26, 0x35, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x26,
	0x36, 0x35, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x22, 0x06, 0x27, 0x26, 0x36,
	0x27, 0x2E, 0x01, 0x35, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x37, 0x34, 0x26, 0x37,
	0x36, 0x16, 0x17, 0x32, 0x06, 0x17, 0x16, 0x36, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32,
	0x16, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x32, 0x33, 0x1E, 0x01, 0x33, 0x3A, 0x01,
	0x33, 0x32, 0x34, 0x27, 0x34, 0x36, 0x35, 0x2E, 0x01, 0x07, 0x06, 0x16, 0x23, 0x22, 0x26, 0x37,
	0x34, 0x06, 0x23, 0x22, 0x16, 0x07, 0x06, 0x34, 0x37, 0x34, 0x26, 0x37, 0x13, 0x26, 0x06, 0x23,
	0x22, 0x16, 0x17, 0x14, 0x36, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x26, 0x37, 0x3E, 0x01, 0x37, 0x36,
	0x26, 0x27, 0x07, 0x26, 0x06, 0x15, 0x14, 0x16, 0x33, 0x34, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x03,
	0x36, 0x09, 0x01, 0x03, 0x04, 0x02, 0x17, 0x04, 0x09, 0x0E, 0x0E, 0x06, 0x12, 0x01, 0x10, 0x02,
	0x04, 0x07, 0x01, 0x0A, 0x09, 0x03, 0x16, 0x01, 0x02, 0x03, 0x09, 0x1B, 0x0B, 0x10, 0x1F, 0x10,
	0x02, 0x0F, 0x01, 0x03, 0x02, 0x04, 0x13, 0x04, 0x0A, 0x15, 0x0A, 0x0F, 0x02, 0x01, 0x11, 0x01,
	0x09, 0x06, 0x03, 0x01, 0x03, 0x0D, 0x05, 0x02, 0x1C, 0x0A, 0x03, 0x20, 0x1B, 0x0A, 0x18, 0x31,
	0x18, 0x07, 0x10, 0x07, 0x0B, 0x08, 0x0E, 0x3C, 0x77, 0x3C, 0x31, 0x62, 0x63, 0x62, 0x31, 0x16,
	0x28, 0x14, 0x03, 0x13, 0x09, 0x04, 0x05, 0x02, 0x1C, 0x01, 0x08, 0x02, 0x02, 0x02, 0x05, 0x03,
	0x04, 0x01, 0x01, 0x04, 0x04, 0x02, 0x0C, 0x04, 0x05, 0x01, 0x01, 0x36, 0x04, 0x01, 0x02, 0x03,
	0x05, 0x06, 0x05, 0x06, 0x03, 0x01, 0x03, 0x14, 0x02, 0x02, 0x04, 0x05, 0x05, 0x2E, 0x44, 0x55,
	0x4C, 0x07, 0x04, 0x02, 0x01, 0x10, 0x02, 0x08, 0x10, 0x08, 0x0E, 0x1E, 0x0F, 0x03, 0x09, 0x04,
	0x02, 0x02, 0x04, 0x03, 0x0B, 0x16, 0x0B, 0x1C, 0x39, 0x1C, 0x0D, 0x04, 0x07, 0x11, 0x23, 0x11,
	0x1E, 0x3C, 0x1D, 0x05, 0x0B, 0x05, 0x03, 0x01, 0x03, 0x09, 0x04, 0x04, 0x09, 0x09, 0x06, 0x0E,
	0x06, 0x0B, 0x02, 0x04, 0x01, 0x04, 0x03, 0x05, 0x02, 0x0A, 0x01, 0x05, 0x08, 0x09, 0x02, 0x02,
	0x02, 0x0C, 0x07, 0x0B, 0x0D, 0x1A, 0x0D, 0x3D, 0x7B, 0x3D, 0x1D, 0x3A, 0x1D, 0x0F, 0x1D, 0x0E,
	0x09, 0x2D, 0x04, 0x03, 0x0F, 0x03, 0x02, 0x01, 0x02, 0x07, 0x0E, 0x07, 0x1C, 0x37, 0x1B, 0x18,
	0x28, 0x14, 0x09, 0x08, 0x02, 0x05, 0x03, 0x05, 0x07, 0x05, 0x09, 0x03, 0x01, 0x04, 0x02, 0x01,
	0x06, 0x02, 0x03, 0x02, 0x03, 0x06, 0x10, 0x07, 0x03, 0x07, 0x05, 0x04, 0x06, 0x04, 0x03, 0x19,
	0x06, 0x0F, 0x1D, 0x0F, 0x16, 0x30, 0x18, 0x0E, 0x07, 0x05, 0x09, 0x0C, 0x04, 0x04, 0x0B, 0x03,
	0x04, 0x08, 0x06, 0x04, 0x01, 0x11, 0x1E, 0x3C, 0x1E, 0x09, 0x12, 0x09, 0x09, 0x0B, 0x05, 0x03,
	0x0C, 0x0C, 0x02, 0x04, 0x0C, 0x06, 0x0C, 0x0B, 0x03, 0x03, 0x39, 0x08, 0x17, 0x30, 0x16, 0x21,
	0x5B, 0x0D, 0x0C, 0x09, 0x0A, 0x05, 0x06, 0x31, 0x10, 0x01, 0x01, 0x01, 0x01, 0x05, 0x07, 0x07,
	0x0A, 0x01, 0x01, 0x01, 0x16, 0x0B, 0x17, 0x0C, 0x05, 0x0B, 0x05, 0x02, 0x01, 0x2E, 0x05, 0x03,
	0x03, 0x01, 0x03, 0x08, 0x06, 0x0B, 0x05, 0x09, 0x01, 0x0A, 0x1A, 0x0B, 0x09, 0x13, 0x08, 0x04,
	0x17, 0x06, 0x07, 0x03, 0x0F, 0x20, 0x08, 0x12, 0x23, 0x09, 0x04, 0x02, 0x0B, 0x08, 0x13, 0x08,
	0x06, 0x02, 0x01, 0x02, 0x05, 0x03, 0x0B, 0x03, 0x03, 0x03, 0x02, 0x02, 0x04, 0x02, 0x02, 0x05,
	0x08, 0x13, 0x08, 0x07, 0x02, 0x01, 0x01, 0x1B, 0x05, 0x1F, 0x3F, 0x1F, 0x3E, 0x7C, 0x3F, 0x19,
	0x39, 0x19, 0x14, 0x19, 0x11, 0x06, 0x04, 0x01, 0x02, 0x0E, 0x05, 0x17, 0x2C, 0x17, 0x14, 0x27,
	0x14, 0x0B, 0x01, 0x01, 0x01, 0x08, 0x01, 0x03, 0x05, 0x0C, 0x04, 0x09, 0x02, 0x20, 0x03, 0x10,
	0x08, 0x0A, 0x12, 0x01, 0x03, 0x05, 0xBF, 0x0A, 0x2A, 0x0D, 0x19, 0x04, 0x01, 0x1E, 0x06, 0x07,
	0x0D, 0x07, 0x0D, 0x09, 0x05, 0x08, 0x1A, 0x01, 0x01, 0x0F, 0x08, 0x86, 0x08, 0x04, 0x16, 0x10,
	0x0B, 0x02, 0x02, 0x09, 0x02, 0x03, 0x48, 0x08, 0x08, 0x08, 0x09, 0x06, 0x06, 0x04, 0x07, 0x29,
	0x02, 0x01, 0x02, 0x09, 0x05, 0x04, 0x03, 0x06, 0x01, 0x09, 0x0A, 0x01, 0x02, 0x03, 0x02, 0x10,
	0x01, 0x03, 0x03, 0x02, 0x03, 0x02, 0x07, 0x02, 0x04, 0x03, 0x01, 0x04, 0x0C, 0x03, 0x01, 0x04,
	0x06, 0x0D, 0x02, 0x02, 0x1A, 0x03, 0x0B, 0x15, 0x0A, 0x05, 0x3A, 0x02, 0x03, 0x0D, 0x03, 0x01,
	0x02, 0x01, 0x01, 0x01, 0x01, 0x0C, 0x02, 0x02, 0x08, 0x04, 0x06, 0x03, 0x05, 0x0D, 0x1A, 0x0D,
	0x06, 0x45, 0x03, 0x01, 0x05, 0x09, 0x05, 0x05, 0x05, 0x0A, 0x05, 0x06, 0x03, 0x06, 0x10, 0x07,
	0x0A, 0x1C, 0x0A, 0x05, 0x03, 0x03, 0x02, 0x0F, 0x04, 0x13, 0x13, 0x0E, 0x01, 0x11, 0x04, 0x05,
	0x01, 0x02, 0x04, 0x05, 0x0A, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x04, 0x03, 0x03, 0x01, 0x02,
	0x01, 0x2A, 0x03, 0x02, 0x1A, 0x02, 0x01, 0x01, 0x02, 0x01, 0x0D, 0x02, 0x01, 0x01, 0x08, 0x02,
	0x08, 0x01, 0x05, 0x07, 0x35, 0x01, 0x02, 0x01, 0x0A, 0x13, 0x11, 0x09, 0x04, 0x01, 0x04, 0x03,
	0x0D, 0x37, 0x01, 0x06, 0x09, 0x0B, 0x08, 0x04, 0x02, 0x06, 0x01, 0x01, 0x03, 0x06, 0x04, 0x02,
	0x03, 0x01, 0x09, 0x02, 0x01, 0x01, 0x09, 0x0D, 0x06, 0x0D, 0x0B, 0x03, 0x0D, 0x03, 0x04, 0x04,
	0x01, 0x02, 0x0F, 0x07, 0x0A, 0x16, 0x28, 0x15, 0x08, 0x0B, 0x07, 0x07, 0x10, 0x08, 0x16, 0x2A,
	0x15, 0x09, 0x16, 0x08, 0x06, 0x0B, 0x09, 0x07, 0x05, 0x02, 0x06, 0x09, 0x05, 0x08, 0x11, 0x39,
	0x0A, 0x13, 0x30, 0x16, 0x11, 0x20, 0x12, 0x16, 0x2E, 0x16, 0x10, 0x09, 0x01, 0x01, 0x01, 0x08,
	0x06, 0x14, 0x07, 0x05, 0x11, 0x05, 0x09, 0x11, 0x08, 0x14, 0x24, 0x15, 0x10, 0x1A, 0x04, 0x0A,
	0x11, 0x0C, 0x11, 0x6E, 0x0D, 0x0D, 0x12, 0x12, 0x12, 0x12, 0x0E, 0x01, 0x05, 0x04, 0x09, 0x12,
	0x09, 0x09, 0x03, 0x03, 0x04, 0x0D, 0x0A, 0x12, 0x15, 0x01, 0x01, 0x01, 0x01, 0x01, 0x17, 0x03,
	0x07, 0x0C, 0x02, 0x08, 0x05, 0x01, 0x01, 0x07, 0x08, 0x0A, 0x0B, 0x0A, 0x09, 0x0C, 0x0B, 0x05,
	0x02, 0x03, 0x03, 0x25, 0x06, 0x21, 0x0A, 0x12, 0x27, 0x18, 0x09, 0x0A, 0x01, 0x01, 0x03, 0x03,
	0x12, 0x05, 0x08, 0x0D, 0x09, 0x23, 0x46, 0x24, 0x16, 0x2C, 0x16, 0x19, 0x31, 0x18, 0x05, 0x14,
	0x02, 0x03, 0x03, 0x01, 0x0D, 0x04, 0x09, 0x02, 0x03, 0x05, 0x04, 0x24, 0x08, 0x03, 0x04, 0x07,
	0x06, 0x01, 0x01, 0x05, 0x0A, 0x04, 0x08, 0x03, 0x03, 0x03, 0x03, 0x07, 0x06, 0x05, 0x07, 0x03,
	0x01, 0x09, 0x04, 0x07, 0x20, 0x0A, 0x16, 0x2C, 0x16, 0xFE, 0x6F, 0x0A, 0x08, 0x2F, 0x11, 0x0A,
	0x03, 0x02, 0x05, 0x07, 0x0D, 0x0C, 0x09, 0x11, 0x04, 0x11, 0x0D, 0x1D, 0x03, 0x12, 0x0F, 0x04,
	0x0D, 0x05, 0x08, 0x0E, 0x08, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x56, 0x00, 0x3F, 0x0A, 0xA0,
	0x03, 0x3F, 0x00, 0x7E, 0x00, 0x96, 0x00, 0x00, 0x01, 0x2F, 0x01, 0x35, 0x23, 0x15, 0x07, 0x0E,
	0x01, 0x0F, 0x02, 0x23, 0x2F, 0x02, 0x23, 0x2F, 0x02, 0x25, 0x07, 0x0E, 0x01, 0x0F, 0x01, 0x21,
	0x27, 0x0F, 0x03, 0x2F, 0x01, 0x0F, 0x02, 0x27, 0x07, 0x0E, 0x01, 0x07, 0x13, 0x25, 0x3F, 0x04,
	0x36, 0x16, 0x1F, 0x01, 0x0F, 0x03, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x3F, 0x02, 0x3E, 0x01, 0x37,
	0x3E, 0x01, 0x3F, 0x02, 0x1E, 0x01, 0x17, 0x37, 0x3E, 0x01, 0x37, 0x17, 0x3F, 0x01, 0x1E, 0x01,
	0x17, 0x1E, 0x01, 0x17, 0x16, 0x17, 0x16, 0x17, 0x3F, 0x02, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27,
	0x2E, 0x01, 0x35, 0x33, 0x17, 0x1E, 0x01, 0x33, 0x17, 0x3F, 0x02, 0x21, 0x37, 0x33, 0x17, 0x37,
	0x21, 0x17, 0x37, 0x33, 0x17, 0x3F, 0x01, 0x27, 0x05, 0x0E, 0x01, 0x2B, 0x01, 0x22, 0x26, 0x27,
	0x2E, 0x01, 0x35, 0x34, 0x36, 0x37, 0x3E, 0x01, 0x33, 0x37, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x15,
	0x0A, 0x9B, 0x08, 0x2B, 0x2E, 0x03, 0x02, 0x05, 0x03, 0x22, 0x0D, 0xB0, 0x16, 0x1B, 0x1E, 0xC8,
	0x15, 0x16, 0x1B, 0xFE, 0x20, 0x1B, 0x04, 0x06, 0x02, 0x07, 0xFD, 0x91, 0x0A, 0x65, 0x3F, 0x30,
	0x1C, 0x2F, 0x20, 0xA2, 0x6E, 0x31, 0x3A, 0x31, 0x0C, 0x15, 0x08, 0x16, 0x01, 0x0A, 0xC8, 0x4D,
	0x43, 0x32, 0x17, 0x08, 0x0E, 0x07, 0x13, 0x14, 0x22, 0x20, 0x11, 0x03, 0x0D, 0x0B, 0x0B, 0x17,
	0x0D, 0x2D, 0x13, 0x04, 0x0F, 0x0B, 0x0A, 0x16, 0x0C, 0x29, 0x15, 0x0F, 0x1E, 0x10, 0x35, 0x0E,
	0x1B, 0x0D, 0x21, 0x09, 0x0C, 0x13, 0x2F, 0x1C, 0x1C, 0x36, 0x1A, 0x1F, 0x1F, 0x20, 0x22, 0x33,
	0x25, 0x14, 0x2E, 0x47, 0x19, 0x18, 0x23, 0x0B, 0x0D, 0x0D, 0x9A, 0x0F, 0x01, 0x05, 0x03, 0x16,
	0x15, 0x1D, 0x28, 0x01, 0x53, 0x03, 0xD8, 0x12, 0x0F, 0x01, 0x2E, 0x24, 0x13, 0x0D, 0x0D, 0x13,
	0x05, 0x05, 0xF9, 0xEB, 0x05, 0x0D, 0x08, 0x3D, 0x09, 0x10, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x10, 0x09, 0x3D, 0x08, 0x0D, 0x05, 0x06, 0x05, 0x02, 0xB0, 0x12, 0x05, 0x78, 0x07, 0x11, 0x02,
	0x0B, 0x08, 0x4B, 0x05, 0x0E, 0x1C, 0x25, 0x07, 0x06, 0x09, 0x05, 0x02, 0x02, 0x02, 0x02, 0x06,
	0x09, 0x57, 0x13, 0x0D, 0x06, 0x0A, 0x0A, 0x0A, 0x09, 0x01, 0x01, 0x0C, 0x04, 0x0A, 0x07, 0xFE,
	0xC3, 0x58, 0x4A, 0x1A, 0x19, 0x11, 0x08, 0x01, 0x05, 0x06, 0x0E, 0x1B, 0x3D, 0x3E, 0x24, 0x14,
	0x1B, 0x07, 0x06, 0x06, 0x01, 0x0A, 0x09, 0x11, 0x21, 0x10, 0x12, 0x1F, 0x0E, 0x2C, 0x11, 0x0C,
	0x0E, 0x01, 0x03, 0x03, 0x0A, 0x07, 0x05, 0x07, 0x02, 0x38, 0x61, 0x28, 0x2A, 0x45, 0x1B, 0x20,
	0x1B, 0x1D, 0x17, 0x53, 0x3A, 0x1A, 0x20, 0x41, 0x21, 0x20, 0x3A, 0x1B, 0x1E, 0x3B, 0x1C, 0x0A,
	0x02, 0x03, 0x04, 0x05, 0x0F, 0x16, 0x13, 0x0E, 0x13, 0x0E, 0x21, 0x03, 0x07, 0x0B, 0x0D, 0xAE,
	0x06, 0x06, 0x06, 0x06, 0x05, 0x0D, 0x07, 0x09, 0x0F, 0x07, 0x05, 0x05, 0x01, 0x06, 0x05, 0x06,
	0x10, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x4D, 0x00, 0x55, 0x0A, 0xE2, 0x03, 0x29, 0x01, 0xB8,
	0x01, 0xC8, 0x00, 0x00, 0x01, 0x06, 0x26, 0x27, 0x22, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01,
	0x23, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x27, 0x26, 0x06, 0x07, 0x06, 0x26, 0x15, 0x14, 0x16, 0x07,
	0x06, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x15, 0x14, 0x22, 0x07, 0x22, 0x26, 0x27, 0x2A,
	0x01, 0x27, 0x2E, 0x01, 0x27, 0x36, 0x22, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x06,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x22, 0x26, 0x27, 0x26, 0x36, 0x23, 0x2A, 0x01, 0x23,
	0x2A, 0x01, 0x23, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E,
	0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x3E, 0x01,
	0x37, 0x2A, 0x01, 0x23, 0x22, 0x16, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07,
	0x06, 0x26, 0x27, 0x26, 0x22, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x07,
	0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x2E, 0x01, 0x35, 0x34, 0x36, 0x37, 0x36,
	0x26, 0x37, 0x36, 0x26, 0x27, 0x34, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x34, 0x26, 0x27, 0x2E, 0x01,
	0x35, 0x34, 0x36, 0x37, 0x36, 0x32, 0x33, 0x32, 0x36, 0x33, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x37,
	0x32, 0x36, 0x37, 0x32, 0x36, 0x33, 0x32, 0x36, 0x33, 0x32, 0x36, 0x17, 0x1E, 0x01, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x33, 0x36, 0x16, 0x37, 0x3A, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16,
	0x17, 0x1E, 0x01, 0x07, 0x16, 0x36, 0x35, 0x34, 0x26, 0x27, 0x2E, 0x01, 0x35, 0x0E, 0x01, 0x07,
	0x06, 0x26, 0x23, 0x2A, 0x01, 0x27, 0x22, 0x26, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x3C,
	0x01, 0x37, 0x34, 0x36, 0x37, 0x36, 0x16, 0x33, 0x32, 0x16, 0x33, 0x16, 0x36, 0x17, 0x1E, 0x01,
	0x37, 0x3E, 0x01, 0x33, 0x3E, 0x01, 0x33, 0x3A, 0x01, 0x37, 0x3A, 0x01, 0x37, 0x3E, 0x01, 0x37,
	0x36, 0x16, 0x17, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E,
	0x01, 0x33, 0x32, 0x16, 0x17, 0x16, 0x14, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x23, 0x22, 0x26,
	0x27, 0x2E, 0x01, 0x07, 0x06, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x22, 0x07, 0x0E, 0x01, 0x07,
	0x3A, 0x03, 0x33, 0x32, 0x36, 0x37, 0x3A, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x33, 0x3A,
	0x01, 0x17, 0x1E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x2E, 0x01, 0x37, 0x3E, 0x01,
	0x37, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x15, 0x1C, 0x01, 0x17, 0x16, 0x14, 0x07,
	0x32, 0x36, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x33, 0x16, 0x32, 0x33, 0x3A, 0x01, 0x33, 0x3A,
	0x01, 0x33, 0x32, 0x36, 0x17, 0x16, 0x14, 0x17, 0x16, 0x06, 0x07, 0x05, 0x06, 0x16, 0x33, 0x32,
	0x36, 0x37, 0x3E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x22, 0x06, 0x07, 0x0A, 0xD5, 0x24, 0x49, 0x24,
	0x05, 0x08, 0x05, 0x0A, 0x14, 0x0A, 0x18, 0x31, 0x18, 0x08, 0x04, 0x07, 0x07, 0x0F, 0x08, 0x16,
	0x0E, 0x07, 0x04, 0x11, 0x02, 0x0C, 0x0E, 0x20, 0x0F, 0x0D, 0x18, 0x0D, 0x06, 0x19, 0x02, 0x07,
	0x05, 0x0A, 0x05, 0x04, 0x09, 0x04, 0x06, 0x02, 0x01, 0x06, 0x1C, 0x04, 0x16, 0x2A, 0x15, 0x33,
	0x67, 0x33, 0x1C, 0x36, 0x1C, 0x08, 0x10, 0x08, 0x09, 0x1B, 0x08, 0x04, 0x08, 0x03, 0x02, 0x01,
	0x01, 0x08, 0x10, 0x07, 0x1D, 0x39, 0x1D, 0x03, 0x07, 0x03, 0x01, 0x10, 0x0C, 0x24, 0x4B, 0x25,
	0x0A, 0x2B, 0x02, 0x03, 0x03, 0x02, 0x03, 0x05, 0x02, 0x01, 0x02, 0x01, 0x01, 0x12, 0x01, 0x03,
	0x08, 0x08, 0x02, 0x04, 0x03, 0x05, 0x0A, 0x05, 0x04, 0x01, 0x01, 0x04, 0x06, 0x05, 0x03, 0x0E,
	0x0A, 0x0C, 0x17, 0x0B, 0x07, 0x0B, 0x07, 0x07, 0x19, 0x06, 0x07, 0x0F, 0x08, 0x02, 0x09, 0x02,
	0x04, 0x06, 0x01, 0x10, 0x1D, 0x10, 0x04, 0x0B, 0x07, 0x08, 0x21, 0x06, 0x11, 0x21, 0x10, 0x02,
	0x05, 0x03, 0x0B, 0x0E, 0x08, 0x0C, 0x22, 0x0D, 0x0B, 0x08, 0x1A, 0x17, 0x2D, 0x16, 0x13, 0x25,
	0x12, 0x0F, 0x1E, 0x0E, 0x20, 0x3E, 0x1F, 0x48, 0x90, 0x48, 0x20, 0x42, 0x22, 0x1C, 0x0C, 0x06,
	0x02, 0x01, 0x02, 0x02, 0x07, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x02, 0x02, 0x01,
	0x12, 0x08, 0x12, 0x25, 0x12, 0x09, 0x10, 0x09, 0x06, 0x07, 0x04, 0x0C, 0x30, 0x0F, 0x23, 0x46,
	0x23, 0x14, 0x26, 0x13, 0x0A, 0x13, 0x0A, 0x03, 0x1B, 0x02, 0x0A, 0x11, 0x13, 0x11, 0x1E, 0x0F,
	0x11, 0x29, 0x16, 0x11, 0x23, 0x11, 0x0A, 0x10, 0x06, 0x07, 0x0A, 0x0A, 0x0F, 0x1D, 0x0F, 0x07,
	0x16, 0x0D, 0x09, 0x01, 0x0A, 0x03, 0x05, 0x0A, 0x12, 0x25, 0x13, 0x0F, 0x1F, 0x10, 0x13, 0x28,
	0x14, 0x11, 0x23, 0x10, 0x14, 0x27, 0x13, 0x05, 0x04, 0x01, 0x01, 0x07, 0x01, 0x02, 0x33, 0x0A,
	0x23, 0x46, 0x23, 0x24, 0x4B, 0x24, 0x10, 0x23, 0x11, 0x14, 0x27, 0x14, 0x11, 0x21, 0x10, 0x09,
	0x11, 0x09, 0x03, 0x09, 0x02, 0x07, 0x03, 0x0A, 0x0F, 0x1E, 0x0F, 0x04, 0x05, 0x02, 0x03, 0x0E,
	0x05, 0x10, 0x22, 0x10, 0x27, 0x4D, 0x26, 0x12, 0x25, 0x12, 0x0E, 0x2F, 0x09, 0x09, 0x04, 0x03,
	0x0C, 0x06, 0x04, 0x3F, 0x07, 0x14, 0x27, 0x13, 0x16, 0x2A, 0x15, 0x08, 0x19, 0x08, 0x03, 0x06,
	0x01, 0x04, 0x03, 0x05, 0x13, 0x2B, 0x07, 0x4C, 0x99, 0x99, 0x99, 0x4D, 0x16, 0x2C, 0x16, 0x07,
	0x0E, 0x07, 0x0A, 0x07, 0x08, 0x06, 0x0F, 0x07, 0x0A, 0x09, 0x07, 0x09, 0x07, 0x0E, 0x13, 0x27,
	0x13, 0x20, 0x40, 0x20, 0x02, 0x0C, 0x08, 0x06, 0x0D, 0x08, 0x05, 0x15, 0x01, 0x06, 0x07, 0x03,
	0x01, 0x01, 0x06, 0x04, 0x03, 0x04, 0x09, 0x02, 0x04, 0x07, 0x04, 0x05, 0x02, 0x04, 0x06, 0x0E,
	0x06, 0x23, 0x45, 0x22, 0x22, 0x44, 0x22, 0x06, 0x0E, 0x03, 0x03, 0x01, 0x01, 0x02, 0x0B, 0xF9,
	0x45, 0x10, 0x3E, 0x09, 0x13, 0x2A, 0x08, 0x03, 0x07, 0x0F, 0x0B, 0x11, 0x0C, 0x14, 0x28, 0x13,
	0x01, 0xDD, 0x05, 0x02, 0x03, 0x05, 0x02, 0x04, 0x04, 0x05, 0x04, 0x0A, 0x1C, 0x0E, 0x08, 0x0D,
	0x0E, 0x0B, 0x13, 0x04, 0x04, 0x09, 0x02, 0x07, 0x09, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x06,
	0x05, 0x05, 0x02, 0x01, 0x01, 0x01, 0x01, 0x07, 0x02, 0x07, 0x03, 0x01, 0x09, 0x26, 0x4C, 0x26,
	0x0C, 0x76, 0x03, 0x09, 0x0E, 0x05, 0x02, 0x0A, 0x0F, 0x12, 0x24, 0x12, 0x1C, 0x38, 0x1C, 0x0E,
	0x1B, 0x0E, 0x01, 0x01, 0x02, 0x06, 0x0E, 0x02, 0x05, 0x09, 0x05, 0x04, 0x03, 0x0B, 0x16, 0x0A,
	0x09, 0x19, 0x02, 0x03, 0x04, 0x02, 0x02, 0x01, 0x01, 0x01, 0x04, 0x05, 0x08, 0x04, 0x01, 0x06,
	0x01, 0x0D, 0x02, 0x21, 0x41, 0x1F, 0x07, 0x0B, 0x03, 0x03, 0x15, 0x05, 0x0C, 0x17, 0x0C, 0x02,
	0x03, 0x01, 0x0D, 0x23, 0x0E, 0x16, 0x1D, 0x13, 0x11, 0x36, 0x0C, 0x04, 0x0B, 0x16, 0x0C, 0x1C,
	0x34, 0x1A, 0x0B, 0x0E, 0x01, 0x1E, 0x17, 0x0C, 0x14, 0x0C, 0x07, 0x12, 0x08, 0x12, 0x23, 0x13,
	0x07, 0x0E, 0x07, 0x05, 0x0B, 0x05, 0x02, 0x04, 0x03, 0x09, 0x11, 0x08, 0x0A, 0x05, 0x02, 0x05,
	0x01, 0x01, 0x1B, 0x05, 0x0B, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x02, 0x03, 0x0C, 0x1F, 0x07,
	0x05, 0x10, 0x09, 0x0B, 0x1A, 0x01, 0x01, 0x01, 0x07, 0x09, 0x0B, 0x06, 0x08, 0x09, 0x04, 0x01,
	0x18, 0x04, 0x02, 0x08, 0x07, 0x06, 0x07, 0x05, 0x09, 0x18, 0x0B, 0x03, 0x05, 0x03, 0x03, 0x02,
	0x01, 0x02, 0x02, 0x03, 0x04, 0x01, 0x01, 0x34, 0x07, 0x0A, 0x12, 0x0A, 0x08, 0x0E, 0x07, 0x0C,
	0x04, 0x03, 0x02, 0x02, 0x06, 0x02, 0x08, 0x02, 0x01, 0x02, 0x01, 0x01, 0x02, 0x01, 0x05, 0x0A,
	0x03, 0x07, 0x07, 0x02, 0x08, 0x02, 0x04, 0x04, 0x01, 0x03, 0x01, 0x01, 0x02, 0x07, 0x04, 0x01,
	0x01, 0x02, 0x0D, 0x0D, 0x2E, 0x0E, 0x0A, 0x13, 0x08, 0x07, 0x03, 0x01, 0x02, 0x03, 0x07, 0x04,
	0x02, 0x06, 0x04, 0x02, 0x0D, 0x03, 0x06, 0x02, 0x0B, 0x16, 0x16, 0x08, 0x01, 0x02, 0x02, 0x05,
	0x05, 0x04, 0x01, 0x08, 0x0D, 0x03, 0x09, 0x27, 0x08, 0x06, 0x0E, 0x02, 0x01, 0x04, 0x04, 0x11,
	0x20, 0x12, 0x06, 0x0E, 0x07, 0x06, 0x01, 0x03, 0x03, 0x0B, 0x04, 0x05, 0x03, 0x02, 0x01, 0x05,
	0x04, 0x13, 0x05, 0x09, 0x16, 0x03, 0x8B, 0x10, 0x12, 0x01, 0x16, 0x0A, 0x16, 0x03, 0x02, 0x05,
	0x06, 0x05, 0x00, 0x00, 0x00, 0x08, 0x00, 0x4A, 0x00, 0x5A, 0x0A, 0xD5, 0x03, 0x26, 0x00, 0x06,
	0x00, 0x0C, 0x01, 0xE7, 0x01, 0xFA, 0x02, 0x0D, 0x02, 0x1F, 0x02, 0x28, 0x02, 0x2E, 0x00, 0x00,
	0x01, 0x22, 0x27, 0x31, 0x30, 0x31, 0x16, 0x37, 0x22, 0x06, 0x23, 0x32, 0x36, 0x25, 0x06, 0x26,
	0x23, 0x22, 0x26, 0x07, 0x2E, 0x01, 0x07, 0x22, 0x06, 0x07, 0x36, 0x06, 0x23, 0x22, 0x06, 0x27,
	0x06, 0x26, 0x23, 0x2A, 0x01, 0x27, 0x06, 0x16, 0x07, 0x3C, 0x01, 0x33, 0x0E, 0x01, 0x35, 0x34,
	0x06, 0x33, 0x22, 0x26, 0x27, 0x16, 0x26, 0x33, 0x22, 0x06, 0x07, 0x36, 0x22, 0x17, 0x2E, 0x01,
	0x23, 0x32, 0x06, 0x37, 0x22, 0x06, 0x17, 0x26, 0x36, 0x23, 0x22, 0x06, 0x35, 0x34, 0x06, 0x07,
	0x34, 0x22, 0x17, 0x2E, 0x01, 0x27, 0x32, 0x06, 0x35, 0x2B, 0x01, 0x34, 0x06, 0x35, 0x34, 0x06,
	0x07, 0x0E, 0x01, 0x07, 0x06, 0x1E, 0x02, 0x15, 0x16, 0x06, 0x23, 0x22, 0x16, 0x15, 0x1C, 0x01,
	0x15, 0x14, 0x06, 0x17, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x23, 0x22, 0x06, 0x07,
	0x2A, 0x01, 0x23, 0x0E, 0x01, 0x07, 0x06, 0x14, 0x15, 0x06, 0x16, 0x07, 0x06, 0x22, 0x07, 0x06,
	0x07, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x16, 0x26, 0x27, 0x2E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x27, 0x26, 0x06, 0x23, 0x2E, 0x01, 0x23, 0x22, 0x06, 0x07, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x27,
	0x26, 0x36, 0x23, 0x22, 0x26, 0x07, 0x06, 0x16, 0x15, 0x14, 0x06, 0x27, 0x16, 0x06, 0x27, 0x32,
	0x16, 0x15, 0x06, 0x36, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x26, 0x27, 0x34, 0x26, 0x35, 0x34, 0x26,
	0x33, 0x32, 0x36, 0x07, 0x16, 0x36, 0x17, 0x16, 0x06, 0x15, 0x1C, 0x01, 0x15, 0x30, 0x17, 0x16,
	0x35, 0x34, 0x16, 0x37, 0x36, 0x26, 0x23, 0x22, 0x06, 0x27, 0x26, 0x36, 0x37, 0x36, 0x16, 0x33,
	0x3A, 0x01, 0x33, 0x32, 0x36, 0x17, 0x16, 0x36, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x07, 0x06, 0x26, 0x07, 0x06, 0x36, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x33, 0x32, 0x16,
	0x37, 0x36, 0x26, 0x37, 0x36, 0x16, 0x33, 0x32, 0x36, 0x23, 0x22, 0x06, 0x27, 0x26, 0x36, 0x33,
	0x32, 0x36, 0x33, 0x36, 0x16, 0x17, 0x16, 0x06, 0x33, 0x32, 0x36, 0x17, 0x16, 0x06, 0x17, 0x16,
	0x36, 0x33, 0x37, 0x36, 0x27, 0x26, 0x06, 0x23, 0x26, 0x06, 0x27, 0x26, 0x36, 0x35, 0x34, 0x26,
	0x37, 0x36, 0x16, 0x33, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x35, 0x34, 0x16, 0x33, 0x32, 0x06, 0x33,
	0x32, 0x16, 0x37, 0x36, 0x26, 0x17, 0x26, 0x36, 0x17, 0x26, 0x36, 0x33, 0x32, 0x06, 0x17, 0x1E,
	0x01, 0x37, 0x36, 0x26, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x06, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x06, 0x17, 0x16, 0x06, 0x15, 0x1C, 0x01, 0x15,
	0x14, 0x26, 0x23, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x22, 0x23, 0x22,
	0x06, 0x07, 0x06, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x26, 0x37, 0x36, 0x26,
	0x37, 0x36, 0x16, 0x33, 0x32, 0x16, 0x17, 0x26, 0x16, 0x17, 0x16, 0x06, 0x33, 0x3A, 0x01, 0x33,
	0x3A, 0x01, 0x33, 0x32, 0x16, 0x07, 0x16, 0x06, 0x15, 0x14, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x32,
	0x26, 0x33, 0x32, 0x16, 0x37, 0x1E, 0x01, 0x17, 0x3C, 0x01, 0x35, 0x16, 0x36, 0x33, 0x3A, 0x01,
	0x33, 0x32, 0x36, 0x17, 0x14, 0x16, 0x07, 0x05, 0x34, 0x26, 0x23, 0x22, 0x26, 0x07, 0x14, 0x06,
	0x17, 0x16, 0x06, 0x33, 0x3A, 0x01, 0x37, 0x26, 0x36, 0x35, 0x05, 0x34, 0x26, 0x07, 0x0E, 0x01,
	0x17, 0x06, 0x36, 0x07, 0x0E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x35, 0x13, 0x26, 0x06,
	0x15, 0x22, 0x26, 0x23, 0x2E, 0x01, 0x07, 0x06, 0x16, 0x07, 0x32, 0x16, 0x33, 0x34, 0x36, 0x05,
	0x22, 0x26, 0x07, 0x3A, 0x01, 0x33, 0x3C, 0x01, 0x05, 0x22, 0x23, 0x07, 0x32, 0x36, 0x06, 0xA4,
	0x01, 0x01, 0x01, 0x11, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x20, 0x07, 0x3A, 0x12, 0x13, 0x9A,
	0x01, 0x08, 0x09, 0x0C, 0x0A, 0x07, 0x0C, 0x05, 0x5B, 0x0E, 0x24, 0x53, 0x22, 0x07, 0x8E, 0x13,
	0x36, 0x6C, 0x36, 0x01, 0x03, 0x07, 0x01, 0x05, 0x12, 0x17, 0x04, 0x09, 0x04, 0x0A, 0x06, 0x17,
	0x02, 0x0A, 0x02, 0x08, 0x05, 0x1B, 0x05, 0x08, 0x02, 0x0A, 0x02, 0x16, 0x06, 0x01, 0x13, 0x08,
	0x0B, 0x01, 0x0B, 0x01, 0x0C, 0x11, 0x05, 0x1B, 0x09, 0x0A, 0x04, 0x0C, 0x01, 0x22, 0x25, 0x24,
	0x31, 0x15, 0x04, 0x0D, 0x15, 0x05, 0x02, 0x01, 0x02, 0x08, 0x01, 0x03, 0x0A, 0x06, 0x02, 0x05,
	0x07, 0x2E, 0x5B, 0x2E, 0x08, 0x04, 0x03, 0x0B, 0x07, 0x09, 0x05, 0x1D, 0x3C, 0x1D, 0x0D, 0x12,
	0x03, 0x01, 0x01, 0x05, 0x02, 0x02, 0x0F, 0x03, 0x05, 0x03, 0x03, 0x02, 0x06, 0x0F, 0x04, 0x14,
	0x62, 0x0F, 0x12, 0x15, 0x05, 0x02, 0x0C, 0x04, 0x14, 0x22, 0x13, 0x0A, 0x14, 0x0D, 0x0E, 0x3C,
	0x17, 0x16, 0x21, 0x16, 0x1B, 0x2A, 0x13, 0x06, 0x0B, 0x06, 0x0F, 0x09, 0x06, 0x07, 0x3C, 0x1F,
	0x1C, 0x39, 0x1C, 0x16, 0x49, 0x15, 0x04, 0x04, 0x04, 0x06, 0x0A, 0x0E, 0x0A, 0x23, 0x05, 0x03,
	0x03, 0x0E, 0x19, 0x02, 0x09, 0x0C, 0x01, 0x01, 0x20, 0x10, 0x02, 0x02, 0x03, 0x08, 0x09, 0x09,
	0x23, 0x08, 0x12, 0x13, 0x05, 0x03, 0x03, 0x21, 0x21, 0x61, 0x05, 0x02, 0x0D, 0x0D, 0x17, 0x26,
	0x06, 0x05, 0x03, 0x09, 0x07, 0x17, 0x0A, 0x21, 0x42, 0x22, 0x27, 0x52, 0x26, 0x16, 0x42, 0x07,
	0x02, 0x13, 0x05, 0x09, 0x16, 0x0C, 0x06, 0x12, 0x08, 0x14, 0x62, 0x03, 0x03, 0x6B, 0x15, 0x07,
	0x0D, 0x04, 0x0E, 0x36, 0x15, 0x13, 0x2D, 0x0B, 0x04, 0x01, 0x04, 0x05, 0x15, 0x07, 0x0E, 0x09,
	0x11, 0x02, 0x1D, 0x02, 0x06, 0x08, 0x07, 0x0F, 0x23, 0x0C, 0x08, 0x0D, 0x05, 0x07, 0x04, 0x10,
	0x0A, 0x21, 0x07, 0x03, 0x03, 0x02, 0x0F, 0x3E, 0x12, 0x02, 0x03, 0x03, 0x0B, 0x17, 0x0D, 0x2C,
	0x61, 0x2A, 0x09, 0x03, 0x02, 0x02, 0x05, 0x46, 0x07, 0x23, 0x44, 0x1E, 0x06, 0x0F, 0x37, 0x0C,
	0x0F, 0x0E, 0x11, 0x0A, 0x18, 0x0A, 0x05, 0x05, 0x11, 0x03, 0x01, 0x09, 0x03, 0x0B, 0x0E, 0x18,
	0x04, 0x05, 0x06, 0x24, 0x16, 0x03, 0x08, 0x0C, 0x0D, 0x1B, 0x0E, 0x12, 0x0A, 0x17, 0x17, 0x22,
	0x15, 0x19, 0x34, 0x1A, 0x17, 0x1E, 0x1E, 0x1A, 0x35, 0x1B, 0x0F, 0x01, 0x02, 0x04, 0x04, 0x12,
	0x0F, 0x28, 0x57, 0x27, 0x0D, 0x1D, 0x0D, 0x0F, 0x1C, 0x0E, 0x10, 0x1F, 0x10, 0x19, 0x02, 0x04,
	0x03, 0x01, 0x0F, 0x3C, 0x76, 0x3B, 0x25, 0x49, 0x25, 0x10, 0x06, 0x04, 0x02, 0x03, 0x05, 0x06,
	0x2F, 0x0B, 0x09, 0x10, 0x06, 0x01, 0x20, 0x05, 0x0A, 0x05, 0x1B, 0x25, 0x48, 0x25, 0x18, 0x2F,
	0x18, 0x09, 0x13, 0x12, 0x09, 0x01, 0x09, 0x1C, 0x34, 0x67, 0x34, 0x0D, 0x05, 0x0A, 0x03, 0x17,
	0x01, 0x02, 0x09, 0x03, 0x18, 0x50, 0x24, 0x09, 0x12, 0x11, 0x0E, 0x41, 0x03, 0x02, 0x02, 0xF6,
	0x11, 0x05, 0x11, 0x0B, 0x1B, 0x06, 0x02, 0x02, 0x03, 0x03, 0x13, 0x0E, 0x19, 0x08, 0x02, 0x02,
	0x03, 0x7D, 0x2C, 0x19, 0x11, 0x02, 0x05, 0x20, 0x12, 0x1A, 0x06, 0x01, 0x12, 0x0F, 0x4C, 0x0C,
	0x07, 0x02, 0xAB, 0x0B, 0x3A, 0x0A, 0x15, 0x0B, 0x01, 0x42, 0x09, 0x05, 0x03, 0x01, 0x30, 0x5E,
	0x30, 0x03, 0x02, 0x44, 0x0B, 0x1B, 0x04, 0x0A, 0x16, 0x0A, 0xFE, 0xE9, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0xA9, 0x01, 0x01, 0x01, 0x01, 0x01, 0x2E, 0x0D, 0x05, 0x05, 0x0F, 0x05, 0x02, 0x01,
	0x06, 0x01, 0x16, 0x07, 0x06, 0x08, 0x10, 0x09, 0x01, 0x0C, 0x18, 0x05, 0x01, 0x01, 0x01, 0x02,
	0x06, 0x0D, 0x11, 0x06, 0x02, 0x01, 0x01, 0x04, 0x02, 0x01, 0x01, 0x02, 0x04, 0x01, 0x01, 0x07,
	0x02, 0x02, 0x07, 0x0D, 0x0A, 0x06, 0x07, 0x02, 0x01, 0x02, 0x02, 0x03, 0x02, 0x06, 0x03, 0x09,
	0x17, 0x0E, 0x05, 0x0A, 0x02, 0x04, 0x07, 0x0C, 0x05, 0x1A, 0x0B, 0x0C, 0x02, 0x0B, 0x0E, 0x17,
	0x05, 0x11, 0x23, 0x12, 0x1E, 0x49, 0x1B, 0x2B, 0x0A, 0x0F, 0x7E, 0x08, 0x01, 0x01, 0x0D, 0x0B,
	0x03, 0x0A, 0x01, 0x01, 0x0B, 0x04, 0x02, 0x03, 0x04, 0x07, 0x06, 0x05, 0x0A, 0x19, 0x0B, 0x24,
	0x17, 0x04, 0x06, 0x06, 0x11, 0x08, 0x0B, 0x07, 0x20, 0x35, 0x1E, 0x0F, 0x1D, 0x12, 0x14, 0x03,
	0x01, 0x0B, 0x02, 0x0C, 0x04, 0x0C, 0x07, 0x10, 0x0E, 0x15, 0x1D, 0x07, 0x08, 0x08, 0x02, 0x0C,
	0x03, 0x04, 0x04, 0x03, 0x07, 0x05, 0x22, 0x07, 0x19, 0x02, 0x01, 0x0A, 0x0C, 0x03, 0x01, 0x01,
	0x0A, 0x44, 0x0B, 0x1B, 0x37, 0x1B, 0x18, 0x2E, 0x16, 0x08, 0x14, 0x05, 0x07, 0x0E, 0x01, 0x0B,
	0x02, 0x02, 0x0E, 0x08, 0x18, 0x08, 0x0A, 0x12, 0x09, 0x04, 0x05, 0x10, 0x1F, 0x22, 0x1C, 0x0F,
	0x02, 0x03, 0x12, 0x11, 0x58, 0x07, 0x05, 0x01, 0x04, 0x02, 0x01, 0x05, 0x1B, 0x09, 0x13, 0x07,
	0x0B, 0x1E, 0x0A, 0x05, 0x0F, 0x03, 0x07, 0x12, 0x19, 0x17, 0x07, 0x10, 0x04, 0x0F, 0x4F, 0x03,
	0x0B, 0x03, 0x10, 0x03, 0x04, 0x02, 0x0C, 0x02, 0x02, 0x07, 0x0D, 0x05, 0x01, 0x02, 0x02, 0x02,
	0x08, 0x02, 0x04, 0x02, 0x11, 0x01, 0x08, 0x07, 0x21, 0x21, 0x05, 0x0F, 0x16, 0x01, 0x06, 0x06,
	0x01, 0x32, 0x09, 0x03, 0x19, 0x03, 0x05, 0x07, 0x03, 0x05, 0x01, 0x08, 0x10, 0x0E, 0x05, 0x14,
	0x03, 0x03, 0x02, 0x0F, 0x04, 0x08, 0x0E, 0x01, 0x10, 0x07, 0x09, 0x11, 0x11, 0x12, 0x0A, 0x02,
	0x0B, 0x12, 0x06, 0x06, 0x06, 0x0B, 0x06, 0x04, 0x01, 0x07, 0x0C, 0x11, 0x29, 0x12, 0x09, 0x12,
	0x09, 0x11, 0x02, 0x05, 0x08, 0x03, 0x0C, 0x02, 0x04, 0x08, 0x03, 0x03, 0x01, 0x11, 0x0F, 0x2A,
	0x07, 0x0C, 0x07, 0x0A, 0x04, 0x07, 0x04, 0x06, 0x06, 0x14, 0x0E, 0x06, 0x0D, 0x12, 0x0E, 0x04,
	0x08, 0x16, 0x11, 0x1A, 0x07, 0x0B, 0x12, 0x12, 0x02, 0x04, 0x04, 0x03, 0x05, 0x03, 0x0D, 0x02,
	0x05, 0x0C, 0x06, 0x14, 0x05, 0x4A, 0x0F, 0x04, 0x01, 0x05, 0x0F, 0x1F, 0x0F, 0x0E, 0x07, 0x06,
	0x0D, 0x21, 0x0F, 0x47, 0x20, 0x0C, 0x13, 0x0C, 0x1E, 0x12, 0x02, 0x50, 0x08, 0x0E, 0x31, 0x09,
	0x07, 0x01, 0x09, 0x06, 0x10, 0x0C, 0x01, 0x63, 0x0A, 0x15, 0x04, 0x01, 0x07, 0x10, 0x09, 0x05,
	0x1F, 0x08, 0x01, 0x05, 0x24, 0x41, 0x02, 0x08, 0x01, 0x04, 0xBA, 0x01, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x62, 0x00, 0x8D, 0x0D, 0x2B, 0x02, 0xF3, 0x00, 0xA4, 0x00, 0xB2, 0x00, 0x00,
	0x01, 0x2F, 0x01, 0x35, 0x21, 0x35, 0x37, 0x17, 0x35, 0x17, 0x33, 0x2F, 0x02, 0x0F, 0x02, 0x23,
	0x35, 0x32, 0x36, 0x3F, 0x01, 0x27, 0x23, 0x07, 0x15, 0x17, 0x15, 0x0F, 0x01, 0x23, 0x27, 0x0F,
	0x02, 0x23, 0x07, 0x0E, 0x01, 0x1D, 0x01, 0x17, 0x15, 0x1F, 0x01, 0x3F, 0x02, 0x33, 0x15, 0x23,
	0x0E, 0x01, 0x0F, 0x03, 0x23, 0x15, 0x0F, 0x01, 0x21, 0x27, 0x2E, 0x01, 0x23, 0x21, 0x0F, 0x03,
	0x23, 0x07, 0x0E, 0x01, 0x1D, 0x01, 0x07, 0x15, 0x1F, 0x01, 0x33, 0x3F, 0x03, 0x33, 0x17, 0x37,
	0x32, 0x36, 0x35, 0x37, 0x33, 0x1F, 0x05, 0x3F, 0x04, 0x33, 0x37, 0x1E, 0x01, 0x17, 0x3F, 0x02,
	0x3E, 0x01, 0x33, 0x15, 0x25, 0x35, 0x3E, 0x01, 0x3F, 0x03, 0x17, 0x0E, 0x01, 0x23, 0x2E, 0x01,
	0x2B, 0x01, 0x22, 0x06, 0x15, 0x06, 0x16, 0x1F, 0x02, 0x33, 0x37, 0x2F, 0x01, 0x37, 0x21, 0x37,
	0x35, 0x3F, 0x01, 0x34, 0x26, 0x2F, 0x01, 0x35, 0x23, 0x35, 0x21, 0x37, 0x3E, 0x01, 0x35, 0x27,
	0x05, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x3B, 0x01, 0x32, 0x16, 0x15, 0x14, 0x06, 0x0D, 0x27,
	0x04, 0x06, 0xF8, 0x92, 0x37, 0x21, 0xE0, 0x07, 0x02, 0x05, 0x26, 0x46, 0x4B, 0x37, 0xA7, 0x02,
	0x05, 0x01, 0x03, 0x0B, 0x02, 0x5F, 0x02, 0x20, 0x32, 0x64, 0x2E, 0x41, 0x37, 0x18, 0x06, 0x02,
	0x02, 0x02, 0x04, 0x02, 0x38, 0x41, 0x37, 0x1D, 0x24, 0x61, 0x03, 0x03, 0x01, 0x0B, 0x25, 0x2D,
	0x02, 0x06, 0x09, 0xFE, 0xC8, 0x1F, 0x04, 0x0A, 0x04, 0xFE, 0xED, 0x09, 0x06, 0x03, 0x02, 0x1E,
	0x67, 0x0B, 0x0C, 0x06, 0x03, 0x03, 0x08, 0x1C, 0x25, 0x23, 0x16, 0x4D, 0x28, 0x0D, 0x03, 0x04,
	0x0C, 0x97, 0x16, 0x22, 0x21, 0x2B, 0x4F, 0x51, 0x36, 0x10, 0x0E, 0x08, 0x01, 0x09, 0x05, 0x13,
	0x22, 0x0F, 0x35, 0x21, 0x14, 0x02, 0x0D, 0x0A, 0x01, 0x08, 0x01, 0x0E, 0x0C, 0x37, 0x35, 0x1D,
	0xDF, 0x0A, 0x13, 0x09, 0x03, 0x12, 0x0E, 0x04, 0x07, 0x07, 0x04, 0x01, 0x06, 0x0F, 0x05, 0x2F,
	0x05, 0x08, 0x05, 0x05, 0x01, 0xD9, 0x06, 0x03, 0x01, 0x05, 0x05, 0x0D, 0x5A, 0x04, 0xC8, 0x04,
	0x07, 0x07, 0x04, 0xF6, 0xF3, 0x40, 0x0D, 0x0E, 0x0E, 0x0D, 0x40, 0x0E, 0x0D, 0x0D, 0x02, 0x26,
	0x0C, 0x0C, 0x05, 0x1A, 0x01, 0x05, 0x04, 0x0E, 0x84, 0x03, 0x05, 0x06, 0x08, 0x08, 0x06, 0x02,
	0x02, 0x04, 0x20, 0x06, 0x12, 0x06, 0x13, 0x03, 0x01, 0x04, 0x04, 0x03, 0x03, 0x02, 0x02, 0x06,
	0x05, 0x1F, 0x31, 0x04, 0x06, 0x03, 0x06, 0x07, 0x04, 0x1E, 0x01, 0x02, 0x01, 0x03, 0x07, 0x08,
	0x06, 0x1D, 0x1D, 0x1F, 0x05, 0x05, 0x07, 0x03, 0x02, 0x03, 0x07, 0x05, 0x09, 0x05, 0x4C, 0x67,
	0x84, 0x14, 0x03, 0x05, 0x08, 0x06, 0x04, 0x08, 0x08, 0x04, 0x05, 0x4A, 0x10, 0x20, 0x22, 0x0F,
	0x0D, 0x0A, 0x06, 0x17, 0x2B, 0x2F, 0x23, 0x03, 0x0C, 0x0D, 0x01, 0x06, 0x11, 0x0F, 0x03, 0x03,
	0x53, 0x1C, 0x50, 0x02, 0x05, 0x03, 0x0F, 0x0F, 0x08, 0x03, 0x04, 0x05, 0x04, 0x04, 0x07, 0x07,
	0x08, 0x16, 0x0D, 0x23, 0x06, 0x11, 0x09, 0x03, 0x0C, 0x0D, 0x04, 0x03, 0x09, 0x0A, 0x0E, 0x04,
	0x0D, 0x4E, 0x15, 0x06, 0x0A, 0x10, 0x06, 0x0F, 0xE8, 0x0F, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0E,
	0x0F, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x55, 0x00, 0x3E, 0x0C, 0x0F, 0x03, 0x42, 0x01, 0x89,
	0x01, 0x9C, 0x01, 0xA5, 0x01, 0xB1, 0x00, 0x00, 0x01, 0x34, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x2A,
	0x03, 0x23, 0x2A, 0x03, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x35, 0x3C, 0x01, 0x35, 0x3C, 0x01,
	0x35, 0x34, 0x36, 0x27, 0x26, 0x06, 0x23, 0x22, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23,
	0x2A, 0x01, 0x23, 0x36, 0x26, 0x35, 0x34, 0x36, 0x27, 0x26, 0x06, 0x23, 0x22, 0x14, 0x15, 0x1C,
	0x01, 0x15, 0x1C, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x36, 0x35, 0x34, 0x36,
	0x27, 0x26, 0x06, 0x23, 0x22, 0x16, 0x07, 0x06, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x14, 0x06, 0x17,
	0x16, 0x36, 0x17, 0x1E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x06, 0x07, 0x06, 0x22, 0x23, 0x0E,
	0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x22, 0x06,
	0x27, 0x26, 0x36, 0x37, 0x36, 0x34, 0x35, 0x34, 0x36, 0x35, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x23,
	0x2A, 0x01, 0x23, 0x22, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x1E, 0x01, 0x17, 0x2E, 0x01,
	0x07, 0x0E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x07, 0x06, 0x16, 0x15,
	0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x37, 0x36, 0x32, 0x37, 0x06,
	0x16, 0x35, 0x34, 0x26, 0x27, 0x3C, 0x01, 0x35, 0x34, 0x36, 0x33, 0x32, 0x16, 0x37, 0x3E, 0x01,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x32, 0x17, 0x16, 0x36, 0x35, 0x34, 0x36, 0x37,
	0x3E, 0x01, 0x33, 0x32, 0x36, 0x17, 0x16, 0x36, 0x33, 0x32, 0x16, 0x07, 0x0E, 0x01, 0x15, 0x14,
	0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x14, 0x15, 0x14, 0x06, 0x17, 0x1E, 0x01,
	0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x27, 0x26, 0x36, 0x37, 0x3E, 0x01, 0x37,
	0x3E, 0x01, 0x35, 0x1E, 0x01, 0x33, 0x3A, 0x02, 0x36, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x37,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x33, 0x3A, 0x02, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x06, 0x17,
	0x14, 0x16, 0x37, 0x14, 0x06, 0x17, 0x22, 0x06, 0x15, 0x06, 0x16, 0x33, 0x06, 0x14, 0x15, 0x14,
	0x06, 0x07, 0x06, 0x14, 0x15, 0x14, 0x16, 0x17, 0x16, 0x36, 0x37, 0x06, 0x16, 0x17, 0x22, 0x06,
	0x17, 0x16, 0x36, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x27, 0x36, 0x26, 0x27, 0x2E, 0x01, 0x27,
	0x2E, 0x01, 0x27, 0x3E, 0x01, 0x35, 0x34, 0x26, 0x27, 0x2E, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x34,
	0x36, 0x27, 0x26, 0x36, 0x35, 0x34, 0x36, 0x35, 0x34, 0x26, 0x37, 0x16, 0x3A, 0x01, 0x16, 0x33,
	0x3A, 0x01, 0x33, 0x16, 0x32, 0x33, 0x36, 0x16, 0x35, 0x3C, 0x01, 0x35, 0x01, 0x0E, 0x01, 0x23,
	0x22, 0x06, 0x07, 0x22, 0x26, 0x27, 0x26, 0x36, 0x35, 0x36, 0x16, 0x33, 0x32, 0x36, 0x07, 0x25,
	0x26, 0x36, 0x37, 0x1C, 0x01, 0x17, 0x06, 0x26, 0x17, 0x36, 0x26, 0x35, 0x3C, 0x01, 0x35, 0x26,
	0x16, 0x33, 0x0E, 0x01, 0x0C, 0x0F, 0x08, 0x0D, 0x23, 0x6E, 0x23, 0x3C, 0x79, 0x79, 0x79, 0x3C,
	0x43, 0x86, 0x86, 0x86, 0x43, 0x0F, 0x1E, 0x0F, 0x0A, 0x02, 0x07, 0x10, 0x12, 0x31, 0x13, 0x0D,
	0x33, 0x09, 0x07, 0x17, 0x0A, 0x0E, 0x20, 0x0E, 0x38, 0x70, 0x39, 0x04, 0x02, 0x04, 0x02, 0x06,
	0x3E, 0x0A, 0x0D, 0x04, 0x0D, 0x18, 0x0D, 0x21, 0x42, 0x20, 0x08, 0x01, 0x02, 0x03, 0x07, 0x36,
	0x0E, 0x10, 0x0D, 0x05, 0x06, 0x40, 0x0D, 0x09, 0x0C, 0x01, 0x03, 0x04, 0x06, 0x2C, 0x10, 0x14,
	0x30, 0x17, 0x0D, 0x1C, 0x0E, 0x02, 0x01, 0x01, 0x02, 0x0E, 0x03, 0x12, 0x23, 0x11, 0x0B, 0x1C,
	0x0D, 0x0E, 0x21, 0x10, 0x0F, 0x1F, 0x0F, 0x0D, 0x1B, 0x0F, 0x0B, 0x3F, 0x06, 0x03, 0x0A, 0x01,
	0x01, 0x04, 0x02, 0x12, 0x0C, 0x1E, 0x3D, 0x1E, 0x25, 0x4A, 0x25, 0x0D, 0x29, 0x0B, 0x0A, 0x04,
	0x01, 0x01, 0x03, 0x06, 0x08, 0x01, 0x0D, 0x20, 0x0D, 0x04, 0x06, 0x04, 0x06, 0x0D, 0x06, 0x13,
	0x27, 0x13, 0x05, 0x12, 0x03, 0x05, 0x03, 0x0F, 0x11, 0x1A, 0x33, 0x1A, 0x05, 0x6A, 0x08, 0x01,
	0x04, 0x0E, 0x07, 0x07, 0x07, 0x3C, 0x79, 0x3C, 0x08, 0x0F, 0x07, 0x07, 0x04, 0x09, 0x05, 0x29,
	0x02, 0x05, 0x19, 0x06, 0x06, 0x05, 0x06, 0x09, 0x07, 0x04, 0x0B, 0x0A, 0x16, 0x0B, 0x04, 0x0C,
	0x02, 0x01, 0x0C, 0x0C, 0x03, 0x05, 0x0A, 0x03, 0x03, 0x0C, 0x02, 0x03, 0x0F, 0x04, 0x09, 0x3A,
	0x13, 0x09, 0x20, 0x0A, 0x05, 0x17, 0x01, 0x04, 0x07, 0x02, 0x01, 0x04, 0x06, 0x05, 0x07, 0x04,
	0x03, 0x0B, 0x02, 0x06, 0x03, 0x36, 0x6B, 0x6C, 0x6A, 0x36, 0x05, 0x11, 0x03, 0x07, 0x0F, 0x05,
	0x05, 0x13, 0x06, 0x07, 0x0A, 0x0A, 0x3E, 0x7C, 0x7C, 0x7B, 0x3E, 0x32, 0x63, 0x31, 0x0A, 0x01,
	0x01, 0x09, 0x0C, 0x03, 0x04, 0x12, 0x06, 0x01, 0x0C, 0x13, 0x01, 0x14, 0x04, 0x06, 0x01, 0x0D,
	0x10, 0x27, 0x11, 0x07, 0x22, 0x02, 0x0E, 0x06, 0x05, 0x04, 0x2C, 0x08, 0x09, 0x07, 0x05, 0x04,
	0x0B, 0x08, 0x06, 0x0C, 0x05, 0x05, 0x07, 0x04, 0x05, 0x11, 0x0D, 0x01, 0x02, 0x03, 0x02, 0x04,
	0x01, 0x05, 0x03, 0x01, 0x06, 0x03, 0x02, 0x01, 0x36, 0x6C, 0x6B, 0x6C, 0x36, 0x3E, 0x7C, 0x3E,
	0x0B, 0x16, 0x0B, 0x16, 0x0C, 0xF5, 0xAF, 0x02, 0x1B, 0x05, 0x06, 0x07, 0x05, 0x03, 0x1B, 0x03,
	0x02, 0x03, 0x07, 0x2C, 0x0A, 0x09, 0x11, 0x03, 0x02, 0x06, 0x01, 0x0C, 0x05, 0x0B, 0x0A, 0x11,
	0x44, 0x01, 0x09, 0x03, 0x3D, 0x0A, 0x05, 0x21, 0x02, 0x68, 0x07, 0x01, 0x04, 0x0B, 0x13, 0x27,
	0x13, 0x0A, 0x13, 0x09, 0x0A, 0x0C, 0x05, 0x06, 0x06, 0x05, 0x0A, 0x07, 0x0A, 0x05, 0x07, 0x09,
	0x0F, 0x1D, 0x0E, 0x06, 0x11, 0x05, 0x0A, 0x05, 0x27, 0x0B, 0x07, 0x0F, 0x08, 0x04, 0x07, 0x11,
	0x07, 0x06, 0x13, 0x05, 0x0B, 0x05, 0x2F, 0x08, 0x0C, 0x0A, 0x04, 0x03, 0x0B, 0x0B, 0x0C, 0x2C,
	0x0C, 0x10, 0x05, 0x01, 0x01, 0x01, 0x05, 0x02, 0x01, 0x01, 0x03, 0x07, 0x05, 0x14, 0x09, 0x09,
	0x10, 0x07, 0x07, 0x0D, 0x05, 0x05, 0x05, 0x08, 0x08, 0x04, 0x0A, 0x04, 0x03, 0x0A, 0x05, 0x08,
	0x15, 0x07, 0x0E, 0x08, 0x04, 0x05, 0x04, 0x14, 0x0A, 0x04, 0x0B, 0x0A, 0x07, 0x05, 0x01, 0x05,
	0x01, 0x01, 0x04, 0x04, 0x07, 0x20, 0x09, 0x0B, 0x17, 0x0B, 0x28, 0x4E, 0x27, 0x13, 0x29, 0x14,
	0x12, 0x0B, 0x01, 0x01, 0x01, 0x13, 0x03, 0x17, 0x0A, 0x0B, 0x09, 0x06, 0x0B, 0x06, 0x0C, 0x04,
	0x02, 0x03, 0x1A, 0x32, 0x1A, 0x03, 0x06, 0x03, 0x03, 0x09, 0x02, 0x02, 0x04, 0x0A, 0x18, 0x06,
	0x08, 0x12, 0x06, 0x04, 0x02, 0x01, 0x03, 0x02, 0x01, 0x23, 0x07, 0x06, 0x0C, 0x07, 0x03, 0x14,
	0x02, 0x02, 0x14, 0x05, 0x06, 0x0C, 0x06, 0x07, 0x14, 0x08, 0x0B, 0x15, 0x0B, 0x14, 0x11, 0x07,
	0x04, 0x09, 0x01, 0x01, 0x09, 0x04, 0x0D, 0x20, 0x0D, 0x0E, 0x0E, 0x0E, 0x0A, 0x10, 0x09, 0x06,
	0x0F, 0x07, 0x01, 0x01, 0x01, 0x20, 0x04, 0x0A, 0x14, 0x0A, 0x0A, 0x16, 0x08, 0x08, 0x0D, 0x01,
	0x0D, 0x08, 0x08, 0x17, 0x04, 0x11, 0x28, 0x0F, 0x0B, 0x0F, 0x12, 0x0A, 0x05, 0x09, 0x04, 0x03,
	0x02, 0x02, 0x05, 0x14, 0x08, 0x0C, 0x0C, 0x02, 0x02, 0x04, 0x01, 0x0A, 0x3D, 0x0C, 0x3A, 0x0A,
	0x09, 0x04, 0x02, 0x06, 0x05, 0x19, 0x04, 0x0B, 0x0D, 0x07, 0x07, 0x11, 0x09, 0x0B, 0x33, 0x03,
	0x04, 0x11, 0x05, 0x04, 0x07, 0x04, 0x07, 0x0D, 0x0A, 0x0A, 0x14, 0x0B, 0x06, 0x13, 0x05, 0x04,
	0x13, 0x07, 0x14, 0x24, 0x15, 0x11, 0x22, 0x11, 0x01, 0x01, 0x01, 0x01, 0x02, 0x08, 0x09, 0x28,
	0x09, 0xFE, 0xFD, 0x07, 0x0E, 0x07, 0x02, 0x01, 0x04, 0x03, 0x1B, 0x02, 0x07, 0x04, 0x01, 0x0B,
	0x2F, 0x09, 0x0A, 0x04, 0x0B, 0x17, 0x06, 0x04, 0x0B, 0x07, 0x07, 0x03, 0x06, 0x05, 0x08, 0x05,
	0x0F, 0x04, 0x16, 0x15, 0x00, 0x05, 0x00, 0x62, 0x00, 0xA4, 0x0A, 0x6A, 0x02, 0xDA, 0x01, 0x0B,
	0x01, 0x1E, 0x01, 0x4A, 0x01, 0x50, 0x01, 0x56, 0x00, 0x00, 0x01, 0x32, 0x36, 0x37, 0x3E, 0x01,
	0x35, 0x31, 0x35, 0x34, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x22,
	0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x26, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x03,
	0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x07, 0x06, 0x26, 0x27, 0x26, 0x06, 0x27, 0x26, 0x36, 0x27,
	0x2A, 0x01, 0x15, 0x16, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22,
	0x06, 0x15, 0x14, 0x16, 0x15, 0x26, 0x36, 0x27, 0x26, 0x22, 0x07, 0x22, 0x26, 0x27, 0x2E, 0x01,
	0x23, 0x22, 0x26, 0x23, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x37,
	0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x07, 0x0E, 0x01, 0x15, 0x1E, 0x01, 0x17, 0x14, 0x16, 0x15, 0x14, 0x06, 0x17, 0x16, 0x36,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37,
	0x0E, 0x01, 0x15, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x15, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x37, 0x36, 0x26, 0x27, 0x26, 0x36,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3A, 0x01, 0x33, 0x3E, 0x01, 0x33,
	0x32, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x37, 0x3E,
	0x01, 0x37, 0x36, 0x16, 0x17, 0x16, 0x36, 0x17, 0x16, 0x32, 0x37, 0x3A, 0x01, 0x33, 0x32, 0x36,
	0x33, 0x36, 0x16, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x33, 0x3A, 0x03, 0x33,
	0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x37, 0x36, 0x26, 0x27, 0x26, 0x06, 0x27, 0x26,
	0x16, 0x37, 0x05, 0x06, 0x26, 0x27, 0x26, 0x22, 0x27, 0x2E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x3A,
	0x01, 0x17, 0x16, 0x06, 0x07, 0x25, 0x22, 0x26, 0x07, 0x0E, 0x01, 0x27, 0x22, 0x26, 0x23, 0x06,
	0x26, 0x37, 0x36, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01,
	0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x33, 0x1E, 0x01, 0x17,
	0x15, 0x25, 0x32, 0x16, 0x33, 0x06, 0x27, 0x23, 0x2A, 0x01, 0x23, 0x36, 0x16, 0x0A, 0x35, 0x0A,
	0x13, 0x09, 0x0D, 0x02, 0x03, 0x08, 0x09, 0x0C, 0x06, 0x0C, 0x1E, 0x10, 0x06, 0x0D, 0x07, 0x09,
	0x03, 0x02, 0x02, 0x08, 0x07, 0x06, 0x0D, 0x08, 0x36, 0x6D, 0x35, 0x38, 0x70, 0x37, 0x2D, 0x5A,
	0x5A, 0x5A, 0x2D, 0x2D, 0x59, 0x2D, 0x2A, 0x54, 0x2A, 0x10, 0x06, 0x03, 0x02, 0x24, 0x09, 0x03,
	0x06, 0x06, 0x03, 0x0E, 0x01, 0x02, 0x08, 0x0A, 0x13, 0x09, 0x2C, 0x58, 0x2C, 0x17, 0x2D, 0x16,
	0x06, 0x04, 0x01, 0x0A, 0x03, 0x06, 0x06, 0x16, 0x08, 0x0B, 0x19, 0x0A, 0x02, 0x02, 0x02, 0x03,
	0x05, 0x03, 0x09, 0x0F, 0x06, 0x05, 0x11, 0x07, 0x02, 0x02, 0x0B, 0x05, 0x0C, 0x01, 0x2C, 0x58,
	0x2D, 0x2B, 0x58, 0x2C, 0x16, 0x2D, 0x17, 0x08, 0x0D, 0x06, 0x06, 0x0C, 0x07, 0x16, 0x29, 0x15,
	0x09, 0x27, 0x01, 0x01, 0x01, 0x01, 0x03, 0x09, 0x11, 0x1E, 0x0F, 0x0F, 0x26, 0x0B, 0x06, 0x08,
	0x03, 0x04, 0x09, 0x05, 0x09, 0x15, 0x10, 0x2A, 0x53, 0x2A, 0x02, 0x01, 0x0A, 0x15, 0x0A, 0x06,
	0x1B, 0x03, 0x08, 0x08, 0x06, 0x0B, 0x17, 0x0B, 0x08, 0x18, 0x01, 0x1E, 0x0B, 0x10, 0x20, 0x11,
	0x14, 0x29, 0x15, 0x13, 0x17, 0x04, 0x08, 0x0C, 0x08, 0x09, 0x12, 0x09, 0x05, 0x0D, 0x0E, 0x10,
	0x23, 0x0F, 0x0B, 0x16, 0x0B, 0x08, 0x11, 0x08, 0x0E, 0x16, 0x08, 0x0A, 0x11, 0x10, 0x0F, 0x1E,
	0x0F, 0x0B, 0x18, 0x0B, 0x08, 0x11, 0x08, 0x0F, 0x17, 0x0F, 0x14, 0x2C, 0x15, 0x11, 0x25, 0x11,
	0x13, 0x2C, 0x14, 0x16, 0x29, 0x15, 0x2D, 0x5A, 0x2C, 0x2D, 0x58, 0x2D, 0x16, 0x2C, 0x17, 0x09,
	0x14, 0x09, 0x09, 0x10, 0x0A, 0x2C, 0x59, 0x59, 0x59, 0x2D, 0x2D, 0x59, 0x2D, 0x18, 0x2E, 0x18,
	0x0C, 0x11, 0x02, 0x02, 0x0B, 0x0E, 0x0B, 0x21, 0x06, 0x03, 0x1B, 0x04, 0xF9, 0x2F, 0x0A, 0x2C,
	0x0D, 0x0A, 0x15, 0x08, 0x06, 0x03, 0x02, 0x05, 0x34, 0x12, 0x09, 0x16, 0x06, 0x08, 0x04, 0x03,
	0x06, 0x7A, 0x4F, 0x9A, 0x4F, 0x27, 0x4F, 0x27, 0x10, 0x20, 0x10, 0x0A, 0x0D, 0x0A, 0x04, 0x14,
	0x06, 0x08, 0x12, 0x08, 0x14, 0x27, 0x14, 0x27, 0x4F, 0x28, 0x26, 0x4E, 0x26, 0x0A, 0x14, 0x0A,
	0x03, 0x0A, 0x01, 0x01, 0x01, 0x01, 0x05, 0x0D, 0x05, 0x04, 0x04, 0x03, 0xF9, 0x6A, 0x01, 0x02,
	0x01, 0x03, 0x01, 0x42, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x4D, 0x03, 0x02, 0x04, 0x02, 0x0B,
	0x1D, 0x08, 0x09, 0x02, 0x03, 0x06, 0x08, 0x0D, 0x15, 0x09, 0x03, 0x07, 0x0F, 0x06, 0x0A, 0x14,
	0x08, 0x07, 0x01, 0x01, 0x04, 0x03, 0x02, 0x03, 0x01, 0x0E, 0x0D, 0x0F, 0x0D, 0x06, 0x03, 0x0F,
	0x01, 0x05, 0x09, 0x05, 0x01, 0x06, 0x05, 0x0B, 0x05, 0x05, 0x10, 0x09, 0x08, 0x01, 0x01, 0x07,
	0x01, 0x0B, 0x03, 0x01, 0x03, 0x07, 0x07, 0x1E, 0x01, 0x19, 0x05, 0x02, 0x11, 0x06, 0x04, 0x08,
	0x04, 0x04, 0x08, 0x04, 0x02, 0x04, 0x02, 0x01, 0x02, 0x06, 0x05, 0x06, 0x01, 0x04, 0x05, 0x03,
	0x01, 0x02, 0x0C, 0x2C, 0x56, 0x2C, 0x17, 0x2F, 0x17, 0x0A, 0x36, 0x04, 0x06, 0x0E, 0x07, 0x06,
	0x0F, 0x0C, 0x07, 0x14, 0x08, 0x0A, 0x12, 0x09, 0x0E, 0x10, 0x04, 0x09, 0x16, 0x07, 0x04, 0x09,
	0x05, 0x01, 0x02, 0x01, 0x02, 0x06, 0x0F, 0x1D, 0x0D, 0x16, 0x29, 0x14, 0x0E, 0x22, 0x10, 0x0F,
	0x0D, 0x03, 0x05, 0x06, 0x04, 0x04, 0x08, 0x05, 0x05, 0x17, 0x08, 0x13, 0x1E, 0x10, 0x13, 0x25,
	0x13, 0x0B, 0x27, 0x04, 0x04, 0x01, 0x02, 0x01, 0x05, 0x15, 0x0A, 0x0B, 0x14, 0x03, 0x03, 0x02,
	0x01, 0x02, 0x05, 0x03, 0x02, 0x08, 0x01, 0x01, 0x14, 0x03, 0x03, 0x04, 0x02, 0x02, 0x04, 0x06,
	0x06, 0x01, 0x01, 0x01, 0x01, 0x04, 0x03, 0x01, 0x01, 0x03, 0x03, 0x04, 0x17, 0x0B, 0x0E, 0x1F,
	0x05, 0x04, 0x09, 0x0D, 0x08, 0x02, 0x01, 0x91, 0x0D, 0x03, 0x01, 0x01, 0x08, 0x05, 0x10, 0x08,
	0x18, 0x01, 0x01, 0x08, 0x0A, 0x16, 0x0B, 0x81, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07,
	0x0B, 0x05, 0x02, 0x01, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x01, 0x04, 0x04, 0x06, 0x8C, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x00, 0x02, 0x00, 0x5E, 0x00, 0xBB, 0x09, 0xE8, 0x02, 0xC6, 0x00, 0xAC,
	0x00, 0xC6, 0x00, 0x00, 0x01, 0x3C, 0x01, 0x35, 0x2A, 0x01, 0x26, 0x22, 0x23, 0x2A, 0x03, 0x23,
	0x2A, 0x01, 0x23, 0x22, 0x26, 0x07, 0x26, 0x06, 0x23, 0x22, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x23, 0x22, 0x26, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x15,
	0x14, 0x06, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x1C,
	0x01, 0x15, 0x30, 0x33, 0x32, 0x35, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36,
	0x17, 0x16, 0x06, 0x33, 0x3A, 0x01, 0x17, 0x26, 0x36, 0x33, 0x32, 0x26, 0x37, 0x3E, 0x01, 0x15,
	0x14, 0x36, 0x33, 0x32, 0x36, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x33, 0x16, 0x32, 0x33, 0x36,
	0x16, 0x33, 0x3A, 0x03, 0x33, 0x32, 0x16, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x32, 0x17, 0x3C, 0x01,
	0x35, 0x3C, 0x01, 0x35, 0x26, 0x06, 0x23, 0x22, 0x36, 0x37, 0x32, 0x16, 0x33, 0x05, 0x06, 0x07,
	0x06, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x37, 0x14, 0x16, 0x33, 0x22, 0x36, 0x37, 0x36, 0x16,
	0x33, 0x32, 0x16, 0x17, 0x16, 0x06, 0x07, 0x09, 0xE8, 0x62, 0xC9, 0xCA, 0xCA, 0x62, 0x3A, 0x72,
	0x73, 0x72, 0x3A, 0x20, 0x42, 0x21, 0x09, 0x22, 0x06, 0x08, 0x84, 0x14, 0x3F, 0x86, 0x3D, 0x14,
	0x2A, 0x10, 0x0F, 0x1F, 0x0E, 0x0E, 0x1A, 0x0E, 0x0B, 0x18, 0x0E, 0x0B, 0x18, 0x0A, 0x0F, 0x23,
	0x10, 0x16, 0x2C, 0x16, 0x1C, 0x24, 0x14, 0x07, 0x01, 0x09, 0x04, 0x22, 0x02, 0x07, 0x16, 0x11,
	0x2C, 0x17, 0x20, 0x15, 0x08, 0x04, 0x11, 0x07, 0x20, 0x5B, 0x35, 0x01, 0x01, 0x27, 0x1E, 0x10,
	0x0A, 0x14, 0x0E, 0x2D, 0x69, 0x2C, 0x1D, 0x43, 0x25, 0x0E, 0x1F, 0x10, 0x06, 0x1D, 0x0B, 0x0A,
	0x18, 0x0B, 0x1D, 0x3A, 0x1D, 0x12, 0x2B, 0x12, 0x02, 0x04, 0x06, 0x0B, 0x15, 0x0B, 0x01, 0x01,
	0x05, 0x11, 0x07, 0x05, 0x02, 0x45, 0x61, 0x0F, 0x32, 0x72, 0x31, 0x0A, 0x13, 0x0A, 0x05, 0x03,
	0x04, 0x0B, 0x17, 0x0B, 0x02, 0xA0, 0x0F, 0x29, 0x52, 0x51, 0x52, 0x29, 0x1F, 0x4B, 0x15, 0x06,
	0x09, 0x06, 0x0D, 0x1B, 0x15, 0x16, 0x1E, 0x09, 0x08, 0x04, 0x04, 0x0F, 0x1E, 0x10, 0xF9, 0x16,
	0x0A, 0x13, 0x12, 0x0E, 0x16, 0x31, 0x11, 0x11, 0x0C, 0x17, 0x01, 0x16, 0x04, 0x16, 0x03, 0x0B,
	0x1D, 0x0D, 0x16, 0x21, 0x08, 0x04, 0x03, 0x06, 0x02, 0x46, 0x16, 0x36, 0x12, 0x01, 0x06, 0x03,
	0x1E, 0x0C, 0x08, 0x09, 0x09, 0x0B, 0x09, 0x07, 0x0D, 0x07, 0x07, 0x10, 0x07, 0x05, 0x16, 0x02,
	0x03, 0x13, 0x05, 0x08, 0x0D, 0x06, 0x07, 0x0F, 0x02, 0x04, 0x11, 0x0A, 0x03, 0x07, 0x01, 0x03,
	0x07, 0x0C, 0x07, 0x18, 0x31, 0x19, 0x22, 0x4E, 0x18, 0x14, 0x2F, 0x09, 0x0C, 0x10, 0x15, 0x0A,
	0x1B, 0x0A, 0x2F, 0x51, 0x18, 0x02, 0x04, 0x02, 0x01, 0x0E, 0x2E, 0x18, 0x0E, 0x16, 0x08, 0x17,
	0x12, 0x1D, 0x16, 0x20, 0x0A, 0x04, 0x07, 0x01, 0x01, 0x17, 0x06, 0x05, 0x01, 0x04, 0x04, 0x01,
	0x0A, 0x01, 0x05, 0x07, 0x07, 0x02, 0x01, 0x08, 0x06, 0x1B, 0x06, 0x09, 0x09, 0x02, 0x0B, 0x03,
	0x01, 0x09, 0x01, 0x0D, 0x06, 0x03, 0x0F, 0x03, 0x13, 0x05, 0x0C, 0x01, 0x0F, 0x1F, 0x0F, 0x07,
	0x15, 0x07, 0x01, 0x01, 0x07, 0x09, 0x01, 0xDC, 0x0E, 0x09, 0x09, 0x04, 0x07, 0x08, 0x0B, 0x0B,
	0x2E, 0x10, 0x13, 0x31, 0x46, 0x06, 0x04, 0x02, 0x03, 0x14, 0x0A, 0x13, 0x07, 0x00, 0x00, 0x00,
	0x00, 0x03, 0x00, 0x63, 0x00, 0x72, 0x07, 0x72, 0x03, 0x0D, 0x00, 0xFF, 0x01, 0x11, 0x01, 0x25,
	0x00, 0x00, 0x01, 0x34, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E,
	0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x07, 0x36, 0x26,
	0x27, 0x2E, 0x01, 0x27, 0x26, 0x34, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x34, 0x37,
	0x36, 0x34, 0x37, 0x3E, 0x01, 0x33, 0x35, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x37, 0x32, 0x36, 0x33,
	0x32, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x03, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A,
	0x01, 0x33, 0x32, 0x16, 0x17, 0x16, 0x32, 0x33, 0x14, 0x06, 0x17, 0x23, 0x15, 0x32, 0x16, 0x17,
	0x36, 0x32, 0x17, 0x35, 0x16, 0x06, 0x15, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x17,
	0x1E, 0x01, 0x15, 0x14, 0x16, 0x07, 0x14, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x1C,
	0x01, 0x15, 0x23, 0x06, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x07, 0x16, 0x06, 0x23, 0x15,
	0x23, 0x1C, 0x01, 0x15, 0x07, 0x0E, 0x03, 0x07, 0x06, 0x22, 0x23, 0x22, 0x26, 0x27, 0x22, 0x06,
	0x23, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07,
	0x06, 0x26, 0x35, 0x34, 0x26, 0x35, 0x34, 0x26, 0x27, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x23, 0x22,
	0x06, 0x23, 0x14, 0x06, 0x07, 0x06, 0x07, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x34,
	0x06, 0x23, 0x06, 0x26, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x37, 0x23, 0x14, 0x06, 0x15, 0x14,
	0x06, 0x07, 0x0E, 0x02, 0x07, 0x30, 0x07, 0x06, 0x14, 0x23, 0x06, 0x16, 0x07, 0x06, 0x22, 0x23,
	0x2A, 0x01, 0x23, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x35, 0x34, 0x36, 0x3F, 0x01, 0x25, 0x35, 0x07,
	0x1C, 0x01, 0x17, 0x1E, 0x01, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x34, 0x26, 0x27, 0x07,
	0x35, 0x0E, 0x01, 0x07, 0x23, 0x14, 0x06, 0x15, 0x23, 0x14, 0x06, 0x15, 0x0E, 0x01, 0x15, 0x33,
	0x34, 0x26, 0x37, 0x01, 0xA3, 0x1A, 0x02, 0x05, 0x0D, 0x07, 0x06, 0x1D, 0x08, 0x0B, 0x16, 0x0C,
	0x16, 0x2C, 0x14, 0x10, 0x27, 0x10, 0x08, 0x11, 0x08, 0x09, 0x0F, 0x09, 0x06, 0x10, 0x09, 0x02,
	0x11, 0x03, 0x04, 0x07, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x09, 0x04, 0x04, 0x03, 0x02,
	0x01, 0x02, 0x08, 0x08, 0x4C, 0x97, 0x4C, 0x1B, 0x36, 0x1B, 0x07, 0x10, 0x06, 0x03, 0x05, 0x02,
	0x06, 0x0A, 0x05, 0x57, 0xAE, 0xAD, 0xAE, 0x57, 0x31, 0x63, 0x32, 0x0B, 0x17, 0x0C, 0x02, 0x05,
	0x02, 0x03, 0x06, 0x02, 0x02, 0x06, 0x05, 0x01, 0x01, 0x04, 0x02, 0x04, 0x02, 0x03, 0x0E, 0x04,
	0x09, 0x01, 0x23, 0x48, 0x22, 0x17, 0x2F, 0x16, 0x06, 0x1F, 0x05, 0x06, 0x02, 0x01, 0x01, 0x04,
	0x08, 0x14, 0x29, 0x15, 0x0B, 0x18, 0x0B, 0x01, 0x04, 0x30, 0x09, 0x0F, 0x1E, 0x0E, 0x06, 0x0A,
	0x05, 0x06, 0x10, 0x05, 0x25, 0x0A, 0x03, 0x08, 0x0A, 0x11, 0x04, 0x06, 0x33, 0x0C, 0x0C, 0x1D,
	0x08, 0x21, 0x42, 0x20, 0x05, 0x09, 0x03, 0x02, 0x02, 0x01, 0x01, 0x08, 0x02, 0x06, 0x0C, 0x04,
	0x08, 0x0C, 0x11, 0x0C, 0x33, 0x04, 0x01, 0x01, 0x18, 0x31, 0x18, 0x0D, 0x1B, 0x0D, 0x05, 0x0B,
	0x05, 0x0A, 0x02, 0x03, 0x04, 0x04, 0x05, 0x05, 0x08, 0x05, 0x03, 0x06, 0x02, 0x08, 0x01, 0x11,
	0x33, 0x15, 0x0F, 0x20, 0x0F, 0x05, 0x0D, 0x04, 0x05, 0x06, 0x05, 0x01, 0x01, 0x23, 0x2A, 0x12,
	0x13, 0x04, 0x04, 0x05, 0x04, 0x03, 0x05, 0x0D, 0x06, 0x24, 0x49, 0x24, 0x0D, 0x2B, 0x0B, 0x03,
	0x0B, 0x26, 0x05, 0x3F, 0x01, 0xC7, 0x60, 0x03, 0x07, 0x10, 0x0F, 0x09, 0x1A, 0x05, 0x02, 0x0C,
	0x04, 0x01, 0x02, 0x82, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x04, 0x18, 0x09, 0x01,
	0x01, 0x73, 0x02, 0x32, 0x03, 0x0B, 0x15, 0x0B, 0x05, 0x03, 0x01, 0x01, 0x05, 0x01, 0x04, 0x08,
	0x07, 0x06, 0x08, 0x0A, 0x06, 0x07, 0x04, 0x05, 0x0E, 0x05, 0x04, 0x10, 0x02, 0x07, 0x0B, 0x05,
	0x05, 0x0C, 0x06, 0x05, 0x0E, 0x05, 0x06, 0x0D, 0x06, 0x08, 0x09, 0x06, 0x07, 0x0D, 0x05, 0x05,
	0x0F, 0x05, 0x06, 0x10, 0x01, 0x01, 0x01, 0x03, 0x03, 0x04, 0x03, 0x04, 0x0B, 0x14, 0x0B, 0x02,
	0x01, 0x01, 0x03, 0x02, 0x01, 0x01, 0x13, 0x06, 0x03, 0x05, 0x07, 0x09, 0x09, 0x07, 0x0D, 0x06,
	0x06, 0x0E, 0x03, 0x06, 0x03, 0x0A, 0x03, 0x01, 0x03, 0x08, 0x04, 0x03, 0x05, 0x0B, 0x05, 0x01,
	0x09, 0x10, 0x11, 0x0D, 0x07, 0x0D, 0x09, 0x0A, 0x03, 0x06, 0x02, 0x02, 0x01, 0x02, 0x02, 0x02,
	0x02, 0x05, 0x0C, 0x08, 0x0D, 0x1B, 0x04, 0x04, 0x09, 0x13, 0x06, 0x0B, 0x06, 0x06, 0x0C, 0x05,
	0x01, 0x02, 0x07, 0x05, 0x05, 0x05, 0x05, 0x04, 0x04, 0x05, 0x0B, 0x05, 0x03, 0x03, 0x04, 0x01,
	0x08, 0x09, 0x04, 0x03, 0x07, 0x04, 0x08, 0x05, 0x03, 0x0B, 0x03, 0x03, 0x47, 0x55, 0x24, 0x24,
	0x09, 0x07, 0x01, 0x09, 0x04, 0x04, 0x03, 0x09, 0x03, 0x0B, 0x05, 0x07, 0x58, 0x0A, 0x7C, 0x83,
	0x01, 0x01, 0x06, 0x0F, 0x06, 0x0C, 0x04, 0x02, 0x0A, 0x04, 0x15, 0x01, 0x01, 0x03, 0x01, 0x12,
	0x02, 0x01, 0x04, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x08, 0x04, 0x06, 0x0B, 0x08,
	0x00, 0x02, 0x00, 0x60, 0x00, 0xA5, 0x0A, 0xDB, 0x02, 0xDA, 0x01, 0x29, 0x01, 0x3C, 0x00, 0x00,
	0x01, 0x26, 0x36, 0x27, 0x26, 0x06, 0x23, 0x22, 0x34, 0x27, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x15,
	0x2E, 0x01, 0x23, 0x14, 0x16, 0x17, 0x2A, 0x03, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x23, 0x2A,
	0x01, 0x23, 0x26, 0x07, 0x06, 0x27, 0x2E, 0x01, 0x23, 0x26, 0x06, 0x27, 0x26, 0x06, 0x23, 0x0E,
	0x01, 0x23, 0x22, 0x26, 0x23, 0x22, 0x06, 0x37, 0x27, 0x26, 0x17, 0x26, 0x22, 0x07, 0x22, 0x06,
	0x35, 0x36, 0x22, 0x23, 0x26, 0x36, 0x07, 0x22, 0x26, 0x17, 0x26, 0x22, 0x23, 0x14, 0x06, 0x07,
	0x0E, 0x01, 0x07, 0x06, 0x07, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07,
	0x0E, 0x01, 0x23, 0x06, 0x26, 0x27, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x23, 0x22, 0x06, 0x27, 0x2A, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x22, 0x23, 0x22, 0x26,
	0x23, 0x06, 0x26, 0x23, 0x22, 0x06, 0x07, 0x06, 0x1E, 0x02, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01,
	0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x37, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36,
	0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E,
	0x01, 0x37, 0x32, 0x36, 0x27, 0x16, 0x32, 0x33, 0x32, 0x36, 0x37, 0x3A, 0x01, 0x37, 0x32, 0x36,
	0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x03, 0x17, 0x1E, 0x01, 0x37,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x27, 0x34, 0x36, 0x26, 0x36, 0x37, 0x36, 0x16,
	0x33, 0x3E, 0x01, 0x33, 0x16, 0x32, 0x33, 0x2E, 0x01, 0x27, 0x32, 0x36, 0x35, 0x34, 0x26, 0x27,
	0x17, 0x15, 0x26, 0x1F, 0x01, 0x05, 0x26, 0x16, 0x33, 0x3A, 0x01, 0x17, 0x1E, 0x01, 0x07, 0x0E,
	0x01, 0x27, 0x2E, 0x01, 0x37, 0x26, 0x1F, 0x01, 0x0A, 0xD4, 0x05, 0x0C, 0x11, 0x0A, 0x16, 0x0A,
	0x07, 0x03, 0x06, 0x1C, 0x0A, 0x0E, 0x0B, 0x0A, 0x14, 0x0A, 0x01, 0x01, 0x55, 0xAA, 0xAA, 0xAA,
	0x55, 0x2A, 0x53, 0x29, 0x16, 0x28, 0x15, 0x0B, 0x17, 0x0B, 0x07, 0x08, 0x09, 0x06, 0x05, 0x06,
	0x05, 0x05, 0x11, 0x03, 0x0B, 0x21, 0x0F, 0x14, 0x28, 0x13, 0x0B, 0x17, 0x0A, 0x01, 0x0F, 0x02,
	0x07, 0x07, 0x05, 0x17, 0x30, 0x18, 0x07, 0x4D, 0x02, 0x10, 0x03, 0x07, 0x02, 0x0A, 0x08, 0x21,
	0x04, 0x03, 0x04, 0x03, 0x1B, 0x0B, 0x10, 0x20, 0x11, 0x08, 0x08, 0x07, 0x08, 0x0A, 0x13, 0x09,
	0x16, 0x29, 0x14, 0x0A, 0x12, 0x0A, 0x09, 0x11, 0x0A, 0x06, 0x14, 0x02, 0x04, 0x1D, 0x08, 0x2C,
	0x5A, 0x2C, 0x14, 0x28, 0x14, 0x16, 0x2D, 0x16, 0x13, 0x24, 0x11, 0x06, 0x0C, 0x05, 0x02, 0x03,
	0x01, 0x06, 0x0C, 0x06, 0x09, 0x12, 0x0A, 0x07, 0x0C, 0x07, 0x16, 0x1E, 0x0A, 0x04, 0x05, 0x02,
	0x01, 0x01, 0x03, 0x01, 0x02, 0x01, 0x04, 0x02, 0x02, 0x01, 0x08, 0x09, 0x27, 0x10, 0x05, 0x13,
	0x02, 0x02, 0x18, 0x07, 0x13, 0x22, 0x12, 0x09, 0x13, 0x09, 0x0A, 0x13, 0x0B, 0x0F, 0x1E, 0x0E,
	0x05, 0x0C, 0x06, 0x08, 0x0C, 0x07, 0x08, 0x11, 0x06, 0x0A, 0x15, 0x0A, 0x16, 0x2C, 0x17, 0x10,
	0x1A, 0x06, 0x03, 0x01, 0x08, 0x0B, 0x16, 0x09, 0x08, 0x11, 0x08, 0x09, 0x10, 0x07, 0x0D, 0x04,
	0x05, 0x02, 0x0A, 0x02, 0x02, 0x04, 0x03, 0x0C, 0x1C, 0x0F, 0x10, 0x22, 0x11, 0x14, 0x0E, 0x0B,
	0x14, 0x50, 0x1B, 0x0E, 0x19, 0x0E, 0x06, 0x0A, 0x06, 0x01, 0x12, 0x01, 0x0E, 0x20, 0x0F, 0x18,
	0x31, 0x19, 0x16, 0x2C, 0x16, 0x07, 0x0F, 0x06, 0x08, 0x10, 0x0A, 0x0F, 0x21, 0x11, 0x17, 0x2F,
	0x18, 0x2E, 0x5C, 0x5C, 0x5C, 0x2F, 0x35, 0x6B, 0x36, 0x0C, 0x17, 0x0C, 0x0C, 0x1B, 0x0B, 0x0A,
	0x1F, 0x01, 0x01, 0x08, 0x08, 0x07, 0x07, 0x0F, 0x07, 0x0E, 0x1A, 0x0E, 0x38, 0x72, 0x37, 0x01,
	0x01, 0x01, 0x03, 0x0A, 0x01, 0x03, 0x01, 0x05, 0x03, 0x02, 0xF9, 0x5F, 0x03, 0x2F, 0x09, 0x05,
	0x0F, 0x02, 0x02, 0x01, 0x02, 0x05, 0x2F, 0x0A, 0x08, 0x0C, 0x06, 0x02, 0x01, 0x01, 0x02, 0x8E,
	0x0A, 0x15, 0x04, 0x03, 0x02, 0x11, 0x04, 0x0A, 0x02, 0x01, 0x01, 0x0A, 0x0F, 0x01, 0x03, 0x02,
	0x03, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x07, 0x01, 0x03, 0x03, 0x09, 0x03, 0x01, 0x01,
	0x02, 0x02, 0x02, 0x01, 0x01, 0x02, 0x04, 0x01, 0x03, 0x05, 0x07, 0x01, 0x0C, 0x01, 0x01, 0x0C,
	0x01, 0x0E, 0x10, 0x06, 0x08, 0x0D, 0x06, 0x03, 0x05, 0x05, 0x03, 0x04, 0x07, 0x04, 0x09, 0x10,
	0x09, 0x04, 0x04, 0x02, 0x03, 0x07, 0x01, 0x04, 0x06, 0x08, 0x06, 0x01, 0x05, 0x06, 0x01, 0x01,
	0x07, 0x01, 0x01, 0x04, 0x03, 0x01, 0x02, 0x01, 0x04, 0x02, 0x02, 0x02, 0x01, 0x05, 0x0A, 0x14,
	0x09, 0x11, 0x13, 0x13, 0x0A, 0x17, 0x2E, 0x17, 0x16, 0x2B, 0x16, 0x11, 0x2D, 0x10, 0x10, 0x06,
	0x03, 0x01, 0x03, 0x06, 0x09, 0x06, 0x02, 0x06, 0x11, 0x0A, 0x04, 0x07, 0x04, 0x04, 0x0B, 0x04,
	0x06, 0x0F, 0x09, 0x03, 0x08, 0x03, 0x04, 0x06, 0x02, 0x02, 0x09, 0x02, 0x04, 0x0A, 0x05, 0x09,
	0x15, 0x08, 0x06, 0x19, 0x0D, 0x06, 0x09, 0x01, 0x02, 0x0C, 0x05, 0x04, 0x02, 0x03, 0x02, 0x08,
	0x05, 0x09, 0x23, 0x0D, 0x06, 0x09, 0x06, 0x05, 0x06, 0x04, 0x0A, 0x0B, 0x04, 0x03, 0x05, 0x01,
	0x01, 0x1D, 0x0F, 0x1A, 0x05, 0x10, 0x09, 0x17, 0x09, 0x03, 0x0C, 0x03, 0x0A, 0x01, 0x04, 0x02,
	0x01, 0x01, 0x01, 0x06, 0x09, 0x10, 0x06, 0x09, 0x05, 0x01, 0x02, 0x01, 0x03, 0x06, 0x0D, 0x0A,
	0x07, 0x01, 0x01, 0x01, 0x05, 0x01, 0x03, 0x02, 0x03, 0x03, 0x05, 0x0D, 0x05, 0x15, 0x09, 0x18,
	0x0F, 0x0D, 0x03, 0x02, 0x01, 0x01, 0x03, 0x01, 0x02, 0x04, 0x02, 0x01, 0x05, 0x09, 0x10, 0x08,
	0x01, 0x01, 0x0A, 0x05, 0x05, 0x9F, 0x0B, 0x02, 0x05, 0x05, 0x13, 0x04, 0x0C, 0x03, 0x04, 0x03,
	0x1D, 0x03, 0x08, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x55, 0x00, 0x0C, 0x09, 0x06,
	0x03, 0x7A, 0x01, 0xB9, 0x01, 0xD2, 0x00, 0x00, 0x01, 0x1E, 0x01, 0x07, 0x16, 0x22, 0x23, 0x06,
	0x26, 0x07, 0x2A, 0x01, 0x07, 0x22, 0x06, 0x15, 0x14, 0x16, 0x17, 0x16, 0x06, 0x15, 0x14, 0x16,
	0x27, 0x14, 0x16, 0x07, 0x16, 0x06, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x16, 0x23, 0x22, 0x16, 0x15,
	0x14, 0x16, 0x23, 0x22, 0x06, 0x35, 0x34, 0x36, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x26, 0x35, 0x34,
	0x26, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x26, 0x37, 0x3E, 0x01, 0x35, 0x34, 0x36, 0x07, 0x26, 0x34,
	0x37, 0x2E, 0x01, 0x35, 0x34, 0x26, 0x15, 0x14, 0x06, 0x07, 0x06, 0x26, 0x15, 0x14, 0x06, 0x07,
	0x06, 0x26, 0x07, 0x0E, 0x01, 0x27, 0x26, 0x36, 0x35, 0x34, 0x22, 0x23, 0x2A, 0x01, 0x23, 0x2A,
	0x01, 0x15, 0x14, 0x06, 0x17, 0x16, 0x36, 0x17, 0x16, 0x06, 0x17, 0x16, 0x36, 0x15, 0x1C, 0x01,
	0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x06, 0x15, 0x14, 0x26, 0x23,
	0x2A, 0x01, 0x23, 0x22, 0x06, 0x27, 0x26, 0x06, 0x35, 0x3C, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x34,
	0x36, 0x27, 0x26, 0x36, 0x37, 0x06, 0x22, 0x17, 0x1E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x30, 0x0F,
	0x01, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x16, 0x07, 0x06, 0x16, 0x23,
	0x22, 0x06, 0x23, 0x06, 0x26, 0x35, 0x34, 0x36, 0x37, 0x36, 0x37, 0x36, 0x35, 0x34, 0x36, 0x27,
	0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x27, 0x2E, 0x01, 0x35, 0x34,
	0x06, 0x23, 0x22, 0x06, 0x27, 0x26, 0x36, 0x23, 0x22, 0x06, 0x27, 0x26, 0x06, 0x23, 0x22, 0x16,
	0x07, 0x0E, 0x01, 0x07, 0x06, 0x22, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27,
	0x2E, 0x01, 0x35, 0x34, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x17, 0x36, 0x16, 0x33, 0x3A,
	0x01, 0x33, 0x32, 0x36, 0x33, 0x3A, 0x01, 0x33, 0x22, 0x3F, 0x01, 0x36, 0x34, 0x37, 0x36, 0x32,
	0x37, 0x36, 0x26, 0x35, 0x34, 0x36, 0x37, 0x3E, 0x01, 0x33, 0x32, 0x16, 0x17, 0x16, 0x32, 0x17,
	0x1E, 0x01, 0x17, 0x16, 0x36, 0x33, 0x32, 0x36, 0x17, 0x36, 0x16, 0x15, 0x32, 0x16, 0x37, 0x3E,
	0x01, 0x17, 0x3E, 0x01, 0x17, 0x36, 0x16, 0x17, 0x32, 0x16, 0x33, 0x16, 0x36, 0x33, 0x32, 0x36,
	0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x33, 0x32, 0x36, 0x17, 0x36, 0x16, 0x33, 0x36, 0x32, 0x33,
	0x32, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E,
	0x01, 0x27, 0x26, 0x06, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x37, 0x36, 0x16, 0x33, 0x32, 0x16,
	0x17, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x14, 0x36, 0x17, 0x16, 0x06, 0x15, 0x1C, 0x01, 0x15,
	0x1C, 0x01, 0x15, 0x14, 0x06, 0x23, 0x22, 0x06, 0x07, 0x06, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x32,
	0x16, 0x37, 0x36, 0x26, 0x37, 0x36, 0x26, 0x37, 0x34, 0x26, 0x37, 0x34, 0x36, 0x37, 0x3E, 0x01,
	0x17, 0x1E, 0x01, 0x15, 0x14, 0x36, 0x17, 0x1E, 0x01, 0x15, 0x14, 0x36, 0x33, 0x3A, 0x03, 0x33,
	0x05, 0x3E, 0x01, 0x37, 0x2A, 0x01, 0x23, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x08, 0xD9, 0x0B, 0x22, 0x15, 0x06, 0x5C,
	0x12, 0x48, 0x90, 0x48, 0x39, 0x74, 0x3A, 0x03, 0x02, 0x0F, 0x03, 0x03, 0x03, 0x02, 0x14, 0x02,
	0x03, 0x10, 0x05, 0x01, 0x01, 0x13, 0x03, 0x0A, 0x0C, 0x05, 0x1E, 0x07, 0x01, 0x13, 0x01, 0x02,
	0x02, 0x07, 0x02, 0x0E, 0x04, 0x04, 0x04, 0x09, 0x09, 0x04, 0x04, 0x02, 0x09, 0x02, 0x02, 0x0A,
	0x1B, 0x0D, 0x0D, 0x13, 0x06, 0x01, 0x01, 0x17, 0x02, 0x26, 0x4C, 0x26, 0x06, 0x62, 0x01, 0x01,
	0x02, 0x06, 0x02, 0x04, 0x01, 0x09, 0x03, 0x08, 0x02, 0x1F, 0x0C, 0x28, 0x51, 0x28, 0x0B, 0x22,
	0x08, 0x04, 0x09, 0x03, 0x05, 0x02, 0x0C, 0x08, 0x13, 0x25, 0x06, 0x02, 0x0C, 0x0A, 0x05, 0x0F,
	0x06, 0x0E, 0x06, 0x05, 0x03, 0x02, 0x03, 0x05, 0x03, 0x01, 0x03, 0x05, 0x04, 0x05, 0x06, 0x03,
	0x02, 0x07, 0x03, 0x0A, 0x04, 0x16, 0x4B, 0x10, 0x04, 0x04, 0x07, 0x06, 0x04, 0x07, 0x06, 0x11,
	0x0A, 0x09, 0x0D, 0x05, 0x01, 0x01, 0x03, 0x04, 0x02, 0x07, 0x05, 0x05, 0x2E, 0x03, 0x11, 0x49,
	0x0D, 0x0A, 0x08, 0x13, 0x0D, 0x1C, 0x0E, 0x04, 0x07, 0x05, 0x07, 0x03, 0x06, 0x2B, 0x5F, 0x2F,
	0x02, 0x07, 0x02, 0x02, 0x04, 0x03, 0x03, 0x0E, 0x04, 0x0B, 0x1A, 0x0A, 0x0A, 0x0E, 0x09, 0x06,
	0x06, 0x01, 0x02, 0x03, 0x03, 0x1D, 0x05, 0x23, 0x09, 0x28, 0x4F, 0x28, 0x34, 0x60, 0x34, 0x0E,
	0x1B, 0x0E, 0x02, 0x04, 0x05, 0x03, 0x07, 0x05, 0x0E, 0x04, 0x06, 0x09, 0x0A, 0x08, 0x06, 0x0C,
	0x07, 0x09, 0x0D, 0x04, 0x02, 0x11, 0x05, 0x04, 0x03, 0x07, 0x0D, 0x22, 0x0E, 0x08, 0x11, 0x02,
	0x0B, 0x06, 0x18, 0x3A, 0x14, 0x07, 0x18, 0x05, 0x07, 0x12, 0x07, 0x06, 0x37, 0x0A, 0x03, 0x05,
	0x01, 0x04, 0x09, 0x04, 0x08, 0x11, 0x08, 0x0D, 0x19, 0x0C, 0x05, 0x08, 0x03, 0x04, 0x0E, 0x01,
	0x08, 0x0C, 0x08, 0x09, 0x10, 0x09, 0x01, 0x03, 0x02, 0x08, 0x0F, 0x06, 0x07, 0x0D, 0x07, 0x04,
	0x17, 0x0D, 0x0F, 0x1D, 0x0F, 0x08, 0x24, 0x02, 0x02, 0x21, 0x07, 0x06, 0x13, 0x04, 0x04, 0x08,
	0x05, 0x0B, 0x0E, 0x07, 0x05, 0x0A, 0x04, 0x09, 0x60, 0x0D, 0x0B, 0x25, 0x06, 0x0C, 0x04, 0x02,
	0x01, 0x17, 0x0C, 0x0C, 0x0D, 0x09, 0x05, 0x01, 0x06, 0x25, 0x4A, 0x25, 0x06, 0x19, 0x04, 0x04,
	0x04, 0x07, 0x0B, 0x01, 0x01, 0x01, 0x04, 0x0B, 0x01, 0x06, 0x1E, 0x08, 0x04, 0x03, 0x06, 0x03,
	0x05, 0x02, 0x41, 0x17, 0x43, 0x86, 0x86, 0x86, 0x43, 0xF8, 0xA0, 0x02, 0x04, 0x02, 0x35, 0x6B,
	0x35, 0x01, 0x03, 0x04, 0x03, 0x0C, 0x02, 0x05, 0x09, 0x04, 0x11, 0x1C, 0x0D, 0x08, 0x16, 0x08,
	0x11, 0x21, 0x10, 0x02, 0xB4, 0x03, 0x35, 0x01, 0x11, 0x01, 0x01, 0x01, 0x01, 0x1D, 0x04, 0x0B,
	0x03, 0x08, 0x08, 0x20, 0x0B, 0x0C, 0x27, 0x07, 0x10, 0x24, 0x0F, 0x02, 0x6A, 0x12, 0x20, 0x40,
	0x20, 0x07, 0x36, 0x2B, 0x10, 0x01, 0x0A, 0x02, 0x08, 0x03, 0x03, 0x06, 0x04, 0x08, 0x04, 0x08,
	0x11, 0x06, 0x04, 0x0D, 0x0A, 0x41, 0x81, 0x41, 0x07, 0x0F, 0x06, 0x05, 0x09, 0x0A, 0x0A, 0x2D,
	0x08, 0x06, 0x2F, 0x02, 0x02, 0x06, 0x05, 0x03, 0x0D, 0x06, 0x07, 0x03, 0x04, 0x03, 0x02, 0x05,
	0x02, 0x06, 0x01, 0x07, 0x03, 0x01, 0x01, 0x02, 0x0C, 0x02, 0x0A, 0x03, 0x02, 0x02, 0x03, 0x09,
	0x03, 0x07, 0x01, 0x06, 0x09, 0x11, 0x0A, 0x04, 0x01, 0x07, 0x04, 0x08, 0x04, 0x11, 0x20, 0x10,
	0x21, 0x42, 0x21, 0x10, 0x20, 0x10, 0x09, 0x12, 0x08, 0x11, 0x03, 0x02, 0x08, 0x04, 0x03, 0x08,
	0x04, 0x08, 0x05, 0x08, 0x10, 0x07, 0x41, 0x84, 0x40, 0x14, 0x10, 0x0E, 0x01, 0x19, 0x0A, 0x0C,
	0x0A, 0x04, 0x01, 0x01, 0x02, 0x07, 0x07, 0x0F, 0x08, 0x08, 0x10, 0x07, 0x07, 0x16, 0x05, 0x05,
	0x14, 0x05, 0x03, 0x0A, 0x05, 0x02, 0x07, 0x1D, 0x10, 0x20, 0x0E, 0x0D, 0x12, 0x12, 0x0D, 0x0B,
	0x09, 0x0B, 0x09, 0x09, 0x05, 0x05, 0x0D, 0x0A, 0x03, 0x08, 0x03, 0x04, 0x01, 0x03, 0x01, 0x06,
	0x05, 0x02, 0x01, 0x07, 0x0C, 0x0A, 0x11, 0x02, 0x04, 0x01, 0x07, 0x05, 0x05, 0x25, 0x48, 0x1E,
	0x02, 0x02, 0x02, 0x0D, 0x03, 0x02, 0x0A, 0x01, 0x06, 0x05, 0x08, 0x07, 0x2A, 0x0C, 0x0D, 0x27,
	0x0C, 0x0D, 0x24, 0x0E, 0x12, 0x45, 0x09, 0x06, 0x02, 0x07, 0x06, 0x07, 0x06, 0x02, 0x04, 0x03,
	0x02, 0x05, 0x11, 0x06, 0x0D, 0x04, 0x05, 0x04, 0x10, 0x02, 0x08, 0x05, 0x04, 0x02, 0x07, 0x02,
	0x04, 0x04, 0x02, 0x0C, 0x04, 0x20, 0x07, 0x03, 0x08, 0x03, 0x14, 0x0E, 0x05, 0x04, 0x05, 0x0A,
	0x02, 0x02, 0x07, 0x01, 0x02, 0x01, 0x06, 0x0A, 0x0D, 0x02, 0x03, 0x01, 0x06, 0x01, 0x02, 0x03,
	0x03, 0x03, 0x05, 0x02, 0x01, 0x0B, 0x04, 0x05, 0x0B, 0x06, 0x02, 0x08, 0x0A, 0x08, 0x01, 0x06,
	0x07, 0x08, 0x09, 0x0B, 0x0C, 0x07, 0x0D, 0x16, 0x05, 0x02, 0x0F, 0x22, 0x03, 0x03, 0x0B, 0x0B,
	0x01, 0x05, 0x04, 0x02, 0x0B, 0x04, 0x08, 0x10, 0x09, 0x08, 0x11, 0x08, 0x0E, 0x04, 0x02, 0x04,
	0x02, 0x0A, 0x02, 0x04, 0x02, 0x0B, 0x03, 0x03, 0x0E, 0x0A, 0x05, 0x01, 0x08, 0x01, 0x0B, 0x01,
	0x04, 0x09, 0x04, 0x02, 0x04, 0x07, 0x09, 0x01, 0x06, 0x08, 0x0C, 0x0B, 0x1E, 0x04, 0x4A, 0x01,
	0x03, 0x01, 0x09, 0x19, 0x07, 0x08, 0x03, 0x08, 0x0D, 0x1B, 0x0D, 0x0D, 0x0D, 0x0A, 0x07, 0x0B,
	0x06, 0x0C, 0x18, 0x0C, 0x00, 0x02, 0x00, 0x53, 0x00, 0x58, 0x0A, 0x33, 0x03, 0x26, 0x01, 0x81,
	0x01, 0x8D, 0x00, 0x00, 0x01, 0x32, 0x36, 0x17, 0x1E, 0x01, 0x33, 0x32, 0x14, 0x17, 0x16, 0x36,
	0x33, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x15, 0x16, 0x06, 0x07,
	0x0E, 0x01, 0x23, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x17, 0x1E, 0x01, 0x17, 0x1E,
	0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x34, 0x36,
	0x37, 0x34, 0x16, 0x33, 0x32, 0x06, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x06, 0x17, 0x16, 0x32, 0x33,
	0x16, 0x32, 0x33, 0x3E, 0x01, 0x37, 0x32, 0x16, 0x37, 0x36, 0x16, 0x33, 0x32, 0x16, 0x17, 0x1E,
	0x01, 0x07, 0x0E, 0x01, 0x23, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x2A, 0x01, 0x07, 0x06, 0x16,
	0x33, 0x32, 0x36, 0x17, 0x16, 0x06, 0x15, 0x14, 0x26, 0x27, 0x2E, 0x01, 0x23, 0x22, 0x06, 0x07,
	0x0E, 0x01, 0x07, 0x22, 0x26, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x1E,
	0x01, 0x07, 0x14, 0x06, 0x27, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x27, 0x2A, 0x01, 0x23, 0x22, 0x06,
	0x23, 0x1E, 0x01, 0x15, 0x14, 0x16, 0x27, 0x26, 0x06, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x26, 0x35,
	0x2E, 0x01, 0x35, 0x34, 0x36, 0x27, 0x26, 0x06, 0x17, 0x14, 0x16, 0x07, 0x06, 0x16, 0x17, 0x14,
	0x06, 0x07, 0x0E, 0x01, 0x23, 0x22, 0x26, 0x27, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x17, 0x14, 0x16, 0x07, 0x0E, 0x01, 0x23, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x07,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x35, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E,
	0x01, 0x23, 0x2A, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x17, 0x14, 0x16, 0x17, 0x1E, 0x01,
	0x07, 0x0E, 0x01, 0x23, 0x22, 0x06, 0x23, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x22, 0x06, 0x27,
	0x2E, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x36, 0x37, 0x36, 0x16, 0x33, 0x3A,
	0x01, 0x17, 0x16, 0x17, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x33, 0x3E,
	0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x33, 0x32, 0x36, 0x37, 0x36, 0x16,
	0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x26, 0x33,
	0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x16, 0x06, 0x17, 0x3A, 0x01, 0x17, 0x16,
	0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x37,
	0x3E, 0x01, 0x27, 0x1E, 0x01, 0x17, 0x01, 0x2A, 0x01, 0x07, 0x22, 0x06, 0x1E, 0x01, 0x33, 0x32,
	0x36, 0x27, 0x05, 0xF3, 0x09, 0x15, 0x07, 0x03, 0x05, 0x03, 0x04, 0x02, 0x05, 0x08, 0x04, 0x0A,
	0x10, 0x08, 0x09, 0x10, 0x09, 0x04, 0x17, 0x03, 0x05, 0x05, 0x01, 0x01, 0x02, 0x03, 0x10, 0x0D,
	0x20, 0x3F, 0x20, 0x16, 0x2B, 0x16, 0x06, 0x1C, 0x05, 0x06, 0x01, 0x08, 0x08, 0x11, 0x09, 0x0E,
	0x1D, 0x0F, 0x07, 0x0F, 0x07, 0x0E, 0x06, 0x02, 0x02, 0x11, 0x01, 0x02, 0x01, 0x18, 0x05, 0x03,
	0x01, 0x02, 0x01, 0x02, 0x17, 0x03, 0x06, 0x0C, 0x06, 0x42, 0x84, 0x43, 0x1C, 0x3A, 0x1D, 0x07,
	0x0F, 0x07, 0x09, 0x02, 0x02, 0x02, 0x03, 0x06, 0x05, 0x11, 0x06, 0x3C, 0x78, 0x3C, 0x2A, 0x54,
	0x29, 0x09, 0x10, 0x08, 0x06, 0x01, 0x07, 0x07, 0x17, 0x06, 0x11, 0x01, 0x15, 0x03, 0x08, 0x0B,
	0x09, 0x21, 0x44, 0x22, 0x16, 0x2A, 0x16, 0x03, 0x14, 0x02, 0x04, 0x0A, 0x08, 0x0C, 0x15, 0x09,
	0x07, 0x0C, 0x09, 0x01, 0x02, 0x01, 0x04, 0x10, 0x05, 0x08, 0x05, 0x06, 0x0E, 0x07, 0x0C, 0x17,
	0x0B, 0x2F, 0x5C, 0x2E, 0x0B, 0x03, 0x01, 0x09, 0x20, 0x44, 0x20, 0x13, 0x25, 0x12, 0x0C, 0x16,
	0x01, 0x01, 0x01, 0x03, 0x07, 0x10, 0x01, 0x05, 0x07, 0x06, 0x04, 0x01, 0x01, 0x03, 0x06, 0x23,
	0x0B, 0x17, 0x2A, 0x15, 0x06, 0x0E, 0x06, 0x04, 0x08, 0x03, 0x01, 0x06, 0x01, 0x08, 0x02, 0x01,
	0x11, 0x0A, 0x0E, 0x1E, 0x0D, 0x09, 0x11, 0x08, 0x09, 0x16, 0x09, 0x11, 0x1D, 0x0F, 0x05, 0x0A,
	0x05, 0x02, 0x09, 0x01, 0x03, 0x0B, 0x04, 0x0E, 0x05, 0x3E, 0x7D, 0x3E, 0x1F, 0x3E, 0x1E, 0x14,
	0x28, 0x13, 0x16, 0x33, 0x01, 0x05, 0x04, 0x03, 0x0C, 0x01, 0x01, 0x08, 0x04, 0x0C, 0x19, 0x0D,
	0x2D, 0x59, 0x2D, 0x12, 0x25, 0x12, 0x08, 0x15, 0x08, 0x10, 0x05, 0x03, 0x0C, 0x04, 0x15, 0x05,
	0x05, 0x0C, 0x06, 0x25, 0x26, 0x26, 0x25, 0x0D, 0x1D, 0x0B, 0x0E, 0x17, 0x12, 0x08, 0x13, 0x08,
	0x3F, 0x7B, 0x3A, 0x18, 0x31, 0x1A, 0x19, 0x32, 0x18, 0x11, 0x20, 0x10, 0x01, 0x11, 0x06, 0x0E,
	0x26, 0x10, 0x0F, 0x1D, 0x0F, 0x0A, 0x02, 0x04, 0x12, 0x23, 0x12, 0x13, 0x25, 0x13, 0x06, 0x03,
	0x01, 0x08, 0x11, 0x09, 0x0A, 0x13, 0x0A, 0x01, 0x06, 0x01, 0x02, 0x05, 0x05, 0x10, 0x1E, 0x0F,
	0x1F, 0x3B, 0x1E, 0x0F, 0x1F, 0x0F, 0x10, 0x21, 0x0D, 0x02, 0x10, 0x03, 0x08, 0x0E, 0x08, 0x12,
	0x23, 0x12, 0x08, 0x10, 0x08, 0x05, 0x06, 0x03, 0x05, 0x04, 0x06, 0x07, 0x16, 0x06, 0x06, 0x07,
	0x03, 0x02, 0x0E, 0x01, 0x0D, 0x17, 0x09, 0xFE, 0xC8, 0x0A, 0x13, 0x0A, 0x0D, 0x18, 0x08, 0x21,
	0x0E, 0x14, 0x05, 0x04, 0x03, 0x11, 0x01, 0x08, 0x02, 0x01, 0x03, 0x01, 0x01, 0x01, 0x01, 0x08,
	0x05, 0x04, 0x01, 0x03, 0x01, 0x08, 0x03, 0x05, 0x19, 0x06, 0x09, 0x12, 0x09, 0x09, 0x26, 0x03,
	0x03, 0x03, 0x0C, 0x01, 0x02, 0x03, 0x02, 0x03, 0x07, 0x03, 0x02, 0x02, 0x01, 0x02, 0x0E, 0x0C,
	0x0F, 0x17, 0x0F, 0x08, 0x0F, 0x08, 0x04, 0x01, 0x38, 0x04, 0x09, 0x13, 0x09, 0x03, 0x0D, 0x02,
	0x04, 0x01, 0x01, 0x01, 0x01, 0x02, 0x04, 0x01, 0x01, 0x11, 0x08, 0x08, 0x0D, 0x06, 0x04, 0x02,
	0x03, 0x03, 0x02, 0x01, 0x0D, 0x03, 0x03, 0x08, 0x25, 0x0E, 0x03, 0x01, 0x02, 0x04, 0x01, 0x05,
	0x01, 0x01, 0x04, 0x01, 0x01, 0x02, 0x07, 0x10, 0x04, 0x06, 0x09, 0x08, 0x07, 0x05, 0x04, 0x0A,
	0x15, 0x0A, 0x0D, 0x14, 0x03, 0x01, 0x05, 0x01, 0x01, 0x29, 0x4E, 0x29, 0x06, 0x77, 0x02, 0x04,
	0x03, 0x03, 0x0F, 0x48, 0x8F, 0x47, 0x05, 0x1A, 0x02, 0x05, 0x0A, 0x08, 0x05, 0x12, 0x03, 0x02,
	0x11, 0x06, 0x06, 0x14, 0x05, 0x0A, 0x0F, 0x05, 0x0A, 0x12, 0x23, 0x11, 0x0A, 0x13, 0x0A, 0x04,
	0x0B, 0x04, 0x06, 0x08, 0x06, 0x09, 0x14, 0x01, 0x0A, 0x04, 0x03, 0x07, 0x03, 0x04, 0x0B, 0x02,
	0x18, 0x36, 0x19, 0x08, 0x11, 0x08, 0x05, 0x0D, 0x05, 0x0B, 0x14, 0x05, 0x03, 0x08, 0x01, 0x04,
	0x0A, 0x03, 0x02, 0x04, 0x02, 0x02, 0x12, 0x1B, 0x09, 0x11, 0x08, 0x05, 0x0E, 0x07, 0x04, 0x02,
	0x02, 0x02, 0x04, 0x02, 0x01, 0x02, 0x01, 0x02, 0x03, 0x08, 0x24, 0x10, 0x12, 0x24, 0x12, 0x2A,
	0x54, 0x2A, 0x0E, 0x07, 0x09, 0x02, 0x03, 0x01, 0x05, 0x06, 0x07, 0x04, 0x02, 0x02, 0x08, 0x0B,
	0x1B, 0x05, 0x02, 0x02, 0x02, 0x22, 0x19, 0x0A, 0x12, 0x05, 0x04, 0x03, 0x04, 0x02, 0x03, 0x32,
	0x04, 0x0D, 0x05, 0x04, 0x03, 0x08, 0x05, 0x04, 0x25, 0x0C, 0x02, 0x0A, 0x01, 0x01, 0x01, 0x02,
	0x02, 0x01, 0x03, 0x01, 0x02, 0x02, 0x0C, 0x03, 0x18, 0x02, 0x05, 0x09, 0x04, 0x07, 0x07, 0x03,
	0x02, 0x03, 0x03, 0x01, 0x03, 0x03, 0x05, 0x01, 0x03, 0x03, 0x07, 0x13, 0x09, 0x07, 0x14, 0x06,
	0x01, 0x0B, 0x09, 0xFE, 0x6E, 0x01, 0x01, 0x27, 0x03, 0x1E, 0x0E, 0x00, 0x00, 0x02, 0x00, 0x56,
	0x00, 0x23, 0x04, 0xCB, 0x03, 0x5B, 0x00, 0x0D, 0x00, 0x8D, 0x00, 0x00, 0x01, 0x23, 0x22, 0x06,
	0x1D, 0x01, 0x14, 0x16, 0x33, 0x32, 0x16, 0x37, 0x3E, 0x01, 0x25, 0x17, 0x0E, 0x01, 0x07, 0x0E,
	0x01, 0x07, 0x0E, 0x01, 0x23, 0x22, 0x26, 0x15, 0x14, 0x16, 0x27, 0x26, 0x06, 0x23, 0x2A, 0x01,
	0x07, 0x2E, 0x01, 0x35, 0x0E, 0x01, 0x2B, 0x01, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01,
	0x17, 0x14, 0x26, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27,
	0x26, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x37, 0x36, 0x37, 0x36, 0x26, 0x27, 0x26, 0x36, 0x35,
	0x34, 0x26, 0x3E, 0x01, 0x37, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x1F, 0x01, 0x36,
	0x16, 0x33, 0x32, 0x36, 0x17, 0x2E, 0x01, 0x37, 0x34, 0x36, 0x37, 0x17, 0x3E, 0x01, 0x37, 0x36,
	0x16, 0x17, 0x1E, 0x01, 0x17, 0x32, 0x36, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36,
	0x17, 0x1E, 0x01, 0x15, 0x1E, 0x01, 0x17, 0x36, 0x16, 0x17, 0x02, 0x59, 0x54, 0x08, 0x08, 0x08,
	0x08, 0x16, 0x2E, 0x11, 0x07, 0x0F, 0x02, 0x53, 0x08, 0x03, 0x0F, 0x06, 0x05, 0x35, 0x13, 0x0E,
	0x24, 0x10, 0x0C, 0x8A, 0x02, 0x13, 0x1D, 0x3C, 0x1D, 0x1E, 0x39, 0x1D, 0x05, 0x05, 0x08, 0x12,
	0x09, 0x75, 0x11, 0x0C, 0x06, 0x0E, 0x10, 0x07, 0x0D, 0x0A, 0x07, 0x1E, 0x09, 0x08, 0x0F, 0x08,
	0x17, 0x2E, 0x17, 0x12, 0x24, 0x12, 0x16, 0x33, 0x07, 0x09, 0x13, 0x07, 0x07, 0x0D, 0x07, 0x0C,
	0x0F, 0x10, 0x0B, 0x02, 0x2F, 0x0D, 0x0B, 0x04, 0x02, 0x0C, 0x22, 0x0E, 0x0C, 0x2F, 0x08, 0x0E,
	0x20, 0x10, 0x21, 0x42, 0x23, 0x05, 0x22, 0x47, 0x24, 0x21, 0x42, 0x20, 0x01, 0x01, 0x01, 0x0A,
	0x0A, 0x14, 0x04, 0x0D, 0x04, 0x18, 0x1C, 0x16, 0x08, 0x15, 0x08, 0x08, 0x10, 0x09, 0x16, 0x2B,
	0x15, 0x0C, 0x13, 0x0A, 0x09, 0x17, 0x08, 0x04, 0x03, 0x16, 0x21, 0x12, 0x0D, 0x10, 0x0D, 0x02,
	0x3E, 0x08, 0x08, 0x30, 0x08, 0x09, 0x01, 0x0F, 0x07, 0x3C, 0xB8, 0x04, 0x2C, 0x57, 0x2C, 0x16,
	0x0F, 0x05, 0x04, 0x0D, 0x02, 0x0E, 0x0B, 0x41, 0x02, 0x05, 0x02, 0x06, 0x04, 0x0B, 0x06, 0x0F,
	0x0E, 0x28, 0x0D, 0x1C, 0x3B, 0x1E, 0x35, 0x5F, 0x36, 0x10, 0x07, 0x01, 0x01, 0x02, 0x01, 0x05,
	0x0A, 0x05, 0x03, 0x0A, 0x05, 0x05, 0x0E, 0x19, 0x1C, 0x45, 0x1C, 0x1C, 0x37, 0x1C, 0x32, 0x31,
	0x31, 0x31, 0x1B, 0x1E, 0x12, 0x0F, 0x34, 0x11, 0x14, 0x30, 0x25, 0x1B, 0x0B, 0x02, 0x02, 0x0A,
	0x06, 0x06, 0x01, 0x04, 0x01, 0x05, 0x0E, 0x09, 0x02, 0x01, 0x08, 0x03, 0x05, 0x04, 0x04, 0x06,
	0x02, 0x04, 0x05, 0x1A, 0x01, 0x02, 0x06, 0x08, 0x03, 0x08, 0x01, 0x07, 0x01, 0x01, 0x0C, 0x04,
	0x03, 0x09, 0x07, 0x03, 0x01, 0x01, 0x02, 0x06, 0x02, 0x06, 0x0D, 0x09, 0x03, 0x02, 0x05, 0x00,
	0x00, 0x01, 0x00, 0x52, 0x00, 0xDA, 0x08, 0x53, 0x02, 0xA9, 0x00, 0xA8, 0x00, 0x00, 0x01, 0x3E,
	0x01, 0x37, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x2A, 0x01,
	0x23, 0x2A, 0x01, 0x23, 0x22, 0x06, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x07,
	0x0E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x35, 0x34,
	0x36, 0x27, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x34, 0x35,
	0x2E, 0x01, 0x27, 0x26, 0x36, 0x37, 0x36, 0x26, 0x37, 0x3C, 0x01, 0x37, 0x34, 0x36, 0x37, 0x36,
	0x16, 0x17, 0x1E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x17, 0x1E, 0x01,
	0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x36, 0x26, 0x35, 0x34, 0x36, 0x17,
	0x1E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x15, 0x14,
	0x36, 0x33, 0x3A, 0x01, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01,
	0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x08, 0x14, 0x10, 0x20, 0x0F, 0x1C, 0x3C, 0x25, 0x1A,
	0x3E, 0x20, 0x13, 0x28, 0x14, 0x37, 0x6F, 0x38, 0x4A, 0x95, 0x4B, 0x0E, 0x1C, 0x0E, 0x03, 0x13,
	0x03, 0x02, 0x05, 0x02, 0x05, 0x10, 0x0D, 0x1F, 0x48, 0x17, 0x0A, 0x1A, 0x0A, 0x04, 0x10, 0x06,
	0x05, 0x04, 0x02, 0x02, 0x10, 0x07, 0x1C, 0x21, 0x01, 0x02, 0x02, 0x18, 0x0C, 0x14, 0x26, 0x13,
	0x17, 0x2E, 0x17, 0x39, 0x71, 0x39, 0x3E, 0x7D, 0x3E, 0x12, 0x25, 0x12, 0x16, 0x16, 0x09, 0x05,
	0x11, 0x0A, 0x06, 0x02, 0x02, 0x01, 0x04, 0x0D, 0x02, 0x04, 0x07, 0x0C, 0x05, 0x01, 0x01, 0x02,
	0x03, 0x05, 0x0B, 0x12, 0x05, 0x0A, 0x18, 0x14, 0x13, 0x27, 0x13, 0x3E, 0x7C, 0x3E, 0x39, 0x72,
	0x39, 0x16, 0x2D, 0x16, 0x14, 0x27, 0x13, 0x06, 0x0A, 0x06, 0x08, 0x03, 0x01, 0x02, 0x02, 0x2B,
	0x1C, 0x0F, 0x02, 0x0C, 0x07, 0x10, 0x02, 0x03, 0x09, 0x08, 0x02, 0x06, 0x02, 0x01, 0x01, 0x16,
	0x06, 0x13, 0x26, 0x13, 0x22, 0x43, 0x22, 0x39, 0x73, 0x39, 0x3A, 0x74, 0x3A, 0x20, 0x42, 0x21,
	0x16, 0x2E, 0x16, 0x1C, 0x39, 0x1D, 0x02, 0x05, 0x01, 0x05, 0x02, 0x24, 0x46, 0x1C, 0x14, 0x1B,
	0x0A, 0x06, 0x0A, 0x02, 0x04, 0x0D, 0x01, 0x02, 0x02, 0x13, 0x04, 0x0D, 0x15, 0x08, 0x12, 0x14,
	0x19, 0x0C, 0x30, 0x11, 0x06, 0x04, 0x03, 0x03, 0x0D, 0x04, 0x08, 0x04, 0x01, 0x04, 0x28, 0x1C,
	0x0F, 0x20, 0x0F, 0x11, 0x04, 0x01, 0x03, 0x06, 0x03, 0x03, 0x02, 0x02, 0x03, 0x08, 0x03, 0x03,
	0x05, 0x06, 0x02, 0x04, 0x01, 0x02, 0x19, 0x11, 0x08, 0x0C, 0x0A, 0x06, 0x13, 0x08, 0x10, 0x20,
	0x10, 0x09, 0x0B, 0x09, 0x0F, 0x20, 0x0A, 0x05, 0x16, 0x07, 0x08, 0x10, 0x08, 0x07, 0x10, 0x06,
	0x0C, 0x13, 0x08, 0x10, 0x15, 0x02, 0x02, 0x03, 0x02, 0x06, 0x06, 0x03, 0x03, 0x09, 0x03, 0x02,
	0x02, 0x03, 0x03, 0x06, 0x03, 0x01, 0x01, 0x01, 0x01, 0x10, 0x05, 0x0E, 0x20, 0x0F, 0x1B, 0x2D,
	0x04, 0x02, 0x18, 0x06, 0x05, 0x03, 0x0B, 0x0D, 0x22, 0x0A, 0x03, 0x04, 0x03, 0x03, 0x0C, 0x03,
	0x07, 0x02, 0x0A, 0x05, 0x05, 0x05, 0x02, 0x02, 0x03, 0x01, 0x01, 0x05, 0x01, 0x02, 0x05, 0x02,
	0x00, 0x01, 0x00, 0x53, 0x00, 0xD4, 0x08, 0x54, 0x02, 0xAB, 0x01, 0x20, 0x00, 0x00, 0x01, 0x2E,
	0x01, 0x27, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x0E, 0x01, 0x27, 0x30, 0x2B, 0x01, 0x06, 0x26,
	0x27, 0x26, 0x06, 0x23, 0x22, 0x26, 0x07, 0x06, 0x26, 0x27, 0x30, 0x31, 0x22, 0x23, 0x14, 0x06,
	0x23, 0x22, 0x26, 0x27, 0x26, 0x06, 0x27, 0x2E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x0E, 0x01, 0x27,
	0x2E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x2E, 0x01, 0x07, 0x0E, 0x01, 0x23, 0x22,
	0x26, 0x35, 0x22, 0x23, 0x31, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x23, 0x2A, 0x01, 0x23, 0x22, 0x06,
	0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x35, 0x36, 0x34, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x26, 0x27,
	0x2E, 0x01, 0x27, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x07, 0x0E,
	0x01, 0x07, 0x06, 0x26, 0x27, 0x26, 0x06, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x02, 0x14, 0x07, 0x22,
	0x06, 0x17, 0x22, 0x17, 0x33, 0x14, 0x16, 0x15, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x36,
	0x37, 0x36, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x33, 0x32, 0x36, 0x37, 0x3E, 0x01, 0x37,
	0x36, 0x32, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x07, 0x1E, 0x01, 0x17, 0x16,
	0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x35, 0x34, 0x36, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01,
	0x33, 0x3A, 0x01, 0x33, 0x32, 0x26, 0x37, 0x36, 0x16, 0x17, 0x31, 0x33, 0x36, 0x32, 0x17, 0x16,
	0x36, 0x37, 0x3E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x37, 0x36, 0x37, 0x36, 0x16, 0x17, 0x3E,
	0x01, 0x33, 0x32, 0x16, 0x15, 0x16, 0x36, 0x33, 0x32, 0x16, 0x17, 0x16, 0x32, 0x37, 0x36, 0x16,
	0x17, 0x32, 0x33, 0x31, 0x36, 0x33, 0x16, 0x17, 0x16, 0x36, 0x33, 0x32, 0x16, 0x17, 0x16, 0x32,
	0x37, 0x36, 0x16, 0x17, 0x3B, 0x01, 0x3E, 0x01, 0x17, 0x16, 0x14, 0x33, 0x3A, 0x01, 0x33, 0x3A,
	0x01, 0x33, 0x3A, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x2E, 0x01, 0x27, 0x07, 0xE5,
	0x20, 0x43, 0x21, 0x33, 0x67, 0x33, 0x3E, 0x7B, 0x3E, 0x04, 0x0B, 0x03, 0x01, 0x01, 0x02, 0x0D,
	0x03, 0x08, 0x0A, 0x09, 0x09, 0x0B, 0x09, 0x02, 0x0C, 0x03, 0x01, 0x01, 0x03, 0x06, 0x04, 0x04,
	0x01, 0x07, 0x0C, 0x0B, 0x06, 0x10, 0x03, 0x04, 0x0B, 0x03, 0x04, 0x07, 0x05, 0x02, 0x03, 0x07,
	0x02, 0x07, 0x06, 0x07, 0x09, 0x04, 0x01, 0x08, 0x02, 0x01, 0x06, 0x01, 0x05, 0x04, 0x01, 0x01,
	0x01, 0x0A, 0x05, 0x03, 0x02, 0x09, 0x0D, 0x1B, 0x0D, 0x09, 0x0F, 0x0A, 0x05, 0x0A, 0x06, 0x05,
	0x02, 0x01, 0x04, 0x04, 0x09, 0x04, 0x02, 0x02, 0x04, 0x0A, 0x16, 0x0B, 0x06, 0x19, 0x1E, 0x11,
	0x25, 0x13, 0x43, 0x85, 0x42, 0x33, 0x66, 0x32, 0x1D, 0x3A, 0x1C, 0x0C, 0x12, 0x0B, 0x10, 0x2A,
	0x0E, 0x0B, 0x13, 0x04, 0x02, 0x03, 0x02, 0x03, 0x0B, 0x01, 0x09, 0x01, 0x03, 0x03, 0x01, 0x01,
	0x03, 0x01, 0x06, 0x1D, 0x1E, 0x17, 0x27, 0x10, 0x09, 0x14, 0x0B, 0x10, 0x23, 0x11, 0x43, 0x86,
	0x43, 0x16, 0x29, 0x15, 0x0F, 0x1D, 0x0F, 0x10, 0x20, 0x11, 0x09, 0x11, 0x09, 0x08, 0x0D, 0x06,
	0x16, 0x04, 0x11, 0x0B, 0x17, 0x0C, 0x05, 0x03, 0x02, 0x09, 0x11, 0x09, 0x01, 0x01, 0x04, 0x08,
	0x08, 0x10, 0x08, 0x06, 0x08, 0x06, 0x0E, 0x1B, 0x0E, 0x09, 0x01, 0x04, 0x06, 0x08, 0x01, 0x01,
	0x03, 0x0D, 0x03, 0x05, 0x05, 0x02, 0x03, 0x0A, 0x06, 0x06, 0x07, 0x01, 0x06, 0x02, 0x03, 0x01,
	0x06, 0x08, 0x02, 0x01, 0x03, 0x05, 0x05, 0x05, 0x06, 0x0C, 0x09, 0x06, 0x09, 0x02, 0x03, 0x07,
	0x01, 0x03, 0x0D, 0x01, 0x01, 0x01, 0x02, 0x07, 0x06, 0x02, 0x07, 0x0D, 0x09, 0x06, 0x08, 0x03,
	0x02, 0x08, 0x01, 0x03, 0x0D, 0x01, 0x01, 0x01, 0x01, 0x0A, 0x05, 0x01, 0x04, 0x07, 0x0E, 0x06,
	0x1C, 0x38, 0x1C, 0x35, 0x6A, 0x34, 0x1F, 0x3E, 0x1E, 0x38, 0x77, 0x2C, 0x18, 0x3A, 0x1D, 0x01,
	0xF4, 0x09, 0x0F, 0x03, 0x05, 0x0A, 0x0F, 0x01, 0x10, 0x10, 0x01, 0x0F, 0x05, 0x16, 0x16, 0x05,
	0x10, 0x01, 0x0F, 0x04, 0x0D, 0x0E, 0x03, 0x05, 0x19, 0x03, 0x01, 0x18, 0x0D, 0x10, 0x0B, 0x0A,
	0x03, 0x14, 0x0D, 0x04, 0x0A, 0x04, 0x05, 0x0B, 0x01, 0x02, 0x09, 0x05, 0x03, 0x04, 0x04, 0x02,
	0x0D, 0x0E, 0x03, 0x07, 0x10, 0x0D, 0x09, 0x01, 0x0C, 0x04, 0x02, 0x02, 0x02, 0x03, 0x02, 0x06,
	0x0A, 0x15, 0x0A, 0x0C, 0x1A, 0x0C, 0x05, 0x19, 0x01, 0x03, 0x04, 0x03, 0x20, 0x3F, 0x11, 0x09,
	0x0C, 0x01, 0x02, 0x04, 0x03, 0x02, 0x08, 0x02, 0x01, 0x07, 0x03, 0x01, 0x0F, 0x04, 0x06, 0x02,
	0x0A, 0x08, 0x15, 0x0D, 0x06, 0x0F, 0x0A, 0x0F, 0x03, 0x23, 0x02, 0x01, 0x04, 0x09, 0x05, 0x08,
	0x10, 0x08, 0x1B, 0x2A, 0x04, 0x03, 0x22, 0x0E, 0x08, 0x04, 0x03, 0x04, 0x02, 0x02, 0x04, 0x01,
	0x01, 0x01, 0x01, 0x07, 0x01, 0x02, 0x01, 0x01, 0x02, 0x01, 0x01, 0x09, 0x05, 0x13, 0x3A, 0x18,
	0x03, 0x06, 0x04, 0x01, 0x0F, 0x04, 0x1A, 0x33, 0x19, 0x02, 0x04, 0x03, 0x08, 0x01, 0x01, 0x01,
	0x09, 0x01, 0x01, 0x04, 0x04, 0x09, 0x0A, 0x13, 0x04, 0x0F, 0x0F, 0x04, 0x0A, 0x02, 0x05, 0x05,
	0x01, 0x02, 0x0A, 0x05, 0x04, 0x05, 0x05, 0x03, 0x0E, 0x13, 0x04, 0x03, 0x0E, 0x0E, 0x03, 0x05,
	0x16, 0x07, 0x06, 0x05, 0x06, 0x0F, 0x0A, 0x0A, 0x0F, 0x01, 0x0E, 0x05, 0x16, 0x08, 0x05, 0x05,
	0x06, 0x0F, 0x0A, 0x0A, 0x06, 0x11, 0x0E, 0x04, 0x05, 0x03, 0x02, 0x03, 0x04, 0x08, 0x22, 0x27,
	0x14, 0x17, 0x08, 0x00, 0x00, 0x01, 0x00, 0x54, 0x00, 0x5A, 0x01, 0x80, 0x03, 0x26, 0x00, 0x44,
	0x00, 0x00, 0x13, 0x35, 0x2E, 0x01, 0x35, 0x34, 0x36, 0x3F, 0x01, 0x33, 0x17, 0x11, 0x07, 0x27,
	0x26, 0x36, 0x37, 0x3E, 0x01, 0x3F, 0x01, 0x11, 0x27, 0x15, 0x07, 0x15, 0x23, 0x15, 0x33, 0x15,
	0x23, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x15, 0x17, 0x15, 0x14, 0x06, 0x2B, 0x01, 0x22, 0x26,
	0x3D, 0x01, 0x37, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35,
	0x27, 0x35, 0x34, 0x36, 0x3B, 0x01, 0x37, 0x95, 0x0D, 0x0E, 0x05, 0x05, 0x17, 0x7C, 0x69, 0x35,
	0x11, 0x03, 0x03, 0x05, 0x04, 0x0E, 0x09, 0x10, 0x2E, 0x1B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
	0x1B, 0x07, 0x08, 0xC9, 0x08, 0x08, 0x1A, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1A, 0x08, 0x08,
	0x0F, 0x22, 0x02, 0xC9, 0x2D, 0x02, 0x0D, 0x0B, 0x07, 0x0A, 0x02, 0x03, 0xA8, 0xFE, 0x9D, 0x1A,
	0x03, 0x05, 0x0A, 0x04, 0x04, 0x09, 0x05, 0x08, 0x01, 0x3D, 0x1A, 0x35, 0x19, 0x35, 0x36, 0x38,
	0x36, 0x39, 0x36, 0x34, 0x2E, 0x27, 0x08, 0x07, 0x07, 0x08, 0x27, 0x2E, 0x34, 0x36, 0x39, 0x36,
	0x38, 0x36, 0x35, 0x19, 0x49, 0x07, 0x08, 0x1E, 0x00, 0x01, 0x00, 0x58, 0x00, 0x58, 0x02, 0x73,
	0x03, 0x26, 0x00, 0xA6, 0x00, 0x00, 0x01, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17,
	0x1E, 0x01, 0x07, 0x06, 0x16, 0x15, 0x14, 0x16, 0x07, 0x0E, 0x01, 0x07, 0x06, 0x26, 0x27, 0x26,
	0x36, 0x37, 0x36, 0x26, 0x35, 0x34, 0x36, 0x27, 0x34, 0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x06, 0x27, 0x22, 0x26, 0x07,
	0x06, 0x16, 0x15, 0x14, 0x06, 0x17, 0x1E, 0x01, 0x33, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E,
	0x01, 0x17, 0x1E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x37, 0x3E, 0x01, 0x37,
	0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x37, 0x36, 0x34, 0x23, 0x22, 0x36, 0x35, 0x22,
	0x06, 0x27, 0x2E, 0x01, 0x35, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x33, 0x32, 0x36,
	0x33, 0x3A, 0x01, 0x33, 0x32, 0x16, 0x35, 0x36, 0x26, 0x35, 0x34, 0x32, 0x33, 0x1E, 0x01, 0x15,
	0x14, 0x06, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x31, 0x01, 0xFD, 0x03,
	0x15, 0x07, 0x0B, 0x11, 0x08, 0x07, 0x0F, 0x09, 0x09, 0x07, 0x01, 0x03, 0x06, 0x02, 0x02, 0x01,
	0x06, 0x07, 0x04, 0x0F, 0x01, 0x02, 0x0D, 0x01, 0x03, 0x03, 0x01, 0x01, 0x07, 0x0B, 0x02, 0x06,
	0x05, 0x04, 0x01, 0x05, 0x0C, 0x0E, 0x0A, 0x04, 0x09, 0x05, 0x04, 0x02, 0x04, 0x09, 0x19, 0x09,
	0x08, 0x1B, 0x06, 0x04, 0x02, 0x02, 0x08, 0x06, 0x0E, 0x06, 0x0B, 0x15, 0x0A, 0x13, 0x1B, 0x0D,
	0x10, 0x0B, 0x07, 0x08, 0x07, 0x03, 0x04, 0x21, 0x17, 0x1D, 0x59, 0x2A, 0x14, 0x2C, 0x15, 0x12,
	0x24, 0x12, 0x0C, 0x12, 0x0A, 0x07, 0x09, 0x05, 0x07, 0x0C, 0x05, 0x15, 0x14, 0x01, 0x01, 0x12,
	0x14, 0x0A, 0x13, 0x10, 0x10, 0x21, 0x10, 0x0A, 0x1E, 0x02, 0x02, 0x0A, 0x08, 0x03, 0x0A, 0x16,
	0x0A, 0x04, 0x04, 0x01, 0x03, 0x02, 0x02, 0x01, 0x02, 0x03, 0x0C, 0x07, 0x09, 0x09, 0x09, 0x19,
	0x33, 0x1A, 0x03, 0x24, 0x01, 0x01, 0x10, 0x03, 0x08, 0x07, 0x04, 0x03, 0x02, 0x06, 0x02, 0x06,
	0x04, 0x04, 0x0A, 0x0A, 0x0E, 0x02, 0x96, 0x11, 0x1E, 0x0F, 0x13, 0x2A, 0x14, 0x10, 0x20, 0x0E,
	0x0F, 0x1D, 0x10, 0x2F, 0x5D, 0x2E, 0x16, 0x2C, 0x16, 0x07, 0x09, 0x02, 0x01, 0x01, 0x05, 0x08,
	0x06, 0x05, 0x08, 0x11, 0x07, 0x1A, 0x32, 0x19, 0x2C, 0x55, 0x2A, 0x07, 0x11, 0x04, 0x04, 0x0D,
	0x03, 0x0B, 0x1D, 0x0F, 0x06, 0x0C, 0x06, 0x04, 0x0B, 0x03, 0x05, 0x02, 0x01, 0x02, 0x06, 0x03,
	0x15, 0x05, 0x07, 0x16, 0x04, 0x02, 0x01, 0x01, 0x05, 0x02, 0x05, 0x10, 0x0E, 0x0F, 0x26, 0x14,
	0x18, 0x2B, 0x1A, 0x24, 0x49, 0x1C, 0x24, 0x19, 0x0A, 0x04, 0x04, 0x06, 0x06, 0x0B, 0x06, 0x04,
	0x0F, 0x06, 0x04, 0x0B, 0x05, 0x06, 0x09, 0x08, 0x25, 0x4E, 0x2A, 0x20, 0x40, 0x19, 0x0D, 0x12,
	0x06, 0x06, 0x09, 0x06, 0x03, 0x05, 0x0D, 0x07, 0x29, 0x83, 0x0A, 0x01, 0x04, 0x02, 0x06, 0x05,
	0x03, 0x05, 0x03, 0x03, 0x03, 0x04, 0x07, 0x05, 0x09, 0x01, 0x02, 0x05, 0x0B, 0x05, 0x05, 0x01,
	0x0A, 0x08, 0x03, 0x05, 0x03, 0x03, 0x04, 0x02, 0x06, 0x12, 0x07, 0x10, 0x2B, 0x0F, 0x00, 0x00,
	0x00, 0x03, 0x00, 0x54, 0x00, 0x58, 0x01, 0xA3, 0x03, 0x26, 0x00, 0x86, 0x00, 0xA9, 0x00, 0xCB,
	0x00, 0x00, 0x01, 0x3C, 0x01, 0x35, 0x34, 0x36, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x34, 0x35, 0x34,
	0x26, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x34, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01,
	0x27, 0x36, 0x06, 0x27, 0x26, 0x36, 0x27, 0x26, 0x22, 0x23, 0x0E, 0x01, 0x07, 0x36, 0x06, 0x23,
	0x2A, 0x01, 0x23, 0x22, 0x26, 0x07, 0x0E, 0x01, 0x33, 0x3A, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14,
	0x06, 0x15, 0x14, 0x06, 0x07, 0x0E, 0x01, 0x17, 0x1C, 0x01, 0x15, 0x1C, 0x03, 0x15, 0x1C, 0x01,
	0x15, 0x14, 0x16, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x36, 0x16, 0x35, 0x3C, 0x01, 0x35,
	0x3C, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16,
	0x06, 0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x06, 0x15, 0x14, 0x16, 0x33, 0x32, 0x36,
	0x37, 0x3E, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x07, 0x1C, 0x01, 0x15, 0x14, 0x06, 0x07, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x22, 0x36, 0x35, 0x3C, 0x01, 0x35, 0x1E, 0x01, 0x17,
	0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x30, 0x15, 0x14, 0x15, 0x11, 0x1C, 0x01, 0x15, 0x14, 0x06,
	0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x26, 0x36, 0x35, 0x3C, 0x01, 0x35,
	0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x1C, 0x01, 0x15, 0x01, 0xA2, 0x01, 0x03,
	0x02, 0x07, 0x03, 0x03, 0x07, 0x01, 0x02, 0x04, 0x03, 0x07, 0x01, 0x08, 0x03, 0x04, 0x03, 0x06,
	0x01, 0x04, 0x08, 0x04, 0x01, 0x06, 0x02, 0x01, 0x02, 0x01, 0x01, 0x09, 0x01, 0x05, 0x0B, 0x04,
	0x02, 0x35, 0x06, 0x0C, 0x1A, 0x0C, 0x05, 0x0D, 0x04, 0x09, 0x0B, 0x03, 0x02, 0x18, 0x06, 0x17,
	0x05, 0x09, 0x32, 0x0A, 0x21, 0x07, 0x29, 0x50, 0x2A, 0x0E, 0x1F, 0x0B, 0x04, 0x02, 0x06, 0x06,
	0x04, 0x04, 0x06, 0x03, 0x02, 0x09, 0x01, 0x05, 0x05, 0x06, 0x01, 0x07, 0x04, 0x02, 0x02, 0x07,
	0x01, 0x45, 0x04, 0x0D, 0x11, 0x23, 0x12, 0x07, 0x12, 0x08, 0x1D, 0x3B, 0x1E, 0x06, 0x01, 0x1F,
	0x3E, 0x1F, 0x0D, 0x1F, 0x0D, 0x10, 0x1E, 0x10, 0x04, 0x0D, 0x11, 0x23, 0x12, 0x07, 0x12, 0x08,
	0x1D, 0x3B, 0x1E, 0x06, 0x01, 0x1F, 0x3E, 0x1F, 0x0D, 0x1F, 0x0D, 0x10, 0x1E, 0x10, 0x01, 0xA4,
	0x1C, 0x37, 0x1B, 0x0E, 0x1E, 0x0C, 0x09, 0x0A, 0x07, 0x04, 0x08, 0x06, 0x02, 0x08, 0x01, 0x05,
	0x0D, 0x04, 0x07, 0x19, 0x08, 0x03, 0x10, 0x04, 0x03, 0x0D, 0x03, 0x0B, 0x14, 0x0A, 0x06, 0x02,
	0x04, 0x02, 0x08, 0x01, 0x01, 0x02, 0x11, 0x07, 0x09, 0x03, 0x02, 0x02, 0x03, 0x29, 0x01, 0x0A,
	0x14, 0x0A, 0x07, 0x0B, 0x09, 0x04, 0x03, 0x01, 0x01, 0x05, 0x15, 0x17, 0x2D, 0x16, 0x2F, 0x5E,
	0x5E, 0x5E, 0x2F, 0x0B, 0x17, 0x0B, 0x07, 0x0E, 0x02, 0x11, 0x03, 0x09, 0x02, 0x0B, 0x08, 0x03,
	0x01, 0x04, 0x0B, 0x15, 0x0B, 0x2C, 0x59, 0x2C, 0x49, 0x91, 0x49, 0x04, 0x0C, 0x04, 0x05, 0x0B,
	0x05, 0x03, 0x0B, 0x03, 0x0B, 0x23, 0x0C, 0x37, 0x6E, 0x37, 0x1B, 0x37, 0x1B, 0x04, 0x05, 0x07,
	0x07, 0x02, 0x01, 0x01, 0x05, 0x11, 0x0A, 0x37, 0x6D, 0x36, 0x99, 0x05, 0x0B, 0x06, 0x0D, 0x02,
	0x02, 0x02, 0x04, 0x03, 0x01, 0x03, 0x01, 0x04, 0x07, 0x04, 0x07, 0x06, 0x07, 0x0D, 0x06, 0x03,
	0x06, 0x03, 0x02, 0x06, 0x02, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x31, 0x05, 0x0B, 0x06,
	0x0C, 0x03, 0x02, 0x02, 0x04, 0x02, 0x01, 0x04, 0x01, 0x04, 0x07, 0x04, 0x01, 0x06, 0x06, 0x07,
	0x0D, 0x07, 0x04, 0x06, 0x03, 0x01, 0x06, 0x01, 0x02, 0x03, 0x02, 0x01, 0x02, 0x01, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x57, 0x00, 0x3E, 0x02, 0x61, 0x03, 0x40, 0x00, 0x4D, 0x00, 0x74, 0x00, 0x00,
	0x01, 0x06, 0x16, 0x17, 0x16, 0x06, 0x0F, 0x01, 0x0E, 0x01, 0x07, 0x3F, 0x02, 0x2F, 0x01, 0x2E,
	0x01, 0x2F, 0x01, 0x0F, 0x01, 0x33, 0x07, 0x27, 0x2E, 0x01, 0x3F, 0x01, 0x36, 0x34, 0x27, 0x17,
	0x1E, 0x01, 0x1F, 0x02, 0x37, 0x36, 0x26, 0x2F, 0x01, 0x2E, 0x01, 0x37, 0x34, 0x36, 0x37, 0x1E,
	0x01, 0x17, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x1F, 0x02, 0x1E, 0x01, 0x37, 0x36, 0x26, 0x27, 0x26,
	0x36, 0x37, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x1F, 0x01, 0x0F, 0x02, 0x37, 0x2F, 0x01, 0x2E, 0x01,
	0x2F, 0x01, 0x07, 0x33, 0x15, 0x0F, 0x02, 0x0E, 0x01, 0x07, 0x03, 0x06, 0x16, 0x17, 0x1E, 0x01,
	0x17, 0x1E, 0x01, 0x17, 0x16, 0x3F, 0x01, 0x13, 0x3E, 0x01, 0x37, 0x3E, 0x01, 0x3F, 0x02, 0x02,
	0x4E, 0x02, 0x03, 0x04, 0x03, 0x02, 0x05, 0x22, 0x06, 0x11, 0x0A, 0x09, 0x05, 0x24, 0x07, 0x19,
	0x07, 0x0E, 0x06, 0x16, 0x22, 0x0A, 0x04, 0x17, 0x0D, 0x05, 0x01, 0x03, 0x0C, 0x04, 0x04, 0x0C,
	0x06, 0x0A, 0x03, 0x04, 0x01, 0x0F, 0x01, 0x07, 0x07, 0x17, 0x03, 0x03, 0x01, 0x05, 0x05, 0x01,
	0x09, 0x09, 0x04, 0x17, 0x12, 0x07, 0x09, 0x02, 0x08, 0x0C, 0x03, 0x06, 0x02, 0x02, 0x04, 0x06,
	0x07, 0x02, 0x09, 0x01, 0x0D, 0x0B, 0x0C, 0x0E, 0x02, 0x01, 0x08, 0x0B, 0x39, 0x1F, 0x05, 0x16,
	0x07, 0x0C, 0x06, 0x0F, 0x1F, 0x01, 0x53, 0x13, 0x1F, 0x18, 0x1F, 0x08, 0xB6, 0x02, 0x06, 0x07,
	0x09, 0x18, 0x0F, 0x0E, 0x1E, 0x10, 0x11, 0x0B, 0x0A, 0xB6, 0x08, 0x0B, 0x03, 0x03, 0x05, 0x02,
	0x44, 0x05, 0x02, 0x86, 0x04, 0x09, 0x05, 0x05, 0x0F, 0x08, 0x28, 0x07, 0x09, 0x02, 0x10, 0x01,
	0x32, 0x12, 0x18, 0x05, 0x07, 0x02, 0x02, 0x2F, 0x0E, 0x1C, 0x1B, 0x0E, 0x17, 0x09, 0x17, 0x07,
	0x14, 0x0D, 0x05, 0x03, 0x0C, 0x08, 0x1C, 0x0B, 0x22, 0x05, 0x11, 0x0B, 0x1D, 0x05, 0x16, 0x11,
	0x12, 0x16, 0x05, 0x0B, 0x13, 0x09, 0x04, 0x09, 0x06, 0x02, 0x09, 0x06, 0x16, 0x10, 0x05, 0x02,
	0x02, 0x02, 0x0C, 0x0A, 0x0A, 0x17, 0x0D, 0x05, 0x10, 0x0B, 0x0B, 0x15, 0x0B, 0x15, 0x19, 0x11,
	0x4F, 0x2B, 0x0E, 0x13, 0x05, 0x07, 0x02, 0x01, 0x2B, 0x06, 0x65, 0x0C, 0x0F, 0x0B, 0x16, 0x0C,
	0xFF, 0x00, 0x06, 0x12, 0x0C, 0x0E, 0x18, 0x0A, 0x0B, 0x0E, 0x05, 0x04, 0x02, 0x03, 0x01, 0x00,
	0x0C, 0x25, 0x19, 0x1B, 0x1C, 0x03, 0x6F, 0x01, 0x00, 0x04, 0x00, 0x61, 0x00, 0x5A, 0x03, 0x1D,
	0x03, 0x8C, 0x00, 0x12, 0x00, 0x25, 0x00, 0x38, 0x00, 0x7D, 0x00, 0x00, 0x13, 0x17, 0x07, 0x27,
	0x15, 0x23, 0x35, 0x07, 0x27, 0x37, 0x27, 0x37, 0x17, 0x35, 0x33, 0x15, 0x37, 0x17, 0x07, 0x13,
	0x37, 0x27, 0x07, 0x35, 0x23, 0x15, 0x27, 0x07, 0x17, 0x07, 0x17, 0x37, 0x15, 0x33, 0x35, 0x17,
	0x37, 0x27, 0x05, 0x37, 0x27, 0x07, 0x35, 0x23, 0x15, 0x27, 0x07, 0x17, 0x07, 0x17, 0x37, 0x15,
	0x33, 0x35, 0x17, 0x37, 0x27, 0x05, 0x07, 0x23, 0x22, 0x06, 0x1D, 0x01, 0x17, 0x15, 0x33, 0x15,
	0x23, 0x15, 0x33, 0x15, 0x23, 0x15, 0x33, 0x15, 0x23, 0x15, 0x07, 0x15, 0x14, 0x16, 0x3B, 0x01,
	0x32, 0x36, 0x3D, 0x01, 0x27, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35, 0x33, 0x35, 0x23, 0x35,
	0x33, 0x35, 0x37, 0x35, 0x17, 0x11, 0x07, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x1F, 0x01, 0x37, 0x11,
	0x27, 0x23, 0x07, 0x0E, 0x01, 0x15, 0x14, 0x16, 0x17, 0x15, 0xDA, 0x2E, 0x13, 0x2D, 0x25, 0x30,
	0x12, 0x2F, 0x2F, 0x14, 0x2E, 0x25, 0x2D, 0x12, 0x2D, 0x4E, 0x37, 0x16, 0x35, 0x2D, 0x38, 0x16,
	0x38, 0x38, 0x16, 0x38, 0x2D, 0x35, 0x16, 0x37, 0x01, 0xC7, 0x2D, 0x12, 0x2D, 0x25, 0x2E, 0x13,
	0x2D, 0x2D, 0x12, 0x2F, 0x25, 0x2D, 0x13, 0x2E, 0xFE, 0xA9, 0x21, 0x10, 0x08, 0x08, 0x1A, 0x0C,
	0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1A, 0x08, 0x08, 0xC9, 0x08, 0x07, 0x1B, 0x0B, 0x0B, 0x0B, 0x0B,
	0x0B, 0x0B, 0x1B, 0x2E, 0x10, 0x09, 0x0E, 0x04, 0x05, 0x03, 0x03, 0x11, 0x35, 0x69, 0x7C, 0x17,
	0x05, 0x05, 0x0E, 0x0D, 0x02, 0x00, 0x1A, 0x20, 0x1A, 0x34, 0x35, 0x1B, 0x20, 0x1A, 0x1B, 0x21,
	0x1B, 0x36, 0x35, 0x1A, 0x21, 0x1B, 0x01, 0x27, 0x20, 0x26, 0x1F, 0x3E, 0x40, 0x21, 0x26, 0x20,
	0x20, 0x26, 0x20, 0x40, 0x3E, 0x1E, 0x26, 0x20, 0x2B, 0x1B, 0x21, 0x1A, 0x35, 0x36, 0x1B, 0x21,
	0x1B, 0x1A, 0x20, 0x1B, 0x35, 0x34, 0x1A, 0x20, 0x1A, 0x33, 0x1E, 0x08, 0x07, 0x49, 0x19, 0x35,
	0x36, 0x38, 0x36, 0x39, 0x36, 0x34, 0x2E, 0x27, 0x07, 0x08, 0x08, 0x07, 0x27, 0x2E, 0x34, 0x36,
	0x39, 0x36, 0x38, 0x36, 0x35, 0x19, 0x35, 0x1A, 0xFE, 0xC3, 0x08, 0x05, 0x09, 0x04, 0x04, 0x0A,
	0x05, 0x03, 0x1A, 0x01, 0x63, 0xA8, 0x03, 0x02, 0x0A, 0x07, 0x0C, 0x0C, 0x02, 0x2D, 0x00, 0x00,
	0x00, 0x03, 0x00, 0x51, 0x00, 0x58, 0x01, 0xA1, 0x03, 0x26, 0x00, 0x86, 0x00, 0xA2, 0x00, 0xC4,
	0x00, 0x00, 0x01, 0x1E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x14, 0x17, 0x1E, 0x01, 0x17, 0x1E,
	0x01, 0x17, 0x14, 0x16, 0x15, 0x14, 0x16, 0x17, 0x1E, 0x01, 0x17, 0x16, 0x06, 0x15, 0x1C, 0x01,
	0x15, 0x1C, 0x01, 0x15, 0x14, 0x06, 0x07, 0x0E, 0x01, 0x23, 0x22, 0x26, 0x35, 0x34, 0x36, 0x35,
	0x3C, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x36, 0x27, 0x2E, 0x01, 0x27, 0x2E, 0x01, 0x27, 0x2E,
	0x01, 0x27, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x1C, 0x01, 0x15, 0x14, 0x26, 0x07, 0x0E, 0x01,
	0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x35, 0x3C, 0x01, 0x35, 0x3C, 0x03, 0x35, 0x3C, 0x01, 0x35,
	0x26, 0x36, 0x37, 0x3E, 0x01, 0x35, 0x34, 0x36, 0x35, 0x3C, 0x01, 0x35, 0x34, 0x22, 0x23, 0x22,
	0x36, 0x37, 0x36, 0x16, 0x33, 0x3A, 0x01, 0x33, 0x32, 0x36, 0x07, 0x3E, 0x01, 0x37, 0x3A, 0x01,
	0x17, 0x16, 0x06, 0x17, 0x16, 0x36, 0x15, 0x07, 0x0E, 0x01, 0x17, 0x1E, 0x01, 0x17, 0x26, 0x36,
	0x37, 0x06, 0x16, 0x17, 0x1E, 0x01, 0x07, 0x16, 0x36, 0x37, 0x36, 0x26, 0x27, 0x2E, 0x01, 0x37,
	0x0E, 0x01, 0x07, 0x13, 0x34, 0x3D, 0x01, 0x0E, 0x01, 0x07, 0x0E, 0x01, 0x27, 0x2E, 0x01, 0x27,
	0x1C, 0x01, 0x15, 0x1C, 0x01, 0x33, 0x1E, 0x01, 0x17, 0x16, 0x36, 0x37, 0x3E, 0x01, 0x37, 0x3E,
	0x01, 0x35, 0x3C, 0x01, 0x35, 0x01, 0x4D, 0x03, 0x09, 0x03, 0x02, 0x05, 0x04, 0x03, 0x04, 0x07,
	0x01, 0x08, 0x03, 0x03, 0x03, 0x07, 0x01, 0x02, 0x03, 0x08, 0x02, 0x03, 0x01, 0x01, 0x07, 0x02,
	0x03, 0x04, 0x06, 0x01, 0x06, 0x04, 0x04, 0x01, 0x0A, 0x02, 0x03, 0x05, 0x04, 0x04, 0x07, 0x05,
	0x03, 0x03, 0x0C, 0x1F, 0x0E, 0x2A, 0x4F, 0x2A, 0x06, 0x21, 0x0B, 0x32, 0x0A, 0x05, 0x16, 0x07,
	0x19, 0x02, 0x03, 0x0B, 0x09, 0x05, 0x0D, 0x04, 0x0D, 0x19, 0x0D, 0x05, 0x35, 0x01, 0x03, 0x0B,
	0x06, 0x01, 0x08, 0x01, 0x02, 0x03, 0x01, 0x02, 0x06, 0x8A, 0x20, 0x1E, 0x01, 0x01, 0x22, 0x2F,
	0x22, 0x03, 0x1E, 0x06, 0x0E, 0x0C, 0x06, 0x25, 0x0E, 0x15, 0x21, 0x03, 0x04, 0x0C, 0x0E, 0x17,
	0x36, 0x21, 0x0F, 0x1E, 0x0F, 0x97, 0x0F, 0x1F, 0x0F, 0x0E, 0x1E, 0x0E, 0x1F, 0x3E, 0x1F, 0x06,
	0x1D, 0x3B, 0x1E, 0x08, 0x11, 0x08, 0x11, 0x23, 0x12, 0x0C, 0x04, 0x03, 0x12, 0x0A, 0x14, 0x0B,
	0x03, 0x0D, 0x03, 0x04, 0x10, 0x03, 0x08, 0x19, 0x07, 0x04, 0x0D, 0x05, 0x01, 0x08, 0x02, 0x06,
	0x08, 0x04, 0x07, 0x0A, 0x09, 0x0C, 0x1E, 0x0E, 0x1B, 0x37, 0x1C, 0x36, 0x6D, 0x37, 0x0A, 0x11,
	0x05, 0x01, 0x01, 0x02, 0x07, 0x07, 0x05, 0x04, 0x1B, 0x37, 0x1B, 0x37, 0x6E, 0x37, 0x0C, 0x23,
	0x0B, 0x03, 0x0B, 0x03, 0x05, 0x0B, 0x05, 0x04, 0x0C, 0x04, 0x49, 0x91, 0x49, 0x2C, 0x59, 0x2C,
	0x0B, 0x15, 0x0B, 0x04, 0x01, 0x03, 0x08, 0x0B, 0x02, 0x09, 0x03, 0x11, 0x02, 0x0D, 0x08, 0x0B,
	0x17, 0x0B, 0x2F, 0x5E, 0x5E, 0x5E, 0x2F, 0x16, 0x2D, 0x17, 0x15, 0x05, 0x01, 0x01, 0x03, 0x04,
	0x09, 0x0B, 0x07, 0x0A, 0x14, 0x0A, 0x01, 0x29, 0x03, 0x02, 0x02, 0x03, 0x09, 0x07, 0x11, 0x02,
	0x01, 0x01, 0x08, 0x02, 0x04, 0x02, 0x06, 0xD4, 0x1C, 0x55, 0x29, 0x28, 0x4C, 0x03, 0x15, 0x55,
	0x16, 0x11, 0x20, 0x0D, 0x06, 0x2F, 0x09, 0x08, 0x37, 0x0E, 0x19, 0x2F, 0x14, 0x22, 0x5A, 0x28,
	0x0C, 0x18, 0x0C, 0xFE, 0xCD, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x02, 0x06, 0x02, 0x03, 0x06,
	0x03, 0x06, 0x0D, 0x07, 0x06, 0x07, 0x04, 0x07, 0x04, 0x01, 0x03, 0x01, 0x03, 0x04, 0x02, 0x02,
	0x02, 0x0D, 0x06, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x5E, 0x00, 0xC0, 0x03, 0x8F,
	0x02, 0xC0, 0x00, 0x10, 0x00, 0x2D, 0x00, 0x3F, 0x00, 0x51, 0x00, 0x61, 0x00, 0x70, 0x00, 0x7D,
	0x00, 0x8C, 0x00, 0x9B, 0x00, 0xA7, 0x00, 0xB9, 0x00, 0xC1, 0x00, 0xCF, 0x00, 0xDD, 0x00, 0xE9,
	0x01, 0x0C, 0x00, 0x00, 0x01, 0x34, 0x26, 0x23, 0x21, 0x22, 0x06, 0x0F, 0x01, 0x15, 0x1F, 0x01,
	0x21, 0x32, 0x36, 0x3D, 0x01, 0x37, 0x1E, 0x01, 0x15, 0x11, 0x14, 0x06, 0x07, 0x0E, 0x01, 0x23,
	0x21, 0x22, 0x26, 0x27, 0x2E, 0x01, 0x35, 0x11, 0x34, 0x36, 0x37, 0x3E, 0x01, 0x33, 0x21, 0x32,
	0x16, 0x17, 0x07, 0x27, 0x37, 0x17, 0x35, 0x33, 0x07, 0x37, 0x17, 0x07, 0x17, 0x07, 0x27, 0x17,
	0x23, 0x35, 0x07, 0x2F, 0x01, 0x07, 0x17, 0x07, 0x27, 0x17, 0x23, 0x35, 0x07, 0x27, 0x37, 0x27,
	0x37, 0x17, 0x35, 0x33, 0x07, 0x37, 0x17, 0x2F, 0x01, 0x23, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x1D,
	0x01, 0x1F, 0x01, 0x33, 0x3F, 0x02, 0x07, 0x0E, 0x01, 0x1D, 0x01, 0x1F, 0x01, 0x33, 0x3F, 0x01,
	0x35, 0x2F, 0x01, 0x23, 0x2F, 0x02, 0x23, 0x0F, 0x01, 0x15, 0x1F, 0x01, 0x33, 0x3F, 0x01, 0x35,
	0x37, 0x27, 0x23, 0x07, 0x0E, 0x01, 0x1D, 0x01, 0x1F, 0x01, 0x33, 0x3F, 0x01, 0x35, 0x27, 0x17,
	0x27, 0x23, 0x07, 0x0E, 0x01, 0x1D, 0x01, 0x1F, 0x01, 0x33, 0x3F, 0x01, 0x35, 0x27, 0x35, 0x27,
	0x23, 0x0F, 0x01, 0x15, 0x1F, 0x01, 0x33, 0x3F, 0x01, 0x35, 0x27, 0x07, 0x17, 0x07, 0x27, 0x17,
	0x23, 0x35, 0x07, 0x27, 0x37, 0x27, 0x37, 0x17, 0x35, 0x33, 0x07, 0x37, 0x07, 0x3F, 0x01, 0x33,
	0x0F, 0x01, 0x15, 0x23, 0x17, 0x23, 0x22, 0x06, 0x0F, 0x01, 0x15, 0x1F, 0x01, 0x33, 0x3F, 0x01,
	0x35, 0x2F, 0x01, 0x23, 0x0F, 0x01, 0x15, 0x17, 0x1E, 0x01, 0x3B, 0x01, 0x3F, 0x01, 0x35, 0x27,
	0x05, 0x15, 0x33, 0x15, 0x33, 0x35, 0x33, 0x35, 0x23, 0x35, 0x23, 0x07, 0x27, 0x1F, 0x01, 0x37,
	0x2F, 0x01, 0x22, 0x06, 0x07, 0x0E, 0x01, 0x15, 0x14, 0x16, 0x17, 0x1E, 0x01, 0x33, 0x3F, 0x01,
	0x27, 0x07, 0x23, 0x22, 0x26, 0x27, 0x2E, 0x01, 0x35, 0x34, 0x36, 0x37, 0x3E, 0x01, 0x33, 0x03,
	0x4A, 0x07, 0x08, 0xFE, 0xCE, 0x03, 0x05, 0x02, 0x06, 0x06, 0x0A, 0x01, 0x32, 0x08, 0x07, 0x3A,
	0x05, 0x06, 0x06, 0x05, 0x06, 0x11, 0x0B, 0xFD, 0x2A, 0x09, 0x10, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x10, 0x09, 0x02, 0xD6, 0x0B, 0x10, 0x07, 0xD1, 0x0B, 0x04, 0x0D, 0x0A, 0x02, 0x0D, 0x04,
	0x0E, 0x0E, 0x04, 0x0D, 0x02, 0x0A, 0x0D, 0x04, 0x13, 0x0D, 0x0D, 0x05, 0x0E, 0x03, 0x0B, 0x0B,
	0x06, 0x0D, 0x0D, 0x06, 0x0B, 0x0B, 0x03, 0x0E, 0x06, 0x03, 0x0A, 0x27, 0x03, 0x04, 0x01, 0x02,
	0x02, 0x04, 0x08, 0x27, 0x0A, 0x03, 0x23, 0x08, 0x03, 0x02, 0x05, 0x08, 0x29, 0x08, 0x03, 0x03,
	0x08, 0x29, 0x23, 0x03, 0x0A, 0x27, 0x08, 0x04, 0x04, 0x08, 0x27, 0x0A, 0x03, 0x54, 0x08, 0x29,
	0x08, 0x03, 0x02, 0x05, 0x08, 0x29, 0x08, 0x03, 0x03, 0x57, 0x0A, 0x26, 0x0A, 0x02, 0x02, 0x04,
	0x0A, 0x26, 0x0A, 0x04, 0x04, 0x0A, 0x26, 0x0A, 0x04, 0x04, 0x0A, 0x26, 0x0A, 0x04, 0xEE, 0x0D,
	0x0D, 0x03, 0x0F, 0x03, 0x0A, 0x0D, 0x04, 0x0B, 0x0B, 0x04, 0x0D, 0x0A, 0x03, 0x0F, 0xEE, 0x0C,
	0x08, 0x03, 0x02, 0x01, 0x2D, 0xE4, 0x26, 0x02, 0x05, 0x02, 0x06, 0x06, 0x09, 0x26, 0x0A, 0x04,
	0x04, 0x0A, 0x26, 0x09, 0x06, 0x06, 0x02, 0x05, 0x02, 0x26, 0x0A, 0x04, 0x04, 0xFE, 0xE4, 0x5B,
	0x2E, 0x1B, 0x1B, 0x3B, 0x4E, 0x31, 0x10, 0x0B, 0x08, 0x11, 0x13, 0x17, 0x22, 0x0C, 0x0A, 0x0B,
	0x0B, 0x0A, 0x0B, 0x1E, 0x13, 0x19, 0x13, 0x05, 0x0E, 0x0F, 0x08, 0x0F, 0x06, 0x07, 0x07, 0x06,
	0x06, 0x05, 0x10, 0x0A, 0x02, 0x7A, 0x08, 0x07, 0x02, 0x02, 0x0B, 0xC4, 0x0B, 0x03, 0x07, 0x07,
	0xC4, 0x38, 0x07, 0x11, 0x0A, 0xFE, 0x5E, 0x09, 0x0F, 0x07, 0x07, 0x08, 0x08, 0x07, 0x07, 0x0F,
	0x09, 0x01, 0xA2, 0x0A, 0x11, 0x07, 0x07, 0x07, 0x07, 0x07, 0x9D, 0x07, 0x07, 0x07, 0x0D, 0x0D,
	0x07, 0x07, 0x07, 0x07, 0x08, 0x07, 0x0E, 0x0E, 0x07, 0x08, 0x0E, 0x07, 0x07, 0x08, 0x07, 0x0E,
	0x0E, 0x07, 0x08, 0x07, 0x07, 0x07, 0x07, 0x0D, 0x0D, 0x07, 0xFE, 0x08, 0x06, 0x03, 0x03, 0x01,
	0x04, 0x03, 0x27, 0x0A, 0x03, 0x03, 0x0A, 0x35, 0x06, 0x01, 0x05, 0x02, 0x27, 0x0A, 0x03, 0x03,
	0x0A, 0x27, 0x08, 0x06, 0x4E, 0x0A, 0x03, 0x03, 0x0A, 0x27, 0x08, 0x06, 0x06, 0x08, 0x27, 0x0A,
	0x03, 0x03, 0x03, 0x05, 0x02, 0x27, 0x08, 0x06, 0x06, 0x08, 0x27, 0x0A, 0x5E, 0x06, 0x06, 0x01,
	0x04, 0x03, 0x27, 0x0A, 0x03, 0x03, 0x0A, 0x27, 0x08, 0x5E, 0x03, 0x03, 0x0A, 0x27, 0x08, 0x06,
	0x06, 0x08, 0x27, 0x9B, 0x07, 0x07, 0x08, 0x07, 0x0E, 0x0E, 0x07, 0x08, 0x07, 0x07, 0x07, 0x07,
	0x0D, 0x0D, 0x07, 0xAC, 0x14, 0x15, 0x15, 0x14, 0x2E, 0x16, 0x03, 0x03, 0x08, 0x27, 0x0A, 0x03,
	0x03, 0x0A, 0x27, 0x08, 0x61, 0x03, 0x0A, 0x27, 0x08, 0x03, 0x03, 0x06, 0x08, 0x27, 0x0A, 0x46,
	0x20, 0x31, 0x31, 0x24, 0x7B, 0x7F, 0x2A, 0x02, 0x02, 0x23, 0x04, 0x01, 0x0C, 0x0C, 0x0B, 0x1C,
	0x12, 0x13, 0x1E, 0x0B, 0x0B, 0x0A, 0x03, 0x04, 0x26, 0x06, 0x06, 0x05, 0x05, 0x10, 0x0B, 0x09,
	0x0F, 0x06, 0x07, 0x07, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x96, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x0B, 0x00, 0x18, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x07,
	0x00, 0x34, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x28, 0x00, 0x8E, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x0B, 0x00, 0xCF, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x05, 0x00, 0x0B, 0x00, 0xF3, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x0B,
	0x01, 0x17, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x01, 0x00, 0x16, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x01, 0x04, 0x09, 0x00, 0x02, 0x00, 0x0E, 0x00, 0x24, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09,
	0x00, 0x03, 0x00, 0x50, 0x00, 0x3C, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x04, 0x00, 0x16,
	0x00, 0xB7, 0x00, 0x03, 0x00, 0x01, 0x04, 0x09, 0x00, 0x05, 0x00, 0x16, 0x00, 0xDB, 0x00, 0x03,
	0x00, 0x01, 0x04, 0x09, 0x00, 0x06, 0x00, 0x16, 0x00, 0xFF, 0x00, 0x77, 0x00, 0x65, 0x00, 0x61,
	0x00, 0x70, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x69, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x73,
	0x00, 0x00, 0x77, 0x65, 0x61, 0x70, 0x6F, 0x6E, 0x69, 0x63, 0x6F, 0x6E, 0x73, 0x00, 0x00, 0x52,
	0x00, 0x65, 0x00, 0x67, 0x00, 0x75, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x72, 0x00, 0x00, 0x52, 0x65,
	0x67, 0x75, 0x6C, 0x61, 0x72, 0x00, 0x00, 0x46, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74, 0x00, 0x46,
	0x00, 0x6F, 0x00, 0x72, 0x00, 0x67, 0x00, 0x65, 0x00, 0x20, 0x00, 0x32, 0x00, 0x2E, 0x00, 0x30,
	0x00, 0x20, 0x00, 0x3A, 0x00, 0x20, 0x00, 0x77, 0x00, 0x65, 0x00, 0x61, 0x00, 0x70, 0x00, 0x6F,
	0x00, 0x6E, 0x00, 0x69, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x20, 0x00, 0x3A,
	0x00, 0x20, 0x00, 0x32, 0x00, 0x33, 0x00, 0x2D, 0x00, 0x31, 0x00, 0x31, 0x00, 0x2D, 0x00, 0x32,
	0x00, 0x30, 0x00, 0x31, 0x00, 0x38, 0x00, 0x00, 0x46, 0x6F, 0x6E, 0x74, 0x46, 0x6F, 0x72, 0x67,
	0x65, 0x20, 0x32, 0x2E, 0x30, 0x20, 0x3A, 0x20, 0x77, 0x65, 0x61, 0x70, 0x6F, 0x6E, 0x69, 0x63,
	0x6F, 0x6E, 0x73, 0x20, 0x3A, 0x20, 0x32, 0x33, 0x2D, 0x31, 0x31, 0x2D, 0x32, 0x30, 0x31, 0x38,
	0x00, 0x00, 0x77, 0x00, 0x65, 0x00, 0x61, 0x00, 0x70, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x69, 0x00,
	0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x73, 0x00, 0x00, 0x77, 0x65, 0x61, 0x70, 0x6F, 0x6E, 0x69,
	0x63, 0x6F, 0x6E, 0x73, 0x00, 0x00, 0x56, 0x00, 0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x69, 0x00,
	0x6F, 0x00, 0x6E, 0x00, 0x20, 0x00, 0x31, 0x00, 0x2E, 0x00, 0x31, 0x00, 0x00, 0x56, 0x65, 0x72,
	0x73, 0x69, 0x6F, 0x6E, 0x20, 0x31, 0x2E, 0x31, 0x00, 0x00, 0x77, 0x00, 0x65, 0x00, 0x61, 0x00,
	0x70, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x69, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x73, 0x00,
	0x00, 0x77, 0x65, 0x61, 0x70, 0x6F, 0x6E, 0x69, 0x63, 0x6F, 0x6E, 0x73, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x00, 0x00, 0x01, 0x02, 0x00, 0x02, 0x00, 0x13, 0x00, 0x14, 0x00, 0x15, 0x00, 0x16,
	0x00, 0x17, 0x00, 0x18, 0x00, 0x19, 0x00, 0x1A, 0x00, 0x1B, 0x00, 0x1C, 0x00, 0x24, 0x00, 0x25,
	0x00, 0x26, 0x00, 0x27, 0x00, 0x28, 0x00, 0x29, 0x00, 0x2A, 0x00, 0x2B, 0x00, 0x2C, 0x00, 0x2D,
	0x00, 0x2E, 0x00, 0x2F, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00, 0x34, 0x00, 0x35,
	0x00, 0x36, 0x00, 0x37, 0x00, 0x38, 0x00, 0x39, 0x00, 0x3A, 0x00, 0x3B, 0x00, 0x3C, 0x00, 0x3D,
	0x00, 0x44, 0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00, 0x48, 0x00, 0x49, 0x00, 0x4A, 0x00, 0x4B,
	0x00, 0x4C, 0x00, 0x4D, 0x00, 0x4E, 0x00, 0x4F, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00, 0x53,
	0x00, 0x54, 0x07, 0x75, 0x6E, 0x69, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01,
	0xFF, 0xFF, 0x00, 0x0F, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x16, 0x00, 0x1E,
	0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x00, 0x37, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0xD5, 0xA4, 0x98, 0xDB, 0x00, 0x00, 0x00, 0x00, 0xD2, 0xEB, 0xED, 0xCA,
	0x00, 0x00, 0x00, 0x00, 0xD8, 0x1D, 0xB3, 0x6C,
};
```

`CSGO SDK/Renderer/Wrapper/font/font.h`:

```h
#pragma once

#include <d3d9.h>
#include <string>

enum font_flags {
	font_centered = (1 << 1),
	font_dropshadow = (1 << 2),
	font_outline = (1 << 3),
};

class font {
private:
	void Draw(std::string text, Vector2D pos, Color c, int flags) {
		RECT rect;
		SetRect(&rect, pos.x, pos.y, pos.x, pos.y);
		p_font->DrawTextA(NULL, text.data(), -1, &rect, ((flags & font_centered) ? DT_CENTER : DT_LEFT) | DT_NOCLIP, D3DCOLOR_RGBA(c.r(), c.g(), c.b(), c.a()));
	}
	std::string name;
	int height;
	unsigned int weight;
	bool anti_aliased = false;
public:
	font(std::string name, int height, unsigned int weight, bool anti_aliased) {
		this->name = name;
		this->height = height;
		this->weight = weight;
		this->anti_aliased = anti_aliased;
	}
	font(std::string name, int height, unsigned int weight) {
		this->name = name;
		this->height = height;
		this->weight = weight;
		this->anti_aliased = false;
	}

	IDirect3DDevice9* device;
	LPD3DXFONT p_font;
	void setup(IDirect3DDevice9* p_device) {
		this->device = p_device;
	}

	void init() {
		D3DXCreateFontA(device, height, 0, weight, 0, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS, anti_aliased ? CLEARTYPE_NATURAL_QUALITY : NONANTIALIASED_QUALITY, DEFAULT_PITCH, name.data(), &p_font);
	}

	void invalidate() {
		p_font->Release();
	}

	void draw_text(std::string text, Vector2D pos, Color c, int flags) {
		if (flags & font_dropshadow) {
			Draw(text, pos + 1, Color(0, 0, 0, c.a()), flags);

		}

		if (flags & font_outline) {
			// bleh
			for (int x = -1; x <= 1; x++) for (int y = -1; y <= 1; y++) Draw(text, Vector2D(pos.x + x, pos.y + y), Color(0, 0, 0, c.a()), flags);
		}

		Draw(text, pos, c, flags);
	}

	Vector2D measure_size(const std::string& text) {
		RECT rect;
		p_font->DrawTextA(0, text.c_str(), text.size(), &rect, DT_CALCRECT, 0);
		return Vector2D(rect.right - rect.left, rect.bottom - rect.top);
	}
};
```

`CSGO SDK/Renderer/Wrapper/sprite/sprite.cpp`:

```cpp
#include "sprite.h"
#include "../../../SDK/Valve/vector2d.hpp"
#include "../../../SDK/CColor.hpp"

void c_sprite::invalidate() {
	this->texture->Release();
	delete this->texture;
	this->sprite->Release();
	delete this->sprite;
}

void c_sprite::Draw(Vector2D pos, Color c) {
	sprite->Begin(D3DXSPRITE_ALPHABLEND);

	D3DXVECTOR3 position;

	position.x = pos.x;
	position.y = pos.y;
	position.z = 0.01f;

	D3DXVECTOR3 scaling(1.f, 1.f, 1.f);
	D3DXVECTOR3 spriteCentre(100, 100, 0);
	D3DXMATRIX matrix;

	D3DXMatrixTransformation(&matrix, NULL, 0, &scaling, &spriteCentre, NULL, &position);

	sprite->SetTransform(&matrix);

	sprite->Draw(texture, NULL, NULL, NULL, c.ToARGB());

	sprite->End();
}
```

`CSGO SDK/Renderer/Wrapper/sprite/sprite.h`:

```h
#pragma once
#include <d3d9.h>
#include <d3dx9.h>
#pragma comment(lib, "d3dx9.lib")

class Vector2D;
class Color;
class c_sprite {
private:
	LPDIRECT3DTEXTURE9 texture;
	bool began;
	int w, h;
public:
	LPD3DXSPRITE sprite;
	template <typename t>
	void setup(IDirect3DDevice9* device, t texture_bytes, int size, int width, int height) {
		this->w = width;
		this->h = height;
		D3DXCreateTextureFromFileInMemoryEx(device, (void*)texture_bytes, size, width, height, 0, D3DPOOL_DEFAULT, D3DFMT_UNKNOWN, D3DPOOL_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, D3DCOLOR_RGBA(0, 0, 0, 255), NULL, NULL, &texture);
		D3DXCreateSprite(device, &sprite);
	}
	void invalidate();
	void Draw(Vector2D pos, Color c);
};
```

`CSGO SDK/SDK/CColor.hpp`:

```hpp
#pragma once

inline float alpha_mod = -1.f;
class Color {
public:
	unsigned char RGBA[ 4 ];

	Color( ) {
		RGBA[ 0 ] = 255;
		RGBA[ 1 ] = 255;
		RGBA[ 2 ] = 255;
		RGBA[ 3 ] = 255 * ( alpha_mod != -1.f ? alpha_mod : 1.f );
	}
	Color( int r, int g, int b, int a = 255 ) {
		RGBA[ 0 ] = r;
		RGBA[ 1 ] = g;
		RGBA[ 2 ] = b;
		RGBA[ 3 ] = a * ( alpha_mod != -1.f ? alpha_mod : 1.f );
	}

	bool operator!=( Color color ) { return RGBA[ 0 ] != color.RGBA[ 0 ] || RGBA[ 1 ] != color.RGBA[ 1 ] || RGBA[ 2 ] != color.RGBA[ 2 ] || RGBA[ 3 ] != color.RGBA[ 3 ]; }
	bool operator==( Color color ) { return RGBA[ 0 ] == color.RGBA[ 0 ] && RGBA[ 1 ] == color.RGBA[ 1 ] && RGBA[ 2 ] == color.RGBA[ 2 ] && RGBA[ 3 ] == color.RGBA[ 3 ]; }
	Color operator*( float fl ) { return Color( RGBA[ 0 ] * fl, RGBA[ 1 ] * fl, RGBA[ 2 ] * fl, RGBA[ 3 ] * fl ); }

	// member accessors.
	__forceinline uint8_t& r( ) { return RGBA[ 0 ]; }
	__forceinline uint8_t& g( ) { return RGBA[ 1 ]; }
	__forceinline uint8_t& b( ) { return RGBA[ 2 ]; }
	__forceinline uint8_t a( ) {
		return RGBA[ 3 ] * ( alpha_mod != -1.f ? alpha_mod : 1.f );
	}

	// returns the color from 0.f - 1.f
	static float Base( const unsigned char col ) {
		return col / 255.f;
	}

	float* Base( ) {
		float clr[ 3 ];

		clr[ 0 ] = RGBA[ 0 ] / 255.0f;
		clr[ 1 ] = RGBA[ 1 ] / 255.0f;
		clr[ 2 ] = RGBA[ 2 ] / 255.0f;

		return &clr[ 0 ];
	}

	static Color Inverse( const Color color ) {
		return Color( 255 - color.RGBA[ 0 ], 255 - color.RGBA[ 1 ], 255 - color.RGBA[ 2 ] );
	}

	int GetD3DColor( ) const {
		return ( ( int )( ( ( ( RGBA[ 3 ] ) & 0xff ) << 24 ) | ( ( ( RGBA[ 0 ] ) & 0xff ) << 16 ) | ( ( ( RGBA[ 1 ] ) & 0xff ) << 8 ) | ( ( RGBA[ 2 ] ) & 0xff ) ) );
	}

	D3DCOLOR ToARGB( ) {
		return D3DCOLOR_ARGB( a( ), r( ), g( ), b( ) );
	}

	static Color Red( ) {
		return Color( 255, 0, 0 );
	}

	static Color Green( ) {
		return Color( 0, 255, 0 );
	}

	static Color Blue( ) {
		return Color( 0, 0, 255 );
	}

	static Color LightBlue( ) {
		return Color( 100, 100, 255 );
	}

	static Color Grey( ) {
		return Color( 128, 128, 128 );
	}

	static Color DarkGrey( ) {
		return Color( 45, 45, 45 );
	}

	static Color Black( ) {
		return Color( 0, 0, 0 );
	}

	static Color White( ) {
		return Color( 255, 255, 255 );
	}

	static Color Purple( ) {
		return Color( 220, 0, 220 );
	}

	float Difference( const Color color ) const // from 0.f - 1.f with 1.f being the most different
	{
		float red_diff = std::fabs( Base( RGBA[ 0 ] ) - Base( color.RGBA[ 0 ] ) );
		float green_diff = std::fabs( Base( RGBA[ 1 ] ) - Base( color.RGBA[ 1 ] ) );
		float blue_diff = std::fabs( Base( RGBA[ 2 ] ) - Base( color.RGBA[ 2 ] ) );
		float alpha_diff = std::fabs( Base( RGBA[ 3 ] ) - Base( color.RGBA[ 3 ] ) );

		return ( red_diff + green_diff + blue_diff + alpha_diff ) * 0.25f;
	}

	// RGB -> HSB
	static float Hue( const Color color ) {
		float R = Base( color.RGBA[ 0 ] );
		float G = Base( color.RGBA[ 1 ] );
		float B = Base( color.RGBA[ 2 ] );

		float mx = std::max( R, std::max( G, B ) );
		float mn = std::min( R, std::min( G, B ) );
		if( mx == mn )
			return 0.f;

		float delta = mx - mn;

		float hue = 0.f;
		if( mx == R )
			hue = ( G - B ) / delta;
		else if( mx == G )
			hue = 2.f + ( B - R ) / delta;
		else
			hue = 4.f + ( R - G ) / delta;

		hue *= 60.f;
		if( hue < 0.f )
			hue += 360.f;

		return hue / 360.f;
	}

	static float Saturation( const Color color ) {
		float R = Base( color.RGBA[ 0 ] );
		float G = Base( color.RGBA[ 1 ] );
		float B = Base( color.RGBA[ 2 ] );

		float mx = std::max( R, std::max( G, B ) );
		float mn = std::min( R, std::min( G, B ) );

		float delta = mx - mn;

		if( mx == 0.f )
			return delta;

		return delta / mx;
	}

	static float Brightness( const Color color ) {
		float R = Base( color.RGBA[ 0 ] );
		float G = Base( color.RGBA[ 1 ] );
		float B = Base( color.RGBA[ 2 ] );

		return  std::max( R, std::max( G, B ) );
	}

	float Hue( ) const {
		return Hue( *this );
	}

	float Saturation( ) const {
		return Saturation( *this );
	}

	float Brightness( ) const {
		return Brightness( *this );
	}

	// HSB -> RGB
	static Color HSBtoRGB( float hue /* 0.f - 1.f*/,
		float saturation /* 0.f - 1.f */,
		float brightness /* 0.f - 1.f */,
		int alpha = 255 ) {
		hue = std::clamp( hue, 0.f, 1.f );
		saturation = std::clamp( saturation, 0.f, 1.f );
		brightness = std::clamp( brightness, 0.f, 1.f );

		float h = ( hue == 1.f ) ? 0.f : ( hue * 6.f );
		float f = h - static_cast< int >( h );
		float p = brightness * ( 1.f - saturation );
		float q = brightness * ( 1.f - saturation * f );
		float t = brightness * ( 1.f - ( saturation * ( 1.f - f ) ) );

		if( h < 1.f )
			return Color( brightness * 255, t * 255, p * 255, alpha );
		else if( h < 2.f )
			return Color( q * 255, brightness * 255, p * 255, alpha );
		else if( h < 3.f )
			return Color( p * 255, brightness * 255, t * 255, alpha );
		else if( h < 4 )
			return Color( p * 255, q * 255, brightness * 255, alpha );
		else if( h < 5 )
			return Color( t * 255, p * 255, brightness * 255, alpha );
		else
			return Color( brightness * 255, p * 255, q * 255, alpha );
	}
	__inline void SetColor( int _r, int _g, int _b, int _a ) {
		RGBA[ 0 ] = ( unsigned char )_r;
		RGBA[ 1 ] = ( unsigned char )_g;
		RGBA[ 2 ] = ( unsigned char )_b;
		RGBA[ 3 ] = ( unsigned char )_a;
	}
	__inline void SetColor( float _r, float _g, float _b, float _a ) {
		RGBA[ 0 ] = static_cast< unsigned char >( _r * 255.0f );
		RGBA[ 1 ] = static_cast< unsigned char >( _g * 255.0f );
		RGBA[ 2 ] = static_cast< unsigned char >( _b * 255.0f );
		RGBA[ 3 ] = static_cast< unsigned char >( _a * 255.0f );
	}
	void SetColor( float* color ) {
		if( !color )
			return;

		RGBA[ 0 ] = ( unsigned char )( color[ 0 ] * 255.f );
		RGBA[ 1 ] = ( unsigned char )( color[ 1 ] * 255.f );
		RGBA[ 2 ] = ( unsigned char )( color[ 2 ] * 255.f );
		RGBA[ 3 ] = ( unsigned char )( color[ 3 ] * 255.f );
	}

	void SetAlpha( int alpha ) {
		RGBA[ 3 ] = alpha * ( alpha_mod != -1.f ? alpha_mod : 1.f );
	}

	struct Palette_t {
		static Color Black( int alpha = 255 ) { return Color( 13, 13, 13, alpha ); }
		static Color LightBlack( int alpha = 255 ) { return Color( 32, 32, 32, alpha ); }
		static Color DarkGrey( int alpha = 255 ) { return Color( 44, 44, 44, alpha ); }
		static Color Grey( int alpha = 255 ) { return Color( 60, 60, 60, alpha ); }
		static Color LightGrey( int alpha = 255 ) { return Color( 77, 77, 77, alpha ); }
		static Color Red( int alpha = 255 ) { return Color( 255, 0, 0, alpha ); }
		static Color White( int alpha = 255 ) { return Color( 255, 255, 255, alpha ); }
		static Color Yellow( int alpha = 255 ) { return Color( 255, 255, 0, alpha ); }
	};

	__forceinline Color OverrideAlpha( int alpha, bool adaptive = false, bool FORCE_FORCE = true ) {
		return Color( r( ), g( ), b( ), ( adaptive ? static_cast< int >( static_cast< float >( alpha ) * ( RGBA[ 3 ] / 255.f ) ) : alpha ) * ( FORCE_FORCE ? ( alpha_mod != -1.f ? alpha_mod : 1.f ) : 1.f ) );
	}

	__forceinline static Color Blend( Color a, Color b, float multiplier ) {
		return Color(
			a.r( ) + static_cast< int >( multiplier * ( b.r( ) - a.r( ) ) ),
			a.g( ) + static_cast< int >( multiplier * ( b.g( ) - a.g( ) ) ),
			a.b( ) + static_cast< int >( multiplier * ( b.b( ) - a.b( ) ) ),
			a.a( ) + static_cast< int >( multiplier * ( b.a( ) - a.a( ) ) )
		);
	}

	struct Hsv_t {
		float Hue, Saturation, Value;
	};

	static Color HSVtoRGB( float hue, float sat, float val ) {
		float red, grn, blu;
		float i, f, p, q, t;
		Color result;

		if( val == 0 ) {
			red = 0;
			grn = 0;
			blu = 0;
		}
		else {
			hue /= 60;
			i = floor( hue );
			f = hue - i;
			p = val * ( 1 - sat );
			q = val * ( 1 - ( sat * f ) );
			t = val * ( 1 - ( sat * ( 1 - f ) ) );
			if( i == 0 ) {
				red = val;
				grn = t;
				blu = p;
			}
			else if( i == 1 ) {
				red = q;
				grn = val;
				blu = p;
			}
			else if( i == 2 ) {
				red = p;
				grn = val;
				blu = t;
			}
			else if( i == 3 ) {
				red = p;
				grn = q;
				blu = val;
			}
			else if( i == 4 ) {
				red = t;
				grn = p;
				blu = val;
			}
			else if( i == 5 ) {
				red = val;
				grn = p;
				blu = q;
			}
		}

		result = Color( int( red * 255 ), int( grn * 255 ), int( blu * 255 ) );
		return result;
	}

	static Hsv_t RGBtoHSV( Color a ) {
		float red, grn, blu;
		red = ( float )a.r( ) / 255.f;
		grn = ( float )a.g( ) / 255.f;
		blu = ( float )a.b( ) / 255.f;
		float hue, sat, val;
		float x, f, i;
		Hsv_t result;

		x = std::min( std::min( red, grn ), blu );
		val = std::max( std::max( red, grn ), blu );
		if( x == val ) {
			hue = 0;
			sat = 0;
		}
		else {
			f = ( red == x ) ? grn - blu : ( ( grn == x ) ? blu - red : red - grn );
			i = ( red == x ) ? 3 : ( ( grn == x ) ? 5 : 1 );
			hue = fmod( ( i - f / ( val - x ) ) * 60, 360 );
			sat = ( ( val - x ) / val );
		}
		result.Hue = hue;
		result.Saturation = sat;
		result.Value = val;

		return result;
	}
};

```

`CSGO SDK/SDK/CVariables.cpp`:

```cpp
#include "CVariables.hpp"
#include "../source.hpp"
#include "../Features/Miscellaneous/KitParser.hpp"
#include "CColor.hpp"
std::vector<KeyBind_t*> g_keybinds;

CVariables g_Vars;

FloatColor FloatColor::Black = FloatColor(0.0f, 0.0f, 0.0f, 1.0f);
FloatColor FloatColor::White = FloatColor(1.0f, 1.0f, 1.0f, 1.0f);
FloatColor FloatColor::Gray = FloatColor(0.75f, 0.75f, 0.75f, 1.0f);

FloatColor FloatColor::Lerp(const FloatColor& dst, float t) const {
    return FloatColor((dst.r - r) * t + r, (dst.g - g) * t + g, (dst.b - b) * t + b, (dst.a - a) * t + a);
}

void FloatColor::SetColor(Color clr) {
    r = static_cast<float>(clr.r()) / 255.0f;
    g = static_cast<float>(clr.g()) / 255.0f;
    b = static_cast<float>(clr.b()) / 255.0f;
    a = static_cast<float>(clr.a()) / 255.0f;
}

Color FloatColor::ToRegularColor() {
    return Color(r * 255.f, g * 255.f, b * 255.f, a * 255.f);
}

void CVariables::Create() {
    // add weapons
    m_skin_changer.SetName(XorStr("skin_changer"));
    for (const auto& value : weapon_skins) {
        auto idx = m_skin_changer.AddEntry();
        auto entry = m_skin_changer[idx];
        entry->m_definition_index = value.id;
        entry->SetName(value.name);
    }

    this->AddChild(&m_skin_changer);

    sv_accelerate = Interfaces::m_pCvar->FindVar(XorStr("sv_accelerate"));
    sv_airaccelerate = Interfaces::m_pCvar->FindVar(XorStr("sv_airaccelerate"));
    sv_gravity = Interfaces::m_pCvar->FindVar(XorStr("sv_gravity"));
    sv_jump_impulse = Interfaces::m_pCvar->FindVar(XorStr("sv_jump_impulse"));
    sv_penetration_type = Interfaces::m_pCvar->FindVar(XorStr("sv_penetration_type"));

    m_yaw = Interfaces::m_pCvar->FindVar(XorStr("m_yaw"));
    m_pitch = Interfaces::m_pCvar->FindVar(XorStr("m_pitch"));
    sensitivity = Interfaces::m_pCvar->FindVar(XorStr("sensitivity"));

    cl_sidespeed = Interfaces::m_pCvar->FindVar(XorStr("cl_sidespeed"));
    cl_forwardspeed = Interfaces::m_pCvar->FindVar(XorStr("cl_forwardspeed"));
    cl_upspeed = Interfaces::m_pCvar->FindVar(XorStr("cl_upspeed"));
    cl_extrapolate = Interfaces::m_pCvar->FindVar(XorStr("cl_extrapolate"));

    sv_noclipspeed = Interfaces::m_pCvar->FindVar(XorStr("sv_noclipspeed"));

    weapon_recoil_scale = Interfaces::m_pCvar->FindVar(XorStr("weapon_recoil_scale"));
    view_recoil_tracking = Interfaces::m_pCvar->FindVar(XorStr("view_recoil_tracking"));

    r_jiggle_bones = Interfaces::m_pCvar->FindVar(XorStr("r_jiggle_bones"));

    mp_friendlyfire = Interfaces::m_pCvar->FindVar(XorStr("mp_friendlyfire"));

    sv_maxunlag = Interfaces::m_pCvar->FindVar(XorStr("sv_maxunlag"));
    sv_minupdaterate = Interfaces::m_pCvar->FindVar(XorStr("sv_minupdaterate"));
    sv_maxupdaterate = Interfaces::m_pCvar->FindVar(XorStr("sv_maxupdaterate"));

    sv_client_min_interp_ratio = Interfaces::m_pCvar->FindVar(XorStr("sv_client_min_interp_ratio"));
    sv_client_max_interp_ratio = Interfaces::m_pCvar->FindVar(XorStr("sv_client_max_interp_ratio"));

    cl_interp_ratio = Interfaces::m_pCvar->FindVar(XorStr("cl_interp_ratio"));
    cl_interp = Interfaces::m_pCvar->FindVar(XorStr("cl_interp"));
    cl_updaterate = Interfaces::m_pCvar->FindVar(XorStr("cl_updaterate"));

    game_type = Interfaces::m_pCvar->FindVar(XorStr("game_type"));
    game_mode = Interfaces::m_pCvar->FindVar(XorStr("game_mode"));

    ff_damage_bullet_penetration = Interfaces::m_pCvar->FindVar(XorStr("ff_damage_bullet_penetration"));
    ff_damage_reduction_bullets = Interfaces::m_pCvar->FindVar(XorStr("ff_damage_reduction_bullets"));

    mp_damage_scale_ct_head = Interfaces::m_pCvar->FindVar(XorStr("mp_damage_scale_ct_head"));
    mp_damage_scale_t_head = Interfaces::m_pCvar->FindVar(XorStr("mp_damage_scale_t_head"));
    mp_damage_scale_ct_body = Interfaces::m_pCvar->FindVar(XorStr("mp_damage_scale_ct_body"));
    mp_damage_scale_t_body = Interfaces::m_pCvar->FindVar(XorStr("mp_damage_scale_t_body"));

    mp_damage_headshot_only = Interfaces::m_pCvar->FindVar(XorStr("mp_damage_headshot_only"));

    viewmodel_fov = Interfaces::m_pCvar->FindVar(XorStr("viewmodel_fov"));
    viewmodel_offset_x = Interfaces::m_pCvar->FindVar(XorStr("viewmodel_offset_x"));
    viewmodel_offset_y = Interfaces::m_pCvar->FindVar(XorStr("viewmodel_offset_y"));
    viewmodel_offset_z = Interfaces::m_pCvar->FindVar(XorStr("viewmodel_offset_z"));

    mat_ambient_light_r = Interfaces::m_pCvar->FindVar(XorStr("mat_ambient_light_r"));
    mat_ambient_light_g = Interfaces::m_pCvar->FindVar(XorStr("mat_ambient_light_g"));
    mat_ambient_light_b = Interfaces::m_pCvar->FindVar(XorStr("mat_ambient_light_b"));

    sv_show_impacts = Interfaces::m_pCvar->FindVar(XorStr("sv_showimpacts"));

    molotov_throw_detonate_time = Interfaces::m_pCvar->FindVar(XorStr("molotov_throw_detonate_time"));
    weapon_molotov_maxdetonateslope = Interfaces::m_pCvar->FindVar(XorStr("weapon_molotov_maxdetonateslope"));
    net_client_steamdatagram_enable_override = Interfaces::m_pCvar->FindVar(XorStr("net_client_steamdatagram_enable_override"));
    mm_dedicated_search_maxping = Interfaces::m_pCvar->FindVar(XorStr("mm_dedicated_search_maxping"));

    cl_csm_shadows = Interfaces::m_pCvar->FindVar(XorStr("cl_csm_shadows"));

    r_drawmodelstatsoverlay = Interfaces::m_pCvar->FindVar(("r_drawmodelstatsoverlay"));
    host_limitlocal = Interfaces::m_pCvar->FindVar(("host_limitlocal"));

    sv_clockcorrection_msecs = Interfaces::m_pCvar->FindVar(XorStr("sv_clockcorrection_msecs"));
    sv_max_usercmd_future_ticks = Interfaces::m_pCvar->FindVar(XorStr("sv_max_usercmd_future_ticks"));
    sv_maxusrcmdprocessticks = Interfaces::m_pCvar->FindVar(XorStr("sv_maxusrcmdprocessticks"));
    crosshair = Interfaces::m_pCvar->FindVar(XorStr("crosshair"));
    engine_no_focus_sleep = Interfaces::m_pCvar->FindVar(XorStr("engine_no_focus_sleep"));

    sv_clip_penetration_traces_to_players = Interfaces::m_pCvar->FindVar(XorStr("sv_clip_penetration_traces_to_players"));

    r_3dsky = Interfaces::m_pCvar->FindVar(XorStr("r_3dsky"));
    r_RainRadius = Interfaces::m_pCvar->FindVar(XorStr("r_RainRadius"));
    r_rainalpha = Interfaces::m_pCvar->FindVar(XorStr("r_rainalpha"));
    /*developer = Interfaces::m_pCvar->FindVar( XorStr( "developer" ) );
    con_enable = Interfaces::m_pCvar->FindVar( XorStr( "con_enable" ) );
    con_filter_enable = Interfaces::m_pCvar->FindVar( XorStr( "con_filter_enable" ) );
    con_filter_text = Interfaces::m_pCvar->FindVar( XorStr( "con_filter_text" ) );
    con_filter_text_out = Interfaces::m_pCvar->FindVar( XorStr( "con_filter_text_out" ) );
    contimes = Interfaces::m_pCvar->FindVar( XorStr( "contimes" ) );*/
}


```

`CSGO SDK/SDK/CVariables.hpp`:

```hpp
#pragma once
#include "../Utils/FnvHash.hpp"
#include <any>
#include <variant>
#include <map>
#include <d3d9.h>
#include "../Libraries/json.h"
#include "Valve/vector.hpp"
#include "Valve/qangle.hpp"
#include "Classes/CStudioRender.hpp" 

#if 1
#define USE_XOR
#endif

#include "../Utils/XorStr.hpp"

class CUserCmd;

namespace KeyBindType
{
	enum {
		ALWAYS_ON = 0,
		HOLD,
		TOGGLE,
		OFFHOLD,
	};
};

struct KeyBind_t {
	KeyBind_t() { }

	int key = 0, cond = 1;
	bool enabled = false;

	void to_json(nlohmann::json& j) {
		j = nlohmann::json{
			{ (XorStr("key")), key },
			{ (XorStr("cond")), cond },
		};
	}

	void from_json(nlohmann::json& j) {
		j.at(XorStr("key")).get_to(key);
		j.at(XorStr("cond")).get_to(cond);
	}
};

extern std::vector<KeyBind_t*> g_keybinds;

class Color;
class FloatColor {
public:
	FloatColor() = default;
	FloatColor(float _r, float _g, float _b, float _a = 1.0f) :
		r(_r), g(_g), b(_b), a(_a) {
	}

	FloatColor(int _r, int _g, int _b, int _a = 255) { SetColor(_r, _g, _b, _a); }

	FloatColor Lerp(const FloatColor& c, float t) const;

	void SetColor(float _r, float _g, float _b, float _a = 1.0f) {
		r = _r;
		g = _g;
		b = _b;
		a = _a;
	}

	void SetColor(Color clr);

	void SetColor(int _r, int _g, int _b, int _a = 255) {
		r = static_cast<float>(_r) / 255.0f;
		g = static_cast<float>(_g) / 255.0f;
		b = static_cast<float>(_b) / 255.0f;
		a = static_cast<float>(_a) / 255.0f;
	}

	FloatColor Alpha(float alpha) {
		return FloatColor(r, g, b, alpha);
	}

	uint32_t Hex() const {
		union {
			uint32_t i;
			struct {
				uint8_t bytes[4];
			};
		} conv;

		conv.bytes[0] = static_cast<int>(r * 255.0f);
		conv.bytes[1] = static_cast<int>(g * 255.0f);
		conv.bytes[2] = static_cast<int>(b * 255.0f);
		conv.bytes[3] = static_cast<int>(a * 255.0f);

		return conv.i;
	};

	void FloatColor::to_json(nlohmann::json& j) {
		j = nlohmann::json{
			{ ("r"), r },
			{ ("g"), g },
			{ ("b"), b },
			{ ("a"), a }
		};
	}

	void FloatColor::from_json(nlohmann::json& j) {
		j.at(("r")).get_to(r);
		j.at(("g")).get_to(g);
		j.at(("b")).get_to(b);
		j.at(("a")).get_to(a);
	}

	bool operator==(const FloatColor& clr) const {
		return clr.r == r && clr.g == g && clr.b == b && clr.a == a;
	};

	bool operator!=(const FloatColor& clr) const {
		return clr.r != r || clr.g != g || clr.b != b || clr.a != a;
	};

	FloatColor operator*(float v) const {
		return FloatColor(r * v, g * v, b * v, a);
	}

	operator uint32_t() const { return Hex(); };

	operator float* () { return &r; };

	float r, g, b, a;

	static FloatColor Black;
	static FloatColor White;
	static FloatColor Gray;

	Color ToRegularColor();
};

#pragma region Config System
// best cfg system aka pizdoc na macrosax by soufiw

class CBaseGroup {
public: // ghetto fix, for skin changer options setup
	std::map< std::string, std::unique_ptr< std::any > > m_options;
	std::string m_name;
	nlohmann::json m_json;
	nlohmann::json m_json_default_cfg;
	std::vector< CBaseGroup* > m_children;

	using AllowedTypes = std::variant< int, bool, float, std::string, FloatColor >;
	template < typename T >
	using IsTypeAllowed = std::enable_if_t< std::is_constructible_v< AllowedTypes, T >, T* >;

public:
	CBaseGroup() = default;
	CBaseGroup(std::string name, CBaseGroup* parent = nullptr) {
		m_name = std::string(name);
		if (parent)
			parent->AddChild(this);
	}

	CBaseGroup(size_t idx, CBaseGroup* parent = nullptr) {
		m_name = std::string("( ") + std::to_string(idx) + std::string(" )");
		if (parent)
			parent->AddChild(this);
	};

protected:
	template < typename T, class... Types >
	auto AddOption(const char* name, Types&& ... args) -> T* {
		auto pair = m_options.try_emplace(std::string(name), std::make_unique< std::any >(std::make_any< T >(std::forward< Types >(args)...)));

		if (typeid(T).hash_code() == typeid(KeyBind_t).hash_code())
			g_keybinds.push_back(reinterpret_cast<KeyBind_t*>(pair.first->second.get()));

		return reinterpret_cast<T*>(pair.first->second.get());
	};

	auto AddChild(CBaseGroup* group) -> void { m_children.push_back(group); };
public:
	auto GetName() const -> std::string { return m_name; }

	auto GetJson() -> nlohmann::json& { return m_json; }

	auto SetName(const std::string_view& name) -> void { m_name = name; }

	virtual auto Save() -> void {
		m_json.clear();
		for (auto& [name, opt] : m_options) {
			// TODO: option class with virtual save function (is it good idea?)
			auto any = *opt.get();
			auto hash = any.type().hash_code();

			// find out, could iterate AllowedTypes
			if (typeid(int).hash_code() == hash)
				m_json[name] = std::any_cast<int>(any);
			else if (typeid(bool).hash_code() == hash)
				m_json[name] = std::any_cast<bool>(any);
			else if (typeid(float).hash_code() == hash)
				m_json[name] = std::any_cast<float>(any);
			else if (typeid(std::string).hash_code() == hash)
				m_json[name] = std::any_cast<std::string>(any);
			else if (typeid(FloatColor).hash_code() == hash)
				std::any_cast<FloatColor>(any).to_json(m_json[name]);
			else if (typeid(KeyBind_t).hash_code() == hash)
				std::any_cast<KeyBind_t>(any).to_json(m_json[name]);
		}

		for (auto& child : m_children) {
			child->Save();

			auto json = child->GetJson();
			m_json[child->GetName()] = json;
		}
	}

	virtual auto Load(nlohmann::json& js) -> void {
		m_json.clear();
		m_json = js;
		for (auto& [name, opt] : m_options) {
			// TODO: option class with virtual load function (is it good idea?)
			std::any& any = *opt.get();
			auto hash = any.type().hash_code();

			if (m_json.count(name) <= 0)
				continue;

			try {
				// find out, can iterate AllowedType? 
				if (typeid(int).hash_code() == hash)
					std::any_cast<int&>(any) = m_json[name];
				else if (typeid(bool).hash_code() == hash)
					std::any_cast<bool&>(any) = m_json[name];
				else if (typeid(float).hash_code() == hash)
					std::any_cast<float&>(any) = m_json[name];
				else if (typeid(std::string).hash_code() == hash)
					std::any_cast<std::string&>(any) = m_json[name];
				else if (typeid(FloatColor).hash_code() == hash)
					std::any_cast<FloatColor&>(any).from_json(m_json[name]);
				else if (typeid(KeyBind_t).hash_code() == hash)
					std::any_cast<KeyBind_t&>(any).from_json(m_json[name]);
			}
			catch (std::exception&) {
				continue;
			}
		}

		for (auto& child : m_children) {
			child->Load(m_json[child->GetName()]);
		}
	}
};

// TODO: std::map group
template < class ArrayImpl, class = std::enable_if_t< std::is_base_of< CBaseGroup, ArrayImpl >::value > >
class CArrayGroup : public CBaseGroup {
public:
	CArrayGroup() { }

	CArrayGroup(const std::string& name, size_t count = 0) :
		CBaseGroup(name) {
		m_children.reserve(count);
		for (auto i = 0u; i < count; ++i) {
			m_children.emplace_back(new ArrayImpl(i));
		}
	}

	auto AddEntry() -> size_t {
		size_t idx = m_children.size();
		m_children.emplace_back(new ArrayImpl(idx));
		return idx;
	}

	auto operator[](ptrdiff_t idx) -> ArrayImpl* {
		return (ArrayImpl*)m_children[idx];
	}

	auto Size() const -> size_t {
		return m_children.size();
	};

	// update only children
	virtual auto Save() -> void {
		m_json.clear();
		for (auto& child : m_children) {
			child->Save();

			auto json = child->GetJson();
			m_json[child->GetName()] = json;
		}
	}

	virtual auto Load(nlohmann::json& js) -> void {
		m_json.clear();
		m_json = js;
		for (auto& child : m_children) {
			child->Load(m_json[child->GetName()]);
		}
	}
};

#define group_begin( group_name )                                  \
                                                                   \
  class group_name : public CBaseGroup {                           \
                                                                   \
  public:                                                          \
    group_name( CBaseGroup* parent = nullptr ) :                   \
        CBaseGroup( #group_name, parent ){};                       \
    group_name( const char* name, CBaseGroup* parent = nullptr ) : \
        CBaseGroup( name, parent ){};                              \
                                                                   \
    group_name( size_t idx, CBaseGroup* parent = nullptr ) :       \
        CBaseGroup( idx, parent ) {}

#define group_end() }

#define group_end_child( group_name, var_name ) \
  }                                             \
  ;                                             \
                                                \
  group_name var_name = group_name( XorStr(#group_name), this )

#define add_child_group( group_name, var_name ) group_name var_name = group_name( XorStr(#group_name), this )
#define add_child_group_ex( group_name, var_name ) group_name var_name = group_name( XorStr(#var_name), this )
#define add_child_group_name( group_name, var_name, name ) group_name var_name = group_name( XorStr(name), this )

#define config_option( type, name, ... ) type& name = *this->AddOption< type >( XorStr(#name), __VA_ARGS__ );
#define config_option_separate( type, name, parent, ... ) type& name = *parent.AddOption< type >( XorStr(#name), __VA_ARGS__ );

#define config_keybind( name ) config_option( KeyBind_t, name )
#pragma endregion

class ConVar;

struct SpreadRandom_t {
	float flRand1;
	float flRandPi1;
	float flRand2;
	float flRandPi2;
};

class CVariables : public CBaseGroup {
public:
	typedef struct _GLOBAL {
		bool menuOpen = false;
		bool d3dinitialize = false;
		bool hackUnload = false;
		int FakeDuckWillChoke = 0;
		int FakeWalkWillChoke = 0;
		bool FixCycle;
		bool UnknownCycleFix;
		bool bCreatedRain;
		bool bMoveExploiting;
		Vector vecExploitOrigin;

		// cached random values used by spread, faster than RandomFloat call every hitchance tick ( also thread safe )
		bool RandomInit = false;
		SpreadRandom_t SpreadRandom[256];

		bool WasShooting = false;
		bool WasShootingInChokeCycle = false;
		bool bFinalPacket = false;

		std::vector<std::string> m_vecPaintKits;

		int BobmActivityIndex = -1;

		float flRealYaw;
		QAngle angViewangles;

		bool CorrectShootPosition = false;
		bool WasShootingInPeek = false;
		Vector AimPoint;
		Vector ShootPosition;

		bool NSFixing = false;
		bool bBombActive;
		bool bBombTicked = false;

		float MouseOverrideYaw = 0.0f;
		bool MouseOverrideEnabled = false;
		bool OverridingMinDmg = false;
		bool OverridingHitscan = false;
		bool bInRagebot = false;
		QAngle PreviousViewangles;
		QAngle RegularAngles;
		QAngle FakeAngle;
		float YawDelta = 0.0f;
		bool ResetWeapon = false;
		float LastVelocityModifier = 0.0f;
		float Realtime = 0.f;
		bool IsRoundFreeze = false;
		bool m_bInverted = false;
		bool Fakewalking = false;
		bool bCanWeaponFire = false;
		bool bReleaseGrenade = false;
		bool m_bAimbotShot = false;
		bool m_bOldShot = false;
		int TickbaseAmount = 0;
		int m_iNetworkedTick = 0;
		int LastChokedCommands = 0;
		int iWeaponIndex = 0;
		Vector m_vecNetworkedOrigin;
		float m_flPreviousDuckAmount = 0.0f;
		bool HackIsReady = false;
		bool RenderIsReady = false;
		bool VoiceEnable = false;
		Vector LagOrigin;
		matrix3x4_t LagPosition[128];
		bool m_bUpdatingAnimations;
		bool m_bDelayingShot[65];

		int m_iResolverType[65];
		int m_iResolverType2[65];
		int m_iResolverSide[65];
		int m_iRecordPriority[65];

		int manual_aa = -1; // left, back, right
		int nOverrideEnemy = -1;

		// real bones animation 
		float m_flPoseParams[24] = { };
		Vector   m_RealBonesPositions[256];
		Quaternion m_RealBonesRotations[256];

		// fake animations
		float FakeWeaponPoses[24];
		float m_flFakePoseParams[24] = { };
		bool m_bFakeInit = false;
		QAngle m_FakeAngles = QAngle(0.0f, 0.0f, 0.0f);

		float MenuAlpha = 1.0f;
		IDirect3DDevice9* m_pD3D9Device;

		int m_nPenetrationDmg = 0;
		bool m_bAimAtEnemyThruWallOrVisibleLoool = false; //sry im tired

		uint32_t m_iShotTick = { };

		struct cheat_header_t {
			char username[32];
			uint64_t sub_expiration;
			uint32_t access_token;
		};

		Vector m_vecVelocity;
		Vector m_vecUnpredictedVel;
		float m_speed;
		bool bBrokeLC = false;
		float delta;
		float	 m_lerp;

		cheat_header_t user_info;
		std::string c_login, c_password, server_adress;

		float m_flCurtime;

		int m_iServerType = 0;
		int m_iGameMode = 0;

		bool m_bNewMap = false;

		HINSTANCE hModule;

		std::vector<int> m_PredictionAnimationEventQueue; // queue of animation events to run before animating the local player
		bool m_bAllowAnimationEvents = true;
		std::string szLastHookCalled = XorStr("null");

		bool m_bLocalPlayerHarmedThisTick = false;
		bool m_bRenderingDormant[65];

		std::vector<int> cmds;
		float m_flNextCmdTime = 0.f;
		int m_iLastCommandAck = 0;

		CUserCmd* m_pCmd = nullptr;

		float m_flLastShotTime = 0.f;
		float m_flLastShotTimeInRage = 0.f;

		bool m_bInCreateMove = false;
		bool m_bInPostScreenEffects = false;

		Vector m_vecFixedEyePosition = Vector();

		int m_iFiredShots = 0;
		bool m_bFirstDoubleTapShot = false;
		bool m_bSwitchJitter = false;
		std::vector<std::string> m_hitsounds;

		bool m_bRevolverReady = false;
		bool m_bDraggingKeyBind = false;
		bool m_bDraggingSpecList = false;

		QAngle m_StoredAngle = QAngle(0.f, 0.f, 0.f);
		QAngle m_ShotAngle = QAngle(0.f, 0.f, 0.f);
		bool m_bForceFiringAnimation = false;
		bool m_InHBP = false;

		float m_flJumpFall;
		float m_flAnimFrame;
		float m_flAnimTime;
		float m_flBody;
		float m_flBodyPred;
		bool  m_bUpdate;
		float m_bGround;
		int m_fFlags;

		float m_flBodyPredNoob;
		float m_flAnimTimeNoob;

		std::vector<std::pair<FloatColor, std::string>> m_vecTextInfo[65];

	} GLOBAL, * PGLOBAL;

	group_begin(MENU);
	config_option(int, m_count, 0);
	config_option(int, m_selected, 0);

	config_option(FloatColor, ascent, FloatColor(0.647058824f, 0.57254902f, 0.952941176f, 1.0f));
	config_keybind(key);
	group_end();

#pragma region Skin Changer
	group_begin(skin_changer_data);
	config_option(bool, m_enabled, false);
	config_option(bool, m_filter_paint_kits, true);
	config_option(bool, m_custom, false);
	config_option(int, m_paint_kit, 0);
	config_option(int, m_paint_kit_no_filter, 0);
	config_option(float, m_seed, 0);
	config_option(float, m_stat_trak, 0);
	config_option(float, m_wear, std::numeric_limits<float>::min());
	config_option(std::string, m_custom_name, "");

	// run-time data only
	//friend class Interfaces::feature::SkinChanger;
	//friend class OptionStorage;
	int m_paint_kit_index = 0;
	uint16_t m_definition_index = 0;
	bool m_executed = false;

	group_end();

	group_begin(skin_changer_global_data);
	config_option(bool, m_active, false);

	config_option(bool, m_knife_changer, false);
	config_option(int, m_knife_idx, 0);
	int m_knife_vector_idx = 0;

	config_option(bool, m_glove_changer, false);
	config_option(int, m_gloves_idx, 0);
	int m_gloves_vector_idx = 0;

	bool m_update_gloves = false;
	bool m_update_skins = false;

	group_end();
#pragma endregion

	group_begin(LEGIT_GENERAL);
	config_option(bool, active, false);
	config_option(bool, throughsmoke, false);
	config_option(bool, whileblind, false);
	config_option(bool, ignorejump, false);
	config_option(bool, snipers_only_scope, false);

	config_option(bool, autopistol, false);
	config_option(float, autopistol_delay, 0.0f);

	group_end();

	group_begin(LEGIT);
	config_option(bool, active, false);
	config_option(bool, silent, false);
	config_option(bool, kill_delay, false); // delay between kills
	config_option(bool, fsd_enabled, false); // first shot delay
	config_option(bool, rcs, false);
	config_option(bool, rcs_standalone, false);

	config_option(float, fov, 0.0f);
	config_option(float, smooth, 0.0f);
	config_option(float, rcs_x, 0.0f);
	config_option(float, rcs_y, 0.0f);
	config_option(float, first_shot_delay, 0.0f);
	config_option(float, kill_shot_delay, 0.0f);
	config_option(float, reaction_time, 0.0f);
	config_option(float, randomize, 0.0f);

	config_option(int, rcs_shots, 0);
	config_option(int, hitbox, 0); // Head/Neck/Chest/Stomach/Pelvis
	config_option(int, hitbox_selection, 0); // priority/dynamic/nearest
	config_option(int, smooth_type, 0);

	config_option(bool, auto_delay, false);

	config_option(bool, head_hitbox, false);
	config_option(bool, neck_hitbox, false);
	config_option(bool, chest_hitbox, false);
	config_option(bool, stomach_hitbox, false);
	config_option(bool, pelvis_hitbox, false);
	config_option(bool, arms_hitbox, false);
	config_option(bool, legs_hitbox, false);

	config_option(bool, trg_enabled, false);
	config_option(bool, trg_autowall, false);
	config_option(float, trg_burst, 0.0f); // 0.0-2.0
	config_option(float, trg_delay, 0.0f); // 0.0-1.0
	config_option(float, trg_hitchance, 25.0f); // 0.0-100.0

	config_keybind(trg_key);

	config_option(bool, trg_head_hitbox, false);
	config_option(bool, trg_chest_hitbox, false);
	config_option(bool, trg_stomach_hitbox, false);
	config_option(bool, trg_arms_hitbox, false);
	config_option(bool, trg_legs_hitbox, false);

	config_option(bool, pos_adjustment, false);
	config_option(float, pos_adjustment_range, 200.f);

	config_keybind(key);
	config_option(float, delay, 0);

	int item_idx = 0;

	group_end();

#pragma region Rage general group
	group_begin(RAGE_GENERAL);
	config_option(bool, enabled, false);
	config_keybind(key);
	//config_option( bool, rage_multithread, false );
	config_option(bool, team_check, false);
	//config_option( bool, experimental_resolver, false );

	config_option(bool, silent_aim, false);
	config_option(bool, auto_fire, false);
	config_option(bool, exploit, false);
	config_option(bool, double_tap_teleport, false);
	config_option(bool, double_tap_recharge_threat, false);
	config_option(bool, double_tap_adaptive, false);
	config_option(bool, double_tap_duck, false);
	config_option(int, double_tap_reserve, 2);
	config_option(int, double_tap_type, 0);

	config_keybind(double_tap_bind);
	//	config_keybind( hide_shots_bind );
	//	config_option( bool, break_lagcomp, false );

	config_keybind(prefer_head);
	config_keybind(prefer_safe);
	config_option(bool, override_resolver_flicks, false);

	// temporary here
	config_option(bool, hide_shots, false);

	config_keybind(hitbox_override_bind);
	config_keybind(key_dmg_override);
	config_keybind(key_dt);
	config_keybind(override_key);
	config_keybind(force_safe_point);

	config_option(bool, force_safe_head, false);

	// debug stuff here.
#if defined(DEV) || defined(BETA_MODE) || defined(DEBUG_MODE)
	config_option(bool, visualize_safepoints, false);
	config_option(bool, visualize_basic_safepoints, false);
	config_option(bool, visualize_aimpoints, false);
	config_option(bool, visualize_resolved_angles, false);
	config_option(bool, visualize_extrap_stomach, false);
	config_option(bool, breaking_lc, false);
#endif

	group_end();

	group_begin(RAGE);
	config_option(bool, active, false);

	config_option(int, min_damage, 0);
	config_option(int, min_damage_visible, 0);
	config_option(float, hitchance, 0.0f);
	config_option(float, doubletap_hitchance, 55.f);
	config_option(int, doubletap_dmg, 50);
	config_option(int, max_misses, 5);
	config_option(float, hitchance_accuracy, 0.0f);

	config_option(bool, health_override, false);
	config_option(float, health_override_amount, 0.0f);

	config_option(bool, silent_aim, false);
	config_option(bool, auto_fire, false);
	config_option(bool, aim_lock, false);
	//config_option( bool, remove_recoil, false );
	config_option(bool, friendly_fire, false);
	config_option(bool, exploit_enable, false);
	config_option(bool, autowall, false);
	config_option(bool, autoscope, false);
	config_option(bool, autoscope_hc, false);
	config_option(int, target_selection, 0);
	config_option(int, autostop, 0);//XD
	config_option(bool, autostop_check, false);

	config_option(bool, always_stop, false);
	config_option(bool, early_stop, false);

	config_option(bool, body_aim_if_lethal, false);
	config_option(bool, between_shots, false);

	config_option(bool, hitbox_override, false);
	config_option(bool, min_damage_override, false);
	config_option(int, min_damage_override_amount, 0);

	config_option(int, hitbox_selection, 0); // Damage, Accuracy

	config_option(bool, static_point_scale, false);
	config_option(bool, hitboxes_head, false);
	config_option(bool, hitboxes_neck, false);
	config_option(bool, hitboxes_chest, false);
	config_option(bool, hitboxes_stomach, false);
	config_option(bool, hitboxes_pelvis, false);
	config_option(bool, hitboxes_arms, false);
	config_option(bool, hitboxes_legs, false);
	config_option(bool, hitboxes_feets, false);

	config_option(bool, hitboxes_ovr_head, false);
	config_option(bool, hitboxes_ovr_neck, false);
	config_option(bool, hitboxes_ovr_chest, false);
	config_option(bool, hitboxes_ovr_stomach, false);
	config_option(bool, hitboxes_ovr_pelvis, false);
	config_option(bool, hitboxes_ovr_arms, false);
	config_option(bool, hitboxes_ovr_legs, false);
	config_option(bool, hitboxes_ovr_feets, false);

	config_option(float, point_scale, 40.f);
	config_option(float, body_point_scale, 60.f);

	config_option(bool, prefer_safety_basic, false);
	config_option(bool, prefer_safety_complex, false);

	config_option(bool, prefer_body, false);
	config_option(bool, prefer_body_disable_shot, false);
	config_option(bool, prefer_body_disable_resolved, false);
	config_option(bool, prefer_body_disable_safepoint_head, false);
	config_option(bool, prefer_body_disable_low_damage, false);

	config_option(bool, mp_hitboxes_head, false);
	config_option(bool, mp_hitboxes_chest, false);
	config_option(bool, mp_hitboxes_stomach, false);
	config_option(bool, mp_hitboxes_legs, false);
	config_option(bool, mp_hitboxes_feets, false);

	config_option(bool, on_shot_aa, false);
	config_option(bool, delay_shot_on_unducking, false);
	config_option(bool, delay_shot_on_peek, false);
	config_option(bool, accry_boost_on_shot, false);
	config_option(int, accry_boost_on_shot_modes, 0);

	config_option(bool, shotdelay, 0);
	config_option(bool, doubletap_pen_dmg, false);
	config_option(float, shotdelay_amount, 0.0f);

	//config_option( bool, improve_accuracy_on_shot, false );

	group_end();
#pragma endregion

#pragma region Antiaim group
	group_begin(ANTIAIM_STATE);
	config_option(int, pitch, 0);
	config_option(int, yaw, 0);
	config_option(int, base_yaw, 0);
	config_option(int, jitter_mode, 0);
	config_option(int, fake_yaw, 0);
	config_option(float, body_lean, 0.f);
	config_option(float, inverted_body_lean, 0.f);

	config_option(bool, jitter, false);
	config_option(bool, jitter_in_air, false);
	config_option(bool, jitter_moving, false);
	config_option(bool, jitter_standing, false);
	config_option(bool, jitter_walking, false);
	config_option(int, jitter_type, 0);
	config_option(float, jitter_range, 15.0f);

	config_option(bool, inverter, false);
	config_option(bool, inverter_in_air, false);
	config_option(bool, inverter_moving, false);
	config_option(bool, inverter_standing, false);
	config_option(bool, inverter_walking, false);

	config_option(bool, spin, false);
	config_option(bool, spin_switch, false);
	config_option(float, spin_range, 30.0f);
	config_option(float, spin_speed, 4.0f);

	config_option(bool, autodirection, false);
	config_option(bool, autodirection_ignore_duck, false);

	config_option(int, desync_autodir, 0); // Off/Hide Real/Hide Fake

	group_end();

	group_begin(ANTIAIM);

	config_option(bool, enabled, false);
	config_option(bool, manual, false);
	config_option(FloatColor, manual_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(bool, bomb_activity, false);

	config_keybind(desync_flip_bind);
	config_keybind(manual_left_bind);
	config_keybind(manual_right_bind);
	config_keybind(manual_back_bind);
	config_keybind(mouse_override);
	config_keybind(autodirection_override);

	config_option(float, distort_speed, 5.0f);
	config_option(float, distort_range, 180.0f);
	config_option(bool, distort_manual_aa, false);
	config_option(bool, distort_twist, false);
	config_option(bool, distort_spin, false);
	config_option(bool, distort_randomize, false);
	config_option(bool, distort_lby_update, false);

	config_option(bool, freestand, false);
	config_option(bool, draw_angles, false);
	config_option(bool, freestand_invert, false);
	config_option(bool, freestand_lock, false);
	config_option(bool, freestand_disable_fakewalk, false);
	config_option(bool, freestand_disable_run, false);
	config_option(bool, freestand_disable_air, false);

	config_option(bool, distort, false);
	config_option(bool, distort_disable_fakewalk, false);
	config_option(bool, distort_disable_run, false);
	config_option(bool, distort_disable_air, false);

	config_option(int, break_lby, 0);
	config_option(int, yaw_addition, 8);
	config_option(int, random_jitter, 15);

	config_option(bool, hide_real_on_shot, false);
	config_keybind(desync_jitter_key);

	group_end();
#pragma endregion

#pragma region Fakelag group
	group_begin(FAKELAG);

	config_option(bool, enabled, false);
	config_option(int, choke, 2);
	config_option(int, choke_type, 0);
	config_option(float, variance, 0.f);
	config_option(int, iLagLimit, 14);
	config_option(bool, when_standing, false);
	config_option(bool, when_moving, false);
	config_option(bool, when_air, false);
	//config_option( bool, when_exploits, false );

	// alternative conditions
	config_option(bool, trigger_duck, false);
	config_option(bool, trigger_land, false);
	config_option(bool, trigger_weapon_activity, false);
	config_option(bool, trigger_shooting, false);
	config_option(bool, trigger_reloading, false);
	config_option(bool, trigger_on_peek, false);
	config_option(bool, lby_update, false);
	config_option(bool, break_lag_compensation, false);
	config_option(int, alternative_choke, 2);
	group_end();
#pragma endregion

#pragma region ESP group
	// TODO: separate visuals from esp
	group_begin(ESP);
	config_option(bool, esp_enable, false);
	config_option(bool, box, false);
	config_option(int, box_type, 0);
	config_option(FloatColor, box_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(bool, health, false);
	config_option(bool, health_override, false);
	config_option(FloatColor, health_color, FloatColor(0.0f, 1.0f, 0.0f, 1.0f));
	config_option(int, health_pos, 0);

	config_option(bool, health_team, false);
	config_option(bool, health_override_team, false);
	config_option(FloatColor, health_color_team, FloatColor(0.0f, 1.0f, 0.0f, 1.0f));

	config_option(bool, armor_bar, false);
	config_option(int, armor_pos, 0);
	config_option(FloatColor, dormant_color, FloatColor(0.58823529411f, 0.58823529411f, 0.58823529411f, 1.0f));

	config_option(bool, info, false);
	config_option(bool, draw_armor, false);
	config_option(bool, draw_bombc4, false);
	config_option(bool, draw_resolver, false);
	config_option(bool, draw_scoped, false);
	config_option(bool, draw_money, false);
	config_option(bool, draw_distance, false);
	config_option(bool, draw_flashed, false);
	config_option(bool, draw_reloading, false);
	config_option(bool, draw_grenade_pin, false);
	config_option(bool, draw_defusing, false);
	config_option(bool, team_check, false);
	config_option(bool, draw_ammo_bar, false);
	config_option(bool, draw_ammo_bar_team, false);
	config_option(bool, draw_lby_bar, false);
	config_option(bool, draw_name, false);
	config_option(bool, draw_name_team, false);
	config_option(int, selection, 0);
	config_option(FloatColor, name_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, name_color_team, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, weapon_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, weapon_color_team, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, ammo_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, ammo_color_team, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, lby_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(bool, weapon, false);
	config_option(bool, weapon_team, false);
	config_option(bool, weapon_ammo, false);
	config_option(bool, weapon_ammo_team, false);
	config_option(bool, weapon_icon, false);
	config_option(bool, weapon_icon_team, false);
	config_option(FloatColor, weapon_icon_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, weapon_icon_color_team, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, skeleton, false);
	config_option(bool, skeleton_team, false);
	config_option(FloatColor, skeleton_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, skeleton_color_team, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, aim_points, false);
	config_option(FloatColor, aim_points_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(int, info_pos, 0);

	config_option(bool, chams_enabled, false);

	config_option(bool, chams_local, false);
	config_option(bool, chams_ghost, false);
	config_option(bool, chams_hands, false);
	config_option(bool, chams_weapon, false);
	config_option(bool, chams_attachments, false);
	config_option(int, chams_type, 0);
	config_option(bool, chams_enemy, false);
	config_option(bool, chams_teammate, false);
	//	config_option( bool, chams_death_enemy, false );
		//config_option( bool, chams_death_teammate, false );
		//config_option( bool, chams_lag, false );
	config_option(bool, chams_history, false);

	config_option(int, chams_local_mat, 0);
	config_option(int, chams_desync_mat, 0);
	config_option(int, hands_chams_mat, 0);
	config_option(int, weapon_chams_mat, 0);
	config_option(int, attachments_chams_mat, 0);
	config_option(int, enemy_chams_mat, 0);
	config_option(int, team_chams_mat, 0);
	config_option(int, enemy_chams_death_mat, 0);
	config_option(int, team_chams_death_mat, 0);
	config_option(int, chams_lag_mat, 0);
	config_option(int, chams_history_mat, 0);
	config_option(int, chams_hitmatrix_mat, 0);

	config_option(bool, enemy_chams_xqz, false);
	config_option(bool, enemy_chams_vis, false);
	config_option(bool, team_chams_xqz, false);
	config_option(bool, team_chams_vis, false);
	/*config_option( bool, enemy_death_chams_xqz, false );
	config_option( bool, enemy_death_chams_vis, false );
	config_option( bool, team_death_chams_xqz, false );
	config_option( bool, team_death_chams_vis, false );*/
	config_option(bool, enemy_death_chams_history_xqz, false);
	config_option(bool, enemy_death_chams_history_vis, false);

	config_option(bool, chams_local_outline, false);
	config_option(bool, chams_local_outline_wireframe, false);

	config_option(bool, chams_ghost_outline, false);
	config_option(bool, chams_ghost_outline_wireframe, false);

	config_option(bool, chams_enemy_outline, false);
	config_option(bool, chams_enemy_outline_wireframe, false);

	config_option(bool, chams_hands_outline, false);
	config_option(bool, chams_hands_outline_wireframe, false)
		config_option(bool, chams_weapon_outline, false);
	config_option(bool, chams_weapon_outline_wireframe, false)
		config_option(bool, chams_attachments_outline, false)
		config_option(bool, chams_attachments_outline_wireframe, false)
		config_option(bool, chams_teammate_outline, false);
	config_option(bool, chams_teammate_outline_wireframe, false);

	/*config_option( bool, chams_enemy_death_outline, false );
	config_option( bool, chams_teammate_death_outline, false );*/
	config_option(bool, chams_history_outline, false);
	config_option(bool, chams_lag_outline, false);
	config_option(bool, chams_hitmatrix_outline, false);

	config_option(float, chams_local_outline_value, 0.f);
	config_option(float, chams_ghost_outline_value, 0.f);
	config_option(float, chams_hands_outline_value, 0.f);
	config_option(float, chams_weapon_outline_value, 0.f);
	config_option(float, chams_attachments_outline_value, 0.f);
	config_option(float, chams_enemy_outline_value, 0.f);
	config_option(float, chams_teammate_outline_value, 0.f);
	/*config_option( float, chams_enemy_death_outline_value, 0.f );
	config_option( float, chams_teammate_death_outline_value, 0.f );*/
	config_option(float, chams_history_outline_value, 0.f);
	config_option(float, chams_lag_outline_value, 0.f);
	config_option(float, chams_hitmatrix_outline_value, 0.f);

	config_option(FloatColor, chams_local_shine_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_ghost_shine_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_hands_shine_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_weapon_shine_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_enemy_shine_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_teammate_shine_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	/*	config_option( FloatColor, chams_enemy_death_shine_color, FloatColor( 1.0f, 1.0f, 1.0f, 1.0f ) );
		config_option( FloatColor, chams_teammate_death_shine_color, FloatColor( 1.0f, 1.0f, 1.0f, 1.0f ) );*/
	config_option(FloatColor, chams_history_shine_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_lag_shine_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_hitmatrix_shine_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(FloatColor, chams_local_outline_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_ghost_outline_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_hands_outline_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_weapon_outline_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_attachments_outline_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_enemy_outline_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_teammate_outline_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	/*config_option( FloatColor, chams_enemy_death_outline_color, FloatColor( 1.0f, 1.0f, 1.0f, 1.0f ) );
	config_option( FloatColor, chams_teammate_death_outline_color, FloatColor( 1.0f, 1.0f, 1.0f, 1.0f ) );*/
	config_option(FloatColor, chams_history_outline_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_lag_outline_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_hitmatrix_outline_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(FloatColor, chams_local_pearlescence_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(float, chams_local_pearlescence, 0.f);
	config_option(float, chams_local_shine, 0.f);

	config_option(FloatColor, chams_enemy_pearlescence_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(float, chams_enemy_pearlescence, 0.f);
	config_option(float, chams_enemy_shine, 0.f);

	config_option(FloatColor, chams_team_pearlescence_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(float, chams_team_pearlescence, 0.f);
	config_option(float, chams_team_shine, 0.f);

	config_option(FloatColor, chams_local_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_desync_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, hands_chams_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, weapon_chams_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, attachments_chams_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, enemy_chams_color_vis, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, team_chams_color_vis, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, enemy_chams_color_xqz, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, team_chams_color_xqz, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	/*config_option( FloatColor, enemy_death_chams_color_vis, FloatColor( 1.0f, 1.0f, 1.0f, 1.0f ) );
		config_option( FloatColor, team_death_chams_color_vis, FloatColor( 1.0f, 1.0f, 1.0f, 1.0f ) );
		config_option( FloatColor, enemy_death_chams_color_xqz, FloatColor( 1.0f, 1.0f, 1.0f, 1.0f ) );
		config_option( FloatColor, team_death_chams_color_xqz, FloatColor( 1.0f, 1.0f, 1.0f, 1.0f ) );*/
	config_option(FloatColor, chams_lag_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, chams_history_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, hitmatrix, false);
	config_option(FloatColor, hitmatrix_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(float, hitmatrix_time, 4.0f);

	config_option(bool, hitskeleton, false);
	config_option(FloatColor, hitskeleton_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(float, hitskeleton_time, 4.0f);

	config_option(bool, glow_enemy, false);
	config_option(bool, glow_team, false);
	config_option(bool, glow_weapons, false);
	config_option(bool, glow_grenade, false);
	config_option(FloatColor, glow_weapons_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, glow_enemy_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, glow_team_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, glow_grenade_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(int, glow_type, 0);

	config_option(bool, glow_local, false);
	config_option(FloatColor, glow_local_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, NadePred, false);
	config_option(FloatColor, nade_pred_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, walls, false);
	config_option(bool, props, false);
	config_option(bool, skybox, false);

	config_option(FloatColor, wall_modulation, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, props_modulation, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, skybox_modulation, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, beam_enabled, false);
	config_option(int, beam_type, 2);

	config_option(bool, offscren_enabled, false);
	config_option(float, offscren_size, 16);
	config_option(float, offscren_distance, 50);
	config_option(FloatColor, offscreen_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, offscreen_outline_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(bool, remove_scope, false);
	config_option(int, remove_scope_type, 0);
	config_option(bool, remove_scope_zoom, false);
	config_option(bool, remove_scope_blur, false);
	config_option(bool, remove_recoil_shake, false);
	config_option(bool, remove_recoil_punch, false);
	config_option(bool, remove_flash, false);
	config_option(bool, remove_smoke, false);
	config_option(bool, remove_sleeves, false);
	config_option(bool, remove_hands, false);
	config_option(bool, remove_bob, false);
	config_option(bool, draw_layer_info, false);
	config_option(int, layer, 2);
	config_option(bool, preserve_killfeed, false);
	config_option(float, preserve_killfeed_time, 1.0f);

	config_option(bool, draw_c4_bar, false);
	config_option(bool, draw_c4, false);
	config_option(FloatColor, c4_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, autowall_crosshair, false);
	config_option(float, autowall_crosshair_height, 0.f);

	config_option(bool, skip_occulusion, false);

	config_option(bool, nades, false);
	config_option(FloatColor, nades_text_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, dropped_weapons, false);
	config_option(bool, dropped_weapons_ammo, false);
	config_option(FloatColor, dropped_weapons_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, dropped_weapons_ammo_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, skeleton_history, false);
	config_option(int, skeleton_history_type, 0);
	config_option(FloatColor, skeleton_history_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(int, sky_changer, 0);

	config_option(bool, extended_esp, false);

	config_option(bool, fov_crosshair, false);
	config_option(FloatColor, fov_crosshair_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, force_sniper_crosshair, false);

	config_option(bool, event_bomb, false);
	config_option(bool, event_harm, false);
	config_option(bool, event_dmg, false);
	config_option(bool, event_buy, false);
	config_option(bool, event_resolver, false);
	config_option(bool, event_misc, false);
	config_option(bool, event_console, false);

	config_option(bool, keybind_window_enabled, false);
	config_option(float, keybind_window_x, 600.f);
	config_option(float, keybind_window_y, 120.f);

	config_option(bool, spec_window_enabled, false);
	config_option(float, spec_window_x, 200.f);
	config_option(float, spec_window_y, 120.f);

	config_option(bool, aa_indicator, false);
	config_option(int, aa_indicator_type, 0);
	config_option(FloatColor, aa_indicator_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, stat_logger, false);

	config_option(bool, vizualize_hitmarker, false);
	config_option(bool, visualize_hitmarker_world, false);
	config_option(bool, visualize_damage, false);

	config_option(bool, grenades_indicator, false);

	config_option(bool, fade_esp, false);

	config_option(bool, dynamic_scope_lines, false);

	config_option(bool, zeus_distance, false);
	config_option(FloatColor, zeus_distance_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(bool, spectator_list, false);

	config_option(float, world_fov, 90.f);

	config_option(bool, draw_hitboxes, false);

	config_option(bool, blur_in_scoped, false);
	config_option(float, blur_in_scoped_value, 50.f);

	config_option(int, event_logger_type, 0);

	config_option(bool, watermark, false);
	config_option(bool, aspect_ratio, false);
	config_option(float, aspect_ratio_value, 1.5f);

	config_option(bool, remove_blur_effect, false);
	config_option(bool, remove_post_proccesing, false);

	config_option(FloatColor, server_impacts, FloatColor(0.0f, 0.0f, 1.0f, 0.49f));
	config_option(FloatColor, client_impacts, FloatColor(1.0f, 0.0f, 0.0f, 0.49f));

	config_option(FloatColor, hitboxes_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, pulse_offscreen_alpha, false);
	config_option(bool, offscreen_outline, false);
	config_option(bool, text_indicators, false);

	config_option(bool, fullbright, false);

	config_option(float, model_brightness, 0);
	config_option(FloatColor, bloom_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(bool, night_mode, false);
	config_option(float, world_adjustement_value, 50.f);
	config_option(float, prop_adjustement_value, 50.f);
	config_option(float, transparent_props, 67.f);
	config_option(int, weather, 0);
	config_option(float, weather_alpha, 40.f);

	config_option(bool, indicator_side, false);
	config_option(bool, indicator_exploits, false);
	config_option(bool, indicator_dmg, false);
	config_option(bool, indicator_baim, false);
	config_option(bool, indicator_lby, false);
	config_option(bool, indicator_breaklc, false);
	config_option(bool, indicator_aimbot, false);
	config_option(bool, indicator_fake_duck, false);
	config_option(FloatColor, indicator_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, chams_on_death_enemy, false);
	config_option(bool, chams_on_death_teamate, false);

	config_option(bool, fog_effect, false);
	config_option(bool, fog_blind, false);
	config_option(float, fog_density, 0.f);
	config_option(float, fog_hdr_scale, 0.f);
	config_option(int, fog_distance, 1000);
	config_option(FloatColor, fog_color, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));
	config_option(FloatColor, fog_color_secondary, FloatColor(1.0f, 1.0f, 1.0f, 1.0f));

	config_option(bool, ambient_ligtning, false);
	config_option(FloatColor, ambient_ligtning_color, FloatColor(0.06666666666, 0.06666666666, 0.090196, 1.0f));

	group_end();
#pragma endregion

#pragma region MISC group
	group_begin(MISC);

	config_option(bool, active, false);
	config_option(bool, autojump, false);
	config_option(bool, autostrafer, false);
	config_option(bool, autostrafer_wasd, false);
	config_option(bool, move_exploit, false);
	config_keybind(move_exploit_key);

	config_option(bool, instant_stop, false);
	config_keybind(instant_stop_key);

	config_option(bool, fastduck, false);
	config_option(bool, doubleflick, false);
	config_option(bool, minijump, false);
	config_option(bool, edgejump, false);
	config_keybind(edgejump_bind);
	config_option(bool, duckjump, false);
	config_option(bool, quickstop, false);
	config_option(bool, accurate_walk, false);
	config_option(bool, slide_walk, false);
	config_option(bool, fakeduck, false);
	config_keybind(fakeduck_bind);

	config_option(bool, third_person, false);
	config_option(bool, third_person_on_grenade, false);
	config_keybind(third_person_bind);
	config_option(float, third_person_dist, 100.f);

	config_option(bool, slow_walk, false);
	config_option(int, slow_walk_type, 0);
	config_keybind(slow_walk_bind);

	config_option(float, viewmodel_fov, 68.f);
	config_option(bool, viewmodel_change, false);
	config_option(float, viewmodel_x, 2.f);
	config_option(float, viewmodel_y, 2.f);
	config_option(float, viewmodel_z, -2.f);

	config_option(bool, indicators_enabled, false);
	config_option(bool, indicator_lc, false);

	config_option(bool, hitsound, false);
	config_option(int, hitsound_type, 0);
	config_option(int, hitsound_custom, 0);
	config_option(float, hitsound_volume, 100.f);

	config_option(bool, print_color, false);
	config_option(FloatColor, log_color, FloatColor(0.647058824f, 0.57254902f, 0.952941176f, 1.0f));
	config_option(bool, log_ping, false);
	config_option(bool, clantag_changer, false);

	config_option(bool, chat_spammer, false);

	config_option(bool, lag_exploit, false);
	config_option(int, lag_exploit_key, 0);

	config_option(bool, autobuy_enabled, false);
	config_option(int, autobuy_first_weapon, 0);
	config_option(int, autobuy_second_weapon, 0);
	config_option(bool, autobuy_flashbang, false);
	config_option(bool, autobuy_smokegreanade, false);
	config_option(bool, autobuy_molotovgrenade, false);
	config_option(bool, autobuy_hegrenade, false);
	config_option(bool, autobuy_decoy, false);
	config_option(bool, autobuy_armor, false);
	config_option(bool, autobuy_zeus, false);
	config_option(bool, autobuy_defusekit, false);

	config_option(bool, impacts_spoof, false);
	config_option(bool, server_impacts_spoof, false);

	config_option(bool, hold_firing_animation, false);

	config_option(bool, hit_logger_frame, false);

	config_option(bool, knife_bot, false);
	config_option(int, knife_bot_type, 0);

	config_option(bool, zeus_bot, false);
	config_option(float, zeus_bot_hitchance, 80.f);

	config_option(bool, sv_pure_bypass, false);

	config_option(bool, extended_backtrack, false);
	config_option(float, extended_backtrack_time, 0.2f);
	config_keybind(extended_backtrack_key);

	config_option(bool, anti_untrusted, true);

	config_option(bool, autopeek, false);
	config_option(bool, autopeek_visualise, false);
	config_keybind(autopeek_bind);
	config_option(FloatColor, autopeek_color, FloatColor(1.0f, 1.0f, 1.0f, 0.5f));

	config_option(bool, skins_model, false);
	config_option(int, ct_model_type, 0);
	config_option(int, tt_model_type, 0);
	config_option(int, local_model_type, 0);

	config_option(bool, money_revealer, false);
	config_option(bool, auto_accept, false);


	config_option(bool, unlock_inventory, false);
	config_option(bool, auto_release_grenade, false);

	//	config_option( int, server_region, 0 );
	//	config_option( int, search_max_ping, 100 );

	config_option(bool, ingame_radar, false);
	config_option(bool, watermark, true);


#if defined(BETA_MODE) || defined(DEV)
	config_option(bool, undercover_log, false);
	config_option(bool, undercover_watermark, false);

#if defined(DEV)
	config_option(int, what_developer_is_this, 0);
#endif

#endif

	group_end();

#pragma endregion

	add_child_group_ex(MENU, menu);
	add_child_group_ex(RAGE_GENERAL, rage);

	RAGE* rage_option();

	add_child_group_ex(RAGE, rage_default);
	add_child_group_ex(RAGE, rage_pistols);
	add_child_group_ex(RAGE, rage_heavypistols);
	add_child_group_ex(RAGE, rage_rifles);
	add_child_group_ex(RAGE, rage_awp);
	add_child_group_ex(RAGE, rage_scout);
	add_child_group_ex(RAGE, rage_autosnipers);
	add_child_group_ex(RAGE, rage_smgs);
	add_child_group_ex(RAGE, rage_heavys);
	add_child_group_ex(RAGE, rage_shotguns);

	add_child_group_ex(ANTIAIM, antiaim);
	add_child_group_ex(ANTIAIM_STATE, antiaim_stand);
	//add_child_group_ex( ANTIAIM_STATE, antiaim_move );
	//add_child_group_ex( ANTIAIM_STATE, antiaim_air );
	add_child_group_ex(LEGIT_GENERAL, legit);
	add_child_group_ex(FAKELAG, fakelag);
	add_child_group_ex(ESP, esp);
	add_child_group_ex(MISC, misc);
	add_child_group_ex(skin_changer_global_data, m_global_skin_changer);
	CArrayGroup<skin_changer_data> m_skin_changer;


	config_option(int, skins_glove_kit, 0);
	config_option(int, skins_gloves, 0);
	config_option(int, skins_knife, 0);

	add_child_group_ex(LEGIT, legit_pistols);
	add_child_group_ex(LEGIT, legit_heavypistols);
	add_child_group_ex(LEGIT, legit_rifles);
	add_child_group_ex(LEGIT, legit_snipers);
	add_child_group_ex(LEGIT, legit_autosnipers);
	add_child_group_ex(LEGIT, legit_smgs);
	add_child_group_ex(LEGIT, legit_heavys);
	add_child_group_ex(LEGIT, legit_shotguns);

	GLOBAL globals;

	// convars
	ConVar* sv_accelerate;
	ConVar* sv_airaccelerate;
	ConVar* sv_gravity;
	ConVar* sv_jump_impulse;
	ConVar* sv_penetration_type;

	ConVar* m_yaw;
	ConVar* m_pitch;
	ConVar* sensitivity;

	ConVar* cl_sidespeed;
	ConVar* cl_forwardspeed;
	ConVar* cl_upspeed;
	ConVar* cl_extrapolate;

	ConVar* sv_noclipspeed;

	ConVar* weapon_recoil_scale;
	ConVar* view_recoil_tracking;

	ConVar* r_jiggle_bones;

	ConVar* mp_friendlyfire;

	ConVar* sv_maxunlag;
	ConVar* sv_minupdaterate;
	ConVar* sv_maxupdaterate;

	ConVar* sv_client_min_interp_ratio;
	ConVar* sv_client_max_interp_ratio;

	ConVar* cl_interp_ratio;
	ConVar* cl_interp;
	ConVar* cl_updaterate;

	ConVar* game_type;
	ConVar* game_mode;

	ConVar* ff_damage_bullet_penetration;
	ConVar* ff_damage_reduction_bullets;

	ConVar* mp_damage_scale_ct_head;
	ConVar* mp_damage_scale_t_head;
	ConVar* mp_damage_scale_ct_body;
	ConVar* mp_damage_scale_t_body;

	ConVar* mp_damage_headshot_only;
	ConVar* viewmodel_fov;
	ConVar* viewmodel_offset_x;
	ConVar* viewmodel_offset_y;
	ConVar* viewmodel_offset_z;

	ConVar* mat_ambient_light_r;
	ConVar* mat_ambient_light_g;
	ConVar* mat_ambient_light_b;

	ConVar* sv_show_impacts;

	ConVar* molotov_throw_detonate_time;
	ConVar* weapon_molotov_maxdetonateslope;
	ConVar* net_client_steamdatagram_enable_override;
	ConVar* mm_dedicated_search_maxping;
	ConVar* cl_csm_shadows;

	ConVar* developer;
	ConVar* con_enable;
	ConVar* con_filter_enable;
	ConVar* con_filter_text;
	ConVar* con_filter_text_out;
	ConVar* contimes;
	ConVar* crosshair;

	ConVar* r_drawmodelstatsoverlay;
	ConVar* sv_clip_penetration_traces_to_players;
	ConVar* sv_clockcorrection_msecs;
	ConVar* sv_max_usercmd_future_ticks;
	ConVar* sv_maxusrcmdprocessticks;
	ConVar* engine_no_focus_sleep;
	ConVar* r_3dsky;

	ConVar* host_limitlocal;

	ConVar* r_RainRadius;
	ConVar* r_rainalpha;

	void Create();
};

struct WeaponName_t {
	constexpr WeaponName_t(int32_t definition_index, const char* name) :
		definition_index(definition_index),
		name(name) {
	}

	int32_t definition_index = 0;
	const char* name = nullptr;
};

extern CVariables g_Vars;

```

`CSGO SDK/SDK/Classes/CCSGO_HudDeathNotice.cpp`:

```cpp
#include "CCSGO_HudDeathNotice.hpp"
#include <Windows.h>

WrapperForTableDEATHNOTICEHUD * CCSGO_DeathNoticeDown::TableAccessor2( )
{
  m_WrapTable.Think( m_vPtr, this );

  return &m_WrapTable;
}

template<typename T>
T TABLE_wrapper::GetPtrByIndex( int i )
{
  return this ( T ) [ i ];
}

void WrapperForTableDEATHNOTICEHUD::Think( TABLE_wrapper * table, CCSGO_DeathNoticeDown * _this )
{
  m_Table = table;
  this->_this = ( CCSGO_DeathNoticeDown * ) ( ( DWORD ) ( ( DWORD ) _this + 20 ) );
}

char * WrapperForTableDEATHNOTICEHUD::GetHudName( )
{
  typedef char * ( __thiscall * fn )( void * );
  return ( ( fn ) m_Table->GetHudName )( _this );
}

int WrapperForTableDEATHNOTICEHUD::EraseNotices( )
{
  *( bool * ) ( ( DWORD ) _this + 0x8 ) = 0;
  typedef int( __thiscall * fn )( void * );
  return ( ( fn ) m_Table->EraseNotice )( _this );
}
```

`CSGO SDK/SDK/Classes/CCSGO_HudDeathNotice.hpp`:

```hpp
#pragma once
// Generated using ReClass 2016

class CCSGO_DeathNoticeDown;
class N00000116;
class N00000229;
class CPanoramaPanel;
class N0000024F;
class N00000252;
class N00000256;
class N0000048C;
class N0000049E;
class CCSGO_HudDeathNotice;
class N000004C2;
class N000004D9;
class TABLE;
class N00000510;
class N00000524;
class N00000528;
class N0000053A;
class N0000054D;
class N00000550;
class N0000055E;
class N00000561;
class N00000573;
class TABLE_wrapper;
class N000005BF;

class TABLE_wrapper
{
public:
private:
  char pad_0x0000 [ 0x1C ]; //0x0000
public:
  void * EraseNotice; //0x001C 
private:
  char pad_0x0020 [ 0x10 ]; //0x0020
public:
  void * GetHudName; //0x0030 
private:
  char pad_0x0034 [ 0x50 ]; //0x0034
public:
  template <typename T>
  T GetPtrByIndex( int i );
}; //Size=0x0084

class WrapperForTableDEATHNOTICEHUD {
private:
  TABLE_wrapper * m_Table;
  CCSGO_DeathNoticeDown * _this;

public:
  void Think( TABLE_wrapper * table, CCSGO_DeathNoticeDown * _this );

public:
  char * GetHudName( );

  int EraseNotices( );
};

class CCSGO_DeathNoticeDown
{
public:
private:
  char pad_0x0000 [ 0x14 ]; //0x0000
public:
  TABLE_wrapper * m_vPtr; //0x0014 
private:
  char pad_0x0018 [ 0x1C ]; //0x0018
public:
  char * m_szNameOfHud; //0x0034 
private:
  char pad_0x0038 [ 0x20 ]; //0x0038
public:
  N00000116 * SomeInstance; //0x0058 
private:
  char pad_0x005C [ 0x4 ]; //0x005C
public:
  float m_flTime; //0x0060 
  float m_flLocalTime; //0x0064 
  float m_flUnknown; //0x0068 
private:
  char pad_0x006C [ 0x3D4 ]; //0x006C
  WrapperForTableDEATHNOTICEHUD m_WrapTable;
public:
  WrapperForTableDEATHNOTICEHUD * TableAccessor2( );

}; //Size=0x0440

class N00000116
{
public:
private:
  char pad_0x0000 [ 0x4 ]; //0x0000
public:
  N00000229 * N00000118; //0x0004 
private:
  char pad_0x0008 [ 0x43C ]; //0x0008

}; //Size=0x0444

class N00000229
{
public:
  CPanoramaPanel * N0000022A; //0x0000 
private:
  char pad_0x0004 [ 0x28 ]; //0x0004
public:
  __int32 m_iUnknownNotChange; //0x002C 
private:
  char pad_0x0030 [ 0x1C ]; //0x0030

}; //Size=0x004C

class CPanoramaPanel
{
public:
private:
  char pad_0x0000 [ 0xC0 ]; //0x0000
public:
  void * GetUnknown; //0x00C0 
private:
  char pad_0x00C4 [ 0x7E7 ]; //0x00C4

}; //Size=0x08AB

class N0000024F
{
public:
private:
  char pad_0x0000 [ 0x4 ]; //0x0000

}; //Size=0x0004

class N00000252
{
public:
private:
  char pad_0x0000 [ 0x4 ]; //0x0000

}; //Size=0x0004

class N00000256
{
public:
private:
  char pad_0x0000 [ 0x4 ]; //0x0000

}; //Size=0x0004

class N0000048C
{
public:
  N0000049E * N0000048D; //0x0000 
private:
  char pad_0x0004 [ 0x3C ]; //0x0004

}; //Size=0x0040

class N0000049E
{
public:
private:
  char pad_0x0000 [ 0x44 ]; //0x0000

}; //Size=0x0044

class CCSGO_HudDeathNotice
{
public:
  N000004C2 * N000004B1; //0x0000 
private:
  char pad_0x0004 [ 0x3C ]; //0x0004

}; //Size=0x0040

class N000004C2
{
public:
private:
  char pad_0x0000 [ 0x30 ]; //0x0000
public:
  N000004D9 * N000004CF; //0x0030 
private:
  char pad_0x0034 [ 0x14 ]; //0x0034
public:
  N00000510 * N000004D5; //0x0048 
private:
  char pad_0x004C [ 0x88 ]; //0x004C

}; //Size=0x00D4

class N000004D9
{
public:
private:
  char pad_0x0000 [ 0x4 ]; //0x0000

}; //Size=0x00 04



class N00000510
{
public:
private:
  char pad_0x0000 [ 0x4 ]; //0x0000

}; //Size=0x0004

class N00000524
{
public:
private:
  char pad_0x0000 [ 0x4 ]; //0x0000

}; //Size=0x0004


class N0000053A
{
public:
private:
  char pad_0x0000 [ 0x44 ]; //0x0000

}; //Size=0x0044

class N0000054D
{
public:
private:
  char pad_0x0000 [ 0x4 ]; //0x0000

}; //Size=0x0004

class N00000550
{
public:
private:
  char pad_0x0000 [ 0x4 ]; //0x0000

}; //Size=0x0004



class N00000561
{
public:
private:
  char pad_0x0000 [ 0x4 ]; //0x0000

}; //Size=0x0004

class N00000573
{
public:
private:
  char pad_0x0000 [ 0x4 ]; //0x0000

}; //Size=0x0004


class N000005BF
{
public:
private:
  char pad_0x0000 [ 0x4 ]; //0x0000

}; //Size=0x0004
```

`CSGO SDK/SDK/Classes/CClientState.cpp`:

```cpp
#include "CClientState.hpp"
#include "../Displacement.hpp"

int& CClientState::m_nDeltaTick( ) {
   return *( int* ) ( ( uintptr_t ) this + Engine::Displacement.CClientState.m_nDeltaTick );
}

int& CClientState::m_nLastOutgoingCommand( ) {
   return *( int* ) ( ( uintptr_t ) this + Engine::Displacement.CClientState.m_nLastOutgoingCommand );
}

int& CClientState::m_nChokedCommands( ) {
   return *( int* ) ( ( uintptr_t ) this + Engine::Displacement.CClientState.m_nChokedCommands );
}

int& CClientState::m_nLastCommandAck( ) {
   return *( int* ) ( ( uintptr_t ) this + Engine::Displacement.CClientState.m_nLastCommandAck );
}

int& CClientState::m_nMaxClients( ) {
   return *( int* ) ( ( uintptr_t ) this + 0x0310 );
}

bool& CClientState::m_bIsHLTV( ) {
   return *( bool* ) ( ( uintptr_t ) this + Engine::Displacement.CClientState.m_bIsHLTV );
}

CEventInfo* CClientState::m_pEvents( ) {
   return *( CEventInfo** ) ( ( uintptr_t ) this + 0x4DEC );
}


```

`CSGO SDK/SDK/Classes/CClientState.hpp`:

```hpp
#pragma once

class ClientClass;
struct CEventInfo {
public:
	enum {
		EVENT_INDEX_BITS = 8,
		EVENT_DATA_LEN_BITS = 11,
		MAX_EVENT_DATA = 192,  // ( 1<<8 bits == 256, but only using 192 below )
	};

	// 0 implies not in use
	short					m_class_id;
	float					m_fire_delay;
	const void* m_send_table;
	const ClientClass* m_client_class;
	int						m_bits;
	unsigned char* m_data;
	int						m_flags;
	char pad_18[ 0x18 ];
	CEventInfo* m_next;
};


class CClientState
{
public:
	int& m_nDeltaTick( );
	int& m_nLastOutgoingCommand( );
	int& m_nChokedCommands( );
	int& m_nLastCommandAck( );
	int& m_nMaxClients( );
	bool& m_bIsHLTV( );
	CEventInfo* m_pEvents( );
};

```

`CSGO SDK/SDK/Classes/CPlayerResource.cpp`:

```cpp
#include "CPlayerResource.hpp"

int CSPlayerResource::GetPlayerPing(int idx) {
	static auto m_iPing = Engine::PropManager::Instance()->GetOffset(("DT_PlayerResource"), ("m_iPing"));
	return *(int*)((uintptr_t)this + m_iPing + idx * 4);
}

int CSPlayerResource::GetPlayerAssists(int idx) {
	static auto m_iAssists = Engine::PropManager::Instance()->GetOffset(("DT_PlayerResource"), ("m_iAssists"));
	return *(int*)((uintptr_t)this + m_iAssists + idx * 4);
}

int CSPlayerResource::GetPlayerKills(int idx) {
	static auto m_iKills = Engine::PropManager::Instance()->GetOffset(("DT_PlayerResource"), ("m_iKills"));
	return *(int*)((uintptr_t)this + m_iKills + idx * 4);
}

int CSPlayerResource::GetPlayerDeaths(int idx) {
	static auto m_iDeaths = Engine::PropManager::Instance()->GetOffset(("DT_PlayerResource"), ("m_iDeaths"));
	return *(int*)((uintptr_t)this + m_iDeaths + idx * 4);
}
```

`CSGO SDK/SDK/Classes/CPlayerResource.hpp`:

```hpp
#pragma once
#include "../sdk.hpp"
#include "PropManager.hpp"

class CSPlayerResource
{
public:
  int GetPlayerPing(int idx);
  int GetPlayerAssists(int idx);
  int GetPlayerKills(int idx);
  int GetPlayerDeaths( int idx );
};
```

`CSGO SDK/SDK/Classes/CStudioRender.hpp`:

```hpp
#pragma once

#include "../Valve/vector.hpp"
#include "../Valve/Matrix.hpp"

class Quaternion {
public:
   float x, y, z, w;
};

typedef float RadianEuler[3];

#define MAX_QPATH  260

#define BONE_CALCULATE_MASK             0x1F
#define BONE_PHYSICALLY_SIMULATED       0x01    // bone is physically simulated when physics are active
#define BONE_PHYSICS_PROCEDURAL         0x02    // procedural when physics is active
#define BONE_ALWAYS_PROCEDURAL          0x04    // bone is always procedurally animated
#define BONE_SCREEN_ALIGN_SPHERE        0x08    // bone aligns to the screen, not constrained in motion.
#define BONE_SCREEN_ALIGN_CYLINDER      0x10    // bone aligns to the screen, constrained by it's own axis.

#define BONE_USED_MASK                  0x0007FF00
#define BONE_USED_BY_ANYTHING           0x0007FF00
#define BONE_USED_BY_HITBOX             0x00000100    // bone (or child) is used by a hit box
#define BONE_USED_BY_ATTACHMENT         0x00000200    // bone (or child) is used by an attachment point
#define BONE_USED_BY_VERTEX_MASK        0x0003FC00
#define BONE_USED_BY_VERTEX_LOD0        0x00000400    // bone (or child) is used by the toplevel model via skinned vertex
#define BONE_USED_BY_VERTEX_LOD1        0x00000800    
#define BONE_USED_BY_VERTEX_LOD2        0x00001000  
#define BONE_USED_BY_VERTEX_LOD3        0x00002000
#define BONE_USED_BY_VERTEX_LOD4        0x00004000
#define BONE_USED_BY_VERTEX_LOD5        0x00008000
#define BONE_USED_BY_VERTEX_LOD6        0x00010000
#define BONE_USED_BY_VERTEX_LOD7        0x00020000
#define BONE_USED_BY_BONE_MERGE         0x00040000    // bone is available for bone merge to occur against it

#define BONE_USED_BY_VERTEX_AT_LOD(lod) ( BONE_USED_BY_VERTEX_LOD0 << (lod) )
#define BONE_USED_BY_ANYTHING_AT_LOD(lod) ( ( BONE_USED_BY_ANYTHING & ~BONE_USED_BY_VERTEX_MASK ) | BONE_USED_BY_VERTEX_AT_LOD(lod) )

#define MAX_NUM_LODS 8
#define MAXSTUDIOBONES		128		// total bones actually used

#define BONE_TYPE_MASK                  0x00F00000
#define BONE_FIXED_ALIGNMENT            0x00100000    // bone can't spin 360 degrees, all interpolation is normalized around a fixed orientation

#define BONE_HAS_SAVEFRAME_POS          0x00200000    // Vector48
#define BONE_HAS_SAVEFRAME_ROT64        0x00400000    // Quaternion64
#define BONE_HAS_SAVEFRAME_ROT32        0x00800000    // Quaternion32

#define BONE_USED_BY_SERVER BONE_USED_BY_HITBOX | BONE_USED_BY_VERTEX_LOD0 | BONE_USED_BY_VERTEX_LOD1 | BONE_USED_BY_VERTEX_LOD2 | BONE_USED_BY_VERTEX_LOD3 | BONE_USED_BY_VERTEX_LOD4 | BONE_USED_BY_VERTEX_LOD5 | BONE_USED_BY_VERTEX_LOD6 | BONE_USED_BY_VERTEX_LOD7

#define Assert( _exp ) ((void)0)

// https://github.com/SteamDatabase/GameTracking-CSGO/blob/master/Protobufs/fatdemo.proto#L3
enum EHitGroup {
  Hitgroup_Generic = 0,
  Hitgroup_Head = 1,
  Hitgroup_Chest = 2,
  Hitgroup_Stomach = 3,
  Hitgroup_LeftArm = 4,
  Hitgroup_RightArm = 5,
  Hitgroup_LeftLeg = 6,
  Hitgroup_RightLeg = 7,
  Hitgroup_Neck = 8,
  Hitgroup_Miss = 9,
  Hitgroup_Gear = 10,
};

enum modtype_t
{
  mod_bad = 0,
  mod_brush,
  mod_sprite,
  mod_studio
};

enum Hitboxes
{
  HITBOX_HEAD, // 0
  HITBOX_NECK, // 1
  HITBOX_LOWER_NECK,// 2
  HITBOX_PELVIS,// 3
  HITBOX_STOMACH,// 4
  HITBOX_LOWER_CHEST,// 5
  HITBOX_CHEST,// 6
  HITBOX_UPPER_CHEST,// 7
  HITBOX_RIGHT_THIGH,// 8
  HITBOX_LEFT_THIGH,// 9
  HITBOX_RIGHT_CALF,// 10
  HITBOX_LEFT_CALF,// 11
  HITBOX_RIGHT_FOOT,// 12
  HITBOX_LEFT_FOOT,// 13
  HITBOX_RIGHT_HAND,// 14
  HITBOX_LEFT_HAND,// 15
  HITBOX_RIGHT_UPPER_ARM,// 16
  HITBOX_RIGHT_FOREARM,// 17
  HITBOX_LEFT_UPPER_ARM,// 18
  HITBOX_LEFT_FOREARM,// 19
  HITBOX_MAX
};

typedef unsigned short MDLHandle_t;

struct mstudiobone_t
{
  int sznameindex;
  inline char *const pszName( void ) const { return ( ( char * )this ) + sznameindex; }
  int parent;
  int bonecontroller[6];

  Vector pos;
  Quaternion quat;
  RadianEuler rot;

  Vector posscale;
  Vector rotscale;

  matrix3x4_t poseToBone;
  Quaternion qAlignment;
  int flags;
  int proctype;
  int procindex;
  mutable int physicsbone;
  inline void *pProcedure( ) const { if( procindex == 0 ) return NULL; else return  ( void * )( ( ( unsigned char * )this ) + procindex ); };
  int surfacepropidx;
  inline char *const pszSurfaceProp( void ) const { return ( ( char * )this ) + surfacepropidx; }
  inline int GetSurfaceProp( void ) const { return surfacepropLookup; }

  int contents;
  int surfacepropLookup;
  int unused[7];
};


struct mstudiobbox_t
{
  int         bone;
  int         group;
  Vector      bbmin;
  Vector      bbmax;
  int         szhitboxnameindex;
  QAngle      m_angAngles;
  float       m_flRadius;
  int32_t     m_iPad02[4];

  char *getHitboxName( ) {
	 if( szhitboxnameindex == 0 )
		return "";

	 return ( ( char* )this ) + szhitboxnameindex;
  }
};

struct mstudiohitboxset_t
{
  int    sznameindex;
  int    numhitboxes;
  int    hitboxindex;

  inline char *const pszName( void ) const {
	 return ( ( char* )this ) + sznameindex;
  }

  inline mstudiobbox_t *pHitbox( int i ) const {
	 if( i > numhitboxes ) return nullptr;
	 return ( mstudiobbox_t* )( ( uint8_t* )this + hitboxindex ) + i;
  }
};

struct model_t
{
   void*				fnHandle;               //0x0000 
   char				szName[ 260 ];          //0x0004 
   __int32			nLoadFlags;             //0x0108 
   __int32			nServerCount;           //0x010C 
   __int32			type;                   //0x0110 
   __int32			flags;                  //0x0114 
   Vector			vecMins;                //0x0118 
   Vector			vecMaxs;                //0x0124 
   float				radius;                 //0x0130 
   __int32		 __pad00134;					//0x0134
   MDLHandle_t		studio;						//0x0138
   char				pad[ 0x16 ];            //0x13A
};//Size=0x0150


class studiohdr_t
{
public:

	__int32 id;                     //0x0000 
	__int32 version;                //0x0004 
	long    checksum;               //0x0008 
	char    szName[ 64 ];             //0x000C 
	__int32 length;                 //0x004C 
	Vector  vecEyePos;              //0x0050 
	Vector  vecIllumPos;            //0x005C 
	Vector  vecHullMin;             //0x0068 
	Vector  vecHullMax;             //0x0074 
	Vector  vecBBMin;               //0x0080 
	Vector  vecBBMax;               //0x008C 
	__int32 flags;                  //0x0098 
	__int32 numbones;               //0x009C 
	__int32 boneindex;              //0x00A0 
	__int32 numbonecontrollers;     //0x00A4 
	__int32 bonecontrollerindex;    //0x00A8 
	__int32 numhitboxsets;          //0x00AC 
	__int32 hitboxsetindex;         //0x00B0 
	int					numlocalanim;			// animations/poses
	int					localanimindex;		// animation descriptions
	int					numlocalseq;				// sequences
	int					localseqindex;

	//private:
	mutable int			activitylistversion;	// initialization flag - have the sequences been indexed?
	mutable int			eventsindexed;

	int					GetSequenceActivity( int iSequence );
	void				SetSequenceActivity( int iSequence, int iActivity );
	int					GetActivityListVersion( void );
	void				SetActivityListVersion( int version ) const;
	int					GetEventListVersion( void );
	void				SetEventListVersion( int version );

	// raw textures
	int					numtextures;
	int					textureindex;


	// raw textures search paths
	int					numcdtextures;
	int					cdtextureindex;

	// replaceable textures tables
	int					numskinref;
	int					numskinfamilies;
	int					skinindex;

	int					numbodyparts;
	int					bodypartindex;

	// queryable attachable points
  //private:
	int					numlocalattachments;
	int					localattachmentindex;
	//public:
	int					GetNumAttachments( void ) const;
	int					GetAttachmentBone( int i );
	// used on my tools in hlmv, not persistant
	void				SetAttachmentBone( int iAttachment, int iBone );

	// animation node to animation node transition graph
  //private:
	int					numlocalnodes;
	int					localnodeindex;
	int					localnodenameindex;

	//public:
	int					EntryNode( int iSequence );
	int					ExitNode( int iSequence );
	char* pszNodeName( int iNode );
	int					GetTransition( int iFrom, int iTo ) const;

	int					numflexdesc;
	int					flexdescindex;

	int					numflexcontrollers;
	int					flexcontrollerindex;

	int					numflexrules;
	int					flexruleindex;

	int					numikchains;
	int					ikchainindex;

	inline const char* pszName( void ) const { return szName; }

	mstudiohitboxset_t* pHitboxSet( int i ) {
		if( i > numhitboxsets ) return nullptr;
		return ( mstudiohitboxset_t* )( ( uint8_t* )this + hitboxsetindex ) + i;
	}
	mstudiobone_t* pBone( int i ) {
		if( i > numbones ) return nullptr;
		return ( mstudiobone_t* )( ( uint8_t* )this + boneindex ) + i;
	}

};//Size=0x00D4
```

`CSGO SDK/SDK/Classes/CUserCmd.cpp`:

```cpp
#include "../sdk.hpp"

CRC32_t CUserCmd::GetChecksum( void ) {
  CRC32_t crc;
  CRC32_Init( &crc );

  CRC32_ProcessBuffer( &crc, &command_number, sizeof( command_number ) );
  CRC32_ProcessBuffer( &crc, &tick_count, sizeof( tick_count ) );
  CRC32_ProcessBuffer( &crc, &viewangles, sizeof( viewangles ) );
  CRC32_ProcessBuffer( &crc, &aimdirection, sizeof( aimdirection ) );
  CRC32_ProcessBuffer( &crc, &forwardmove, sizeof( forwardmove ) );
  CRC32_ProcessBuffer( &crc, &sidemove, sizeof( sidemove ) );
  CRC32_ProcessBuffer( &crc, &upmove, sizeof( upmove ) );
  CRC32_ProcessBuffer( &crc, &buttons, sizeof( buttons ) );
  CRC32_ProcessBuffer( &crc, &impulse, sizeof( impulse ) );
  CRC32_ProcessBuffer( &crc, &weaponselect, sizeof( weaponselect ) );
  CRC32_ProcessBuffer( &crc, &weaponsubtype, sizeof( weaponsubtype ) );
  CRC32_ProcessBuffer( &crc, &random_seed, sizeof( random_seed ) );
  CRC32_ProcessBuffer( &crc, &mousedx, sizeof( mousedx ) );
  CRC32_ProcessBuffer( &crc, &mousedy, sizeof( mousedy ) );

  CRC32_Final( &crc );
  return crc;
}

```

`CSGO SDK/SDK/Classes/CUserCmd.hpp`:

```hpp
#pragma once

class CUserCmd
{
public:
  CRC32_t GetChecksum( void );

  char pad_0x0000[0x4]; //0x0000	
  int     command_number;     // 0x04 For matching server and client commands for debugging
  int     tick_count;         // 0x08 the tick the client created this command
  QAngle  viewangles;         // 0x0C Player instantaneous view angles.
  Vector  aimdirection;       // 0x18
  float   forwardmove;        // 0x24
  float   sidemove;           // 0x28
  float   upmove;             // 0x2C
  int     buttons;            // 0x30 Attack button states
  char    impulse;            // 0x34
  int     weaponselect;       // 0x38 Current weapon id
  int     weaponsubtype;      // 0x3C
  int     random_seed;        // 0x40 For shared random functions
  short   mousedx;            // 0x44 mouse accum in x from create move
  short   mousedy;            // 0x46 mouse accum in y from create move
  bool    hasbeenpredicted;   // 0x48 Client only, tracks whether we've predicted this command at least once
  char    pad_0x4C[0x18];     // 0x4C Current sizeof( usercmd ) =  100  = 0x64
};

```

`CSGO SDK/SDK/Classes/DataMap.hpp`:

```hpp
#pragma once
struct inputdata_t;
typedef enum _fieldtypes
{
  FIELD_VOID = 0,			// No type or value
  FIELD_FLOAT,			// Any floating point value
  FIELD_STRING,			// A string ID (return from ALLOC_STRING)
  FIELD_VECTOR,			// Any vector, QAngle, or AngularImpulse
  FIELD_QUATERNION,		// A quaternion
  FIELD_INTEGER,			// Any integer or enum
  FIELD_BOOLEAN,			// boolean, implemented as an int, I may use this as a hint for compression
  FIELD_SHORT,			// 2 byte integer
  FIELD_CHARACTER,		// a byte
  FIELD_COLOR32,			// 8-bit per channel r,g,b,a (32bit color)
  FIELD_EMBEDDED,			// an embedded object with a datadesc, recursively traverse and embedded class/structure based on an additional typedescription
  FIELD_CUSTOM,			// special type that contains function pointers to it's read/write/parse functions

  FIELD_CLASSPTR,			// CBaseEntity *
  FIELD_EHANDLE,			// Entity handle
  FIELD_EDICT,			// edict_t *

  FIELD_POSITION_VECTOR,	// A world coordinate (these are fixed up across level transitions automagically)
  FIELD_TIME,				// a floating point time (these are fixed up automatically too!)
  FIELD_TICK,				// an integer tick count( fixed up similarly to time)
  FIELD_MODELNAME,		// Engine string that is a model name (needs precache)
  FIELD_SOUNDNAME,		// Engine string that is a sound name (needs precache)

  FIELD_INPUT,			// a list of inputed data fields (all derived from CMultiInputVar)
  FIELD_FUNCTION,			// A class function pointer (Think, Use, etc)

  FIELD_VMATRIX,			// a vmatrix (output coords are NOT worldspace)

								// NOTE: Use float arrays for local transformations that don't need to be fixed up.
								FIELD_VMATRIX_WORLDSPACE,// A VMatrix that maps some local space to world space (translation is fixed up on level transitions)
								FIELD_MATRIX3X4_WORLDSPACE,	// matrix3x4_t that maps some local space to world space (translation is fixed up on level transitions)

								FIELD_INTERVAL,			// a start and range floating point interval ( e.g., 3.2->3.6 == 3.2 and 0.4 )
								FIELD_MODELINDEX,		// a model index
								FIELD_MATERIALINDEX,	// a material index (using the material precache string table)

								FIELD_VECTOR2D,			// 2 floats

								FIELD_TYPECOUNT,		// MUST BE LAST
} fieldtype_t;

class ISaveRestoreOps;
class C_BaseEntity;
//
// Function prototype for all input handlers.
//
typedef void ( C_BaseEntity::*inputfunc_t )( inputdata_t &data );

struct datamap_t;
class typedescription_t;

enum
{
  TD_OFFSET_NORMAL = 0,
  TD_OFFSET_PACKED = 1,

  // Must be last
  TD_OFFSET_COUNT,
};

class typedescription_t
{
public:
  int fieldType; //0x0000
  char* fieldName; //0x0004
  int fieldOffset[TD_OFFSET_COUNT]; //0x0008
  short fieldSize_UNKNWN; //0x0010
  short flags_UNKWN; //0x0012
  char pad_0014[12]; //0x0014
  datamap_t* td; //0x0020
  char pad_0024[24]; //0x0024
}; //Size: 0x003C


	//-----------------------------------------------------------------------------
	// Purpose: stores the list of objects in the hierarchy
	//            used to iterate through an object's data descriptions
	//-----------------------------------------------------------------------------
struct datamap_t
{
  typedescription_t    *dataDesc;
  int                    dataNumFields;
  char const            *dataClassName;
  datamap_t            *baseMap;

  bool                chains_validated;
  // Have the "packed" offsets been computed
  bool                packed_offsets_computed;
  int                    packed_size;
};

```

`CSGO SDK/SDK/Classes/Exploits.hpp`:

```hpp
#pragma once

class bf_read {
public:
  const char* m_pDebugName;
  bool m_bOverflow;
  int m_nDataBits;
  unsigned int m_nDataBytes;
  unsigned int m_nInBufWord;
  int m_nBitsAvail;
  const unsigned int* m_pDataIn;
  const unsigned int* m_pBufferEnd;
  const unsigned int* m_pData;

  bf_read( ) = default;

  bf_read( const void* pData, int nBytes, int nBits = -1 ) {
	 StartReading( pData, nBytes, 0, nBits );
  }

  void StartReading( const void* pData, int nBytes, int iStartBit, int nBits ) {
	 // Make sure it's dword aligned and padded.
	 m_pData = ( uint32_t* )pData;
	 m_pDataIn = m_pData;
	 m_nDataBytes = nBytes;

	 if( nBits == -1 ) {
		m_nDataBits = nBytes << 3;
	 } else {
		m_nDataBits = nBits;
	 }
	 m_bOverflow = false;
	 m_pBufferEnd = reinterpret_cast< uint32_t const* >( reinterpret_cast< uint8_t const* >( m_pData ) + nBytes );
	 if( m_pData )
		Seek( iStartBit );
  }

  bool Seek( int nPosition ) {
	 bool bSucc = true;
	 if( nPosition < 0 || nPosition > m_nDataBits ) {
		m_bOverflow = true;
		bSucc = false;
		nPosition = m_nDataBits;
	 }
	 int nHead = m_nDataBytes & 3; // non-multiple-of-4 bytes at head of buffer. We put the "round off"
											 // at the head to make reading and detecting the end efficient.

	 int nByteOfs = nPosition / 8;
	 if( ( m_nDataBytes < 4 ) || ( nHead && ( nByteOfs < nHead ) ) ) {
		// partial first dword
		uint8_t const* pPartial = ( uint8_t const* )m_pData;
		if( m_pData ) {
		  m_nInBufWord = *( pPartial++ );
		  if( nHead > 1 )
			 m_nInBufWord |= ( *pPartial++ ) << 8;
		  if( nHead > 2 )
			 m_nInBufWord |= ( *pPartial++ ) << 16;
		}
		m_pDataIn = ( uint32_t const* )pPartial;
		m_nInBufWord >>= ( nPosition & 31 );
		m_nBitsAvail = ( nHead << 3 ) - ( nPosition & 31 );
	 } else {
		int nAdjPosition = nPosition - ( nHead << 3 );
		m_pDataIn = reinterpret_cast< uint32_t const* >(
		  reinterpret_cast< uint8_t const* >( m_pData ) + ( ( nAdjPosition / 32 ) << 2 ) + nHead );
		if( m_pData ) {
		  m_nBitsAvail = 32;
		  GrabNextDWord( );
		} else {
		  m_nInBufWord = 0;
		  m_nBitsAvail = 1;
		}
		m_nInBufWord >>= ( nAdjPosition & 31 );
		m_nBitsAvail = std::min( m_nBitsAvail, 32 - ( nAdjPosition & 31 ) ); // in case grabnextdword overflowed
	 }
	 return bSucc;
  }

  FORCEINLINE void GrabNextDWord( bool bOverFlowImmediately = false ) {
	 if( m_pDataIn == m_pBufferEnd ) {
		m_nBitsAvail = 1; // so that next read will run out of words
		m_nInBufWord = 0;
		m_pDataIn++; // so seek count increments like old
		if( bOverFlowImmediately )
		  m_bOverflow = true;
	 } else if( m_pDataIn > m_pBufferEnd ) {
		m_bOverflow = true;
		m_nInBufWord = 0;
	 } else {
		m_nInBufWord = LittleDWord( *( m_pDataIn++ ) );
	 }
  }
};

class bf_write {
public:
  unsigned char* m_pData;
  int m_nDataBytes;
  int m_nDataBits;
  int m_iCurBit;
  bool m_bOverflow;
  bool m_bAssertOnOverflow;
  const char* m_pDebugName;

  void StartWriting( void* pData, int nBytes, int iStartBit = 0, int nBits = -1 ) {
	 // Make sure it's dword aligned and padded.
	 // The writing code will overrun the end of the buffer if it isn't dword aligned, so truncate to force alignment
	 nBytes &= ~3;

	 m_pData = ( unsigned char* )pData;
	 m_nDataBytes = nBytes;

	 if( nBits == -1 ) {
		m_nDataBits = nBytes << 3;
	 } else {
		m_nDataBits = nBits;
	 }

	 m_iCurBit = iStartBit;
	 m_bOverflow = false;
  }

  bf_write( ) {
	 m_pData = NULL;
	 m_nDataBytes = 0;
	 m_nDataBits = -1; // set to -1 so we generate overflow on any operation
	 m_iCurBit = 0;
	 m_bOverflow = false;
	 m_bAssertOnOverflow = true;
	 m_pDebugName = NULL;
  }

  // nMaxBits can be used as the number of bits in the buffer.
  // It must be <= nBytes*8. If you leave it at -1, then it's set to nBytes * 8.
  bf_write( void* pData, int nBytes, int nBits = -1 ) {
	 m_bAssertOnOverflow = true;
	 m_pDebugName = NULL;
	 StartWriting( pData, nBytes, 0, nBits );
  }

  bf_write( const char* pDebugName, void* pData, int nBytes, int nBits = -1 ) {
	 m_bAssertOnOverflow = true;
	 m_pDebugName = pDebugName;
	 StartWriting( pData, nBytes, 0, nBits );
  }
};

class CLC_Move {
private:
  char __PAD0[0x8]; // 0x0 two vtables
public:
  int m_nBackupCommands; // 0x8
  int m_nNewCommands;    // 0xC
  void* m_data;   // 0x10 std::string
  int _cached_size_;
  uint32_t _has_bits_[( 3 + 31 ) / 32];
};                       // size: 0x50

template < typename T >
class CNetMessagePB : public INetMessage, public T {};
using CCLCMsg_Move_t = CNetMessagePB< CLC_Move >;

```

`CSGO SDK/SDK/Classes/GlowOutlineEffect.hpp`:

```hpp
#pragma once
#include "../Valve/UtlVector.hpp"

class GlowObjectDefinition_t {
public:
  GlowObjectDefinition_t( ) { memset( this, 0, sizeof( *this ) ); }

  class IClientEntity* m_pEntity; //0x0000
  Vector4D m_vGlowColor;			 //0x0004
  uint8_t pad_0014[4];            //0x0014
  float m_flSomeFloat;            //0x0018
  uint8_t pad_001C[4];            //0x001C
  float m_flAnotherFloat;         //0x0020
  bool m_bRenderWhenOccluded;     //0x0024
  bool m_bRenderWhenUnoccluded;   //0x0025
  bool m_bFullBloomRender;        //0x0026
  uint8_t pad_0027[5];            //0x0027
  int32_t m_nGlowStyle;           //0x002C
  int32_t m_nSplitScreenSlot;     //0x0030
  int32_t m_nNextFreeSlot;        //0x0034

  bool IsUnused( ) const { return m_nNextFreeSlot != GlowObjectDefinition_t::ENTRY_IN_USE; }

  static const int END_OF_FREE_LIST = -1;
  static const int ENTRY_IN_USE = -2;
}; //Size: 0x0038 (56)

class CGlowObjectManager {
public:
  int RegisterGlowObject( IClientEntity* pEntity, const Vector4D& vGlowColor, bool bRenderWhenOccluded, bool bRenderWhenUnoccluded, int nSplitScreenSlot ) {
	 int nIndex;
	 if( m_nFirstFreeSlot == GlowObjectDefinition_t::END_OF_FREE_LIST ) {
		return -1;
	 } else {
		nIndex = m_nFirstFreeSlot;
		m_nFirstFreeSlot = m_GlowObjectDefinitions.m_Memory.m_pMemory[nIndex].m_nNextFreeSlot;
	 }

	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nIndex].m_pEntity = pEntity;
	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nIndex].m_vGlowColor = vGlowColor;
	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nIndex].m_bRenderWhenOccluded = bRenderWhenOccluded;
	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nIndex].m_bRenderWhenUnoccluded = bRenderWhenUnoccluded;
	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nIndex].m_nSplitScreenSlot = nSplitScreenSlot;
	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nIndex].m_nNextFreeSlot = GlowObjectDefinition_t::ENTRY_IN_USE;

	 return nIndex;
  }

  void UnregisterGlowObject( int nGlowObjectHandle ) {
	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nGlowObjectHandle].m_nNextFreeSlot = m_nFirstFreeSlot;
	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nGlowObjectHandle].m_pEntity = nullptr;
	 m_nFirstFreeSlot = nGlowObjectHandle;
  }

  void SetEntity( int nGlowObjectHandle, IClientEntity* pEntity ) {
	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nGlowObjectHandle].m_pEntity = pEntity;
  }

  void SetColor( int nGlowObjectHandle, const Vector4D& vGlowColor ) {
	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nGlowObjectHandle].m_vGlowColor = vGlowColor;
  }

  void SetAlpha( int nGlowObjectHandle, float flAlpha ) {
	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nGlowObjectHandle].m_vGlowColor.w = flAlpha;
  }

  void SetRenderFlags( int nGlowObjectHandle, bool bRenderWhenOccluded, bool bRenderWhenUnoccluded ) {
	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nGlowObjectHandle].m_bRenderWhenOccluded = bRenderWhenOccluded;
	 m_GlowObjectDefinitions.m_Memory.m_pMemory[nGlowObjectHandle].m_bRenderWhenUnoccluded = bRenderWhenUnoccluded;
  }

  bool IsRenderingWhenOccluded( int nGlowObjectHandle ) const {
	 return m_GlowObjectDefinitions.m_Memory.m_pMemory[nGlowObjectHandle].m_bRenderWhenOccluded;
  }

  bool IsRenderingWhenUnoccluded( int nGlowObjectHandle ) const {
	 return m_GlowObjectDefinitions.m_Memory.m_pMemory[nGlowObjectHandle].m_bRenderWhenUnoccluded;
  }

  bool HasGlowEffect( IClientEntity* pEntity ) const {
	 for( int i = 0; i < m_GlowObjectDefinitions.m_Size; ++i ) {
		if( !m_GlowObjectDefinitions.m_Memory.m_pMemory[i].IsUnused( ) && m_GlowObjectDefinitions.m_Memory.m_pMemory[i].m_pEntity == pEntity ) {
		  return true;
		}
	 }

	 return false;
  }

  CUtlVector< GlowObjectDefinition_t > m_GlowObjectDefinitions; //0x0000
  int m_nFirstFreeSlot;                                         //0x000C
};


```

`CSGO SDK/SDK/Classes/IAppSystem.hpp`:

```hpp
#pragma once
#include "sdk.hpp"

typedef void* (*CreateInterfaceFn)(const char *pName, int *pReturnCode);
typedef void* (*InstantiateInterfaceFn)();

class IAppSystem
{
public:
	virtual bool                            Connect(CreateInterfaceFn factory) = 0;                                     // 0
	virtual void                            Disconnect() = 0;                                                           // 1
	virtual void*                           QueryInterface(const char *pInterfaceName) = 0;                             // 2
	virtual int /*InitReturnVal_t*/         Init() = 0;                                                                 // 3
	virtual void                            Shutdown() = 0;                                                             // 4
	virtual const void* /*AppSystemInfo_t*/ GetDependencies() = 0;                                                      // 5
	virtual int /*AppSystemTier_t*/         GetTier() = 0;                                                              // 6
	virtual void                            Reconnect(CreateInterfaceFn factory, const char *pInterfaceName) = 0;       // 7
	virtual void                            UnkFunc() = 0;                                                              // 8
};
```

`CSGO SDK/SDK/Classes/IBaseClientDll.cpp`:

```cpp
#include "../sdk.hpp"

ClientClass* IBaseClientDLL::GetAllClasses()
{
	using Fn = ClientClass * (__thiscall*)(void*);
	return Memory::VCall<Fn>(this, Index::IBaseClientDLL::GetAllClasses)(this);
}

bool IBaseClientDLL::IsChatRaised( ) {
   using Fn = bool( __thiscall* )( void* );
   return Memory::VCall<Fn>( this, 90 )( this );
}

```

`CSGO SDK/SDK/Classes/IBaseClientDll.hpp`:

```hpp
#pragma once
class IBaseClientDLL {
public:
	ClientClass* GetAllClasses();
	bool IsChatRaised( );
};
```

`CSGO SDK/SDK/Classes/ICenterPrint.hpp`:

```hpp
#pragma once

class ICenterPrint {
public:
  virtual void* Create( unsigned long long unknown ) = 0;
  virtual int   Destroy( ) = 0;
  virtual int	 SetTextColor( int, int, int, int ) = 0;
  virtual void  Print( char16_t* ) = 0;
  virtual int	 PrintW( wchar_t* ) = 0;
  virtual void  ColorPrint( int, int, int, int, char16_t * ) = 0;
  virtual int	 ColorPrintW( int, int, int, int, wchar_t* ) = 0;
  virtual int	 Clear( ) = 0;
};
```

`CSGO SDK/SDK/Classes/IClientEntity.hpp`:

```hpp
#pragma once
#include "sdk.hpp"

class IBaseClientDLL
{
public:
	ClientClass* GetAllClasses();
};

```

`CSGO SDK/SDK/Classes/IClientEntityList.cpp`:

```cpp
#include "../sdk.hpp"
#include "../Valve/CBaseHandle.hpp"

int IClientEntityList::GetHighestEntityIndex()
{
	using Fn = int(__thiscall*)(void*);
	return Memory::VCall<Fn>(this, Index::IClientEntityList::GetHighestEntityIndex)(this);
}

IClientEntity* IClientEntityList::GetClientEntity(int entnum)
{
	using Fn = IClientEntity * (__thiscall*)(void*, int);
	return Memory::VCall<Fn>(this, Index::IClientEntityList::GetClientEntity)(this, entnum); 
}

IClientEntity* IClientEntityList::GetClientEntityFromHandle(CBaseHandle hEnt)
{
	using Fn = IClientEntity * (__thiscall*)(void*, CBaseHandle);
	return Memory::VCall<Fn>(this, Index::IClientEntityList::GetClientEntityFromHandle)(this, hEnt);
}

```

`CSGO SDK/SDK/Classes/IClientEntityList.hpp`:

```hpp
#pragma once

class IClientEntityList
{
public:
	IClientEntity* GetClientEntity(int entnum);
	IClientEntity* GetClientEntityFromHandle(CBaseHandle hEnt);
	int GetHighestEntityIndex();
};

```

`CSGO SDK/SDK/Classes/IClientLeafSystem.hpp`:

```hpp
#pragma once
#include "sdk.hpp"

class ClientRenderHandle_t;
class CClientLeafSubSystemData;
using RenderableModelType_t = int;
class SetupRenderInfo_t;
class ClientLeafShadowHandle_t;
class ClientShadowHandle_t;

class IClientLeafSystem {
public:
  
};

typedef int TABLEID;

class INetworkStringTable;

typedef void( *pfnStringChanged )( void* object, INetworkStringTable* stringTable, int stringNumber, char const* newString, void const* newData );

class INetworkStringTable
{
public:

    virtual					~INetworkStringTable( void ) {};

    // Table Info
    virtual const char* GetTableName( void ) const = 0;
    virtual TABLEID			GetTableId( void ) const = 0;
    virtual int				GetNumStrings( void ) const = 0;
    virtual int				GetMaxStrings( void ) const = 0;
    virtual int				GetEntryBits( void ) const = 0;

    // Networking
    virtual void			SetTick( int tick ) = 0;
    virtual bool			ChangedSinceTick( int tick ) const = 0;

    // Accessors (length -1 means don't change user data if string already exits)
    virtual int				AddString( bool bIsServer, const char* value, int length = -1, const void* userdata = 0 ) = 0;

    virtual const char* GetString( int stringNumber ) = 0;
    virtual void			SetStringUserData( int stringNumber, int length, const void* userdata ) = 0;
    virtual const void* GetStringUserData( int stringNumber, int* length ) = 0;
    virtual int				FindStringIndex( char const* string ) = 0; // returns INVALID_STRING_INDEX if not found

                                                                     // Callbacks
    virtual void			SetStringChangedCallback( void* object, pfnStringChanged changeFunc ) = 0;
};

class CNetworkStringTableContainer
{
public:
    INetworkStringTable* FindTable( const char* tableName )
    {
        typedef INetworkStringTable* ( __thiscall* oFindTable )( PVOID, const char* );
        return Memory::VCall< oFindTable >( this, 3 )( this, tableName );
    }
};
```

`CSGO SDK/SDK/Classes/IConVar.cpp`:

```cpp
#include "../sdk.hpp"

inline int CCommand::MaxCommandLength()
{
	return COMMAND_MAX_LENGTH - 1;
}

inline int CCommand::ArgC() const
{
	return m_nArgc;
}

inline const char **CCommand::ArgV() const
{
	return m_nArgc ? (const char**)m_ppArgv : NULL;
}

inline const char *CCommand::ArgS() const
{
	return m_nArgv0Size ? &m_pArgSBuffer[m_nArgv0Size] : "";
}

inline const char *CCommand::GetCommandString() const
{
	return m_nArgc ? m_pArgSBuffer : "";
}

inline const char *CCommand::Arg(int nIndex) const
{
	// FIXME: Many command handlers appear to not be particularly careful
	// about checking for valid argc range. For now, we're going to
	// do the extra check and return an empty string if it's out of range
	if (nIndex < 0 || nIndex >= m_nArgc)
		return "";
	return m_ppArgv[nIndex];
}

inline const char *CCommand::operator[](int nIndex) const
{
	return Arg(nIndex);
}

```

`CSGO SDK/SDK/Classes/IConVar.hpp`:

```hpp
#pragma once
// The default, no flags at all
#define FCVAR_NONE				0 

	// Command to ConVars and ConCommands
	// ConVar Systems
#define FCVAR_UNREGISTERED		(1<<0)	// If this is set, don't add to linked list, etc.
#define FCVAR_DEVELOPMENTONLY	(1<<1)	// Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined.
#define FCVAR_GAMEDLL			(1<<2)	// defined by the game DLL
#define FCVAR_CLIENTDLL			(1<<3)  // defined by the client DLL
#define FCVAR_HIDDEN			(1<<4)	// Hidden. Doesn't appear in find or autocomplete. Like DEVELOPMENTONLY, but can't be compiled out.

	// ConVar only
#define FCVAR_PROTECTED			(1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
#define FCVAR_SPONLY			(1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define	FCVAR_ARCHIVE			(1<<7)	// set to cause it to be saved to vars.rc
#define	FCVAR_NOTIFY			(1<<8)	// notifies players when changed
#define	FCVAR_USERINFO			(1<<9)	// changes the client's info string
#define FCVAR_CHEAT				(1<<14) // Only useable in singleplayer / debug / multiplayer & sv_cheats

#define FCVAR_PRINTABLEONLY		(1<<10)  // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).
#define FCVAR_UNLOGGED			(1<<11)  // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log
#define FCVAR_NEVER_AS_STRING	(1<<12)  // never try to print that cvar

	// It's a ConVar that's shared between the client and the server.
	// At signon, the values of all such ConVars are sent from the server to the client (skipped for local
	//  client, of course )
	// If a change is requested it must come from the console (i.e., no remote client changes)
	// If a value is changed while a server is active, it's replicated to all connected clients
#define FCVAR_REPLICATED		(1<<13)	// server setting enforced on clients, TODO rename to FCAR_SERVER at some time
#define FCVAR_DEMO				(1<<16)  // record this cvar when starting a demo file
#define FCVAR_DONTRECORD		(1<<17)  // don't record these command in demofiles
#define FCVAR_RELOAD_MATERIALS	(1<<20)	// If this cvar changes, it forces a material reload
#define FCVAR_RELOAD_TEXTURES	(1<<21)	// If this cvar changes, if forces a texture reload

#define FCVAR_NOT_CONNECTED		(1<<22)	// cvar cannot be changed by a client that is connected to a server
#define FCVAR_MATERIAL_SYSTEM_THREAD (1<<23)	// Indicates this cvar is read from the material system thread
#define FCVAR_ARCHIVE_XBOX		(1<<24) // cvar written to config.cfg on the Xbox

#define FCVAR_ACCESSIBLE_FROM_THREADS	(1<<25)	// used as a debugging tool necessary to check material system thread convars

#define FCVAR_SERVER_CAN_EXECUTE	(1<<28)// the server is allowed to execute this command on clients via ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd.
#define FCVAR_SERVER_CANNOT_QUERY	(1<<29)// If this is set, then the server is not allowed to query this cvar's value (via IServerPluginHelpers::StartQueryCvarValue).
#define FCVAR_CLIENTCMD_CAN_EXECUTE	(1<<30)	// IVEngineClient::ClientCmd is allowed to execute this command. 

#include "../Valve/characterset.hpp"
#include "../Valve/UtlVector.hpp"

class CCommand
{
public:
	CCommand();
	CCommand(int nArgC, const char **ppArgV);
	bool Tokenize(const char *pCommand, characterset_t *pBreakSet = NULL);
	void Reset();

	int ArgC() const;
	const char **ArgV() const;
	const char *ArgS() const;					// All args that occur after the 0th arg, in string form
	const char *GetCommandString() const;		// The entire command in string form, including the 0th arg
	const char *operator[](int nIndex) const;	// Gets at arguments
	const char *Arg(int nIndex) const;		// Gets at arguments

	// Helper functions to parse arguments to commands.
	const char* FindArg(const char *pName) const;
	int FindArgInt(const char *pName, int nDefaultVal) const;

	static int MaxCommandLength();
	static characterset_t* DefaultBreakSet();

private:
	enum
	{
		COMMAND_MAX_ARGC = 64,
		COMMAND_MAX_LENGTH = 512,
	};

	int		m_nArgc;
	int		m_nArgv0Size;
	char	m_pArgSBuffer[COMMAND_MAX_LENGTH];
	char	m_pArgvBuffer[COMMAND_MAX_LENGTH];
	const char*	m_ppArgv[COMMAND_MAX_ARGC];
};

class ConVar
{
public:
	char pad_0x0000[0x4];
	ConVar * pNext;
	int32_t bRegistered;
	char* pszName;
	char* pszHelpString;
	int32_t nFlags;
	char pad_0x0018[0x4];
	ConVar* pParent;
	char* pszDefaultValue;
	char* strString;
	int32_t StringLength;
	float fValue;
	int32_t nValue;
	int32_t bHasMin;
	float fMinVal;
	int32_t bHasMax;
	float fMaxVal;
	CUtlVector<ChangeCallback_t> fnChangeCallback;
	float GetFloat()
	{
		auto temp = *(int*)(&fValue);
		auto temp_result = (int)(temp ^ (DWORD)this);

		return *(float*)(&temp_result);
	}
	int GetInt()
	{
		auto temp = *(int*)(&nValue);
		auto temp_result = (int)(temp ^ (uintptr_t)this);

		return *(int*)(&temp_result);
	}
	bool GetBool() { return !!GetInt(); }

	void SetValue(const char* value)
	{
		typedef void(__thiscall* OriginalFn)(void*, const char *);
		return Memory::VCall<OriginalFn>(this, 14)(this, value);
	}
	void SetValueStr(const char* str)
	{
		typedef void(__thiscall* SetStringFn)(void*, const char*);
		return Memory::VCall<SetStringFn>(this, 13)(this, str);
	}
	void SetValue(int value)
	{
		typedef void(__thiscall* OriginalFn)(void*, int);
		return Memory::VCall<OriginalFn>(this, 16)(this, value);
	}

	/* bruh these are for lua*/
	void SetValueString( const char* value ) {
		typedef void( __thiscall* OriginalFn )( void*, const char* );
		return Memory::VCall<OriginalFn>( this, 14 )( this, value );
	}

	void SetValueInt( int value ) {
		typedef void( __thiscall* OriginalFn )( void*, int );
		return Memory::VCall<OriginalFn>( this, 16 )( this, value );
	}

	void SetValueFloat( float value ) {
		typedef void( __thiscall* OriginalFn )( void*, float );
		return Memory::VCall<OriginalFn>( this, 15 )( this, value );
	}

	void SetValueChar(const char* name)
	{
		typedef void(__thiscall* SetNameFN)(void*, const char*);
		return Memory::VCall<SetNameFN>(this, 14)(this, name);
	}
	void InternalSetString(const char* str)
	{
		typedef void(__thiscall* SetStringFn)(void*, const char*);
		return Memory::VCall<SetStringFn>(this, 17)(this, str);
	}
	char* GetBaseName()
	{
		typedef char*(__thiscall* SetStringFn)(void*);
		return Memory::VCall<SetStringFn>(this, 6)(this);
	}

	const char* GetString() {
		return pParent->pszDefaultValue;
	}

	bool Valid(  ) {
		return this != nullptr;
	}

};//Size=0x0048

class ICVar
{
public:
	virtual void			RegisterConCommand(ConVar *pCommandBase) = 0;
	virtual void			UnregisterConCommand(ConVar *pCommandBase) = 0;

	ConVar *FindVar(const char *var_name)
	{
		typedef ConVar*(__thiscall* FindVarFn)(void*, const char *);
		return Memory::VCall<FindVarFn>(this, 14)(this, var_name);
	}
	void const ConsoleColorPrintf(const Color& clr, const char *pFormat, ...) {
		typedef void(__cdecl *OriginalFn)(void*, const Color&, const char *, ...);

		if (pFormat == nullptr)
			return;

		char buf[8192];

		va_list list;
		va_start(list, pFormat);
		_vsnprintf(buf, sizeof(buf) - 1, pFormat, list);
		va_end(list);
		buf[sizeof(buf) - 1] = 0;

		Memory::VCall<OriginalFn>(this, 25)(this, clr, buf, list);
	}
};


```

`CSGO SDK/SDK/Classes/IEngineSound.hpp`:

```hpp
#pragma once
#include "sdk.hpp"

struct SndInfo_t
{
  // Sound Guid
  int			m_nGuid;
  void* m_filenameHandle;		// filesystem filename handle - call IFilesystem to conver this to a string
  int			m_nSoundSource;
  int			m_nChannel;
  // If a sound is being played through a speaker entity (e.g., on a monitor,), this is the
  //  entity upon which to show the lips moving, if the sound has sentence data
  int			m_nSpeakerEntity;
  float		m_flVolume;
  float		m_flLastSpatializedVolume;
  // Radius of this sound effect (spatialization is different within the radius)
  float		m_flRadius;
  int			m_nPitch;
  Vector		*m_pOrigin;
  Vector		*m_pDirection;

  // if true, assume sound source can move and update according to entity
  bool		m_bUpdatePositions;
  // true if playing linked sentence
  bool		m_bIsSentence;
  // if true, bypass all dsp processing for this sound (ie: music)	
  bool		m_bDryMix;
  // true if sound is playing through in-game speaker entity.
  bool		m_bSpeaker;
  // for snd_show, networked sounds get colored differently than local sounds
  bool		m_bFromServer;
};
class IRecipientFilter;

enum soundlevel_t
{
  SNDLVL_NONE = 0,
  SNDLVL_20dB = 20,		// rustling leaves
  SNDLVL_25dB = 25,		// whispering
  SNDLVL_30dB = 30,		// library
  SNDLVL_35dB = 35,
  SNDLVL_40dB = 40,
  SNDLVL_45dB = 45,		// refrigerator
  SNDLVL_50dB = 50,	    // 3.9    // average home
  SNDLVL_55dB = 55,	    // 3.0
  SNDLVL_IDLE = 60,	    // 2.0	
  SNDLVL_60dB = 60,	    // 2.0	// normal conversation, clothes dryer
  SNDLVL_65dB = 65,	    // 1.5	// washing machine, dishwasher
  SNDLVL_STATIC = 66,	    // 1.25
  SNDLVL_70dB = 70,	    // 1.0	// car, vacuum cleaner, mixer, electric sewing machine
  SNDLVL_NORM = 75,
  SNDLVL_75dB = 75,	    // 0.8	// busy traffic
  SNDLVL_80dB = 80,	    // 0.7	// mini-bike, alarm clock, noisy restaurant, office tabulator, outboard motor, passing snowmobile
  SNDLVL_TALKING = 80,    // 0.7
  SNDLVL_85dB = 85,	    // 0.6	// average factory, electric shaver
  SNDLVL_90dB = 90,	    // 0.5	// screaming child, passing motorcycle, convertible ride on frw
  SNDLVL_95dB = 95,
  SNDLVL_100dB = 100,	    // 0.4	// subway train, diesel truck, woodworking shop, pneumatic drill, boiler shop, jackhammer
  SNDLVL_105dB = 105,     // helicopter, power mower
  SNDLVL_110dB = 110,     // snowmobile drvrs seat, inboard motorboat, sandblasting
  SNDLVL_120dB = 120,     // auto horn, propeller aircraft
  SNDLVL_130dB = 130,     // air raid siren
  SNDLVL_GUNFIRE = 140,	// 0.27	// THRESHOLD OF PAIN, gunshot, jet engine
  SNDLVL_140dB = 140,	    // 0.2
  SNDLVL_150dB = 150,	    // 0.2
  SNDLVL_180dB = 180,		// rocket launching

									// NOTE: Valid soundlevel_t values are 0-255.
									//       256-511 are reserved for sounds using goldsrc compatibility attenuation.
};

//-----------------------------------------------------------------------------
// common pitch values
//-----------------------------------------------------------------------------
#define PITCH_NORM		100			  // non-pitch shifted
#define PITCH_LOW		95			    // other values are possible - 0-255, where 255 is very high
#define PITCH_HIGH		120

class IEngineSound
{
public:
  // Precache a particular sample
  virtual bool PrecacheSound( const char *pSample, bool bPreload = false, bool bIsUISound = false ) = 0;
  virtual bool IsSoundPrecached( const char *pSample ) = 0;
  virtual void PrefetchSound( const char *pSample ) = 0;
  virtual bool IsLoopingSound( const char *pSample ) = 0;

  // Just loads the file header and checks for duration (not hooked up for .mp3's yet)
  // Is accessible to server and client though
  virtual float GetSoundDuration( const char *pSample ) = 0;

  // Pitch of 100 is no pitch shift.  Pitch > 100 up to 255 is a higher pitch, pitch < 100
  // down to 1 is a lower pitch.   150 to 70 is the realistic range.
  // EmitSound with pitch != 100 should be used sparingly, as it's not quite as
  // fast (the pitchshift mixer is not native coded).

  // NOTE: setting iEntIndex to -1 will cause the sound to be emitted from the local
  // player (client-side only)
  virtual int EmitSound( IRecipientFilter& filter, int iEntIndex, int iChannel, const char *pSoundEntry, unsigned int nSoundEntryHash, const char *pSample,
	 float flVolume, float flAttenuation, int nSeed, int iFlags = 0, int iPitch = PITCH_NORM,
	 const Vector *pOrigin = NULL, const Vector *pDirection = NULL, CUtlVector< Vector >* pUtlVecOrigins = NULL, bool bUpdatePositions = true, float soundtime = 0.0f, int speakerentity = -1 ) = 0;

  virtual int EmitSound( IRecipientFilter& filter, int iEntIndex, int iChannel, const char *pSoundEntry, unsigned int nSoundEntryHash, const char *pSample,
	 float flVolume, soundlevel_t iSoundlevel, int nSeed, int iFlags = 0, int iPitch = PITCH_NORM,
	 const Vector *pOrigin = NULL, const Vector *pDirection = NULL, CUtlVector< Vector >* pUtlVecOrigins = NULL, bool bUpdatePositions = true, float soundtime = 0.0f, int speakerentity = -1 ) = 0;

  virtual void EmitSentenceByIndex( IRecipientFilter& filter, int iEntIndex, int iChannel, int iSentenceIndex,
	 float flVolume, soundlevel_t iSoundlevel, int nSeed, int iFlags = 0, int iPitch = PITCH_NORM,
	 const Vector *pOrigin = NULL, const Vector *pDirection = NULL, CUtlVector< Vector >* pUtlVecOrigins = NULL, bool bUpdatePositions = true, float soundtime = 0.0f, int speakerentity = -1 ) = 0;

  virtual void    StopSound( int iEntIndex, int iChannel, const char *pSample, unsigned int nSoundEntryHash ) = 0;
  virtual void    StopAllSounds( bool bClearBuffers ) = 0;
  virtual void    SetRoomType( IRecipientFilter& filter, int roomType ) = 0;
  virtual void    SetPlayerDSP( IRecipientFilter& filter, int dspType, bool fastReset ) = 0;
  virtual int     EmitAmbientSound( const char *pSample, float flVolume, int iPitch = PITCH_NORM, int flags = 0, float soundtime = 0.0f ) = 0;
  virtual float   GetDistGainFromSoundLevel( soundlevel_t soundlevel, float dist ) = 0;
  virtual int		GetGuidForLastSoundEmitted( ) = 0;
  virtual bool		IsSoundStillPlaying( int guid ) = 0;
  virtual void		StopSoundByGuid( int guid, bool bForceSync ) = 0;
  virtual void		SetVolumeByGuid( int guid, float fvol ) = 0;
  virtual void    unknown( ) = 0;
  virtual void		GetActiveSounds( CUtlVector<SndInfo_t>& sndlist ) = 0;
  virtual void		PrecacheSentenceGroup( const char *pGroupName ) = 0;
  virtual void		NotifyBeginMoviePlayback( ) = 0;
  virtual void		NotifyEndMoviePlayback( ) = 0;
  virtual bool		GetSoundChannelVolume( const char* sound, float &flVolumeLeft, float &flVolumeRight ) = 0;
  virtual float	GetElapsedTimeByGuid( int guid ) = 0;
};
```

`CSGO SDK/SDK/Classes/IEngineTrace.cpp`:

```cpp
#include "IEngineTrace.hpp"
#include "entity.hpp"
#include "../displacement.hpp"
#include "../../source.hpp"

bool CTraceFilterPlayersOnlySkipOne::ShouldHitEntity( IHandleEntity* pEntityHandle, int ) {
   return pEntityHandle != pEnt && ( ( IClientEntity* ) pEntityHandle )->GetClientClass( )->m_ClassID == CCSPlayer;
}

bool CTraceFilter::ShouldHitEntity( IHandleEntity* pEntityHandle, int ) {
   ClientClass* pEntCC = ( ( IClientEntity* ) pEntityHandle )->GetClientClass( );
   if ( pEntCC && strcmp( ccIgnore, "" ) ) {
	  if ( pEntCC->m_pNetworkName == ccIgnore )
		 return false;
   }

   return !( pEntityHandle == pSkip );
}

bool CGameTrace::DidHitWorld() const {
	return hit_entity == Interfaces::m_pEntList->GetClientEntity(0);
}

bool CGameTrace::DidHitNonWorldEntity() const {
	return hit_entity != nullptr && !DidHitWorld();
}


__forceinline uint32_t IEngineTrace::GetFilterSimpleVtable( ) {
   static const auto filter_simple = *reinterpret_cast< uint32_t* >( Engine::Displacement.Function.m_TraceFilterSimple );
   return filter_simple;
}

```

`CSGO SDK/SDK/Classes/IEngineTrace.hpp`:

```hpp
#pragma once
#include "../sdk.hpp"

class ITraceFilter
{
public:
	virtual bool ShouldHitEntity(IHandleEntity *pEntity, int contentsMask) = 0;
	virtual TraceType GetTraceType() const = 0;
};

using ShouldHitFunc_t = bool(__cdecl*)(IHandleEntity*, int);


//-----------------------------------------------------------------------------
// Classes are expected to inherit these + implement the ShouldHitEntity method
//-----------------------------------------------------------------------------

// This iCTraceFilterWorldOnlys the one most normal traces will inherit from
class CTraceFilter : public ITraceFilter
{
public:
	bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/);

	virtual TraceType GetTraceType() const
	{
		return TraceType::TRACE_EVERYTHING;
	}

	inline void SetIgnoreClass(char* Class)
	{
		ccIgnore = Class;
	}

	void* pSkip;
	char* ccIgnore = "";
};


class CTraceFilterSimple : public CTraceFilter {
public:
	const IHandleEntity* m_pass_ent1;
	int             m_collision_group;
	ShouldHitFunc_t m_shouldhit_check_fn;

public:
	__forceinline CTraceFilterSimple() {}

	__forceinline CTraceFilterSimple(const IHandleEntity* pass_ent1, int collision_group = COLLISION_GROUP_NONE, ShouldHitFunc_t shouldhit_check_fn = nullptr) :
		m_pass_ent1{ pass_ent1 },
		m_collision_group{ collision_group },
		m_shouldhit_check_fn{ shouldhit_check_fn } {}

	virtual bool ShouldHitEntity(IHandleEntity* entity, int contents_mask) {
		return entity != m_pass_ent1;
	}

	virtual void SetPassEntity(IHandleEntity* pass_ent1) {
		m_pass_ent1 = pass_ent1;
	}

	virtual void SetCollisionGroup(int collision_group) {
		m_collision_group = collision_group;
	}
};

class CTraceFilterWorldOnly : public ITraceFilter {
public:
	virtual bool ShouldHitEntity(IHandleEntity* entity, int contents_mask) {
		return false;
	}

	virtual TraceType GetTraceType() const {
		return TraceType::TRACE_WORLD_ONLY;
	}
};

class CTraceFilterWorldAndPropsOnly : public ITraceFilter
{
public:
	bool ShouldHitEntity(IHandleEntity* /*pServerEntity*/, int /*contentsMask*/)
	{
		return false;
	}
	virtual TraceType GetTraceType() const
	{
		return TraceType::TRACE_EVERYTHING;
	}

	void* pEntity;
};

class CTraceFilterPlayersOnlySkipOne : public ITraceFilter
{
public:
	CTraceFilterPlayersOnlySkipOne(IClientEntity* ent)
	{
		pEnt = ent;
	}
	bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/);

	virtual TraceType GetTraceType() const
	{
		return TraceType::TRACE_ENTITIES_ONLY;
	}

private:
	IClientEntity* pEnt;
};

class CTraceFilterSkipTwoEntities : public ITraceFilter
{
public:
	CTraceFilterSkipTwoEntities(IClientEntity* ent1, IClientEntity* ent2)
	{
		pEnt1 = ent1;
		pEnt2 = ent2;
	}
	bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/)
	{
		return !(pEntityHandle == (IHandleEntity*)pEnt1 || pEntityHandle == (IHandleEntity*)pEnt2);
	}
	virtual TraceType GetTraceType() const
	{
		return TraceType::TRACE_EVERYTHING;
	}

private:
	IClientEntity* pEnt1;
	IClientEntity* pEnt2;
};

class CTraceFilterHitAll : public CTraceFilter
{
public:
	virtual bool ShouldHitEntity(IHandleEntity* /*pServerEntity*/, int /*contentsMask*/)
	{
		return true;
	}
};


struct Ray_t
{
	VectorAligned  m_Start;  // starting point, centered within the extents
	VectorAligned  m_Delta;  // direction + length of the ray
	VectorAligned  m_StartOffset; // Add this to m_Start to Get the actual ray start
	VectorAligned  m_Extents;     // Describes an axis aligned box extruded along a ray
	const matrix3x4_t *m_pWorldAxisTransform;
	bool m_IsRay;  // are the extents zero?
	bool m_IsSwept;     // is delta != 0?

	Ray_t() : m_pWorldAxisTransform(NULL) {}
	Ray_t(Vector _start, Vector _end, Vector _mins, Vector _maxs)
	{
		Init(_start, _end, _mins, _maxs);
	}
	Ray_t(Vector _start, Vector _end)
	{
		Init(_start, _end);
	}
	void Init(Vector const& start, Vector const& end)
	{
		m_Delta = end - start;

		m_IsSwept = (m_Delta.LengthSquared() != 0);

		m_Extents.Init();

		m_pWorldAxisTransform = NULL;
		m_IsRay = true;

		// Offset m_Start to be in the center of the box...
		m_StartOffset.Init();
		m_Start = start;
	}

	void Init(Vector const& start, Vector const& end, Vector const& mins, Vector const& maxs)
	{
		m_Delta = end - start;

		m_pWorldAxisTransform = NULL;
		m_IsSwept = (m_Delta.LengthSquared() != 0);

		m_Extents = maxs - mins;
		m_Extents *= 0.5f;
		m_IsRay = (m_Extents.LengthSquared() < 1e-6);

		// Offset m_Start to be in the center of the box...
		m_StartOffset = maxs + mins;
		m_StartOffset *= 0.5f;
		m_Start = start + m_StartOffset;
		m_StartOffset *= -1.0f;
	}
	Vector InvDelta() const
	{
		Vector vecInvDelta;
		for (int iAxis = 0; iAxis < 3; ++iAxis) {
			if (m_Delta[iAxis] != 0.0f) {
				vecInvDelta[iAxis] = 1.0f / m_Delta[iAxis];
			}
			else {
				vecInvDelta[iAxis] = FLT_MAX;
			}
		}
		return vecInvDelta;
	}

private:
};

class CBaseTrace
{
public:
	bool IsDispSurface(void) { return ((dispFlags & DISPSURF_FLAG_SURFACE) != 0); }
	bool IsDispSurfaceWalkable(void) { return ((dispFlags & DISPSURF_FLAG_WALKABLE) != 0); }
	bool IsDispSurfaceBuildable(void) { return ((dispFlags & DISPSURF_FLAG_BUILDABLE) != 0); }
	bool IsDispSurfaceProp1(void) { return ((dispFlags & DISPSURF_FLAG_SURFPROP1) != 0); }
	bool IsDispSurfaceProp2(void) { return ((dispFlags & DISPSURF_FLAG_SURFPROP2) != 0); }

public:

	// these members are aligned!!
	Vector         startpos;            // start position
	Vector         endpos;              // final position
	cplane_t       plane;               // surface normal at impact

	float          fraction;            // time completed, 1.0 = didn't hit anything

	int            contents;            // contents on other side of surface hit
	unsigned short dispFlags;           // displacement flags for marking surfaces with data

	bool           allsolid;            // if true, plane is not valid
	bool           startsolid;          // if true, the initial point was in a solid area

	CBaseTrace() {}

};


class CGameTrace : public CBaseTrace
{
public:
	bool DidHitWorld() const;
	bool DidHitNonWorldEntity() const;
	int GetEntityIndex() const;
	bool DidHit() const;
	bool IsVisible() const;

public:

	float               fractionleftsolid;  // time we left a solid, only valid if we started in solid
	csurface_t          surface;            // surface hit (impact surface)
	int                 hitgroup;           // 0 == generic, non-zero is specific body part
	short               physicsbone;        // physics bone hit by trace in studio
	unsigned short      worldSurfaceIndex;  // Index of the msurface2_t, if applicable
	IClientEntity*      hit_entity;
	int                 hitbox;  
	bool				m_allsolid;
	bool				m_startsolid;
	// box hit by trace in studio

	__forceinline bool hit() const {
		return fraction < 1.f || m_allsolid || m_startsolid;
	}

	CGameTrace() {}

private:
	// No copy constructors allowed
	CGameTrace(const CGameTrace& other) :
		fractionleftsolid(other.fractionleftsolid),
		surface(other.surface),
		hitgroup(other.hitgroup),
		physicsbone(other.physicsbone),
		worldSurfaceIndex(other.worldSurfaceIndex),
		hit_entity(other.hit_entity),
		hitbox(other.hitbox)
	{
		startpos = other.startpos;
		endpos = other.endpos;
		plane = other.plane;
		fraction = other.fraction;
		contents = other.contents;
		dispFlags = other.dispFlags;
		allsolid = other.allsolid;
		startsolid = other.startsolid;
	}
};

inline bool CGameTrace::DidHit() const
{
	return fraction < 1.0 || allsolid || startsolid;
}

inline bool CGameTrace::IsVisible() const
{
	return fraction > 0.97f;
}

class IEngineTrace
{
public:
	virtual int   GetPointContents(const Vector &vecAbsPosition, int contentsMask = MASK_ALL, IHandleEntity** ppEntity = nullptr) = 0;
	virtual int   GetPointContents_WorldOnly(const Vector &vecAbsPosition, int contentsMask = MASK_ALL) = 0;
	virtual int   GetPointContents_Collideable(ICollideable *pCollide, const Vector &vecAbsPosition) = 0;
	virtual void  ClipRayToEntity(const Ray_t &ray, unsigned int fMask, IHandleEntity *pEnt, CGameTrace *pTrace) = 0;
	virtual void  ClipRayToCollideable(const Ray_t &ray, unsigned int fMask, ICollideable *pCollide, CGameTrace *pTrace) = 0;
	virtual void  TraceRay(const Ray_t &ray, unsigned int fMask, ITraceFilter *pTraceFilter, CGameTrace *pTrace) = 0;

	__forceinline uint32_t GetFilterSimpleVtable( );
};
```

`CSGO SDK/SDK/Classes/IGameEventManager.hpp`:

```hpp
#pragma once
#include <cstdint>

#define EVENT_DEBUG_ID_INIT 42 
#define EVENT_DEBUG_ID_SHUTDOWN 13  

class IGameEvent
{
public:
  virtual ~IGameEvent() = 0;
  virtual const char*     GetName() const = 0;

  virtual bool            IsReliable() const = 0;
  virtual bool            IsLocal() const = 0;
  virtual bool            IsEmpty(const char *keyName = nullptr) = 0;

  virtual bool            GetBool(const char *keyName = nullptr, bool defaultValue = false) = 0;
  virtual int             GetInt(const char *keyName = nullptr, int defaultValue = 0) = 0;
  virtual uint64_t        GetUint64(const char *keyName = nullptr, unsigned long defaultValue = 0) = 0;
  virtual float           GetFloat(const char *keyName = nullptr, float defaultValue = 0.0f) = 0;
  virtual const char*     GetString(const char *keyName = nullptr, const char *defaultValue = "") = 0;
  virtual const wchar_t*  GetWString(const char *keyName, const wchar_t *defaultValue = L"") = 0;

  virtual void            SetBool(const char *keyName, bool value) = 0;
  virtual void            SetInt(const char *keyName, int value) = 0;
  virtual void            SetUint64(const char *keyName, unsigned long value) = 0;
  virtual void            SetFloat(const char *keyName, float value) = 0;
  virtual void            SetString(const char *keyName, const char *value) = 0;
  virtual void            SetWString(const char *keyName, const wchar_t *value) = 0;

  bool get_bool( const char* keyName ) {
	  return GetBool( keyName );
  }

  int get_int( const char* keyName ) {
	  return GetInt( keyName );
  }

  uint64_t get_uint64( const char* keyName ) {
	  return GetUint64( keyName );
  }

  float get_float( const char* keyName ) {
	  return GetFloat( keyName );
  }

  const char* get_string( const char* keyName ) {
	  return GetString( keyName );
  }

  const wchar_t* get_wstring( const char* keyName ) {
	  return GetWString( keyName );
  }
};

class IGameEventListener
{
public:
  virtual ~IGameEventListener(void) {}

  virtual void FireGameEvent(IGameEvent *event) = 0;
  virtual int  GetEventDebugID(void) = 0;

public:
  int m_iDebugId;
};

class IGameEventManager
{
public:
  virtual             ~IGameEventManager() = 0;
  virtual int         LoadEventsFromFile(const char *filename) = 0;
  virtual void        Reset() = 0;
  virtual bool        AddListener(IGameEventListener *listener, const char *name, bool bServerSide) = 0;
  virtual bool        FindListener(IGameEventListener *listener, const char *name) = 0;
  virtual int         RemoveListener(IGameEventListener *listener) = 0;
  virtual IGameEvent* CreateEvent(const char *name, bool bForce, unsigned int dwUnknown) = 0;
  virtual bool        FireEvent(IGameEvent *event, bool bDontBroadcast = false) = 0;
  virtual bool        FireEventClientSide(IGameEvent *event) = 0;
  virtual IGameEvent* DuplicateEvent(IGameEvent *event) = 0;
  virtual void        FreeEvent(IGameEvent *event) = 0;
  virtual bool        SerializeEvent(IGameEvent *event, bf_write *buf) = 0;
  virtual IGameEvent* UnserializeEvent(bf_read *buf) = 0;
};

```

`CSGO SDK/SDK/Classes/IGameMovement.cpp`:

```cpp
#include "../sdk.hpp"

void IGameMovement::ProcessMovement( C_BasePlayer* pPlayer, CMoveData* pMove ) {
  using Fn = void( __thiscall* )( void*, C_BasePlayer*, CMoveData* );
  return Memory::VCall<Fn>( this, Index::IGameMovement::ProcessMovement )( this, pPlayer, pMove );
}

void IGameMovement::Reset( ) {
  using Fn = void( __thiscall* )( void* );
  return Memory::VCall<Fn>( this, Index::IGameMovement::Reset )( this );
}

void IGameMovement::StartTrackPredictionErrors( C_BasePlayer* pPlayer ) {
  using Fn = void( __thiscall* )( void*, C_BasePlayer* );
  return Memory::VCall<Fn>( this, Index::IGameMovement::StartTrackPredictionErrors )( this, pPlayer );
}

void IGameMovement::FinishTrackPredictionErrors( C_BasePlayer* pPlayer ) {
  using Fn = void( __thiscall* )( void*, C_BasePlayer* );
  return Memory::VCall<Fn>( this, Index::IGameMovement::FinishTrackPredictionErrors )( this, pPlayer );
}

Vector IGameMovement::GetPlayerMins( bool bDucked ) {
  return Memory::VCall< const Vector&( __thiscall* )( void*, bool ) >( this, Index::IGameMovement::GetPlayerMins )( this, bDucked );
}

Vector IGameMovement::GetPlayerMaxs( bool bDucked ) {
  return Memory::VCall< const Vector&( __thiscall* )( void*, bool ) >( this, Index::IGameMovement::GetPlayerMaxs )( this, bDucked );
}

Vector IGameMovement::GetPlayerViewOffset( bool bDucked ) {
  return Memory::VCall< const Vector&( __thiscall* )( void*, bool ) >( this, Index::IGameMovement::GetPlayerViewOffset )( this, bDucked );
}

```

`CSGO SDK/SDK/Classes/IGameMovement.hpp`:

```hpp
#pragma once
class IGameMovement
{
public:
	void ProcessMovement( C_BasePlayer* pPlayer, CMoveData* pMove );
	void Reset( );
	void StartTrackPredictionErrors( C_BasePlayer* pPlayer );
	void FinishTrackPredictionErrors( C_BasePlayer* pPlayer );
	Vector GetPlayerMins( bool bDucked );
	Vector GetPlayerMaxs( bool bDucked );
	Vector GetPlayerViewOffset( bool bDucked );
};

```

`CSGO SDK/SDK/Classes/IInput.cpp`:

```cpp
#include "../sdk.hpp"

CUserCmd* IInput::GetUserCmd(int sequence_number)
{
	return &m_pCommands[sequence_number % MULTIPLAYER_BACKUP];
}
//
//CVerifiedUserCmd* IInput::GetVerifiedUserCmd(int sequence_number)
//{
//	return &m_pVerifiedCommands[sequence_number % MULTIPLAYER_BACKUP];
//}
```

`CSGO SDK/SDK/Classes/IInput.hpp`:

```hpp
#pragma once
class IInput
{
public:
	virtual void Init_All( void ) = 0;
	virtual void Shutdown_All( void ) = 0;
	virtual int GetButtonBits( int ) = 0;
	virtual void CreateMove( int sequence_number, float input_sample_frametime, bool active ) = 0;
	virtual void ExtraMouseSample( float frametime, bool active ) = 0;
	virtual bool WriteUsercmdDeltaToBuffer( int nSlot, void* buf, int from, int to, bool isnewcommand ) = 0;
	virtual void EncodeUserCmdToBuffer( void* buf, int slot ) = 0;
	virtual void DecodeUserCmdFromBuffer( void* buf, int slot ) = 0;
	virtual CUserCmd* GetUserCmd( int slot, int sequence_number ) = 0;

	//void* pvftable;
	bool				m_pad_something;
	bool				m_mouse_initialized;
	bool				m_mouse_active;
	bool				pad_something01;
	char				pad_0x08[ 0x2C ];
	void* m_keys;
	char				pad_0x38[ 0x64 ];
	__int32				pad_0x41;
	__int32				pad_0x42;
	bool				m_camera_intercepting_mouse;
	bool				m_fCameraInThirdPerson;
	bool                m_fCameraMovingWithMouse;
	Vector			    m_vecCameraOffset;
	bool                m_fCameraDistanceMove;
	int                 m_nCameraOldX;
	int                 m_nCameraOldY;
	int                 m_nCameraX;
	int                 m_nCameraY;
	bool                m_CameraIsOrthographic;
	Vector              m_angPreviousViewAngles;
	Vector              m_angPreviousViewAnglesTilt;
	float               m_flLastForwardMove;
	int                 m_nClearInputState;
	char                pad_0xE4[ 0x8 ];
	CUserCmd* m_pCommands;
	CVerifiedUserCmd* m_pVerifiedCommands;

	__forceinline int CAM_IsThirdPerson( int slot = -1 ) {
		return Memory::VCall< int( __thiscall* )( decltype( this ), int ) >( this, 32 )( this, slot );
	}

	__forceinline void CAM_ToThirdPerson( ) {
		return Memory::VCall< void( __thiscall* )( decltype( this ) ) >( this, 35 )( this );
	}

	__forceinline void CAM_ToFirstPerson( ) {
		return Memory::VCall< void( __thiscall* )( decltype( this ) ) >( this, 36 )( this );
	}
	CUserCmd* GetUserCmd(int sequence_number);
};

```

`CSGO SDK/SDK/Classes/IInputSystem.cpp`:

```cpp
#include "IInputSystem.hpp"
#include "../sdk.hpp"

// ayysense kek
void IInputSystem::EnableInput( bool state ) {
	using original_fn = void( __thiscall* )( IInputSystem*, bool );
	return ( *( original_fn** )this )[ 11 ]( this, state );
}
```

`CSGO SDK/SDK/Classes/IInputSystem.hpp`:

```hpp
#pragma once

class IInputSystem {
public:
	void EnableInput( bool state );
};
```

`CSGO SDK/SDK/Classes/ILocalize.hpp`:

```hpp
#pragma once
#include "IAppSystem.hpp"

class ILocalize : public IAppSystem {
public:
  virtual bool AddFile(const char* fileName, const char* pPathID = nullptr, bool bIncludeFallbackSearchPaths = false) = 0;
  virtual void RemoveAll() = 0;
  virtual wchar_t* Find(const char* tokenName) = 0;
  virtual const wchar_t* FindSafe(const char* tokenName) = 0;
  virtual int ConvertANSIToUnicode(const char* ansi, wchar_t* unicode, int unicodeBufferSizeInBytes) = 0;
  virtual int ConvertUnicodeToANSI(const wchar_t* unicode, char* ansi, int ansiBufferSize) = 0;
  virtual unsigned FindIndex(const char* tokenName) = 0;
  virtual void ConstructString(wchar_t* unicodeOuput, int unicodeBufferSizeInBytes, const wchar_t* formatString, int numFormatParameters, ...) = 0;
  virtual const char* GetNameByIndex(unsigned index) = 0;
  virtual wchar_t* GetValueByIndex(unsigned index) = 0;
};
```

`CSGO SDK/SDK/Classes/IMaterialSystem.hpp`:

```hpp
#pragma once
#include "sdk.hpp"
#include "IAppSystem.hpp"

typedef void(*MaterialBufferReleaseFunc_t)(int nChangeFlags);	// see RestoreChangeFlags_t
typedef void(*MaterialBufferRestoreFunc_t)(int nChangeFlags);	// see RestoreChangeFlags_t
typedef void(*ModeChangeCallbackFunc_t)(void);
typedef void(*EndFrameCleanupFunc_t)(void);
typedef bool(*EndFramePriorToNextContextFunc_t)(void);
typedef void(*OnLevelShutdownFunc_t)(void *pUserData);

typedef unsigned short MaterialHandle_t;
DECLARE_POINTER_HANDLE(MaterialLock_t);

class IMaterialSystem : public IAppSystem
{
public:

	virtual CreateInterfaceFn               Init(char const* pShaderAPIDLL, IMaterialProxyFactory *pMaterialProxyFactory, CreateInterfaceFn fileSystemFactory, CreateInterfaceFn cvarFactory = NULL) = 0;
	virtual void                            SetShaderAPI(char const *pShaderAPIDLL) = 0;
	virtual void                            SetAdapter(int nAdapter, int nFlags) = 0;
	virtual void                            ModInit() = 0;
	virtual void                            ModShutdown() = 0;
	virtual void                            SetThreadMode(MaterialThreadMode_t mode, int nServiceThread = -1) = 0;
	virtual MaterialThreadMode_t            GetThreadMode() = 0;
	virtual void                            ExecuteQueued() = 0;
	virtual void                            OnDebugEvent(const char *pEvent) = 0;
	virtual IMaterialSystemHardwareConfig*  GetHardwareConfig(const char *pVersion, int *returnCode) = 0;
	virtual void                            __unknown() = 0;
	virtual bool                            UpdateConfig(bool bForceUpdate) = 0; //20
	virtual bool                            OverrideConfig(const MaterialSystem_Config_t &config, bool bForceUpdate) = 0;
	virtual const MaterialSystem_Config_t&  GetCurrentConfigForVideoCard() const = 0;
	virtual bool                            GetRecommendedConfigurationInfo(int nDXLevel, KeyValues * pKeyValues) = 0;
	virtual int                             GetDisplayAdapterCount() const = 0;
	virtual int                             GetCurrentAdapter() const = 0;
	virtual void                            GetDisplayAdapterInfo(int adapter, MaterialAdapterInfo_t& info) const = 0;
	virtual int                             GetModeCount(int adapter) const = 0;
	virtual void                            GetModeInfo(int adapter, int mode, MaterialVideoMode_t& info) const = 0;
	virtual void                            AddModeChangeCallBack(ModeChangeCallbackFunc_t func) = 0;
	virtual void                            GetDisplayMode(MaterialVideoMode_t& mode) const = 0; //30
	virtual bool                            SetMode(void* hwnd, const MaterialSystem_Config_t &config) = 0;
	virtual bool                            SupportsMSAAMode(int nMSAAMode) = 0;
	virtual const MaterialSystemHWID_t&     GetVideoCardIdentifier(void) const = 0;
	virtual void                            SpewDriverInfo() const = 0;
	virtual void                            GetBackBufferDimensions(int &width, int &height) const = 0;
	virtual ImageFormat                     GetBackBufferFormat() const = 0;
	virtual const AspectRatioInfo_t&        GetAspectRatioInfo() const = 0;
	virtual bool                            SupportsHDRMode(HDRType_t nHDRModede) = 0;
	virtual bool                            AddView(void* hwnd) = 0;
	virtual void                            RemoveView(void* hwnd) = 0; //40
	virtual void                            SetView(void* hwnd) = 0;
	virtual void                            BeginFrame(float frameTime) = 0;
	virtual void                            EndFrame() = 0;
	virtual void                            Flush(bool flushHardware = false) = 0;
	virtual unsigned int                    GetCurrentFrameCount() = 0;
	virtual void                            SwapBuffers() = 0;
	virtual void                            EvictManagedResources() = 0;
	virtual void                            ReleaseResources(void) = 0;
	virtual void                            ReacquireResources(void) = 0;
	virtual void                            AddReleaseFunc(MaterialBufferReleaseFunc_t func) = 0; //50
	virtual void                            RemoveReleaseFunc(MaterialBufferReleaseFunc_t func) = 0;
	virtual void                            AddRestoreFunc(MaterialBufferRestoreFunc_t func) = 0;
	virtual void                            RemoveRestoreFunc(MaterialBufferRestoreFunc_t func) = 0;
	virtual void                            AddEndFrameCleanupFunc(EndFrameCleanupFunc_t func) = 0;
	virtual void                            RemoveEndFrameCleanupFunc(EndFrameCleanupFunc_t func) = 0;
	virtual void                            OnLevelShutdown() = 0;
	virtual bool                            AddOnLevelShutdownFunc(OnLevelShutdownFunc_t func, void *pUserData) = 0;
	virtual bool                            RemoveOnLevelShutdownFunc(OnLevelShutdownFunc_t func, void *pUserData) = 0;
	virtual void                            OnLevelLoadingComplete() = 0;
	virtual void                            ResetTempHWMemory(bool bExitingLevel = false) = 0; //60
	virtual void                            HandleDeviceLost() = 0;
	virtual int                             ShaderCount() const = 0;
	virtual int                             GetShaders(int nFirstShader, int nMaxCount, IShader **ppShaderList) const = 0;
	virtual int                             ShaderFlagCount() const = 0;
	virtual const char*                     ShaderFlagName(int nIndex) const = 0;
	virtual void                            GetShaderFallback(const char *pShaderName, char *pFallbackShader, int nFallbackLength) = 0;
	virtual IMaterialProxyFactory*          GetMaterialProxyFactory() = 0;
	virtual void                            SetMaterialProxyFactory(IMaterialProxyFactory* pFactory) = 0;
	virtual void                            EnableEditorMaterials() = 0;
	virtual void                            EnableGBuffers() = 0; //70
	virtual void                            SetInStubMode(bool bInStubMode) = 0;
	virtual void                            DebugPrintUsedMaterials(const char *pSearchSubString, bool bVerbose) = 0;
	virtual void                            DebugPrintUsedTextures(void) = 0;
	virtual void                            ToggleSuppressMaterial(char const* pMaterialName) = 0;
	virtual void                            ToggleDebugMaterial(char const* pMaterialName) = 0;
	virtual bool                            UsingFastClipping(void) = 0;
	virtual int                             StencilBufferBits(void) = 0; //number of bits per pixel in the stencil buffer
	virtual void                            UncacheAllMaterials() = 0;
	virtual void                            UncacheUnusedMaterials(bool bRecomputeStateSnapshots = false) = 0;
	virtual void                            CacheUsedMaterials() = 0; //80
	virtual void                            ReloadTextures() = 0;
	virtual void                            ReloadMaterials(const char *pSubString = NULL) = 0;
	virtual IMaterial*                      CreateMaterial(const char *pMaterialName, KeyValues *pVMTKeyValues) = 0;
	virtual IMaterial*                      FindMaterial(char const* pMaterialName, const char *pTextureGroupName, bool complain = true, const char *pComplainPrefix = NULL) = 0;
	virtual void							unk0() = 0;
	virtual MaterialHandle_t                FirstMaterial() const = 0;
	virtual MaterialHandle_t                NextMaterial(MaterialHandle_t h) const = 0;
	virtual MaterialHandle_t                InvalidMaterial() const = 0;
	virtual IMaterial*                      GetMaterial(MaterialHandle_t h) const = 0;
	virtual int                             GetNumMaterials() const = 0;
	virtual ITexture*                       FindTexture(char const* pTextureName, const char *pTextureGroupName, bool complain = true) = 0;
	virtual bool                            IsTextureLoaded(char const* pTextureName) const = 0;
	virtual ITexture*                       CreateProceduralTexture(const char	*pTextureName, const char *pTextureGroupName, int w, int h, ImageFormat fmt, int nFlags) = 0;
	virtual void                            BeginRenderTargetAllocation() = 0;
	virtual void                            EndRenderTargetAllocation() = 0; // Simulate an Alt-Tab in here, which causes a release/restore of all resources
	virtual ITexture*                       CreateRenderTargetTexture(int w, int h, RenderTargetSizeMode_t sizeMode, ImageFormat	format, MaterialRenderTargetDepth_t depth = MATERIAL_RT_DEPTH_SHARED) = 0;
	virtual ITexture*                       CreateNamedRenderTargetTextureEx(const char *pRTName, int w, int h, RenderTargetSizeMode_t sizeMode, ImageFormat format, MaterialRenderTargetDepth_t depth = MATERIAL_RT_DEPTH_SHARED, unsigned int textureFlags = TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT, unsigned int renderTargetFlags = 0) = 0;
	virtual ITexture*                       CreateNamedRenderTargetTexture(const char *pRTName, int w, int h, RenderTargetSizeMode_t sizeMode, ImageFormat format, MaterialRenderTargetDepth_t depth = MATERIAL_RT_DEPTH_SHARED, bool bClampTexCoords = true, bool bAutoMipMap = false) = 0;
	virtual ITexture*                       CreateNamedRenderTargetTextureEx2(const char *pRTName, int w, int h, RenderTargetSizeMode_t sizeMode, ImageFormat format, MaterialRenderTargetDepth_t depth = MATERIAL_RT_DEPTH_SHARED, unsigned int textureFlags = TEXTUREFLAGS_CLAMPS | TEXTUREFLAGS_CLAMPT, unsigned int renderTargetFlags = 0) = 0;
	virtual void				BeginLightmapAllocation() = 0;
	virtual void                unk228() = 0;
	virtual void				EndLightmapAllocation() = 0;
	virtual int 				AllocateLightmap(int width, int height,int offsetIntoLightmapPage[2],IMaterial* pMaterial) = 0;
	virtual int					AllocateWhiteLightmap(IMaterial* pMaterial) = 0;
	virtual void				UpdateLightmap(int lightmapPageID, int lightmapSize[2],	int offsetIntoLightmapPage[2],	float* pFloatImage, float* pFloatImageBump1,float* pFloatImageBump2, float* pFloatImageBump3) = 0;
	virtual int					GetNumSortIDs() = 0;
	virtual void				GetSortInfo(void* sortInfoArray) = 0;
	virtual void				GetLightmapPageSize(int lightmap, int* width, int* height) const = 0;
	virtual void				ResetMaterialLightmapPageInfo() = 0;
	virtual void				ClearBuffers(bool bClearColor, bool bClearDepth, bool bClearStencil = false) = 0;
	virtual void unk1231() = 0;
	virtual void unk1232() = 0;
	virtual void unk1233() = 0;
	virtual void unk1234() = 0;
	//virtual void unk1235() = 0;
	//virtual void unk1236() = 0;
	//virtual void unk1237() = 0;
	virtual IMatRenderContext* GetRenderContext() = 0;
};
```

`CSGO SDK/SDK/Classes/IMemAlloc.cpp`:

```cpp
#include "IMemAlloc.hpp"
#include "../sdk.hpp"

auto IMemAlloc::Alloc( int nSize ) -> void * {
  using Fn = void*( __thiscall* )( void*, int );
  return Memory::VCall< Fn >( this, 1 )( this, nSize );
}

auto IMemAlloc::Realloc( void * pMem, int nSize ) -> void * {
  using Fn = void*( __thiscall* )( void*, void*, int );
  return Memory::VCall< Fn >( this, 3 )( this, pMem, nSize );
}

auto IMemAlloc::Free( void * pMem ) -> void {
  using Fn = void( __thiscall* )( void*, void* );
  return Memory::VCall< Fn >( this, 5 )( this, pMem );
}

```

`CSGO SDK/SDK/Classes/IMemAlloc.hpp`:

```hpp
#pragma once

class IMemAlloc {
public:
  auto Alloc( int nSize ) -> void*;

  auto Realloc( void* pMem, int nSize ) -> void*;

  auto Free( void* pMem ) -> void;
};
```

`CSGO SDK/SDK/Classes/IMoveHelper.cpp`:

```cpp
#include "../sdk.hpp"

void IMoveHelper::SetHost(C_BaseEntity* host)
{
	using Fn = void(__thiscall*)(void*, C_BaseEntity*);
	return Memory::VCall<Fn>(this, Index::IMoveHelper::SetHost)(this, host);
}

void IMoveHelper::ProcessImpacts( ) {
  using Fn = void(__thiscall*)(void*);
  return Memory::VCall<Fn>(this, Index::IMoveHelper::ProccesImpacts)(this);
}

```

`CSGO SDK/SDK/Classes/IMoveHelper.hpp`:

```hpp
#pragma once
class IMoveHelper
{
public:
	void SetHost(C_BaseEntity* host);
	void ProcessImpacts();
};

```

`CSGO SDK/SDK/Classes/INetChannel.hpp`:

```hpp
#pragma once
#include "IVEngineClient.hpp"
#include "sdk.hpp"

class INetChannelInfo
{
public:

  enum {
	 GENERIC = 0,	// must be first and is default group
	 LOCALPLAYER,	// bytes for local player entity update
	 OTHERPLAYERS,	// bytes for other players update
	 ENTITIES,		// all other entity bytes
	 SOUNDS,			// game sounds
	 EVENTS,			// event messages
	 USERMESSAGES,	// user messages
	 ENTMESSAGES,	// entity messages
	 VOICE,			// voice data
	 STRINGTABLE,	// a stringtable update
	 MOVE,			// client move cmds
	 STRINGCMD,		// string command
	 SIGNON,			// various signondata
	 TOTAL,			// must be last and is not a real group
  };

  virtual const char  *GetName( void ) const = 0;	// get channel name
  virtual const char  *GetAddress( void ) const = 0; // get channel IP address as string
  virtual float		GetTime( void ) const = 0;	// current net time
  virtual float		GetTimeConnected( void ) const = 0;	// get connection time in seconds
  virtual int			GetBufferSize( void ) const = 0;	// netchannel packet history size
  virtual int			GetDataRate( void ) const = 0; // send data rate in byte/sec

  virtual bool		IsLoopback( void ) const = 0;	// true if loopback channel
  virtual bool		IsTimingOut( void ) const = 0;	// true if timing out
  virtual bool		IsPlayback( void ) const = 0;	// true if demo playback

  virtual float		GetLatency( int flow ) const = 0;	 // current latency (RTT), more accurate but jittering
  virtual float		GetAvgLatency( int flow ) const = 0; // average packet latency in seconds
  virtual float		GetAvgLoss( int flow ) const = 0;	 // avg packet loss[0..1]
  virtual float		GetAvgChoke( int flow ) const = 0;	 // avg packet choke[0..1]
  virtual float		GetAvgData( int flow ) const = 0;	 // data flow in bytes/sec
  virtual float		GetAvgPackets( int flow ) const = 0; // avg packets/sec
  virtual int			GetTotalData( int flow ) const = 0;	 // total flow in/out in bytes
  virtual int			GetSequenceNr( int flow ) const = 0;	// last send seq number
  virtual bool		IsValidPacket( int flow, int frame_number ) const = 0; // true if packet was not lost/dropped/chocked/flushed
  virtual float		GetPacketTime( int flow, int frame_number ) const = 0; // time when packet was send
  virtual int			GetPacketBytes( int flow, int frame_number, int group ) const = 0; // group size of this packet
  virtual bool		GetStreamProgress( int flow, int *received, int *total ) const = 0;  // TCP progress if transmitting
  virtual float		GetTimeSinceLastReceived( void ) const = 0;	// get time since last recieved packet in seconds
  virtual	float		GetCommandInterpolationAmount( int flow, int frame_number ) const = 0;
  virtual void		GetPacketResponseLatency( int flow, int frame_number, int *pnLatencyMsecs, int *pnChoke ) const = 0;
  virtual void		GetRemoteFramerate( float *pflFrameTime, float *pflFrameTimeStdDeviation ) const = 0;

  virtual float		GetTimeoutSeconds( ) const = 0;
};

class INetChannel : public INetChannelInfo {
public:
  char pad_0000[16];           //0x0004
  bool m_bProcessingMessages;  //0x0014
  bool m_bShouldDelete;        //0x0015
  char pad_0016[2];            //0x0016
  int32_t m_nOutSequenceNr;    //0x0018 last send outgoing sequence number
  int32_t m_nInSequenceNr;     //0x001C last received incoming sequnec number
  int32_t m_nOutSequenceNrAck; //0x0020 last received acknowledge outgoing sequnce number
  int32_t m_nOutReliableState; //0x0024 state of outgoing reliable data (0/1) flip flop used for loss detection
  int32_t m_nInReliableState;  //0x0028 state of incoming reliable data
  int32_t m_nChokedPackets;    //0x002C number of choked packets
  char pad_0030[1044];         //0x0030

  int SendDatagram( uintptr_t* datagram = nullptr ) {
	 return Memory::VCall< bool( __thiscall* )( void*, uintptr_t* ) >( this, 48 )( this, datagram );
  }

}; //Size: 0x0444
```

`CSGO SDK/SDK/Classes/INetMessage.hpp`:

```hpp
#pragma once
#include "sdk.hpp"

class INetMessage {
public:
  virtual ~INetMessage(){};

  // Use these to setup who can hear whose voice.
  // Pass in client indices (which are their ent indices - 1).

  virtual void SetNetChannel( INetChannel* netchan ) = 0; // netchannel this message is from/for
  virtual void SetReliable( bool state ) = 0;             // set to true if it's a reliable message

  virtual bool Process( void ) = 0; // calles the recently set handler to process this message

  virtual bool ReadFromBuffer( bf_read& buffer ) = 0; // returns true if parsing was OK
  virtual bool WriteToBuffer( bf_write& buffer ) = 0; // returns true if writing was OK

  virtual bool IsReliable( void ) const = 0; // true, if message needs reliable handling

  virtual int GetType( void ) const = 0;         // returns module specific header tag eg svc_serverinfo
  virtual int GetGroup( void ) const = 0;        // returns net message group of this message
  virtual const char* GetName( void ) const = 0; // returns network message name, eg "svc_serverinfo"
  virtual INetChannel* GetNetChannel( void ) const = 0;
  virtual const char* ToString( void ) const = 0; // returns a human readable string about message content
};
```

`CSGO SDK/SDK/Classes/INetworkStringTable.h`:

```h
#pragma once


```

`CSGO SDK/SDK/Classes/IPanel.cpp`:

```cpp
#include "../sdk.hpp"

const char* IPanel::GetName(VPANEL vguiPanel)
{
	using Fn = const char* (__thiscall*)(void*, VPANEL);
	return Memory::VCall<Fn>(this, Index::IPanel::GetName)(this, vguiPanel);
}

```

`CSGO SDK/SDK/Classes/IPanel.hpp`:

```hpp
#pragma once
class IPanel
{
public:
	const char* GetName(VPANEL vguiPanel);
};
```

`CSGO SDK/SDK/Classes/IPhysics.hpp`:

```hpp

#pragma once

struct surfacephysicsparams_t {
	float friction;
	float elasticity;
	float density;
	float thickness;
	float dampening;
};

struct surfaceaudioparams_t {
	float reflectivity;          // like elasticity, but how much sound should be reflected by this surface
	float hardnessFactor;        // like elasticity, but only affects impact sound choices
	float roughnessFactor;       // like friction, but only affects scrape sound choices
	float roughThreshold;        // surface roughness > this causes "rough" scrapes, < this causes "smooth" scrapes
	float hardThreshold;         // surface hardness > this causes "hard" impacts, < this causes "soft" impacts
	float hardVelocityThreshold; // collision velocity > this causes "hard" impacts, < this causes "soft" impacts
	float highPitchOcclusion;    //a value betweeen 0 and 100 where 0 is not occluded at all and 100 is silent (except for any additional reflected sound)
	float midPitchOcclusion;
	float lowPitchOcclusion;
};

struct surfacesoundnames_t {
	unsigned short walkStepLeft;
	unsigned short walkStepRight;
	unsigned short runStepLeft;
	unsigned short runStepRight;
	unsigned short impactSoft;
	unsigned short impactHard;
	unsigned short scrapeSmooth;
	unsigned short scrapeRough;
	unsigned short bulletImpact;
	unsigned short rolling;
	unsigned short breakSound;
	unsigned short strainSound;
};

struct surfacegameprops_t {
public:
	float maxSpeedFactor;
	float jumpFactor;
	float flPenetrationModifier;
	float flDamageModifier;
	unsigned short material;
	uint8_t climbable;
};

struct surfacedata_t {
	surfacephysicsparams_t physics;
	surfaceaudioparams_t audio;
	surfacesoundnames_t sounds;
	surfacegameprops_t game;
};

class IPhysicsSurfaceProps {
public:
	virtual ~IPhysicsSurfaceProps( void ) {}
	virtual int ParseSurfaceData( const char* pFilename, const char* pTextfile ) = 0;
	virtual int SurfacePropCount( void ) const = 0;
	virtual int GetSurfaceIndex( const char* pSurfacePropName ) const = 0;
	virtual void GetPhysicsProperties( int surfaceDataIndex, float* density, float* thickness, float* friction, float* elasticity ) const = 0;
	virtual surfacedata_t* GetSurfaceData( int surfaceDataIndex ) = 0;
	virtual const char GetString( unsigned short stringTableIndex ) const = 0;
	virtual const char GetPropName( int surfaceDataIndex ) const = 0;
	virtual void SetWorldMaterialIndexTable( int* pMapArray, int mapSize ) = 0;
	virtual void GetPhysicsParameters( int surfaceDataIndex, surfacephysicsparams_t* pParamsOut ) const = 0;
};

```

`CSGO SDK/SDK/Classes/IPrediction.cpp`:

```cpp
#include "../sdk.hpp"
#include "../../source.hpp"
#include "../Displacement.hpp"

void IPrediction::Update( int startframe, bool validframe, int incoming_acknowledged, int outgoing_command ) {
	using Fn = void( __thiscall* )( void*, int, bool, int, int );
	return Memory::VCall<Fn>( this, Index::IPrediction::Update )( this, startframe, validframe, incoming_acknowledged, outgoing_command );
}

void IPrediction::SetupMove( C_BasePlayer* player, CUserCmd* ucmd, IMoveHelper* pHelper, CMoveData* move ) {
	using Fn = void( __thiscall* )( void*, C_BasePlayer*, CUserCmd*, IMoveHelper*, CMoveData* );
	return Memory::VCall<Fn>( this, Index::IPrediction::SetupMove )( this, player, ucmd, pHelper, move );
}

void IPrediction::FinishMove( C_BasePlayer* player, CUserCmd* ucmd, CMoveData* move ) {
	using Fn = void( __thiscall* )( void*, C_BasePlayer*, CUserCmd*, CMoveData* );
	return Memory::VCall<Fn>( this, Index::IPrediction::FinishMove )( this, player, ucmd, move );
}

void IPrediction::SetLocalViewAngles( const QAngle& ang ) {
	return Memory::VCall< void( __thiscall* )( decltype( this ), const QAngle& ) >( this, 13 )( this, ang );
}

int IPrediction::CheckMovingGround( C_BasePlayer* player, double unk ) {
	using Fn = int( __thiscall* )( void*, C_BasePlayer*, double );
	return Memory::VCall<Fn>( this, Index::IPrediction::CheckMovingGround )( this, player, unk );
}

int& IPrediction::m_nCommandsPredicted( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.IPrediction.m_nCommandsPredicted );
}

bool IPrediction::InPrediction( ) {
	using Fn = bool( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::IPrediction::InPrediction )( this );
}

CGlobalVarsBase* IPrediction::GetUnpredictedGlobals( ) {
	if( InPrediction( ) )
		return reinterpret_cast< CGlobalVarsBase* >( uint32_t( this ) + 0x4c );

	return Interfaces::m_pGlobalVars.Xor( );
}

```

`CSGO SDK/SDK/Classes/IPrediction.hpp`:

```hpp
#pragma once

class IPrediction
{
public:
  void Update( int startframe, bool validframe, int incoming_acknowledged, int outgoing_command );
  void SetupMove( C_BasePlayer* player, CUserCmd* ucmd, IMoveHelper* pHelper, CMoveData* move );
  void FinishMove( C_BasePlayer* player, CUserCmd* ucmd, CMoveData* move );
  void SetLocalViewAngles( const QAngle& ang );
  int CheckMovingGround( C_BasePlayer * player, double unk );
  int& m_nCommandsPredicted( );
  bool InPrediction( );
  CGlobalVarsBase* GetUnpredictedGlobals( );
};

```

`CSGO SDK/SDK/Classes/ISteamClient.hpp`:

```hpp
#pragma once
//#include "SDK.hpp"
//#include "sdk.hpp"

typedef __int8  int8;
typedef __int16 int16;
typedef __int32 int32;
typedef __int64 int64;

typedef unsigned __int8  uint8;
typedef unsigned __int16 uint16;
typedef unsigned __int32 uint32;
typedef unsigned __int64 uint64;

class ISteamGameServer;
class ISteamUtils;
class ISteamMatchmaking;
class ISteamContentServer;
class ISteamMatchmakingServers;
class ISteamUserStats;
class ISteamApps;
class ISteamNetworking;
class ISteamRemoteStorage;
class ISteamScreenshots;
class ISteamMusic;
class ISteamMusicRemote;
class ISteamGameServerStats;
class ISteamHTTP;
class ISteamUnifiedMessages;
class ISteamController;
class ISteamUGC;
class ISteamAppList;
class ISteamHTMLSurface;
class ISteamInventory;
class ISteamVideo;
typedef INT32 HSteamPipe;
typedef INT32 HSteamUser;
enum EPersonaState
{
	k_EPersonaStateOffline = 0,			// friend is not currently logged on
	k_EPersonaStateOnline = 1,			// friend is logged on
	k_EPersonaStateBusy = 2,			// user is on, but busy
	k_EPersonaStateAway = 3,			// auto-away feature
	k_EPersonaStateSnooze = 4,			// auto-away for a long time
	k_EPersonaStateLookingToTrade = 5,	// Online, trading
	k_EPersonaStateLookingToPlay = 6,	// Online, wanting to play
	k_EPersonaStateMax,
};
enum EFriendRelationship
{
	k_EFriendRelationshipNone = 0,
	k_EFriendRelationshipBlocked = 1,
	k_EFriendRelationshipRequestRecipient = 2,
	k_EFriendRelationshipFriend = 3,
	k_EFriendRelationshipRequestInitiator = 4,
	k_EFriendRelationshipIgnored = 5,
	k_EFriendRelationshipIgnoredFriend = 6,
	k_EFriendRelationshipSuggested = 7,

	// keep this updated
	k_EFriendRelationshipMax = 8,
};
enum EOverlayToStoreFlag
{
	k_EOverlayToStoreFlag_None = 0,
	k_EOverlayToStoreFlag_AddToCart = 1,
	k_EOverlayToStoreFlag_AddToCartAndShow = 2,
};
enum EChatEntryType
{
	k_EChatEntryTypeInvalid = 0,
	k_EChatEntryTypeChatMsg = 1,		// Normal text message from another user
	k_EChatEntryTypeTyping = 2,			// Another user is typing (not used in multi-user chat)
	k_EChatEntryTypeInviteGame = 3,		// Invite from other user into that users current game
	k_EChatEntryTypeEmote = 4,			// text emote message (deprecated, should be treated as ChatMsg)
	//k_EChatEntryTypeLobbyGameStart = 5,	// lobby game is starting (dead - listen for LobbyGameCreated_t callback instead)
	k_EChatEntryTypeLeftConversation = 6, // user has left the conversation ( closed chat window )
	// Above are previous FriendMsgType entries, now merged into more generic chat entry types
	k_EChatEntryTypeEntered = 7,		// user has entered the conversation (used in multi-user chat and group chat)
	k_EChatEntryTypeWasKicked = 8,		// user was kicked (data: 64-bit steamid of actor performing the kick)
	k_EChatEntryTypeWasBanned = 9,		// user was banned (data: 64-bit steamid of actor performing the ban)
	k_EChatEntryTypeDisconnected = 10,	// user disconnected
	k_EChatEntryTypeHistoricalChat = 11,	// a chat message from user's chat history or offilne message
	k_EChatEntryTypeReserved1 = 12,
	k_EChatEntryTypeReserved2 = 13,
	k_EChatEntryTypeLinkBlocked = 14, // a link was removed by the chat filter.
};
enum EFriendFlags
{
	k_EFriendFlagNone = 0x00,
	k_EFriendFlagBlocked = 0x01,
	k_EFriendFlagFriendshipRequested = 0x02,
	k_EFriendFlagImmediate = 0x04,			// "regular" friend
	k_EFriendFlagClanMember = 0x08,
	k_EFriendFlagOnGameServer = 0x10,
	// k_EFriendFlagHasPlayedWith	= 0x20,	// not currently used
	// k_EFriendFlagFriendOfFriend	= 0x40, // not currently used
	k_EFriendFlagRequestingFriendship = 0x80,
	k_EFriendFlagRequestingInfo = 0x100,
	k_EFriendFlagIgnored = 0x200,
	k_EFriendFlagIgnoredFriend = 0x400,
	k_EFriendFlagSuggested = 0x800,
	k_EFriendFlagAll = 0xFFFF,
};

class CGameID
{
public:

	CGameID()
	{
		m_gameID.m_nType = k_EGameIDTypeApp;
		m_gameID.m_nAppID = 0;
		m_gameID.m_nModID = 0;
	}

	explicit CGameID(uint64 ulGameID)
	{
		m_ulGameID = ulGameID;
	}
#ifdef INT64_DIFFERENT_FROM_INT64_T
	CGameID(uint64_t ulGameID)
	{
		m_ulGameID = (uint64)ulGameID;
	}
#endif

	explicit CGameID(int32 nAppID)
	{
		m_ulGameID = 0;
		m_gameID.m_nAppID = nAppID;
	}

	explicit CGameID(uint32 nAppID)
	{
		m_ulGameID = 0;
		m_gameID.m_nAppID = nAppID;
	}

	CGameID(uint32 nAppID, uint32 nModID)
	{
		m_ulGameID = 0;
		m_gameID.m_nAppID = nAppID;
		m_gameID.m_nModID = nModID;
		m_gameID.m_nType = k_EGameIDTypeGameMod;
	}

	// Hidden functions used only by Steam
	explicit CGameID(const char *pchGameID);
	const char *Render() const;					// render this Game ID to string
	static const char *Render(uint64 ulGameID);		// static method to render a uint64 representation of a Game ID to a string

	// must include checksum_crc.h first to get this functionality
#if defined( CHECKSUM_CRC_H )


#if defined( VSTFILEID_H )

	CGameID(VstFileID vstFileID)
	{
		m_ulGameID = 0;
		m_gameID.m_nAppID = k_uAppIdInvalid;
		m_gameID.m_nType = k_EGameIDTypeP2P;

		CRC32_t crc32;
		CRC32_Init(&crc32);
		const char *pchFileId = vstFileID.Render();
		CRC32_ProcessBuffer(&crc32, pchFileId, Q_strlen(pchFileId));
		CRC32_Final(&crc32);

		// set the high-bit on the mod-id 
		// reduces crc32 to 31bits, but lets us use the modID as a guaranteed unique
		// replacement for appID's
		m_gameID.m_nModID = crc32 | (0x80000000);
	}

#endif /* VSTFILEID_H */

#endif /* CHECKSUM_CRC_H */


	uint64 ToUint64() const
	{
		return m_ulGameID;
	}

	uint64 *GetUint64Ptr()
	{
		return &m_ulGameID;
	}

	void Set(uint64 ulGameID)
	{
		m_ulGameID = ulGameID;
	}

	bool IsMod() const
	{
		return (m_gameID.m_nType == k_EGameIDTypeGameMod);
	}

	bool IsShortcut() const
	{
		return (m_gameID.m_nType == k_EGameIDTypeShortcut);
	}

	bool IsP2PFile() const
	{
		return (m_gameID.m_nType == k_EGameIDTypeP2P);
	}

	bool IsSteamApp() const
	{
		return (m_gameID.m_nType == k_EGameIDTypeApp);
	}

	uint32 ModID() const
	{
		return m_gameID.m_nModID;
	}

	uint32 AppID() const
	{
		return m_gameID.m_nAppID;
	}

	bool operator == (const CGameID &rhs) const
	{
		return m_ulGameID == rhs.m_ulGameID;
	}

	bool operator != (const CGameID &rhs) const
	{
		return !(*this == rhs);
	}

	bool operator < (const CGameID &rhs) const
	{
		return (m_ulGameID < rhs.m_ulGameID);
	}

	bool IsValid() const
	{
		// each type has it's own invalid fixed point:
		switch (m_gameID.m_nType)
		{
		case k_EGameIDTypeApp:
			return m_gameID.m_nAppID != 0;

		case k_EGameIDTypeGameMod:
			return m_gameID.m_nAppID != 0 && m_gameID.m_nModID & 0x80000000;

		case k_EGameIDTypeShortcut:
			return (m_gameID.m_nModID & 0x80000000) != 0;

		case k_EGameIDTypeP2P:
			return m_gameID.m_nAppID == 0 && m_gameID.m_nModID & 0x80000000;

		default:
#if defined(Assert)
			Assert(false);
#endif
			return false;
		}

	}

	void Reset()
	{
		m_ulGameID = 0;
	}



private:

	enum EGameIDType
	{
		k_EGameIDTypeApp = 0,
		k_EGameIDTypeGameMod = 1,
		k_EGameIDTypeShortcut = 2,
		k_EGameIDTypeP2P = 3,
	};

	struct GameID_t
	{
#ifdef VALVE_BIG_ENDIAN
		unsigned int m_nModID : 32;
		unsigned int m_nType : 8;
		unsigned int m_nAppID : 24;
#else
		unsigned int m_nAppID : 24;
		unsigned int m_nType : 8;
		unsigned int m_nModID : 32;
#endif
	};

	union
	{
		uint64 m_ulGameID;
		GameID_t m_gameID;
	};
};

const unsigned int k_unSteamAccountIDMask = 0xFFFFFFFF;
const unsigned int k_unSteamAccountInstanceMask = 0x000FFFFF;
// we allow 3 simultaneous user account instances right now, 1= desktop, 2 = console, 4 = web, 0 = all
const unsigned int k_unSteamUserDesktopInstance = 1;
const unsigned int k_unSteamUserConsoleInstance = 2;
const unsigned int k_unSteamUserWebInstance = 4;

enum EChatSteamIDInstanceFlags
{
	k_EChatAccountInstanceMask = 0x00000FFF, // top 8 bits are flags

	k_EChatInstanceFlagClan = (k_unSteamAccountInstanceMask + 1) >> 1,	// top bit
	k_EChatInstanceFlagLobby = (k_unSteamAccountInstanceMask + 1) >> 2,	// next one down, etc
	k_EChatInstanceFlagMMSLobby = (k_unSteamAccountInstanceMask + 1) >> 3,	// next one down, etc

	// Max of 8 flags
};

enum EUniverse
{
	k_EUniverseInvalid = 0,
	k_EUniversePublic = 1,
	k_EUniverseBeta = 2,
	k_EUniverseInternal = 3,
	k_EUniverseDev = 4,
	//	k_EUniverseRC = 5, // Removed

	k_EUniverseMax
};

enum EAccountType
{
	k_EAccountTypeInvalid = 0,
	k_EAccountTypeIndividual = 1,		// single user account
	k_EAccountTypeMultiseat = 2,		// multiseat (e.g. cybercafe) account
	k_EAccountTypeGameServer = 3,		// game server account
	k_EAccountTypeAnonGameServer = 4,	// anonymous game server account
	k_EAccountTypePending = 5,			// pending
	k_EAccountTypeContentServer = 6,	// content server
	k_EAccountTypeClan = 7,
	k_EAccountTypeChat = 8,
	k_EAccountTypeConsoleUser = 9,		// Fake SteamID for local PSN account on PS3 or Live account on 360, etc.
	k_EAccountTypeAnonUser = 10,

	// Max of 16 items in this field
	k_EAccountTypeMax
};

class CSteamID
{
public:

	//-----------------------------------------------------------------------------
	// Purpose: Constructor
	//-----------------------------------------------------------------------------
	CSteamID()
	{
		m_steamid.m_comp.m_unAccountID = 0;
		m_steamid.m_comp.m_EAccountType = k_EAccountTypeInvalid;
		m_steamid.m_comp.m_EUniverse = k_EUniverseInvalid;
		m_steamid.m_comp.m_unAccountInstance = 0;
	}


	//-----------------------------------------------------------------------------
	// Purpose: Constructor
	// Input  : unAccountID -	32-bit account ID
	//			eUniverse -		Universe this account belongs to
	//			eAccountType -	Type of account
	//-----------------------------------------------------------------------------



	//-----------------------------------------------------------------------------
	// Purpose: Constructor
	// Input  : ulSteamID -		64-bit representation of a Steam ID
	// Note:	Will not accept a uint32_t or int32 as input, as that is a probable mistake.
	//			See the stubbed out overloads in the private: section for more info.
	//-----------------------------------------------------------------------------
	CSteamID(uint64_t ulSteamID)
	{
		SetFromuint64_t(ulSteamID);
	}


	//-----------------------------------------------------------------------------
	// Purpose: Sets parameters for steam ID
	// Input  : unAccountID -	32-bit account ID
	//			eUniverse -		Universe this account belongs to
	//			eAccountType -	Type of account
	//-----------------------------------------------------------------------------
	void Set(uint32_t unAccountID, EUniverse eUniverse, EAccountType eAccountType)
	{
		m_steamid.m_comp.m_unAccountID = unAccountID;
		m_steamid.m_comp.m_EUniverse = eUniverse;
		m_steamid.m_comp.m_EAccountType = eAccountType;

		if (eAccountType == k_EAccountTypeClan)
		{
			m_steamid.m_comp.m_unAccountInstance = 0;
		}
		else
		{
			// by default we pick the desktop instance
			m_steamid.m_comp.m_unAccountInstance = k_unSteamUserDesktopInstance;
		}
	}


	//-----------------------------------------------------------------------------
	// Purpose: Sets parameters for steam ID
	// Input  : unAccountID -	32-bit account ID
	//			eUniverse -		Universe this account belongs to
	//			eAccountType -	Type of account
	//-----------------------------------------------------------------------------
	void InstancedSet(uint32_t unAccountID, uint32_t unInstance, EUniverse eUniverse, EAccountType eAccountType)
	{
		m_steamid.m_comp.m_unAccountID = unAccountID;
		m_steamid.m_comp.m_EUniverse = eUniverse;
		m_steamid.m_comp.m_EAccountType = eAccountType;
		m_steamid.m_comp.m_unAccountInstance = unInstance;
	}


	//-----------------------------------------------------------------------------
	// Purpose: Initializes a steam ID from its 52 bit parts and universe/type
	// Input  : ulIdentifier - 52 bits of goodness
	//-----------------------------------------------------------------------------
	void FullSet(uint64_t ulIdentifier, EUniverse eUniverse, EAccountType eAccountType)
	{
		m_steamid.m_comp.m_unAccountID = (ulIdentifier & k_unSteamAccountIDMask);						// account ID is low 32 bits
		m_steamid.m_comp.m_unAccountInstance = ((ulIdentifier >> 32) & k_unSteamAccountInstanceMask);			// account instance is next 20 bits
		m_steamid.m_comp.m_EUniverse = eUniverse;
		m_steamid.m_comp.m_EAccountType = eAccountType;
	}


	//-----------------------------------------------------------------------------
	// Purpose: Initializes a steam ID from its 64-bit representation
	// Input  : ulSteamID -		64-bit representation of a Steam ID
	//-----------------------------------------------------------------------------
	void SetFromuint64_t(uint64_t ulSteamID)
	{
		m_steamid.m_unAll64Bits = ulSteamID;
	}



	//-----------------------------------------------------------------------------
	// Purpose: Converts steam ID to its 64-bit representation
	// Output : 64-bit representation of a Steam ID
	//-----------------------------------------------------------------------------
	uint64_t ConvertTouint64_t() const
	{
		return m_steamid.m_unAll64Bits;
	}


	//-----------------------------------------------------------------------------
	// Purpose: Converts the static parts of a steam ID to a 64-bit representation.
	//			For multiseat accounts, all instances of that account will have the
	//			same static account key, so they can be grouped together by the static
	//			account key.
	// Output : 64-bit static account key
	//-----------------------------------------------------------------------------
	uint64_t GetStaticAccountKey() const
	{
		// note we do NOT include the account instance (which is a dynamic property) in the static account key
		return (uint64_t)((((uint64_t)m_steamid.m_comp.m_EUniverse) << 56) + ((uint64_t)m_steamid.m_comp.m_EAccountType << 52) + m_steamid.m_comp.m_unAccountID);
	}


	//-----------------------------------------------------------------------------
	// Purpose: create an anonymous game server login to be filled in by the AM
	//-----------------------------------------------------------------------------
	void CreateBlankAnonLogon(EUniverse eUniverse)
	{
		m_steamid.m_comp.m_unAccountID = 0;
		m_steamid.m_comp.m_EAccountType = k_EAccountTypeAnonGameServer;
		m_steamid.m_comp.m_EUniverse = eUniverse;
		m_steamid.m_comp.m_unAccountInstance = 0;
	}


	//-----------------------------------------------------------------------------
	// Purpose: create an anonymous game server login to be filled in by the AM
	//-----------------------------------------------------------------------------
	void CreateBlankAnonUserLogon(EUniverse eUniverse)
	{
		m_steamid.m_comp.m_unAccountID = 0;
		m_steamid.m_comp.m_EAccountType = k_EAccountTypeAnonUser;
		m_steamid.m_comp.m_EUniverse = eUniverse;
		m_steamid.m_comp.m_unAccountInstance = 0;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Is this an anonymous game server login that will be filled in?
	//-----------------------------------------------------------------------------
	bool BBlankAnonAccount() const
	{
		return m_steamid.m_comp.m_unAccountID == 0 && BAnonAccount() && m_steamid.m_comp.m_unAccountInstance == 0;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Is this a game server account id?
	//-----------------------------------------------------------------------------
	bool BGameServerAccount() const
	{
		return m_steamid.m_comp.m_EAccountType == k_EAccountTypeGameServer || m_steamid.m_comp.m_EAccountType == k_EAccountTypeAnonGameServer;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Is this a content server account id?
	//-----------------------------------------------------------------------------
	bool BContentServerAccount() const
	{
		return m_steamid.m_comp.m_EAccountType == k_EAccountTypeContentServer;
	}


	//-----------------------------------------------------------------------------
	// Purpose: Is this a clan account id?
	//-----------------------------------------------------------------------------
	bool BClanAccount() const
	{
		return m_steamid.m_comp.m_EAccountType == k_EAccountTypeClan;
	}


	//-----------------------------------------------------------------------------
	// Purpose: Is this a chat account id?
	//-----------------------------------------------------------------------------
	bool BChatAccount() const
	{
		return m_steamid.m_comp.m_EAccountType == k_EAccountTypeChat;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Is this a chat account id?
	//-----------------------------------------------------------------------------
	bool IsLobby() const
	{
		return (m_steamid.m_comp.m_EAccountType == k_EAccountTypeChat)
			&& (m_steamid.m_comp.m_unAccountInstance & k_EChatInstanceFlagLobby);
	}


	//-----------------------------------------------------------------------------
	// Purpose: Is this an individual user account id?
	//-----------------------------------------------------------------------------
	bool BIndividualAccount() const
	{
		return m_steamid.m_comp.m_EAccountType == k_EAccountTypeIndividual || m_steamid.m_comp.m_EAccountType == k_EAccountTypeConsoleUser;
	}


	//-----------------------------------------------------------------------------
	// Purpose: Is this an anonymous account?
	//-----------------------------------------------------------------------------
	bool BAnonAccount() const
	{
		return m_steamid.m_comp.m_EAccountType == k_EAccountTypeAnonUser || m_steamid.m_comp.m_EAccountType == k_EAccountTypeAnonGameServer;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Is this an anonymous user account? ( used to create an account or reset a password )
	//-----------------------------------------------------------------------------
	bool BAnonUserAccount() const
	{
		return m_steamid.m_comp.m_EAccountType == k_EAccountTypeAnonUser;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Is this a faked up Steam ID for a PSN friend account?
	//-----------------------------------------------------------------------------
	bool BConsoleUserAccount() const
	{
		return m_steamid.m_comp.m_EAccountType == k_EAccountTypeConsoleUser;
	}


	// simple accessors
	void SetAccountID(uint32_t unAccountID) { m_steamid.m_comp.m_unAccountID = unAccountID; }
	void SetAccountInstance(uint32_t unInstance) { m_steamid.m_comp.m_unAccountInstance = unInstance; }
	void ClearIndividualInstance() { if (BIndividualAccount()) m_steamid.m_comp.m_unAccountInstance = 0; }
	bool HasNoIndividualInstance() const { return BIndividualAccount() && (m_steamid.m_comp.m_unAccountInstance == 0); }
	uint32_t GetAccountID() const { return m_steamid.m_comp.m_unAccountID; }
	uint32_t GetUnAccountInstance() const { return m_steamid.m_comp.m_unAccountInstance; }
	EAccountType GetEAccountType() const { return (EAccountType)m_steamid.m_comp.m_EAccountType; }
	EUniverse GetEUniverse() const { return m_steamid.m_comp.m_EUniverse; }
	void SetEUniverse(EUniverse eUniverse) { m_steamid.m_comp.m_EUniverse = eUniverse; }
	bool IsValid() const;

#ifdef _MSC_VER
#pragma warning(push) 
#pragma warning(disable: 4996) 
#endif

	const char * Render() const				// renders this steam ID to string
	{
		const int k_cBufLen = 30;
		const int k_cBufs = 4;
		char* pchBuf;

		static char rgchBuf[k_cBufs][k_cBufLen];
		static int nBuf = 0;

		pchBuf = rgchBuf[nBuf++];
		nBuf %= k_cBufs;

		switch (m_steamid.m_comp.m_EAccountType)
		{
		case k_EAccountTypeInvalid:
		case k_EAccountTypeIndividual:
			sprintf(pchBuf, "STEAM_0:%u:%u", (m_steamid.m_comp.m_unAccountID % 2) ? 1 : 0, (uint32_t)m_steamid.m_comp.m_unAccountID);
			break;
		default:
			sprintf(pchBuf, "%llu", ConvertTouint64_t());
		}
		return pchBuf;
	}
	static const char * Render(uint64_t ulSteamID)	// static method to render a uint64_t representation of a steam ID to a string
	{
		return CSteamID(ulSteamID).Render();
	}

	const char *SteamRender() const // renders this steam ID to string using the new rendering style
	{
		const int k_cBufLen = 37;
		const int k_cBufs = 4;
		char* pchBuf;

		static char rgchBuf[k_cBufs][k_cBufLen];
		static int nBuf = 0;

		pchBuf = rgchBuf[nBuf++];
		nBuf %= k_cBufs;

		switch (m_steamid.m_comp.m_EAccountType)
		{
		case k_EAccountTypeAnonGameServer:
			sprintf(pchBuf, "[A:%u:%u:%u]", m_steamid.m_comp.m_EUniverse, m_steamid.m_comp.m_unAccountID, m_steamid.m_comp.m_unAccountInstance);
			break;
		case k_EAccountTypeGameServer:
			sprintf(pchBuf, "[G:%u:%u]", m_steamid.m_comp.m_EUniverse, m_steamid.m_comp.m_unAccountID);
			break;
		case k_EAccountTypeMultiseat:
			sprintf(pchBuf, "[M:%u:%u:%u]", m_steamid.m_comp.m_EUniverse, m_steamid.m_comp.m_unAccountID, m_steamid.m_comp.m_unAccountInstance);
			break;
		case k_EAccountTypePending:
			sprintf(pchBuf, "[P:%u:%u]", m_steamid.m_comp.m_EUniverse, m_steamid.m_comp.m_unAccountID);
			break;
		case k_EAccountTypeContentServer:
			sprintf(pchBuf, "[C:%u:%u]", m_steamid.m_comp.m_EUniverse, m_steamid.m_comp.m_unAccountID);
			break;
		case k_EAccountTypeClan:
			sprintf(pchBuf, "[g:%u:%u]", m_steamid.m_comp.m_EUniverse, m_steamid.m_comp.m_unAccountID);
			break;
		case k_EAccountTypeChat:
			switch (m_steamid.m_comp.m_unAccountInstance & ~k_EChatAccountInstanceMask)
			{
			case k_EChatInstanceFlagClan:
				sprintf(pchBuf, "[c:%u:%u]", m_steamid.m_comp.m_EUniverse, m_steamid.m_comp.m_unAccountID);
				break;
			case k_EChatInstanceFlagLobby:
				sprintf(pchBuf, "[L:%u:%u]", m_steamid.m_comp.m_EUniverse, m_steamid.m_comp.m_unAccountID);
				break;
			default:
				sprintf(pchBuf, "[T:%u:%u]", m_steamid.m_comp.m_EUniverse, m_steamid.m_comp.m_unAccountID);
				break;
			}
			break;
		case k_EAccountTypeInvalid:
			sprintf(pchBuf, "[I:%u:%u]", m_steamid.m_comp.m_EUniverse, m_steamid.m_comp.m_unAccountID);
			break;
		case k_EAccountTypeIndividual:
			sprintf(pchBuf, "[U:%u:%u]", m_steamid.m_comp.m_EUniverse, m_steamid.m_comp.m_unAccountID);
			break;
		default:
			sprintf(pchBuf, "[i:%u:%u]", m_steamid.m_comp.m_EUniverse, m_steamid.m_comp.m_unAccountID);
			break;
		}

		return pchBuf;
	}

	static const char *SteamRender(uint64_t ulSteamID)	// static method to render a uint64_t representation of a steam ID to a string
	{
		return CSteamID(ulSteamID).SteamRender();
	}

#ifdef _MSC_VER
#pragma warning(pop) 
#endif

	inline bool operator==(const CSteamID &val) const { return m_steamid.m_unAll64Bits == val.m_steamid.m_unAll64Bits; }
	inline bool operator!=(const CSteamID &val) const { return !operator==(val); }
	inline bool operator<(const CSteamID &val) const { return m_steamid.m_unAll64Bits < val.m_steamid.m_unAll64Bits; }
	inline bool operator>(const CSteamID &val) const { return m_steamid.m_unAll64Bits > val.m_steamid.m_unAll64Bits; }

private:
	// These are defined here to prevent accidental implicit conversion of a u32AccountID to a CSteamID.
	// If you get a compiler error about an ambiguous constructor/function then it may be because you're
	// passing a 32-bit int to a function that takes a CSteamID. You should explicitly create the SteamID
	// using the correct Universe and account Type/Instance values.
	CSteamID(uint32_t);
	CSteamID(int32_t);

	// 64 bits total
	union SteamID_t
	{
		struct SteamIDComponent_t
		{

			uint32_t				m_unAccountID : 32;			// unique account identifier
			unsigned int		m_unAccountInstance : 20;	// dynamic instance ID
			unsigned int		m_EAccountType : 4;			// type of account - can't show as EAccountType, due to signed / unsigned difference
			EUniverse			m_EUniverse : 8;	// universe this account belongs to
		} m_comp;

		uint64_t m_unAll64Bits;
	} m_steamid;
};
typedef uint32_t AppId_t;
typedef uint64_t SteamAPICall_t;
struct FriendGameInfo_t
{
	CGameID m_gameID;
	uint32 m_unGameIP;
	uint16 m_usGamePort;
	uint16 m_usQueryPort;
	CSteamID m_steamIDLobby;
};
enum ELobbyType
{
	k_ELobbyTypePrivate = 0,		// only way to join the lobby is to invite to someone else
	k_ELobbyTypeFriendsOnly = 1,	// shows for friends or invitees, but not in lobby list
	k_ELobbyTypePublic = 2,			// visible for friends and in lobby list
	k_ELobbyTypeInvisible = 3,		// returned by search, but not visible to other friends 
									//    useful if you want a user in two lobbies, for example matching groups together
									//	  a user can be in only one regular lobby, and up to two invisible lobbies
};

enum ELobbyComparison
{
	k_ELobbyComparisonEqualToOrLessThan = -2,
	k_ELobbyComparisonLessThan = -1,
	k_ELobbyComparisonEqual = 0,
	k_ELobbyComparisonGreaterThan = 1,
	k_ELobbyComparisonEqualToOrGreaterThan = 2,
	k_ELobbyComparisonNotEqual = 3,
};

enum ELobbyDistanceFilter
{
	k_ELobbyDistanceFilterClose,		// only lobbies in the same immediate region will be returned
	k_ELobbyDistanceFilterDefault,		// only lobbies in the same region or near by regions
	k_ELobbyDistanceFilterFar,			// for games that don't have many latency requirements, will return lobbies about half-way around the globe
	k_ELobbyDistanceFilterWorldwide,	// no filtering, will match lobbies as far as India to NY (not recommended, expect multiple seconds of latency between the clients)
};

class ISteamMatchmaking
{
public:
	// game server favorites storage
	// saves basic details about a multiplayer game server locally

	// returns the number of favorites servers the user has stored
	virtual int GetFavoriteGameCount() = 0;
	
	// returns the details of the game server
	// iGame is of range [0,GetFavoriteGameCount())
	// *pnIP, *pnConnPort are filled in the with IP:port of the game server
	// *punFlags specify whether the game server was stored as an explicit favorite or in the history of connections
	// *pRTime32LastPlayedOnServer is filled in the with the Unix time the favorite was added
	virtual bool GetFavoriteGame( int iGame, AppId_t *pnAppID, uint32 *pnIP, uint16 *pnConnPort, uint16 *pnQueryPort, uint32 *punFlags, uint32 *pRTime32LastPlayedOnServer ) = 0;

	// adds the game server to the local list; updates the time played of the server if it already exists in the list
	virtual int AddFavoriteGame( AppId_t nAppID, uint32 nIP, uint16 nConnPort, uint16 nQueryPort, uint32 unFlags, uint32 rTime32LastPlayedOnServer ) = 0;
	
	// removes the game server from the local storage; returns true if one was removed
	virtual bool RemoveFavoriteGame( AppId_t nAppID, uint32 nIP, uint16 nConnPort, uint16 nQueryPort, uint32 unFlags ) = 0;

	///////
	// Game lobby functions

	// Get a list of relevant lobbies
	// this is an asynchronous request
	// results will be returned by LobbyMatchList_t callback & call result, with the number of lobbies found
	// this will never return lobbies that are full
	// to add more filter, the filter calls below need to be call before each and every RequestLobbyList() call
	// use the CCallResult<> object in steam_api.h to match the SteamAPICall_t call result to a function in an object, e.g.
	/*
		class CMyLobbyListManager
		{
			CCallResult<CMyLobbyListManager, LobbyMatchList_t> m_CallResultLobbyMatchList;
			void FindLobbies()
			{
				// SteamMatchmaking()->AddRequestLobbyListFilter*() functions would be called here, before RequestLobbyList()
				SteamAPICall_t hSteamAPICall = SteamMatchmaking()->RequestLobbyList();
				m_CallResultLobbyMatchList.Set( hSteamAPICall, this, &CMyLobbyListManager::OnLobbyMatchList );
			}
			void OnLobbyMatchList( LobbyMatchList_t *pLobbyMatchList, bool bIOFailure )
			{
				// lobby list has be retrieved from Steam back-end, use results
			}
		}
	*/
	// 
	virtual SteamAPICall_t RequestLobbyList() = 0;
	// filters for lobbies
	// this needs to be called before RequestLobbyList() to take effect
	// these are cleared on each call to RequestLobbyList()
	virtual void AddRequestLobbyListStringFilter( const char *pchKeyToMatch, const char *pchValueToMatch, ELobbyComparison eComparisonType ) = 0;
	// numerical comparison
	virtual void AddRequestLobbyListNumericalFilter( const char *pchKeyToMatch, int nValueToMatch, ELobbyComparison eComparisonType ) = 0;
	// returns results closest to the specified value. Multiple near filters can be added, with early filters taking precedence
	virtual void AddRequestLobbyListNearValueFilter( const char *pchKeyToMatch, int nValueToBeCloseTo ) = 0;
	// returns only lobbies with the specified number of slots available
	virtual void AddRequestLobbyListFilterSlotsAvailable( int nSlotsAvailable ) = 0;
	// sets the distance for which we should search for lobbies (based on users IP address to location map on the Steam backed)
	virtual void AddRequestLobbyListDistanceFilter( ELobbyDistanceFilter eLobbyDistanceFilter ) = 0;
	// sets how many results to return, the lower the count the faster it is to download the lobby results & details to the client
	virtual void AddRequestLobbyListResultCountFilter( int cMaxResults ) = 0;

	virtual void AddRequestLobbyListCompatibleMembersFilter( CSteamID steamIDLobby ) = 0;

	// returns the CSteamID of a lobby, as retrieved by a RequestLobbyList call
	// should only be called after a LobbyMatchList_t callback is received
	// iLobby is of the range [0, LobbyMatchList_t::m_nLobbiesMatching)
	// the returned CSteamID::IsValid() will be false if iLobby is out of range
	virtual CSteamID GetLobbyByIndex( int iLobby ) = 0;

	// Create a lobby on the Steam servers.
	// If private, then the lobby will not be returned by any RequestLobbyList() call; the CSteamID
	// of the lobby will need to be communicated via game channels or via InviteUserToLobby()
	// this is an asynchronous request
	// results will be returned by LobbyCreated_t callback and call result; lobby is joined & ready to use at this point
	// a LobbyEnter_t callback will also be received (since the local user is joining their own lobby)
	virtual SteamAPICall_t CreateLobby( ELobbyType eLobbyType, int cMaxMembers ) = 0;

	// Joins an existing lobby
	// this is an asynchronous request
	// results will be returned by LobbyEnter_t callback & call result, check m_EChatRoomEnterResponse to see if was successful
	// lobby metadata is available to use immediately on this call completing
	virtual SteamAPICall_t JoinLobby( CSteamID steamIDLobby ) = 0;

	// Leave a lobby; this will take effect immediately on the client side
	// other users in the lobby will be notified by a LobbyChatUpdate_t callback
	virtual void LeaveLobby( CSteamID steamIDLobby ) = 0;

	// Invite another user to the lobby
	// the target user will receive a LobbyInvite_t callback
	// will return true if the invite is successfully sent, whether or not the target responds
	// returns false if the local user is not connected to the Steam servers
	// if the other user clicks the join link, a GameLobbyJoinRequested_t will be posted if the user is in-game,
	// or if the game isn't running yet the game will be launched with the parameter +connect_lobby <64-bit lobby id>
	virtual bool InviteUserToLobby( CSteamID steamIDLobby, CSteamID steamIDInvitee ) = 0;

	// Lobby iteration, for viewing details of users in a lobby
	// only accessible if the lobby user is a member of the specified lobby
	// persona information for other lobby members (name, avatar, etc.) will be asynchronously received
	// and accessible via ISteamFriends interface
	
	// returns the number of users in the specified lobby
	virtual int GetNumLobbyMembers( CSteamID steamIDLobby ) = 0;
	// returns the CSteamID of a user in the lobby
	// iMember is of range [0,GetNumLobbyMembers())
	// note that the current user must be in a lobby to retrieve CSteamIDs of other users in that lobby
	virtual CSteamID GetLobbyMemberByIndex( CSteamID steamIDLobby, int iMember ) = 0;

	// Get data associated with this lobby
	// takes a simple key, and returns the string associated with it
	// "" will be returned if no value is set, or if steamIDLobby is invalid
	virtual const char *GetLobbyData( CSteamID steamIDLobby, const char *pchKey ) = 0;
	// Sets a key/value pair in the lobby metadata
	// each user in the lobby will be broadcast this new value, and any new users joining will receive any existing data
	// this can be used to set lobby names, map, etc.
	// to reset a key, just set it to ""
	// other users in the lobby will receive notification of the lobby data change via a LobbyDataUpdate_t callback
	virtual bool SetLobbyData( CSteamID steamIDLobby, const char *pchKey, const char *pchValue ) = 0;

	// returns the number of metadata keys set on the specified lobby
	virtual int GetLobbyDataCount( CSteamID steamIDLobby ) = 0;

	// returns a lobby metadata key/values pair by index, of range [0, GetLobbyDataCount())
	virtual bool GetLobbyDataByIndex( CSteamID steamIDLobby, int iLobbyData, char *pchKey, int cchKeyBufferSize, char *pchValue, int cchValueBufferSize ) = 0;

	// removes a metadata key from the lobby
	virtual bool DeleteLobbyData( CSteamID steamIDLobby, const char *pchKey ) = 0;

	// Gets per-user metadata for someone in this lobby
	virtual const char *GetLobbyMemberData( CSteamID steamIDLobby, CSteamID steamIDUser, const char *pchKey ) = 0;
	// Sets per-user metadata (for the local user implicitly)
	virtual void SetLobbyMemberData( CSteamID steamIDLobby, const char *pchKey, const char *pchValue ) = 0;
	
	// Broadcasts a chat message to the all the users in the lobby
	// users in the lobby (including the local user) will receive a LobbyChatMsg_t callback
	// returns true if the message is successfully sent
	// pvMsgBody can be binary or text data, up to 4k
	// if pvMsgBody is text, cubMsgBody should be strlen( text ) + 1, to include the null terminator
	virtual bool SendLobbyChatMsg( CSteamID steamIDLobby, const void *pvMsgBody, int cubMsgBody ) = 0;
	// Get a chat message as specified in a LobbyChatMsg_t callback
	// iChatID is the LobbyChatMsg_t::m_iChatID value in the callback
	// *pSteamIDUser is filled in with the CSteamID of the member
	// *pvData is filled in with the message itself
	// return value is the number of bytes written into the buffer
	virtual int GetLobbyChatEntry( CSteamID steamIDLobby, int iChatID, CSteamID *pSteamIDUser, void *pvData, int cubData, EChatEntryType *peChatEntryType ) = 0;

	// Refreshes metadata for a lobby you're not necessarily in right now
	// you never do this for lobbies you're a member of, only if your
	// this will send down all the metadata associated with a lobby
	// this is an asynchronous call
	// returns false if the local user is not connected to the Steam servers
	// results will be returned by a LobbyDataUpdate_t callback
	// if the specified lobby doesn't exist, LobbyDataUpdate_t::m_bSuccess will be set to false
	virtual bool RequestLobbyData( CSteamID steamIDLobby ) = 0;
	
	// sets the game server associated with the lobby
	// usually at this point, the users will join the specified game server
	// either the IP/Port or the steamID of the game server has to be valid, depending on how you want the clients to be able to connect
	virtual void SetLobbyGameServer( CSteamID steamIDLobby, uint32 unGameServerIP, uint16 unGameServerPort, CSteamID steamIDGameServer ) = 0;
	// returns the details of a game server set in a lobby - returns false if there is no game server set, or that lobby doesn't exist
	virtual bool GetLobbyGameServer( CSteamID steamIDLobby, uint32 *punGameServerIP, uint16 *punGameServerPort, CSteamID *psteamIDGameServer ) = 0;

	// set the limit on the # of users who can join the lobby
	virtual bool SetLobbyMemberLimit( CSteamID steamIDLobby, int cMaxMembers ) = 0;
	// returns the current limit on the # of users who can join the lobby; returns 0 if no limit is defined
	virtual int GetLobbyMemberLimit( CSteamID steamIDLobby ) = 0;

	// updates which type of lobby it is
	// only lobbies that are k_ELobbyTypePublic or k_ELobbyTypeInvisible, and are set to joinable, will be returned by RequestLobbyList() calls
	virtual bool SetLobbyType( CSteamID steamIDLobby, ELobbyType eLobbyType ) = 0;

	// sets whether or not a lobby is joinable - defaults to true for a new lobby
	// if set to false, no user can join, even if they are a friend or have been invited
	virtual bool SetLobbyJoinable( CSteamID steamIDLobby, bool bLobbyJoinable ) = 0;

	// returns the current lobby owner
	// you must be a member of the lobby to access this
	// there always one lobby owner - if the current owner leaves, another user will become the owner
	// it is possible (bur rare) to join a lobby just as the owner is leaving, thus entering a lobby with self as the owner
	virtual CSteamID GetLobbyOwner( CSteamID steamIDLobby ) = 0;

	// changes who the lobby owner is
	// you must be the lobby owner for this to succeed, and steamIDNewOwner must be in the lobby
	// after completion, the local user will no longer be the owner
	virtual bool SetLobbyOwner( CSteamID steamIDLobby, CSteamID steamIDNewOwner ) = 0;

	// link two lobbies for the purposes of checking player compatibility
	// you must be the lobby owner of both lobbies
	virtual bool SetLinkedLobby( CSteamID steamIDLobby, CSteamID steamIDLobbyDependent ) = 0;

#ifdef _PS3
	// changes who the lobby owner is
	// you must be the lobby owner for this to succeed, and steamIDNewOwner must be in the lobby
	// after completion, the local user will no longer be the owner
	virtual void CheckForPSNGameBootInvite( unsigned int iGameBootAttributes  ) = 0;
#endif
};

class ISteamFriends
{
public:
	// returns the local players name - guaranteed to not be NULL.
	// this is the same name as on the users community profile page
	// this is stored in UTF-8 format
	// like all the other interface functions that return a char *, it's important that this pointer is not saved
	// off; it will eventually be free'd or re-allocated
	virtual const char *GetPersonaName() = 0;
	virtual SteamAPICall_t SetPersonaName(const char *pchPersonaName) = 0;

	// gets the status of the current user
	virtual EPersonaState GetPersonaState() = 0;

	// friend iteration
	// takes a set of k_EFriendFlags, and returns the number of users the client knows about who meet that criteria
	// then GetFriendByIndex() can then be used to return the id's of each of those users
	virtual int GetFriendCount(int iFriendFlags) = 0;

	// returns the steamID of a user
	// iFriend is a index of range [0, GetFriendCount())
	// iFriendsFlags must be the same value as used in GetFriendCount()
	// the returned CSteamID can then be used by all the functions below to access details about the user
	virtual CSteamID GetFriendByIndex(int iFriend, int iFriendFlags) = 0;

	// returns a relationship to a user
	virtual EFriendRelationship GetFriendRelationship(CSteamID steamIDFriend) = 0;

	// returns the current status of the specified user
	// this will only be known by the local user if steamIDFriend is in their friends list; on the same game server; in a chat room or lobby; or in a small group with the local user
	virtual EPersonaState GetFriendPersonaState(CSteamID steamIDFriend) = 0;

	// returns the name another user - guaranteed to not be NULL.
	// same rules as GetFriendPersonaState() apply as to whether or not the user knowns the name of the other user
	// note that on first joining a lobby, chat room or game server the local user will not known the name of the other users automatically; that information will arrive asyncronously
	// 
	virtual const char *GetFriendPersonaName(CSteamID steamIDFriend) = 0;

	// returns true if the friend is actually in a game, and fills in pFriendGameInfo with an extra details 
	virtual bool GetFriendGamePlayed(CSteamID steamIDFriend, FriendGameInfo_t *pFriendGameInfo) = 0;
	// accesses old friends names - returns an empty string when their are no more items in the history
	virtual const char *GetFriendPersonaNameHistory(CSteamID steamIDFriend, int iPersonaName) = 0;

	// Returns nickname the current user has set for the specified player. Returns NULL if the no nickname has been set for that player.
	virtual const char *GetPlayerNickname(CSteamID steamIDPlayer) = 0;

	// returns true if the specified user meets any of the criteria specified in iFriendFlags
	// iFriendFlags can be the union (binary or, |) of one or more k_EFriendFlags values
	virtual bool HasFriend(CSteamID steamIDFriend, int iFriendFlags) = 0;

	// clan (group) iteration and access functions
	virtual int GetClanCount() = 0;
	virtual CSteamID GetClanByIndex(int iClan) = 0;
	virtual const char *GetClanName(CSteamID steamIDClan) = 0;
	virtual const char *GetClanTag(CSteamID steamIDClan) = 0;
	// returns the most recent information we have about what's happening in a clan
	virtual bool GetClanActivityCounts(CSteamID steamIDClan, int *pnOnline, int *pnInGame, int *pnChatting) = 0;
	// for clans a user is a member of, they will have reasonably up-to-date information, but for others you'll have to download the info to have the latest
	virtual SteamAPICall_t DownloadClanActivityCounts(CSteamID *psteamIDClans, int cClansToRequest) = 0;

	// iterators for getting users in a chat room, lobby, game server or clan
	// note that large clans that cannot be iterated by the local user
	// note that the current user must be in a lobby to retrieve CSteamIDs of other users in that lobby
	// steamIDSource can be the steamID of a group, game server, lobby or chat room
	virtual int GetFriendCountFromSource(CSteamID steamIDSource) = 0;
	virtual CSteamID GetFriendFromSourceByIndex(CSteamID steamIDSource, int iFriend) = 0;

	// returns true if the local user can see that steamIDUser is a member or in steamIDSource
	virtual bool IsUserInSource(CSteamID steamIDUser, CSteamID steamIDSource) = 0;

	// User is in a game pressing the talk button (will suppress the microphone for all voice comms from the Steam friends UI)
	virtual void SetInGameVoiceSpeaking(CSteamID steamIDUser, bool bSpeaking) = 0;

	// activates the game overlay, with an optional dialog to open 
	// valid options are "Friends", "Community", "Players", "Settings", "OfficialGameGroup", "Stats", "Achievements"
	virtual void ActivateGameOverlay(const char *pchDialog) = 0;

	// activates game overlay to a specific place
	// valid options are
	//		"steamid" - opens the overlay web browser to the specified user or groups profile
	//		"chat" - opens a chat window to the specified user, or joins the group chat 
	//		"jointrade" - opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API
	//		"stats" - opens the overlay web browser to the specified user's stats
	//		"achievements" - opens the overlay web browser to the specified user's achievements
	//		"friendadd" - opens the overlay in minimal mode prompting the user to add the target user as a friend
	//		"friendremove" - opens the overlay in minimal mode prompting the user to remove the target friend
	//		"friendrequestaccept" - opens the overlay in minimal mode prompting the user to accept an incoming friend invite
	//		"friendrequestignore" - opens the overlay in minimal mode prompting the user to ignore an incoming friend invite
	virtual void ActivateGameOverlayToUser(const char *pchDialog, CSteamID steamID) = 0;

	// activates game overlay web browser directly to the specified URL
	// full address with protocol type is required, e.g. http://www.steamgames.com/
	virtual void ActivateGameOverlayToWebPage(const char *pchURL) = 0;

	// activates game overlay to store page for app
	virtual void ActivateGameOverlayToStore(AppId_t nAppID, EOverlayToStoreFlag eFlag) = 0;

	// Mark a target user as 'played with'. This is a client-side only feature that requires that the calling user is 
	// in game 
	virtual void SetPlayedWith(CSteamID steamIDUserPlayedWith) = 0;

	// activates game overlay to open the invite dialog. Invitations will be sent for the provided lobby.
	virtual void ActivateGameOverlayInviteDialog(CSteamID steamIDLobby) = 0;

	// gets the small (32x32) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set
	virtual int GetSmallFriendAvatar(CSteamID steamIDFriend) = 0;

	// gets the medium (64x64) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set
	virtual int GetMediumFriendAvatar(CSteamID steamIDFriend) = 0;

	// gets the large (184x184) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set
	// returns -1 if this image has yet to be loaded, in this case wait for a AvatarImageLoaded_t callback and then call this again
	virtual int GetLargeFriendAvatar(CSteamID steamIDFriend) = 0;

	// requests information about a user - persona name & avatar
	// if bRequireNameOnly is set, then the avatar of a user isn't downloaded 
	// - it's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them
	// if returns true, it means that data is being requested, and a PersonaStateChanged_t callback will be posted when it's retrieved
	// if returns false, it means that we already have all the details about that user, and functions can be called immediately
	virtual bool RequestUserInformation(CSteamID steamIDUser, bool bRequireNameOnly) = 0;

	// requests information about a clan officer list
	// when complete, data is returned in ClanOfficerListResponse_t call result
	// this makes available the calls below
	// you can only ask about clans that a user is a member of
	// note that this won't download avatars automatically; if you get an officer,
	// and no avatar image is available, call RequestUserInformation( steamID, false ) to download the avatar
	virtual SteamAPICall_t RequestClanOfficerList(CSteamID steamIDClan) = 0;

	// iteration of clan officers - can only be done when a RequestClanOfficerList() call has completed

	// returns the steamID of the clan owner
	virtual CSteamID GetClanOwner(CSteamID steamIDClan) = 0;
	// returns the number of officers in a clan (including the owner)
	virtual int GetClanOfficerCount(CSteamID steamIDClan) = 0;
	// returns the steamID of a clan officer, by index, of range [0,GetClanOfficerCount)
	virtual CSteamID GetClanOfficerByIndex(CSteamID steamIDClan, int iOfficer) = 0;
	// if current user is chat restricted, he can't send or receive any text/voice chat messages.
	// the user can't see custom avatars. But the user can be online and send/recv game invites.
	// a chat restricted user can't add friends or join any groups.
	virtual uint32 GetUserRestrictions() = 0;

	// Rich Presence data is automatically shared between friends who are in the same game
	// Each user has a set of Key/Value pairs
	// Up to 20 different keys can be set
	// There are two magic keys:
	//		"status"  - a UTF-8 string that will show up in the 'view game info' dialog in the Steam friends list
	//		"connect" - a UTF-8 string that contains the command-line for how a friend can connect to a game
	// GetFriendRichPresence() returns an empty string "" if no value is set
	// SetRichPresence() to a NULL or an empty string deletes the key
	// You can iterate the current set of keys for a friend with GetFriendRichPresenceKeyCount()
	// and GetFriendRichPresenceKeyByIndex() (typically only used for debugging)
	virtual bool SetRichPresence(const char *pchKey, const char *pchValue) = 0;
	virtual void ClearRichPresence() = 0;
	virtual const char *GetFriendRichPresence(CSteamID steamIDFriend, const char *pchKey) = 0;
	virtual int GetFriendRichPresenceKeyCount(CSteamID steamIDFriend) = 0;
	virtual const char *GetFriendRichPresenceKeyByIndex(CSteamID steamIDFriend, int iKey) = 0;
	// Requests rich presence for a specific user.
	virtual void RequestFriendRichPresence(CSteamID steamIDFriend) = 0;

	// rich invite support
	// if the target accepts the invite, the pchConnectString gets added to the command-line for launching the game
	// if the game is already running, a GameRichPresenceJoinRequested_t callback is posted containing the connect string
	// invites can only be sent to friends
	virtual bool InviteUserToGame(CSteamID steamIDFriend, const char *pchConnectString) = 0;

	// recently-played-with friends iteration
	// this iterates the entire list of users recently played with, across games
	// GetFriendCoplayTime() returns as a unix time
	virtual int GetCoplayFriendCount() = 0;
	virtual CSteamID GetCoplayFriend(int iCoplayFriend) = 0;
	virtual int GetFriendCoplayTime(CSteamID steamIDFriend) = 0;
	virtual AppId_t GetFriendCoplayGame(CSteamID steamIDFriend) = 0;

	// chat interface for games
	// this allows in-game access to group (clan) chats from in the game
	// the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay
	// use ActivateGameOverlayToUser( "chat", steamIDClan ) to open the in-game overlay version of the chat
	virtual SteamAPICall_t JoinClanChatRoom(CSteamID steamIDClan) = 0;
	virtual bool LeaveClanChatRoom(CSteamID steamIDClan) = 0;
	virtual int GetClanChatMemberCount(CSteamID steamIDClan) = 0;
	virtual CSteamID GetChatMemberByIndex(CSteamID steamIDClan, int iUser) = 0;
	virtual bool SendClanChatMessage(CSteamID steamIDClanChat, const char *pchText) = 0;
	virtual int GetClanChatMessage(CSteamID steamIDClanChat, int iMessage, void *prgchText, int cchTextMax, EChatEntryType *peChatEntryType, CSteamID *psteamidChatter) = 0;
	virtual bool IsClanChatAdmin(CSteamID steamIDClanChat, CSteamID steamIDUser) = 0;

	// interact with the Steam (game overlay / desktop)
	virtual bool IsClanChatWindowOpenInSteam(CSteamID steamIDClanChat) = 0;
	virtual bool OpenClanChatWindowInSteam(CSteamID steamIDClanChat) = 0;
	virtual bool CloseClanChatWindowInSteam(CSteamID steamIDClanChat) = 0;

	// peer-to-peer chat interception
	// this is so you can show P2P chats inline in the game
	virtual bool SetListenForFriendsMessages(bool bInterceptEnabled) = 0;
	virtual bool ReplyToFriendMessage(CSteamID steamIDFriend, const char *pchMsgToSend) = 0;
	virtual int GetFriendMessage(CSteamID steamIDFriend, int iMessageID, void *pvData, int cubData, EChatEntryType *peChatEntryType) = 0;

	// following apis
	virtual SteamAPICall_t GetFollowerCount(CSteamID steamID) = 0;
	virtual SteamAPICall_t IsFollowing(CSteamID steamID) = 0;
	virtual SteamAPICall_t EnumerateFollowingList(uint32 unStartIndex) = 0;
};

class ISteamUser
{
public:
	virtual HSteamUser GetHSteamUser() = 0;
	virtual bool BLoggedOn() = 0;
	virtual CSteamID GetSteamID() = 0;
	virtual int InitiateGameConnection(void *pAuthBlob, int cbMaxAuthBlob, CSteamID steamIDGameServer, uint32 unIPServer, uint16 usPortServer, bool bSecure) = 0;

	// notify of disconnect
	// needs to occur when the game client leaves the specified game server, needs to match with the InitiateGameConnection() call
	virtual void TerminateGameConnection(uint32 unIPServer, uint16 usPortServer) = 0;

	// Legacy functions

	// used by only a few games to track usage events
	virtual void TrackAppUsageEvent(CGameID gameID, int eAppUsageEvent, const char *pchExtraInfo = "") = 0;

	// get the local storage folder for current Steam account to write application data, e.g. save games, configs etc.
	// this will usually be something like "C:\Progam Files\Steam\userdata\<SteamID>\<AppID>\local"
	virtual bool GetUserDataFolder(char *pchBuffer, int cubBuffer) = 0;

	// Starts voice recording. Once started, use GetVoice() to get the data
	virtual void StartVoiceRecording() = 0;

	// Stops voice recording. Because people often release push-to-talk keys early, the system will keep recording for
	// a little bit after this function is called. GetVoice() should continue to be called until it returns
	// k_eVoiceResultNotRecording
	virtual void StopVoiceRecording() = 0;

	// Determine the amount of captured audio data that is available in bytes.
	// This provides both the compressed and uncompressed data. Please note that the uncompressed
	// data is not the raw feed from the microphone: data may only be available if audible 
	// levels of speech are detected.
	// nUncompressedVoiceDesiredSampleRate is necessary to know the number of bytes to return in pcbUncompressed - can be set to 0 if you don't need uncompressed (the usual case)
	// If you're upgrading from an older Steamworks API, you'll want to pass in 11025 to nUncompressedVoiceDesiredSampleRate
	virtual void pad_1() = 0;

	// Gets the latest voice data from the microphone. Compressed data is an arbitrary format, and is meant to be handed back to 
	// DecompressVoice() for playback later as a binary blob. Uncompressed data is 16-bit, signed integer, 11025Hz PCM format.
	// Please note that the uncompressed data is not the raw feed from the microphone: data may only be available if audible 
	// levels of speech are detected, and may have passed through denoising filters, etc.
	// This function should be called as often as possible once recording has started; once per frame at least.
	// nBytesWritten is set to the number of bytes written to pDestBuffer. 
	// nUncompressedBytesWritten is set to the number of bytes written to pUncompressedDestBuffer. 
	// You must grab both compressed and uncompressed here at the same time, if you want both.
	// Matching data that is not read during this call will be thrown away.
	// GetAvailableVoice() can be used to determine how much data is actually available.
	// If you're upgrading from an older Steamworks API, you'll want to pass in 11025 to nUncompressedVoiceDesiredSampleRate
	virtual void pad_2() = 0;
	// Decompresses a chunk of compressed data produced by GetVoice().
	// nBytesWritten is set to the number of bytes written to pDestBuffer unless the return value is k_EVoiceResultBufferTooSmall.
	// In that case, nBytesWritten is set to the size of the buffer required to decompress the given
	// data. The suggested buffer size for the destination buffer is 22 kilobytes.
	// The output format of the data is 16-bit signed at the requested samples per second.
	// If you're upgrading from an older Steamworks API, you'll want to pass in 11025 to nDesiredSampleRate
	virtual void pad_3() = 0;
	// This returns the frequency of the voice data as it's stored internally; calling DecompressVoice() with this size will yield the best results
	virtual uint32 GetVoiceOptimalSampleRate() = 0;

	// Retrieve ticket to be sent to the entity who wishes to authenticate you. 
	// pcbTicket retrieves the length of the actual ticket.
	virtual void pad_4() = 0;
	// Authenticate ticket from entity steamID to be sure it is valid and isnt reused
	// Registers for callbacks if the entity goes offline or cancels the ticket ( see ValidateAuthTicketResponse_t callback and EAuthSessionResponse )
	virtual void pad_5() = 0;
	// Stop tracking started by BeginAuthSession - called when no longer playing game with this entity
	virtual void EndAuthSession(CSteamID steamID) = 0;

	// Cancel auth ticket from GetAuthSessionTicket, called when no longer playing game with the entity you gave the ticket to
	virtual void pad_6() = 0;
	// After receiving a user's authentication data, and passing it to BeginAuthSession, use this function
	// to determine if the user owns downloadable content specified by the provided AppID.
	virtual void pad_7() = 0;
	// returns true if this users looks like they are behind a NAT device. Only valid once the user has connected to steam 
	// (i.e a SteamServersConnected_t has been issued) and may not catch all forms of NAT.
	virtual bool BIsBehindNAT() = 0;

	// set data to be replicated to friends so that they can join your game
	// CSteamID steamIDGameServer - the steamID of the game server, received from the game server by the client
	// uint32 unIPServer, uint16 usPortServer - the IP address of the game server
	virtual void AdvertiseGame(CSteamID steamIDGameServer, uint32 unIPServer, uint16 usPortServer) = 0;

	// Requests a ticket encrypted with an app specific shared key
	// pDataToInclude, cbDataToInclude will be encrypted into the ticket
	// ( This is asynchronous, you must wait for the ticket to be completed by the server )
	virtual SteamAPICall_t RequestEncryptedAppTicket(void *pDataToInclude, int cbDataToInclude) = 0;

	// retrieve a finished ticket
	virtual bool GetEncryptedAppTicket(void *pTicket, int cbMaxTicket, uint32 *pcbTicket) = 0;

	// Trading Card badges data access
	// if you only have one set of cards, the series will be 1
	// the user has can have two different badges for a series; the regular (max level 5) and the foil (max level 1)
	virtual int GetGameBadgeLevel(int nSeries, bool bFoil) = 0;

	// gets the Steam Level of the user, as shown on their profile
	virtual int GetPlayerSteamLevel() = 0;

	// Requests a URL which authenticates an in-game browser for store check-out,
	// and then redirects to the specified URL. As long as the in-game browser
	// accepts and handles session cookies, Steam microtransaction checkout pages
	// will automatically recognize the user instead of presenting a login page.
	// The result of this API call will be a StoreAuthURLResponse_t callback.
	// NOTE: The URL has a very short lifetime to prevent history-snooping attacks,
	// so you should only call this API when you are about to launch the browser,
	// or else immediately navigate to the result URL using a hidden browser window.
	// NOTE 2: The resulting authorization cookie has an expiration time of one day,
	// so it would be a good idea to request and visit a new auth URL every 12 hours.
	virtual SteamAPICall_t RequestStoreAuthURL(const char *pchRedirectURL) = 0;
	/*CSteamID GetSteamID()
	{
		//return ((CSteamID(__cdecl*)(ISteamUser*))GetProcAddress(GetModuleHandle("steam_api.dll"), "SteamAPI_ISteamUser_GetSteamID"))(this);

		typedef CSteamID(__thiscall* OriginalFn)(void*);
		return CallVFunc<OriginalFn>(this, 2)(this);
	}*/
};

class ISteamClient
{
public:
	ISteamUser *GetISteamUser(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion)
	{
		typedef ISteamUser*(__thiscall* OriginalFn)(void*, HSteamUser, HSteamPipe, const char*);
		return Memory::VCall<OriginalFn>(this, 5)(this, hSteamUser, hSteamPipe, pchVersion);
	}

	void *GetISteamGenericInterface(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion)
	{
		typedef void*(__thiscall* OriginalFn)(void*, HSteamUser, HSteamPipe, const char*);
		return Memory::VCall<OriginalFn>(this, 12)(this, hSteamUser, hSteamPipe, pchVersion);
	}
	ISteamMatchmaking *GetISteamMatchmaking(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion)
	{
		typedef ISteamMatchmaking*(__thiscall* OriginalFn)(void*, HSteamUser, HSteamPipe, const char*);
		return Memory::VCall<OriginalFn>(this, 16)(this, hSteamUser, hSteamPipe, pchVersion);
	}
	//virtual ISteamFriends *GetISteamFriends( HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion ) = 0;
	ISteamFriends* GetISteamFriends(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) {
		typedef ISteamFriends*(__thiscall* OriginalFn)(void*, HSteamUser, HSteamPipe, const char*);
		return Memory::VCall<OriginalFn>(this, 8)(this, hSteamUser, hSteamPipe, pchVersion);
	}
};


enum EGCResults
{
	k_EGCResultOK = 0,
	k_EGCResultNoMessage = 1,			// There is no message in the queue
	k_EGCResultBufferTooSmall = 2,		// The buffer is too small for the requested message
	k_EGCResultNotLoggedOn = 3,			// The client is not logged onto Steam
	k_EGCResultInvalidMessage = 4,		// Something was wrong with the message being sent with SendMessage
};

class ISteamGameCoordinator
{
public:
	virtual EGCResults sendMessage(uint32_t unMsgType, const void *pubData, uint32_t cubData) = 0;
	virtual bool IsMessageAvailable(uint32_t *pcubMsgSize) = 0;
	virtual EGCResults RetrieveMessage(uint32_t *punMsgType, void *pubDest, uint32_t cubDest, uint32_t *pcubMsgSize) = 0;
};

```

`CSGO SDK/SDK/Classes/IStudioRender.hpp`:

```hpp
#pragma once
#include "sdk.hpp"

class IStudioRender {
public:
  void* vtable;
  float fEyeShiftX;                      //0x0004
  float fEyeShiftY;                      //0x0008
  float fEyeShiftZ;                      //0x000C
  float fEyeSize;                        //0x0010
  float fEyeGlintPixelWidthLODThreshold; //0x0014
  __int32 maxDecalsPerModel;             //0x0018
  __int32 drawEntities;                  //0x001C
  __int32 skin;                          //0x0020
  __int32 fullbright;                    //0x0024
  bool bEyeMove : 1;                     // look around
  bool bSoftwareSkin : 1;
  bool bNoHardware : 1;
  bool bNoSoftware : 1;
  bool bTeeth : 1;
  bool bEyes : 1;
  bool bFlex : 1;
  bool bWireframe : 1;
  bool bDrawNormals : 1;
  bool bDrawTangentFrame : 1;
  bool bDrawZBufferedWireframe : 1;
  bool bSoftwareLighting : 1;
  bool bShowEnvCubemapOnly : 1;
  bool bWireframeDecals : 1;
  int m_nReserved[5];
  Vector m_ViewTarget;           //0x0040
  Vector m_ViewOrigin;           //0x004C
  Vector m_ViewRight;            //0x0058
  Vector m_ViewUp;               //0x0064
  Vector m_ViewPlaneNormal;      //0x0070
  Vector4D m_LightBoxColors[6];  //0x00CC
  LightDesc_t m_LocalLights[4];  //0x01E4
  __int32 m_NumLocalLights;      //0x023C
  float m_ColorMod[3];           //0x0248
  float m_AlphaMod;              //0x024C
  IMaterial* m_pForcedMaterial;  //0x0250
  __int32 m_nForcedMaterialType; //0x0254
  char pad_0x0258[0xC];          //0x0258
  __int32 unkhandle1;            //0x0264
  __int32 unkhandle2;            //0x0268
  __int32 unkhandle3;            //0x026C
  __int32 unkhandle4;            //0x0270
  char pad_0x0274[0x4];          //0x0274
  lightpos_t m_pLightPos[16];    //0x0278

  void SetColorModulation( float const* pColor ) {
	 typedef void( __thiscall * OrigFn )( void*, float const* );
	 Memory::VCall< OrigFn >( this, 27 )( this, pColor );
  }

  void DrawModel(void* pResults, DrawModelInfo_t* pInfo, matrix3x4_t* pBoneToWorld, float* flpFlexWeights, float* flpFlexDelayedWeights, Vector& vrModelOrigin, int32_t iFlags) {
	  using DrawModelFn = void(__thiscall*)(void*, void*, DrawModelInfo_t*, const matrix3x4_t*, float*, float*, Vector&, int);
	  Memory::VCall< DrawModelFn >(this, 29) (this, pResults, pInfo, pBoneToWorld, flpFlexWeights, flpFlexDelayedWeights, vrModelOrigin, iFlags);
  }

  inline void ForcedMaterialOverride( IMaterial* material, OverrideType_t nOverrideType = 0 ) {
	 m_pForcedMaterial = material;
	 m_nForcedMaterialType = nOverrideType;
  }
};

//static_assert( FIELD_OFFSET( IStudioRender, m_pForcedMaterial ) == 0x250, "Wrong m_pForcedMaterial offset" );

```

`CSGO SDK/SDK/Classes/ISurface.cpp`:

```cpp
#include "../sdk.hpp"


```

`CSGO SDK/SDK/Classes/ISurface.hpp`:

```hpp
#pragma once
#include "IAppSystem.hpp"
#include "Definitions.hpp"

typedef unsigned long HFont;
typedef unsigned int VPANEL;

class ISurface : public IAppSystem
{
public:

	virtual void          RunFrame() = 0;
	virtual VPANEL		  GetEmbeddedPanel() = 0;
	virtual void          SetEmbeddedPanel(VPANEL pPanel) = 0;
	virtual void          PushMakeCurrent(VPANEL panel, bool useInsets) = 0;
	virtual void          PopMakeCurrent(VPANEL panel) = 0;
	virtual void          DrawSetColor(int r, int g, int b, int a) = 0;
	virtual void          DrawSetColor(Color col) = 0;
	virtual void          DrawFilledRect(int x0, int y0, int x1, int y1) = 0;
	virtual void          DrawFilledRectArray(IntRect *pRects, int numRects) = 0;
	virtual void          DrawOutlinedRect(int x0, int y0, int x1, int y1) = 0;
	virtual void          DrawLine(int x0, int y0, int x1, int y1) = 0;
	virtual void          DrawPolyLine(int *px, int *py, int numPoints) = 0;
	virtual void          DrawSetApparentDepth(float f) = 0;
	virtual void          DrawClearApparentDepth(void) = 0;
	virtual void          DrawSetTextFont(HFont font) = 0;
	virtual void          DrawSetTextColor(int r, int g, int b, int a) = 0;
	virtual void          DrawSetTextColor(Color col) = 0;
	virtual void          DrawSetTextPos(int x, int y) = 0;
	virtual void          DrawGetTextPos(int& x, int& y) = 0;
	virtual void          DrawPrintText(const wchar_t *text, int textLen, FontDrawType drawType = FontDrawType::FONT_DRAW_DEFAULT) = 0;
	virtual void          DrawUnicodeChar(wchar_t wch, FontDrawType drawType = FontDrawType::FONT_DRAW_DEFAULT) = 0;
	virtual void          DrawFlushText() = 0;
	virtual void*         CreateHTMLWindow(void *events, VPANEL context) = 0;
	virtual void          PaintHTMLWindow(void *htmlwin) = 0;
	virtual void          DeleteHTMLWindow(void *htmlwin) = 0;
	virtual int           DrawGetTextureId(char const *filename) = 0;
	virtual bool          DrawGetTextureFile(int id, char *filename, int maxlen) = 0;
	virtual void          DrawSetTextureFile(int id, const char *filename, int hardwareFilter, bool forceReload) = 0;
	virtual void          DrawSetTextureRGBA(int id, const unsigned char *rgba, int wide, int tall) = 0;
	virtual void          DrawSetTexture(int id) = 0;
	virtual void          DeleteTextureByID(int id) = 0;
	virtual void          DrawGetTextureSize(int id, int &wide, int &tall) = 0;
	virtual void          DrawTexturedRect(int x0, int y0, int x1, int y1) = 0;
	virtual bool          IsTextureIDValid(int id) = 0;
	virtual int           CreateNewTextureID(bool procedural = false) = 0;
	virtual void          GetScreenSize(int &wide, int &tall) = 0;
	virtual void          SetAsTopMost(VPANEL panel, bool state) = 0;
	virtual void          BringToFront(VPANEL panel) = 0;
	virtual void          SetForegroundWindow(VPANEL panel) = 0;
	virtual void          SetPanelVisible(VPANEL panel, bool state) = 0;
	virtual void          SetMinimized(VPANEL panel, bool state) = 0;
	virtual bool          IsMinimized(VPANEL panel) = 0;
	virtual void          FlashWindow(VPANEL panel, bool state) = 0;
	virtual void          SetTitle(VPANEL panel, const wchar_t *title) = 0;
	virtual void          SetAsToolBar(VPANEL panel, bool state) = 0;
	virtual void          CreatePopup(VPANEL panel, bool minimised, bool showTaskbarIcon = true, bool disabled = false, bool mouseInput = true, bool kbInput = true) = 0;
	virtual void          SwapBuffers(VPANEL panel) = 0;
	virtual void          Invalidate(VPANEL panel) = 0;
	virtual void          SetCursor(unsigned long cursor) = 0;
	virtual bool          IsCursorVisible() = 0;
	virtual void          ApplyChanges() = 0;
	virtual bool          IsWithin(int x, int y) = 0;
	virtual bool          HasFocus() = 0;
	virtual bool          SupportsFeature(int /*SurfaceFeature_t*/ feature) = 0;
	virtual void          RestrictPaintToSinglePanel(VPANEL panel, bool bForceAllowNonModalSurface = false) = 0;
	virtual void          SetModalPanel(VPANEL) = 0;
	virtual VPANEL		  GetModalPanel() = 0;
	virtual void          UnlockCursor() = 0;
	virtual void          LockCursor() = 0;
	virtual void          SetTranslateExtendedKeys(bool state) = 0;
	virtual VPANEL		  GetTopmostPopup() = 0;
	virtual void          SetTopLevelFocus(VPANEL panel) = 0;
	virtual HFont		  CreateFont_() = 0;
	virtual bool          SetFontGlyphSet(HFont font, const char *windowsFontName, int tall, int weight, int blur, int scanlines, int flags, int nRangeMin = 0, int nRangeMax = 0) = 0;
	virtual bool          AddCustomFontFile(const char *fontFileName) = 0;
	virtual int           GetFontTall(HFont font) = 0;
	virtual int           GetFontAscent(HFont font, wchar_t wch) = 0;
	virtual bool          IsFontAdditive(HFont font) = 0;
	virtual void          GetCharABCwide(HFont font, int ch, int &a, int &b, int &c) = 0;
	virtual int           GetCharacterWidth(HFont font, int ch) = 0;
	virtual void          GetTextSize(HFont font, const wchar_t *text, int &wide, int &tall) = 0;
	virtual VPANEL		  GetNotifyPanel() = 0;
	virtual void          SetNotifyIcon(VPANEL context, unsigned long icon, VPANEL panelToReceiveMessages, const char *text) = 0;
	virtual void          PlaySound_(const char *fileName) = 0;
	virtual int           GetPopupCount() = 0;
	virtual VPANEL		  GetPopup(int index) = 0;
	virtual bool          ShouldPaintChildPanel(VPANEL childPanel) = 0;
	virtual bool          RecreateContext(VPANEL panel) = 0;
	virtual void          AddPanel(VPANEL panel) = 0;
	virtual void          ReleasePanel(VPANEL panel) = 0;
	virtual void          MovePopupToFront(VPANEL panel) = 0;
	virtual void          MovePopupToBack(VPANEL panel) = 0;
	virtual void          SolveTraverse(VPANEL panel, bool forceApplySchemeSettings = false) = 0;
	virtual void          PaintTraverse(VPANEL panel) = 0;
	virtual void          EnableMouseCapture(VPANEL panel, bool state) = 0;
	virtual void          GetWorkspaceBounds(int &x, int &y, int &wide, int &tall) = 0;
	virtual void          GetAbsoluteWindowBounds(int &x, int &y, int &wide, int &tall) = 0;
	virtual void          GetProportionalBase(int &width, int &height) = 0;
	virtual void          CalculateMouseVisible() = 0;
	virtual bool          NeedKBInput() = 0;
	virtual bool          HasCursorPosFunctions() = 0;
	virtual void          SurfaceGetCursorPos(int &x, int &y) = 0;
	virtual void          SurfaceSetCursorPos(int x, int y) = 0;
	virtual void          DrawTexturedLine(const Vertex_t &a, const Vertex_t &b) = 0;
	virtual void          DrawOutlinedCircle(int x, int y, int radius, int segments) = 0;
	virtual void          DrawTexturedPolyLine(const Vertex_t *p, int n) = 0;
	virtual void          DrawTexturedSubRect(int x0, int y0, int x1, int y1, float texs0, float text0, float texs1, float text1) = 0;
	virtual void          DrawTexturedPolygon(int n, Vertex_t *pVertice, bool bClipVertices = true) = 0;

	__forceinline void DrawFilledRectFade( int x0, int y0, int x1, int y1, uint32_t alpha0, uint32_t alpha1, bool bSDKtal ) {
		using Fn = void( __thiscall* )( decltype( this ), int, int, int, int, uint32_t, uint32_t, bool );
		Memory::VCall<Fn>( this, 123 )( this, x0, y1, x1, y1, alpha0, alpha1, bSDKtal );
	}
};
```

`CSGO SDK/SDK/Classes/IVDebugOverlay.hpp`:

```hpp
#pragma once
#include "sdk.hpp"

class OverlayText_t;

class IVDebugOverlay
{
public:
  virtual void            AddEntityTextOverlay(int ent_index, int line_offset, float duration, int r, int g, int b, int a, const char *format, ...) = 0;
  virtual void            AddBoxOverlay(const Vector& origin, const Vector& mins, const Vector& max, QAngle const& orientation, int r, int g, int b, int a, float duration) = 0;
  virtual void            AddSphereOverlay(const Vector& vOrigin, float flRadius, int nTheta, int nPhi, int r, int g, int b, int a, float flDuration) = 0;
  virtual void            AddTriangleOverlay(const Vector& p1, const Vector& p2, const Vector& p3, int r, int g, int b, int a, bool noDepthTest, float duration) = 0;
  virtual void            __unkn() = 0;
  virtual void            AddLineOverlay(const Vector& origin, const Vector& dest, int r, int g, int b, bool noDepthTest, float duration) = 0;
  virtual void            AddTextOverlay(const Vector& origin, float duration, const char *format, ...) = 0;
  virtual void            AddTextOverlay(const Vector& origin, int line_offset, float duration, const char *format, ...) = 0;
  virtual void            AddScreenTextOverlay(float flXPos, float flYPos, float flDuration, int r, int g, int b, int a, const char *text) = 0;
  virtual void            AddSweptBoxOverlay(const Vector& start, const Vector& end, const Vector& mins, const Vector& max, const QAngle & angles, int r, int g, int b, int a, float flDuration) = 0;
  virtual void            AddGridOverlay(const Vector& origin) = 0;
  virtual void            AddCoordFrameOverlay(const matrix3x4_t& frame, float flScale, int vColorTable[3][3] = NULL) = 0;
  virtual int             ScreenPosition(const Vector& point, Vector& screen) = 0;
  virtual int             ScreenPosition(float flXPos, float flYPos, Vector& screen) = 0;
  virtual OverlayText_t*  GetFirst(void) = 0;
  virtual OverlayText_t*  GetNext(OverlayText_t *current) = 0;
  virtual void            ClearDeadOverlays(void) = 0;
  virtual void            ClearAllOverlays() = 0;
  virtual void            AddTextOverlayRGB(const Vector& origin, int line_offset, float duration, float r, float g, float b, float alpha, const char *format, ...) = 0;
  virtual void            AddTextOverlayRGB(const Vector& origin, int line_offset, float duration, int r, int g, int b, int a, const char *format, ...) = 0;
  virtual void            AddLineOverlayAlpha(const Vector& origin, const Vector& dest, int r, int g, int b, int a, bool noDepthTest, float duration) = 0;
  virtual void            AddBoxOverlay2(const Vector& origin, const Vector& mins, const Vector& max, QAngle const& orientation, const uint8_t* faceColor, const uint8_t* edgeColor, float duration) = 0;
  virtual void            PurgeTextOverlays() = 0;
  virtual void            DrawPill(const Vector& mins, const Vector& max, float& diameter, int r, int g, int b, int a, float duration) = 0;
  void AddCapsuleOverlay(Vector& mins, Vector& maxs, float pillradius, int r, int g, int b, int a, float duration)
  {
	 Memory::VCall<void(__thiscall*)(void*, Vector&, Vector&, float&, int, int, int, int, float)>(this, 24)(this, mins, maxs, pillradius, r, g, b, a, duration);
  }

private:
  inline void AddTextOverlay(const Vector& origin, int line_offset, float duration, int r, int g, int b, int a, const char *format, ...) {} /* catch improper use of bad interface. Needed because '0' duration can be resolved by compiler to NULL format string (i.e., compiles but calls wrong function) */
};

```

`CSGO SDK/SDK/Classes/IVEngineClient.cpp`:

```cpp
#include "../sdk.hpp"
//#include "matrix.hpp"
```

`CSGO SDK/SDK/Classes/IVEngineClient.hpp`:

```hpp
#pragma once
#include "INetChannel.hpp"



#define FLOW_OUTGOING	0		
#define FLOW_INCOMING	1
#define MAX_FLOWS		2		// in & out

typedef struct player_info_s
{
  __int64         unknown;            //0x0000 
  union
  {
	 __int64       steamID64;          //0x0008 - SteamID64
	 struct
	 {
		__int32     xuid_low;
		__int32     xuid_high;
	 };
  };
  char            szName[128];        //0x0010 - Player Name
  int             userId;             //0x0090 - Unique Server Identifier
  char            szSteamID[20];      //0x0094 - STEAM_X:Y:Z
  char            pad_0x00A8[0x10];   //0x00A8
  unsigned long   iSteamID;           //0x00B8 - SteamID 
  char            szFriendsName[128];
  bool            fakeplayer;
  bool            ishltv;
  unsigned int    customfiles[4];
  unsigned char   filesdownloaded;
} player_info_t;



class IVEngineClient
{
public:
  virtual int                   GetIntersectingSurfaces( const model_t *model, const Vector &vCenter, const float radius, const bool bOnlyVisibleSurfaces, SurfInfo *pInfos, const int nMaxInfos ) = 0;
  virtual Vector                GetLightForPoint( const Vector &pos, bool bClamp ) = 0;
  virtual IMaterial*            TraceLineMaterialAndLighting( const Vector &start, const Vector &end, Vector &diffuseLightColor, Vector& baseColor ) = 0;
  virtual const char*           ParseFile( const char *data, char *token, int maxlen ) = 0;
  virtual bool                  CopyFile( const char *source, const char *destination ) = 0;
  virtual void                  GetScreenSize( int& width, int& height ) = 0;
  virtual void                  ServerCmd( const char *szCmdString, bool bReliable = true ) = 0;
  virtual void                  ClientCmd( const char *szCmdString ) = 0;
  virtual bool                  GetPlayerInfo( int ent_num, player_info_t *pinfo ) = 0;
  virtual int                   GetPlayerForUserID( int userID ) = 0;
  virtual client_textmessage_t* TextMessageGet( const char *pName ) = 0; // 10
  virtual bool                  Con_IsVisible( void ) = 0;
  virtual int                   GetLocalPlayer( void ) = 0;
  virtual const model_t*        LoadModel( const char *pName, bool bProp = false ) = 0;
  virtual float                 GetLastTimeStamp( void ) = 0;
  virtual CSentence*            GetSentence( CAudioSource *pAudioSource ) = 0; // 15
  virtual float                 GetSentenceLength( CAudioSource *pAudioSource ) = 0;
  virtual bool                  IsStreaming( CAudioSource *pAudioSource ) const = 0;
  virtual void                  GetViewAngles( QAngle& va ) = 0;
  virtual void                  SetViewAngles( QAngle& va ) = 0;
  virtual int                   GetMaxClients( void ) = 0; // 20
  virtual const char*           Key_LookupBinding( const char *pBinding ) = 0;
  virtual const char*           Key_BindingForKey( int &code ) = 0;
  virtual void                  Key_SetBinding( int, char const* ) = 0;
  virtual void                  StartKeyTrapMode( void ) = 0;
  virtual bool                  CheckDoneKeyTrapping( int &code ) = 0;
  virtual bool                  IsInGame( void ) = 0;
  virtual bool                  IsConnected( void ) = 0;
  virtual bool                  IsDrawingLoadingImage( void ) = 0;
  virtual void                  HideLoadingPlaque( void ) = 0;
  virtual void                  Con_NPrintf( int pos, const char *fmt, ... ) = 0; // 30
  virtual void                  Con_NXPrintf( const struct con_nprint_s *info, const char *fmt, ... ) = 0;
  virtual int                   IsBoxVisible( const Vector& mins, const Vector& maxs ) = 0;
  virtual int                   IsBoxInViewCluster( const Vector& mins, const Vector& maxs ) = 0;
  virtual bool                  CullBox( const Vector& mins, const Vector& maxs ) = 0;
  virtual void                  Sound_ExtraUpdate( void ) = 0;
  virtual const char*           GetGameDirectory( void ) = 0;
  virtual const VMatrix&        WorldToScreenMatrix( ) = 0;
  virtual const VMatrix&        WorldToViewMatrix( ) = 0;
  virtual int                   GameLumpVersion( int lumpId ) const = 0;
  virtual int                   GameLumpSize( int lumpId ) const = 0; // 40
  virtual bool                  LoadGameLump( int lumpId, void* pBuffer, int size ) = 0;
  virtual int                   LevelLeafCount( ) const = 0;
  virtual ISpatialQuery*        GetBSPTreeQuery( ) = 0;
  virtual void                  LinearToGamma( float* linear, float* gamma ) = 0;
  virtual float                 LightStyleValue( int style ) = 0; // 45
  virtual void                  ComputeDynamicLighting( const Vector& pt, const Vector* pNormal, Vector& color ) = 0;
  virtual void                  GetAmbientLightColor( Vector& color ) = 0;
  virtual int                   GetDXSupportLevel( ) = 0;
  virtual bool                  SupportsHDR( ) = 0;
  virtual void                  Mat_Stub( void *pMatSys ) = 0; // 50
  virtual void                  GetChapterName( char *pchBuff, int iMaxLength ) = 0;
  virtual char const*           GetLevelName( void ) = 0;
  virtual char const*           GetLevelNameShort( void ) = 0;
  virtual char const*           GetMapGroupName( void ) = 0;
  virtual struct IVoiceTweak_s* GetVoiceTweakAPI( void ) = 0;
  virtual void                  SetVoiceCasterID( unsigned int someint ) = 0; // 56
  virtual void                  EngineStats_BeginFrame( void ) = 0;
  virtual void                  EngineStats_EndFrame( void ) = 0;
  virtual void                  FireEvents( ) = 0;
  virtual int                   GetLeavesArea( unsigned short *pLeaves, int nLeaves ) = 0;
  virtual bool                  DoesBoxTouchAreaFrustum( const Vector &mins, const Vector &maxs, int iArea ) = 0; // 60
  virtual int                   GetFrustumList( Frustum_t **pList, int listMax ) = 0;
  virtual bool                  ShouldUseAreaFrustum( int i ) = 0;
  virtual void                  SetAudioState( const AudioState_t& state ) = 0;
  virtual int                   SentenceGroupPick( int groupIndex, char *name, int nameBufLen ) = 0;
  virtual int                   SentenceGroupPickSequential( int groupIndex, char *name, int nameBufLen, int sentenceIndex, int reset ) = 0;
  virtual int                   SentenceIndexFromName( const char *pSentenceName ) = 0;
  virtual const char*           SentenceNameFromIndex( int sentenceIndex ) = 0;
  virtual int                   SentenceGroupIndexFromName( const char *pGroupName ) = 0;
  virtual const char*           SentenceGroupNameFromIndex( int groupIndex ) = 0;
  virtual float                 SentenceLength( int sentenceIndex ) = 0;
  virtual void                  ComputeLighting( const Vector& pt, const Vector* pNormal, bool bClamp, Vector& color, Vector *pBoxColors = NULL ) = 0;
  virtual void                  ActivateOccluder( int nOccluderIndex, bool bActive ) = 0;
  virtual bool                  IsOccluded( const Vector &vecAbsMins, const Vector &vecAbsMaxs ) = 0; // 74
  virtual int                   GetOcclusionViewId( void ) = 0;
  virtual void*                 SaveAllocMemory( size_t num, size_t size ) = 0;
  virtual void                  SaveFreeMemory( void *pSaveMem ) = 0;
  virtual INetChannel*			  GetNetChannelInfo( void ) = 0;
  virtual void                  DebugDrawPhysCollide( const CPhysCollide *pCollide, IMaterial *pMaterial, const matrix3x4_t& transform, const uint8_t* color ) = 0; //79
  virtual void                  CheckPoint( const char *pName ) = 0; // 80
  virtual void                  DrawPortals( ) = 0;
  virtual bool                  IsPlayingDemo( void ) = 0;
  virtual bool                  IsRecordingDemo( void ) = 0;
  virtual bool                  IsPlayingTimeDemo( void ) = 0;
  virtual int                   GetDemoRecordingTick( void ) = 0;
  virtual int                   GetDemoPlaybackTick( void ) = 0;
  virtual int                   GetDemoPlaybackStartTick( void ) = 0;
  virtual float                 GetDemoPlaybackTimeScale( void ) = 0;
  virtual int                   GetDemoPlaybackTotalTicks( void ) = 0;
  virtual bool                  IsPaused( void ) = 0; // 90
  virtual float                 GetTimescale( void ) const = 0;
  virtual bool                  IsTakingScreenshot( void ) = 0;
  virtual void						  Unknown_0( void ) = 0;
  virtual bool                  IsHLTV( void ) = 0;
  virtual bool                  IsLevelMainMenuBackground( void ) = 0;
  virtual void                  GetMainMenuBackgroundName( char *dest, int destlen ) = 0;
  virtual void                  SetOcclusionParameters( const int /*OcclusionParams_t*/ &params ) = 0; // 96
  virtual void                  GetUILanguage( char *dest, int destlen ) = 0;
  virtual int                   IsSkyboxVisibleFromPoint( const Vector &vecPoint ) = 0;
  virtual const char*           GetMapEntitiesString( ) = 0;
  virtual bool                  IsInEditMode( void ) = 0; // 100
  virtual float                 GetScreenAspectRatio( int viewportWidth, int viewportHeight ) = 0;
  virtual bool                  REMOVED_SteamRefreshLogin( const char *password, bool isSecure ) = 0;
  virtual bool                  REMOVED_SteamProcessCall( bool & finished ) = 0;
  virtual unsigned int          GetEngineBuildNumber( ) = 0; // engines build
  virtual const char *          GetProductVersionString( ) = 0; // mods version number (steam.inf)
  virtual void                  GrabPreColorCorrectedFrame( int x, int y, int width, int height ) = 0;
  virtual bool                  IsHammerRunning( ) const = 0;
  virtual void                  ExecuteClientCmd( const char *szCmdString, int ticks_delay = 0 ) = 0; //108
  virtual bool                  MapHasHDRLighting( void ) = 0;
  virtual bool                  MapHasLightMapAlphaData( void ) = 0;
  virtual int                   GetAppID( ) = 0;
  virtual Vector                GetLightForPointFast( const Vector &pos, bool bClamp ) = 0;
  virtual void                  ClientCmd_Unrestricted( char  const*, int, bool ) = 0;
  virtual void                  ClientCmd_Unrestricted( const char *szCmdString ) = 0; // 114
  virtual void                  SetRestrictServerCommands( bool bRestrict ) = 0;
  virtual void                  SetRestrictClientCommands( bool bRestrict ) = 0;
  virtual void                  SetOverlayBindProxy( int iOverlayID, void *pBindProxy ) = 0;
  virtual bool                  CopyFrameBufferToMaterial( const char *pMaterialName ) = 0;
  virtual void                  ReadConfiguration( const int iController, const bool readDefault ) = 0;
  virtual void                  SetAchievementMgr( IAchievementMgr *pAchievementMgr ) = 0;
  virtual IAchievementMgr*      GetAchievementMgr( ) = 0;
  virtual bool                  MapLoadFailed( void ) = 0;
  virtual void                  SetMapLoadFailed( bool bState ) = 0;
  virtual bool                  IsLowViolence( ) = 0;
  virtual const char*           GetMostRecentSaveGame( void ) = 0;
  virtual void                  SetMostRecentSaveGame( const char *lpszFilename ) = 0;
  virtual void                  StartXboxExitingProcess( ) = 0;
  virtual bool                  IsSaveInProgress( ) = 0;
  virtual bool                  IsAutoSaveDangerousInProgress( void ) = 0;
  virtual unsigned int          OnStorageDeviceAttached( int iController ) = 0;
  virtual void                  OnStorageDeviceDetached( int iController ) = 0;
  virtual char* const           GetSaveDirName( void ) = 0;
  virtual void                  WriteScreenshot( const char *pFilename ) = 0;
  virtual void                  ResetDemoInterpolation( void ) = 0;
  virtual int                   GetActiveSplitScreenPlayerSlot( ) = 0;
  virtual int                   SetActiveSplitScreenPlayerSlot( int slot ) = 0;
  virtual bool                  SetLocalPlayerIsResolvable( char const *pchContext, int nLine, bool bResolvable ) = 0;
  virtual bool                  IsLocalPlayerResolvable( ) = 0;
  virtual int                   GetSplitScreenPlayer( int nSlot ) = 0;
  virtual bool                  IsSplitScreenActive( ) = 0;
  virtual bool                  IsValidSplitScreenSlot( int nSlot ) = 0;
  virtual int                   FirstValidSplitScreenSlot( ) = 0; // -1 == invalid
  virtual int                   NextValidSplitScreenSlot( int nPreviousSlot ) = 0; // -1 == invalid
  virtual ISPSharedMemory*      GetSinglePlayerSharedMemorySpace( const char *szName, int ent_num = ( 1 << 11 ) ) = 0;
  virtual void                  ComputeLightingCube( const Vector& pt, bool bClamp, Vector *pBoxColors ) = 0;
  virtual void                  RegisterDemoCustomDataCallback( const char* szCallbackSaveID, pfnDemoCustomDataCallback pCallback ) = 0;
  virtual void                  RecordDemoCustomData( pfnDemoCustomDataCallback pCallback, const void *pData, size_t iDataLength ) = 0;
  virtual void                  SetPitchScale( float flPitchScale ) = 0;
  virtual float                 GetPitchScale( void ) = 0;
  virtual bool                  LoadFilmmaker( ) = 0;
  virtual void                  UnloadFilmmaker( ) = 0;
  virtual void                  SetLeafFlag( int nLeafIndex, int nFlagBits ) = 0;
  virtual void                  RecalculateBSPLeafFlags( void ) = 0;
  virtual bool                  DSPGetCurrentDASRoomNew( void ) = 0;
  virtual bool                  DSPGetCurrentDASRoomChanged( void ) = 0;
  virtual bool                  DSPGetCurrentDASRoomSkyAbove( void ) = 0;
  virtual float                 DSPGetCurrentDASRoomSkyPercent( void ) = 0;
  virtual void                  SetMixGroupOfCurrentMixer( const char *szgroupname, const char *szparam, float val, int setMixerType ) = 0;
  virtual int                   GetMixLayerIndex( const char *szmixlayername ) = 0;
  virtual void                  SetMixLayerLevel( int index, float level ) = 0;
  virtual int                   GetMixGroupIndex( char  const* groupname ) = 0;
  virtual void                  SetMixLayerTriggerFactor( int i1, int i2, float fl ) = 0;
  virtual void                  SetMixLayerTriggerFactor( char  const* char1, char  const* char2, float fl ) = 0;
  virtual bool                  IsCreatingReslist( ) = 0;
  virtual bool                  IsCreatingXboxReslist( ) = 0;
  virtual void                  SetTimescale( float flTimescale ) = 0;
  virtual void                  SetGamestatsData( CGamestatsData *pGamestatsData ) = 0;
  virtual CGamestatsData*       GetGamestatsData( ) = 0;
  virtual void                  GetMouseDelta( int &dx, int &dy, bool b ) = 0; // unknown
  virtual   const char*         Key_LookupBindingEx( const char *pBinding, int iUserId = -1, int iStartCount = 0, int iAllowJoystick = -1 ) = 0;
  virtual int                   Key_CodeForBinding( char  const*, int, int, int ) = 0; // 186
  virtual void                  UpdateDAndELights( void ) = 0;
  virtual int                   GetBugSubmissionCount( ) const = 0;
  virtual void                  ClearBugSubmissionCount( ) = 0;
  virtual bool                  DoesLevelContainWater( ) const = 0;
  virtual float                 GetServerSimulationFrameTime( ) const = 0;
  virtual void                  SolidMoved( class IClientEntity *pSolidEnt, class ICollideable *pSolidCollide, const Vector* pPrevAbsOrigin, bool accurateBboxTriggerChecks ) = 0;
  virtual void                  TriggerMoved( class IClientEntity *pTriggerEnt, bool accurateBboxTriggerChecks ) = 0;
  virtual void                  ComputeLeavesConnected( const Vector &vecOrigin, int nCount, const int *pLeafIndices, bool *pIsConnected ) = 0;
  virtual bool                  IsInCommentaryMode( void ) = 0;
  virtual void                  SetBlurFade( float amount ) = 0;
  virtual bool                  IsTransitioningToLoad( ) = 0;
  virtual void                  SearchPathsChangedAfterInstall( ) = 0;
  virtual void                  ConfigureSystemLevel( int nCPULevel, int nGPULevel ) = 0;
  virtual void                  SetConnectionPassword( char const *pchCurrentPW ) = 0;
  virtual CSteamAPIContext*     GetSteamAPIContext( ) = 0;
  virtual void                  SubmitStatRecord( char const *szMapName, unsigned int uiBlobVersion, unsigned int uiBlobSize, const void *pvBlob ) = 0;
  virtual void                  ServerCmdKeyValues( KeyValues *pKeyValues ) = 0; // 203
  virtual void                  SpherePaintSurface( const model_t* model, const Vector& location, unsigned char chr, float fl1, float fl2 ) = 0;
  virtual bool                  HasPaintmap( void ) = 0;
  virtual void                  EnablePaintmapRender( ) = 0;
  //virtual void                TracePaintSurface( const model_t *model, const Vector& position, float radius, CUtlVector<Color>& surfColors ) = 0;
  virtual void                  SphereTracePaintSurface( const model_t* model, const Vector& position, const Vector &vec2, float radius, /*CUtlVector<unsigned char, CUtlMemory<unsigned char, int>>*/ int& utilVecShit ) = 0;
  virtual void                  RemoveAllPaint( ) = 0;
  virtual void                  PaintAllSurfaces( unsigned char uchr ) = 0;
  virtual void                  RemovePaint( const model_t* model ) = 0;
  virtual bool                  IsActiveApp( ) = 0;
  virtual bool                  IsClientLocalToActiveServer( ) = 0;
  virtual void                  TickProgressBar( ) = 0;
  virtual InputContextHandle_t  GetInputContext( int /*EngineInputContextId_t*/ id ) = 0;
  virtual void                  GetStartupImage( char* filename, int size ) = 0;
  virtual bool                  IsUsingLocalNetworkBackdoor( void ) = 0;
  virtual void                  SaveGame( const char*, bool, char*, int, char*, int ) = 0;
  virtual void                  GetGenericMemoryStats(/* GenericMemoryStat_t */ void ** ) = 0;
  virtual bool                  GameHasShutdownAndFlushedMemory( void ) = 0;
  virtual int                   GetLastAcknowledgedCommand( void ) = 0;
  virtual void                  FinishContainerWrites( int i ) = 0;
  virtual void                  FinishAsyncSave( void ) = 0;
  virtual int                   GetServerTick( void ) = 0;
  virtual const char*           GetModDirectory( void ) = 0;
  virtual bool                  AudioLanguageChanged( void ) = 0;
  virtual bool                  IsAutoSaveInProgress( void ) = 0;
  virtual void                  StartLoadingScreenForCommand( const char* command ) = 0;
  virtual void                  StartLoadingScreenForKeyValues( KeyValues* values ) = 0;
  virtual void                  SOSSetOpvarFloat( const char*, float ) = 0;
  virtual void                  SOSGetOpvarFloat( const char*, float & ) = 0;
  virtual bool                  IsSubscribedMap( const char*, bool ) = 0;
  virtual bool                  IsFeaturedMap( const char*, bool ) = 0;
  virtual void                  GetDemoPlaybackParameters( void ) = 0;
  virtual int                   GetClientVersion( void ) = 0;
  virtual bool                  IsDemoSkipping( void ) = 0;
  virtual void                  SetDemoImportantEventData( const KeyValues* values ) = 0;
  virtual void                  ClearEvents( void ) = 0;
  virtual int                   GetSafeZoneXMin( void ) = 0;
  virtual bool                  IsVoiceRecording( void ) = 0;
  virtual void                  ForceVoiceRecordOn( void ) = 0;
  virtual bool                  IsReplay( void ) = 0;
};

```

`CSGO SDK/SDK/Classes/IVModelInfo.hpp`:

```hpp
#pragma once
#include "sdk.hpp"
class CGameTrace;

class IVModelInfo
{
public:
	virtual                                 ~IVModelInfo( void ) {}
	virtual const model_t* GetModel( int modelindex ) const = 0;
	virtual int                             GetModelIndex( const char* name ) const = 0;
	virtual const char* GetModelName( const model_t* model ) const = 0;
	virtual void										UNUSED( ) {};
	virtual vcollide_t* GetVCollide( const model_t* model ) const = 0;
	virtual vcollide_t* GetVCollide( int modelindex ) const = 0;
	virtual void                            GetModelBounds( const model_t* model, Vector& mins, Vector& maxs ) const = 0;
	virtual void                            GetModelRenderBounds( const model_t* model, Vector& mins, Vector& maxs ) const = 0;
	virtual int                             GetModelFrameCount( const model_t* model ) const = 0;
	virtual int                             GetModelType( const model_t* model ) const = 0;
	virtual void* GetModelExtraData( const model_t* model ) = 0;
	virtual bool                            ModelHasMaterialProxy( const model_t* model ) const = 0;
	virtual bool                            IsTranslucent( model_t const* model ) const = 0;
	virtual bool                            IsTranslucentTwoPass( const model_t* model ) const = 0;
	// virtual void                            Unused0() {};
	virtual RenderableTranslucencyType_t    ComputeTranslucencyType( const model_t* model, int nSkin, int nBody ) = 0;
	virtual int                             GetModelMaterialCount( const model_t* model ) const = 0;
	virtual void                            GetModelMaterials( const model_t* model, int count, IMaterial** ppMaterial ) = 0;
	virtual bool                            IsModelVertexLit( const model_t* model ) const = 0;
	virtual const char* GetModelKeyValueText( const model_t* model ) = 0;
	virtual bool                            GetModelKeyValue( const model_t* model, CUtlBuffer& buf ) = 0;
	virtual float                           GetModelRadius( const model_t* model ) = 0;
	virtual CStudioHdr* GetStudioHdr( MDLHandle_t handle ) = 0;
	virtual const studiohdr_t* FindModel( const studiohdr_t* pStudioHdr, void** cache, const char* modelname ) const = 0;
	virtual const studiohdr_t* FindModel( void* cache ) const = 0;
	virtual virtualmodel_t* GetVirtualModel( const studiohdr_t* pStudioHdr ) const = 0;
	virtual uint8_t* GetAnimBlock( const studiohdr_t* pStudioHdr, int iBlock ) const = 0;
	virtual void                            GetModelMaterialColorAndLighting( const model_t* model, Vector const& origin, QAngle const& angles, void* pTrace, Vector& lighting, Vector& matColor ) = 0;
	virtual void                            GetIlluminationPoint( const model_t* model, IClientRenderable* pRenderable, Vector const& origin, QAngle const& angles, Vector* pLightingCenter ) = 0;
	virtual int                             GetModelContents( int modelIndex ) const = 0;
	//virtual void										UNUSED11() {};
	virtual studiohdr_t* GetStudiomodel( const model_t* mod ) = 0;
	virtual int                             GetModelSpriteWidth( const model_t* model ) const = 0;
	virtual int                             GetModelSpriteHeight( const model_t* model ) const = 0;
	virtual void                            SetLevelScreenFadeRange( float flMinSize, float flMaxSize ) = 0;
	virtual void                            GetLevelScreenFadeRange( float* pMinArea, float* pMaxArea ) const = 0;
	virtual void                            SetViewScreenFadeRange( float flMinSize, float flMaxSize ) = 0;
	virtual unsigned char                   ComputeLevelScreenFade( const Vector& vecAbsOrigin, float flRadius, float flFadeScale ) const = 0;
	virtual unsigned char                   ComputeViewScreenFade( const Vector& vecAbsOrigin, float flRadius, float flFadeScale ) const = 0;
	virtual int                             GetAutoplayList( const studiohdr_t* pStudioHdr, unsigned short** pAutoplayList ) const = 0;
	virtual CPhysCollide* GetCollideForVirtualTerrain( int index ) = 0;
	virtual bool                            IsUsingFBTexture( const model_t* model, int nSkin, int nBody, IClientRenderable** pClientRenderable ) const = 0;
	virtual const model_t* FindOrLoadModel( const char* name ) const = 0;
	virtual MDLHandle_t                     GetCacheHandle( const model_t* model ) const = 0;
	virtual int                             GetBrushModelPlaneCount( const model_t* model ) const = 0;
	virtual void                            GetBrushModelPlane( const model_t* model, int nIndex, cplane_t& plane, Vector* pOrigin ) const = 0;
	virtual int                             GetSurfacepropsForVirtualTerrain( int index ) = 0;
	virtual bool                            UsesEnvCubemap( const model_t* model ) const = 0;
	virtual bool                            UsesStaticLighting( const model_t* model ) const = 0;
};

```

`CSGO SDK/SDK/Classes/IVModelRender.hpp`:

```hpp
#pragma once
#include "sdk.hpp"
#include "IEngineTrace.hpp"

class IMaterial
{
public:
	virtual const char*             GetName() const = 0; // 0
	virtual const char*             GetTextureGroupName() const = 0;
	virtual PreviewImageRetVal_t    GetPreviewImageProperties(int *width, int *height, ImageFormat *imageFormat, bool* isTranslucent) const = 0;
	virtual PreviewImageRetVal_t    GetPreviewImage(unsigned char *data, int width, int height, ImageFormat imageFormat) const = 0;
	virtual int                     GetMappingWidth() = 0;
	virtual int                     GetMappingHeight() = 0;
	virtual int                     GetNumAnimationFrames() = 0;
	virtual bool                    InMaterialPage(void) = 0;
	virtual    void                 GetMaterialOffset(float *pOffset) = 0;
	virtual void                    GetMaterialScale(float *pScale) = 0;
	virtual IMaterial*              GetMaterialPage(void) = 0;
	virtual IMaterialVar*           FindVar(const char *varName, bool *found, bool complain = true) = 0;
	virtual void                    IncrementReferenceCount(void) = 0;
	virtual void                    DecrementReferenceCount(void) = 0;
	inline void                     AddRef() { IncrementReferenceCount(); }
	inline void                     Release() { DecrementReferenceCount(); }
	virtual int                     GetEnumerationID(void) const = 0;
	virtual void                    GetLowResColorSample(float s, float t, float *color) const = 0;
	virtual void                    RecomputeStateSnapshots() = 0;
	virtual bool                    IsTranslucent() = 0;
	virtual bool                    IsAlphaTested() = 0;
	virtual bool                    IsVertexLit() = 0;
	virtual VertexFormat_t          GetVertexFormat() const = 0;
	virtual bool                    HasProxy(void) const = 0;
	virtual bool                    UsesEnvCubemap(void) = 0;
	virtual bool                    NeedsTangentSpace(void) = 0;
	virtual bool                    NeedsPowerOfTwoFrameBufferTexture(bool bCheckSpecificToThisFrame = true) = 0;
	virtual bool                    NeedsFullFrameBufferTexture(bool bCheckSpecificToThisFrame = true) = 0;
	virtual bool                    NeedsSoftwareSkinning(void) = 0;
	virtual void                    AlphaModulate(float alpha) = 0;
	virtual void                    ColorModulate(float r, float g, float b) = 0;
	virtual void                    SetMaterialVarFlag(MaterialVarFlags_t flag, bool on) = 0;
	virtual bool                    GetMaterialVarFlag(MaterialVarFlags_t flag) const = 0;
	virtual void                    GetReflectivity(Vector& reflect) = 0;
	virtual bool                    GetPropertyFlag(MaterialPropertyTypes_t type) = 0;
	virtual bool                    IsTwoSided() = 0;
	virtual void                    SetShader(const char *pShaderName) = 0;
	virtual int                     GetNumPasses(void) = 0;
	virtual int                     GetTextureMemoryBytes(void) = 0;
	virtual void                    Refresh() = 0;
	virtual bool                    NeedsLightmapBlendAlpha(void) = 0;
	virtual bool                    NeedsSoftwareLighting(void) = 0;
	virtual int                     ShaderParamCount() const = 0;
	virtual IMaterialVar**          GetShaderParams(void) = 0;
	virtual bool                    IsErrorMaterial() const = 0;
	virtual void                    Unused() = 0;
	virtual float                   GetAlphaModulation() = 0;
	virtual void                    GetColorModulation(float *r, float *g, float *b) = 0;
	virtual bool                    IsTranslucentUnderModulation(float fAlphaModulation = 1.0f) const = 0;
	virtual IMaterialVar*           FindVarFast(char const *pVarName, unsigned int *pToken) = 0;
	virtual void                    SetShaderAndParams(KeyValues *pKeyValues) = 0;
	virtual const char*             GetShaderName() const = 0;
	virtual void                    DeleteIfUnreferenced() = 0;
	virtual bool                    IsSpriteCard() = 0;
	virtual void                    CallBindProxy(void *proxyData) = 0;
	virtual void                    RefreshPreservingMaterialVars() = 0;
	virtual bool                    WasReloadedFromWhitelist() = 0;
	virtual bool                    SetTempExcluded(bool bSet, int nExcludedDimensionLimit) = 0;
	virtual int                     GetReferenceCount() const = 0;
};

class IVModelRender
{
public:
	virtual int                     DrawModel(int flags, IClientRenderable *pRenderable, ModelInstanceHandle_t instance, int entity_index, const model_t *model, Vector const& origin, QAngle const& angles, int skin, int body, int hitboxset, const matrix3x4_t *modelToWorld = NULL, const matrix3x4_t *pLightingOffset = NULL) = 0;
	virtual void                    ForcedMaterialOverride(IMaterial *newMaterial, OverrideType_t nOverrideType = 0, int nOverrides = 0) = 0;
	virtual bool                    IsForcedMaterialOverride(void) = 0;
	virtual void                    SetViewTarget(const studiohdr_t *pStudioHdr, int nBodyIndex, const Vector& target) = 0;
	virtual ModelInstanceHandle_t   CreateInstance(IClientRenderable *pRenderable, LightCacheHandle_t *pCache = NULL) = 0;
	virtual void                    DestroyInstance(ModelInstanceHandle_t handle) = 0;
	virtual void                    SetStaticLighting(ModelInstanceHandle_t handle, LightCacheHandle_t* pHandle) = 0;
	virtual LightCacheHandle_t      GetStaticLighting(ModelInstanceHandle_t handle) = 0;
	virtual bool                    ChangeInstance(ModelInstanceHandle_t handle, IClientRenderable *pRenderable) = 0;
	virtual void                    AddDecal(ModelInstanceHandle_t handle, void* const& ray, Vector const& decalUp, int decalIndex, int body, bool noPokeThru, int maxLODToDecal) = 0;
	virtual void                    RemoveAllDecals(ModelInstanceHandle_t handle) = 0;
	virtual bool                    ModelHasDecals(ModelInstanceHandle_t handle) = 0;
	virtual void                    RemoveAllDecalsFromAllModels() = 0;
	virtual matrix3x4_t*            DrawModelShadowSetup(IClientRenderable *pRenderable, int body, int skin, DrawModelInfo_t *pInfo, matrix3x4_t *pCustomBoneToWorld = NULL) = 0;
	virtual void                    DrawModelShadow(IClientRenderable *pRenderable, const DrawModelInfo_t &info, matrix3x4_t *pCustomBoneToWorld = NULL) = 0;
	virtual bool                    RecomputeStaticLighting(ModelInstanceHandle_t handle) = 0;
	virtual void                    ReleaseAllStaticPropColorData(void) = 0;
	virtual void                    RestoreAllStaticPropColorData(void) = 0;
	virtual int                     DrawModelEx(ModelRenderInfo_t &pInfo) = 0;
	virtual int                     DrawModelExStaticProp(ModelRenderInfo_t &pInfo) = 0;
	virtual bool                    DrawModelSetup(ModelRenderInfo_t &pInfo, DrawModelState_t *pState, matrix3x4_t **ppBoneToWorldOut) = 0;
	virtual void                    DrawModelExecute(IMatRenderContext* ctx, const DrawModelState_t& state, const ModelRenderInfo_t& pInfo, matrix3x4_t* pCustomBoneToWorld = NULL) = 0;
	virtual void                    SetupLighting(const Vector &vecCenter) = 0;
	virtual int                     DrawStaticPropArrayFast(StaticPropRenderInfo_t *pProps, int count, bool bShadowDepth) = 0;
	virtual void                    SuppressEngineLighting(bool bSuppress) = 0;
	virtual void                    SetupColorMeshes(int nTotalVerts) = 0;
	virtual void                    SetupLightingEx(const Vector &vecCenter, ModelInstanceHandle_t handle) = 0;
	virtual bool                    GetBrightestShadowingLightSource(const Vector &vecCenter, Vector& lightPos, Vector& lightBrightness, bool bAllowNonTaggedLights) = 0;
	virtual void                    ComputeLightingState(int nCount, const LightingQuery_t *pQuery, MaterialLightingState_t *pState, ITexture **ppEnvCubemapTexture) = 0;
	virtual void                    GetModelDecalHandles(StudioDecalHandle_t *pDecals, int nDecalStride, int nCount, const ModelInstanceHandle_t *pHandles) = 0;
	virtual void                    ComputeStaticLightingState(int nCount, const StaticLightingQuery_t *pQuery, MaterialLightingState_t *pState, MaterialLightingState_t *pDecalState, ColorMeshInfo_t **ppStaticLighting, ITexture **ppEnvCubemapTexture, DataCacheHandle_t *pColorMeshHandles) = 0;
	virtual void                    CleanupStaticLightingState(int nCount, DataCacheHandle_t *pColorMeshHandles) = 0;
};

```

`CSGO SDK/SDK/Classes/IVRenderView.hpp`:

```hpp
#pragma once
#include "sdk.hpp"

enum
{
  INVALID_LEAF_INDEX = (LeafIndex_t)~0
};

struct WorldListLeafData_t
{
  LeafIndex_t     leafIndex;    // 16 bits
  int16_t         waterData;
  uint16_t        firstTranslucentSurface;    // engine-internal list index
  uint16_t        translucentSurfaceCount;    // count of translucent surfaces+disps
};

struct WorldListInfo_t
{
  int                     m_ViewFogVolume;
  int                     m_LeafCount;
  bool                    m_bHasWater;
  WorldListLeafData_t*    m_pLeafDataList;
};

class IWorldRenderList
{
};

struct VisibleFogVolumeInfo_t
{
  int            m_nVisibleFogVolume;
  int            m_nVisibleFogVolumeLeaf;
  bool        m_bEyeInFogVolume;
  float       m_flDistanceToWater;
  float       m_flWaterHeight;
  IMaterial*  m_pFogVolumeMaterial;
};

struct BrushVertex_t
{
  Vector        m_Pos;
  Vector        m_Normal;
  Vector        m_TangentS;
  Vector        m_TangentT;
  Vector2D    m_TexCoord;
  Vector2D    m_LightmapCoord;

private:
  BrushVertex_t(const BrushVertex_t& src);
};

struct VisOverrideData_t
{
  Vector        m_vecVisOrigin;                    // The point to to use as the viewpoint for area portal backface cull checks.
  float        m_fDistToAreaPortalTolerance;    // The distance from an area portal before using the full screen as the viewable portion.
};

class IBrushSurface
{
public:
  // Computes texture coordinates + lightmap coordinates given a world position
  virtual void ComputeTextureCoordinate(Vector const& worldPos, Vector2D& texCoord) = 0;
  virtual void ComputeLightmapCoordinate(Vector const& worldPos, Vector2D& lightmapCoord) = 0;

  // Gets the vertex data for this surface
  virtual int  GetVertexCount() const = 0;
  virtual void GetVertexData(BrushVertex_t* pVerts) = 0;

  // Gets at the material properties for this surface
  virtual IMaterial* GetMaterial() = 0;
};

class IBrushRenderer
{
public:
  // Draws the surface; returns true if decals should be rendered on this surface
  virtual bool RenderBrushModelSurface(IClientEntity* pBaseEntity, IBrushSurface* pBrushSurface) = 0;
};

class IVRenderView
{
  enum
  {
	 VIEW_SETUP_VIS_EX_RETURN_FLAGS_USES_RADIAL_VIS = 0x00000001
  };
public:
  virtual void                DrawBrushModel(IClientEntity *baseentity, model_t *model, const Vector& origin, const QAngle& angles, bool sort) = 0;
  virtual void                DrawIdentityBrushModel(IWorldRenderList *pList, model_t *model) = 0;
  virtual void                TouchLight(struct dlight_t *light) = 0;
  virtual void                Draw3DDebugOverlays(void) = 0;
  virtual void                SetBlend(float blend) = 0;
  virtual float               GetBlend(void) = 0;
  virtual void                SetColorModulation(float const* blend) = 0;
  inline void                 SetColorModulation(float r, float g, float b)
  {
	 float clr[3] = { r, g, b };
	 SetColorModulation(clr);
  }
  virtual void                GetColorModulation(float* blend) = 0;
  virtual void                SceneBegin(void) = 0;
  virtual void                SceneEnd(void) = 0;
  virtual void                GetVisibleFogVolume(const Vector& eyePoint, VisibleFogVolumeInfo_t *pInfo) = 0;
  virtual IWorldRenderList*   CreateWorldList() = 0;
  virtual void                BuildWorldLists(IWorldRenderList *pList, WorldListInfo_t* pInfo, int iForceFViewLeaf, const VisOverrideData_t* pVisData = NULL, bool bShadowDepth = false, float *pReflectionWaterHeight = NULL) = 0;
  virtual void                DrawWorldLists(IWorldRenderList *pList, unsigned long flags, float waterZAdjust) = 0;
  virtual int                 GetNumIndicesForWorldLists(IWorldRenderList *pList, unsigned long nFlags) = 0;
  virtual void                DrawTopView(bool enable) = 0;
  virtual void                TopViewBounds(Vector2D const& mins, Vector2D const& maxs) = 0;
  virtual void                DrawLights(void) = 0;
  virtual void                DrawMaskEntities(void) = 0;
  virtual void                DrawTranslucentSurfaces(IWorldRenderList *pList, int *pSortList, int sortCount, unsigned long flags) = 0;
  virtual void                DrawLineFile(void) = 0;
  virtual void                DrawLightmaps(IWorldRenderList *pList, int pageId) = 0;
  virtual void                ViewSetupVis(bool novis, int numorigins, const Vector origin[]) = 0;
  virtual bool                AreAnyLeavesVisible(int *leafList, int nLeaves) = 0;
  virtual    void             VguiPaint(void) = 0;
  virtual void                ViewDrawFade(uint8_t *color, IMaterial *pMaterial) = 0;
  virtual void                OLD_SetProjectionMatrix(float fov, float zNear, float zFar) = 0;
  virtual unsigned long       GetLightAtPoint(Vector& pos) = 0;
  virtual int                 GetViewEntity(void) = 0;
  virtual bool                IsViewEntity(int entindex) = 0;
  virtual float               GetFieldOfView(void) = 0;
  virtual unsigned char**     GetAreaBits(void) = 0;
  virtual void                SetFogVolumeState(int nVisibleFogVolume, bool bUseHeightFog) = 0;
  virtual void                InstallBrushSurfaceRenderer(IBrushRenderer* pBrushRenderer) = 0;
  virtual void                DrawBrushModelShadow(IClientRenderable *pRenderable) = 0;
  virtual    bool             LeafContainsTranslucentSurfaces(IWorldRenderList *pList, int sortIndex, unsigned long flags) = 0;
  virtual bool                DoesBoxIntersectWaterVolume(const Vector &mins, const Vector &maxs, int leafWaterDataID) = 0;
  virtual void                SetAreaState(unsigned char chAreaBits[MAX_AREA_STATE_BYTES], unsigned char chAreaPortalBits[MAX_AREA_PORTAL_STATE_BYTES]) = 0;
  virtual void                VGui_Paint(int mode) = 0;
  virtual void                Push3DView(const CViewSetup &view, int nFlags, ITexture* pRenderTarget, Frustum frustumPlanes) = 0;
  virtual void                Push2DView(const CViewSetup &view, int nFlags, ITexture* pRenderTarget, Frustum frustumPlanes) = 0;
  virtual void                PopView(Frustum frustumPlanes) = 0;
  virtual void                SetMainView(const Vector &vecOrigin, const QAngle &angles) = 0;
  virtual void                ViewSetupVisEx(bool novis, int numorigins, const Vector origin[], unsigned int &returnFlags) = 0;
  virtual void                OverrideViewFrustum(Frustum custom) = 0;
  virtual void                DrawBrushModelShadowDepth(IClientEntity *baseentity, model_t *model, const Vector& origin, const QAngle& angles, bool bSort) = 0;
  virtual void                UpdateBrushModelLightmap(model_t *model, IClientRenderable *pRenderable) = 0;
  virtual void                BeginUpdateLightmaps(void) = 0;
  virtual void                EndUpdateLightmaps(void) = 0;
  virtual void                OLD_SetOffCenterProjectionMatrix(float fov, float zNear, float zFar, float flAspectRatio, float flBottom, float flTop, float flLeft, float flRight) = 0;
  virtual void                OLD_SetProjectionMatrixOrtho(float left, float top, float right, float bottom, float zNear, float zFar) = 0;
  virtual void                Push3DView(const CViewSetup &view, int nFlags, ITexture* pRenderTarget, Frustum frustumPlanes, ITexture* pDepthTexture) = 0;
  virtual void                GetMatricesForView(const CViewSetup &view, VMatrix *pWorldToView, VMatrix *pViewToProjection, VMatrix *pWorldToProjection, VMatrix *pWorldToPixels) = 0;
};
```

`CSGO SDK/SDK/Classes/IViewRender.hpp`:

```hpp
#pragma once
struct vrect_t;
class IViewRender {
public:
   virtual void                Init( void ) = 0;
   virtual void                LevelInit( void ) = 0;
   virtual void                LevelShutdown( void ) = 0;
   virtual void                Shutdown( void ) = 0;
   virtual void                OnRenderStart( ) = 0;
   virtual	void                Render( vrect_t* rect ) = 0;
   virtual void                RenderView( const CViewSetup& view, int nClearFlags, int whatToDraw ) = 0;
   virtual int                 GetDrawFlags( ) = 0;
   virtual void                StartPitchDrift( void ) = 0;
   virtual void                StopPitchDrift( void ) = 0;
   virtual void* GetFrustum( ) = 0;
   virtual bool                ShouldDrawBrushModels( void ) = 0;
   virtual const CViewSetup* GetPlayerViewSetup( void ) const = 0;
   virtual const CViewSetup* GetViewSetup( void ) const = 0;
   virtual void                DisableVis( void ) = 0;
   virtual int                 BuildWorldListsNumber( ) const = 0;
   virtual void                SetCheapWaterStartDistance( float flCheapWaterStartDistance ) = 0;
   virtual void                SetCheapWaterEndDistance( float flCheapWaterEndDistance ) = 0;
   virtual void                GetWaterLODParams( float& flCheapWaterStartDistance, float& flCheapWaterEndDistance ) = 0;
   virtual void                DriftPitch( void ) = 0;
   virtual void                SetScreenOverlayMaterial( IMaterial* pMaterial ) = 0;
   virtual IMaterial* GetScreenOverlayMaterial( ) = 0;
   virtual void                WriteSaveGameScreenshot( const char* pFilename ) = 0;
   virtual void                WriteSaveGameScreenshotOfSize( const char* pFilename, int width, int height ) = 0;
   virtual void                QueueOverlayRenderView( const CViewSetup& view, int nClearFlags, int whatToDraw ) = 0;
   virtual float               GetZNear( ) = 0;
   virtual float               GetZFar( ) = 0;
   virtual void                GetScreenFadeDistances( float* min, float* max ) = 0;
   virtual C_BaseEntity* GetCurrentlyDrawingEntity( ) = 0;
   virtual void               SetCurrentlyDrawingEntity( C_BaseEntity* pEnt ) = 0;
};
```

`CSGO SDK/SDK/Classes/IViewRenderBeams.hpp`:

```hpp
#pragma once
#include "sdk.hpp"

class ITraceFilter;

class Beam_t
{
public:
  Beam_t();

  // Methods of IClientRenderable
  virtual const Vector&	GetRenderOrigin(void) = 0;
  virtual const QAngle&	GetRenderAngles(void) = 0;
  virtual const matrix3x4_t &RenderableToWorldTransform() = 0;
  virtual void			GetRenderBounds(Vector& mins, Vector& maxs) = 0;
  virtual bool			ShouldDraw(void) = 0;
  virtual bool			IsTransparent(void) = 0;
  virtual int				DrawModel(int flags) = 0;
  virtual void			ComputeFxBlend() = 0;
  virtual int				GetFxBlend() = 0;

  // Resets the beam state
  void			Reset();

  // Method to computing the bounding box
  void			ComputeBounds();

  // Bounding box...
  Vector			m_Mins;
  Vector			m_Maxs;
  pixelvis_handle_t *m_queryHandleHalo;
  float			m_haloProxySize;

  // Data is below..

  // Next beam in list
  Beam_t*			next;

  // Type of beam
  int				type;
  int				flags;

  // Control points for the beam
  int				numAttachments;
  Vector			attachment[MAX_BEAM_ENTS];
  Vector			delta;

  // 0 .. 1 over lifetime of beam
  float			t;
  float			freq;

  // Time when beam should die
  float			die;
  float			width;
  float			endWidth;
  float			fadeLength;
  float			amplitude;
  float			life;

  // Color
  float			r, g, b;
  float			brightness;

  // Speed
  float			speed;

  // Animation
  float			frameRate;
  float			frame;
  int				segments;

  // Attachment entities for the beam
  HANDLE			entity[MAX_BEAM_ENTS];
  int				attachmentIndex[MAX_BEAM_ENTS];

  // Model info
  int				modelIndex;
  int				haloIndex;

  float			haloScale;
  int				frameCount;

  float			rgNoise[NOISE_DIVISIONS + 1];

  // Popcorn trail for beam follows to use
  BeamTrail_t*	trail;

  // for TE_BEAMRINGPOINT
  float			start_radius;
  float			end_radius;

  // for FBEAM_ONLYNOISEONCE
  bool			m_bCalculatedNoise;

  float			m_flHDRColorScale;

};

class IViewRenderBeams
{
public:
  virtual void	InitBeams(void) = 0;
  virtual void	ShutdownBeams(void) = 0;
  virtual void	ClearBeams(void) = 0;

  // Updates the state of the temp ent beams
  virtual void	UpdateTempEntBeams() = 0;

  virtual void	DrawBeam(C_Beam* pbeam, ITraceFilter *pEntityBeamTraceFilter = NULL) = 0;
  virtual void	DrawBeam(Beam_t *pbeam) = 0;

  virtual void	KillDeadBeams(C_BaseEntity *pEnt) = 0;

  // New interfaces!
  virtual Beam_t	*CreateBeamEnts(BeamInfo_t &beamInfo) = 0;
  virtual Beam_t	*CreateBeamEntPoint(BeamInfo_t &beamInfo) = 0;
  virtual	Beam_t	*CreateBeamPoints(BeamInfo_t &beamInfo) = 0;
  virtual Beam_t	*CreateBeamRing(BeamInfo_t &beamInfo) = 0;
  virtual Beam_t	*CreateBeamRingPoint(BeamInfo_t &beamInfo) = 0;
  virtual Beam_t	*CreateBeamCirclePoints(BeamInfo_t &beamInfo) = 0;
  virtual Beam_t	*CreateBeamFollow(BeamInfo_t &beamInfo) = 0;

  virtual void	FreeBeam(Beam_t *pBeam) = 0;
  virtual void	UpdateBeamInfo(Beam_t *pBeam, BeamInfo_t &beamInfo) = 0;

  // These will go away!
  virtual void	CreateBeamEnts(int startEnt, int endEnt, int modelIndex, int haloIndex, float haloScale,
	 float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
	 float brightness, float speed, int startFrame,
	 float framerate, float r, float g, float b, int type = -1) = 0;
  virtual void	CreateBeamEntPoint(int	nStartEntity, const Vector *pStart, int nEndEntity, const Vector* pEnd,
	 int modelIndex, int haloIndex, float haloScale,
	 float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
	 float brightness, float speed, int startFrame,
	 float framerate, float r, float g, float b) = 0;
  virtual void	CreateBeamPoints(Vector& start, Vector& end, int modelIndex, int haloIndex, float haloScale,
	 float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
	 float brightness, float speed, int startFrame,
	 float framerate, float r, float g, float b) = 0;
  virtual void	CreateBeamRing(int startEnt, int endEnt, int modelIndex, int haloIndex, float haloScale,
	 float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
	 float brightness, float speed, int startFrame,
	 float framerate, float r, float g, float b, int flags = 0) = 0;
  virtual void	CreateBeamRingPoint(const Vector& center, float start_radius, float end_radius, int modelIndex, int haloIndex, float haloScale,
	 float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
	 float brightness, float speed, int startFrame,
	 float framerate, float r, float g, float b, int flags = 0) = 0;
  virtual void	CreateBeamCirclePoints(int type, Vector& start, Vector& end,
	 int modelIndex, int haloIndex, float haloScale, float life, float width,
	 float m_nEndWidth, float m_nFadeLength, float amplitude, float brightness, float speed,
	 int startFrame, float framerate, float r, float g, float b) = 0;
  virtual void	CreateBeamFollow(int startEnt, int modelIndex, int haloIndex, float haloScale,
	 float life, float width, float m_nEndWidth, float m_nFadeLength, float r, float g, float b,
	 float brightness) = 0;
};

```

`CSGO SDK/SDK/Classes/Player.cpp`:

```cpp
#include "player.hpp"
#include "../displacement.hpp"
#include "../source.hpp"
#include "weapon.hpp"
#include "../../Features/Rage/TickbaseShift.hpp"

QAngle& C_BasePlayer::m_aimPunchAngle( ) {
	return *( QAngle* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_aimPunchAngle );
}

QAngle& C_BasePlayer::m_aimPunchAngleVel( ) {
	return *( QAngle* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_aimPunchAngleVel );
}

QAngle& C_BasePlayer::m_viewPunchAngle( ) {
	return *( QAngle* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_viewPunchAngle );
}

Vector& C_BasePlayer::m_vecViewOffset( ) {
	return *( Vector* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_vecViewOffset );
}
Vector& C_BasePlayer::m_vecVelocity( ) {
	return *( Vector* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_vecVelocity );
}

Vector& C_BasePlayer::m_vecBaseVelocity( ) {
	return *( Vector* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_vecBaseVelocity );
}

float& C_BasePlayer::m_flFallVelocity( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_flFallVelocity );
}

float& C_BasePlayer::m_flDuckAmount( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_flDuckAmount );
}

float& C_BasePlayer::m_flDuckSpeed( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_flDuckSpeed );
}

char& C_BasePlayer::m_lifeState( ) {
	return *( char* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_lifeState );
}

int& C_BasePlayer::m_nTickBase( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_nTickBase );
}

int& C_BasePlayer::m_iHealth( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_iHealth );
}

int& C_BasePlayer::m_fFlags( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_fFlags );
}

int& C_BasePlayer::m_iDefaultFOV( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_iDefaultFOV );
}

int& C_BasePlayer::m_iObserverMode( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_iObserverMode );
}

bool& C_BasePlayer::m_bSpotted() {
	return *(bool*)((uintptr_t)this + Engine::Displacement.DT_BasePlayer.m_bSpotted);
}

CPlayerState& C_BasePlayer::pl( ) {
	return *( CPlayerState* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.pl );
}

CBaseHandle& C_BasePlayer::m_hObserverTarget( ) {
	return *( CBaseHandle* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_hObserverTarget );
}

CHandle<C_BaseViewModel> C_BasePlayer::m_hViewModel( ) {
	return *( CHandle<C_BaseViewModel>* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_hViewModel );
}

int& C_BasePlayer::m_vphysicsCollisionState( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_BasePlayer.m_vphysicsCollisionState );
}

float C_BasePlayer::GetMaxSpeed( ) {
	if( !this )
		return 250.0f;

	auto hWeapon = this->m_hActiveWeapon( );
	if( hWeapon == -1 )
		return 250.0f;

	auto pWeapon = reinterpret_cast< C_WeaponCSBaseGun* >( this->m_hActiveWeapon( ).Get( ) );
	if( !pWeapon )
		return 250.0f;

	auto pWeaponData = pWeapon->GetCSWeaponData( );
	if( !pWeaponData.IsValid( ) )
		return 250.0f;

	if( pWeapon->m_zoomLevel( ) == 0 )
		return pWeaponData->m_flMaxSpeed;

	return pWeaponData->m_flMaxSpeed2;
}


float C_BasePlayer::SequenceDuration( CStudioHdr* pStudioHdr, int iSequence ) {
	//55 8B EC 53 57 8B 7D 08 8B D9 85 FF 75 double __userpurge SequenceDuration@<st0>(int a1@<ecx>, float a2@<xmm0>, int *a3, int a4)
	using SequenceDurationFn = float( __thiscall* )( void*, CStudioHdr*, int );
	return Memory::VCall< SequenceDurationFn >( this, 221 )( this, pStudioHdr, iSequence );
}

const Vector& C_BasePlayer::WorldSpaceCenter( ) {
	using WorldSpaceCenterFn = const Vector& ( __thiscall* )( void* );
	return Memory::VCall< WorldSpaceCenterFn >( this, 78 )( this );
}

float C_BasePlayer::GetSequenceMoveDist( CStudioHdr* pStudioHdr, int iSequence ) {
	Vector vecReturn;

	auto rel_32_fix = [ ] ( uintptr_t ptr ) -> uintptr_t { // TODO: Move this to displacement
		auto offset = *( uintptr_t* )( ptr + 0x1 );
		return ( uintptr_t )( ptr + 5 + offset );
	};

	// int __usercall GetSequenceLinearMotion@<eax>(int a1@<edx>, _DWORD *a2@<ecx>, int a3, _DWORD *a4)
	// it fastcall, but edx and ecx swaped
	// xref: Bad pstudiohdr in GetSequenceLinearMotion()!\n | Bad sequence (%i out of %i max) in GetSequenceLinearMotion() for model '%s'!\n
	static uintptr_t ptr = rel_32_fix( Memory::Scan( XorStr( "client.dll" ), XorStr( "E8 ? ? ? ? F3 0F 10 4D ? 83 C4 08 F3 0F 10 45 ? F3 0F 59 C0" ) ) );


	using GetSequenceLinearMotionFn = int( __fastcall* )( CStudioHdr*, int, float*, Vector* );
	( ( GetSequenceLinearMotionFn )ptr )( pStudioHdr, iSequence, m_flPoseParameter( ), &vecReturn );
	__asm {
		add esp, 8
	}
	return vecReturn.Length( );
}

bool C_BasePlayer::IsDead( ) {
	return ( this->m_lifeState( ) );
}

void C_BasePlayer::SetCurrentCommand( CUserCmd* cmd ) {
	*( CUserCmd** )( ( uintptr_t )this + Engine::Displacement.C_BasePlayer.m_pCurrentCommand ) = cmd;
}

Vector C_BasePlayer::GetEyePosition( ) {
	Vector vecOrigin = this->GetAbsOrigin( );

	Vector offset = m_vecViewOffset( );
	if( offset.z >= 46.1f ) {
		if( offset.z > 64.0f ) {
			offset.z = 64.0f;
		}
	}
	else {
		offset.z = 46.0f;
	}
	vecOrigin += offset;

	return vecOrigin;
}

Vector C_BasePlayer::GetViewHeight( ) {
	Vector offset;
	if( this->m_flDuckAmount( ) == 0.0f ) {
		offset = Interfaces::m_pGameMovement->GetPlayerViewOffset( false );
	}
	else {
		offset = m_vecViewOffset( );
	}
	return offset;
}

float C_BasePlayer::GetLayerSequenceCycleRate( C_AnimationLayer* pLayer, int iSequence ) {
	using GetLayerSequenceCycleRateFn = float( __thiscall* )( void*, C_AnimationLayer*, int );
	return Memory::VCall< GetLayerSequenceCycleRateFn >( this, 222 )( this, pLayer, iSequence );
}

C_AnimationLayer& C_BasePlayer::GetAnimLayer( int index ) {
	// ref: CCBaseEntityAnimState::ComputePoseParam_MoveYaw
	// move_x move_y move_yaw
	typedef C_AnimationLayer& ( __thiscall* Fn )( void*, int, bool );
	static Fn fn = NULL;

	if( !fn )
		fn = ( Fn )Memory::Scan( XorStr( "client.dll" ), XorStr( "55 8B EC 57 8B F9 8B 97 ? ? ? ? 85 D2" ) );

	index = Math::Clamp( index, 0, 13 );

	return fn( this, index, true );
}

// L3D451R7, raxer23 (c)
void C_BasePlayer::TryInitiateAnimation( C_AnimationLayer* pLayer, int nSequence ) {
	if( !pLayer || nSequence < 2 )
		return;

	pLayer->m_flPlaybackRate = GetLayerSequenceCycleRate( pLayer, nSequence );
	pLayer->m_nSequence = nSequence;
	pLayer->m_flCycle = pLayer->m_flWeight = 0.f;
};

C_CSPlayer* C_CSPlayer::GetLocalPlayer( ) {
	auto index = Interfaces::m_pEngine->GetLocalPlayer( );

	if( !index )
		return nullptr;

	auto client = Interfaces::m_pEntList->GetClientEntity( index );

	if( !client )
		return nullptr;

	return ToCSPlayer( client->GetBaseEntity( ) );
}

C_CSPlayer* C_CSPlayer::GetPlayerByIndex( int index ) {
	if( !index )
		return nullptr;

	auto client = Interfaces::m_pEntList->GetClientEntity( index );

	if( !client )
		return nullptr;

	return ToCSPlayer( client->GetBaseEntity( ) );
}

std::array<int, 5>& C_CSPlayer::m_vecPlayerPatchEconIndices( )
{
	return *( std::array<int, 5>* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_vecPlayerPatchEconIndices );
}

CCSGOPlayerAnimState*& C_CSPlayer::m_PlayerAnimState( ) {
	return *( CCSGOPlayerAnimState** )( ( uintptr_t )this + Engine::Displacement.C_CSPlayer.m_PlayerAnimState );
}

QAngle& C_CSPlayer::m_angEyeAngles( ) {
	return *( QAngle* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_angEyeAngles );
}

int& C_CSPlayer::m_nSurvivalTeam( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_nSurvivalTeam );
}

int& C_CSPlayer::m_ArmorValue( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_ArmorValue );
}

int& C_CSPlayer::m_iAccount( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_iAccount );
}

int& C_CSPlayer::m_iFOV( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_iFOV );
}

int& C_CSPlayer::m_iShotsFired( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_iShotsFired );
}

float& C_CSPlayer::m_flFlashDuration( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_flFlashDuration );
}

float& C_CSPlayer::m_flSecondFlashAlpha( ) {
	return *( float* )( uintptr_t( this ) + Engine::Displacement.DT_CSPlayer.m_flFlashDuration - 0xC );
}

float& C_CSPlayer::m_flVelocityModifier( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_flVelocityModifier );
}

float& C_CSPlayer::m_flLowerBodyYawTarget( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_flLowerBodyYawTarget );
}

float& C_CSPlayer::m_flSpawnTime( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.C_CSPlayer.m_flSpawnTime );
}

float& C_CSPlayer::m_flHealthShotBoostExpirationTime( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_flHealthShotBoostExpirationTime );
}

bool& C_CSPlayer::m_bHasHelmet( ) {
	return *( bool* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_bHasHelmet );
}

bool& C_CSPlayer::m_bHasHeavyArmor( ) {
	return *( bool* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_bHasHeavyArmor );
}

bool& C_CSPlayer::m_bIsScoped( ) {
	return *( bool* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_bScoped );
}

bool& C_CSPlayer::m_bWaitForNoAttack( ) {
	return *( bool* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_bWaitForNoAttack );
}

bool& C_CSPlayer::m_bIsPlayerGhost( )
{
	return *( bool* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_bIsPlayerGhost );
}

int& C_CSPlayer::m_iMatchStats_Kills( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_iMatchStats_Kills );
}

int& C_CSPlayer::m_iMatchStats_Deaths( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_iMatchStats_Deaths );
}

int& C_CSPlayer::m_iMatchStats_HeadShotKills( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_iMatchStats_HeadShotKills );
}

bool& C_CSPlayer::m_bGunGameImmunity( ) {
	return *( bool* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_bGunGameImmunity );
}

bool& C_CSPlayer::m_bIsDefusing( ) {
	return *( bool* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_bIsDefusing );
}

bool& C_CSPlayer::m_bHasDefuser( ) {
	return *( bool* )( ( uintptr_t )this + Engine::Displacement.DT_CSPlayer.m_bHasDefuser );
}

bool C_CSPlayer::PhysicsRunThink( int unk01 ) {
	static auto impl_PhysicsRunThink = ( bool( __thiscall* )( void*, int ) )Engine::Displacement.Function.m_uImplPhysicsRunThink;
	return impl_PhysicsRunThink( this, unk01 );
}

int C_CSPlayer::SetNextThink( int tick ) {
	static const auto next_think = Memory::Scan( XorStr( "client.dll" ), XorStr( "55 8B EC 56 57 8B F9 8B B7 E8" ) );

	typedef int( __thiscall* fnSetNextThink ) ( C_CSPlayer*, int tick );
	auto ret = ( ( fnSetNextThink )next_think ) ( this, tick );
	return ret;
}

void C_CSPlayer::Think( ) {
	static auto index = *( int* )( Memory::Scan( XorStr( "client.dll" ), XorStr( "FF 90 ? ? ? ? FF 35 ? ? ? ? 8B 4C 24 3C" ) ) + 2 ) / 4; // ref: CPrediction::ProcessMovement  (*(void (__thiscall **)(_DWORD *))(*player + 552))(player);
	//xref CPrediction::ProcessMovement (*(void (__thiscall **)(_DWORD *))(*a2 + 552))(a2);
	using Fn = void( __thiscall* )( void* );
	Memory::VCall<Fn>( this, 137 )( this ); // 139
}

void C_CSPlayer::PreThink( ) {
	static auto index = *( int* )( Memory::Scan( XorStr( "client.dll" ), XorStr( "FF 90 ? ? ? ? 8B 86 ? ? ? ? 83 F8 FF" ) ) + 2 ) / 4;
	//xref CPrediction::ProcessMovement 
	// if ( (unsigned __int8)sub_102FED00(0) )
	// (*(void (__thiscall **)(_DWORD *))(*a2 + 1268))(a2);
	using Fn = void( __thiscall* )( void* );
	Memory::VCall<Fn>( this, 307 )( this ); // 169
}

void C_CSPlayer::PostThink( ) {
	using Fn = void( __thiscall* )( void* );
	Memory::VCall<Fn>( this, /*316*/ 308 )( this );
}

bool C_CSPlayer::is( std::string networkname )
{
	auto& propmanager = Engine::PropManager::Instance( );

	auto clientClass = this->GetClientClass( );
	if( !clientClass )
		return false;

	return propmanager.GetClientID( networkname ) == clientClass->m_ClassID;
}

bool C_CSPlayer::IsTeammate( C_CSPlayer* player ) {
	if( !player || !this )
		return false;

	return this->m_iTeamNum( ) == player->m_iTeamNum( );
}

bool C_CSPlayer::CanShoot( bool bSkipRevolver ) {
	bool local = EntIndex( ) == Interfaces::m_pEngine->GetLocalPlayer( );

	auto weapon = ( C_WeaponCSBaseGun* )( this->m_hActiveWeapon( ).Get( ) );
	if( !weapon )
		return false;

	auto weapon_data = weapon->GetCSWeaponData( );
	if( !weapon_data.IsValid( ) )
		return false;

	auto g_GameRules = *( uintptr_t** )( Engine::Displacement.Data.m_GameRules );
	if( !g_GameRules )
		return false;

	if( weapon->m_iItemDefinitionIndex( ) != WEAPON_REVOLVER ) {
		if( g_Vars.globals.WasShootingInChokeCycle || g_Vars.globals.WasShooting && local )
			return false;
	}

	if( this->m_fFlags( ) & 0x40 )
		return false;

	if( *( bool* )( *( uintptr_t* )g_GameRules + 0x20 ) )
		return false;

	if( this->m_bWaitForNoAttack( ) )
		return false;

	if( *( int* )( uintptr_t( this ) + Engine::Displacement.DT_CSPlayer.m_iPlayerState ) )
		return false;

	if( this->m_bIsDefusing() )
		return false;

	if( this->IsReloading( ) )
		return false;

	if( weapon_data->m_iWeaponType >= WEAPONTYPE_PISTOL && weapon_data->m_iWeaponType <= WEAPONTYPE_MACHINEGUN && weapon->m_iClip1( ) < 1 )
		return false;

	float curtime = TICKS_TO_TIME( this->m_nTickBase( ) );
	if( curtime < m_flNextAttack( ) )
		return false;

	if( ( weapon->m_iItemDefinitionIndex( ) == WEAPON_GLOCK || weapon->m_iItemDefinitionIndex( ) == WEAPON_FAMAS ) && weapon->m_iBurstShotsRemaining( ) > 0 ) {
		if( curtime >= weapon->m_fNextBurstShot( ) )
			return true;
	}

	if( curtime < weapon->m_flNextPrimaryAttack( ) )
		return false;

	if( weapon->m_iItemDefinitionIndex( ) != WEAPON_REVOLVER )
		return true;

	if( bSkipRevolver )
		return true;

	if( *( int* )( uintptr_t( weapon ) + Engine::Displacement.DT_BaseAnimating.m_nSequence ) != 5 )
		return false;

	return curtime >= weapon->m_flPostponeFireReadyTime( );
}

bool C_CSPlayer::IsReloading( ) {
	auto animLayer = this->m_AnimOverlay( ).Element( 1 );
	if( !animLayer.m_pOwner )
		return false;

	return GetSequenceActivity( animLayer.m_nSequence ) == 967 && animLayer.m_flWeight != 0.f;
}

void CCSGOPlayerAnimState::ModifyEyePosition( CCSGOPlayerAnimState *pState, Vector *pos ) {
	/* NOTE FROM ALPHA:
	 * Although I had the choice to paste this from DucaRii and be done with it, I wanted to avoid that as much as i possibly can
	 * Tt's super easy to get to this function - throw server.dll into IDA, open strings view and search for "head_0"
	 * find xrefs to it (there should be 3 in total: https://i.imgur.com/n4Uguxo.png) and pick the 3rd one (call to CCSGOPlayerAnimState::ModifyEyePosition)
	 * boom you're here
	 */

	if( !pState || !pState->m_Player ) {
		return;
	}

	// If this sig ever goes out of date, refer to the instructions above to get into here and sig this:
	// https://i.imgur.com/zGnqd3y.png
	static auto C_BaseAnimating__LookupBone = *reinterpret_cast< int( __thiscall * )( void *, const char * ) >( Memory::Scan( XorStr( "client.dll" ), XorStr( "55 8B EC 53 56 8B F1 57 83 BE ?? ?? ?? ?? ?? 75 14" ) ) );

	if( pState->m_Player && pState->m_bHitground || pState->m_fDuckAmount != 0.f ) {
		// this returns 8 but i'd rather grab it dynamically in the rare event of it changing
		auto v5 = C_BaseAnimating__LookupBone( pState->m_Player, XorStr( "head_0" ) );

		if( v5 != -1 ) {
			auto v12 = ( reinterpret_cast< C_CSPlayer * >( pState->m_Player ) )->GetBonePos( v5 );
			auto v7 = v12.z + 1.7;

			auto v8 = pos->z;
			if( v8 > v7 ) // if (v8 > (v12 + 1.7))
			{
				float v13 = 0.f;
				float v3 = ( *pos ).z - v7;

				// changed this from float division to float multiplication cos its faster
				float v4 = ( v3 - 4.f ) * 0.16666667;
				if( v4 >= 0.f )
					v13 = std::fminf( v4, 1.f );

				( *pos ).z += ( ( v7 - ( *pos ).z ) * ( ( ( v13 * v13 ) * 3.f ) - ( ( ( v13 * v13 ) * 2.f ) * v13 ) ) );
			}
		}

		// ( *( *g_MdlCache + 136 ) )( g_MdlCache );

		// Idk what the fuck this does but it gets called on server so why not call it here
		// ((136 / 4) = 34) -> That's the server index, and on server they are offseted by one
		// Memory::GetVirtualFunction( Context::CSGO.ModelCache, 33 ).cast< void( __thiscall * )( void * )>( )( Context::CSGO.ModelCache );
	}
}

Vector C_CSPlayer::GetEyePosition( ) {
	// hey, modifying it by ourself isn't needed at all, this is way more accurate when landing etc.
	// hey alpha ur incorrect brother man. it is needed for accuracy.

	if( !this ) {
		return{ };
	}

	Vector pos;

	pos = C_BasePlayer::GetEyePosition( );

	if( *reinterpret_cast < int32_t * > ( uintptr_t( this ) + 0x39E1 ) ) {
		auto v3 = m_PlayerAnimState( );
		if( v3 ) {
			CCSGOPlayerAnimState::ModifyEyePosition( v3, &pos );
		}
	}

	return pos;
}
```

`CSGO SDK/SDK/Classes/Player.hpp`:

```hpp
#pragma once

#include "entity.hpp"

#include "PlayerAnimState.hpp"
#include "../Valve/CBaseHandle.hpp"

class C_BaseViewModel;

class CPlayerState {
public:
   virtual ~CPlayerState( ) { }
   bool deadflag;
   QAngle		v_angle; // Viewing angle (player only)

   // The client .dll only cares about deadflag
   // the game and engine .dlls need to worry about the rest of this data
   // Player's network name
   string_t	netname;

   // 0:nothing, 1:force view angles, 2:add avelocity
   int			fixangle;

   // delta angle for fixangle == FIXANGLE_RELATIVE
   QAngle		anglechange;

   // flag to single the HLTV/Replay fake client, not transmitted
   bool		hltv;
   bool		replay;
   int			frags;
   int			deaths;
};

class C_BasePlayer : public C_BaseCombatCharacter {
public:
   QAngle& m_aimPunchAngle( );
   QAngle& m_aimPunchAngleVel( );
   QAngle& m_viewPunchAngle( );
   Vector& m_vecViewOffset( );
   Vector& m_vecVelocity( );
   Vector& m_vecBaseVelocity( );
   float& m_flFallVelocity( );
   float& m_flDuckAmount( );
   float& m_flDuckSpeed( );
   char& m_lifeState( );
   int& m_nTickBase( );
   int& m_iHealth( );
   int& m_fFlags( );
   int& m_iDefaultFOV( );
   int& m_iObserverMode( );
   bool& m_bSpotted();

   CPlayerState& pl( );
   CBaseHandle& m_hObserverTarget( );
   CHandle<C_BaseViewModel> m_hViewModel( );
   int& m_vphysicsCollisionState( );
   float GetMaxSpeed( );
   float SequenceDuration( CStudioHdr* pStudioHdr, int iSequence );
   const Vector& WorldSpaceCenter( );
   float GetSequenceMoveDist( CStudioHdr* pStudioHdr, int iSequence );
public:

   bool IsDead( );
   void SetCurrentCommand( CUserCmd* cmd );

   Vector GetEyePosition( );
   Vector GetViewHeight( );
   C_AnimationLayer& GetAnimLayer( int index );

   float GetLayerSequenceCycleRate( C_AnimationLayer* pLayer, int iSequence );
   void TryInitiateAnimation( C_AnimationLayer* pLayer, int nSequence );
};

class C_CSPlayer : public C_BasePlayer {
public:
   static C_CSPlayer* GetLocalPlayer( );
   static C_CSPlayer* GetPlayerByIndex( int index );

   bool IsTeammate( C_CSPlayer* player );
   bool CanShoot( bool skip_revolver = false);
   bool IsReloading( );

   Vector GetEyePosition( );

public:
   CCSGOPlayerAnimState*& m_PlayerAnimState( );
   QAngle& m_angEyeAngles( );
   int& m_nSurvivalTeam( );
   int& m_ArmorValue( );
   int& m_iAccount( );
   int& m_iFOV( );
   int& m_iShotsFired( );
   float& m_flFlashDuration( );
   float& m_flSecondFlashAlpha( );
   float& m_flVelocityModifier( );
   float& m_flLowerBodyYawTarget( );
   float& m_flSpawnTime( );
   float& m_flHealthShotBoostExpirationTime( );
   bool& m_bHasHelmet( );
   bool& m_bHasHeavyArmor( );
   bool& m_bIsScoped( );
   bool& m_bWaitForNoAttack( );
   bool& m_bIsPlayerGhost( );
   std::array<int, 5>& m_vecPlayerPatchEconIndices( );
   int& m_iMatchStats_Kills( );
   int& m_iMatchStats_Deaths( );
   int& m_iMatchStats_HeadShotKills( );
   bool& m_bGunGameImmunity( );
   bool& m_bIsDefusing( );
   bool& m_bHasDefuser( );
   bool PhysicsRunThink( int unk01 );
   int SetNextThink( int tick );
   void Think( );
   void PreThink( );
   void PostThink( );

   bool	is( std::string networkname );
};

FORCEINLINE C_CSPlayer* ToCSPlayer( C_BaseEntity* pEnt ) {
   if ( !pEnt || !pEnt->m_entIndex || !pEnt->IsPlayer( ) )
	  return nullptr;

   return ( C_CSPlayer* ) ( pEnt );
}

```

`CSGO SDK/SDK/Classes/PlayerAnimState.cpp`:

```cpp
#include "PlayerAnimState.hpp"
#include "../../Utils/Math.h"
#include "../Displacement.hpp"
#include "player.hpp"

void CCSGOPlayerAnimState::Reset( ) {
   using ResetAnimState_t = void( __thiscall* )( CCSGOPlayerAnimState* );
   ( ( ResetAnimState_t ) Engine::Displacement.Function.m_uResetAnimState )( this );
}

void CCSGOPlayerAnimState::Update( QAngle angles ) {
   __asm
   {
	  push 0
	  mov ecx, this

	  movss xmm1, dword ptr[ angles + 4 ]
	  movss xmm2, dword ptr[ angles ]

	  call Engine::Displacement.Function.m_uUpdateAnimState
   }
}

const char* CCSGOPlayerAnimState::GetWeaponPrefix() {
    typedef const char* (__thiscall* fnGetWeaponPrefix)(void*);
    static const auto get_weapon_adr = Memory::Scan(("client.dll"), ("53 56 57 8B F9 33 F6 8B 4F 60 8B 01 FF 90 2C 04 00 00 89 47 64"));
    return ((fnGetWeaponPrefix)get_weapon_adr) (this);
}

float CCSGOPlayerAnimState::GetMaxFraction( ) {
   float speedFactor = Math::Clamp( m_flDuckingSpeed, 0.0f, 1.0f );
   float groundFraction = ( ( m_flGroundFraction * -0.3f ) - 0.2f ) * speedFactor;
   float maxFraction = groundFraction + 1.0f;

   if ( m_fDuckAmount > 0.0f ) {
	  float maxVelocity = Math::Clamp( m_flRunningSpeed, 0.0f, 1.0f );
	  float duckSpeed = m_fDuckAmount * maxVelocity;
	  maxFraction += ( duckSpeed * ( 0.5f - maxFraction ) );
   }
   return maxFraction;
}

float CCSGOPlayerAnimState::GetDesyncDelta( bool useMinYaw ) {
   return m_flMaxBodyYaw * GetMaxFraction( );
}

struct mstudioposeparamdesc_t1 {
   int sznameindex;
   inline char* const pszName( void ) const { return ( ( char* ) this ) + sznameindex; }
   int flags;   // ???? ( volvo, really? )
   float start; // starting value
   float end;   // ending value
   float loop;  // looping range, 0 for no looping, 360 for rotations, etc.
};
mstudioposeparamdesc_t1* pPoseParameter( CStudioHdr* hdr, int index ) {
   using poseParametorFN = mstudioposeparamdesc_t1 * ( __thiscall* )( CStudioHdr*, int );
   poseParametorFN p_pose_parameter = ( poseParametorFN ) Engine::Displacement.Function.m_pPoseParameter;
   return p_pose_parameter( hdr, index );
}

void animstate_pose_param_cache_t::SetValue( C_CSPlayer* player, float flValue ) {
   auto hdr = player->m_pStudioHdr( );
   if ( hdr ) {
      auto pose_param = pPoseParameter( hdr, index );
      if ( !pose_param )
         return;

      auto PoseParam = *pose_param;

      if ( PoseParam.loop ) {
         float wrap = ( PoseParam.start + PoseParam.end ) / 2.0f + PoseParam.loop / 2.0f;
         float shift = PoseParam.loop - wrap;

         flValue = flValue - PoseParam.loop * std::floorf( ( flValue + shift ) / PoseParam.loop );
      }

      auto ctlValue = ( flValue - PoseParam.start ) / ( PoseParam.end - PoseParam.start );
      player->m_flPoseParameter( )[ index ] = ctlValue;
   }
}

```

`CSGO SDK/SDK/Classes/PlayerAnimState.hpp`:

```hpp
#pragma once
#include "../sdk.hpp"

class C_CSPlayer;
class C_WeaponCSBaseGun;

struct animstate_pose_param_cache_t {
  bool valid = false;
  int index = -1;
  const char* name;
  void SetValue( C_CSPlayer* player, float flValue );
};

class CCSGOPlayerAnimState {
public:
  char pad[3];
  char bUnknown;									  // 0x03
  bool m_bInvalid;								  // 0x04
  char pad2[72];
  int m_iModelIndex;
  char pad_[11];
  C_CSPlayer* m_Player;                     // 0x60
  C_WeaponCSBaseGun* m_ActiveWeapon;        // 0x64
  C_WeaponCSBaseGun* m_LastActiveWeapon;	  // 0x68
  float m_flLastUpdateTime;                 // 0x6C
  int m_nLastFrame;                         // 0x70
  float m_flLastUpdateIncrement;                      // 0x74
  float m_flEyeYaw;                         // 0x78
  float m_flPitch;                          // 0x7C
  float m_flAbsRotation;                    // 0x80
  float m_flOldAbsRotation;                 // 0x84
  float m_flCurrentTorsoYaw;                // 0x88
  float m_flUnknownVelocityLean;            // 0x8C changes when moving/jumping/hitting ground
  float m_flLeanAmount;                     // 0x90
  float m_flUnknown1;                       // 0x94
  float m_flFeetCycle;                      // 0x98 0 to 1
  float m_flFeetYawRate;                    // 0x9C 0 to 1
  float m_fUnknown2;								  // 0xA0
  float m_fDuckAmount;							  // 0xA4
  float m_fLandingDuckAdditiveSomething;	  // 0xA8
  float m_fUnknown3;								  // 0xAC
  Vector m_vOrigin;								  // 0xB0, 0xB4, 0xB8
  Vector m_vLastOrigin;							  // 0xBC, 0xC0, 0xC4
  Vector m_vecVelocity;							  // 0xC8
  Vector m_vecNormalizedVelocity;			  // 0xD4 velocity * (1.0 / velocity_length)
  Vector m_vecNormalizedMovingVelocity;	  // 0xE0
  float m_velocity;								  // 0xEC
  float flUpVelocity;							  // 0xF0
  float m_flSpeedNormalized;					  // 0xF4 //from 0 to 1
  float m_flDuckingSpeed;						  // 0xF8 calculation: (1.923077 / flMaxPlayerSpeed) * velocity;
  float m_flRunningSpeed;						  // 0xFC calculation: (2.9411764 / flMaxPlayerSpeed) * velocity; 1.0 / 2.9411764 = 0.34
  float m_flTimeSinceStartedMoving;			  // 0x100
  float m_flTimeSinceStoppedMoving;			  // 0x104
  bool m_bOnGround;			
  bool m_bLand;
  bool m_bHitground;								  // 0x109
  float m_flLastBodyUpdate;					  // 0x10C
  float m_flAirTime;								  // 0x110
  float m_fUnknown4;								  // 0x114
  float m_flLastOriginZ;						  // 0x118
  float m_flGroundFraction;					  // 0x11C decreasing if velocity smaller 135.2, and vice versa
  float m_flStopToFullRunningFraction;		  // 0x120
  float m_flProceduralFootPlant;				  // 0x124
  float m_flUnknownFraction;					  // 0x128
  float m_fUnknown5;                        // 0x12C
  float m_flUnknown3;							  // 0x130
  bool m_StartedMoving;							  // 0x134
  char pad10[ 35 ];                               // 0x157
  float m_unkLeanTime;                            // 0x15B
  Vector m_vecLeanVelocity;                       // 0x16D
  Vector m_velocityUnk2;                          // 0x17F
  Vector m_leanVelocity1;                         // 0x191
  Vector m_leanVelocity2;
  char pad11[32];
  bool m_bUnknown01;
  bool m_bIsAccelerating;
  animstate_pose_param_cache_t lean_yaw; // 0x1B0
  animstate_pose_param_cache_t speed;
  animstate_pose_param_cache_t ladder_speed;
  animstate_pose_param_cache_t ladder_yaw;
  animstate_pose_param_cache_t move_yaw;
  animstate_pose_param_cache_t run;
  animstate_pose_param_cache_t body_yaw;
  animstate_pose_param_cache_t body_pitch;
  animstate_pose_param_cache_t death_yaw;
  animstate_pose_param_cache_t stand;
  animstate_pose_param_cache_t jump_fall;
  animstate_pose_param_cache_t aim_blend_stand_idle;
  animstate_pose_param_cache_t aim_blend_crouch_idle;
  animstate_pose_param_cache_t strafe_yaw;
  animstate_pose_param_cache_t aim_blend_stand_walk;
  animstate_pose_param_cache_t aim_blend_stand_run;
  animstate_pose_param_cache_t aim_blend_crouch_walk;
  animstate_pose_param_cache_t move_blend_walk;
  animstate_pose_param_cache_t move_blend_run;
  animstate_pose_param_cache_t move_blend_crouch;
  float unk_speed_01;
  float m_flVelocityUnknown;

  // note; alpha:
  // vars after dis r used in DoProceduralFootPlant, so idk wtf they are (idc either)
  char pad12[136];

  // used for pose calculations ( body_yaw and body_pitch )
  float m_flMinBodyYaw; // 0x330
  float m_flMaxBodyYaw; // 0x334
  float m_flMinBodyPitch;
  float m_flMaxBodyPitch;
  int anim_state_version; // this is 2, i havent seen it change at all

  void Reset();
  void Update( QAngle angles );
  float GetMaxFraction( );
  float GetDesyncDelta( bool useMinYaw = false );
  const char* GetWeaponPrefix();
  static void ModifyEyePosition( CCSGOPlayerAnimState * pState, Vector * pos );
};//Size=0x344

```

`CSGO SDK/SDK/Classes/PropManager.cpp`:

```cpp
#include "PropManager.hpp"

namespace Engine
{

  PropManager::~PropManager( ) {
	 this->Destroy( );
  }

  bool PropManager::Create( IBaseClientDLL* client ) {
	 if( !client ) {
#ifdef DEV
		Win32::Error( XorStr( "IBaseClientDLL is nullptr" ) );
#endif
		return false;
	 }

	 auto entry = client->GetAllClasses( );

	 if( !entry ) {
#ifdef DEV
		Win32::Error( XorStr( "ClientClass is nullptr" ) );
#endif
		return false;
	 }

	 while( entry ) {
		auto table = entry->m_pRecvTable;

		if( table )
		  this->m_pTables.emplace_back( table );

		entry = entry->m_pNext;
	 }

	 if( this->m_pTables.empty( ) ) {
#ifdef DEV
		Win32::Error( XorStr( "std::vector<RecvTable*> is empty" ) );
#endif
		return false;
	 }

	 for ( auto clientclass = client->GetAllClasses( );
		   clientclass != nullptr;
		   clientclass = clientclass->m_pNext ) {
		if ( clientclass->m_pRecvTable ) {
		   database.emplace_back( LoadTable( clientclass->m_pRecvTable ) );
		}

		m_client_ids[ clientclass->m_pNetworkName ] = clientclass->m_ClassID;
	 }

	 return true;
  }

  PropManager::netvar_table PropManager::LoadTable( RecvTable* recvTable ) {
	 auto table = netvar_table{};

	 table.offset = 0;
	 table.name = recvTable->m_pNetTableName;

	 if ( isdigit( recvTable->m_pNetTableName[ 0 ] ) )
		table.name = recvTable->m_pNetTableName;

	 for ( auto i = 0; i < recvTable->m_nProps; ++i ) {
		auto prop = &recvTable->m_pProps[ i ];

		if ( !prop )
		   continue;

		bool digit = isdigit( prop->m_pVarName[ 0 ] );
		if ( digit && prop->m_RecvType != DPT_DataTable )
		   continue;

		if ( strcmp( "baseclass", prop->m_pVarName ) == 0 )
		   continue;

		if ( prop->m_RecvType == DPT_DataTable && prop->m_pDataTable ) {
		   table.child_tables.emplace_back( LoadTable( prop->m_pDataTable ) );
		   table.child_tables.back( ).offset = prop->m_Offset;
		   table.child_tables.back( ).prop = prop;
		} else {
		   table.child_props.emplace_back( prop );
		}
	 }
	 return table;
  }

  int PropManager::GetClientID( std::string networkname )
  {
	  return m_client_ids[ networkname ];
  }

  void PropManager::Destroy( ) {
	 this->m_pTables.clear( );
  }

  int PropManager::GetOffset( const std::string& table_name, const std::string& prop_name ) {
	 return ( this->GetProp( table_name, prop_name ) );
  }

  RecvVarProxyFn PropManager::Hook( const RecvVarProxyFn hooked, const std::string& table_name, const std::string& prop_name ) {
	 RecvProp* prop = nullptr;

	 if( !GetProp( table_name, prop_name, &prop ) ) {
#ifdef DEV
		Win32::Warning( XorStr( "Prop '%s::%s' not found (PropManager::%s)" ), table_name.c_str( ), prop_name.c_str( ) );
#endif
		return nullptr;
	 }

	 auto restore = prop->m_ProxyFn;

	 prop->m_ProxyFn = hooked;

	 return restore;
  }

  int PropManager::GetProp( const std::string& table_name, const std::string& prop_name, RecvProp** out_prop /*= nullptr */ ) {
	 return ( this->GetProp( this->GetTable( table_name ), prop_name, out_prop ) );
  }

  int PropManager::GetProp( RecvTable* table, const std::string& prop_name, RecvProp** out_prop /*= nullptr */ ) {
	 int extra = 0;

	 for( int i = 0; i < table->m_nProps; i++ ) {
		auto prop = &table->m_pProps[i];
		auto child = prop->m_pDataTable;

		if( child && child->m_nProps ) {
		  int add = GetProp( child, prop_name, out_prop );

		  if( add )
			 extra += ( prop->m_Offset + add );
		}

		if( prop_name.compare( prop->m_pVarName ) == 0 ) {
		  if( out_prop )
			 *out_prop = prop;

		  return ( prop->m_Offset + extra );
		}
	 }

	 return extra;
  }

  RecvTable* PropManager::GetTable( const std::string& name ) {
	 if( !this->m_pTables.empty( ) ) {
		for( auto& table : m_pTables ) {
		  if( name.compare( table->m_pNetTableName ) == 0 )
			 return table;
		}
	 }
#ifdef DEV
	 Win32::Warning( XorStr( "Prop table '%s' not found" ), name.c_str( ) );
#endif
	 return nullptr;
  }

}

```

`CSGO SDK/SDK/Classes/PropManager.hpp`:

```hpp
#pragma once

#include "../sdk.hpp"

namespace Engine
{

  class PropManager : public Core::Singleton<PropManager>
  {
  public:
	 ~PropManager( );
     struct netvar_table {
        std::string name;
        RecvProp* prop;
        uint32_t offset;
        std::vector< RecvProp* > child_props;
        std::vector< netvar_table > child_tables;

        bool operator==( const char* str ) const {
           return name.compare( str ) == 0;
        }
     };
  public:
	 bool Create( IBaseClientDLL* client );
     
	 void Destroy( );

	 int GetOffset( const std::string& table_name, const std::string& prop_name );
	 RecvVarProxyFn Hook( const RecvVarProxyFn hooked, const std::string& table_name, const std::string& prop_name );

	 int GetProp( const std::string& table_name, const std::string& prop_name, RecvProp** out_prop = nullptr );
	 int GetProp( RecvTable* table, const std::string& prop_name, RecvProp** out_prop = nullptr );

	 RecvTable* GetTable( const std::string& name );
     netvar_table LoadTable( RecvTable* recvTable );

     int GetClientID( std::string networkname );

     std::vector< netvar_table > database;
     std::unordered_map< std::string, int > m_client_ids;
  private:
	 std::vector<RecvTable*> m_pTables;

  };

}

```

`CSGO SDK/SDK/Classes/WeaponInfo.hpp`:

```hpp
#pragma once
class CCSWeaponInfo
{
public:
	virtual ~CCSWeaponInfo( ) {};

	char* m_consoleName;				// 0x0004
	char		pad_0008[ 12 ];				// 0x0008
	int			m_iMaxClip;					// 0x0014
	int			m_iMaxClip2;					// 0x0018
	int			m_iDefaultClip1;				// 0x001C
	int			m_iDefaultClip2;				// 0x0020
	char		pad_0024[ 8 ];				// 0x0024
	char* m_szWorldModel;				// 0x002C
	char* m_szViewModel;				// 0x0030
	char* m_szDroppedModel;				// 0x0034
	char		pad_0038[ 4 ];				// 0x0038
	char* N0000023E;					// 0x003C
	char		pad_0040[ 56 ];				// 0x0040
	char* m_szEmptySound;				// 0x0078
	char		pad_007C[ 4 ];				// 0x007C
	char* m_szBulletType;				// 0x0080
	char		pad_0084[ 4 ];				// 0x0084
	char* m_szHudName;					// 0x0088
	char* m_szWeaponName;				// 0x008C
	char		pad_0090[ 56 ];				// 0x0090
	int 		m_iWeaponType;					// 0x00C8
	int			m_m_iWeaponPrice;				// 0x00CC
	int			m_iKillAward;					// 0x00D0
	char* m_szAnimationPrefix;			// 0x00D4
	float		m_flCycleTime;				// 0x00D8
	float		m_flCycleTimeAlt;				// 0x00DC
	float		m_flTimeToIdle;				// 0x00E0
	float		m_flIdleInterval;				// 0x00E4
	bool		m_bFullAuto;					// 0x00E8
	char		pad_0x00E5[ 3 ];			// 0x00E9
	int			m_iWeaponDamage;					// 0x00EC
	float		m_flArmorRatio;				// 0x00F0
	int			m_iBullets;					// 0x00F4
	float		m_flPenetration;				// 0x00F8
	float		m_flFlinchVelocityModifierLarge;	// 0x00FC
	float		m_flFlinchVelocityModifierSmall;	// 0x0100
	float		m_flWeaponRange;					// 0x0104
	float		m_flRangeModifier;			// 0x0108
	float		m_flThrowVelocity;			// 0x010C
	char		pad_0x010C[ 12 ];			// 0x0110
	bool		m_bHasSilencer;				// 0x011C
	char		pad_0x0119[ 3 ];			// 0x011D
	char* m_pSilencerModel;				// 0x0120
	int			m_iCrosshairMinDistance;		// 0x0124
	int			m_iCrosshairDeltaDistance;	// 0x0128 - iTeam?
	float		m_flMaxSpeed;			// 0x012C
	float		m_flMaxSpeed2;		// 0x0130
	float		m_flSpread;					// 0x0134
	float		m_flSpreadAlt;				// 0x0138
	float		m_flInaccuracyCrouch;			// 0x013C
	float		m_flInaccuracyCrouchAlt;		// 0x0140
	float		m_flInaccuracyStand;			// 0x0144
	float		m_flInaccuracyStandAlt;		// 0x0148
	float		m_flInaccuracyJumpInitial;	// 0x014C
	float		m_flInaccuracyJump;			// 0x0150
	float		m_flInaccuracyJumpAlt;		// 0x0154
	float		m_flInaccuracyLand;			// 0x0158
	float		m_flInaccuracyLandAlt;		// 0x015C
	float		m_flInaccuracyLadder;			// 0x0160
	float		m_flInaccuracyLadderAlt;		// 0x0164
	float		m_flInaccuracyFire;			// 0x0168
	float		m_flInaccuracyFireAlt;		// 0x016C
	float		m_flInaccuracyMove;			// 0x0170
	float		m_flInaccuracyMoveAlt;		// 0x0174
	float		m_flInaccuracyReload;			// 0x0178
	int			m_iRecoilSeed;				// 0x017C
	float		m_flRecoilAngle;				// 0x0180
	float		m_flRecoilAngleAlt;			// 0x0184
	float		m_flRecoilAngleVariance;		// 0x0188
	float		m_flRecoilAngleVarianceAlt;	// 0x018C
	float		m_flRecoilMagnitude;			// 0x0190
	float		m_flRecoilMagnitudeAlt;		// 0x0194
	float		m_flRecoilMagnitudeVariance;	// 0x0198
	float		m_flRecoilMagnitudeVarianceAlt;	// 0x019C
	float		m_flRecoveryTimeCrouch;		// 0x01A0
	float		m_flRecoveryTimeStand;		// 0x01A4
	float		m_flRecoveryTimeCrouchFinal;	// 0x01A8
	float		m_flRecoveryTimeStandFinal;	// 0x01AC
	int			m_iRecoveryTransitionStartBullet;	// 0x01B0 
	int			m_iRecoveryTransitionEndBullet;	// 0x01B4
	bool		m_bUnzoomAfterShot;			// 0x01B8
	bool		m_bHideViewModelZoomed;		// 0x01B9
	char		pad_0x01B5[ 2 ];			// 0x01BA
	char		m_iZoomLevels[ 3 ];			// 0x01BC
	int			m_iZoomFOV[ 2 ];				// 0x01C0
	float		m_fZoomTime[ 3 ];				// 0x01C4
	char* m_szWeaponClass;				// 0x01D4
	float		m_flAddonScale;				// 0x01D8
	char		pad_0x01DC[ 4 ];			// 0x01DC
	char* m_szEjectBrassEffect;			// 0x01E0
	char* m_szTracerEffect;				// 0x01E4
	int			m_iTracerFrequency;			// 0x01E8
	int			m_iTracerFrequencyAlt;		// 0x01EC
	char* m_szMuzzleFlashEffect_1stPerson;	// 0x01F0
	char		pad_0x01F4[ 4 ];				// 0x01F4
	char* m_szMuzzleFlashEffect_3rdPerson;	// 0x01F8
	char		pad_0x01FC[ 4 ];			// 0x01FC
	char* m_szMuzzleSmokeEffect;		// 0x0200
	float		m_flHeatPerShot;				// 0x0204
	char* m_szZoomInSound;				// 0x0208
	char* m_szZoomOutSound;				// 0x020C
	float		m_flInaccuracyPitchShift;		// 0x0210
	float		m_flInaccuracySoundThreshold;	// 0x0214
	float		m_flBotAudibleRange;			// 0x0218
	char		pad_0x0218[ 8 ];			// 0x0220
	char* m_pWrongTeamMsg;				// 0x0224
	bool		m_bHasBurstMode;				// 0x0228
	char		pad_0x0225[ 3 ];			// 0x0229
	bool		m_bIsRevolver;				// 0x022C
	bool		m_bCannotShootUnderwater;		// 0x0230

}; //Size=0x083C

```

`CSGO SDK/SDK/Classes/entity.cpp`:

```cpp
#include "entity.hpp"
#include "../displacement.hpp"
#include "../sdk.hpp"
#include "../Valve/CBaseHandle.hpp"

void IHandleEntity::SetRefEHandle( const CBaseHandle& handle ) {
	using Fn = void( __thiscall* )( void*, const CBaseHandle& );
	return Memory::VCall<Fn>( this, Index::IHandleEntity::SetRefEHandle )( this, handle );
}

const CBaseHandle& IHandleEntity::GetRefEHandle( ) const {
	using Fn = const CBaseHandle& ( __thiscall* )( const IHandleEntity* );
	return Memory::VCall<Fn>( this, Index::IHandleEntity::GetRefEHandle )( this );
}

ICollideable* IClientUnknown::GetCollideable( ) {
	using Fn = ICollideable * ( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::IClientUnknown::GetCollideable )( this );
}

IClientNetworkable* IClientUnknown::GetClientNetworkable( ) {
	using Fn = IClientNetworkable * ( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::IClientUnknown::GetClientNetworkable )( this );
}

IClientRenderable* IClientUnknown::GetClientRenderable( ) {
	using Fn = IClientRenderable * ( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::IClientUnknown::GetClientRenderable )( this );
}

IClientEntity* IClientUnknown::GetIClientEntity( ) {
	using Fn = IClientEntity * ( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::IClientUnknown::GetIClientEntity )( this );
}

C_BaseEntity* IClientUnknown::GetBaseEntity( ) {
	using Fn = C_BaseEntity * ( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::IClientUnknown::GetBaseEntity )( this );
}

Vector& ICollideable::OBBMins( ) {
	using Fn = Vector & ( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::ICollideable::OBBMins )( this );
}

Vector& ICollideable::OBBMaxs( ) {
	using Fn = Vector & ( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::ICollideable::OBBMaxs )( this );
}

SolidType_t ICollideable::GetSolid( ) {
	using Fn = SolidType_t( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::ICollideable::GetSolid )( this );
}

ClientClass* IClientNetworkable::GetClientClass( ) {
	using Fn = ClientClass * ( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::IClientNetworkable::GetClientClass )( this );
}

bool IClientNetworkable::IsDormant( ) {
	using Fn = bool( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::IClientNetworkable::IsDormant )( this );
}

int IClientNetworkable::entindex( ) {
	using Fn = int( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::IClientNetworkable::entindex )( this );
}

void IClientNetworkable::SetDestroyedOnRecreateEntities( void ) {
	using Fn = void( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, 13 )( this );
}

void IClientNetworkable::Release( void ) {
	using Fn = void( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, 1 )( this );
}

void IClientNetworkable::OnPreDataChanged( int updateType ) {
	using Fn = void( __thiscall* )( void*, int );
	return Memory::VCall<Fn>( this, 4 )( this, updateType );
}

void IClientNetworkable::OnDataChanged( int updateType ) {
	using Fn = void( __thiscall* )( void*, int );
	return Memory::VCall<Fn>( this, 5 )( this, updateType );
}

void IClientNetworkable::PreDataUpdate( int updateType ) {
	using Fn = void( __thiscall* )( void*, int );
	return Memory::VCall<Fn>( this, 6 )( this, updateType );
}

void IClientNetworkable::PostDataUpdate( int updateType ) {
	using Fn = void( __thiscall* )( void*, int );
	return Memory::VCall<Fn>( this, 7 )( this, updateType );
}

const model_t* IClientRenderable::GetModel( ) {
	using Fn = const model_t* ( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::IClientRenderable::GetModel )( this );
}

bool IClientRenderable::SetupBones( matrix3x4_t* pBoneToWorld, int nMaxBones, int boneMask, float currentTime ) {
	using Fn = bool( __thiscall* )( void*, matrix3x4_t*, int, int, float );
	return Memory::VCall<Fn>( this, Index::IClientRenderable::SetupBones )( this, pBoneToWorld, nMaxBones, boneMask, currentTime );
}

void IClientRenderable::GetRenderBounds( Vector& mins, Vector& maxs ) {
	using Fn = void( __thiscall* )( void*, Vector&, Vector& );
	return Memory::VCall<Fn>( this, Index::IClientRenderable::RenderBounds )( this, mins, maxs );
}

Vector& IClientEntity::OBBMins( ) {
	auto collideable = GetCollideable( );
	return collideable->OBBMins( );
}

Vector& IClientEntity::OBBMaxs( ) {
	auto collideable = GetCollideable( );
	return collideable->OBBMaxs( );
}

Vector& IClientEntity::GetAbsOrigin( ) {
	using Fn = Vector & ( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::IClientEntity::GetAbsOrigin )( this );
}

QAngle& IClientEntity::GetAbsAngles( ) {
	using Fn = QAngle & ( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::IClientEntity::GetAbsAngles )( this );
}

ClientClass* IClientEntity::GetClientClass( ) {
	auto networkable = GetClientNetworkable( );
	if( !networkable )
		return nullptr;

	return networkable->GetClientClass( );
}

bool IClientEntity::IsDormant( ) {
	auto networkable = GetClientNetworkable( );
	if( !networkable )
		return true;

	return networkable->IsDormant( );
}

int IClientEntity::EntIndex( ) {
	auto networkable = GetClientNetworkable( );
	if( !networkable )
		return -1;

	return networkable->entindex( );
}

const model_t* IClientEntity::GetModel( ) {
	auto renderable = GetClientRenderable( );
	if( !renderable )
		return nullptr;

	return renderable->GetModel( );
}

bool IClientEntity::SetupBones( matrix3x4_t* pBoneToWorld, int nMaxBones, int boneMask, float currentTime ) {
	auto renderable = GetClientRenderable( );
	if( !renderable )
		return nullptr;

	return renderable->SetupBones( pBoneToWorld, nMaxBones, boneMask, currentTime );
}

void CIKContext::Construct( ) {
	typedef void( __thiscall* IKConstruct )( void* );
	auto ik_ctor = ( IKConstruct )Engine::Displacement.CIKContext.m_nConstructor;
	ik_ctor( this );
}

void CIKContext::Destructor( ) {
	typedef void( __thiscall* IKDestructor )( CIKContext* );
	auto ik_dector = ( IKDestructor )Engine::Displacement.CIKContext.m_nDestructor;
	ik_dector( this );
}

// This somehow got inlined so we need to rebuild it
void CIKContext::ClearTargets( ) {
	static auto constexpr TARGET_SIZE = 85;

	auto i = 0;
	auto count = *reinterpret_cast< int* >( reinterpret_cast< uint32_t >( this ) + static_cast< ptrdiff_t >( 4080 ) );

	if( count > 0 ) {
		auto target = reinterpret_cast< int* >( reinterpret_cast< uint32_t >( this ) + static_cast< ptrdiff_t >( 208 ) );
		do {
			*target = -9999;
			target += TARGET_SIZE;
			++i;
		} while( i < count );
	}
}

void CIKContext::Init( CStudioHdr* hdr, QAngle* angles, Vector* origin, float currentTime, int frames, int boneMask ) {
	typedef void( __thiscall* Init_t )( void*, CStudioHdr*, QAngle*, Vector*, float, int, int );
	auto ik_init = Engine::Displacement.CIKContext.m_nInit;
	( ( Init_t )ik_init )( this, hdr, angles, origin, currentTime, frames, boneMask );
}

void CIKContext::UpdateTargets( Vector* pos, Quaternion* qua, matrix3x4_t* matrix, uint8_t* boneComputed ) {
	typedef void( __thiscall* UpdateTargets_t )( void*, Vector*, Quaternion*, matrix3x4_t*, uint8_t* );
	auto  ik_update_targets = Engine::Displacement.CIKContext.m_nUpdateTargets;
	( ( UpdateTargets_t )ik_update_targets )( this, pos, qua, matrix, boneComputed );
}

void CIKContext::SolveDependencies( Vector* pos, Quaternion* qua, matrix3x4_t* matrix, uint8_t* boneComputed ) {
	typedef void( __thiscall* SolveDependencies_t )( void*, Vector*, Quaternion*, matrix3x4_t*, uint8_t* );
	auto  ik_solve_dependencies = Engine::Displacement.CIKContext.m_nSolveDependencies;
	( ( SolveDependencies_t )ik_solve_dependencies )( this, pos, qua, matrix, boneComputed );
}

bool C_BaseEntity::ComputeHitboxSurroundingBox( Vector* mins, Vector* maxs ) {
	using ComputeHitboxSurroundingBox_t = bool( __thiscall* )( void*, Vector*, Vector* );

	static auto ComputeHitboxSurroundingBoxFn = Memory::CallableFromRelative( Memory::Scan( XorStr( "client.dll" ), XorStr( "E9 ? ? ? ? 32 C0 5D" ) ) );
	return ( ( ComputeHitboxSurroundingBox_t )ComputeHitboxSurroundingBoxFn )( this, mins, maxs );
}

bool C_BaseEntity::IsPlayer( ) {
	using Fn = bool( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::C_BaseEntity::IsPlayer )( this );
}

bool C_BaseEntity::IsWeapon( ) {
	using Fn = bool( __thiscall* )( void* );
	return Memory::VCall<Fn>( this, Index::C_BaseEntity::IsWeapon )( this );
}

void C_BaseEntity::SetAbsVelocity( const Vector& velocity ) {
	static auto m_vecAbsVelocity = SDK::Memory::FindInDataMap( this->GetPredDescMap( ), XorStr( "m_vecAbsVelocity" ) );
	*( Vector* )( ( uintptr_t )this + m_vecAbsVelocity ) = velocity;
}

Vector& C_BaseEntity::GetAbsVelocity( ) {
	static auto m_vecAbsVelocity = SDK::Memory::FindInDataMap( this->GetPredDescMap( ), XorStr( "m_vecAbsVelocity" ) );
	return *( Vector* )( ( uintptr_t )this + m_vecAbsVelocity );
}

void C_BaseEntity::SetAbsOrigin( const Vector& origin ) {
	reinterpret_cast< void( __thiscall* )( void*, const Vector& ) >( Engine::Displacement.Function.m_uSetAbsOrigin )( this, origin );
}

void C_BaseEntity::InvalidatePhysicsRecursive( int change_flags ) {
	reinterpret_cast< void( __thiscall* )( void*, int ) >( Engine::Displacement.Function.m_uInvalidatePhysics )( this, change_flags );
}

void C_BaseEntity::SetAbsAngles( const QAngle& angles ) {
	reinterpret_cast< void( __thiscall* )( void*, const QAngle& ) >( Engine::Displacement.Function.m_uSetAbsAngles )( this, angles );
}

std::uint8_t& C_BaseEntity::m_MoveType( ) {
	return *( std::uint8_t* )( ( uintptr_t )this + Engine::Displacement.C_BaseEntity.m_MoveType );
}

matrix3x4_t& C_BaseEntity::m_rgflCoordinateFrame( ) {
	return *( matrix3x4_t* )( ( uintptr_t )this + Engine::Displacement.C_BaseEntity.m_rgflCoordinateFrame );
}

int& C_BaseEntity::m_CollisionGroup( )
{
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_BaseEntity.m_iEFlags );
}

CCollisionProperty* C_BaseEntity::m_Collision( ) {
	return ( CCollisionProperty* )( ( uintptr_t )this + Engine::Displacement.DT_BaseEntity.m_Collision );
}

int& C_BaseEntity::m_fEffects( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_BaseEntity.m_fEffects );
}

bool& C_BaseEntity::m_bIsJiggleBonesEnabled( ) {
	return *( bool* )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_bIsJiggleBonesEnabled );
}

int& C_BaseEntity::m_iEFlags( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_BaseEntity.m_iEFlags );
}

void C_BaseEntity::BuildTransformations( CStudioHdr* hdr, Vector* pos, Quaternion* q, const matrix3x4_t& transform, int mask, uint8_t* computed ) {
	using BuildTransformations_t = void( __thiscall* )( decltype( this ), CStudioHdr*, Vector*, Quaternion*, matrix3x4_t const&, int, uint8_t* );
	return Memory::VCall< BuildTransformations_t >( this, 184 )( this, hdr, pos, q, transform, mask, computed );
}

void C_BaseEntity::StandardBlendingRules( CStudioHdr* hdr, Vector* pos, Quaternion* q, float time, int mask ) {
	using StandardBlendingRules_t = void( __thiscall* )( decltype( this ), CStudioHdr*, Vector*, Quaternion*, float, int );
	return Memory::VCall< StandardBlendingRules_t >( this, 200 )( this, hdr, pos, q, time, mask );
}

CIKContext*& C_BaseEntity::m_pIk( ) {
	return *( CIKContext** )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_pIk );
}

int& C_BaseEntity::m_iTeamNum( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_BaseEntity.m_iTeamNum );
}

bool C_BaseEntity::IsPlantedC4( ) {
	return GetClientClass( )->m_ClassID == ClassId_t::CPlantedC4;
}

Vector& C_BaseEntity::m_vecOrigin( ) {
	return *( Vector* )( ( uintptr_t )this + Engine::Displacement.DT_BaseEntity.m_vecOrigin );
}

void C_BaseEntity::UpdateVisibilityAllEntities( ) {
	if( Engine::Displacement.C_BasePlayer.UpdateVisibilityAllEntities )
		reinterpret_cast< void( __thiscall* )( void* ) >( Engine::Displacement.C_BasePlayer.UpdateVisibilityAllEntities )( this );
}

float& C_PlantedC4::m_flC4Blow( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.DT_PlantedC4.m_flC4Blow );
}

float& C_BaseEntity::m_flSimulationTime( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.DT_BaseEntity.m_flSimulationTime );
}

float& C_BaseEntity::m_flOldSimulationTime( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.DT_BaseEntity.m_flSimulationTime + 0x4 );
}

float C_BaseEntity::m_flAnimationTime( ) {
	return m_flOldSimulationTime() + Interfaces::m_pGlobalVars->interval_per_tick;
}

void C_BaseEntity::SetPredictionRandomSeed( const CUserCmd* cmd ) {
	*( int* )( Engine::Displacement.Data.m_uPredictionRandomSeed ) = cmd ? cmd->random_seed : -1;
}

void C_BaseEntity::SetPredictionPlayer( C_BasePlayer* player ) {
	*( C_BasePlayer** )( Engine::Displacement.Data.m_uPredictionPlayer ) = player;
}

CBaseHandle& C_BaseEntity::m_hOwnerEntity( ) {
	return *( CBaseHandle* )( ( uintptr_t )this + Engine::Displacement.DT_BaseEntity.m_hOwnerEntity );;
}

CBaseHandle& C_BaseEntity::moveparent( ) {
	return *( CBaseHandle* )( ( uintptr_t )this + Engine::Displacement.DT_BaseEntity.moveparent );;
}

CBaseHandle& C_BaseEntity::m_hCombatWeaponParent( ) {
	return *( CBaseHandle* )( ( uintptr_t )this + Engine::Displacement.DT_BaseWeaponWorldModel.m_hCombatWeaponParent );;
}

void C_BaseAnimating::UpdateClientSideAnimation( ) {
	g_Vars.globals.m_bUpdatingAnimations = true;
	using Fn = void( __thiscall* )( void* );
	Memory::VCall<Fn>( this, Index::C_BaseAnimating::UpdateClientSideAnimation )( this );
	g_Vars.globals.m_bUpdatingAnimations = false;
}

void C_BaseAnimating::UpdateClientSideAnimationEx( ) {
	auto ishltv = Interfaces::m_pClientState->m_bIsHLTV( );
	auto backup = this->m_bClientSideAnimation( );
	this->m_bClientSideAnimation( ) = true; // disable CGlobalVarsBase::curtime interpolation
	Interfaces::m_pClientState->m_bIsHLTV( ) = true; // disable velocity and duck amount interpolation
	this->UpdateClientSideAnimation( );
	this->m_bClientSideAnimation( ) = backup;
	Interfaces::m_pClientState->m_bIsHLTV( ) = ishltv;
}

void C_BaseAnimating::InvalidateBoneCache( ) {
	*( uint32_t* )( &m_flLastBoneSetupTime( ) ) = 0xFF7FFFFF;
	m_iMostRecentModelBoneCounter( ) = 0;
	m_BoneAccessor( ).m_ReadableBones = m_BoneAccessor( ).m_WritableBones = 0;
}

void C_BaseAnimating::LockStudioHdr( ) {
	auto _LockStudioHdr = ( void( __thiscall* )( void* ) )Engine::Displacement.Function.m_LockStudioHdr;
	_LockStudioHdr( this );
}

bool C_BaseAnimating::ComputeHitboxSurroundingBox( Vector& mins, Vector& maxs, const matrix3x4_t* boneTransform ) {
	auto model = GetModel( );
	if( !model )
		return false;

	auto hdr = Interfaces::m_pModelInfo->GetStudiomodel( model );
	if( !hdr )
		return false;

	mstudiohitboxset_t* set = hdr->pHitboxSet( m_nHitboxSet( ) );
	if( !set || !set->numhitboxes )
		return false;

	const matrix3x4_t* bones = boneTransform ? boneTransform : this->m_BoneAccessor( ).m_pBones;
	mins.Init( FLT_MAX, FLT_MAX, FLT_MAX );
	maxs.Init( -FLT_MAX, -FLT_MAX, -FLT_MAX );
	Vector abs_min, abs_max;

	for( int i = 0; i < set->numhitboxes; i++ ) {
		mstudiobbox_t* pbox = set->pHitbox( i );

		bones[ pbox->bone ].TransformAABB( pbox->bbmin, pbox->bbmax, abs_min, abs_max );

		mins = abs_min.Min( mins );
		maxs = abs_max.Max( maxs );
	}

	return true;
}

int C_BaseAnimating::GetSequenceActivity( int sequence ) {
	auto model = this->GetModel( );
	if( !model )
		return -1;

	auto hdr = Interfaces::m_pModelInfo->GetStudiomodel( model );

	if( !hdr )
		return -1;

	// sig for stuidohdr_t version: 53 56 8B F1 8B DA 85 F6 74 55
	// sig for C_BaseAnimating version: 55 8B EC 83 7D 08 FF 56 8B F1 74 3D
	// c_csplayer vfunc 242, follow calls to find the function.
	return reinterpret_cast< int( __fastcall* )( void*, studiohdr_t*, int ) >( Engine::Displacement.Function.m_uGetSequenceActivity )( this, hdr, sequence );
}

int C_BaseAnimating::LookupSequence( const char* label )
{
	typedef int( __thiscall* fnLookupSequence )( void*, const char* );

	auto rel_32_fix = [ ] ( uintptr_t ptr ) -> uintptr_t { // TODO: Move this to displacement
		auto offset = *( uintptr_t* )( ptr + 0x1 );
		return ( uintptr_t )( ptr + 5 + offset );
	};

	static auto loookup_sequnece_adr = rel_32_fix( Memory::Scan( XorStr( "client.dll" ), XorStr( "E8 ? ? ? ? 5E 83 F8 FF" ) ) );
	return ( ( fnLookupSequence )loookup_sequnece_adr ) ( this, label );
}

int& C_BaseAnimating::m_nHitboxSet( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_BaseAnimating.m_nHitboxSet );
}

int& C_BaseAnimating::m_iMostRecentModelBoneCounter( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_iMostRecentModelBoneCounter );
}

int& C_BaseAnimating::m_iPrevBoneMask( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_iPrevBoneMask );
}

int& C_BaseAnimating::m_iAccumulatedBoneMask( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_iAccumulatedBoneMask );
}

int& C_BaseAnimating::m_iOcclusionFramecount( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_iOcclusionFramecount );
}

int& C_BaseAnimating::m_iOcclusionFlags( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_iOcclusionFlags );
}

bool& C_BaseAnimating::m_bClientSideAnimation( ) {
	return *( bool* )( ( uintptr_t )this + Engine::Displacement.DT_BaseAnimating.m_bClientSideAnimation );
}

bool& C_BaseAnimating::m_bShouldDraw( ) {
	return *( bool* )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_bShouldDraw );
}

float& C_BaseAnimating::m_flLastBoneSetupTime( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_flLastBoneSetupTime );
}

float* C_BaseAnimating::m_flPoseParameter( ) {
	return ( float* )( ( uintptr_t )this + Engine::Displacement.DT_BaseAnimating.m_flPoseParameter );
}

CBoneAccessor& C_BaseAnimating::m_BoneAccessor( ) {
	return *( CBoneAccessor* )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_BoneAccessor );
}

CUtlVector<matrix3x4_t>& C_BaseAnimating::m_CachedBoneData( ) {
	return *( CUtlVector<matrix3x4_t>* )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_CachedBoneData );
}

CUtlVector<C_AnimationLayer>& C_BaseAnimating::m_AnimOverlay( ) {
	return *( CUtlVector<C_AnimationLayer>* )( ( uintptr_t )this + 0x2970 );
}

Vector* C_BaseAnimating::m_vecBonePos( ) {
	return ( Vector* )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_nCachedBonesPosition );
}

Vector C_BaseAnimating::GetBonePos( int bone ) {
	matrix3x4_t matrix[ 128 ];
	if( SetupBones( matrix, 128, 0x100, Interfaces::m_pGlobalVars->curtime ) ) {
		return Vector( matrix[ bone ][ 0 ][ 3 ], matrix[ bone ][ 1 ][ 3 ], matrix[ bone ][ 2 ][ 3 ] );
	}

	return Vector( 0, 0, 0 );
}

Quaternion* C_BaseAnimating::m_quatBoneRot( ) {
	return ( Quaternion* )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_nCachedBonesRotation );;
}

CStudioHdr* C_BaseAnimating::m_pStudioHdr( ) {
	return *( CStudioHdr** )( ( uintptr_t )this + Engine::Displacement.C_BaseAnimating.m_pStudioHdr );
}

CBaseHandle& C_BaseCombatCharacter::m_hActiveWeapon( ) {
	return *( CBaseHandle* )( ( uintptr_t )this + Engine::Displacement.DT_BaseCombatCharacter.m_hActiveWeapon );
}

float& C_BaseCombatCharacter::m_flNextAttack( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.DT_BaseCombatCharacter.m_flNextAttack );
}

CBaseHandle* C_BaseCombatCharacter::m_hMyWeapons( ) {
	return ( CBaseHandle* )( ( uintptr_t )this + Engine::Displacement.DT_BaseCombatCharacter.m_hMyWeapons );
}

CBaseHandle* C_BaseCombatCharacter::m_hMyWearables( ) {
	return ( CBaseHandle* )( ( uintptr_t )this + Engine::Displacement.DT_BaseCombatCharacter.m_hMyWearables );
}

float C_Inferno::m_flSpawnTime( ) {
	return *( float* )( ( uintptr_t )this + 0x20 );
}

int C_SmokeGrenadeProjectile::m_nSmokeEffectTickBegin( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_SmokeGrenadeProjectile.m_nSmokeEffectTickBegin );
}

void CCollisionProperty::SetCollisionBounds( const Vector& mins, const Vector& maxs ) {
	using Fn = void( __thiscall* )( CCollisionProperty*, const Vector&, const Vector& );
	static auto mem = ( Fn )Memory::Scan( XorStr( "client.dll" ), XorStr( "53 8B DC 83 EC 08 83 E4 F8 83 C4 04 55 8B 6B 04 89 6C 24 04 8B EC 83 EC 10 56 57 8B 7B" ) );
	mem( this, mins, maxs );
}

```

`CSGO SDK/SDK/Classes/entity.hpp`:

```hpp
#pragma once

#include "../sdk.hpp"
#include "../Valve/UtlVector.hpp"

#pragma region decl_indices
namespace Index
{
	namespace IHandleEntity
	{
		enum {
			SetRefEHandle = 1,
			GetRefEHandle = 2,
		};
	}
	namespace IClientUnknown
	{
		enum {
			GetCollideable = 3,
			GetClientNetworkable = 4,
			GetClientRenderable = 5,
			GetIClientEntity = 6,
			GetBaseEntity = 7,
		};
	}
	namespace ICollideable
	{
		enum {
			OBBMins = 1,
			OBBMaxs = 2,
			GetSolid = 11,
		};
	}
	namespace IClientNetworkable
	{
		enum {
			GetClientClass = 2,
			IsDormant = 9,
			entindex = 10,
		};
	}
	namespace IClientRenderable
	{
		enum {
			GetModel = 8,
			SetupBones = 13,
			RenderBounds = 17,
		};
	}
	namespace IClientEntity
	{
		enum {
			GetAbsOrigin = 10,
			GetAbsAngles = 11,
		};
	}
	namespace C_BaseEntity
	{
		enum {
			IsPlayer = 152,
			IsWeapon = 160,
		};
	}
	namespace C_BaseAnimating
	{
		enum {
			UpdateClientSideAnimation = 218,
		};
	}
}
#pragma endregion

class IHandleEntity {
public:
	void SetRefEHandle( const CBaseHandle& handle );
	const CBaseHandle& GetRefEHandle( ) const;
};

class IClientUnknown : public IHandleEntity {
public:
	ICollideable* GetCollideable( );
	IClientNetworkable* GetClientNetworkable( );
	IClientRenderable* GetClientRenderable( );
	IClientEntity* GetIClientEntity( );
	C_BaseEntity* GetBaseEntity( );
};

class ICollideable {
public:
	Vector& OBBMins( );
	Vector& OBBMaxs( );
	SolidType_t GetSolid( );
};

class IClientNetworkable {
public:
	ClientClass* GetClientClass( );
	bool IsDormant( );
	int entindex( );
	void SetDestroyedOnRecreateEntities( void ); //13
	void Release( void ); // 1
	void OnPreDataChanged( int updateType ); //4
	void OnDataChanged( int updateType ); //5
	void PreDataUpdate( int updateType ); //6
	void PostDataUpdate( int updateType ); //7
};

class IClientRenderable {
public:
	virtual IClientUnknown* GetIClientUnknown( ) = 0;
	const model_t* GetModel( );
	bool SetupBones( matrix3x4_t* pBoneToWorld, int nMaxBones, int boneMask, float currentTime );
	void GetRenderBounds( Vector& mins, Vector& maxs );
};

class CCollisionProperty : public ICollideable {
public:
	void* vtable;
	C_BaseEntity* m_pEntity;
	Vector m_vecMins;
	Vector m_vecMaxs;
	unsigned short m_usSolidFlags;
	unsigned short m_nSolidType;
	float m_flRadius;

	unsigned short m_Partition; // SpatialPartitionHandle_t
	unsigned char m_nSurroundType;
	unsigned char m_triggerBloat;

	Vector m_vecSpecifiedSurroundingMins;
	Vector m_vecSpecifiedSurroundingMaxs;
	Vector m_vecSurroundingMins;
	Vector m_vecSurroundingMaxs;

	void SetCollisionBounds( const Vector& mins, const Vector& maxs );
};

class IClientEntity : public IClientUnknown {
public:
	SDK_pad( 0x64 );
	int m_entIndex;

	// Entity flags that are only for the client (ENTCLIENTFLAG_ defines).
	unsigned short m_EntClientFlags;

	Vector& OBBMins( );
	Vector& OBBMaxs( );

	Vector& GetAbsOrigin( );
	QAngle& GetAbsAngles( );

	ClientClass* GetClientClass( );
	bool IsDormant( );
	int EntIndex( );

	const model_t* GetModel( );
	bool SetupBones( matrix3x4_t* pBoneToWorld, int nMaxBones, int boneMask, float currentTime );
};

class CBoneAccessor {
public:
	inline matrix3x4_t* GetBoneArrayForWrite( ) { return m_pBones; }

	inline void SetBoneArrayForWrite( matrix3x4_t* bone_array ) { m_pBones = bone_array; }

	inline int GetReadableBones( ) {
		return m_ReadableBones;
	}

	inline void SetReadableBones( int flags ) {
		m_ReadableBones = flags;
	}

	inline int GetWritableBones( ) {
		return m_WritableBones;
	}

	inline void SetWritableBones( int flags ) {
		m_WritableBones = flags;
	}

	alignas( 16 ) matrix3x4_t* m_pBones;
	int m_ReadableBones; // Which bones can be read.
	int m_WritableBones; // Which bones can be written.
};

class CIKContext {
public:
	void Construct( );
	void Destructor( );

	void ClearTargets( );
	void Init( CStudioHdr* hdr, QAngle* angles, Vector* origin, float currentTime, int frames, int boneMask );
	void UpdateTargets( Vector* pos, Quaternion* qua, matrix3x4_t* matrix, uint8_t* boneComputed );
	void SolveDependencies( Vector* pos, Quaternion* qua, matrix3x4_t* matrix, uint8_t* boneComputed );
};

class C_AnimationLayer {
public:
	bool m_bClientBlend;				 //0x0000
	float m_flBlendIn;					 //0x0004
	void* m_pStudioHdr;					 //0x0008
	int m_nDispatchSequence;     //0x000C
	int m_nDispatchSequence_2;   //0x0010
	uint32_t m_nOrder;           //0x0014
	uint32_t m_nSequence;        //0x0018
	float_t m_flPrevCycle;       //0x001C
	float_t m_flWeight;          //0x0020
	float_t m_flWeightDeltaRate; //0x0024
	float_t m_flPlaybackRate;    //0x0028
	float_t m_flCycle;           //0x002C
	void* m_pOwner;              //0x0030 // player's thisptr
	char pad_0038[ 4 ];            //0x0034
};                             //Size: 0x0038

class C_BaseEntity : public IClientEntity {
public:
	datamap_t* GetDataDescMap( ) {
		typedef datamap_t* ( __thiscall* o_GetPredDescMap )( void* );
		return Memory::VCall<o_GetPredDescMap>( this, 15 )( this );
	}

	datamap_t* GetPredDescMap( ) {
		typedef datamap_t* ( __thiscall* o_GetPredDescMap )( void* );
		return Memory::VCall<o_GetPredDescMap>( this, 17 )( this );
	}

	void SetModelIndex( const int index ) {
		using Fn = void( __thiscall* )( C_BaseEntity*, int );
		return Memory::VCall<Fn>( this, 75 )( this, index );
	}

public:
	bool ComputeHitboxSurroundingBox( Vector* mins, Vector* maxs );
	bool IsPlayer( );
	bool IsWeapon( );
	bool IsPlantedC4( );

	void SetAbsVelocity( const Vector& velocity );
	Vector& GetAbsVelocity( );
	void SetAbsOrigin( const Vector& origin );
	void InvalidatePhysicsRecursive( int change_flags );
	void SetAbsAngles( const QAngle& angles );

	std::uint8_t& m_MoveType( );
	matrix3x4_t& m_rgflCoordinateFrame( );

	int& m_CollisionGroup( );
	CCollisionProperty* m_Collision( );

	int& m_fEffects( );
	bool& m_bIsJiggleBonesEnabled( );
	int& m_iEFlags( );
	void BuildTransformations( CStudioHdr* hdr, Vector* pos, Quaternion* q, const matrix3x4_t& transform, int mask, uint8_t* computed );
	void StandardBlendingRules( CStudioHdr* hdr, Vector* pos, Quaternion* q, float time, int mask );
	CIKContext*& m_pIk( );
	int& m_iTeamNum( );

	Vector& m_vecOrigin( );
	void UpdateVisibilityAllEntities( );

	float& m_flSimulationTime( );
	float& m_flOldSimulationTime( );
	float m_flAnimationTime( );

public:
	static void SetPredictionRandomSeed( const CUserCmd* cmd );
	static void SetPredictionPlayer( C_BasePlayer* player );
	CBaseHandle& m_hOwnerEntity( );
	CBaseHandle& moveparent( );
	CBaseHandle& m_hCombatWeaponParent( );
	int& m_nModelIndex( );
	int& m_nPrecipType( );

};

class C_PlantedC4 : public C_BaseEntity {
public:
	float& m_flC4Blow( );
};

class C_BaseAnimating : public C_BaseEntity {
public:
	void UpdateClientSideAnimation( );
	void UpdateClientSideAnimationEx( );
	void InvalidateBoneCache( );
	void LockStudioHdr( );
	bool ComputeHitboxSurroundingBox( Vector& VecWorldMins, Vector& VecWorldMaxs, const matrix3x4_t* boneTransform = nullptr );
	int GetSequenceActivity( int sequence );
	int LookupSequence( const char* label );
public:
	int& m_nHitboxSet( );
	int& m_iMostRecentModelBoneCounter( );
	int& m_iPrevBoneMask( );
	int& m_iAccumulatedBoneMask( );
	int& m_iOcclusionFramecount( );
	int& m_iOcclusionFlags( );
	bool& m_bClientSideAnimation( );
	bool& m_bShouldDraw( );
	float& m_flLastBoneSetupTime( );
	float* m_flPoseParameter( );

public:
	CBoneAccessor& m_BoneAccessor( );
	CUtlVector<matrix3x4_t>& m_CachedBoneData( );
	CUtlVector<C_AnimationLayer>& m_AnimOverlay( );

	Vector* m_vecBonePos( );
	Vector GetBonePos( int bone );
	Quaternion* m_quatBoneRot( );

	CStudioHdr* m_pStudioHdr( );

};

class C_BaseCombatCharacter : public C_BaseAnimating {
public:
	CBaseHandle& m_hActiveWeapon( );
	float& m_flNextAttack( );

	CBaseHandle* m_hMyWeapons( );
	CBaseHandle* m_hMyWearables( );
};

class C_SmokeGrenadeProjectile : public C_BaseEntity {
public:
	int m_nSmokeEffectTickBegin( );

	static float GetExpiryTime( ) {
		return 19.f;
	}
};

class C_Inferno : public C_BaseEntity {
public:
	float m_flSpawnTime( ); // 0x20

	static float GetExpiryTime( ) {
		return 7.f;
	}
};

```

`CSGO SDK/SDK/Classes/weapon.cpp`:

```cpp
#include "weapon.hpp"
#include "../displacement.hpp"
#include "../../source.hpp"
#include "PropManager.hpp"


float& C_BaseCombatWeapon::m_flNextPrimaryAttack( ) {
   return *( float* ) ( ( uintptr_t ) this + Engine::Displacement.DT_BaseCombatWeapon.m_flNextPrimaryAttack );
}

float& C_BaseCombatWeapon::m_flNextSecondaryAttack( ) {
   return *( float* ) ( ( uintptr_t ) this + Engine::Displacement.DT_BaseCombatWeapon.m_flNextSecondaryAttack );
}

float& C_BaseCombatWeapon::m_flPostponeFireReadyTime( ) {
   return *( float* ) ( ( uintptr_t ) this + Engine::Displacement.DT_WeaponCSBase.m_flPostponeFireReadyTime );
}

int& C_BaseCombatWeapon::m_iBurstShotsRemaining( ) {
	return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_WeaponCSBaseGun.m_iBurstShotsRemaining );
}

float& C_BaseCombatWeapon::m_fNextBurstShot( ) {
	return *( float* )( ( uintptr_t )this + Engine::Displacement.DT_WeaponCSBaseGun.m_fNextBurstShot );
}

CBaseHandle& C_BaseCombatWeapon::m_hOwner( ) {
   return *( CBaseHandle* ) ( ( uintptr_t ) this + Engine::Displacement.DT_BaseCombatWeapon.m_hOwner );
}

int& C_BaseCombatWeapon::m_iClip1( ) {
   return *( int* ) ( ( uintptr_t ) this + Engine::Displacement.DT_BaseCombatWeapon.m_iClip1 );
}

int& C_BaseCombatWeapon::m_iPrimaryReserveAmmoCount( ) {
   return *( int* ) ( ( uintptr_t ) this + Engine::Displacement.DT_BaseCombatWeapon.m_iPrimaryReserveAmmoCount );
}

short& C_BaseCombatWeapon::m_iItemDefinitionIndex( ) {
   return *( short* ) ( ( uintptr_t ) this + Engine::Displacement.DT_BaseCombatWeapon.m_iItemDefinitionIndex );
}

CUtlVector<IRefCounted*>& C_BaseCombatWeapon::m_CustomMaterials( ) {
   return *( CUtlVector< IRefCounted* >* )( ( uintptr_t ) this + Engine::Displacement.DT_BaseCombatWeapon.m_CustomMaterials );
}

bool& C_BaseCombatWeapon::m_bCustomMaterialInitialized( ) {
   return *( bool* ) ( ( uintptr_t ) this + Engine::Displacement.DT_BaseCombatWeapon.m_bCustomMaterialInitialized );
}

float& C_WeaponCSBaseGun::m_flRecoilIndex( ) {
   return *( float* ) ( ( uintptr_t ) this + Engine::Displacement.DT_WeaponCSBase.m_flRecoilIndex );
}

float& C_WeaponCSBaseGun::m_fLastShotTime( ) {
   return *( float* ) ( ( uintptr_t ) this + Engine::Displacement.DT_WeaponCSBase.m_fLastShotTime );
}

int& C_WeaponCSBaseGun::m_weaponMode( ) {
   return *( int* ) ( ( uintptr_t ) this + Engine::Displacement.DT_WeaponCSBase.m_weaponMode );
}

int& C_WeaponCSBaseGun::m_zoomLevel( ) {
   return *( int* ) ( ( uintptr_t ) this + Engine::Displacement.DT_WeaponCSBaseGun.m_zoomLevel );
}

int& C_WeaponCSBaseGun::m_Activity( ) {
   static unsigned int m_activity = Memory::FindInDataMap( GetPredDescMap( ), ("m_Activity") );
   return *( int* ) ( ( uintptr_t ) this + m_activity );
}

float& C_WeaponCSBaseGun::m_flThrowStrength( ) {
   return *( float* ) ( ( uintptr_t ) this + Engine::Displacement.DT_BaseCSGrenade.m_flThrowStrength );
}

float& C_WeaponCSBaseGun::m_fThrowTime( ) {
   return *( float* ) ( ( uintptr_t ) this + Engine::Displacement.DT_BaseCSGrenade.m_fThrowTime );
}

bool& C_WeaponCSBaseGun::m_bPinPulled( ) {
   return *( bool* ) ( ( uintptr_t ) this + Engine::Displacement.DT_BaseCSGrenade.m_bPinPulled );
}

Encrypted_t<CCSWeaponInfo> C_WeaponCSBaseGun::GetCSWeaponData( ) {
   using Fn = CCSWeaponInfo * ( __thiscall* )( void* );
   return Memory::VCall<Fn>( this, Index::C_WeaponCSBaseGun::GetCSWeaponData )( this );
}
//8B 81 ? ? ? ? 85 C0 0F 84 ? ? ? ? C3
//
//10B8F32C
//
//10B8FA44

float C_WeaponCSBaseGun::GetMaxSpeed( ) {
   auto pWeaponData = GetCSWeaponData( );
   if ( !pWeaponData.IsValid( ) )
	  return 250.0f;

   if ( m_weaponMode( ) == 0 )
	  return pWeaponData->m_flMaxSpeed;

   return pWeaponData->m_flMaxSpeed2;
}

float C_WeaponCSBaseGun::GetSpread( ) {
   using Fn = float( __thiscall* )( void* );
   return Memory::VCall<Fn>( this, Index::C_WeaponCSBaseGun::GetSpread )( this );
}

float C_WeaponCSBaseGun::GetInaccuracy( ) {
   using Fn = float( __thiscall* )( void* );
   return Memory::VCall<Fn>( this, Index::C_WeaponCSBaseGun::GetInnacuracy )( this );
}

void C_WeaponCSBaseGun::UpdateAccuracyPenalty( ) {
   using Fn = void( __thiscall* )( void* );
   return Memory::VCall<Fn>( this, Index::C_WeaponCSBaseGun::UpdateAccuracyPenalty )( this );
}

bool C_WeaponCSBaseGun::IsFireTime( ) {
   return ( Interfaces::m_pGlobalVars->curtime >= m_flNextPrimaryAttack( ) );
}

bool C_WeaponCSBaseGun::IsSecondaryFireTime( ) {
   return ( Interfaces::m_pGlobalVars->curtime >= m_flNextSecondaryAttack( ) );
}

bool C_WeaponCSBaseGun::IsInThrow( ) {
   if ( !m_bPinPulled( ) ) {
	  float throwTime = m_fThrowTime( );

	  if ( throwTime > 0 )
		 return true;
   }
   return false;
}

CUtlVector<IRefCounted*>& C_EconItemView::m_CustomMaterials( ) {
   static auto _m_CustomMaterials = Engine::Displacement.DT_BaseAttributableItem.m_Item + 0x14;
   return *( CUtlVector< IRefCounted* >* )( ( uintptr_t ) this + _m_CustomMaterials );
}

CUtlVector<IRefCounted*>& C_EconItemView::m_VisualsDataProcessors( ) {
   static auto _m_CustomMaterials = Engine::Displacement.DT_BaseAttributableItem.m_Item + 0x230;
   return *( CUtlVector< IRefCounted* >* )( ( uintptr_t ) this + _m_CustomMaterials );
}

int32_t& C_EconItemView::m_bInitialized( ) {
   return *( int32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_bInitialized );
}

int32_t& C_EconItemView::m_iEntityLevel( ) {
   return *( int32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_iEntityLevel );
}

int32_t& C_EconItemView::m_iAccountID( ) {
   return *( int32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_iAccountID );
}

int32_t& C_EconItemView::m_iItemIDLow( ) {
   return *( int32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_iItemIDLow );
}

int32_t& C_EconItemView::m_iItemIDHigh( ) {
   return *( int32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_iItemIDHigh );
}

int32_t& C_EconItemView::m_iEntityQuality( ) {
   return *( int32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_iEntityQuality );
}

uint32_t& C_EconItemView::m_nFallbackPaintKit( ) {
   return *( uint32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_nFallbackPaintKit );
}

uint32_t& C_EconItemView::m_nFallbackSeed( ) {
   return *( uint32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_nFallbackSeed );
}

uint32_t& C_EconItemView::m_nFallbackStatTrak( ) {
   return *( uint32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_nFallbackStatTrak );
}

float& C_EconItemView::m_flFallbackWear( ) {
   return *( float* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_flFallbackWear );
}

str_32& C_EconItemView::m_szCustomName( ) {
   return *( str_32* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_szCustomName );
}

int16_t& C_EconItemView::m_iItemDefinitionIndex( ) {
   return *( int16_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_iItemDefinitionIndex );
}

uint64_t& C_BaseAttributableItem::m_OriginalOwnerXuid( ) {
   return *( uint64_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_OriginalOwnerXuidLow );
}

int32_t& C_BaseAttributableItem::m_OriginalOwnerXuidLow( ) {
   return *( int32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_OriginalOwnerXuidLow );
}

int32_t& C_BaseAttributableItem::m_OriginalOwnerXuidHigh( ) {
   return *( int32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_OriginalOwnerXuidHigh );
}

int32_t& C_BaseAttributableItem::m_nFallbackPaintKit( ) {
   return *( int32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_nFallbackPaintKit );
}

int32_t& C_BaseAttributableItem::m_nFallbackSeed( ) {
   return *( int32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_nFallbackSeed );
}

int32_t& C_BaseAttributableItem::m_nFallbackStatTrak( ) {
   return *( int32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_nFallbackStatTrak );
}

int32_t& C_BaseAttributableItem::m_flFallbackWear( ) {
   return *( int32_t* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_flFallbackWear );
}

str_32& C_BaseAttributableItem::m_szCustomName( ) {
   return *( str_32* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseAttributableItem.m_szCustomName );
}

CHandle<C_BaseEntity> C_BaseAttributableItem::m_hWeaponWorldModel( ) {
   return *( CHandle<C_BaseEntity>* )( ( int32_t ) this + Engine::Displacement.DT_BaseCombatWeapon.m_hWeaponWorldModel );
}

CHandle<C_BaseEntity> C_BaseViewModel::m_hOwner( ) {
   return *( CHandle<C_BaseEntity>* )( ( int32_t ) this + Engine::Displacement.DT_BaseViewModel.m_hOwner );
}

CHandle<C_BaseCombatWeapon> C_BaseViewModel::m_hWeapon( ) {
   return *( CHandle<C_BaseCombatWeapon>* )( ( int32_t ) this + Engine::Displacement.DT_BaseViewModel.m_hWeapon );
}

void C_BaseViewModel::SendViewModelMatchingSequence( int sequence ) {
   using Fn = void( __thiscall* )( void*, int );
   return  Memory::VCall<Fn>( this, 246 )( this, sequence );
}

int& C_BaseEntity::m_nModelIndex( ) {
   return *( int* ) ( ( int32_t ) this + Engine::Displacement.DT_BaseEntity.m_nModelIndex );
}

int& C_BaseEntity::m_nPrecipType( ) {
   return *( int* )( ( uintptr_t )this + Engine::Displacement.DT_Precipitation.m_nPrecipType );
}

```

`CSGO SDK/SDK/Classes/weapon.hpp`:

```hpp
#pragma once

#include "entity.hpp"
#include "../Valve/CBaseHandle.hpp"

#pragma region decl_indices
namespace Index
{
  namespace C_WeaponCSBaseGun
  {
	 enum
	 {
		GetSpread = 439,
		GetCSWeaponData = 446,
		GetInnacuracy = 469,
		UpdateAccuracyPenalty = 471,
	 };
  }
}

#pragma endregion

class IRefCounted {
private:
  volatile long refCount;

public:
  virtual void destructor( char bDelete ) = 0;
  virtual bool OnFinalRelease( ) = 0;

  void unreference( ) {
	 if( InterlockedDecrement( &refCount ) == 0 && OnFinalRelease( ) )
		destructor( 1 );
  }
};

class C_EconItemView {
public:
  CUtlVector< IRefCounted* >& m_CustomMaterials( );
  CUtlVector< IRefCounted* >& m_VisualsDataProcessors( );

  int32_t& m_bInitialized( );
  int32_t& m_iEntityLevel( );
  int32_t& m_iAccountID( );
  int32_t& m_iItemIDLow( );
  int32_t& m_iItemIDHigh( );
  int32_t& m_iEntityQuality( );

  uint32_t& m_nFallbackPaintKit( );
  uint32_t& m_nFallbackSeed( );
  uint32_t& m_nFallbackStatTrak( );

  float& m_flFallbackWear( );

  str_32& m_szCustomName( );

  int16_t& m_iItemDefinitionIndex( );
};

class C_BaseCombatWeapon : public C_BaseEntity
{
public:
  float& m_flNextPrimaryAttack( );
  float& m_flNextSecondaryAttack( );
  float& m_flPostponeFireReadyTime( );
  int& m_iBurstShotsRemaining( );
  float& m_fNextBurstShot( );
  CBaseHandle& m_hOwner( );
  int& m_iClip1( );
  int& m_iPrimaryReserveAmmoCount( );
  short& m_iItemDefinitionIndex( );

  CUtlVector< IRefCounted* >& m_CustomMaterials();
  bool& m_bCustomMaterialInitialized();

  C_EconItemView& m_Item( ) {
	 // Cheating. It should be this + m_Item netvar but then the netvars inside C_EconItemView wont work properly.
	 // A real fix for this requires a rewrite of the netvar manager
	 return *( C_EconItemView* )this;
  }
};

class C_WeaponCSBaseGun : public C_BaseCombatWeapon
{
public:
  float& m_flRecoilIndex( );
  float & m_fLastShotTime( );
  int& m_weaponMode( );
  int& m_zoomLevel( );
  int& m_Activity( );
public:
  float& m_flThrowStrength( );
  float& m_fThrowTime( );
  bool& m_bPinPulled( );

public:
  Encrypted_t<CCSWeaponInfo> GetCSWeaponData( );

  float GetMaxSpeed( );
  float GetSpread( );
  float GetInaccuracy( );
  void UpdateAccuracyPenalty( );

  bool IsInThrow( );
  bool IsFireTime( );
  bool IsSecondaryFireTime( );
};

class C_BaseAttributableItem : public C_BaseAnimating {

public:
  uint64_t& m_OriginalOwnerXuid( );

  int32_t& m_OriginalOwnerXuidLow( );
  int32_t& m_OriginalOwnerXuidHigh( );

  int32_t& m_nFallbackPaintKit( );
  int32_t& m_nFallbackSeed( );
  int32_t& m_nFallbackStatTrak( );
  int32_t& m_flFallbackWear( );

  str_32& m_szCustomName( );

  CHandle< C_BaseEntity > m_hWeaponWorldModel( );

  C_EconItemView& m_Item( ) {
	 // Cheating. It should be this + m_Item netvar but then the netvars inside C_EconItemView wont work properly.
	 // A real fix for this requires a rewrite of the netvar manager
	 return *( C_EconItemView* )this;
  }
};

class C_BaseViewModel : public C_BaseAttributableItem {
public:
  CHandle< C_BaseEntity > m_hOwner( ); //"DT_BaseViewModel", "m_hOwner");
  CHandle< C_BaseCombatWeapon > m_hWeapon( ); //"DT_BaseViewModel", "m_hWeapon");
  void SendViewModelMatchingSequence( int sequence );
};


```

`CSGO SDK/SDK/Definitions.hpp`:

```hpp
#pragma once

enum FontFlags_t {
   FONTFLAG_NONE,
   FONTFLAG_ITALIC = 0x001,
   FONTFLAG_UNDERLINE = 0x002,
   FONTFLAG_STRIKEOUT = 0x004,
   FONTFLAG_SYMBOL = 0x008,
   FONTFLAG_ANTIALIAS = 0x010,
   FONTFLAG_GAUSSIANBLUR = 0x020,
   FONTFLAG_ROTARY = 0x040,
   FONTFLAG_DROPSHADOW = 0x080,
   FONTFLAG_ADDITIVE = 0x100,
   FONTFLAG_OUTLINE = 0x200,
};
enum {
   TE_BEAMPOINTS = 0x00,		// beam effect between two points
   TE_SPRITE = 0x01,	// additive sprite, plays 1 cycle
   TE_BEAMDISK = 0x02,	// disk that expands to max radius over lifetime
   TE_BEAMCYLINDER = 0x03,		// cylinder that expands to max radius over lifetime
   TE_BEAMFOLLOW = 0x04,		// create a line of decaying beam segments until entity stops moving
   TE_BEAMRING = 0x05,		// connect a beam ring to two entities
   TE_BEAMSPLINE = 0x06,
   TE_BEAMRINGPOINT = 0x07,
   TE_BEAMLASER = 0x08,		// Fades according to viewpoint
   TE_BEAMTESLA = 0x09,
};
enum {
	STUDIORENDER_DRAW_ENTIRE_MODEL = 0,
	STUDIORENDER_DRAW_OPAQUE_ONLY = 0x01,
	STUDIORENDER_DRAW_TRANSLUCENT_ONLY = 0x02,
	STUDIORENDER_DRAW_GROUP_MASK = 0x03,

	STUDIORENDER_DRAW_NO_FLEXES = 0x04,
	STUDIORENDER_DRAW_STATIC_LIGHTING = 0x08,

	STUDIORENDER_DRAW_ACCURATETIME = 0x10, // Use accurate timing when drawing the model.
	STUDIORENDER_DRAW_NO_SHADOWS = 0x20,
	STUDIORENDER_DRAW_GET_PERF_STATS = 0x40,

	STUDIORENDER_DRAW_WIREFRAME = 0x80,

	STUDIORENDER_DRAW_ITEM_BLINK = 0x100,

	STUDIORENDER_SHADOWDEPTHTEXTURE = 0x200
};
enum {
   FBEAM_STARTENTITY = 0x00000001,
   FBEAM_ENDENTITY = 0x00000002,
   FBEAM_FADEIN = 0x00000004,
   FBEAM_FADEOUT = 0x00000008,
   FBEAM_SINENOISE = 0x00000010,
   FBEAM_SOLID = 0x00000020,
   FBEAM_SHADEIN = 0x00000040,
   FBEAM_SHADEOUT = 0x00000080,
   FBEAM_ONLYNOISEONCE = 0x00000100,		// Only calculate our noise once
   FBEAM_NOTILE = 0x00000200,
   FBEAM_USE_HITBOXES = 0x00000400,		// Attachment indices represent hitbox indices instead when this is set.
   FBEAM_STARTVISIBLE = 0x00000800,		// Has this client actually seen this beam's start entity yet?
   FBEAM_ENDVISIBLE = 0x00001000,		// Has this client actually seen this beam's end entity yet?
   FBEAM_ISACTIVE = 0x00002000,
   FBEAM_FOREVER = 0x00004000,
   FBEAM_HALOBEAM = 0x00008000,		// When drawing a beam with a halo, don't ignore the segments and endwidth
   FBEAM_REVERSED = 0x00010000,
   NUM_BEAM_FLAGS = 17	// KEEP THIS UPDATED!
};
enum RenderableTranslucencyType_t {
   RENDERABLE_IS_OPAQUE = 0,
   RENDERABLE_IS_TRANSLUCENT,
   RENDERABLE_IS_TWO_PASS,    // has both translucent and opaque sub-partsa
};

enum ItemDefinitionIndex {
	WEAPON_DEAGLE = 1,
	WEAPON_ELITE = 2,
	WEAPON_FIVESEVEN = 3,
	WEAPON_GLOCK = 4,
	WEAPON_AK47 = 7,
	WEAPON_AUG = 8,
	WEAPON_AWP = 9,
	WEAPON_FAMAS = 10,
	WEAPON_G3SG1 = 11,
	WEAPON_GALIL = 13,
	WEAPON_M249 = 14,
	WEAPON_M4A4 = 16,
	WEAPON_MAC10 = 17,
	WEAPON_P90 = 19,
	WEAPON_UMP45 = 24,
	WEAPON_XM1014 = 25,
	WEAPON_BIZON = 26,
	WEAPON_MAG7 = 27,
	WEAPON_NEGEV = 28,
	WEAPON_SAWEDOFF = 29,
	WEAPON_TEC9 = 30,
	WEAPON_ZEUS = 31,
	WEAPON_P2000 = 32,
	WEAPON_MP7 = 33,
	WEAPON_MP9 = 34,
	WEAPON_NOVA = 35,
	WEAPON_P250 = 36,
	WEAPON_SCAR20 = 38,
	WEAPON_SG553 = 39,
	WEAPON_SSG08 = 40,
	WEAPON_KNIFE_T = 42,
	WEAPON_FLASHBANG = 43,
	WEAPON_HEGRENADE = 44,
	WEAPON_SMOKE = 45,
	WEAPON_MOLOTOV = 46,
	WEAPON_DECOY = 47,
	WEAPON_FIREBOMB = 48,
	WEAPON_C4 = 49,
	WEAPON_MUSICKIT = 58,
	WEAPON_KNIFE_CT = 59,
	WEAPON_M4A1S = 60,
	WEAPON_USPS = 61,
	WEAPON_TRADEUPCONTRACT = 62,
	WEAPON_CZ75A = 63,
	WEAPON_REVOLVER = 64,
	WEAPON_KNIFE_BAYONET = 500,
	WEAPON_KNIFE_FLIP = 505,
	WEAPON_KNIFE_GUT = 506,
	WEAPON_KNIFE_KARAMBIT = 507,
	WEAPON_KNIFE_M9_BAYONET = 508,
	WEAPON_KNIFE_HUNTSMAN = 509,
	WEAPON_KNIFE_FALCHION = 512,
	WEAPON_KNIFE_BOWIE = 514,
	WEAPON_KNIFE_BUTTERFLY = 515,
	WEAPON_KNIFE_SHADOW_DAGGERS = 516,
	GLOVE_STUDDED_BLOODHOUND = 5027,
	GLOVE_T_SIDE = 5028,
	GLOVE_CT_SIDE = 5029,
	GLOVE_SPORTY = 5030,
	GLOVE_SLICK = 5031,
	GLOVE_LEATHER_WRAP = 5032,
	GLOVE_MOTORCYCLE = 5033,
	GLOVE_SPECIALIST = 5034
};

enum FontFeature {
   FONT_FEATURE_ANTIALIASED_FONTS = 1,
   FONT_FEATURE_DROPSHADOW_FONTS = 2,
   FONT_FEATURE_OUTLINE_FONTS = 6,
};

enum FontDrawType {
   FONT_DRAW_DEFAULT = 0,
   FONT_DRAW_NONADDITIVE,
   FONT_DRAW_ADDITIVE,
   FONT_DRAW_TYPE_COUNT = 2,
};

enum MoveType {
   MOVETYPE_NONE = 0,
   MOVETYPE_ISOMETRIC,
   MOVETYPE_WALK,
   MOVETYPE_STEP,
   MOVETYPE_FLY,
   MOVETYPE_FLYGRAVITY,
   MOVETYPE_VPHYSICS,
   MOVETYPE_PUSH,
   MOVETYPE_NOCLIP,
   MOVETYPE_LADDER,
   MOVETYPE_OBSERVER,
   MOVETYPE_CUSTOM,
};

enum CompiledVtfFlags {
   TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
   TEXTUREFLAGS_TRILINEAR = 0x00000002,
   TEXTUREFLAGS_CLAMPS = 0x00000004,
   TEXTUREFLAGS_CLAMPT = 0x00000008,
   TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
   TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
   TEXTUREFLAGS_PWL_CORRECTED = 0x00000040,
   TEXTUREFLAGS_NORMAL = 0x00000080,
   TEXTUREFLAGS_NOMIP = 0x00000100,
   TEXTUREFLAGS_NOLOD = 0x00000200,
   TEXTUREFLAGS_ALL_MIPS = 0x00000400,
   TEXTUREFLAGS_PROCEDURAL = 0x00000800,
   TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
   TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,
   TEXTUREFLAGS_ENVMAP = 0x00004000,
   TEXTUREFLAGS_RENDERTARGET = 0x00008000,
   TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
   TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
   TEXTUREFLAGS_SINGLECOPY = 0x00040000,
   TEXTUREFLAGS_PRE_SRGB = 0x00080000,
   TEXTUREFLAGS_UNUSED_00100000 = 0x00100000,
   TEXTUREFLAGS_UNUSED_00200000 = 0x00200000,
   TEXTUREFLAGS_UNUSED_00400000 = 0x00400000,
   TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,
   TEXTUREFLAGS_UNUSED_01000000 = 0x01000000,
   TEXTUREFLAGS_CLAMPU = 0x02000000,
   TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,
   TEXTUREFLAGS_SSBUMP = 0x08000000,
   TEXTUREFLAGS_UNUSED_10000000 = 0x10000000,
   TEXTUREFLAGS_BORDER = 0x20000000,
   TEXTUREFLAGS_UNUSED_40000000 = 0x40000000,
   TEXTUREFLAGS_UNUSED_80000000 = 0x80000000
};

enum StandardLightmap_t {
   MATERIAL_SYSTEM_LIGHTMAP_PAGE_WHITE = -1,
   MATERIAL_SYSTEM_LIGHTMAP_PAGE_WHITE_BUMP = -2,
   MATERIAL_SYSTEM_LIGHTMAP_PAGE_USER_DEFINED = -3
};

enum MaterialThreadMode_t {
   MATERIAL_SINGLE_THREADED,
   MATERIAL_QUEUED_SINGLE_THREADED,
   MATERIAL_QUEUED_THREADED
};

enum MaterialContextType_t {
   MATERIAL_HARDWARE_CONTEXT,
   MATERIAL_QUEUED_CONTEXT,
   MATERIAL_NULL_CONTEXT
};

enum {
   MATERIAL_ADAPTER_NAME_LENGTH = 512
};

enum HDRType_t {
   HDR_TYPE_NONE,
   HDR_TYPE_INTEGER,
   HDR_TYPE_FLOAT,
};

enum RestoreChangeFlags_t {
   MATERIAL_RESTORE_VERTEX_FORMAT_CHANGED = 0x1,
   MATERIAL_RESTORE_RELEASE_MANAGED_RESOURCES = 0x2,
};

enum RenderTargetSizeMode_t {
   RT_SIZE_NO_CHANGE = 0,
   RT_SIZE_DEFAULT = 1,
   RT_SIZE_PICMIP = 2,
   RT_SIZE_HDR = 3,
   RT_SIZE_FULL_FRAME_BUFFER = 4,
   RT_SIZE_OFFSCREEN = 5,
   RT_SIZE_FULL_FRAME_BUFFER_ROUNDED_UP = 6
};

enum MaterialRenderTargetDepth_t {
   MATERIAL_RT_DEPTH_SHARED = 0x0,
   MATERIAL_RT_DEPTH_SEPARATE = 0x1,
   MATERIAL_RT_DEPTH_NONE = 0x2,
   MATERIAL_RT_DEPTH_ONLY = 0x3,
};

enum CSWeaponType {
   WEAPONTYPE_KNIFE = 0,
   WEAPONTYPE_PISTOL,
   WEAPONTYPE_SUBMACHINEGUN,
   WEAPONTYPE_RIFLE,
   WEAPONTYPE_SHOTGUN,
   WEAPONTYPE_SNIPER_RIFLE,
   WEAPONTYPE_MACHINEGUN,
   WEAPONTYPE_C4,
   WEAPONTYPE_PLACEHOLDER,
   WEAPONTYPE_GRENADE,
   WEAPONTYPE_UNKNOWN
};

enum PLAYER_TEAM {
   TEAM_NONE = 0,
   TEAM_SPEC = 1,
   TEAM_TT,
   TEAM_CT
};

enum SolidType_t {
   SOLID_NONE = 0,	// no solid model
   SOLID_BSP = 1,	// a BSP tree
   SOLID_BBOX = 2,	// an AABB
   SOLID_OBB = 3,	// an OBB (not implemented yet)
   SOLID_OBB_YAW = 4,	// an OBB, constrained so that it can only yaw
   SOLID_CUSTOM = 5,	// Always call into the entity for tests
   SOLID_VPHYSICS = 6,	// solid vphysics object, get vcollide from the model and collide with that
   SOLID_LAST,
};


enum Collision_Groups {
   COLLISION_GROUP_NONE = 0,
   COLLISION_GROUP_DEBRIS,			// Collides with nothing but world and static stuff
   COLLISION_GROUP_DEBRIS_TRIGGER,         // Same as debris, but hits triggers
   COLLISION_GROUP_INTERACTIVE_DEBRIS,	// Collides with everything except other interactive debris or debris
   COLLISION_GROUP_INTERACTIVE,		// Collides with everything except interactive debris or debris
   COLLISION_GROUP_PLAYER,
   COLLISION_GROUP_BREAKABLE_GLASS,
   COLLISION_GROUP_VEHICLE,
   COLLISION_GROUP_PLAYER_MOVEMENT,  	// For HL2, same as Collision_Group_Player, for
						   // TF2, this filters out other players and CBaseObjects
   COLLISION_GROUP_NPC,			// Generic NPC group
   COLLISION_GROUP_IN_VEHICLE,		// for any entity inside a vehicle
   COLLISION_GROUP_WEAPON,			// for any weapons that need collision detection
   COLLISION_GROUP_VEHICLE_CLIP,		// vehicle clip brush to restrict vehicle movement
   COLLISION_GROUP_PROJECTILE,		// Projectiles!	  
   COLLISION_GROUP_DOOR_BLOCKER,		// Blocks entities not permitted to get near moving doors
   COLLISION_GROUP_PASSABLE_DOOR,		// Doors that the player shouldn't collide with
   COLLISION_GROUP_DISSOLVING,		// Things that are dissolving are in this group
   COLLISION_GROUP_PUSHAWAY,		// Nonsolid on client and server, pushaway in player code

   COLLISION_GROUP_NPC_ACTOR,		// Used so NPCs in scripts ignore the player.
   COLLISION_GROUP_NPC_SCRIPTED,		// Used for NPCs in scripts that should not collide with each other
};
enum ClassId_t {
	CAI_BaseNPC = 0,
	CAK47,
	CBaseAnimating,
	CBaseAnimatingOverlay,
	CBaseAttributableItem,
	CBaseButton,
	CBaseCombatCharacter,
	CBaseCombatWeapon,
	CBaseCSGrenade,
	CBaseCSGrenadeProjectile,
	CBaseDoor,
	CBaseEntity,
	CBaseFlex,
	CBaseGrenade,
	CBaseParticleEntity,
	CBasePlayer,
	CBasePropDoor,
	CBaseTeamObjectiveResource,
	CBaseTempEntity,
	CBaseToggle,
	CBaseTrigger,
	CBaseViewModel,
	CBaseVPhysicsTrigger,
	CBaseWeaponWorldModel,
	CBeam,
	CBeamSpotlight,
	CBoneFollower,
	CBreakableProp,
	CBreakableSurface,
	CC4,
	CCascadeLight,
	CChicken,
	CColorCorrection,
	CColorCorrectionVolume,
	CCSGameRulesProxy,
	CCSPlayer,
	CCSPlayerResource,
	CCSRagdoll,
	CCSTeam,
	CDEagle,
	CDecoyGrenade,
	CDecoyProjectile,
	CDynamicLight,
	CDynamicProp,
	CEconEntity,
	CEconWearable,
	CEmbers,
	CEntityDissolve,
	CEntityFlame,
	CEntityFreezing,
	CEntityParticleTrail,
	CEnvAmbientLight,
	CEnvDetailController,
	CEnvDOFController,
	CEnvParticleScript,
	CEnvProjectedTexture,
	CEnvQuadraticBeam,
	CEnvScreenEffect,
	CEnvScreenOverlay,
	CEnvTonemapController,
	CEnvWind,
	CFEPlayerDecal,
	CFireCrackerBlast,
	CFireSmoke,
	CFireTrail,
	CFish,
	CFlashbang,
	CFogController,
	CFootstepControl,
	CFunc_Dust,
	CFunc_LOD,
	CFuncAreaPortalWindow,
	CFuncBrush,
	CFuncConveyor,
	CFuncLadder,
	CFuncMonitor,
	CFuncMoveLinear,
	CFuncOccluder,
	CFuncReflectiveGlass,
	CFuncRotating,
	CFuncSmokeVolume,
	CFuncTrackTrain,
	CGameRulesProxy,
	CHandleTest,
	CHEGrenade,
	CHostage,
	CHostageCarriableProp,
	CIncendiaryGrenade,
	CInferno,
	CInfoLadderDismount,
	CInfoOverlayAccessor,
	CItem_Healthshot,
	CItemDogTags,
	CKnife,
	CKnifeGG,
	CLightGlow,
	CMaterialModifyControl,
	CMolotovGrenade,
	CMolotovProjectile,
	CMovieDisplay,
	CParticleFire,
	CParticlePerformanceMonitor,
	CParticleSystem,
	CPhysBox,
	CPhysBoxMultiplayer,
	CPhysicsProp,
	CPhysicsPropMultiplayer,
	CPhysMagnet,
	CPlantedC4,
	CPlasma,
	CPlayerResource,
	CPointCamera,
	CPointCommentaryNode,
	CPointWorldText,
	CPoseController,
	CPostProcessController,
	CPrecipitation,
	CPrecipitationBlocker,
	CPredictedViewModel,
	CProp_Hallucination,
	CPropDoorRotating,
	CPropJeep,
	CPropVehicleDriveable,
	CRagdollManager,
	CRagdollProp,
	CRagdollPropAttached,
	CRopeKeyframe,
	CSCAR17,
	CSceneEntity,
	CSensorGrenade,
	CSensorGrenadeProjectile,
	CShadowControl,
	CSlideshowDisplay,
	CSmokeGrenade,
	CSmokeGrenadeProjectile,
	CSmokeStack,
	CSpatialEntity,
	CSpotlightEnd,
	CSprite,
	CSpriteOriented,
	CSpriteTrail,
	CStatueProp,
	CSteamJet,
	CSun,
	CSunlightShadowControl,
	CTeam,
	CTeamplayRoundBasedRulesProxy,
	CTEArmorRicochet,
	CTEBaseBeam,
	CTEBeamEntPoint,
	CTEBeamEnts,
	CTEBeamFollow,
	CTEBeamLaser,
	CTEBeamPoints,
	CTEBeamRing,
	CTEBeamRingPoint,
	CTEBeamSpline,
	CTEBloodSprite,
	CTEBloodStream,
	CTEBreakModel,
	CTEBSPDecal,
	CTEBubbles,
	CTEBubbleTrail,
	CTEClientProjectile,
	CTEDecal,
	CTEDust,
	CTEDynamicLight,
	CTEEffectDispatch,
	CTEEnergySplash,
	CTEExplosion,
	CTEFireBullets,
	CTEFizz,
	CTEFootprintDecal,
	CTEFoundryHelpers,
	CTEGaussExplosion,
	CTEGlowSprite,
	CTEImpact,
	CTEKillPlayerAttachments,
	CTELargeFunnel,
	CTEMetalSparks,
	CTEMuzzleFlash,
	CTEParticleSystem,
	CTEPhysicsProp,
	CTEPlantBomb,
	CTEPlayerAnimEvent,
	CTEPlayerDecal,
	CTEProjectedDecal,
	CTERadioIcon,
	CTEShatterSurface,
	CTEShowLine,
	CTesla,
	CTESmoke,
	CTESparks,
	CTESprite,
	CTESpriteSpray,
	CTest_ProxyToggle_Networkable,
	CTestTraceline,
	CTEWorldDecal,
	CTriggerPlayerMovement,
	CTriggerSoundOperator,
	CVGuiScreen,
	CVoteController,
	CWaterBullet,
	CWaterLODControl,
	CWeaponAug,
	CWeaponAWP,
	CWeaponBaseItem,
	CWeaponBizon,
	CWeaponCSBase,
	CWeaponCSBaseGun,
	CWeaponCycler,
	CWeaponElite,
	CWeaponFamas,
	CWeaponFiveSeven,
	CWeaponG3SG1,
	CWeaponGalil,
	CWeaponGalilAR,
	CWeaponGlock,
	CWeaponHKP2000,
	CWeaponM249,
	CWeaponM3,
	CWeaponM4A1,
	CWeaponMAC10,
	CWeaponMag7,
	CWeaponMP5Navy,
	CWeaponMP7,
	CWeaponMP9,
	CWeaponNegev,
	CWeaponNOVA,
	CWeaponP228,
	CWeaponP250,
	CWeaponP90,
	CWeaponSawedoff,
	CWeaponSCAR20,
	CWeaponScout,
	CWeaponSG550,
	CWeaponSG552,
	CWeaponSG556,
	CWeaponSSG08,
	CWeaponTaser,
	CWeaponTec9,
	CWeaponTMP,
	CWeaponUMP45,
	CWeaponUSP,
	CWeaponXM1014,
	CWorld,
	DustTrail,
	MovieExplosion,
	ParticleSmokeGrenade,
	RocketTrail,
	SmokeTrail,
	SporeExplosion,
	SporeTrail,
	MAX_CLASSID
};

enum PreviewImageRetVal_t {
   MATERIAL_PREVIEW_IMAGE_BAD = 0,
   MATERIAL_PREVIEW_IMAGE_OK,
   MATERIAL_NO_PREVIEW_IMAGE,
};

enum class TraceType {
   TRACE_EVERYTHING = 0,
   TRACE_WORLD_ONLY,
   TRACE_ENTITIES_ONLY,
   TRACE_EVERYTHING_FILTER_PROPS,
};

enum class DebugTraceCounterBehavior_t {
   kTRACE_COUNTER_SET = 0,
   kTRACE_COUNTER_INC,
};

enum MaterialVarFlags_t {
   MATERIAL_VAR_DEBUG = ( 1 << 0 ),
   MATERIAL_VAR_NO_DEBUG_OVERRIDE = ( 1 << 1 ),
   MATERIAL_VAR_NO_DRAW = ( 1 << 2 ),
   MATERIAL_VAR_USE_IN_FILLRATE_MODE = ( 1 << 3 ),
   MATERIAL_VAR_VERTEXCOLOR = ( 1 << 4 ),
   MATERIAL_VAR_VERTEXALPHA = ( 1 << 5 ),
   MATERIAL_VAR_SELFILLUM = ( 1 << 6 ),
   MATERIAL_VAR_ADDITIVE = ( 1 << 7 ),
   MATERIAL_VAR_ALPHATEST = ( 1 << 8 ),
   //MATERIAL_VAR_UNUSED = (1 << 9),
   MATERIAL_VAR_ZNEARER = ( 1 << 10 ),
   MATERIAL_VAR_MODEL = ( 1 << 11 ),
   MATERIAL_VAR_FLAT = ( 1 << 12 ),
   MATERIAL_VAR_NOCULL = ( 1 << 13 ),
   MATERIAL_VAR_NOFOG = ( 1 << 14 ),
   MATERIAL_VAR_IGNOREZ = ( 1 << 15 ),
   MATERIAL_VAR_DECAL = ( 1 << 16 ),
   MATERIAL_VAR_ENVMAPSPHERE = ( 1 << 17 ), // OBSOLETE
   MATERIAL_VAR_UNUSED = ( 1 << 18 ), // UNUSED
   MATERIAL_VAR_ENVMAPCAMERASPACE = ( 1 << 19 ), // OBSOLETE
   MATERIAL_VAR_BASEALPHAENVMAPMASK = ( 1 << 20 ),
   MATERIAL_VAR_TRANSLUCENT = ( 1 << 21 ),
   MATERIAL_VAR_NORMALMAPALPHAENVMAPMASK = ( 1 << 22 ),
   MATERIAL_VAR_NEEDS_SOFTWARE_SKINNING = ( 1 << 23 ), // OBSOLETE
   MATERIAL_VAR_OPAQUETEXTURE = ( 1 << 24 ),
   MATERIAL_VAR_ENVMAPMODE = ( 1 << 25 ), // OBSOLETE
   MATERIAL_VAR_SUPPRESS_DECALS = ( 1 << 26 ),
   MATERIAL_VAR_HALFLAMBERT = ( 1 << 27 ),
   MATERIAL_VAR_WIREFRAME = ( 1 << 28 ),
   MATERIAL_VAR_ALLOWALPHATOCOVERAGE = ( 1 << 29 ),
   MATERIAL_VAR_ALPHA_MODIFIED_BY_PROXY = ( 1 << 30 ),
   MATERIAL_VAR_VERTEXFOG = ( 1 << 31 ),
};

enum MaterialType_t {
   CHAR_TEX_ANTLION = 'A',
   CHAR_TEX_BLOODYFLESH = 'B',
   CHAR_TEX_CONCRETE = 'C',
   CHAR_TEX_DIRT = 'D',
   CHAR_TEX_EGGSHELL = 'E',
   CHAR_TEX_FLESH = 'F',
   CHAR_TEX_GRATE = 'G',
   CHAR_TEX_ALIENFLESH = 'H',
   CHAR_TEX_CLIP = 'I',
   CHAR_TEX_PLASTIC = 'L',
   CHAR_TEX_METAL = 'M',
   CHAR_TEX_SAND = 'N',
   CHAR_TEX_FOLIAGE = 'O',
   CHAR_TEX_COMPUTER = 'P',
   CHAR_TEX_SLOSH = 'S',
   CHAR_TEX_TILE = 'T',
   CHAR_TEX_CARDBOARD = 'U',
   CHAR_TEX_VENT = 'V',
   CHAR_TEX_WOOD = 'W',
   CHAR_TEX_GLASS = 'Y',
   CHAR_TEX_WARPSHIELD = 'Z',
};

// entity effects C_BaseEntity::m_fEffects
enum EntityEffects_t : int {
   EF_BONEMERGE = 0x001,          // Performs bone merge on client side
   EF_BRIGHTLIGHT = 0x002,        // DLIGHT centered at entity origin
   EF_DIMLIGHT = 0x004,           // player flashlight
   EF_NOINTERP = 0x008,           // don't interpolate the next frame
   EF_NOSHADOW = 0x010,           // Don't cast no shadow
   EF_NODRAW = 0x020,             // don't draw entity
   EF_NORECEIVESHADOW = 0x040,    // Don't receive no shadow
   EF_BONEMERGE_FASTCULL = 0x080, // For use with EF_BONEMERGE. If this is set, then it places this ent's origin at its
											 // parent and uses the parent's bbox + the max extents of the aiment.
											 // Otherwise, it sets up the parent's bones every frame to figure out where to place
											 // the aiment, which is inefficient because it'll setup the parent's bones even if
											 // the parent is not in the PVS.

											 EF_ITEM_BLINK = 0x100,         // blink an item so that the user notices it.
											 EF_PARENT_ANIMATES = 0x200,    // always assume that the parent entity is animating
											 EF_MAX_BITS = 10
};

// entity flags, CBaseEntity::m_iEFlags
enum EFlags_t : int {
   EFL_KILLME = ( 1 << 0 ),                    // This entity is marked for death -- This allows the game to actually delete ents at a safe time
   EFL_DORMANT = ( 1 << 1 ),                   // Entity is dormant, no updates to client
   EFL_NOCLIP_ACTIVE = ( 1 << 2 ),             // Lets us know when the noclip command is active.
   EFL_SETTING_UP_BONES = ( 1 << 3 ),          // Set while a model is setting up its bones.
   EFL_KEEP_ON_RECREATE_ENTITIES = ( 1 << 4 ), // This is a special entity that should not be deleted when we restart entities only

   EFL_HAS_PLAYER_CHILD = ( 1 << 4 ), // One of the child entities is a player.

   EFL_DIRTY_SHADOWUPDATE = ( 1 << 5 ), // Client only- need shadow manager to update the shadow...
   EFL_NOTIFY = ( 1 << 6 ),             // Another entity is watching events on this entity (used by teleport)

	 // The default behavior in ShouldTransmit is to not send an entity if it doesn't
	 // have a model. Certain entities want to be sent anyway because all the drawing logic
	 // is in the client DLL. They can set this flag and the engine will transmit them even
	 // if they don't have a model.
	 EFL_FORCE_CHECK_TRANSMIT = ( 1 << 7 ),

	 EFL_BOT_FROZEN = ( 1 << 8 ),            // This is set on bots that are frozen.
	 EFL_SERVER_ONLY = ( 1 << 9 ),           // Non-networked entity.
	 EFL_NO_AUTO_EDICT_ATTACH = ( 1 << 10 ), // Don't attach the edict; we're doing it explicitly

	  // Some dirty bits with respect to abs computations
	  EFL_DIRTY_ABSTRANSFORM = ( 1 << 11 ),
	  EFL_DIRTY_ABSVELOCITY = ( 1 << 12 ),
	  EFL_DIRTY_ABSANGVELOCITY = ( 1 << 13 ),
	  EFL_DIRTY_SURROUNDING_COLLISION_BOUNDS = ( 1 << 14 ),
	  EFL_DIRTY_SPATIAL_PARTITION = ( 1 << 15 ),
	  //	UNUSED						= (1<<16),

	  // This is set if the entity detects that it's in the skybox.
	  // This forces it to pass the "in PVS" for transmission.
	  EFL_IN_SKYBOX = ( 1 << 17 ),

	  EFL_USE_PARTITION_WHEN_NOT_SOLID = ( 1 << 18 ), // Entities with this flag set show up in the partition even when not solid
	  EFL_TOUCHING_FLUID = ( 1 << 19 ),               // Used to determine if an entity is floating

	  // FIXME: Not really sure where I should add this...
	  EFL_IS_BEING_LIFTED_BY_BARNACLE = ( 1 << 20 ),
	  EFL_NO_ROTORWASH_PUSH = ( 1 << 21 ), // I shouldn't be pushed by the rotorwash
	  EFL_NO_THINK_FUNCTION = ( 1 << 22 ),
	  EFL_NO_GAME_PHYSICS_SIMULATION = ( 1 << 23 ),

	  EFL_CHECK_UNTOUCH = ( 1 << 24 ),
	  EFL_DONTBLOCKLOS = ( 1 << 25 ),              // I shouldn't block NPC line-of-sight
	  EFL_DONTWALKON = ( 1 << 26 ),                // NPC;s should not walk on this entity
	  EFL_NO_DISSOLVE = ( 1 << 27 ),               // These guys shouldn't dissolve
	  EFL_NO_MEGAPHYSCANNON_RAGDOLL = ( 1 << 28 ), // Mega physcannon can't ragdoll these guys.
	  EFL_NO_WATER_VELOCITY_CHANGE = ( 1 << 29 ),  // Don't adjust this entity's velocity when transitioning into water
	  EFL_NO_PHYSCANNON_INTERACTION = ( 1 << 30 ), // Physcannon can't pick these up or punt them
	  EFL_NO_DAMAGE_FORCES = ( 1 << 31 ),          // Doesn't accept forces from physics damage
};

enum LightType_t {
   MATERIAL_LIGHT_DISABLE = 0,
   MATERIAL_LIGHT_POINT,
   MATERIAL_LIGHT_DIRECTIONAL,
   MATERIAL_LIGHT_SPOT,
};

enum {
   DRAWWORLDLISTS_DRAW_STRICTLYABOVEWATER = 0x001,
   DRAWWORLDLISTS_DRAW_STRICTLYUNDERWATER = 0x002,
   DRAWWORLDLISTS_DRAW_INTERSECTSWATER = 0x004,
   DRAWWORLDLISTS_DRAW_WATERSURFACE = 0x008,
   DRAWWORLDLISTS_DRAW_SKYBOX = 0x010,
   DRAWWORLDLISTS_DRAW_CLIPSKYBOX = 0x020,
   DRAWWORLDLISTS_DRAW_SHADOWDEPTH = 0x040,
   DRAWWORLDLISTS_DRAW_REFRACTION = 0x080,
   DRAWWORLDLISTS_DRAW_REFLECTION = 0x100,
   DRAWWORLDLISTS_DRAW_WORLD_GEOMETRY = 0x200,
   DRAWWORLDLISTS_DRAW_DECALS_AND_OVERLAYS = 0x400,
};

enum {
   MAT_SORT_GROUP_STRICTLY_ABOVEWATER = 0,
   MAT_SORT_GROUP_STRICTLY_UNDERWATER,
   MAT_SORT_GROUP_INTERSECTS_WATER_SURFACE,
   MAT_SORT_GROUP_WATERSURFACE,

   MAX_MAT_SORT_GROUPS
};

enum class usermsg_type {
   CS_UM_VGUIMenu = 1,
   CS_UM_Geiger,
   CS_UM_Train,
   CS_UM_HudText,
   CS_UM_SayText,							// team chat?
   CS_UM_SayText2,							// all chat
   CS_UM_TextMsg,
   CS_UM_HudMsg,
   CS_UM_ResetHud,
   CS_UM_GameTitle,
   CS_UM_Shake = 12,						// map/server plugin shake effect?
   CS_UM_Fade,								// fade HUD in/out
   CS_UM_Rumble,							// controller rumble?
   CS_UM_CloseCaption,
   CS_UM_CloseCaptionDirect,
   CS_UM_SendAudio,
   CS_UM_RawAudio,
   CS_UM_VoiceMask,
   CS_UM_RequestState,
   CS_UM_Damage,
   CS_UM_RadioText,
   CS_UM_HintText,
   CS_UM_KeyHintText,
   CS_UM_ProcessSpottedEntityUpdate,
   CS_UM_ReloadEffect,
   CS_UM_AdjustMoney,
   CS_UM_UpdateTeamMoney,
   CS_UM_StopSpectatorMode,
   CS_UM_KillCam,
   CS_UM_DesiredTimescale,
   CS_UM_CurrentTimescale,
   CS_UM_AchievementEvent,
   CS_UM_MatchEndConditions,
   CS_UM_DisconnectToLobby,
   CS_UM_DisplayInventory = 37,
   CS_UM_WarmupHasEnded,
   CS_UM_ClientInfo,
   CS_UM_CallVoteFailed = 45,
   CS_UM_VoteStart,
   CS_UM_VotePass,
   CS_UM_VoteFailed,
   CS_UM_VoteSetup,
   CS_UM_SendLastKillerDamageToClient = 51,
   CS_UM_ItemPickup = 53,
   CS_UM_ShowMenu,							// show hud menu
   CS_UM_BarTime,							// For the C4 progress bar.
   CS_UM_AmmoDenied,
   CS_UM_MarkAchievement,
   CS_UM_ItemDrop = 59,
   CS_UM_GlowPropTurnOff
};
```

`CSGO SDK/SDK/Displacement.cpp`:

```cpp
#include "Displacement.hpp"
#include "Classes/PropManager.hpp"
#include "../Utils/FnvHash.hpp"

DllInitializeData Engine::Displacement{ };

namespace Engine
{
	__forceinline uintptr_t CallableFromRelative( DWORD nAddress ) {
		return nAddress + *( DWORD* )( nAddress + 1 ) + 5;
	}

	void Create( ) {
		auto& pPropManager = PropManager::Instance( );

		auto image_vstdlib = GetModuleHandleA( XorStr( "vstdlib.dll" ) );
		auto image_client = ( std::uintptr_t )GetModuleHandleA( XorStr( "client.dll" ) );
		auto image_engine = ( std::uintptr_t )GetModuleHandleA( XorStr( "engine.dll" ) );
		auto image_server = ( std::uintptr_t )GetModuleHandleA( XorStr( "server.dll" ) );
		auto image_shaderapidx9 = ( std::uintptr_t )GetModuleHandleA( XorStr( "shaderapidx9.dll" ) );

		// TODO: datamap
		Displacement.C_BaseEntity.m_MoveType = pPropManager->GetOffset( XorStr( "DT_BaseEntity" ), XorStr( "m_nRenderMode" ) ) + 1;
		Displacement.C_BaseEntity.m_rgflCoordinateFrame = pPropManager->GetOffset( XorStr( "DT_BaseEntity" ), XorStr( "m_CollisionGroup" ) ) - 0x30;

		Displacement.DT_BaseEntity.m_iTeamNum = pPropManager->GetOffset( XorStr( "DT_BaseEntity" ), XorStr( "m_iTeamNum" ) );
		Displacement.DT_BaseEntity.m_vecOrigin = pPropManager->GetOffset( XorStr( "DT_BaseEntity" ), XorStr( "m_vecOrigin" ) );
		Displacement.DT_BaseEntity.m_flSimulationTime = pPropManager->GetOffset( XorStr( "DT_BaseEntity" ), XorStr( "m_flSimulationTime" ) );
		Displacement.DT_BaseEntity.m_fEffects = pPropManager->GetOffset( XorStr( "DT_BaseEntity" ), XorStr( "m_fEffects" ) );
		Displacement.DT_BaseEntity.m_iEFlags = Displacement.DT_BaseEntity.m_fEffects - 0x8;
		Displacement.DT_BaseEntity.m_hOwnerEntity = pPropManager->GetOffset( XorStr( "DT_BaseEntity" ), XorStr( "m_hOwnerEntity" ) );
		Displacement.DT_BaseEntity.moveparent = pPropManager->GetOffset( XorStr( "DT_BaseEntity" ), XorStr( "moveparent" ) );
		Displacement.DT_BaseEntity.m_nModelIndex = pPropManager->GetOffset( XorStr( "DT_BaseEntity" ), XorStr( "m_nModelIndex" ) );
		Displacement.DT_BaseEntity.m_Collision = pPropManager->GetOffset( XorStr( "DT_BaseEntity" ), XorStr( "m_Collision" ) );
		Displacement.DT_BaseEntity.m_CollisionGroup = pPropManager->GetOffset( XorStr( "DT_BaseEntity" ), XorStr( "m_CollisionGroup" ) );
		Displacement.DT_BaseEntity.m_flAnimTime = pPropManager->GetOffset( XorStr( "DT_BaseEntity" ), XorStr( "m_flAnimTime" ) );

		Displacement.DT_BaseWeaponWorldModel.m_hCombatWeaponParent = pPropManager->GetOffset( XorStr( "DT_BaseWeaponWorldModel" ), XorStr( "m_hCombatWeaponParent" ) );

		auto m_hLightingOrigin = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_hLightingOrigin" ) );
		auto m_nForceBone = pPropManager->GetOffset( XorStr( "DT_BaseAnimating" ), XorStr( "m_nForceBone" ) );
		Displacement.C_BaseAnimating.InvalidateBoneCache = Memory::Scan( image_client, XorStr( "80 3D ? ? ? ? ? 74 16 A1 ? ? ? ? 48 C7 81" ) );

		Displacement.C_BaseAnimating.m_BoneAccessor = m_nForceBone + 0x1C; // todo
		Displacement.C_BaseAnimating.m_iMostRecentModelBoneCounter = *( int* )( Displacement.C_BaseAnimating.InvalidateBoneCache + 0x1B );
		Displacement.C_BaseAnimating.m_iPrevBoneMask = m_nForceBone + 0x10;
		Displacement.C_BaseAnimating.m_iAccumulatedBoneMask = m_nForceBone + 0x14;
		Displacement.C_BaseAnimating.m_bIsJiggleBonesEnabled = m_hLightingOrigin - 0x18;
		Displacement.C_BaseAnimating.m_iOcclusionFramecount = 0xA30;
		Displacement.C_BaseAnimating.m_iOcclusionFlags = 0xA28;
		Displacement.C_BaseAnimating.m_flLastBoneSetupTime = *( int* )( Displacement.C_BaseAnimating.InvalidateBoneCache + 0x11 );
		Displacement.C_BaseAnimating.m_CachedBoneData = *( int* )( Memory::Scan( image_client, XorStr( "FF B7 ?? ?? ?? ?? 52" ) ) + 2 ) + 0x4;
		Displacement.C_BaseAnimating.m_AnimOverlay = *( int* )( Memory::Scan( image_client, XorStr( "8B 89 ?? ?? ?? ?? 8D 0C D1" ) ) + 2 );

		auto BoneSnapshotsCall = Memory::Scan( image_client, XorStr( "8D 8F ?? ?? ?? ?? 6A 01 C7 87" ) );
		Displacement.C_BaseAnimating.m_pFirstBoneSnapshot = *( int* )( BoneSnapshotsCall + 0x2 );
		Displacement.C_BaseAnimating.m_pSecondBoneSnapshot = *( int* )( BoneSnapshotsCall + 0x1B );

		auto CacheBoneData = Memory::Scan( image_client, XorStr( "8D 87 ?? ?? ?? ?? 50 E8 ?? ?? ?? ?? 8B 06" ) );
		Displacement.C_BaseAnimating.m_nCachedBonesPosition = *( int* )( CacheBoneData + 0x2 ) + 0x4;
		Displacement.C_BaseAnimating.m_nCachedBonesRotation = *( int* )( CacheBoneData + 0x25 ) + 0x4;
		Displacement.C_BaseAnimating.m_pStudioHdr = *( int* )( Memory::Scan( image_client, XorStr( "8B B7 ?? ?? ?? ?? 89 74 24 20" ) ) + 0x2 ) + 0x4;
		Displacement.C_BaseAnimating.m_bShouldDraw = *( int* )( Memory::Scan( image_client, XorStr( "FF 15 ?? ?? ?? ?? 80 BE ?? ?? ?? ?? ?? 0F 84 ?? ?? ?? ??" ) ) + 0x8 );
		Displacement.C_BaseAnimating.m_pBoneMerge = *( int* )( Memory::Scan( image_client, XorStr( "89 86 ?? ?? ?? ?? E8 ?? ?? ?? ?? FF 75 08" ) ) + 2 );
		Displacement.C_BaseAnimating.m_pIk = *( int* )( Memory::Scan( image_client, XorStr( "8B 8F ?? ?? ?? ?? 89 4C 24 1C" ) ) + 2 ) + 4;

		Displacement.DT_BaseAnimating.m_bClientSideAnimation = pPropManager->GetOffset( XorStr( "DT_BaseAnimating" ), XorStr( "m_bClientSideAnimation" ) );
		Displacement.DT_BaseAnimating.m_flPoseParameter = pPropManager->GetOffset( XorStr( "DT_BaseAnimating" ), XorStr( "m_flPoseParameter" ) );
		Displacement.DT_BaseAnimating.m_nHitboxSet = pPropManager->GetOffset( XorStr( "DT_BaseAnimating" ), XorStr( "m_nHitboxSet" ) );
		Displacement.DT_BaseAnimating.m_flCycle = pPropManager->GetOffset( XorStr( "DT_BaseAnimating" ), XorStr( "m_flCycle" ) );
		Displacement.DT_BaseAnimating.m_nSequence = pPropManager->GetOffset( XorStr( "DT_BaseAnimating" ), XorStr( "m_nSequence" ) );
		Displacement.DT_BaseAnimating.m_flEncodedController = pPropManager->GetOffset( XorStr( "DT_BaseAnimating" ), XorStr( "m_flEncodedController" ) );

		Displacement.DT_BaseCombatCharacter.m_hActiveWeapon = pPropManager->GetOffset( XorStr( "DT_BaseCombatCharacter" ), XorStr( "m_hActiveWeapon" ) );
		Displacement.DT_BaseCombatCharacter.m_flNextAttack = pPropManager->GetOffset( XorStr( "DT_BaseCombatCharacter" ), XorStr( "m_flNextAttack" ) );
		Displacement.DT_BaseCombatCharacter.m_hMyWeapons = pPropManager->GetOffset( XorStr( "DT_BaseCombatCharacter" ), XorStr( "m_hMyWeapons" ) ) / 2;
		Displacement.DT_BaseCombatCharacter.m_hMyWearables = pPropManager->GetOffset( XorStr( "DT_BaseCombatCharacter" ), XorStr( "m_hMyWearables" ) );

		Displacement.C_BasePlayer.m_pCurrentCommand = 0x3338;
		auto relative_call = Memory::Scan( image_client, XorStr( "E8 ? ? ? ? 83 7D D8 00 7C 0F" ) );
		auto offset = *( uintptr_t* )( relative_call + 0x1 );
		Displacement.C_BasePlayer.UpdateVisibilityAllEntities = ( DWORD32 )( relative_call + 5 + offset );

		Displacement.DT_BasePlayer.m_aimPunchAngle = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_aimPunchAngle" ) );
		Displacement.DT_BasePlayer.m_aimPunchAngleVel = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_aimPunchAngleVel" ) );
		Displacement.DT_BasePlayer.m_viewPunchAngle = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_viewPunchAngle" ) );
		Displacement.DT_BasePlayer.m_vecViewOffset = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_vecViewOffset[0]" ) );
		Displacement.DT_BasePlayer.m_vecVelocity = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_vecVelocity[0]" ) );
		Displacement.DT_BasePlayer.m_vecBaseVelocity = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_vecBaseVelocity" ) );
		Displacement.DT_BasePlayer.m_flFallVelocity = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_flFallVelocity" ) );
		Displacement.DT_BasePlayer.m_flDuckAmount = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_flDuckAmount" ) );
		Displacement.DT_BasePlayer.m_flDuckSpeed = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_flDuckSpeed" ) );
		Displacement.DT_BasePlayer.m_lifeState = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_lifeState" ) );
		Displacement.DT_BasePlayer.m_nTickBase = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_nTickBase" ) );
		Displacement.DT_BasePlayer.m_iHealth = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_iHealth" ) );
		Displacement.DT_BasePlayer.m_iDefaultFOV = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_iDefaultFOV" ) );
		Displacement.DT_BasePlayer.m_fFlags = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_fFlags" ) );
		Displacement.DT_BasePlayer.m_bSpotted = pPropManager->GetOffset(XorStr("DT_BasePlayer"), XorStr("m_bSpotted"));
		Displacement.DT_BasePlayer.m_iObserverMode = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_iObserverMode" ) );
		Displacement.DT_BasePlayer.pl = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "pl" ) );
		Displacement.DT_BasePlayer.m_hObserverTarget = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_hObserverTarget" ) );
		Displacement.DT_BasePlayer.m_hViewModel = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_hViewModel[0]" ) );
		Displacement.DT_BasePlayer.m_vphysicsCollisionState = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_vphysicsCollisionState" ) );
		Displacement.DT_BasePlayer.m_ubEFNoInterpParity = pPropManager->GetOffset( XorStr( "DT_BasePlayer" ), XorStr( "m_ubEFNoInterpParity" ) );
		Displacement.DT_BasePlayer.m_ubOldEFNoInterpParity = *( int* )( Memory::Scan( image_client, XorStr( "8A 87 ?? ?? ?? ?? 8D 5F F8" ) ) + 2 ) + 8;

		Displacement.C_CSPlayer.m_PlayerAnimState = *( int* )( Memory::Scan( image_client, XorStr( "8B 8E ?? ?? ?? ?? 85 C9 74 3E" ) ) + 2 );
		Displacement.C_CSPlayer.m_flSpawnTime = *( int* )( Memory::Scan( image_client, XorStr( "89 86 ?? ?? ?? ?? E8 ?? ?? ?? ?? 80 BE ?? ?? ?? ?? ??" ) ) + 2 );
		Displacement.DT_CSPlayer.m_flLowerBodyYawTargetProxy = Memory::Scan( image_engine, XorStr( "EB 0D FF 77 10" ) );

		Displacement.DT_CSPlayer.m_angEyeAngles = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_angEyeAngles[0]" ) );
		Displacement.DT_CSPlayer.m_nSurvivalTeam = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_nSurvivalTeam" ) );
		Displacement.DT_CSPlayer.m_bHasHelmet = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_bHasHelmet" ) );
		Displacement.DT_CSPlayer.m_bHasHeavyArmor = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_bHasHeavyArmor" ) );
		Displacement.DT_CSPlayer.m_ArmorValue = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_ArmorValue" ) );
		Displacement.DT_CSPlayer.m_bScoped = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_bIsScoped" ) );
		Displacement.DT_CSPlayer.m_bIsWalking = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_bIsWalking" ) );
		Displacement.DT_CSPlayer.m_iAccount = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_iAccount" ) );
		Displacement.DT_CSPlayer.m_iShotsFired = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_iShotsFired" ) );
		Displacement.DT_CSPlayer.m_flFlashDuration = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_flFlashDuration" ) );
		Displacement.DT_CSPlayer.m_flLowerBodyYawTarget = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_flLowerBodyYawTarget" ) );
		Displacement.DT_CSPlayer.m_flVelocityModifier = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_flVelocityModifier" ) );
		Displacement.DT_CSPlayer.m_bGunGameImmunity = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_bGunGameImmunity" ) );
		Displacement.DT_CSPlayer.m_flHealthShotBoostExpirationTime = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_flHealthShotBoostExpirationTime" ) );
		Displacement.DT_CSPlayer.m_iMatchStats_Kills = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_iMatchStats_Kills" ) );
		Displacement.DT_CSPlayer.m_iMatchStats_Deaths = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_iMatchStats_Deaths" ) );
		Displacement.DT_CSPlayer.m_iMatchStats_HeadShotKills = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_iMatchStats_HeadShotKills" ) );
		Displacement.DT_CSPlayer.m_iMoveState = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_iMoveState" ) );
		Displacement.DT_CSPlayer.m_bWaitForNoAttack = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_bWaitForNoAttack" ) );
		Displacement.DT_CSPlayer.m_bCustomPlayer = *( int* )( Memory::Scan( image_client, XorStr( "80 BF ?? ?? ?? ?? ?? 0F 84 ?? ?? ?? ?? 83 BF ?? ?? ?? ?? ?? 74 7C" ) ) + 2 );
		Displacement.DT_CSPlayer.m_iPlayerState = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_iPlayerState" ) );
		Displacement.DT_CSPlayer.m_bIsDefusing = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_bIsDefusing" ) );
		Displacement.DT_CSPlayer.m_bHasDefuser = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_bHasDefuser" ) );
		Displacement.DT_CSPlayer.m_iFOV = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_iFOV" ) );
		Displacement.DT_CSPlayer.m_bIsPlayerGhost = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_bIsPlayerGhost" ) );
		Displacement.DT_CSPlayer.m_vecPlayerPatchEconIndices = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_vecPlayerPatchEconIndices" ) );
		Displacement.DT_CSPlayer.m_hRagdoll = pPropManager->GetOffset( XorStr( "DT_CSPlayer" ), XorStr( "m_hRagdoll" ) );

		Displacement.DT_CSRagdoll.m_hPlayer = pPropManager->GetOffset( XorStr( "DT_CSRagdoll" ), XorStr( "m_hPlayer" ) );

		Displacement.DT_FogController.m_fog_enable = pPropManager->GetOffset( XorStr( "DT_FogController" ), XorStr( "m_fog.enable" ) );
		Displacement.DT_Precipitation.m_nPrecipType = pPropManager->GetOffset( XorStr( "DT_Precipitation" ), XorStr( "m_nPrecipType" ) );

		Displacement.DT_BaseCombatWeapon.m_flNextPrimaryAttack = pPropManager->GetOffset( XorStr( "DT_BaseCombatWeapon" ), XorStr( "m_flNextPrimaryAttack" ) );
		Displacement.DT_BaseCombatWeapon.m_flNextSecondaryAttack = pPropManager->GetOffset( XorStr( "DT_BaseCombatWeapon" ), XorStr( "m_flNextSecondaryAttack" ) );
		Displacement.DT_BaseCombatWeapon.m_hOwner = pPropManager->GetOffset( XorStr( "DT_BaseCombatWeapon" ), XorStr( "m_hOwner" ) );
		Displacement.DT_BaseCombatWeapon.m_iClip1 = pPropManager->GetOffset( XorStr( "DT_BaseCombatWeapon" ), XorStr( "m_iClip1" ) );
		Displacement.DT_BaseCombatWeapon.m_iPrimaryReserveAmmoCount = pPropManager->GetOffset( XorStr( "DT_BaseCombatWeapon" ), XorStr( "m_iPrimaryReserveAmmoCount" ) );
		Displacement.DT_BaseCombatWeapon.m_iItemDefinitionIndex = pPropManager->GetOffset( XorStr( "DT_BaseCombatWeapon" ), XorStr( "m_iItemDefinitionIndex" ) );
		Displacement.DT_BaseCombatWeapon.m_hWeaponWorldModel = pPropManager->GetOffset( XorStr( "DT_BaseCombatWeapon" ), XorStr( "m_hWeaponWorldModel" ) );
		Displacement.DT_BaseCombatWeapon.m_iWorldModelIndex = pPropManager->GetOffset( XorStr( "DT_BaseCombatWeapon" ), XorStr( "m_iWorldModelIndex" ) );
		Displacement.DT_BaseCombatWeapon.m_iWorldDroppedModelIndex = pPropManager->GetOffset( XorStr( "DT_BaseCombatWeapon" ), XorStr( "m_iWorldDroppedModelIndex" ) );
		Displacement.DT_BaseCombatWeapon.m_iViewModelIndex = pPropManager->GetOffset( XorStr( "DT_BaseCombatWeapon" ), XorStr( "m_iViewModelIndex" ) );

		Displacement.DT_BaseCombatWeapon.m_CustomMaterials = ( *( int* )( Memory::Scan( image_client, XorStr( "83 BE ? ? ? ? ? 7F 67" ) ) + 0x2 ) ) - 12;
		Displacement.DT_BaseCombatWeapon.m_bCustomMaterialInitialized = *( int* )( Memory::Scan( image_client, XorStr( "C6 86 ? ? ? ? ? FF 50 04" ) ) + 0x2 );

		Displacement.DT_WeaponCSBase.m_flRecoilIndex = pPropManager->GetOffset( XorStr( "DT_WeaponCSBase" ), XorStr( "m_flRecoilIndex" ) );
		Displacement.DT_WeaponCSBase.m_weaponMode = pPropManager->GetOffset( XorStr( "DT_WeaponCSBase" ), XorStr( "m_weaponMode" ) );
		Displacement.DT_WeaponCSBase.m_flPostponeFireReadyTime = pPropManager->GetOffset( XorStr( "DT_WeaponCSBase" ), XorStr( "m_flPostponeFireReadyTime" ) );
		Displacement.DT_WeaponCSBase.m_fLastShotTime = pPropManager->GetOffset( XorStr( "DT_WeaponCSBase" ), XorStr( "m_fLastShotTime" ) );

		Displacement.DT_WeaponCSBaseGun.m_zoomLevel = pPropManager->GetOffset( XorStr( "DT_WeaponCSBaseGun" ), XorStr( "m_zoomLevel" ) );
		Displacement.DT_WeaponCSBaseGun.m_iBurstShotsRemaining = pPropManager->GetOffset( XorStr( "DT_WeaponCSBaseGun" ), XorStr( "m_iBurstShotsRemaining" ) );
		Displacement.DT_WeaponCSBaseGun.m_fNextBurstShot = pPropManager->GetOffset( XorStr( "DT_WeaponCSBaseGun" ), XorStr( "m_fNextBurstShot" ) );

		Displacement.DT_BaseCSGrenade.m_bPinPulled = pPropManager->GetOffset( XorStr( "DT_BaseCSGrenade" ), XorStr( "m_bPinPulled" ) );
		Displacement.DT_BaseCSGrenade.m_fThrowTime = pPropManager->GetOffset( XorStr( "DT_BaseCSGrenade" ), XorStr( "m_fThrowTime" ) );
		Displacement.DT_BaseCSGrenade.m_flThrowStrength = pPropManager->GetOffset( XorStr( "DT_BaseCSGrenade" ), XorStr( "m_flThrowStrength" ) );

		Displacement.DT_BaseAttributableItem.m_flFallbackWear = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_flFallbackWear" ) );
		Displacement.DT_BaseAttributableItem.m_nFallbackPaintKit = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_nFallbackPaintKit" ) );
		Displacement.DT_BaseAttributableItem.m_nFallbackSeed = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_nFallbackSeed" ) );
		Displacement.DT_BaseAttributableItem.m_nFallbackStatTrak = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_nFallbackStatTrak" ) );
		Displacement.DT_BaseAttributableItem.m_OriginalOwnerXuidHigh = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_OriginalOwnerXuidHigh" ) );
		Displacement.DT_BaseAttributableItem.m_OriginalOwnerXuidLow = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_OriginalOwnerXuidLow" ) );
		Displacement.DT_BaseAttributableItem.m_szCustomName = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_szCustomName" ) );
		Displacement.DT_BaseAttributableItem.m_bInitialized = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_bInitialized" ) );
		Displacement.DT_BaseAttributableItem.m_iAccountID = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_iAccountID" ) );
		Displacement.DT_BaseAttributableItem.m_iEntityLevel = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_iEntityLevel" ) );
		Displacement.DT_BaseAttributableItem.m_iEntityQuality = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_iEntityQuality" ) );
		Displacement.DT_BaseAttributableItem.m_iItemDefinitionIndex = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_iItemDefinitionIndex" ) );
		Displacement.DT_BaseAttributableItem.m_Item = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_Item" ) );
		Displacement.DT_BaseAttributableItem.m_iItemIDLow = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_iItemIDLow" ) );
		Displacement.DT_BaseAttributableItem.m_iItemIDHigh = pPropManager->GetOffset( XorStr( "DT_BaseAttributableItem" ), XorStr( "m_iItemIDHigh" ) );

		Displacement.DT_BaseViewModel.m_hOwner = pPropManager->GetOffset( XorStr( "DT_BaseViewModel" ), XorStr( "m_hOwner" ) );
		Displacement.DT_BaseViewModel.m_hWeapon = pPropManager->GetOffset( XorStr( "DT_BaseViewModel" ), XorStr( "m_hWeapon" ) );
		Displacement.DT_BaseViewModel.m_nSequence = pPropManager->GetOffset( XorStr( "DT_BaseViewModel" ), XorStr( "m_nSequence" ) );

		Displacement.DT_SmokeGrenadeProjectile.m_nSmokeEffectTickBegin = pPropManager->GetOffset( XorStr( "DT_SmokeGrenadeProjectile" ), XorStr( "m_bDidSmokeEffect" ) );
		Displacement.DT_SmokeGrenadeProjectile.m_nSmokeCount = Memory::Scan( image_client, XorStr( "A3 ? ? ? ? 57 8B CB" ) ) + 0x1;
		//Displacement.DT_SmokeGrenadeProjectile.m_SmokeParticlesSpawned = *( int* )( Memory::Scan( image_client, XorStr( "80 BF ?? ?? ?? ?? ?? 0F 85 ?? ?? ?? ?? F3 0F 7E 87 ?? ?? ?? ??" ) ) + 2 );

		Displacement.CBoneMergeCache.m_nConstructor = Memory::Scan( image_client, XorStr( "56 8B F1 0F 57 C0 C7 86 ?? ?? ?? ?? ?? ?? ?? ??" ) );
		Displacement.CBoneMergeCache.m_nInit = CallableFromRelative( Memory::Scan( image_client, XorStr( "E8 ?? ?? ?? ?? FF 75 08 8B 8E ?? ?? ?? ??" ) ) );
		Displacement.CBoneMergeCache.m_nUpdateCache = CallableFromRelative( Memory::Scan( image_client, XorStr( "E8 ?? ?? ?? ?? 83 7E 10 00 74 64" ) ) );
		Displacement.CBoneMergeCache.m_CopyToFollow = CallableFromRelative( Memory::Scan( image_client, XorStr( "E8 ?? ?? ?? ?? 8B 87 ?? ?? ?? ?? 8D 8C 24 ?? ?? ?? ?? 8B 7C 24 18" ) ) );
		Displacement.CBoneMergeCache.m_CopyFromFollow = CallableFromRelative( Memory::Scan( image_client, XorStr( "E8 ?? ?? ?? ?? F3 0F 10 45 ?? 8D 84 24 ?? ?? ?? ??" ) ) );

		//	Displacement.CIKContext.m_nConstructor = Memory::Scan( image_client, XorStr( "53 8B D9 F6 C3 03 74 0B FF 15 ?? ?? ?? ?? 84 C0 74 01 CC C7 83 ?? ?? ?? ?? ?? ?? ?? ?? 8B CB" ) );
		Displacement.CIKContext.m_nDestructor = Memory::Scan( image_client, XorStr( "56 8B F1 57 8D 8E ?? ?? ?? ?? E8 ?? ?? ?? ?? 8D 8E ?? ?? ?? ?? E8 ?? ?? ?? ?? 83 BE ?? ?? ?? ?? ??" ) );
		Displacement.CIKContext.m_nInit = Memory::Scan( image_client, XorStr( "55 8B EC 83 EC 08 8B 45 08 56 57 8B F9 8D 8F" ) );
		Displacement.CIKContext.m_nUpdateTargets = Memory::Scan( image_client, XorStr( "55 8B EC 83 E4 F0 81 EC ?? ?? ?? ?? 33 D2" ) );
		Displacement.CIKContext.m_nSolveDependencies = Memory::Scan( image_client, XorStr( "55 8B EC 83 E4 F0 81 EC ?? ?? ?? ?? 8B 81" ) );

		Displacement.CBoneSetup.InitPose = Memory::Scan( image_client, XorStr( "55 8B EC 83 EC 10 53 8B D9 89 55 F8 56 57 89 5D F4 8B 0B 89 4D F0" ) );
		Displacement.CBoneSetup.AccumulatePose = Memory::Scan( image_client, XorStr( "55 8B EC 83 E4 F0 B8 ?? ?? ?? ?? E8 ?? ?? ?? ?? A1 ?? ?? ?? ??" ) );
		Displacement.CBoneSetup.CalcAutoplaySequences = Memory::Scan( image_client, XorStr( "55 8B EC 83 EC 10 53 56 57 8B 7D 10 8B D9 F3 0F 11 5D ??" ) );
		Displacement.CBoneSetup.CalcBoneAdj = Memory::Scan( image_client, XorStr( "55 8B EC 83 E4 F8 81 EC ?? ?? ?? ?? 8B C1 89 54 24 04 89 44 24 2C 56 57 8B 00" ) );

		Displacement.IPrediction.m_nCommandsPredicted = 0x1C;

		// jmp patterns is not very reliable
		auto CL_Predict = Memory::Scan( image_engine, XorStr( "75 30 8B 87 ?? ?? ?? ??" ) );
		auto CL_Move = Memory::Scan( image_engine, XorStr( "74 0F 80 BF ?? ?? ?? ?? ??" ) );
		Displacement.CClientState.m_nLastCommandAck = *( int* )( CL_Predict + 0x20 );
		Displacement.CClientState.m_nDeltaTick = *( int* )( CL_Predict + 0x10 );
		Displacement.CClientState.m_nLastOutgoingCommand = *( int* )( CL_Predict + 0xA );
		Displacement.CClientState.m_nChokedCommands = *( int* )( CL_Predict + 0x4 );
		Displacement.CClientState.m_bIsHLTV = *( int* )( CL_Move + 0x4 );

		Displacement.DT_PlantedC4.m_flC4Blow = pPropManager->GetOffset( XorStr( "DT_PlantedC4" ), XorStr( "m_flC4Blow" ) );

		Displacement.Data.m_uMoveHelper = **( std::uintptr_t** )( Memory::Scan( image_client, XorStr( "8B 0D ?? ?? ?? ?? 8B 46 08 68" ) ) + 2 );
		Displacement.Data.m_uInput = *( std::uintptr_t* )( Memory::Scan( image_client, XorStr( "B9 ?? ?? ?? ?? F3 0F 11 04 24 FF 50 10" ) ) + 1 );
		Displacement.Data.m_uPredictionRandomSeed = *( std::uintptr_t* )( Memory::Scan( image_client, XorStr( "8B 0D ?? ?? ?? ?? BA ?? ?? ?? ?? E8 ?? ?? ?? ?? 83 C4" ) ) + 2 );
		Displacement.Data.m_uPredictionPlayer = *( std::uintptr_t* )( Memory::Scan( image_client, XorStr( "89 ?? ?? ?? ?? ?? F3 0F 10 48 20" ) ) + 2 );
		Displacement.Data.m_uModelBoneCounter = *( std::uintptr_t* )( Displacement.C_BaseAnimating.InvalidateBoneCache + 0xA );
		Displacement.Data.m_uClientSideAnimationList = *( std::uintptr_t* )( Memory::Scan( image_client, XorStr( "A1 ?? ?? ?? ?? F6 44 F0 04 01 74 0B" ) ) + 1 );
		Displacement.Data.m_uGlowObjectManager = *( std::uintptr_t* )( Memory::Scan( image_client, XorStr( "0F 11 05 ?? ?? ?? ?? 83 C8 01" ) ) + 3 );
		Displacement.Data.m_uCamThink = ( std::uintptr_t )( Memory::Scan( image_client, XorStr( "85 C0 75 30 38 86" ) ) );
		Displacement.Data.m_uRenderBeams = ( std::uintptr_t )( Memory::Scan( image_client, XorStr( "A1 ?? ?? ?? ?? FF 10 A1 ?? ?? ?? ?? B9" ) ) + 0x1 );
		//Displacement.Data.m_uSmokeCount = *( std::uintptr_t* )( Memory::Scan( image_client, XorStr( "55 8B EC 83 EC 08 8B 15 ?? ?? ?? ?? 0F 57 C0" ) ) + 0x8 );
		Displacement.Data.m_uCenterPrint = ( std::uintptr_t )( Memory::Scan( image_client, XorStr( "8B 35 ? ? ? ? 8D 4C 24 20" ) ) + 0x2 );
		Displacement.Data.m_uHostFrameTicks = ( Memory::Scan( image_engine, XorStr( "03 05 ? ? ? ? 83 CF 10" ) ) + 2 );
		Displacement.Data.m_uServerGlobals = Memory::Scan( image_server, XorStr( "8B 15 ? ? ? ? 33 C9 83 7A 18 01" ) ) + 0x2;
		Displacement.Data.m_uServerPoseParameters = Memory::Scan( image_server, XorStr( "8D 87 ? ? ? ? 89 46 08 C7 46 ? ? ? ? ? EB 06" ) ) + 0x2;
		Displacement.Data.m_uServerAnimState = Memory::Scan( image_server, XorStr( "8B 8F ?? ?? ?? ?? 85 C9 74 06 56" ) ) + 2;
		Displacement.Data.m_uTicksAllowed = Memory::Scan( image_server, XorStr( "FF 86 ?? ?? ?? ?? 8B CE 89 86 ?? ?? ?? ??" ) ) + 2;
		Displacement.Data.m_uHudElement = Memory::Scan( image_client, XorStr( "B9 ?? ?? ?? ?? E8 ?? ?? ?? ?? 8B 5D 08" ) ) + 1;
		//Displacement.Data.m_uListLeavesInBoxReturn = Memory::Scan( image_client, XorStr( "56 52 FF 50 18" ) ) + 0x5;
		Displacement.Data.s_bAllowExtrapolation = Memory::Scan( image_client, XorStr( "A2 ? ? ? ? 8B 45 E8" ) ) + 1;
		Displacement.Data.m_FireBulletsReturn = Memory::Scan( image_client, XorStr( "3B 3D ?? ?? ?? ?? 75 4C" ) );
		Displacement.Data.m_D3DDevice = Memory::Scan( image_shaderapidx9, XorStr( "A1 ?? ?? ?? ?? 50 8B 08 FF 51 0C" ) ) + 1;
		Displacement.Data.m_SoundService = Memory::Scan( image_engine, XorStr( "B9 ? ? ? ? 80 65 FC FE 6A 00" ) );
		Displacement.Data.m_InterpolateServerEntities = Memory::Scan( image_client, XorStr( "55 8B EC 83 EC 1C 8B 0D ? ? ? ? 53 56" ) ); // xref CVProfile::EnterScope(g_VProfCurrentProfile, ("C_BaseEntity::InterpolateServerEntities"), 0, ("Interpolation"), 0, 4);
		Displacement.Data.m_SendNetMsg = Memory::Scan( image_engine, XorStr( "55 8B EC 56 8B F1 8B 86 ? ? ? ? 85 C0 74 24 48 83 F8 02 77 2C 83 BE ? ? ? ? ? 8D 8E ? ? ? ? 74 06 32 C0 84 C0 EB 10 E8 ? ? ? ? 84 C0 EB 07 83 BE ? ? ? ? ? 0F 94 C0 84 C0 74 07 B0 01 5E 5D C2 0C 00" ) ); // xref volume || ConVarRef %s doesn't point to an existing ConVar\n
		Displacement.Data.m_ModifyEyePos = CallableFromRelative( Memory::Scan( image_client, XorStr( "E8 ? ? ? ? 8B 06 8B CE FF 90 ? ? ? ? 85 C0 74 4E" ) ) ); // xref head_0
		Displacement.Data.m_ResetContentsCache = Memory::Scan( image_client, XorStr( "56 8D 51 3C BE" ) );
		Displacement.Data.m_ProcessInterpolatedList = Memory::Scan( image_client, XorStr( "0F B7 05 ? ? ? ? 3D ? ? ? ? 74 3F" ) ); // xref C_BaseEntity::InterpolateServerEntities
		Displacement.Data.CheckReceivingListReturn = *reinterpret_cast< DWORD32* >( Memory::Scan( image_engine, XorStr( "FF 50 34 8B 1D ? ? ? ? 85 C0 74 16 FF B6" ) ) + 0x3 );
		Displacement.Data.ReadSubChannelDataReturn = *reinterpret_cast< DWORD32* >( Memory::Scan( image_engine, XorStr( "FF 50 34 85 C0 74 12 53 FF 75 0C 68" ) ) + 0x3 );
		Displacement.Data.SendDatagram = Memory::Scan( image_engine, XorStr( "55 8B EC 83 E4 F0 B8 ? ? ? ? E8 ? ? ? ? 56 57 8B F9 89 7C 24 18" ) );
		Displacement.Data.ProcessPacket = Memory::Scan( image_engine, XorStr( "55 8B EC 83 E4 C0 81 EC ? ? ? ? 53 56 57 8B 7D 08 8B D9" ) );
		Displacement.Data.m_GameRules = ( Memory::Scan( image_client, XorStr( "8B 0D ?? ?? ?? ?? 85 C0 74 0A 8B 01 FF 50 78 83 C0 54" ) ) + 2 );

		Displacement.Function.m_uRandomSeed = ( std::uintptr_t )( GetProcAddress( image_vstdlib, XorStr( "RandomSeed" ) ) );
		Displacement.Function.m_uRandomFloat = ( std::uintptr_t )( GetProcAddress( image_vstdlib, XorStr( "RandomFloat" ) ) );
		Displacement.Function.m_uRandomInt = ( std::uintptr_t )( GetProcAddress( image_vstdlib, XorStr( "RandomInt" ) ) );

		Displacement.Function.m_uSetAbsOrigin = Memory::Scan( image_client, XorStr( "55 8B EC 83 E4 F8 51 53 56 57 8B F1 E8" ) );
		Displacement.Function.m_uSetAbsAngles = Memory::Scan( image_client, XorStr( "55 8B EC 83 E4 F8 83 EC 64 53 56 57 8B F1 E8" ) );
		Displacement.Function.m_uIsBreakable = Memory::Scan( image_client, XorStr( "55 8B EC 51 56 8B F1 85 F6 74 68" ) ); //xref
		//Displacement.Function.m_uClearHudWeaponIcon = Memory::Scan( image_client, XorStr( "55 8B EC 51 53 56 8B 75 08 8B D9 57 6B FE 2C 89 5D FC" ) );
		Displacement.Function.m_uLoadNamedSkys = Memory::Scan( image_engine, XorStr( "55 8B EC 81 EC ? ? ? ? 56 57 8B F9 C7 45" ) );
		Displacement.Function.m_uCreateAnimState = Memory::Scan( image_client, XorStr( "55 8B EC 56 8B F1 B9 ?? ?? ?? ?? C7 46" ) );
		Displacement.Function.m_uResetAnimState = Memory::Scan( image_client, XorStr( "56 6A 01 68 ?? ?? ?? ?? 8B F1" ) );
		Displacement.Function.m_uUpdateAnimState = Memory::Scan( image_client, XorStr( "55 8B EC 83 E4 F8 83 EC 18 56 57 8B F9 F3 0F 11 54 24" ) );
		Displacement.Function.m_uClanTagChange = Memory::Scan( image_engine, XorStr( "53 56 57 8B DA 8B F9 FF 15" ) );
		Displacement.Function.m_uGetSequenceActivity = Memory::Scan( image_client, XorStr( "55 8B EC 83 7D 08 FF 56 8B F1 74 3D" ) );
		Displacement.Function.m_uInvalidatePhysics = Memory::Scan( image_client, XorStr( "55 8B EC 83 E4 F8 83 EC 0C 53 8B 5D 08 8B C3 56 83 E0 04" ) );
		Displacement.Function.m_uPostThinkVPhysics = Memory::Scan( image_client, XorStr( "55 8B EC 83 E4 F8 81 EC ? ? ? ? 53 8B D9 56 57 83 BB ? ? ? ? ? 75 50 8B 0D" ) );
		Displacement.Function.m_SimulatePlayerSimulatedEntities = Memory::Scan( image_client, XorStr( "56 8B F1 57 8B BE ?? ?? ?? ?? 83 EF 01 78 72 90 8B 86" ) );
		Displacement.Function.m_uImplPhysicsRunThink = Memory::Scan( image_client, XorStr( "55 8B EC 83 EC 10 53 56 57 8B F9 8B 87 ?? ?? ?? ?? C1 E8 16" ) );
		//Displacement.Function.m_uClearDeathNotices = Memory::Scan( image_client, XorStr( "55 8B EC 83 EC 0C 53 56 8B 71 58" ) ); //55 8B EC 83 EC 0C 53 56 8B 71 58 33 DB 57 89 5D F8 8B 4E 04 8B 01 FF 90
		Displacement.Function.m_uSetTimeout = Memory::Scan( image_engine, XorStr( "55 8B EC 80 7D 0C 00 F3 0F 10 4D" ) );
		Displacement.Function.m_uFindHudElement = Memory::Scan( image_client, XorStr( "55 8B EC 53 8B 5D 08 56 57 8B F9 33 F6 39 77 28" ) );
		Displacement.Function.m_SetCollisionBounds = Memory::Scan( image_client, XorStr( "53 8B DC 83 EC 08 83 E4 F8 83 C4 04 55 8B 6B 04 89 6C 24 04 8B EC 83 EC 10 56 57 8B 7B" ) );
		Displacement.Function.m_MD5PseudoRandom = Memory::Scan( image_client, XorStr( "55 8B EC 83 E4 F8 83 EC 70 6A 58 8D 44 24 1C 89 4C 24 08 6A 00 50" ) );
		Displacement.Function.m_WriteUsercmd = Memory::Scan( image_client, XorStr( "55 8B EC 83 E4 F8 51 53 56 8B D9 8B 0D" ) );
		Displacement.Function.m_StdStringAssign = Memory::Scan( image_engine, XorStr( "55 8B EC 53 8B 5D 08 56 8B F1 85 DB 74 57 8B 4E 14 83 F9 10 72 04 8B 06 EB 02" ) );
		Displacement.Function.m_pPoseParameter = Memory::Scan( image_client, XorStr( "55 8B EC 8B 45 08 57 8B F9 8B 4F 04 85 C9 75 15 8B" ) );
		Displacement.Function.m_AttachmentHelper = Memory::Scan( image_client, XorStr( "55 8B EC 83 EC 48 53 8B 5D 08 89 4D F4" ) );
		Displacement.Function.m_LockStudioHdr = CallableFromRelative( Memory::Scan( image_client, XorStr( "E8 ?? ?? ?? ?? 8D 47 FC" ) ) );
		Displacement.Function.m_LineGoesThroughSmoke = Memory::Scan( image_client, XorStr( "55 8B EC 83 EC 08 8B 15 ?? ?? ?? ?? 0F 57 C0" ) );
		Displacement.Function.m_RunSimulation = CallableFromRelative( Memory::Scan( image_client, XorStr( "E8 ? ? ? ? A1 ? ? ? ? F3 0F 10 45 ? F3 0F 11 40" ) ) );
		Displacement.Function.m_PredictionUpdate = Memory::Scan( image_client, XorStr( "55 8B EC 83 EC 08 53 56 8B F1 8B 0D ? ? ? ? 57 8B B9" ) );
		Displacement.Function.m_TraceFilterSimple = Memory::Scan( image_client, XorStr( "55 8B EC 83 E4 F0 83 EC 7C 56 52" ) ) + 0x3D; //xref : offset ??_7CTraceFilterSimple@@6B@ ; const CTraceFilterSimple::`vftable' 
	}

	bool CreateDisplacement( void* reserved ) {
		Create( );

		//  DumpOffsets( reserved );
		return true;
	}
}
```

`CSGO SDK/SDK/Displacement.hpp`:

```hpp
#pragma once

#include "sdk.hpp"

struct DllInitializeData {
   DWORD32 dwDataN;

   // C_BaseEntity
   struct {
	  DWORD32 m_MoveType;
	  DWORD32 m_rgflCoordinateFrame;
   } C_BaseEntity;

   // DT_BaseEntity
   struct {
	  DWORD32 m_iTeamNum;
	  DWORD32 m_vecOrigin;
	  DWORD32 m_flSimulationTime;
	  DWORD32 m_fEffects;
	  DWORD32 m_iEFlags;
	  DWORD32 m_hOwnerEntity;
	  DWORD32 moveparent;
	  DWORD32 m_nModelIndex;
	  DWORD32 m_Collision;
	  DWORD32 m_CollisionGroup;

	  DWORD32 m_nForceBone;
	  DWORD32 InvalidateBoneCache;
	  DWORD32 m_flAnimTime;
   } DT_BaseEntity;  
   
   // DT_BaseWeaponWorldModel
   struct {
	  DWORD32 m_hCombatWeaponParent;
   } DT_BaseWeaponWorldModel;

   // C_BaseAnimating
   struct {
	  DWORD32 m_BoneAccessor;
	  DWORD32 m_iMostRecentModelBoneCounter;
	  DWORD32 m_flLastBoneSetupTime;
	  DWORD32 m_CachedBoneData;
	  DWORD32 m_AnimOverlay;

	  DWORD32 BoneSnapshotsCall;
	  DWORD32 m_pFirstBoneSnapshot;
	  DWORD32 m_pSecondBoneSnapshot;

	  DWORD32 m_pIk;
	  DWORD32 m_pBoneMerge;

	  DWORD32 CacheBoneData;
	  DWORD32 m_nCachedBonesPosition;
	  DWORD32 m_nCachedBonesRotation;
	  DWORD32 m_pStudioHdr;
	  DWORD32 m_bShouldDraw;

	  DWORD32 m_iPrevBoneMask;
	  DWORD32 m_iAccumulatedBoneMask;
	  DWORD32 m_iOcclusionFlags;
	  DWORD32 m_iOcclusionFramecount;
	  DWORD32 m_bIsJiggleBonesEnabled;
	  DWORD32 InvalidateBoneCache;
   } C_BaseAnimating;

   // DT_BaseAnimating
   struct {
	  DWORD32 m_bClientSideAnimation;
	  DWORD32 m_flPoseParameter;
	  DWORD32 m_nHitboxSet;
	  DWORD32 m_flCycle;
	  DWORD32 m_nSequence;
	  DWORD32 m_flEncodedController;

   } DT_BaseAnimating;

   // DT_BaseCombatCharacter
   struct {
	  DWORD32 m_hActiveWeapon;
	  DWORD32 m_flNextAttack;
	  DWORD32 m_hMyWeapons;
	  DWORD32 m_hMyWearables;
   } DT_BaseCombatCharacter;

   // C_BasePlayer
   struct {
	  DWORD32 m_pCurrentCommand;
	  DWORD32 relative_call;
	  DWORD32 offset;
	  DWORD32 UpdateVisibilityAllEntities;
   } C_BasePlayer;

   // DT_BasePlayer
   struct {
	  DWORD32 m_aimPunchAngle;
	  DWORD32 m_aimPunchAngleVel;
	  DWORD32 m_viewPunchAngle;
	  DWORD32 m_vecViewOffset;
	  DWORD32 m_vecVelocity;
	  DWORD32 m_vecBaseVelocity;
	  DWORD32 m_flFallVelocity;
	  DWORD32 m_flDuckAmount;
	  DWORD32 m_flDuckSpeed;
	  DWORD32 m_lifeState;
	  DWORD32 m_nTickBase;
	  DWORD32 m_iHealth;
	  DWORD32 m_iDefaultFOV;
	  DWORD32 m_fFlags;
	  DWORD32 m_bSpotted;
	  DWORD32 pl;
	  DWORD32 m_hObserverTarget;
	  DWORD32 m_hViewModel;
	  DWORD32 m_vphysicsCollisionState;
	  DWORD32 m_ubEFNoInterpParity;
	  DWORD32 m_ubOldEFNoInterpParity;
	  DWORD32 m_iObserverMode;
   } DT_BasePlayer;

   // C_CSPlayer
   struct {
	  DWORD32 m_PlayerAnimState;
	  DWORD32 m_flSpawnTime;
   } C_CSPlayer;

   // DT_CSPlayer 
   struct {
	  DWORD32 m_angEyeAngles;
	  DWORD32 m_nSurvivalTeam;
	  DWORD32 m_bHasHelmet;
	  DWORD32 m_bHasHeavyArmor;
	  DWORD32 m_ArmorValue;
	  DWORD32 m_bScoped;
	  DWORD32 m_bIsWalking;
	  DWORD32 m_iAccount;
	  DWORD32 m_iShotsFired;
	  DWORD32 m_flFlashDuration;
	  DWORD32 m_flLowerBodyYawTarget;
	  DWORD32 m_flLowerBodyYawTargetProxy;
	  DWORD32 m_flVelocityModifier;
	  DWORD32 m_bGunGameImmunity;
	  DWORD32 m_flHealthShotBoostExpirationTime;
	  DWORD32 m_iMatchStats_Kills;
	  DWORD32 m_iMatchStats_Deaths;
	  DWORD32 m_iMatchStats_HeadShotKills;
	  DWORD32 m_iMoveState;
	  DWORD32 m_bWaitForNoAttack;
	  DWORD32 m_bCustomPlayer;
	  DWORD32 m_iPlayerState;
	  DWORD32 m_bIsDefusing;
	  DWORD32 m_bHasDefuser;
	  DWORD32 m_bIsPlayerGhost;
	  DWORD32 m_iFOV;
	  DWORD32 m_vecPlayerPatchEconIndices;
	  DWORD32 m_hRagdoll;
   } DT_CSPlayer;

   // DT_CSRagdoll
   struct {
	  DWORD32 m_hPlayer;
   } DT_CSRagdoll;   
   
   // DT_FogController
   struct {
	  DWORD32 m_fog_enable;
   } DT_FogController;

   // DT_Precipitation
   struct {
	   DWORD32 m_nPrecipType;
   } DT_Precipitation;

   // DT_BaseCombatWeapon
   struct {
	  DWORD32 m_flNextPrimaryAttack;
	  DWORD32 m_flNextSecondaryAttack;
	  DWORD32 m_hOwner;
	  DWORD32 m_iClip1;
	  DWORD32 m_iPrimaryReserveAmmoCount;
	  DWORD32 m_iItemDefinitionIndex;
	  DWORD32 m_hWeaponWorldModel;
	  DWORD32 m_iWorldModelIndex;
	  DWORD32 m_iWorldDroppedModelIndex;
	  DWORD32 m_iViewModelIndex;

	  DWORD32 m_CustomMaterials;
	  DWORD32 m_bCustomMaterialInitialized;
   } DT_BaseCombatWeapon;

   // DT_WeaponCSBase
   struct {
	  DWORD32 m_flRecoilIndex;
	  DWORD32 m_weaponMode;
	  DWORD32 m_flPostponeFireReadyTime;
	  DWORD32 m_fLastShotTime;
   } DT_WeaponCSBase;

   // DT_WeaponCSBaseGun
   struct {
	  DWORD32 m_zoomLevel;
	  DWORD32 m_iBurstShotsRemaining;
	  DWORD32 m_fNextBurstShot;
   } DT_WeaponCSBaseGun;

   // DT_BaseCSGrenade
   struct {
	  DWORD32 m_bPinPulled;
	  DWORD32 m_fThrowTime;
	  DWORD32 m_flThrowStrength;
   } DT_BaseCSGrenade;

   // DT_BaseAttributableItem
   struct {
	  DWORD32 m_flFallbackWear;
	  DWORD32 m_nFallbackPaintKit;
	  DWORD32 m_nFallbackSeed;
	  DWORD32 m_nFallbackStatTrak;
	  DWORD32 m_OriginalOwnerXuidHigh;
	  DWORD32 m_OriginalOwnerXuidLow;
	  DWORD32 m_szCustomName;
	  DWORD32 m_bInitialized;
	  DWORD32 m_iAccountID;
	  DWORD32 m_iEntityLevel;
	  DWORD32 m_iEntityQuality;
	  DWORD32 m_iItemDefinitionIndex;
	  DWORD32 m_Item;
	  DWORD32 m_iItemIDLow;
	  DWORD32 m_iItemIDHigh;
   } DT_BaseAttributableItem;

   // DT_BaseViewModel
   struct {
	  DWORD32 m_hOwner;
	  DWORD32 m_hWeapon;
	  DWORD32 m_nSequence;
   } DT_BaseViewModel;

   // DT_SmokeGrenadeProjectile
   struct {
	  DWORD32 m_nSmokeEffectTickBegin;
	  DWORD32 m_nSmokeCount;
	//  DWORD32 m_SmokeParticlesSpawned;
   } DT_SmokeGrenadeProjectile;

   // DT_PlantedC4
   struct {
	  DWORD32 m_flC4Blow;
   } DT_PlantedC4;

   // CClientState
   struct {
	  DWORD32 m_nDeltaTick;
	  DWORD32 m_nLastOutgoingCommand;
	  DWORD32 m_nChokedCommands;
	  DWORD32 m_nLastCommandAck;
	  DWORD32 m_bIsHLTV;
   } CClientState;

   // CBoneMergeCache
   struct {
	  DWORD32 m_nConstructor;
	  DWORD32 m_nInit;
	  DWORD32 m_nUpdateCache;
	  DWORD32 m_CopyToFollow;
	  DWORD32 m_CopyFromFollow;
   } CBoneMergeCache;

   // CIKContext
   struct {
	  DWORD32 m_nConstructor;
	  DWORD32 m_nDestructor;
	  DWORD32 m_nInit;
	  DWORD32 m_nUpdateTargets;
	  DWORD32 m_nSolveDependencies;
   } CIKContext;

   // CBoneSetup
   struct {
	  DWORD32 InitPose;
	  DWORD32 AccumulatePose;
	  DWORD32 CalcAutoplaySequences;
	  DWORD32 CalcBoneAdj;
   } CBoneSetup; 
   
   // IPrediction
   struct {
	  DWORD32 m_nCommandsPredicted;
   } IPrediction;

   struct {
	  DWORD32 m_uMoveHelper;
	  DWORD32 m_uInput;
	  DWORD32 m_uGlobalVars;
	  DWORD32 m_uPredictionRandomSeed;
	  DWORD32 m_uPredictionPlayer;
	  DWORD32 m_uModelBoneCounter;
	  DWORD32 m_uClientSideAnimationList;
	  DWORD32 m_uGlowObjectManager;
	  DWORD32 m_uCamThink;
	  DWORD32 m_uRenderBeams;
	  DWORD32 m_uSmokeCount;
	  DWORD32 m_uCenterPrint;
	  DWORD32 m_uHostFrameTicks;
	  DWORD32 m_uServerGlobals;
	  DWORD32 m_uServerPoseParameters;
	  DWORD32 m_uServerAnimState;
	  DWORD32 m_uTicksAllowed;
	  DWORD32 m_uHudElement;
	  DWORD32 m_uListLeavesInBoxReturn;
	  DWORD32 s_bAllowExtrapolation;
	  DWORD32 m_FireBulletsReturn;
	  DWORD32 m_D3DDevice;
	  DWORD32 m_SoundService;
	  DWORD32 m_InterpolateServerEntities;
	  DWORD32 m_SendNetMsg;
	  DWORD32 m_ModifyEyePos;
	  DWORD32 m_ResetContentsCache;
	  DWORD32 m_ProcessInterpolatedList;
	  DWORD32 CheckReceivingListReturn;
	  DWORD32 ReadSubChannelDataReturn;
	  DWORD32 SendDatagram;
	  DWORD32 ProcessPacket;
	  DWORD32 m_GameRules;
   } Data;

   struct {
	  DWORD32 m_uRandomSeed;
	  DWORD32 m_uRandomFloat;
	  DWORD32 m_uRandomInt;
	  DWORD32 m_uSetAbsOrigin;
	  DWORD32 m_uSetAbsAngles;
	  DWORD32 m_uIsBreakable;
	  DWORD32 m_uClearHudWeaponIcon;
	  DWORD32 m_uLoadNamedSkys;
	  DWORD32 m_uCreateAnimState;
	  DWORD32 m_uResetAnimState;
	  DWORD32 m_uUpdateAnimState;
	  DWORD32 m_uClanTagChange;
	  DWORD32 m_uGetSequenceActivity;
	  DWORD32 m_uInvalidatePhysics;
	  DWORD32 m_uPostThinkVPhysics;
	  DWORD32 m_SimulatePlayerSimulatedEntities;
	  DWORD32 m_uImplPhysicsRunThink;
	  DWORD32 m_uClearDeathNotices;
	  DWORD32 m_uSetTimeout;
	  DWORD32 m_uFindHudElement;
	  DWORD32 m_SetCollisionBounds;
	  DWORD32 m_MD5PseudoRandom;
	  DWORD32 m_WriteUsercmd;
	  DWORD32 m_StdStringAssign;
	  DWORD32 m_pPoseParameter;
	  DWORD32 m_AttachmentHelper;
	  DWORD32 m_LockStudioHdr;
	  DWORD32 m_LineGoesThroughSmoke;
	  DWORD32 m_RunSimulation;
	  DWORD32 m_PredictionUpdate;
	  DWORD32 m_TraceFilterSimple;
   } Function;
};

struct DllArgsBase {
   long long size;
};

struct DllArgsToRecieve : DllArgsBase {
   DWORD32 dwMemorySize;
   DWORD32 lpInitStruct; //Allocated memory (R. Cast lpInitStruct to DllInitializeData*

   char login[ 256 ] = "\0";
   char password[ 256 ] = "\0";
};

namespace Engine
{
   extern DllInitializeData Displacement;

   bool CreateDisplacement( void* reserved );
}

#pragma optimize( "", off ) 

#define XOR_DWORD( var ) var ^  std::integral_constant<uint32_t, hash_32_fnv1a_const(#var ) >::value

#pragma optimize( "", on )

```

`CSGO SDK/SDK/Includes.hpp`:

```hpp
#pragma once

#include "Utils/PatternScan.hpp"
#include "Utils/vcall.hpp"
#include "Utils/vmt_swap.hpp"
#include "Utils/singleton.hpp"
#include "Utils/Print.hpp"

```

`CSGO SDK/SDK/RayTracer.cpp`:

```cpp
#include "RayTracer.h"
#include "../Utils/InputSys.hpp"
#include "../Source.hpp"
#include <cassert>

RayTracer::Ray::Ray(const Vector& direction) : m_startPoint(), m_direction(direction), m_length(0.f) { }

RayTracer::Ray::Ray(const Vector& startPoint, const Vector& endPoint) : m_startPoint(startPoint) {
	//assert( startPoint != endPoint );

	auto vectorDiff = endPoint - startPoint;
	m_direction = vectorDiff.Normalized();
	m_length = vectorDiff.Length();
}

RayTracer::Hitbox::Hitbox() : m_mins(), m_maxs(), m_radius() { }

RayTracer::Hitbox::Hitbox(const Vector& mins, const Vector& maxs, const float radius) : m_mins(mins), m_maxs(maxs), m_radius(radius) { }

RayTracer::Hitbox::Hitbox(const std::tuple<Vector, Vector, float>& initTuple) : m_mins(std::get<0>(initTuple)), m_maxs(std::get<1>(initTuple)), m_radius(std::get<2>(initTuple)) { }

RayTracer::Trace::Trace() : m_hit(false), m_fraction(0.f), m_traceEnd() { }

void RayTracer::TraceFromCenter(const Ray& ray, const Hitbox& hitbox, Trace& trace, int flags) {
	//assert( ray.m_direction.Length( ) > 0.f );

	// we are treating the cylinder as a cylinder y^2+z^2=r^2, in the x-direction, so we will make it the x direction
	const Vector unitDesired(1.f, 0.f, 0.f);
	const matrix3x4_t identityMatrix(
		1.f, 0.f, 0.f, 0.f,
		0.f, 1.f, 0.f, 0.f,
		0.f, 0.f, 1.f, 0.f
	);

	auto center = (hitbox.m_mins + hitbox.m_maxs) / 2.f;

	auto minsOffset = hitbox.m_mins - center;
	auto maxsOffset = hitbox.m_maxs - center;

	auto vecHitbox = maxsOffset - minsOffset;
	auto hitboxLength = vecHitbox.Length();

	// now we calculate the transformation matrix to get our normalized hitbox to center
	auto unitHitbox = vecHitbox / hitboxLength;

	// dot == cos because they are both unit vectors
	auto dot = unitHitbox.Dot(unitDesired);
	auto cross = unitHitbox.Cross(unitDesired);

	Vector rotatedDirection;

	// if cross is 0, then we don't have to rotate because they are parallel
	if (cross.Length() > 0.f) {
		matrix3x4_t crossMatrix(
			0.f, -cross.z, cross.y, 0.f,
			cross.z, 0.f, -cross.x, 0.f,
			-cross.y, cross.x, 0.f, 0.f
		);

		auto rotationMatrix = identityMatrix + crossMatrix +
			(crossMatrix * crossMatrix) * (1.f / (1.f + dot));

		rotatedDirection = rotationMatrix * ray.m_direction;
	}
	else {
		// cross is 0, they are parallel, if dot is 1.f they are same, else they are opposite
		if (dot == 1.f)
			rotatedDirection = ray.m_direction;
		else
			rotatedDirection = ray.m_direction * -1.0f;
	}

	auto a = rotatedDirection.y * rotatedDirection.y +
		rotatedDirection.z * rotatedDirection.z;

	if (a == 0) {
		// the ray goes through both caps, easy case because we don't actually need to trace the ray because they are circles
		if (rotatedDirection.x > 0) {
			// through the right cap, scale by radius and call it a day
			auto newLength = minsOffset.Length() + hitbox.m_radius;
			auto offset = (minsOffset * (newLength) / minsOffset.Length());

			if (flags & Flags_RETURNEND)
				trace.m_traceEnd = center + offset;
			if (flags & Flags_RETURNOFFSET)
				trace.m_traceOffset = offset;
		}
		else {
			// through the left cap, scale by radius again
			auto newLength = maxsOffset.Length() + hitbox.m_radius;
			auto offset = (maxsOffset * (newLength) / maxsOffset.Length());

			if (flags & Flags_RETURNEND)
				trace.m_traceEnd = center + offset;
			if (flags & Flags_RETURNOFFSET)
				trace.m_traceOffset = offset;
		}
		trace.m_hit = true;
		return;
	}

	// b is always 0 because we start at the origin

	auto c = -(hitbox.m_radius * hitbox.m_radius);

	// we only care about t1 because we are inside of the surface that we are tracing, so t0 will always be negative. 
	// also -4*a*c will always be positive because c is always negative and a is always positive
	auto t = (sqrtf(-4.f * a * c)) / (2.f * a);

	//assert( t >= 0.f );

	// virutal direction is in the 3-D plane of x
	auto virtualPos = rotatedDirection * t;

	auto minsAdjusted = -hitboxLength / 2.f;
	auto maxsAdjusted = hitboxLength / 2.f;

	auto outOfMinsSide = virtualPos.x < minsAdjusted;
	auto outOfMaxsSide = virtualPos.x > maxsAdjusted;

	// we need to trace the spheres on the ends
	if (outOfMinsSide || outOfMaxsSide) {
		// set our position offset to the opposite side to raytrace the sphere
		Vector offsetPosition(
			(outOfMinsSide) ? -minsAdjusted : -maxsAdjusted, 0.f, 0.f
		);

		// we treat a_s as 1 because for a sphere, it is just the entire unit vector's length, always 1

		auto b_s = 2.f * (offsetPosition.x * rotatedDirection.x);

		auto c_s = offsetPosition.x * offsetPosition.x -
			hitbox.m_radius * hitbox.m_radius;

		auto operand = sqrtf(b_s * b_s - 4 * c_s);

		t = (-b_s + operand) / 2.f;

		//assert( t - FLT_EPSILON >= 0.f );
	}

	auto offset = ray.m_direction * t;

	if (flags & Flags_RETURNEND)
		trace.m_traceEnd = center + offset;
	if (flags & Flags_RETURNOFFSET)
		trace.m_traceOffset = offset;

	trace.m_hit = true;
}

void RayTracer::TraceHitbox(const Ray& ray, const Hitbox& hitbox, Trace& trace, int flags) {
	assert(ray.m_direction.Length() > 0.f);

	trace.m_fraction = 1.f;

	// we are treating the cylinder as a cylinder y^2+z^2=r^2, in the x-direction, so we will make it the x direction
	const Vector unitDesired(1.f, 0.f, 0.f);
	const matrix3x4_t identityMatrix(
		1.f, 0.f, 0.f, 0.f,
		0.f, 1.f, 0.f, 0.f,
		0.f, 0.f, 1.f, 0.f
	);

	auto center = (hitbox.m_mins + hitbox.m_maxs) / 2.f;

	auto minsOffset = hitbox.m_mins - center;
	auto maxsOffset = hitbox.m_maxs - center;

	auto vecHitbox = maxsOffset - minsOffset;
	auto hitboxLength = vecHitbox.Length();

	// now we calculate the transformation matrix to get our normalized hitbox to center
	auto unitHitbox = vecHitbox / hitboxLength;

	// dot == cos because they are both unit vectors
	auto dot = unitHitbox.Dot(unitDesired);
	auto cross = unitHitbox.Cross(unitDesired);

	Vector rotatedDirection;
	Vector rotatedStart;

	// offset the position
	auto adjustedStart = ray.m_startPoint - center;

	// if cross is 0, then we don't have to rotate because they are parallel
	if (cross.Length() > 0.f) {
		matrix3x4_t crossMatrix(
			0.f, -cross.z, cross.y, 0.f,
			cross.z, 0.f, -cross.x, 0.f,
			-cross.y, cross.x, 0.f, 0.f
		);

		auto rotationMatrix = identityMatrix + crossMatrix +
			(crossMatrix * crossMatrix) * (1.f / (1.f + dot));

		rotatedDirection = rotationMatrix * ray.m_direction;
		rotatedStart = rotationMatrix * adjustedStart;
	}
	else {
		// cross is 0, they are parallel, if dot is 1.f they are same, else they are opposite
		if (dot > 0.f) {
			rotatedDirection = ray.m_direction;
			rotatedStart = adjustedStart;
		}
		else {
			rotatedDirection = ray.m_direction * -1.0f;
			rotatedStart = adjustedStart * -1.0f;
		}
	}

	auto a_c = rotatedDirection.y * rotatedDirection.y +
		rotatedDirection.z * rotatedDirection.z;

	/// TODO: Detect the plane!
	// this is INCREDIBLY RARE
	if (a_c == 0.f) {
		// the ray goes through both caps, easy case because we don't actually need to trace the ray because they are circles
		if (rotatedDirection.x > 0) {
			// through the right cap, scale by radius and call it a day
			auto newLength = minsOffset.Length() + hitbox.m_radius;
			auto offset = (minsOffset * (newLength) / minsOffset.Length());

			if (flags & Flags_RETURNEND)
				trace.m_traceEnd = center + offset;
			if (flags & Flags_RETURNOFFSET)
				trace.m_traceOffset = offset;
		}
		else {
			// through the left cap, scale by radius again
			auto newLength = maxsOffset.Length() + hitbox.m_radius;
			auto offset = (maxsOffset * (newLength) / maxsOffset.Length());

			if (flags & Flags_RETURNEND)
				trace.m_traceEnd = center + offset;
			if (flags & Flags_RETURNOFFSET)
				trace.m_traceOffset = offset;
		}
		trace.m_hit = true;
		return;
	}

	constexpr auto a_s = 1.f;

	auto minsAdjusted = -hitboxLength / 2.f;
	auto maxsAdjusted = hitboxLength / 2.f;

	auto minsStart = Vector(rotatedStart.x - minsAdjusted, rotatedStart.y, rotatedStart.z);
	auto maxsStart = Vector(rotatedStart.x - maxsAdjusted, rotatedStart.y, rotatedStart.z);

	auto b_c = 2.f *
		(rotatedStart.y * rotatedDirection.y +
			rotatedStart.z * rotatedDirection.z);

	auto b_smins = 2.f * (minsStart.Dot(rotatedDirection));
	auto b_smaxs = 2.f * (maxsStart.Dot(rotatedDirection));

	auto c_c = rotatedStart.y * rotatedStart.y +
		rotatedStart.z * rotatedStart.z -
		hitbox.m_radius * hitbox.m_radius;

	auto c_smins = minsStart.Dot(minsStart) -
		hitbox.m_radius * hitbox.m_radius;
	auto c_smaxs = maxsStart.Dot(maxsStart) -
		hitbox.m_radius * hitbox.m_radius;

	auto cylOperand = b_c * b_c - 4 * a_c * c_c;
	auto sphMinsOperand = b_smins * b_smins - 4 * a_s * c_smins;
	auto sphMaxsOperand = b_smaxs * b_smaxs - 4 * a_s * c_smaxs;

	auto tCyl = 0.f;
	auto tSphMins = 0.f;
	auto tSphMaxs = 0.f;

	auto cylHit = false;
	auto sphMinsHit = false;
	auto sphMaxsHit = false;

	// if we don't hit, operand is negative
	if (cylOperand > 0.f) {
		tCyl = (-b_c - sqrtf(cylOperand)) / (2.f * a_c);

		if (tCyl - FLT_EPSILON > 0.f) {
			// make sure we hit within our bounds, and not outside of the cylinder's bore
			auto virtualPos = rotatedDirection * tCyl;

			auto outOfMinsSide = virtualPos.x < minsAdjusted;
			auto outOfMaxsSide = virtualPos.x > maxsAdjusted;

			if (!outOfMinsSide &&
				!outOfMaxsSide)
				cylHit = true;
		}
	}

	if (sphMinsOperand > 0.f) {
		tSphMins = (-b_smins - sqrtf(sphMinsOperand)) / (2.f * a_s);

		if (tSphMins - FLT_EPSILON > 0.f)
			sphMinsHit = true;
	}

	if (sphMaxsOperand > 0.f) {
		tSphMaxs = (-b_smaxs - sqrtf(sphMaxsOperand)) / (2.f * a_s);

		if (tSphMaxs - FLT_EPSILON > 0.f)
			sphMaxsHit = true;
	}

	// see which one hit first, then return accordingly
	if (cylHit) {
		trace.m_fraction = tCyl / ray.m_length;
		trace.m_hit = true;
	}
	else if (sphMinsHit) {
		trace.m_fraction = tSphMins / ray.m_length;
		trace.m_hit = true;
	}
	else if (sphMaxsHit) {
		trace.m_fraction = tSphMaxs / ray.m_length;
		trace.m_hit = true;
	}
}
```

`CSGO SDK/SDK/RayTracer.h`:

```h
#pragma once

#include <tuple>
#include "../SDK/sdk.hpp"

/*
RayTracer provides the same functionality as ClipRayToEntity, only
it allows to trace for a specific hitbox through all others and provides
exceptional performance compared to the game's RayTracing engine due to its
inherent specialization
*/

class RayTracer {
public:
   struct Ray {
	  Ray( const Vector& direction );
	  Ray( const Vector& startPoint, const Vector& endPoint );
	  Vector m_startPoint;
	  Vector m_direction;
	  float m_length;
   };

   struct Hitbox {
	  Hitbox( );
	  Hitbox( const Vector& mins, const Vector& maxs, const float radius );
	  Hitbox( const std::tuple<Vector, Vector, float>& initTuple );
	  Vector m_mins;
	  Vector m_maxs;
	  float m_radius;
   };

   struct Trace {
	  Trace( );
	  bool m_hit;
	  float m_fraction;
	  Vector m_traceEnd;
	  Vector m_traceOffset;
   };

   enum Flags {
	  Flags_NONE = 0,
	  Flags_RETURNEND = ( 1 << 0 ),
	  Flags_RETURNOFFSET = ( 1 << 1 )
   };

   // This is a specialization that starts from the center, as calculations are much simpler from the center of the hitbox
   static void TraceFromCenter( const Ray& ray, const Hitbox& hitbox, Trace& trace, int flags = 0 );
   // This is for the general case, tracing against the hitbox
   static void TraceHitbox( const Ray& ray, const Hitbox& hitbox, Trace& trace, int flags = 0 );
};

```

`CSGO SDK/SDK/Utils/PatternScan.cpp`:

```cpp
#include "PatternScan.hpp"
#include "Print.hpp"
#include <sstream>      // std::stringstream
#include <iomanip>      // std::stringstream
#include "../../Utils/XorStr.hpp"

#define IS_IN_RANGE( value, max, min ) ( value >= max && value <= min )
#define GET_BITS( value ) ( IS_IN_RANGE( value, '0', '9' ) ? ( value - '0' ) : ( ( value & ( ~0x20 ) ) - 'A' + 0xA ) )
#define GET_BYTE( value ) ( GET_BITS( value[0] ) << 4 | GET_BITS( value[1] ) )

namespace SDK::Memory
{

	char* find_utf8( const char* module, const char* string ) {
		uint32_t module_start = ( uint32_t )GetModuleHandleA( module );
		const auto dos_headers = ( IMAGE_DOS_HEADER* )module_start;
		const auto nt_headers = ( IMAGE_NT_HEADERS* )( module_start + dos_headers->e_lfanew );

		uint32_t module_end = module_start + nt_headers->OptionalHeader.SizeOfImage;

		for( uint32_t current = module_start; current < module_end; current++ ) {
			if( strcmp( ( const char* )current, string ) == 0 )
				return ( char* )current;
		}

		return nullptr;
	}

	void strcpy_protected( char* dest, const char* src ) {
		unsigned long old = 0;
		int len = strlen( src );

		VirtualProtect( ( void* )dest, len, PAGE_READWRITE, &old );
		strcpy( dest, src );
		VirtualProtect( ( void* )dest, len, old, &old );
	}

	__forceinline uintptr_t PatternScan( uintptr_t mod, const char* sig, size_t size )
	{
		// Credits: MarkHC, although slightly modified by DucaRii and also documented
		static auto pattern_to_byte = [ ] ( const char* pattern )
		{
			// Prerequisites
			auto bytes = std::vector<int>{ };
			auto start = const_cast< char* >( pattern );
			auto end = const_cast< char* >( pattern ) + strlen( pattern );

			// Convert signature into corresponding bytes
			for( auto current = start; current < end; ++current )
			{
				// Is current byte a wildcard? Simply ignore that that byte later
				if( *current == '?' )
				{
					++current;

					// Check if following byte is also a wildcard
					if( *current == '?' )
						++current;

					// Dummy byte
					bytes.push_back( -1 );
				}
				else
				{
					// Convert character to byte on hexadecimal base
					bytes.push_back( strtoul( current, &current, 16 ) );
				}
			}
			return bytes;
		};


		// The region where we will search for the byte sequence
		const auto image_size = size;

		// Check if the image is faulty
		if( !image_size )
			return { };

		// Convert IDA-Style signature to a byte sequence
		auto pattern_bytes = pattern_to_byte( sig );

		const auto image_bytes = reinterpret_cast< byte* >( mod );

		const auto signature_size = pattern_bytes.size( );
		const auto signature_bytes = pattern_bytes.data( );

		// Now loop through all bytes and check if the byte sequence matches
		for( auto i = 0ul; i < image_size - signature_size; ++i )
		{
			auto byte_sequence_found = true;

			// Go through all bytes from the signature and check if it matches
			for( auto j = 0ul; j < signature_size; ++j )
			{
				if( image_bytes[ i + j ] != signature_bytes[ j ] // Bytes don't match
					&& signature_bytes[ j ] != -1 ) // Byte isn't a wildcard either, WHAT THE HECK
				{
					byte_sequence_found = false;
					break;
				}
			}

			// All good, now return the right address
			if( byte_sequence_found )
				return uintptr_t( &image_bytes[ i ] );
		}

		// Byte sequence wasn't found
		return { };
	}


	/*Credits: @hinnie on unknowncheats: https://www.unknowncheats.me/forum/counterstrike-global-offensive/375564-rtti-helper-easy-vtable-pointers.html */
	__forceinline std::string BytesToIDAPattern( byte* bytes, size_t size ) {
		std::stringstream ida_pattern;
		ida_pattern << std::hex << std::setfill( '0' );
		for( size_t i = 0; i < size; i++ )
		{
			const int32_t current_byte = bytes[ i ];
			if( current_byte != 255 )
				ida_pattern << std::setw( 2 ) << current_byte;
			else
				ida_pattern << std::setw( 1 ) << XorStr( "?" );

			if( i != size - 1 )
				ida_pattern << XorStr( " " );
		}

		return ida_pattern.str( );
	}

	/*Credits: @hinnie on unknowncheats: https://www.unknowncheats.me/forum/counterstrike-global-offensive/375564-rtti-helper-easy-vtable-pointers.html */
	__forceinline std::vector<uintptr_t> GetXRefsTo( uintptr_t address, uintptr_t start, uintptr_t size ) {
		std::vector<uintptr_t> xrefs = { };

		// Convert the address over to an IDA pattern string
		const std::string ida_pattern = BytesToIDAPattern( ( byte* )&address, 4 );

		// Get the end of the section (in our case the end of the .rdata section)
		const uintptr_t end = start + size;
		while( start && start < end )
		{
			uintptr_t xref = ( uintptr_t )PatternScan( start, ida_pattern.c_str( ), size );

			// If the xref is 0 it means that there either were no xrefs, or there are no remaining xrefs.
			// So we should break out of our loop, otherwise it will keep on trying to look for xrefs.
			if( !xref )
				break;

			// We've found an xref, save it in the vector, and add 4 to start, so it wil now search for xrefs
			// from the previously found xref untill we're at the end of the section, or there aren't any xrefs left.
			xrefs.push_back( xref );
			start = xref + 4;
		}

		return xrefs;
	}

	/*Credits: @hinnie on unknowncheats: https://www.unknowncheats.me/forum/counterstrike-global-offensive/375564-rtti-helper-easy-vtable-pointers.html */
	__forceinline bool GetSectionInfo( uintptr_t base_address, const char* section_name, uintptr_t& section_start, uintptr_t& section_size ) {
		const PIMAGE_DOS_HEADER dos_header = ( PIMAGE_DOS_HEADER )base_address;
		if( dos_header->e_magic != IMAGE_DOS_SIGNATURE )
			return false;

		const PIMAGE_NT_HEADERS32 nt_headers = ( PIMAGE_NT_HEADERS32 )( base_address + dos_header->e_lfanew );
		if( nt_headers->Signature != IMAGE_NT_SIGNATURE )
			return false;

		PIMAGE_SECTION_HEADER section_header = IMAGE_FIRST_SECTION( nt_headers );
		uint16_t number_of_sections = nt_headers->FileHeader.NumberOfSections;
		while( number_of_sections > 0 )
		{
			// If we're at the right section
			if( !strcmp( section_name, ( const char* )section_header->Name ) )
			{
				section_start = base_address + section_header->VirtualAddress;
				section_size = section_header->SizeOfRawData;
				return true;
			}

			section_header++;
			number_of_sections--;
		}

		return false;
	}

	/*Credits: @hinnie on unknowncheats: https://www.unknowncheats.me/forum/counterstrike-global-offensive/375564-rtti-helper-easy-vtable-pointers.html */
	uintptr_t* GetVirtualTablePointer( const char* ModuleName, const char* TableName ) {
		uintptr_t BaseAddress = reinterpret_cast< uintptr_t >( GetModuleHandleA( ModuleName ) );
		if( !BaseAddress )
			return nullptr;

		// Type descriptor names look like this: .?AVC_CSPlayer@@ (so: ".?AV" + TableName + "@@")
		const std::string type_descriptor_name = XorStr( ".?AV" ) + std::string( TableName ) + XorStr( "@@" );

		// Convert the string to an IDA pattern so that we can pattern scan it
		std::string IDAPattern = BytesToIDAPattern( ( byte* )type_descriptor_name.data( ), type_descriptor_name.size( ) );

		auto module = ( uintptr_t )GetModuleHandleA( ModuleName );

		uintptr_t rtti_type_descriptor = Scan( module, IDAPattern.data( ) );
		if( !rtti_type_descriptor )
			return nullptr;

		// We're doing - 0x8 here, because the location of the rtti_type_descriptor is 0x8 bytes before the string (open up client_panorama.dll in IDA and take a look) 
		rtti_type_descriptor -= 0x8;

		// We only need to get xrefs that are inside the .rdata section (there sometimes are xrefs in .text, so we have to filter them out)
		uintptr_t rdata_start = 0, rdata_size = 0;
		if( !GetSectionInfo( BaseAddress, XorStr( ".rdata" ), rdata_start, rdata_size ) )
			return nullptr;

		// Get all xrefs to the type_descriptor
		const std::vector<uintptr_t> xrefs = GetXRefsTo( rtti_type_descriptor, rdata_start, rdata_size );
		for( const uintptr_t xref : xrefs )
		{
			// xref - 0x8 = offset of this vtable in complete class (from top)
			// So if it's 0 it means it's the class we need, and not some class it inherits from (again, opening up client_panorama.dll in IDA will help you understand)
			const int32_t offset_from_class = *( int32_t* )( xref - 0x8 );
			if( offset_from_class != 0 )
				continue;

			// We've found the correct xref, the object locator is 0xC bytes before the xref. (Again, client_panorama.dll yada yada yada)
			const uintptr_t object_locator = xref - 0xC;

			// Now we need to get an xref to the object locator, as that's where the vtable is located
			{
				// Convert the object locator address to an IDA pattern
				IDAPattern = BytesToIDAPattern( ( byte* )&object_locator, 4 );

				const uintptr_t vtable_address = ( uintptr_t )PatternScan( rdata_start, IDAPattern.c_str( ), rdata_size ) + 0x4;

				// Here I'm checking for <= 4 as we're adding 0x4 to it. So if the pattern scan returns 0 we still head the fuck out
				if( vtable_address <= 4 )
					return nullptr;

				// We've now found the vtable address, however, we probably want a pointer to the vtable (which is in .text).
				// To do this, we're going to find a reference to the vtable address, and use that as pointer.

				// If you don't need a pointer to the vtable in your implementation however, just return vtable_address
				uintptr_t text_start = 0, text_size = 0;
				if( !GetSectionInfo( BaseAddress, XorStr( ".text" ), text_start, text_size ) )
					return nullptr;

				// Convert the vtable address to an IDA pattern
				IDAPattern = BytesToIDAPattern( ( byte* )&vtable_address, 4 );
				return reinterpret_cast< uintptr_t* >( PatternScan( text_start, IDAPattern.c_str( ), text_size ) );
			}
		}

		// We for some odd reason didn't find any valid xrefs
		return nullptr;
	}

	std::uintptr_t Scan( const std::string& image_name, const std::string& signature, bool LOL ) {
		auto image = GetModuleHandleA( image_name.c_str( ) );
		return Scan( ( std::uintptr_t )image, signature, LOL );
	}	
	
	std::uintptr_t ScanC( const std::string& image_name, const std::string& signature ) {
		auto image = GetModuleHandleA( image_name.c_str( ) );
		return Scan( ( std::uintptr_t )image, signature );
	}

	std::uintptr_t Scan( const std::uintptr_t image, const std::string& signature, bool LOL ) {
		if( !image ) {
			return 0u;
		}

		auto image_base = ( std::uintptr_t )( image );
		auto image_dos_hdr = ( IMAGE_DOS_HEADER* )( image_base );

		if( image_dos_hdr->e_magic != IMAGE_DOS_SIGNATURE ) {
			return 0u;
		}

		auto image_nt_hdrs = ( IMAGE_NT_HEADERS* )( image_base + image_dos_hdr->e_lfanew );

		if( image_nt_hdrs->Signature != IMAGE_NT_SIGNATURE ) {
			return 0u;
		}

		auto scan_begin = ( std::uint8_t* )( image_base );
		auto scan_end = ( std::uint8_t* )( image_base + image_nt_hdrs->OptionalHeader.SizeOfImage );

		std::uint8_t* scan_result = nullptr;
		std::uint8_t* scan_data = ( std::uint8_t* )( signature.c_str( ) );

		for( auto current = scan_begin; current < scan_end; current++ ) {
			if( *( std::uint8_t* )scan_data == '\?' || *current == GET_BYTE( scan_data ) ) {
				if( !scan_result )
					scan_result = current;

				if( !scan_data[ 2 ] )
					return ( std::uintptr_t )( scan_result );

				scan_data += ( *( std::uint16_t* )scan_data == '\?\?' || *( std::uint8_t* )scan_data != '\?' ) ? 3 : 2;

				if( !*scan_data )
					return ( std::uintptr_t )( scan_result );
			}
			else if( scan_result ) {
				current = scan_result;
				scan_data = ( std::uint8_t* )( signature.c_str( ) );
				scan_result = nullptr;
			}
		}

		return 0u;
	}
	
	unsigned int FindInDataMap( datamap_t* pMap, const char* name ) {
		while( pMap ) {
			for( int i = 0; i < pMap->dataNumFields; i++ ) {
				if( pMap->dataDesc[ i ].fieldName == NULL )
					continue;

				if( strcmp( name, pMap->dataDesc[ i ].fieldName ) == 0 )
					return pMap->dataDesc[ i ].fieldOffset[ TD_OFFSET_NORMAL ];

				if( pMap->dataDesc[ i ].fieldType == FIELD_EMBEDDED ) {
					if( pMap->dataDesc[ i ].td ) {
						unsigned int offset;

						if( ( offset = FindInDataMap( pMap->dataDesc[ i ].td, name ) ) != 0 )
							return offset;
					}
				}
			}
			pMap = pMap->baseMap;
		}

		return 0;
	}

	DWORD CallableFromRelative( DWORD nAddress )
	{
		return nAddress + *( DWORD* )( nAddress + 1 ) + 5;
	}
}
```

`CSGO SDK/SDK/Utils/PatternScan.hpp`:

```hpp
#pragma once

#include "auto.hpp"
#include "../Classes/DataMap.hpp"

#include <functional>
#include <thread>
#include <chrono>

#define SDK_concat(x, y) x##y
#define SDK_concatiate(x, y) SDK_concat(x, y)
#define SDK_pad(size)                                         \
private:                                                          \
  std::uint8_t SDK_concatiate(__pad, __COUNTER__)[size] = {}; \
                                                                  \
public:

namespace SDK::Memory
{
	char* find_utf8( const char* module, const char* string );
	void strcpy_protected( char* dest, const char* src );
	std::uintptr_t Scan( const std::string& image_name, const std::string& signature, bool LOL = false );
	std::uintptr_t Scan( const std::uintptr_t image, const std::string& signature, bool LOL = false );
	uintptr_t* GetVirtualTablePointer( const char* ModuleName, const char* TableName );
	unsigned int FindInDataMap( datamap_t* pMap, const char* name );
	// we have like 5 lambdas for this in random places
	DWORD CallableFromRelative( DWORD nAddress );

	inline void ThreadSleep( DWORD msecs ) {
		std::this_thread::sleep_for( std::chrono::milliseconds( msecs ) );
	}

	template <typename T>
	inline bool ResolveSymbol( T* out, const std::function<T( )>& fn )
	{
		unsigned int i = 0;
		while( true )
		{
			*out = fn( );
			if( *out )
			{
				break;
			}

			i++;

			//10 seconds
			if( i > 200 )
			{
				return false;
			}

			ThreadSleep( 50 );
		}

		return true;
	}
}

```

`CSGO SDK/SDK/Utils/Print.cpp`:

```cpp
#include "print.hpp"
#include "auto.hpp"

namespace SDK::Win32
{

#ifdef DEV
   const char* m_pPrintTypes[] =
   {
	   "[Trace]",
	   "[Warning]",
	   "[Error]",
   };

   const wchar_t* m_pWidePrintTypes[] =
   {
	   L"[Trace]",
	   L"[Warning]",
	   L"[Error]",
   };
#endif

   void DebugPrint( PrintType print_type, const char* message ) {
   #ifdef DEV
	  char output[ 4096 ] = { };

	  auto type = m_pPrintTypes[ static_cast< int >( print_type ) ];
	  sprintf_s( output, "%s %s\r\n", type, message );

	  printf( output );
   #endif
}

   void DebugPrint( PrintType print_type, const wchar_t* message ) {
   #ifdef DEV
	  wchar_t output[ 4096 ] = { };

	  auto type = m_pWidePrintTypes[ static_cast< int >( print_type ) ];
	  wsprintfW( output, L"%s %s\r\n", type, message );

	  OutputDebugStringW( output );
   #endif
   }

   void Trace( const char* format, ... ) {
   #ifdef DEV
	  char message[ 2048 ] = { };

	  va_list args;
	  va_start( args, format );
	  int length = vsprintf_s( message, format, args );
	  va_end( args );

	  DebugPrint( PrintType::Trace, message );
   #endif
   }

   void Trace( const wchar_t* format, ... ) {
   #ifdef DEV
	  wchar_t message[ 2048 ] = { };

	  va_list args;
	  va_start( args, format );
	  int length = wvsprintfW( message, format, args );
	  va_end( args );

	  DebugPrint( PrintType::Trace, message );
   #endif
   }

   void Warning( const char* format, ... ) {
   #ifdef DEV
	  char message[ 2048 ] = { };

	  va_list args;
	  va_start( args, format );
	  int length = vsprintf_s( message, format, args );
	  va_end( args );

	  DebugPrint( PrintType::Warning, message );
   #endif
   }

   void Warning( const wchar_t* format, ... ) {
   #ifdef DEV
	  wchar_t message[ 2048 ] = { };

	  va_list args;
	  va_start( args, format );
	  int length = wvsprintfW( message, format, args );
	  va_end( args );

	  DebugPrint( PrintType::Warning, message );
   #endif
}

   void Error( const char* format, ... ) {
   #ifdef DEV
	  char message[ 2048 ] = { };

	  va_list args;
	  va_start( args, format );
	  int length = vsprintf_s( message, format, args );
	  va_end( args );

	  DebugPrint( PrintType::Error, message );
   #endif // !1
   }

   void Error( const wchar_t* format, ... ) {
   #ifdef DEV
	  wchar_t message[ 2048 ] = { };

	  va_list args;
	  va_start( args, format );
	  int length = wvsprintfW( message, format, args );
	  va_end( args );

	  DebugPrint( PrintType::Error, message );
   #endif // !1
   }

   }

```

`CSGO SDK/SDK/Utils/Print.hpp`:

```hpp
#pragma once

namespace SDK::Win32
{

  enum class PrintType
  {
	 Trace = 0,
	 Warning,
	 Error,
  };

  void DebugPrint( PrintType print_type, const char* message );
  void DebugPrint( PrintType print_type, const wchar_t* message );

  void Trace( const char* format, ... );
  void Trace( const wchar_t* format, ... );
  void Warning( const char* format, ... );
  void Warning( const wchar_t* format, ... );
  void Error( const char* format, ... );
  void Error( const wchar_t* format, ... );

}

```

`CSGO SDK/SDK/Utils/auto.hpp`:

```hpp
#pragma once

#include "os.hpp"

#include <string>
#include <memory>
#include <vector>
#include <cmath>
#include <algorithm>

```

`CSGO SDK/SDK/Utils/os.hpp`:

```hpp
#pragma once

#include <windows.h>

#undef min
#undef max

#undef GetProp
```

`CSGO SDK/SDK/Utils/singleton.hpp`:

```hpp
#pragma once

namespace SDK::Core
{

  template<class T>
  class Singleton
  {
  public:
	 static T& Instance( ) {
		static T instance;
		return instance;
	 }

	 T* operator -> ( ) {
		return ( T* )( this );
	 }

	 const T* operator -> ( ) const {
		return ( const T* )( this );
	 }

  protected:
	 Singleton( ) = default;
	 Singleton( const Singleton& ) = delete;
	 Singleton& operator = ( const Singleton& ) = delete;
  };

}

```

`CSGO SDK/SDK/Utils/vcall.hpp`:

```hpp
#pragma once

namespace SDK::Memory
{
  template<typename T>
  __forceinline T VCall( const void* instance, const unsigned int index ) {
	 return ( T )( ( *( void*** )instance )[index] );
  }
}

```

`CSGO SDK/SDK/Utils/vmt_swap.cpp`:

```cpp
#include "vmt_swap.hpp"
#include "../../Libraries/minhook-master/include/MinHook.h"

bool SDK::Memory::VmtSwap::Create( const void* instance ) {
	m_ppInstance = ( std::uintptr_t** )instance;
	m_pRestore = *m_ppInstance;

	if( !m_pRestore )
		return false;

	while( m_pRestore[ m_nSize ] )
		m_nSize++;

	if( !m_nSize )
		return false;

	m_nSize++;
	m_pReplace = std::make_unique<std::uintptr_t[ ]>( m_nSize );
	memcpy( m_pReplace.get( ), &m_pRestore[ -1 ], m_nSize * sizeof( std::uintptr_t ) );

	Replace( );

	return true;
}

void SDK::Memory::VmtSwap::Destroy( ) {
	Restore( );

	m_ppInstance = nullptr;
	m_pRestore = nullptr;
	m_pReplace.reset( );
	m_nSize = 0u;
}

void SDK::Memory::VmtSwap::Replace( ) {
	if( !m_ppInstance || !m_pReplace )
		return;

	*m_ppInstance = &m_pReplace.get( )[ 1 ];
}

void SDK::Memory::VmtSwap::Restore( ) {
	if( !m_ppInstance || !m_pRestore )
		return;

	*m_ppInstance = m_pRestore;
}

void SDK::Memory::VmtSwap::Hook( const void* hooked, const std::uint32_t index ) {
	if( !m_pReplace )
		return;

	m_pReplace[ index + 1 ] = ( std::uintptr_t )hooked;
}

SDK::Memory::DetourHook_t::DetourHook_t( void* pNewFunction ) :
	m_nAddress( NULL ), m_pNewFunction( pNewFunction ), m_pOldFunction( nullptr )
{
	;
}

bool SDK::Memory::DetourHook_t::Hook( ) {
	if( !m_nAddress ) {
		return false;
	}

	if( MH_CreateHook( ( LPVOID )m_nAddress, m_pNewFunction, &m_pOldFunction ) != MH_OK ) {
		return false;
	}

	if( MH_EnableHook( ( LPVOID )m_nAddress ) != MH_OK ) {
		return false;
	}

	return true;
}

bool SDK::Memory::DetourHook_t::Restore( ) {
	if( !m_nAddress ) {
		return true;
	}

	if( MH_DisableHook( ( LPVOID )m_nAddress ) != MH_OK ) {
		return false;
	}

	return true;
}
```

`CSGO SDK/SDK/Utils/vmt_swap.hpp`:

```hpp
#pragma once
#include <memory>
#include <stdint.h>

namespace SDK::Memory
{

	class VmtSwap
	{
	public:
		using Shared = std::shared_ptr<VmtSwap>;
	public:
		VmtSwap( const void* instance = nullptr ) {
			if( instance )
				Create( instance );
		}

	public:
		~VmtSwap( ) {
			Destroy( );
		}

	public:
		bool Create( const void* instance );
		void Destroy( );
		void Replace( );
		void Restore( );
		void Hook( const void* hooked, const std::uint32_t index );

		template<typename T>
		T VCall( const std::size_t index ) {
			return ( T )( m_pRestore[ index ] );
		}
	private:
		std::uintptr_t** m_ppInstance = nullptr;
		std::uintptr_t* m_pRestore = nullptr;
		std::unique_ptr<std::uintptr_t[ ]> m_pReplace = nullptr;
		std::uint32_t m_nSize = 0u;
	};

	class DetourHook_t
	{
	public:
		DetourHook_t( ) = delete;
		DetourHook_t( void* pNewFunction );
		~DetourHook_t( ) = default;

		bool Hook( );
		bool Restore( );

		uint32_t m_nAddress;
		void* m_pNewFunction;
		void* m_pOldFunction;
	};

}

```

`CSGO SDK/SDK/Valve/CBaseHandle.hpp`:

```hpp
#pragma once
#include "../sdk.hpp"
#include "../Classes/entity.hpp"
#include "../../source.hpp"

class CBaseHandle
{
public:
  CBaseHandle( );
  CBaseHandle( const CBaseHandle &other );
  CBaseHandle( unsigned long value );
  CBaseHandle( int iEntry, int iSerialNumber );

  void Init( int iEntry, int iSerialNumber );
  void Init( int iEntry, int iSerialNumber, int iBits );
  void Term( );

  // Even if this returns true, Get() still can return return a non-null value.
  // This just tells if the handle has been initted with any values.
  bool IsValid( ) const;

  int GetEntryIndex( ) const;
  int GetSerialNumber( ) const;

  int ToInt( ) const;
  bool operator !=( const CBaseHandle &other ) const;
  bool operator ==( const CBaseHandle &other ) const;
  bool operator ==( const IHandleEntity* pEnt ) const;
  bool operator !=( const IHandleEntity* pEnt ) const;
  bool operator <( const CBaseHandle &other ) const;
  bool operator <( const IHandleEntity* pEnt ) const;

  // Assign a value to the handle.
  const CBaseHandle& operator=( const IHandleEntity *pEntity );
  const CBaseHandle& Set( const IHandleEntity *pEntity );

  // Use this to dereference the handle.
  // Note: this is implemented in game code (ehandle.h)
  IHandleEntity* Get( ) const;

protected:
  // The low NUM_SERIAL_BITS hold the index. If this value is less than MAX_EDICTS, then the entity is networkable.
  // The high NUM_SERIAL_NUM_BITS bits are the serial number.
  unsigned long	m_Index;
};

inline CBaseHandle::CBaseHandle( ) {
  m_Index = INVALID_EHANDLE_INDEX;
}

inline CBaseHandle::CBaseHandle( const CBaseHandle &other ) {
  m_Index = other.m_Index;
}

inline CBaseHandle::CBaseHandle( unsigned long value ) {
  m_Index = value;
}

inline CBaseHandle::CBaseHandle( int iEntry, int iSerialNumber ) {
  Init( iEntry, iSerialNumber );
}

inline void CBaseHandle::Init( int iEntry, int iSerialNumber ) {
  m_Index = iEntry | ( iSerialNumber << NUM_ENT_ENTRY_BITS );
}

inline void CBaseHandle::Init( int iEntry, int iSerialNumber, int iBits ) {
  m_Index = iEntry | ( iSerialNumber << iBits );
}

inline void CBaseHandle::Term( ) {
  m_Index = INVALID_EHANDLE_INDEX;
}

inline bool CBaseHandle::IsValid( ) const {
  return m_Index != INVALID_EHANDLE_INDEX;
}

inline int CBaseHandle::GetEntryIndex( ) const {
  return m_Index & ENT_ENTRY_MASK;
}

inline int CBaseHandle::GetSerialNumber( ) const {
  return m_Index >> NUM_ENT_ENTRY_BITS;
}

inline int CBaseHandle::ToInt( ) const {
  return ( int )m_Index;
}

inline bool CBaseHandle::operator !=( const CBaseHandle &other ) const {
  return m_Index != other.m_Index;
}

inline bool CBaseHandle::operator ==( const CBaseHandle &other ) const {
  return m_Index == other.m_Index;
}

inline bool CBaseHandle::operator ==( const IHandleEntity* pEnt ) const {
  return Get( ) == pEnt;
}

inline bool CBaseHandle::operator !=( const IHandleEntity* pEnt ) const {
  return Get( ) != pEnt;
}

inline bool CBaseHandle::operator <( const CBaseHandle &other ) const {
  return m_Index < other.m_Index;
}

inline bool CBaseHandle::operator <( const IHandleEntity *pEntity ) const {
  unsigned long otherIndex = ( pEntity ) ? pEntity->GetRefEHandle( ).m_Index : INVALID_EHANDLE_INDEX;
  return m_Index < otherIndex;
}

inline const CBaseHandle& CBaseHandle::operator=( const IHandleEntity *pEntity ) {
  return Set( pEntity );
}

inline const CBaseHandle& CBaseHandle::Set( const IHandleEntity *pEntity ) {
  if( pEntity ) {
	 *this = pEntity->GetRefEHandle( );
  } else {
	 m_Index = INVALID_EHANDLE_INDEX;
  }

  return *this;
}

inline IHandleEntity* CBaseHandle::Get( ) const {
  return ( IHandleEntity* )Interfaces::m_pEntList->GetClientEntityFromHandle( *this );
}

template < class T >
class CHandle : public CBaseHandle {
public:
  CHandle( );
  CHandle( int iEntry, int iSerialNumber );
  CHandle( const CBaseHandle& handle );
  CHandle( T* pVal );

  // The index should have come from a call to ToInt(). If it hasn't, you're in trouble.
  static CHandle< T > FromIndex( int index );

  T* Get( ) const;
  void Set( const T* pVal );

  operator T*( );
  operator T*( ) const;

  bool operator!( ) const;
  bool operator==( T* val ) const;
  bool operator!=( T* val ) const;
  const CBaseHandle& operator=( const T* val );

  T* operator->( ) const;
};

template < class T >
CHandle< T >::CHandle( ) {
}

template < class T >
CHandle< T >::CHandle( int iEntry, int iSerialNumber ) {
  Init( iEntry, iSerialNumber );
}

template < class T >
CHandle< T >::CHandle( const CBaseHandle& handle ) :
  CBaseHandle( handle ) {
}

template < class T >
CHandle< T >::CHandle( T* pObj ) {
  Term( );
  Set( pObj );
}

template < class T >
inline CHandle< T > CHandle< T >::FromIndex( int index ) {
  CHandle< T > ret;
  ret.m_Index = index;
  return ret;
}

template < class T >
inline T* CHandle< T >::Get( ) const {
  return ( T* )CBaseHandle::Get( );
}

template < class T >
inline CHandle< T >::operator T*( ) {
  return Get( );
}

template < class T >
inline CHandle< T >::operator T*( ) const {
  return Get( );
}

template < class T >
inline bool CHandle< T >::operator!( ) const {
  return !Get( );
}

template < class T >
inline bool CHandle< T >::operator==( T* val ) const {
  return Get( ) == val;
}

template < class T >
inline bool CHandle< T >::operator!=( T* val ) const {
  return Get( ) != val;
}

template < class T >
void CHandle< T >::Set( const T* pVal ) {
  CBaseHandle::Set( reinterpret_cast< const IHandleEntity* >( pVal ) );
}

template < class T >
inline const CBaseHandle& CHandle< T >::operator=( const T* val ) {
  Set( val );
  return *this;
}

template < class T >
T* CHandle< T >::operator->( ) const {
  return Get( );
}

```

`CSGO SDK/SDK/Valve/Matrix.cpp`:

```cpp
#include "matrix.hpp"
#include "vector.hpp"
#include "qangle.hpp"
#include "../Classes/CStudioRender.hpp"

float* matrix3x4_t::operator [] ( const std::uint32_t index ) {
   return m[ index ];
}
const float* matrix3x4_t::operator [] ( const std::uint32_t index ) const {
   return m[ index ];
}

Vector matrix3x4_t::at( const std::uint32_t i ) const {
   return Vector{ m[ 0 ][ i ], m[ 1 ][ i ], m[ 2 ][ i ] };
}

void matrix3x4_t::TransformAABB( const Vector& vecMinsIn, const Vector& vecMaxsIn, Vector& vecMinsOut, Vector& vecMaxsOut ) const {
   Vector localCenter = ( vecMinsIn + vecMaxsIn ) * 0.5f;
   Vector localExtents = ( vecMaxsIn - localCenter );

   Vector worldCenter = localCenter.Transform( *this );

   Vector worldExtents = Vector(
	  std::fabsf( localExtents.Dot( m[ 0 ] ) ),
	  std::fabsf( localExtents.Dot( m[ 1 ] ) ),
	  std::fabsf( localExtents.Dot( m[ 2 ] ) ) );

   vecMinsOut = ( worldCenter - worldExtents );
   vecMaxsOut = ( worldCenter + worldExtents );
}

void matrix3x4_t::AngleMatrix( const QAngle& angles ) {
   float sr, sp, sy, cr, cp, cy;
   DirectX::XMScalarSinCos( &sy, &cy, ToRadians( angles[ 1 ] ) );
   DirectX::XMScalarSinCos( &sp, &cp, ToRadians( angles[ 0 ] ) );
   DirectX::XMScalarSinCos( &sr, &cr, ToRadians( angles[ 2 ] ) );

   // matrix = (YAW * PITCH) * ROLL
   m[ 0 ][ 0 ] = cp * cy;
   m[ 1 ][ 0 ] = cp * sy;
   m[ 2 ][ 0 ] = -sp;

   float crcy = cr * cy;
   float crsy = cr * sy;
   float srcy = sr * cy;
   float srsy = sr * sy;
   m[ 0 ][ 1 ] = sp * srcy - crsy;
   m[ 1 ][ 1 ] = sp * srsy + crcy;
   m[ 2 ][ 1 ] = sr * cp;

   m[ 0 ][ 2 ] = ( sp * crcy + srsy );
   m[ 1 ][ 2 ] = ( sp * crsy - srcy );
   m[ 2 ][ 2 ] = cr * cp;

   m[ 0 ][ 3 ] = 0.0f;
   m[ 1 ][ 3 ] = 0.0f;
   m[ 2 ][ 3 ] = 0.0f;
}

void matrix3x4_t::AngleMatrix( const QAngle& angles, const Vector& position ) {
   AngleMatrix( angles );
   MatrixSetColumn( position, 3 );
}

void matrix3x4_t::MatrixAngles( QAngle& angles ) {
   float forward[ 3 ];
   float left[ 3 ];
   float up[ 3 ];

   //
   // Extract the basis vectors from the matrix. Since we only need the Z
   // component of the up vector, we don't get X and Y.
   //
   forward[ 0 ] = m[ 0 ][ 0 ];
   forward[ 1 ] = m[ 1 ][ 0 ];
   forward[ 2 ] = m[ 2 ][ 0 ];
   left[ 0 ] = m[ 0 ][ 1 ];
   left[ 1 ] = m[ 1 ][ 1 ];
   left[ 2 ] = m[ 2 ][ 1 ];
   up[ 2 ] = m[ 2 ][ 2 ];

   float xyDist = sqrtf( forward[ 0 ] * forward[ 0 ] + forward[ 1 ] * forward[ 1 ] );

   // enough here to get angles?
   if ( xyDist > 0.001f ) {
	  // (yaw)	y = ATAN( forward.y, forward.x );		-- in our space, forward is the X axis
	  angles.yaw = ToDegrees( atan2f( forward[ 1 ], forward[ 0 ] ) );

	  // (pitch)	x = ATAN( -forward.z, sqrt(forward.x*forward.x+forward.y*forward.y) );
	  angles.pitch = ToDegrees( atan2f( -forward[ 2 ], xyDist ) );

	  // (roll)	z = ATAN( left.z, up.z );
	  angles.roll = ToDegrees( atan2f( left[ 2 ], up[ 2 ] ) );
   } else // forward is mostly Z, gimbal lock-
   {
	  // (yaw)	y = ATAN( -left.x, left.y );			-- forward is mostly z, so use right for yaw
	  angles.yaw = ToDegrees( atan2f( -left[ 0 ], left[ 1 ] ) );

	  // (pitch)	x = ATAN( -forward.z, sqrt(forward.x*forward.x+forward.y*forward.y) );
	  angles.pitch = ToDegrees( atan2f( -forward[ 2 ], xyDist ) );

	  // Assume no roll in this case as one degree of freedom has been lost (i.e. yaw == roll)
	  angles.roll = 0.f;
   }
}

void matrix3x4_t::MatrixAngles( QAngle& angles, Vector& position ) {
   MatrixAngles( angles );
   MatrixSetColumn( position, 3 );
}

void matrix3x4_t::MatrixSetColumn( const Vector& in, int column ) {
   m[ 0 ][ column ] = in.x;
   m[ 1 ][ column ] = in.y;
   m[ 2 ][ column ] = in.z;
}

void matrix3x4_t::QuaternionMatrix( const Quaternion& q ) {
   // Original code
   // This should produce the same code as below with optimization, but looking at the assmebly,
   // it doesn't.  There are 7 extra multiplies in the release build of this, go figure.
#if 1
   m[ 0 ][ 0 ] = 1.0 - 2.0 * q.y * q.y - 2.0 * q.z * q.z;
   m[ 1 ][ 0 ] = 2.0 * q.x * q.y + 2.0 * q.w * q.z;
   m[ 2 ][ 0 ] = 2.0 * q.x * q.z - 2.0 * q.w * q.y;

   m[ 0 ][ 1 ] = 2.0f * q.x * q.y - 2.0f * q.w * q.z;
   m[ 1 ][ 1 ] = 1.0f - 2.0f * q.x * q.x - 2.0f * q.z * q.z;
   m[ 2 ][ 1 ] = 2.0f * q.y * q.z + 2.0f * q.w * q.x;

   m[ 0 ][ 2 ] = 2.0f * q.x * q.z + 2.0f * q.w * q.y;
   m[ 1 ][ 2 ] = 2.0f * q.y * q.z - 2.0f * q.w * q.x;
   m[ 2 ][ 2 ] = 1.0f - 2.0f * q.x * q.x - 2.0f * q.y * q.y;

   m[ 0 ][ 3 ] = 0.0f;
   m[ 1 ][ 3 ] = 0.0f;
   m[ 2 ][ 3 ] = 0.0f;
#else
   float wx, wy, wz, xx, yy, yz, xy, xz, zz, x2, y2, z2;

   // precalculate common multiplitcations
   x2 = q.x + q.x;
   y2 = q.y + q.y;
   z2 = q.z + q.z;
   xx = q.x * x2;
   xy = q.x * y2;
   xz = q.x * z2;
   yy = q.y * y2;
   yz = q.y * z2;
   zz = q.z * z2;
   wx = q.w * x2;
   wy = q.w * y2;
   wz = q.w * z2;

   matrix[ 0 ][ 0 ] = 1.0 - ( yy + zz );
   matrix[ 0 ][ 1 ] = xy - wz;
   matrix[ 0 ][ 2 ] = xz + wy;
   matrix[ 0 ][ 3 ] = 0.0f;

   matrix[ 1 ][ 0 ] = xy + wz;
   matrix[ 1 ][ 1 ] = 1.0 - ( xx + zz );
   matrix[ 1 ][ 2 ] = yz - wx;
   matrix[ 1 ][ 3 ] = 0.0f;

   matrix[ 2 ][ 0 ] = xz - wy;
   matrix[ 2 ][ 1 ] = yz + wx;
   matrix[ 2 ][ 2 ] = 1.0 - ( xx + yy );
   matrix[ 2 ][ 3 ] = 0.0f;
#endif
}

void matrix3x4_t::QuaternionMatrix( const Quaternion& q, const Vector& pos ) {
   QuaternionMatrix( q );

   this->m[ 0 ][ 3 ] = pos.x;
   this->m[ 1 ][ 3 ] = pos.y;
   this->m[ 2 ][ 3 ] = pos.z;
}

// СПАСИБО ПАПАША( ДЖОН КАРМАК ) ЗА ЭТУ КВАКОВСКУЮ МАТЕМАТИКУ 20 ВЕКА ( НУ ТУТ НЕ СПИЗДИЛ РЕАЛЬНО 20 ВЕК )
matrix3x4_t matrix3x4_t::ConcatTransforms( matrix3x4_t in ) const {
   matrix3x4_t out;
   out[ 0 ][ 0 ] = m[ 0 ][ 0 ] * in[ 0 ][ 0 ] + m[ 0 ][ 1 ] * in[ 1 ][ 0 ] + m[ 0 ][ 2 ] * in[ 2 ][ 0 ];
   out[ 0 ][ 1 ] = m[ 0 ][ 0 ] * in[ 0 ][ 1 ] + m[ 0 ][ 1 ] * in[ 1 ][ 1 ] + m[ 0 ][ 2 ] * in[ 2 ][ 1 ];
   out[ 0 ][ 2 ] = m[ 0 ][ 0 ] * in[ 0 ][ 2 ] + m[ 0 ][ 1 ] * in[ 1 ][ 2 ] + m[ 0 ][ 2 ] * in[ 2 ][ 2 ];
   out[ 0 ][ 3 ] = m[ 0 ][ 0 ] * in[ 0 ][ 3 ] + m[ 0 ][ 1 ] * in[ 1 ][ 3 ] + m[ 0 ][ 2 ] * in[ 2 ][ 3 ] + m[ 0 ][ 3 ];
   out[ 1 ][ 0 ] = m[ 1 ][ 0 ] * in[ 0 ][ 0 ] + m[ 1 ][ 1 ] * in[ 1 ][ 0 ] + m[ 1 ][ 2 ] * in[ 2 ][ 0 ];
   out[ 1 ][ 1 ] = m[ 1 ][ 0 ] * in[ 0 ][ 1 ] + m[ 1 ][ 1 ] * in[ 1 ][ 1 ] + m[ 1 ][ 2 ] * in[ 2 ][ 1 ];
   out[ 1 ][ 2 ] = m[ 1 ][ 0 ] * in[ 0 ][ 2 ] + m[ 1 ][ 1 ] * in[ 1 ][ 2 ] + m[ 1 ][ 2 ] * in[ 2 ][ 2 ];
   out[ 1 ][ 3 ] = m[ 1 ][ 0 ] * in[ 0 ][ 3 ] + m[ 1 ][ 1 ] * in[ 1 ][ 3 ] + m[ 1 ][ 2 ] * in[ 2 ][ 3 ] + m[ 1 ][ 3 ];
   out[ 2 ][ 0 ] = m[ 2 ][ 0 ] * in[ 0 ][ 0 ] + m[ 2 ][ 1 ] * in[ 1 ][ 0 ] + m[ 2 ][ 2 ] * in[ 2 ][ 0 ];
   out[ 2 ][ 1 ] = m[ 2 ][ 0 ] * in[ 0 ][ 1 ] + m[ 2 ][ 1 ] * in[ 1 ][ 1 ] + m[ 2 ][ 2 ] * in[ 2 ][ 1 ];
   out[ 2 ][ 2 ] = m[ 2 ][ 0 ] * in[ 0 ][ 2 ] + m[ 2 ][ 1 ] * in[ 1 ][ 2 ] + m[ 2 ][ 2 ] * in[ 2 ][ 2 ];
   out[ 2 ][ 3 ] = m[ 2 ][ 0 ] * in[ 0 ][ 3 ] + m[ 2 ][ 1 ] * in[ 1 ][ 3 ] + m[ 2 ][ 2 ] * in[ 2 ][ 3 ] + m[ 2 ][ 3 ];
   return out;
}

Vector matrix3x4_t::operator*( const Vector& vVec ) const {
   Vector vRet;
   vRet.x = m[ 0 ][ 0 ] * vVec.x + m[ 0 ][ 1 ] * vVec.y + m[ 0 ][ 2 ] * vVec.z + m[ 0 ][ 3 ];
   vRet.y = m[ 1 ][ 0 ] * vVec.x + m[ 1 ][ 1 ] * vVec.y + m[ 1 ][ 2 ] * vVec.z + m[ 1 ][ 3 ];
   vRet.z = m[ 2 ][ 0 ] * vVec.x + m[ 2 ][ 1 ] * vVec.y + m[ 2 ][ 2 ] * vVec.z + m[ 2 ][ 3 ];

   return vRet;
}

matrix3x4_t matrix3x4_t::operator+( const matrix3x4_t& other ) const {
   matrix3x4_t ret;
   for ( int i = 0; i < 12; i++ ) {
	  ( ( float* ) ret.m )[ i ] = ( ( float* ) m )[ i ] + ( ( float* ) other.m )[ i ];
   }
   return ret;
}

matrix3x4_t matrix3x4_t::operator-( const matrix3x4_t& other ) const {
   matrix3x4_t ret;
   for ( int i = 0; i < 12; i++ ) {
	  ( ( float* ) ret.m )[ i ] = ( ( float* ) m )[ i ] - ( ( float* ) other.m )[ i ];
   }
   return ret;
}

matrix3x4_t matrix3x4_t::operator*( const float& other ) const {
   matrix3x4_t ret;
   for ( int i = 0; i < 12; i++ ) {
	  ( ( float* ) ret.m )[ i ] = ( ( float* ) m )[ i ] * other;
   }
   return ret;
}

inline void MatrixGetColumn( const matrix3x4_t& src, int nCol, Vector& pColumn ) {
   pColumn.x = src[ 0 ][ nCol ];
   pColumn.y = src[ 1 ][ nCol ];
   pColumn.z = src[ 2 ][ nCol ];
}

inline void MatrixPosition( const matrix3x4_t& matrix, Vector& position ) {
   MatrixGetColumn( matrix, 3, position );
}

float* VMatrix::operator [] ( const std::uint32_t index ) {
   return m[ index ];
}

const float* VMatrix::operator [] ( const std::uint32_t index ) const {
   return m[ index ];
}

```

`CSGO SDK/SDK/Valve/Matrix.hpp`:

```hpp
#pragma once

#include "../core.hpp"
class Quaternion;
class Vector;
class matrix3x4_t {
public:
   float m[ 3 ][ 4 ] = { };

   float* operator [] ( const std::uint32_t index );
   const float* operator [] ( const std::uint32_t index ) const;

   Vector at( const std::uint32_t i ) const;

   void TransformAABB( const Vector& vecMinsIn, const Vector& vecMaxsIn, Vector& vecMinsOut, Vector& vecMaxsOut ) const;
   void AngleMatrix( const QAngle& angles );
   void AngleMatrix( const QAngle& angles, const Vector& position );
   void MatrixAngles( QAngle& angles );
   void MatrixAngles( QAngle& angles, Vector& position );
   void MatrixSetColumn( const Vector& in, int column );
   void QuaternionMatrix( const Quaternion& q );
   void QuaternionMatrix( const Quaternion& q, const Vector& pos );
   matrix3x4_t ConcatTransforms( matrix3x4_t in ) const;

   matrix3x4_t( ) { }
   matrix3x4_t(
	  float m00, float m01, float m02, float m03,
	  float m10, float m11, float m12, float m13,
	  float m20, float m21, float m22, float m23 ) {
	  m[ 0 ][ 0 ] = m00; m[ 0 ][ 1 ] = m01; m[ 0 ][ 2 ] = m02; m[ 0 ][ 3 ] = m03;
	  m[ 1 ][ 0 ] = m10; m[ 1 ][ 1 ] = m11; m[ 1 ][ 2 ] = m12; m[ 1 ][ 3 ] = m13;
	  m[ 2 ][ 0 ] = m20; m[ 2 ][ 1 ] = m21; m[ 2 ][ 2 ] = m22; m[ 2 ][ 3 ] = m23;
   }

   Vector operator*( const Vector& vVec ) const;
   matrix3x4_t matrix3x4_t::operator+( const matrix3x4_t& other ) const;
   matrix3x4_t matrix3x4_t::operator-( const matrix3x4_t& other ) const;
   matrix3x4_t matrix3x4_t::operator*( const float& other ) const;
   matrix3x4_t matrix3x4_t::operator*( const matrix3x4_t& vm ) const {
	  return ConcatTransforms( vm );
   }
};

class VMatrix {
public:
   float* operator [] ( const std::uint32_t index );
   const float* operator [] ( const std::uint32_t index ) const;

public:
   float m[ 4 ][ 4 ] = { };
};

```

`CSGO SDK/SDK/Valve/UtlBuffer.cpp`:

```cpp
//===== Copyright © 1996-2005, Valve Corporation, All rights reserved. ======//
//
// $Header: $
// $NoKeywords: $
//
// Serialization buffer
//===========================================================================//

#pragma warning( disable : 4514 )

#include "../source.hpp"
#include "UtlBuffer.hpp"
#include <stdio.h>
#include <stdarg.h>
#include <ctype.h>
#include <stdlib.h>
#include <limits.h>
#include "characterset.hpp"

const char* V_strnchr( const char* pStr, char c, int n ) {
  char const* pLetter = pStr;
  char const* pLast = pStr + n;

  // Check the entire string
  while( ( pLetter < pLast ) && ( *pLetter != 0 ) ) {
	 if( *pLetter == c )
		return pLetter;
	 ++pLetter;
  }
  return NULL;
}
//-----------------------------------------------------------------------------
// Finds a string in another string with a case insensitive test w/ length validation
//-----------------------------------------------------------------------------
char const* V_strnistr( char const* pStr, char const* pSearch, int n ) {
  if( !pStr || !pSearch )
	 return 0;

  char const* pLetter = pStr;

  // Check the entire string
  while( *pLetter != 0 ) {
	 if( n <= 0 )
		return 0;

	 // Skip over non-matches
	 if( tolower( *pLetter ) == tolower( *pSearch ) ) {
		int n1 = n - 1;

		// Check for match
		char const* pMatch = pLetter + 1;
		char const* pTest = pSearch + 1;
		while( *pTest != 0 ) {
		  if( n1 <= 0 )
			 return 0;

		  // We've run off the end; don't bother.
		  if( *pMatch == 0 )
			 return 0;

		  if( tolower( *pMatch ) != tolower( *pTest ) )
			 break;

		  ++pMatch;
		  ++pTest;
		  --n1;
		}

		// Found a match!
		if( *pTest == 0 )
		  return pLetter;
	 }

	 ++pLetter;
	 --n;
  }

  return 0;
}
//-----------------------------------------------------------------------------
// Character conversions for C strings
//-----------------------------------------------------------------------------
class CUtlCStringConversion : public CUtlCharConversion {
public:
  CUtlCStringConversion( char nEscapeChar, const char* pDelimiter, int nCount, ConversionArray_t* pArray );

  // Finds a conversion for the passed-in string, returns length
  virtual char FindConversion( const char* pString, int* pLength );

private:
  char m_pConversion[255];
};

//-----------------------------------------------------------------------------
// Character conversions for no-escape sequence strings
//-----------------------------------------------------------------------------
class CUtlNoEscConversion : public CUtlCharConversion {
public:
  CUtlNoEscConversion( char nEscapeChar, const char* pDelimiter, int nCount, ConversionArray_t* pArray ) :
	 CUtlCharConversion( nEscapeChar, pDelimiter, nCount, pArray ) {
  }

  // Finds a conversion for the passed-in string, returns length
  virtual char FindConversion( const char* pString, int* pLength ) {
	 *pLength = 0;
	 return 0;
  }
};

//-----------------------------------------------------------------------------
// List of character conversions
//-----------------------------------------------------------------------------
BEGIN_CUSTOM_CHAR_CONVERSION( CUtlCStringConversion, s_StringCharConversion, "\"", '\\' ) {
  '\n', "n"
},
  { '\t', "t" },
  { '\v', "v" },
  { '\b', "b" },
  { '\r', "r" },
  { '\f', "f" },
  { '\a', "a" },
  { '\\', "\\" },
  { '\?', "\?" },
  { '\'', "\'" },
  { '\"', "\"" },
	 END_CUSTOM_CHAR_CONVERSION( CUtlCStringConversion, s_StringCharConversion, "\"", '\\' );

  CUtlCharConversion* GetCStringCharConversion( ) {
	 return &s_StringCharConversion;
  }

  BEGIN_CUSTOM_CHAR_CONVERSION( CUtlNoEscConversion, s_NoEscConversion, "\"", 0x7F ) {
	 0x7F, ""
  },
	 END_CUSTOM_CHAR_CONVERSION( CUtlNoEscConversion, s_NoEscConversion, "\"", 0x7F );

	 CUtlCharConversion* GetNoEscCharConversion( ) {
		return &s_NoEscConversion;
	 }

	 //-----------------------------------------------------------------------------
	 // Constructor
	 //-----------------------------------------------------------------------------
	 CUtlCStringConversion::CUtlCStringConversion( char nEscapeChar, const char* pDelimiter, int nCount, ConversionArray_t* pArray ) :
		CUtlCharConversion( nEscapeChar, pDelimiter, nCount, pArray ) {
		memset( m_pConversion, 0x0, sizeof( m_pConversion ) );
		for( int i = 0; i < nCount; ++i ) {
		  m_pConversion[pArray[i].m_pReplacementString[0]] = pArray[i].m_nActualChar;
		}
	 }

	 // Finds a conversion for the passed-in string, returns length
	 char CUtlCStringConversion::FindConversion( const char* pString, int* pLength ) {
		char c = m_pConversion[pString[0]];
		*pLength = ( c != '\0' ) ? 1 : 0;
		return c;
	 }

	 //-----------------------------------------------------------------------------
	 // Constructor
	 //-----------------------------------------------------------------------------
	 CUtlCharConversion::CUtlCharConversion( char nEscapeChar, const char* pDelimiter, int nCount, ConversionArray_t* pArray ) {
		m_nEscapeChar = nEscapeChar;
		m_pDelimiter = pDelimiter;
		m_nCount = nCount;
		m_nDelimiterLength = strlen( pDelimiter );
		m_nMaxConversionLength = 0;

		memset( m_pReplacements, 0, sizeof( m_pReplacements ) );

		for( int i = 0; i < nCount; ++i ) {
		  m_pList[i] = pArray[i].m_nActualChar;
		  ConversionInfo_t& info = m_pReplacements[m_pList[i]];
		  assert( info.m_pReplacementString == 0 );
		  info.m_pReplacementString = pArray[i].m_pReplacementString;
		  info.m_nLength = strlen( info.m_pReplacementString );
		  if( info.m_nLength > m_nMaxConversionLength ) {
			 m_nMaxConversionLength = info.m_nLength;
		  }
		}
	 }

	 //-----------------------------------------------------------------------------
	 // Escape character + delimiter
	 //-----------------------------------------------------------------------------
	 char CUtlCharConversion::GetEscapeChar( ) const {
		return m_nEscapeChar;
	 }

	 const char* CUtlCharConversion::GetDelimiter( ) const {
		return m_pDelimiter;
	 }

	 int CUtlCharConversion::GetDelimiterLength( ) const {
		return m_nDelimiterLength;
	 }

	 //-----------------------------------------------------------------------------
	 // Constructor
	 //-----------------------------------------------------------------------------
	 const char* CUtlCharConversion::GetConversionString( char c ) const {
		return m_pReplacements[c].m_pReplacementString;
	 }

	 int CUtlCharConversion::GetConversionLength( char c ) const {
		return m_pReplacements[c].m_nLength;
	 }

	 int CUtlCharConversion::MaxConversionLength( ) const {
		return m_nMaxConversionLength;
	 }

	 //-----------------------------------------------------------------------------
	 // Finds a conversion for the passed-in string, returns length
	 //-----------------------------------------------------------------------------
	 char CUtlCharConversion::FindConversion( const char* pString, int* pLength ) {
		for( int i = 0; i < m_nCount; ++i ) {
		  if( !strcmp( pString, m_pReplacements[m_pList[i]].m_pReplacementString ) ) {
			 *pLength = m_pReplacements[m_pList[i]].m_nLength;
			 return m_pList[i];
		  }
		}

		*pLength = 0;
		return '\0';
	 }

	 //-----------------------------------------------------------------------------
	 // constructors
	 //-----------------------------------------------------------------------------
	 CUtlBuffer::CUtlBuffer( int growSize, int initSize, int nFlags ) :
		m_Memory( growSize, initSize ), m_Error( 0 ) {
		m_Get = 0;
		m_Put = 0;
		m_nTab = 0;
		m_nOffset = 0;
		m_Flags = ( unsigned char )nFlags;
		if( ( initSize != 0 ) && !IsReadOnly( ) ) {
		  m_nMaxPut = -1;
		  AddNullTermination( );
		} else {
		  m_nMaxPut = 0;
		}
		SetOverflowFuncs( &CUtlBuffer::GetOverflow, &CUtlBuffer::PutOverflow );
	 }

	 CUtlBuffer::CUtlBuffer( const void* pBuffer, int nSize, int nFlags ) :
		m_Memory( ( unsigned char* )pBuffer, nSize ), m_Error( 0 ) {
		assert( nSize != 0 );

		m_Get = 0;
		m_Put = 0;
		m_nTab = 0;
		m_nOffset = 0;
		m_Flags = ( unsigned char )nFlags;
		if( IsReadOnly( ) ) {
		  m_nMaxPut = nSize;
		} else {
		  m_nMaxPut = -1;
		  AddNullTermination( );
		}
		SetOverflowFuncs( &CUtlBuffer::GetOverflow, &CUtlBuffer::PutOverflow );
	 }

	 //-----------------------------------------------------------------------------
	 // Modifies the buffer to be binary or text; Blows away the buffer and the CONTAINS_CRLF value.
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::SetBufferType( bool bIsText, bool bContainsCRLF ) {
	 #ifdef _DEBUG
		// If the buffer is empty, there is no opportunity for this stuff to fail
		if( TellMaxPut( ) != 0 ) {
		  if( IsText( ) ) {
			 if( bIsText ) {
				assert( ContainsCRLF( ) == bContainsCRLF );
			 } else {
				assert( ContainsCRLF( ) );
			 }
		  } else {
			 if( bIsText ) {
				assert( bContainsCRLF );
			 }
		  }
		}
	 #endif

		if( bIsText ) {
		  m_Flags |= TEXT_BUFFER;
		} else {
		  m_Flags &= ~TEXT_BUFFER;
		}
		if( bContainsCRLF ) {
		  m_Flags |= CONTAINS_CRLF;
		} else {
		  m_Flags &= ~CONTAINS_CRLF;
		}
	 }

	 //-----------------------------------------------------------------------------
	 // Attaches the buffer to external memory....
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::SetExternalBuffer( void* pMemory, int nSize, int nInitialPut, int nFlags ) {
		m_Memory.SetExternalBuffer( ( unsigned char* )pMemory, nSize );

		// Reset all indices; we just changed memory
		m_Get = 0;
		m_Put = nInitialPut;
		m_nTab = 0;
		m_Error = 0;
		m_nOffset = 0;
		m_Flags = ( unsigned char )nFlags;
		m_nMaxPut = -1;
		AddNullTermination( );
	 }

	 //-----------------------------------------------------------------------------
	 // Assumes an external buffer but manages its deletion
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::AssumeMemory( void* pMemory, int nSize, int nInitialPut, int nFlags ) {
		m_Memory.AssumeMemory( ( unsigned char* )pMemory, nSize );

		// Reset all indices; we just changed memory
		m_Get = 0;
		m_Put = nInitialPut;
		m_nTab = 0;
		m_Error = 0;
		m_nOffset = 0;
		m_Flags = ( unsigned char )nFlags;
		m_nMaxPut = -1;
		AddNullTermination( );
	 }

	 //-----------------------------------------------------------------------------
	 // Makes sure we've got at least this much memory
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::EnsureCapacity( int num ) {
		// Add one extra for the null termination
		num += 1;
		if( m_Memory.IsExternallyAllocated( ) ) {
		  if( IsGrowable( ) && ( m_Memory.NumAllocated( ) < num ) ) {
			 m_Memory.ConvertToGrowableMemory( 0 );
		  } else {
			 num -= 1;
		  }
		}

		m_Memory.EnsureCapacity( num );
	 }

	 //-----------------------------------------------------------------------------
	 // Base Get method from which all others derive
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::Get( void* pMem, int size ) {
		if( CheckGet( size ) ) {
		  memcpy( pMem, &m_Memory[m_Get - m_nOffset], size );
		  m_Get += size;
		}
	 }

	 //-----------------------------------------------------------------------------
	 // This will Get at least 1 uint8_t and up to nSize bytes.
	 // It will return the number of bytes actually read.
	 //-----------------------------------------------------------------------------
	 int CUtlBuffer::GetUpTo( void* pMem, int nSize ) {
		if( CheckArbitraryPeekGet( 0, nSize ) ) {
		  memcpy( pMem, &m_Memory[m_Get - m_nOffset], nSize );
		  m_Get += nSize;
		  return nSize;
		}
		return 0;
	 }

	 //-----------------------------------------------------------------------------
	 // Eats whitespace
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::EatWhiteSpace( ) {
		if( IsText( ) && IsValid( ) ) {
		  while( CheckGet( sizeof( char ) ) ) {
			 if( !isspace( *( const unsigned char* )PeekGet( ) ) )
				break;
			 m_Get += sizeof( char );
		  }
		}
	 }

	 //-----------------------------------------------------------------------------
	 // Eats C++ style comments
	 //-----------------------------------------------------------------------------
	 bool CUtlBuffer::EatCPPComment( ) {
		if( IsText( ) && IsValid( ) ) {
		  // If we don't have a a c++ style comment next, we're done
		  const char* pPeek = ( const char* )PeekGet( 2 * sizeof( char ), 0 );
		  if( !pPeek || ( pPeek[0] != '/' ) || ( pPeek[1] != '/' ) )
			 return false;

		  // Deal with c++ style comments
		  m_Get += 2;

		  // read complete line
		  for( char c = GetChar( ); IsValid( ); c = GetChar( ) ) {
			 if( c == '\n' )
				break;
		  }
		  return true;
		}
		return false;
	 }

	 //-----------------------------------------------------------------------------
	 // Peeks how much whitespace to eat
	 //-----------------------------------------------------------------------------
	 int CUtlBuffer::PeekWhiteSpace( int nOffset ) {
		if( !IsText( ) || !IsValid( ) )
		  return 0;

		while( CheckPeekGet( nOffset, sizeof( char ) ) ) {
		  if( !isspace( *( unsigned char* )PeekGet( nOffset ) ) )
			 break;
		  nOffset += sizeof( char );
		}

		return nOffset;
	 }

	 //-----------------------------------------------------------------------------
	 // Peek size of sting to come, check memory bound
	 //-----------------------------------------------------------------------------
	 int CUtlBuffer::PeekStringLength( ) {
		if( !IsValid( ) )
		  return 0;

		// Eat preceeding whitespace
		int nOffset = 0;
		if( IsText( ) ) {
		  nOffset = PeekWhiteSpace( nOffset );
		}

		int nStartingOffset = nOffset;

		do {
		  int nPeekAmount = 128;

		  // NOTE: Add 1 for the terminating zero!
		  if( !CheckArbitraryPeekGet( nOffset, nPeekAmount ) ) {
			 if( nOffset == nStartingOffset )
				return 0;
			 return nOffset - nStartingOffset + 1;
		  }

		  const char* pTest = ( const char* )PeekGet( nOffset );

		  if( !IsText( ) ) {
			 for( int i = 0; i < nPeekAmount; ++i ) {
				// The +1 here is so we eat the terminating 0
				if( pTest[i] == 0 )
				  return ( i + nOffset - nStartingOffset + 1 );
			 }
		  } else {
			 for( int i = 0; i < nPeekAmount; ++i ) {
				// The +1 here is so we eat the terminating 0
				if( isspace( ( unsigned char )pTest[i] ) || ( pTest[i] == 0 ) )
				  return ( i + nOffset - nStartingOffset + 1 );
			 }
		  }

		  nOffset += nPeekAmount;

		} while( true );
	 }

	 //-----------------------------------------------------------------------------
	 // Peek size of line to come, check memory bound
	 //-----------------------------------------------------------------------------
	 int CUtlBuffer::PeekLineLength( ) {
		if( !IsValid( ) )
		  return 0;

		int nOffset = 0;
		int nStartingOffset = nOffset;

		do {
		  int nPeekAmount = 128;

		  // NOTE: Add 1 for the terminating zero!
		  if( !CheckArbitraryPeekGet( nOffset, nPeekAmount ) ) {
			 if( nOffset == nStartingOffset )
				return 0;
			 return nOffset - nStartingOffset + 1;
		  }

		  const char* pTest = ( const char* )PeekGet( nOffset );

		  for( int i = 0; i < nPeekAmount; ++i ) {
			 // The +2 here is so we eat the terminating '\n' and 0
			 if( pTest[i] == '\n' || pTest[i] == '\r' )
				return ( i + nOffset - nStartingOffset + 2 );
			 // The +1 here is so we eat the terminating 0
			 if( pTest[i] == 0 )
				return ( i + nOffset - nStartingOffset + 1 );
		  }

		  nOffset += nPeekAmount;

		} while( true );
	 }

	 //-----------------------------------------------------------------------------
	 // Does the next bytes of the buffer match a pattern?
	 //-----------------------------------------------------------------------------
	 bool CUtlBuffer::PeekStringMatch( int nOffset, const char* pString, int nLen ) {
		if( !CheckPeekGet( nOffset, nLen ) )
		  return false;
		return !strncmp( ( const char* )PeekGet( nOffset ), pString, nLen );
	 }

	 //-----------------------------------------------------------------------------
	 // This version of PeekStringLength converts \" to \\ and " to \, etc.
	 // It also reads a " at the beginning and end of the string
	 //-----------------------------------------------------------------------------
	 int CUtlBuffer::PeekDelimitedStringLength( CUtlCharConversion* pConv, bool bActualSize ) {
		if( !IsText( ) || !pConv )
		  return PeekStringLength( );

		// Eat preceeding whitespace
		int nOffset = 0;
		if( IsText( ) ) {
		  nOffset = PeekWhiteSpace( nOffset );
		}

		if( !PeekStringMatch( nOffset, pConv->GetDelimiter( ), pConv->GetDelimiterLength( ) ) )
		  return 0;

		// Try to read ending ", but don't accept \"
		int nActualStart = nOffset;
		nOffset += pConv->GetDelimiterLength( );
		int nLen = 1; // Starts at 1 for the '\0' termination

		do {
		  if( PeekStringMatch( nOffset, pConv->GetDelimiter( ), pConv->GetDelimiterLength( ) ) )
			 break;

		  if( !CheckPeekGet( nOffset, 1 ) )
			 break;

		  char c = *( const char* )PeekGet( nOffset );
		  ++nLen;
		  ++nOffset;
		  if( c == pConv->GetEscapeChar( ) ) {
			 int nLength = pConv->MaxConversionLength( );
			 if( !CheckArbitraryPeekGet( nOffset, nLength ) )
				break;

			 pConv->FindConversion( ( const char* )PeekGet( nOffset ), &nLength );
			 nOffset += nLength;
		  }
		} while( true );

		return bActualSize ? nLen : nOffset - nActualStart + pConv->GetDelimiterLength( ) + 1;
	 }

	 //-----------------------------------------------------------------------------
	 // Reads a null-terminated string
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::GetString( char* pString, int nMaxChars ) {
		if( !IsValid( ) ) {
		  *pString = 0;
		  return;
		}

		if( nMaxChars == 0 ) {
		  nMaxChars = INT_MAX;
		}

		// Remember, this *includes* the null character
		// It will be 0, however, if the buffer is empty.
		int nLen = PeekStringLength( );

		if( IsText( ) ) {
		  EatWhiteSpace( );
		}

		if( nLen == 0 ) {
		  *pString = 0;
		  m_Error |= GET_OVERFLOW;
		  return;
		}

		// Strip off the terminating NULL
		if( nLen <= nMaxChars ) {
		  Get( pString, nLen - 1 );
		  pString[nLen - 1] = 0;
		} else {
		  Get( pString, nMaxChars - 1 );
		  pString[nMaxChars - 1] = 0;
		  SeekGet( SEEK_CURRENT, nLen - 1 - nMaxChars );
		}

		// Read the terminating NULL in binary formats
		if( !IsText( ) ) {
		  assert( GetChar( ) == 0 );
		}
	 }

	 //-----------------------------------------------------------------------------
	 // Reads up to and including the first \n
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::GetLine( char* pLine, int nMaxChars ) {
		assert( IsText( ) && !ContainsCRLF( ) );

		if( !IsValid( ) ) {
		  *pLine = 0;
		  return;
		}

		if( nMaxChars == 0 ) {
		  nMaxChars = INT_MAX;
		}

		// Remember, this *includes* the null character
		// It will be 0, however, if the buffer is empty.
		int nLen = PeekLineLength( );
		if( nLen == 0 ) {
		  *pLine = 0;
		  m_Error |= GET_OVERFLOW;
		  return;
		}

		// Strip off the terminating NULL
		if( nLen <= nMaxChars ) {
		  Get( pLine, nLen - 1 );
		  pLine[nLen - 1] = 0;
		} else {
		  Get( pLine, nMaxChars - 1 );
		  pLine[nMaxChars - 1] = 0;
		  SeekGet( SEEK_CURRENT, nLen - 1 - nMaxChars );
		}
	 }

	 //-----------------------------------------------------------------------------
	 // This version of GetString converts \ to \\ and " to \", etc.
	 // It also places " at the beginning and end of the string
	 //-----------------------------------------------------------------------------
	 char CUtlBuffer::GetDelimitedCharInternal( CUtlCharConversion* pConv ) {
		char c = GetChar( );
		if( c == pConv->GetEscapeChar( ) ) {
		  int nLength = pConv->MaxConversionLength( );
		  if( !CheckArbitraryPeekGet( 0, nLength ) )
			 return '\0';

		  c = pConv->FindConversion( ( const char* )PeekGet( ), &nLength );
		  SeekGet( SEEK_CURRENT, nLength );
		}

		return c;
	 }

	 char CUtlBuffer::GetDelimitedChar( CUtlCharConversion* pConv ) {
		if( !IsText( ) || !pConv )
		  return GetChar( );
		return GetDelimitedCharInternal( pConv );
	 }

	 void CUtlBuffer::GetDelimitedString( CUtlCharConversion* pConv, char* pString, int nMaxChars ) {
		if( !IsText( ) || !pConv ) {
		  GetString( pString, nMaxChars );
		  return;
		}

		if( !IsValid( ) ) {
		  *pString = 0;
		  return;
		}

		if( nMaxChars == 0 ) {
		  nMaxChars = INT_MAX;
		}

		EatWhiteSpace( );
		if( !PeekStringMatch( 0, pConv->GetDelimiter( ), pConv->GetDelimiterLength( ) ) )
		  return;

		// Pull off the starting delimiter
		SeekGet( SEEK_CURRENT, pConv->GetDelimiterLength( ) );

		int nRead = 0;
		while( IsValid( ) ) {
		  if( PeekStringMatch( 0, pConv->GetDelimiter( ), pConv->GetDelimiterLength( ) ) ) {
			 SeekGet( SEEK_CURRENT, pConv->GetDelimiterLength( ) );
			 break;
		  }

		  char c = GetDelimitedCharInternal( pConv );

		  if( nRead < nMaxChars ) {
			 pString[nRead] = c;
			 ++nRead;
		  }
		}

		if( nRead >= nMaxChars ) {
		  nRead = nMaxChars - 1;
		}
		pString[nRead] = '\0';
	 }

	 //-----------------------------------------------------------------------------
	 // Checks if a Get is ok
	 //-----------------------------------------------------------------------------
	 bool CUtlBuffer::CheckGet( int nSize ) {
		if( m_Error & GET_OVERFLOW )
		  return false;

		if( TellMaxPut( ) < m_Get + nSize ) {
		  m_Error |= GET_OVERFLOW;
		  return false;
		}

		if( ( m_Get < m_nOffset ) || ( m_Memory.NumAllocated( ) < m_Get - m_nOffset + nSize ) ) {
		  if( !OnGetOverflow( nSize ) ) {
			 m_Error |= GET_OVERFLOW;
			 return false;
		  }
		}

		return true;
	 }

	 //-----------------------------------------------------------------------------
	 // Checks if a peek Get is ok
	 //-----------------------------------------------------------------------------
	 bool CUtlBuffer::CheckPeekGet( int nOffset, int nSize ) {
		if( m_Error & GET_OVERFLOW )
		  return false;

		// Checking for peek can't Set the overflow flag
		bool bOk = CheckGet( nOffset + nSize );
		m_Error &= ~GET_OVERFLOW;
		return bOk;
	 }

	 //-----------------------------------------------------------------------------
	 // Call this to peek arbitrarily long into memory. It doesn't fail unless
	 // it can't read *anything* new
	 //-----------------------------------------------------------------------------
	 bool CUtlBuffer::CheckArbitraryPeekGet( int nOffset, int& nIncrement ) {
		if( TellGet( ) + nOffset >= TellMaxPut( ) ) {
		  nIncrement = 0;
		  return false;
		}

		if( TellGet( ) + nOffset + nIncrement > TellMaxPut( ) ) {
		  nIncrement = TellMaxPut( ) - TellGet( ) - nOffset;
		}

		// NOTE: CheckPeekGet could modify TellMaxPut for streaming files
		// We have to call TellMaxPut again here
		CheckPeekGet( nOffset, nIncrement );
		int nMaxGet = TellMaxPut( ) - TellGet( );
		if( nMaxGet < nIncrement ) {
		  nIncrement = nMaxGet;
		}
		return ( nIncrement != 0 );
	 }

	 //-----------------------------------------------------------------------------
	 // Peek part of the butt
	 //-----------------------------------------------------------------------------
	 const void* CUtlBuffer::PeekGet( int nMaxSize, int nOffset ) {
		if( !CheckPeekGet( nOffset, nMaxSize ) )
		  return NULL;
		return &m_Memory[m_Get + nOffset - m_nOffset];
	 }

	 //-----------------------------------------------------------------------------
	 // Change where I'm reading
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::SeekGet( SeekType_t type, int offset ) {
		switch( type ) {
		case SEEK_HEAD:
		  m_Get = offset;
		  break;

		case SEEK_CURRENT:
		  m_Get += offset;
		  break;

		case SEEK_TAIL:
		  m_Get = m_nMaxPut - offset;
		  break;
		}

		if( m_Get > m_nMaxPut ) {
		  m_Error |= GET_OVERFLOW;
		} else {
		  m_Error &= ~GET_OVERFLOW;
		  if( m_Get < m_nOffset || m_Get >= m_nOffset + Size( ) ) {
			 OnGetOverflow( -1 );
		  }
		}
	 }

	 //-----------------------------------------------------------------------------
	 // Parse...
	 //-----------------------------------------------------------------------------

  #pragma warning( disable : 4706 )

	 int CUtlBuffer::VaScanf( const char* pFmt, va_list list ) {
		assert( pFmt );
		if( m_Error || !IsText( ) )
		  return 0;

		int numScanned = 0;
		int nLength;
		char c;
		char* pEnd;
		while( c = *pFmt++ ) {
		  // Stop if we hit the end of the buffer
		  if( m_Get >= TellMaxPut( ) ) {
			 m_Error |= GET_OVERFLOW;
			 break;
		  }

		  switch( c ) {
		  case ' ':
			 // eat all whitespace
			 EatWhiteSpace( );
			 break;

		  case '%': {
			 // Conversion character... try to convert baby!
			 char type = *pFmt++;
			 if( type == 0 )
				return numScanned;

			 switch( type ) {
			 case 'c': {
				char* ch = va_arg( list, char* );
				if( CheckPeekGet( 0, sizeof( char ) ) ) {
				  *ch = *( const char* )PeekGet( );
				  ++m_Get;
				} else {
				  *ch = 0;
				  return numScanned;
				}
			 } break;

			 case 'i':
			 case 'd': {
				int* i = va_arg( list, int* );

				// NOTE: This is not bullet-proof; it assumes numbers are < 128 characters
				nLength = 128;
				if( !CheckArbitraryPeekGet( 0, nLength ) ) {
				  *i = 0;
				  return numScanned;
				}

				*i = strtol( ( char* )PeekGet( ), &pEnd, 10 );
				int nBytesRead = ( int )( pEnd - ( char* )PeekGet( ) );
				if( nBytesRead == 0 )
				  return numScanned;
				m_Get += nBytesRead;
			 } break;

			 case 'x': {
				int* i = va_arg( list, int* );

				// NOTE: This is not bullet-proof; it assumes numbers are < 128 characters
				nLength = 128;
				if( !CheckArbitraryPeekGet( 0, nLength ) ) {
				  *i = 0;
				  return numScanned;
				}

				*i = strtol( ( char* )PeekGet( ), &pEnd, 16 );
				int nBytesRead = ( int )( pEnd - ( char* )PeekGet( ) );
				if( nBytesRead == 0 )
				  return numScanned;
				m_Get += nBytesRead;
			 } break;

			 case 'u': {
				unsigned int* u = va_arg( list, unsigned int* );

				// NOTE: This is not bullet-proof; it assumes numbers are < 128 characters
				nLength = 128;
				if( !CheckArbitraryPeekGet( 0, nLength ) ) {
				  *u = 0;
				  return numScanned;
				}

				*u = strtoul( ( char* )PeekGet( ), &pEnd, 10 );
				int nBytesRead = ( int )( pEnd - ( char* )PeekGet( ) );
				if( nBytesRead == 0 )
				  return numScanned;
				m_Get += nBytesRead;
			 } break;

			 case 'f': {
				float* f = va_arg( list, float* );

				// NOTE: This is not bullet-proof; it assumes numbers are < 128 characters
				nLength = 128;
				if( !CheckArbitraryPeekGet( 0, nLength ) ) {
				  *f = 0.0f;
				  return numScanned;
				}

				*f = ( float )strtod( ( char* )PeekGet( ), &pEnd );
				int nBytesRead = ( int )( pEnd - ( char* )PeekGet( ) );
				if( nBytesRead == 0 )
				  return numScanned;
				m_Get += nBytesRead;
			 } break;

			 case 's': {
				char* s = va_arg( list, char* );
				GetString( s );
			 } break;

			 default: {
				// unimplemented scanf type
				assert( 0 );
				return numScanned;
			 } break;
			 }

			 ++numScanned;
		  } break;

		  default: {
			 // Here we have to match the format string character
			 // against what's in the buffer or we're done.
			 if( !CheckPeekGet( 0, sizeof( char ) ) )
				return numScanned;

			 if( c != *( const char* )PeekGet( ) )
				return numScanned;

			 ++m_Get;
		  }
		  }
		}
		return numScanned;
	 }

  #pragma warning( default : 4706 )

	 int CUtlBuffer::Scanf( const char* pFmt, ... ) {
		va_list args;

		va_start( args, pFmt );
		int count = VaScanf( pFmt, args );
		va_end( args );

		return count;
	 }

	 //-----------------------------------------------------------------------------
	 // Advance the Get index until after the particular string is found
	 // Do not eat whitespace before starting. Return false if it failed
	 //-----------------------------------------------------------------------------
	 bool CUtlBuffer::GetToken( const char* pToken ) {
		assert( pToken );

		// Look for the token
		int nLen = strlen( pToken );

		int nSizeToCheck = Size( ) - TellGet( ) - m_nOffset;

		int nGet = TellGet( );
		do {
		  int nMaxSize = TellMaxPut( ) - TellGet( );
		  if( nMaxSize < nSizeToCheck ) {
			 nSizeToCheck = nMaxSize;
		  }
		  if( nLen > nSizeToCheck )
			 break;

		  if( !CheckPeekGet( 0, nSizeToCheck ) )
			 break;

		  const char* pBufStart = ( const char* )PeekGet( );
		  const char* pFoundEnd = V_strnistr( pBufStart, pToken, nSizeToCheck );
		  if( pFoundEnd ) {
			 size_t nOffset = ( size_t )pFoundEnd - ( size_t )pBufStart;
			 SeekGet( CUtlBuffer::SEEK_CURRENT, nOffset + nLen );
			 return true;
		  }

		  SeekGet( CUtlBuffer::SEEK_CURRENT, nSizeToCheck - nLen - 1 );
		  nSizeToCheck = Size( ) - ( nLen - 1 );

		} while( true );

		SeekGet( CUtlBuffer::SEEK_HEAD, nGet );
		return false;
	 }

	 //-----------------------------------------------------------------------------
	 // (For text buffers only)
	 // Parse a token from the buffer:
	 // Grab all text that lies between a starting delimiter + ending delimiter
	 // (skipping whitespace that leads + trails both delimiters).
	 // Note the delimiter checks are case-insensitive.
	 // If successful, the Get index is advanced and the function returns true,
	 // otherwise the index is not advanced and the function returns false.
	 //-----------------------------------------------------------------------------
	 bool CUtlBuffer::ParseToken( const char* pStartingDelim, const char* pEndingDelim, char* pString, int nMaxLen ) {
		int nCharsToCopy = 0;
		int nCurrentGet = 0;

		size_t nEndingDelimLen;

		// Starting delimiter is optional
		char emptyBuf = '\0';
		if( !pStartingDelim ) {
		  pStartingDelim = &emptyBuf;
		}

		// Ending delimiter is not
		assert( pEndingDelim && pEndingDelim[0] );
		nEndingDelimLen = strlen( pEndingDelim );

		int nStartGet = TellGet( );
		char nCurrChar;
		int nTokenStart = -1;
		EatWhiteSpace( );
		while( *pStartingDelim ) {
		  nCurrChar = *pStartingDelim++;
		  if( !isspace( ( unsigned char )nCurrChar ) ) {
			 if( tolower( GetChar( ) ) != tolower( nCurrChar ) )
				goto parseFailed;
		  } else {
			 EatWhiteSpace( );
		  }
		}

		EatWhiteSpace( );
		nTokenStart = TellGet( );
		if( !GetToken( pEndingDelim ) )
		  goto parseFailed;

		nCurrentGet = TellGet( );
		nCharsToCopy = ( nCurrentGet - nEndingDelimLen ) - nTokenStart;
		if( nCharsToCopy >= nMaxLen ) {
		  nCharsToCopy = nMaxLen - 1;
		}

		if( nCharsToCopy > 0 ) {
		  SeekGet( CUtlBuffer::SEEK_HEAD, nTokenStart );
		  Get( pString, nCharsToCopy );
		  if( !IsValid( ) )
			 goto parseFailed;

		  // Eat trailing whitespace
		  for( ; nCharsToCopy > 0; --nCharsToCopy ) {
			 if( !isspace( ( unsigned char )pString[nCharsToCopy - 1] ) )
				break;
		  }
		}
		pString[nCharsToCopy] = '\0';

		// Advance the Get index
		SeekGet( CUtlBuffer::SEEK_HEAD, nCurrentGet );
		return true;

	 parseFailed:
		// Revert the Get index
		SeekGet( SEEK_HEAD, nStartGet );
		pString[0] = '\0';
		return false;
	 }

	 //-----------------------------------------------------------------------------
	 // Parses the next token, given a Set of character breaks to stop at
	 //-----------------------------------------------------------------------------
	 int CUtlBuffer::ParseToken( characterset_t* pBreaks, char* pTokenBuf, int nMaxLen, bool bParseComments ) {
		assert( nMaxLen > 0 );
		pTokenBuf[0] = 0;

		// skip whitespace + comments
		while( true ) {
		  if( !IsValid( ) )
			 return -1;
		  EatWhiteSpace( );
		  if( bParseComments ) {
			 if( !EatCPPComment( ) )
				break;
		  } else {
			 break;
		  }
		}

		char c = GetChar( );

		// End of buffer
		if( c == 0 )
		  return -1;

		// handle quoted strings specially
		if( c == '\"' ) {
		  int nLen = 0;
		  while( IsValid( ) ) {
			 c = GetChar( );
			 if( c == '\"' || !c ) {
				pTokenBuf[nLen] = 0;
				return nLen;
			 }
			 pTokenBuf[nLen] = c;
			 if( ++nLen == nMaxLen ) {
				pTokenBuf[nLen - 1] = 0;
				return nMaxLen;
			 }
		  }

		  // In this case, we hit the end of the buffer before hitting the end qoute
		  pTokenBuf[nLen] = 0;
		  return nLen;
		}

		// parse single characters
		if( IN_CHARACTERSET( *pBreaks, c ) ) {
		  pTokenBuf[0] = c;
		  pTokenBuf[1] = 0;
		  return 1;
		}

		// parse a regular word
		int nLen = 0;
		while( true ) {
		  pTokenBuf[nLen] = c;
		  if( ++nLen == nMaxLen ) {
			 pTokenBuf[nLen - 1] = 0;
			 return nMaxLen;
		  }
		  c = GetChar( );
		  if( !IsValid( ) )
			 break;

		  if( IN_CHARACTERSET( *pBreaks, c ) || c == '\"' || c <= ' ' ) {
			 SeekGet( SEEK_CURRENT, -1 );
			 break;
		  }
		}

		pTokenBuf[nLen] = 0;
		return nLen;
	 }

	 //-----------------------------------------------------------------------------
	 // Serialization
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::Put( const void* pMem, int size ) {
		if( size && CheckPut( size ) ) {
		  memcpy( &m_Memory[m_Put - m_nOffset], pMem, size );
		  m_Put += size;

		  AddNullTermination( );
		}
	 }

	 //-----------------------------------------------------------------------------
	 // Writes a null-terminated string
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::PutString( const char* pString ) {
		if( !IsText( ) ) {
		  if( pString ) {
			 // Not text? append a null at the end.
			 size_t nLen = strlen( pString ) + 1;
			 Put( pString, nLen * sizeof( char ) );
			 return;
		  } else {
			 PutTypeBin< char >( 0 );
		  }
		} else if( pString ) {
		  int nTabCount = ( m_Flags & AUTO_TABS_DISABLED ) ? 0 : m_nTab;
		  if( nTabCount > 0 ) {
			 if( WasLastCharacterCR( ) ) {
				PutTabs( );
			 }

			 const char* pEndl = strchr( pString, '\n' );
			 while( pEndl ) {
				size_t nSize = ( size_t )pEndl - ( size_t )pString + sizeof( char );
				Put( pString, nSize );
				pString = pEndl + 1;
				if( *pString ) {
				  PutTabs( );
				  pEndl = strchr( pString, '\n' );
				} else {
				  pEndl = NULL;
				}
			 }
		  }
		  size_t nLen = strlen( pString );
		  if( nLen ) {
			 Put( pString, nLen * sizeof( char ) );
		  }
		}
	 }

	 //-----------------------------------------------------------------------------
	 // This version of PutString converts \ to \\ and " to \", etc.
	 // It also places " at the beginning and end of the string
	 //-----------------------------------------------------------------------------
	 inline void CUtlBuffer::PutDelimitedCharInternal( CUtlCharConversion* pConv, char c ) {
		int l = pConv->GetConversionLength( c );
		if( l == 0 ) {
		  PutChar( c );
		} else {
		  PutChar( pConv->GetEscapeChar( ) );
		  Put( pConv->GetConversionString( c ), l );
		}
	 }

	 void CUtlBuffer::PutDelimitedChar( CUtlCharConversion* pConv, char c ) {
		if( !IsText( ) || !pConv ) {
		  PutChar( c );
		  return;
		}

		PutDelimitedCharInternal( pConv, c );
	 }

	 void CUtlBuffer::PutDelimitedString( CUtlCharConversion* pConv, const char* pString ) {
		if( !IsText( ) || !pConv ) {
		  PutString( pString );
		  return;
		}

		if( WasLastCharacterCR( ) ) {
		  PutTabs( );
		}
		Put( pConv->GetDelimiter( ), pConv->GetDelimiterLength( ) );

		int nLen = pString ? strlen( pString ) : 0;
		for( int i = 0; i < nLen; ++i ) {
		  PutDelimitedCharInternal( pConv, pString[i] );
		}

		if( WasLastCharacterCR( ) ) {
		  PutTabs( );
		}
		Put( pConv->GetDelimiter( ), pConv->GetDelimiterLength( ) );
	 }

	 void CUtlBuffer::VaPrintf( const char* pFmt, va_list list ) {
		char temp[2048];
		int nLen = vsnprintf( temp, sizeof( temp ), pFmt, list );
		assert( nLen < 2048 );
		PutString( temp );
	 }

	 void CUtlBuffer::Printf( const char* pFmt, ... ) {
		va_list args;

		va_start( args, pFmt );
		VaPrintf( pFmt, args );
		va_end( args );
	 }

	 //-----------------------------------------------------------------------------
	 // Calls the overflow functions
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::SetOverflowFuncs( UtlBufferOverflowFunc_t getFunc, UtlBufferOverflowFunc_t putFunc ) {
		m_GetOverflowFunc = getFunc;
		m_PutOverflowFunc = putFunc;
	 }

	 //-----------------------------------------------------------------------------
	 // Calls the overflow functions
	 //-----------------------------------------------------------------------------
	 bool CUtlBuffer::OnPutOverflow( int nSize ) {
		return ( this->*m_PutOverflowFunc )( nSize );
	 }

	 bool CUtlBuffer::OnGetOverflow( int nSize ) {
		return ( this->*m_GetOverflowFunc )( nSize );
	 }

	 //-----------------------------------------------------------------------------
	 // Checks if a put is ok
	 //-----------------------------------------------------------------------------
	 bool CUtlBuffer::PutOverflow( int nSize ) {
		if( m_Memory.IsExternallyAllocated( ) ) {
		  if( !IsGrowable( ) )
			 return false;

		  m_Memory.ConvertToGrowableMemory( 0 );
		}

		while( Size( ) < m_Put - m_nOffset + nSize ) {
		  m_Memory.Grow( );
		}

		return true;
	 }

	 bool CUtlBuffer::GetOverflow( int nSize ) {
		return false;
	 }

	 //-----------------------------------------------------------------------------
	 // Checks if a put is ok
	 //-----------------------------------------------------------------------------
	 bool CUtlBuffer::CheckPut( int nSize ) {
		if( ( m_Error & PUT_OVERFLOW ) || IsReadOnly( ) )
		  return false;

		if( ( m_Put < m_nOffset ) || ( m_Memory.NumAllocated( ) < m_Put - m_nOffset + nSize ) ) {
		  if( !OnPutOverflow( nSize ) ) {
			 m_Error |= PUT_OVERFLOW;
			 return false;
		  }
		}
		return true;
	 }

	 void CUtlBuffer::SeekPut( SeekType_t type, int offset ) {
		int nNextPut = m_Put;
		switch( type ) {
		case SEEK_HEAD:
		  nNextPut = offset;
		  break;

		case SEEK_CURRENT:
		  nNextPut += offset;
		  break;

		case SEEK_TAIL:
		  nNextPut = m_nMaxPut - offset;
		  break;
		}

		// Force a write of the data
		// FIXME: We could make this more optimal potentially by writing out
		// the entire buffer if you seek outside the current range

		// NOTE: This call will write and will also seek the file to nNextPut.
		OnPutOverflow( -nNextPut - 1 );
		m_Put = nNextPut;

		AddNullTermination( );
	 }

	 void CUtlBuffer::ActivateByteSwapping( bool bActivate ) {
		m_Byteswap.ActivateByteSwapping( bActivate );
	 }

	 void CUtlBuffer::SetBigEndian( bool bigEndian ) {
		m_Byteswap.SetTargetBigEndian( bigEndian );
	 }

	 bool CUtlBuffer::IsBigEndian( void ) {
		return m_Byteswap.IsTargetBigEndian( );
	 }

	 //-----------------------------------------------------------------------------
	 // null terminate the buffer
	 //-----------------------------------------------------------------------------
	 void CUtlBuffer::AddNullTermination( void ) {
		if( m_Put > m_nMaxPut ) {
		  if( !IsReadOnly( ) && ( ( m_Error & PUT_OVERFLOW ) == 0 ) ) {
			 // Add null termination value
			 if( CheckPut( 1 ) ) {
				m_Memory[m_Put - m_nOffset] = 0;
			 } else {
				// Restore the overflow state, it was valid before...
				m_Error &= ~PUT_OVERFLOW;
			 }
		  }
		  m_nMaxPut = m_Put;
		}
	 }

	 //-----------------------------------------------------------------------------
	 // Converts a buffer from a CRLF buffer to a CR buffer (and back)
	 // Returns false if no conversion was necessary (and outBuf is left untouched)
	 // If the conversion occurs, outBuf will be cleared.
	 //-----------------------------------------------------------------------------
	 bool CUtlBuffer::ConvertCRLF( CUtlBuffer& outBuf ) {
		if( !IsText( ) || !outBuf.IsText( ) )
		  return false;

		if( ContainsCRLF( ) == outBuf.ContainsCRLF( ) )
		  return false;

		int nInCount = TellMaxPut( );

		outBuf.Purge( );
		outBuf.EnsureCapacity( nInCount );

		bool bFromCRLF = ContainsCRLF( );

		// Start reading from the beginning
		int nGet = TellGet( );
		int nPut = TellPut( );
		int nGetDelta = 0;
		int nPutDelta = 0;

		const char* pBase = ( const char* )Base( );
		int nCurrGet = 0;
		while( nCurrGet < nInCount ) {
		  const char* pCurr = &pBase[nCurrGet];
		  if( bFromCRLF ) {
			 const char* pNext = V_strnistr( pCurr, "\r\n", nInCount - nCurrGet );
			 if( !pNext ) {
				outBuf.Put( pCurr, nInCount - nCurrGet );
				break;
			 }

			 int nBytes = ( size_t )pNext - ( size_t )pCurr;
			 outBuf.Put( pCurr, nBytes );
			 outBuf.PutChar( '\n' );
			 nCurrGet += nBytes + 2;
			 if( nGet >= nCurrGet - 1 ) {
				--nGetDelta;
			 }
			 if( nPut >= nCurrGet - 1 ) {
				--nPutDelta;
			 }
		  } else {
			 const char* pNext = V_strnchr( pCurr, '\n', nInCount - nCurrGet );
			 if( !pNext ) {
				outBuf.Put( pCurr, nInCount - nCurrGet );
				break;
			 }

			 int nBytes = ( size_t )pNext - ( size_t )pCurr;
			 outBuf.Put( pCurr, nBytes );
			 outBuf.PutChar( '\r' );
			 outBuf.PutChar( '\n' );
			 nCurrGet += nBytes + 1;
			 if( nGet >= nCurrGet ) {
				++nGetDelta;
			 }
			 if( nPut >= nCurrGet ) {
				++nPutDelta;
			 }
		  }
		}

		assert( nPut + nPutDelta <= outBuf.TellMaxPut( ) );

		outBuf.SeekGet( SEEK_HEAD, nGet + nGetDelta );
		outBuf.SeekPut( SEEK_HEAD, nPut + nPutDelta );

		return true;
	 }

	 //---------------------------------------------------------------------------
	 // Implementation of CUtlInplaceBuffer
	 //---------------------------------------------------------------------------

	 CUtlInplaceBuffer::CUtlInplaceBuffer( int growSize /* = 0 */, int initSize /* = 0 */, int nFlags /* = 0 */ ) :
		CUtlBuffer( growSize, initSize, nFlags ) {
		NULL;
	 }

	 bool CUtlInplaceBuffer::InplaceGetLinePtr( char** ppszInBufferPtr, int* pnLineLength ) {
		assert( IsText( ) && !ContainsCRLF( ) );

		int nLineLen = PeekLineLength( );
		if( nLineLen <= 1 ) {
		  SeekGet( SEEK_TAIL, 0 );
		  return false;
		}

		--nLineLen; // because it accounts for putting a terminating null-character

		char* pszLine = ( char* )const_cast< void* >( PeekGet( ) );
		SeekGet( SEEK_CURRENT, nLineLen );

		// Set the out args
		if( ppszInBufferPtr )
		  *ppszInBufferPtr = pszLine;

		if( pnLineLength )
		  *pnLineLength = nLineLen;

		return true;
	 }

	 char* CUtlInplaceBuffer::InplaceGetLinePtr( void ) {
		char* pszLine = NULL;
		int nLineLen = 0;

		if( InplaceGetLinePtr( &pszLine, &nLineLen ) ) {
		  assert( nLineLen >= 1 );

		  switch( pszLine[nLineLen - 1] ) {
		  case '\n':
		  case '\r':
			 pszLine[nLineLen - 1] = 0;
			 if( --nLineLen ) {
				switch( pszLine[nLineLen - 1] ) {
				case '\n':
				case '\r':
				  pszLine[nLineLen - 1] = 0;
				  break;
				}
			 }
			 break;

		  default:
			 assert( pszLine[nLineLen] == 0 );
			 break;
		  }
		}
		return pszLine;
	 }


```

`CSGO SDK/SDK/Valve/UtlBuffer.hpp`:

```hpp
//====== Copyright © 1996-2005, Valve Corporation, All rights reserved. =======//
//
// Purpose: 
//
// $NoKeywords: $
//
// Serialization/unserialization buffer
//=============================================================================//
#pragma once

#include <stdarg.h>
#include "Vector.hpp"
#include "Vector2D.hpp"
#include "UtlMemory.hpp"

#pragma warning(disable:4127) //conditional operation is constant
#define IsX360() (0)

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
struct characterset_t;
struct typedescription_t;
struct datamap_t;

class CByteswap
{
public:
  CByteswap( ) {
	 // Default behavior sets the target endian to match the machine native endian (no swap).
	 SetTargetBigEndian( IsMachineBigEndian( ) );
  }

  //-----------------------------------------------------------------------------
  // Write a single field.
  //-----------------------------------------------------------------------------
  void SwapFieldToTargetEndian( void* pOutputBuffer, void *pData, typedescription_t *pField );

  //-----------------------------------------------------------------------------
  // Write a block of fields.  Works a bit like the saverestore code.  
  //-----------------------------------------------------------------------------
  void SwapFieldsToTargetEndian( void *pOutputBuffer, void *pBaseData, datamap_t *pDataMap );

  // Swaps fields for the templated type to the output buffer.
  template<typename T> inline void SwapFieldsToTargetEndian( T* pOutputBuffer, void *pBaseData, unsigned int objectCount = 1 ) {
	 for( unsigned int i = 0; i < objectCount; ++i, ++pOutputBuffer ) {
		SwapFieldsToTargetEndian( ( void* )pOutputBuffer, pBaseData, &T::m_DataMap );
		pBaseData = ( uint8_t* )pBaseData + sizeof( T );
	 }
  }

  // Swaps fields for the templated type in place.
  template<typename T> inline void SwapFieldsToTargetEndian( T* pOutputBuffer, unsigned int objectCount = 1 ) {
	 SwapFieldsToTargetEndian<T>( pOutputBuffer, ( void* )pOutputBuffer, objectCount );
  }

  //-----------------------------------------------------------------------------
  // True if the current machine is detected as big endian. 
  // (Endienness is effectively detected at compile time when optimizations are
  // enabled)
  //-----------------------------------------------------------------------------
  static bool IsMachineBigEndian( ) {
	 short nIsBigEndian = 1;

	 // if we are big endian, the first uint8_t will be a 0, if little endian, it will be a one.
	 return ( bool )( 0 == *( char * )&nIsBigEndian );
  }

  //-----------------------------------------------------------------------------
  // Sets the target uint8_t ordering we are swapping to or from.
  //
  // Braindead Endian Reference:
  //		x86 is LITTLE Endian
  //		PowerPC is BIG Endian
  //-----------------------------------------------------------------------------
  inline void SetTargetBigEndian( bool bigEndian ) {
	 m_bBigEndian = bigEndian;
	 m_bSwapBytes = IsMachineBigEndian( ) != bigEndian;
  }

  // Changes target endian
  inline void FlipTargetEndian( void ) {
	 m_bSwapBytes = !m_bSwapBytes;
	 m_bBigEndian = !m_bBigEndian;
  }

  // Forces uint8_t swapping state, regardless of endianess
  inline void ActivateByteSwapping( bool bActivate ) {
	 SetTargetBigEndian( IsMachineBigEndian( ) != bActivate );
  }

  //-----------------------------------------------------------------------------
  // Returns true if the target machine is the same as this one in endianness.
  //
  // Used to determine when a byteswap needs to take place.
  //-----------------------------------------------------------------------------
  inline bool IsSwappingBytes( void )	// Are bytes being swapped?
  {
	 return m_bSwapBytes;
  }

  inline bool IsTargetBigEndian( void )	// What is the current target endian?
  {
	 return m_bBigEndian;
  }

  //-----------------------------------------------------------------------------
  // IsByteSwapped()
  //
  // When supplied with a chunk of input data and a constant or magic number
  // (in native format) determines the endienness of the current machine in
  // relation to the given input data.
  //
  // Returns:
  //		1  if input is the same as nativeConstant.
  //		0  if input is byteswapped relative to nativeConstant.
  //		-1 if input is not the same as nativeConstant and not byteswapped either.
  //
  // ( This is useful for detecting byteswapping in magic numbers in structure 
  // headers for example. )
  //-----------------------------------------------------------------------------
  template<typename T> inline int SourceIsNativeEndian( T input, T nativeConstant ) {
	 // If it's the same, it isn't byteswapped:
	 if( input == nativeConstant )
		return 1;

	 int output;
	 LowLevelByteSwap<T>( &output, &input );
	 if( output == nativeConstant )
		return 0;

	 assert( 0 );		// if we Get here, input is neither a swapped nor unswapped version of nativeConstant.
	 return -1;
  }

  //-----------------------------------------------------------------------------
  // Swaps an input buffer full of type T into the given output buffer.
  //
  // Swaps [count] items from the inputBuffer to the outputBuffer.
  // If inputBuffer is omitted or NULL, then it is assumed to be the same as
  // outputBuffer - effectively swapping the contents of the buffer in place.
  //-----------------------------------------------------------------------------
  template<typename T> inline void SwapBuffer( T* outputBuffer, T* inputBuffer = NULL, int count = 1 ) {
	 assert( count >= 0 );
	 assert( outputBuffer );

	 // Fail gracefully in release:
	 if( count <= 0 || !outputBuffer )
		return;

	 // Optimization for the case when we are swapping in place.
	 if( inputBuffer == NULL ) {
		inputBuffer = outputBuffer;
	 }

	 // Swap everything in the buffer:
	 for( int i = 0; i < count; i++ ) {
		LowLevelByteSwap<T>( &outputBuffer[i], &inputBuffer[i] );
	 }
  }

  //-----------------------------------------------------------------------------
  // Swaps an input buffer full of type T into the given output buffer.
  //
  // Swaps [count] items from the inputBuffer to the outputBuffer.
  // If inputBuffer is omitted or NULL, then it is assumed to be the same as
  // outputBuffer - effectively swapping the contents of the buffer in place.
  //-----------------------------------------------------------------------------
  template<typename T> inline void SwapBufferToTargetEndian( T* outputBuffer, T* inputBuffer = NULL, int count = 1 ) {
	 assert( count >= 0 );
	 assert( outputBuffer );

	 // Fail gracefully in release:
	 if( count <= 0 || !outputBuffer )
		return;

	 // Optimization for the case when we are swapping in place.
	 if( inputBuffer == NULL ) {
		inputBuffer = outputBuffer;
	 }

	 // Are we already the correct endienness? ( or are we swapping 1 uint8_t items? )
	 if( !m_bSwapBytes || ( sizeof( T ) == 1 ) ) {
		// If we were just going to swap in place then return.
		if( !inputBuffer )
		  return;

		// Otherwise copy the inputBuffer to the outputBuffer:
		memcpy( outputBuffer, inputBuffer, count * sizeof( T ) );
		return;

	 }

	 // Swap everything in the buffer:
	 for( int i = 0; i < count; i++ ) {
		LowLevelByteSwap<T>( &outputBuffer[i], &inputBuffer[i] );
	 }
  }

private:
  //-----------------------------------------------------------------------------
  // The lowest level uint8_t swapping workhorse of doom.  output always contains the 
  // swapped version of input.  ( Doesn't compare machine to target endianness )
  //-----------------------------------------------------------------------------
  template<typename T> static void LowLevelByteSwap( T *output, T *input ) {
	 T temp = *output;
  #if defined( _X360 )
	 // Intrinsics need the source type to be fixed-point
	 DWORD* word = ( DWORD* )input;
	 switch( sizeof( T ) ) {
	 case 8:
	 {
		__storewordbytereverse( *word, 0, &temp );
		__storewordbytereverse( *( word + 1 ), 4, &temp );
	 }
	 break;

	 case 4:
		__storewordbytereverse( *word, 0, &temp );
		break;

	 case 2:
		__storeshortbytereverse( *input, 0, &temp );
		break;

	 default:
		assert( "Invalid size in CByteswap::LowLevelByteSwap" && 0 );
	 }
  #else
	 for( int i = 0; i < sizeof( T ); i++ ) {
		( ( unsigned char* )&temp )[i] = ( ( unsigned char* )input )[sizeof( T ) - ( i + 1 )];
	 }
  #endif
	 memcpy( output, &temp, sizeof( T ) );
  }

  unsigned int m_bSwapBytes : 1;
  unsigned int m_bBigEndian : 1;
};

//-----------------------------------------------------------------------------
// Description of character conversions for string output
// Here's an example of how to use the macros to define a character conversion
// BEGIN_CHAR_CONVERSION( CStringConversion, '\\' )
//	{ '\n', "n" },
//	{ '\t', "t" }
// END_CHAR_CONVERSION( CStringConversion, '\\' )
//-----------------------------------------------------------------------------
class CUtlCharConversion
{
public:
  struct ConversionArray_t
  {
	 char m_nActualChar;
	 char *m_pReplacementString;
  };

  CUtlCharConversion( char nEscapeChar, const char *pDelimiter, int nCount, ConversionArray_t *pArray );
  char GetEscapeChar( ) const;
  const char *GetDelimiter( ) const;
  int GetDelimiterLength( ) const;

  const char *GetConversionString( char c ) const;
  int GetConversionLength( char c ) const;
  int MaxConversionLength( ) const;

  // Finds a conversion for the passed-in string, returns length
  virtual char FindConversion( const char *pString, int *pLength );

protected:
  struct ConversionInfo_t
  {
	 int m_nLength;
	 char *m_pReplacementString;
  };

  char m_nEscapeChar;
  const char *m_pDelimiter;
  int m_nDelimiterLength;
  int m_nCount;
  int m_nMaxConversionLength;
  char m_pList[255];
  ConversionInfo_t m_pReplacements[255];
};

#define BEGIN_CHAR_CONVERSION( _name, _delimiter, _escapeChar )	\
	static CUtlCharConversion::ConversionArray_t s_pConversionArray ## _name[] = {

#define END_CHAR_CONVERSION( _name, _delimiter, _escapeChar ) \
	}; \
	CUtlCharConversion _name( _escapeChar, _delimiter, sizeof( s_pConversionArray ## _name ) / sizeof( CUtlCharConversion::ConversionArray_t ), s_pConversionArray ## _name )

#define BEGIN_CUSTOM_CHAR_CONVERSION( _className, _name, _delimiter, _escapeChar ) \
	static CUtlCharConversion::ConversionArray_t s_pConversionArray ## _name[] = {

#define END_CUSTOM_CHAR_CONVERSION( _className, _name, _delimiter, _escapeChar ) \
	}; \
	_className _name( _escapeChar, _delimiter, sizeof( s_pConversionArray ## _name ) / sizeof( CUtlCharConversion::ConversionArray_t ), s_pConversionArray ## _name )

//-----------------------------------------------------------------------------
// Character conversions for C strings
//-----------------------------------------------------------------------------
CUtlCharConversion *GetCStringCharConversion( );

//-----------------------------------------------------------------------------
// Character conversions for quoted strings, with no escape sequences
//-----------------------------------------------------------------------------
CUtlCharConversion *GetNoEscCharConversion( );


//-----------------------------------------------------------------------------
// Macro to Set overflow functions easily
//-----------------------------------------------------------------------------
#define SetUtlBufferOverflowFuncs( _get, _put )	\
	SetOverflowFuncs( static_cast <UtlBufferOverflowFunc_t>( _get ), static_cast <UtlBufferOverflowFunc_t>( _put ) )


//-----------------------------------------------------------------------------
// Command parsing..
//-----------------------------------------------------------------------------
class CUtlBuffer
{
public:
  enum SeekType_t
  {
	 SEEK_HEAD = 0,
	 SEEK_CURRENT,
	 SEEK_TAIL
  };

  // flags
  enum BufferFlags_t
  {
	 TEXT_BUFFER = 0x1,			// Describes how Get + put work (as strings, or binary)
	 EXTERNAL_GROWABLE = 0x2,	// This is used w/ external buffers and causes the utlbuf to switch to reallocatable memory if an overflow happens when Putting.
	 CONTAINS_CRLF = 0x4,		// For text buffers only, does this contain \n or \n\r?
	 READ_ONLY = 0x8,			// For external buffers; prevents null termination from happening.
	 AUTO_TABS_DISABLED = 0x10,	// Used to disable/enable push/pop tabs
  };

  // Overflow functions when a Get or put overflows
  typedef bool ( CUtlBuffer::*UtlBufferOverflowFunc_t )( int nSize );

  // Constructors for growable + external buffers for serialization/unserialization
  CUtlBuffer( int growSize = 0, int initSize = 0, int nFlags = 0 );
  CUtlBuffer( const void* pBuffer, int size, int nFlags = 0 );
  // This one isn't actually defined so that we catch contructors that are trying to pass a bool in as the third param.
  CUtlBuffer( const void *pBuffer, int size, bool crap );

  unsigned char	GetFlags( ) const;

  // NOTE: This will assert if you attempt to recast it in a way that
  // is not compatible. The only valid conversion is binary-> text w/CRLF
  void			SetBufferType( bool bIsText, bool bContainsCRLF );

  // Makes sure we've got at least this much memory
  void			EnsureCapacity( int num );

  // Attaches the buffer to external memory....
  void			SetExternalBuffer( void* pMemory, int nSize, int nInitialPut, int nFlags = 0 );
  bool			IsExternallyAllocated( ) const;
  void			AssumeMemory( void *pMemory, int nSize, int nInitialPut, int nFlags = 0 );

  __forceinline void ActivateByteSwappingIfBigEndian( void ) {
	 if( IsX360( ) )
		ActivateByteSwapping( true );
  }


  // Controls endian-ness of binary utlbufs - default matches the current platform
  void			ActivateByteSwapping( bool bActivate );
  void			SetBigEndian( bool bigEndian );
  bool			IsBigEndian( void );

  // Resets the buffer; but doesn't free memory
  void			Clear( );

  // Clears out the buffer; frees memory
  void			Purge( );

  // Read stuff out.
  // Binary mode: it'll just read the bits directly in, and characters will be
  //		read for strings until a null character is reached.
  // Text mode: it'll parse the file, turning text #s into real numbers.
  //		GetString will read a string until a space is reached
  char			GetChar( );
  unsigned char	GetUnsignedChar( );
  short			GetShort( );
  unsigned short	GetUnsignedShort( );
  int				GetInt( );
  int				GetIntHex( );
  unsigned int	GetUnsignedInt( );
  float			GetFloat( );
  double			GetDouble( );
  void			GetString( char* pString, int nMaxChars = 0 );
  void			Get( void* pMem, int size );
  void			GetLine( char* pLine, int nMaxChars = 0 );

  // Used for getting objects that have a byteswap datadesc defined
  template <typename T> void GetObjects( T *dest, int count = 1 );

  // This will Get at least 1 uint8_t and up to nSize bytes. 
  // It will return the number of bytes actually read.
  int				GetUpTo( void *pMem, int nSize );

  // This version of GetString converts \" to \\ and " to \, etc.
  // It also reads a " at the beginning and end of the string
  void			GetDelimitedString( CUtlCharConversion *pConv, char *pString, int nMaxChars = 0 );
  char			GetDelimitedChar( CUtlCharConversion *pConv );

  // This will return the # of characters of the string about to be read out
  // NOTE: The count will *include* the terminating 0!!
  // In binary mode, it's the number of characters until the next 0
  // In text mode, it's the number of characters until the next space.
  int				PeekStringLength( );

  // This version of PeekStringLength converts \" to \\ and " to \, etc.
  // It also reads a " at the beginning and end of the string
  // NOTE: The count will *include* the terminating 0!!
  // In binary mode, it's the number of characters until the next 0
  // In text mode, it's the number of characters between "s (checking for \")
  // Specifying false for bActualSize will return the pre-translated number of characters
  // including the delimiters and the escape characters. So, \n counts as 2 characters when bActualSize == false
  // and only 1 character when bActualSize == true
  int				PeekDelimitedStringLength( CUtlCharConversion *pConv, bool bActualSize = true );

  // Just like scanf, but doesn't work in binary mode
  int				Scanf( const char* pFmt, ... );
  int				VaScanf( const char* pFmt, va_list list );

  // Eats white space, advances Get index
  void			EatWhiteSpace( );

  // Eats C++ style comments
  bool			EatCPPComment( );

  // (For text buffers only)
  // Parse a token from the buffer:
  // Grab all text that lies between a starting delimiter + ending delimiter
  // (skipping whitespace that leads + trails both delimiters).
  // If successful, the Get index is advanced and the function returns true,
  // otherwise the index is not advanced and the function returns false.
  bool			ParseToken( const char *pStartingDelim, const char *pEndingDelim, char* pString, int nMaxLen );

  // Advance the Get index until after the particular string is found
  // Do not eat whitespace before starting. Return false if it failed
  // String test is case-insensitive.
  bool			GetToken( const char *pToken );

  // Parses the next token, given a Set of character breaks to stop at
  // Returns the length of the token parsed in bytes (-1 if none parsed)
  int				ParseToken( characterset_t *pBreaks, char *pTokenBuf, int nMaxLen, bool bParseComments = true );

  // Write stuff in
  // Binary mode: it'll just write the bits directly in, and strings will be
  //		written with a null terminating character
  // Text mode: it'll convert the numbers to text versions
  //		PutString will not write a terminating character
  void			PutChar( char c );
  void			PutUnsignedChar( unsigned char uc );
  void			PutShort( short s );
  void			PutUnsignedShort( unsigned short us );
  void			PutInt( int i );
  void			PutUnsignedInt( unsigned int u );
  void			PutFloat( float f );
  void			PutDouble( double d );
  void			PutString( const char* pString );
  void			Put( const void* pMem, int size );

  // Used for putting objects that have a byteswap datadesc defined
  template <typename T> void PutObjects( T *src, int count = 1 );

  // This version of PutString converts \ to \\ and " to \", etc.
  // It also places " at the beginning and end of the string
  void			PutDelimitedString( CUtlCharConversion *pConv, const char *pString );
  void			PutDelimitedChar( CUtlCharConversion *pConv, char c );

  // Just like printf, writes a terminating zero in binary mode
  void			Printf( const char* pFmt, ... );
  void			VaPrintf( const char* pFmt, va_list list );

  // What am I writing (put)/reading (Get)?
  void* PeekPut( int offset = 0 );
  const void* PeekGet( int offset = 0 ) const;
  const void* PeekGet( int nMaxSize, int nOffset );

  // Where am I writing (put)/reading (Get)?
  int TellPut( ) const;
  int TellGet( ) const;

  // What's the most I've ever written?
  int TellMaxPut( ) const;

  // How many bytes remain to be read?
  // NOTE: This is not accurate for streaming text files; it overshoots
  int GetBytesRemaining( ) const;

  // Change where I'm writing (put)/reading (Get)
  void SeekPut( SeekType_t type, int offset );
  void SeekGet( SeekType_t type, int offset );

  // Buffer base
  const void* Base( ) const;
  void* Base( );

  // memory allocation size, does *not* reflect size written or read,
  //	use TellPut or TellGet for that
  int Size( ) const;

  // Am I a text buffer?
  bool IsText( ) const;

  // Can I grow if I'm externally allocated?
  bool IsGrowable( ) const;

  // Am I valid? (overflow or underflow error), Once invalid it stays invalid
  bool IsValid( ) const;

  // Do I contain carriage return/linefeeds? 
  bool ContainsCRLF( ) const;

  // Am I read-only
  bool IsReadOnly( ) const;

  // Converts a buffer from a CRLF buffer to a CR buffer (and back)
  // Returns false if no conversion was necessary (and outBuf is left untouched)
  // If the conversion occurs, outBuf will be cleared.
  bool ConvertCRLF( CUtlBuffer &outBuf );

  // Push/pop pretty-printing tabs
  void PushTab( );
  void PopTab( );

  // Temporarily disables pretty print
  void EnableTabs( bool bEnable );

protected:
  // error flags
  enum
  {
	 PUT_OVERFLOW = 0x1,
	 GET_OVERFLOW = 0x2,
	 MAX_ERROR_FLAG = GET_OVERFLOW,
  };

  void SetOverflowFuncs( UtlBufferOverflowFunc_t getFunc, UtlBufferOverflowFunc_t putFunc );

  bool OnPutOverflow( int nSize );
  bool OnGetOverflow( int nSize );

protected:
  // Checks if a Get/put is ok
  bool CheckPut( int size );
  bool CheckGet( int size );

  void AddNullTermination( );

  // Methods to help with pretty-printing
  bool WasLastCharacterCR( );
  void PutTabs( );

  // Help with delimited stuff
  char GetDelimitedCharInternal( CUtlCharConversion *pConv );
  void PutDelimitedCharInternal( CUtlCharConversion *pConv, char c );

  // Default overflow funcs
  bool PutOverflow( int nSize );
  bool GetOverflow( int nSize );

  // Does the next bytes of the buffer match a pattern?
  bool PeekStringMatch( int nOffset, const char *pString, int nLen );

  // Peek size of line to come, check memory bound
  int	PeekLineLength( );

  // How much whitespace should I skip?
  int PeekWhiteSpace( int nOffset );

  // Checks if a peek Get is ok
  bool CheckPeekGet( int nOffset, int nSize );

  // Call this to peek arbitrarily long into memory. It doesn't fail unless
  // it can't read *anything* new
  bool CheckArbitraryPeekGet( int nOffset, int &nIncrement );

  template <typename T> void GetType( T& dest, const char *pszFmt );
  template <typename T> void GetTypeBin( T& dest );
  template <typename T> void GetObject( T *src );

  template <typename T> void PutType( T src, const char *pszFmt );
  template <typename T> void PutTypeBin( T src );
  template <typename T> void PutObject( T *src );

  CUtlMemory<unsigned char> m_Memory;
  int m_Get;
  int m_Put;

  unsigned char m_Error;
  unsigned char m_Flags;
  unsigned char m_Reserved;
#if defined( _X360 )
  unsigned char pad;
#endif

  int m_nTab;
  int m_nMaxPut;
  int m_nOffset;

  UtlBufferOverflowFunc_t m_GetOverflowFunc;
  UtlBufferOverflowFunc_t m_PutOverflowFunc;

  CByteswap	m_Byteswap;
};


// Stream style output operators for CUtlBuffer
inline CUtlBuffer &operator<<( CUtlBuffer &b, char v ) {
  b.PutChar( v );
  return b;
}

inline CUtlBuffer &operator<<( CUtlBuffer &b, unsigned char v ) {
  b.PutUnsignedChar( v );
  return b;
}

inline CUtlBuffer &operator<<( CUtlBuffer &b, short v ) {
  b.PutShort( v );
  return b;
}

inline CUtlBuffer &operator<<( CUtlBuffer &b, unsigned short v ) {
  b.PutUnsignedShort( v );
  return b;
}

inline CUtlBuffer &operator<<( CUtlBuffer &b, int v ) {
  b.PutInt( v );
  return b;
}

inline CUtlBuffer &operator<<( CUtlBuffer &b, unsigned int v ) {
  b.PutUnsignedInt( v );
  return b;
}

inline CUtlBuffer &operator<<( CUtlBuffer &b, float v ) {
  b.PutFloat( v );
  return b;
}

inline CUtlBuffer &operator<<( CUtlBuffer &b, double v ) {
  b.PutDouble( v );
  return b;
}

inline CUtlBuffer &operator<<( CUtlBuffer &b, const char *pv ) {
  b.PutString( pv );
  return b;
}

inline CUtlBuffer &operator<<( CUtlBuffer &b, const Vector &v ) {
  b << v.x << " " << v.y << " " << v.z;
  return b;
}

inline CUtlBuffer &operator<<( CUtlBuffer &b, const Vector2D &v ) {
  b << v.x << " " << v.y;
  return b;
}


class CUtlInplaceBuffer : public CUtlBuffer
{
public:
  CUtlInplaceBuffer( int growSize = 0, int initSize = 0, int nFlags = 0 );

  //
  // Routines returning buffer-inplace-pointers
  //
public:
  //
  // Upon success, determines the line length, fills out the pointer to the
  // beginning of the line and the line length, advances the "Get" pointer
  // offset by the line length and returns "true".
  //
  // If end of file is reached or upon error returns "false".
  //
  // Note:	the returned length of the line is at least one character because the
  //			trailing newline characters are also included as part of the line.
  //
  // Note:	the pointer returned points into the local memory of this buffer, in
  //			case the buffer gets relocated or destroyed the pointer becomes invalid.
  //
  // e.g.:	-------------
  //
  //			char *pszLine;
  //			int nLineLen;
  //			while ( pUtlInplaceBuffer->InplaceGetLinePtr( &pszLine, &nLineLen ) )
  //			{
  //				...
  //			}
  //
  //			-------------
  //
  // @param	ppszInBufferPtr		on return points into this buffer at start of line
  // @param	pnLineLength		on return holds num bytes accessible via (*ppszInBufferPtr)
  //
  // @returns	true				if line was successfully read
  //			false				when EOF is reached or error occurs
  //
  bool InplaceGetLinePtr( /* out */ char **ppszInBufferPtr, /* out */ int *pnLineLength );

  //
  // Determines the line length, advances the "Get" pointer offset by the line length,
  // replaces the newline character with null-terminator and returns the initial pointer
  // to now null-terminated line.
  //
  // If end of file is reached or upon error returns NULL.
  //
  // Note:	the pointer returned points into the local memory of this buffer, in
  //			case the buffer gets relocated or destroyed the pointer becomes invalid.
  //
  // e.g.:	-------------
  //
  //			while ( char *pszLine = pUtlInplaceBuffer->InplaceGetLinePtr() )
  //			{
  //				...
  //			}
  //
  //			-------------
  //
  // @returns	ptr-to-zero-terminated-line		if line was successfully read and buffer modified
  //			NULL							when EOF is reached or error occurs
  //
  char * InplaceGetLinePtr( void );
};


//-----------------------------------------------------------------------------
// Where am I reading?
//-----------------------------------------------------------------------------
inline int CUtlBuffer::TellGet( ) const {
  return m_Get;
}


//-----------------------------------------------------------------------------
// How many bytes remain to be read?
//-----------------------------------------------------------------------------
inline int CUtlBuffer::GetBytesRemaining( ) const {
  return m_nMaxPut - TellGet( );
}


//-----------------------------------------------------------------------------
// What am I reading?
//-----------------------------------------------------------------------------
inline const void* CUtlBuffer::PeekGet( int offset ) const {
  return &m_Memory[m_Get + offset - m_nOffset];
}


//-----------------------------------------------------------------------------
// Unserialization
//-----------------------------------------------------------------------------

template <typename T>
inline void CUtlBuffer::GetObject( T *dest ) {
  if( CheckGet( sizeof( T ) ) ) {
	 if( !m_Byteswap.IsSwappingBytes( ) || ( sizeof( T ) == 1 ) ) {
		*dest = *( T * )PeekGet( );
	 } else {
		m_Byteswap.SwapFieldsToTargetEndian<T>( dest, ( T* )PeekGet( ) );
	 }
	 m_Get += sizeof( T );
  } else {
	 Q_memset( &dest, 0, sizeof( T ) );
  }
}


template <typename T>
inline void CUtlBuffer::GetObjects( T *dest, int count ) {
  for( int i = 0; i < count; ++i, ++dest ) {
	 GetObject<T>( dest );
  }
}


template <typename T>
inline void CUtlBuffer::GetTypeBin( T &dest ) {
  if( CheckGet( sizeof( T ) ) ) {
	 if( !m_Byteswap.IsSwappingBytes( ) || ( sizeof( T ) == 1 ) ) {
		dest = *( T * )PeekGet( );
	 } else {
		m_Byteswap.SwapBufferToTargetEndian<T>( &dest, ( T* )PeekGet( ) );
	 }
	 m_Get += sizeof( T );
  } else {
	 dest = 0;
  }
}

template <>
inline void CUtlBuffer::GetTypeBin< float >( float &dest ) {
  if( CheckGet( sizeof( float ) ) ) {
	 unsigned int pData = ( unsigned int )PeekGet( );
	 if( IsX360( ) && ( pData & 0x03 ) ) {
		// handle unaligned read
		( ( unsigned char* )&dest )[0] = ( ( unsigned char* )pData )[0];
		( ( unsigned char* )&dest )[1] = ( ( unsigned char* )pData )[1];
		( ( unsigned char* )&dest )[2] = ( ( unsigned char* )pData )[2];
		( ( unsigned char* )&dest )[3] = ( ( unsigned char* )pData )[3];
	 } else {
		// aligned read
		dest = *( float * )pData;
	 }
	 if( m_Byteswap.IsSwappingBytes( ) ) {
		m_Byteswap.SwapBufferToTargetEndian< float >( &dest, &dest );
	 }
	 m_Get += sizeof( float );
  } else {
	 dest = 0;
  }
}

template <typename T>
inline void CUtlBuffer::GetType( T &dest, const char *pszFmt ) {
  if( !IsText( ) ) {
	 GetTypeBin( dest );
  } else {
	 dest = 0;
	 Scanf( pszFmt, &dest );
  }
}

inline char CUtlBuffer::GetChar( ) {
  char c;
  GetType( c, "%c" );
  return c;
}

inline unsigned char CUtlBuffer::GetUnsignedChar( ) {
  unsigned char c;
  GetType( c, "%u" );
  return c;
}

inline short CUtlBuffer::GetShort( ) {
  short s;
  GetType( s, "%d" );
  return s;
}

inline unsigned short CUtlBuffer::GetUnsignedShort( ) {
  unsigned short s;
  GetType( s, "%u" );
  return s;
}

inline int CUtlBuffer::GetInt( ) {
  int i;
  GetType( i, "%d" );
  return i;
}

inline int CUtlBuffer::GetIntHex( ) {
  int i;
  GetType( i, "%x" );
  return i;
}

inline unsigned int CUtlBuffer::GetUnsignedInt( ) {
  unsigned int u;
  GetType( u, "%u" );
  return u;
}

inline float CUtlBuffer::GetFloat( ) {
  float f;
  GetType( f, "%f" );
  return f;
}

inline double CUtlBuffer::GetDouble( ) {
  double d;
  GetType( d, "%f" );
  return d;
}


//-----------------------------------------------------------------------------
// Where am I writing?
//-----------------------------------------------------------------------------
inline unsigned char CUtlBuffer::GetFlags( ) const {
  return m_Flags;
}


//-----------------------------------------------------------------------------
// 
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsExternallyAllocated( ) const {
  return m_Memory.IsExternallyAllocated( );
}


//-----------------------------------------------------------------------------
// Where am I writing?
//-----------------------------------------------------------------------------
inline int CUtlBuffer::TellPut( ) const {
  return m_Put;
}


//-----------------------------------------------------------------------------
// What's the most I've ever written?
//-----------------------------------------------------------------------------
inline int CUtlBuffer::TellMaxPut( ) const {
  return m_nMaxPut;
}


//-----------------------------------------------------------------------------
// What am I reading?
//-----------------------------------------------------------------------------
inline void* CUtlBuffer::PeekPut( int offset ) {
  return &m_Memory[m_Put + offset - m_nOffset];
}


//-----------------------------------------------------------------------------
// Various put methods
//-----------------------------------------------------------------------------

template <typename T>
inline void CUtlBuffer::PutObject( T *src ) {
  if( CheckPut( sizeof( T ) ) ) {
	 if( !m_Byteswap.IsSwappingBytes( ) || ( sizeof( T ) == 1 ) ) {
		*( T * )PeekPut( ) = *src;
	 } else {
		m_Byteswap.SwapFieldsToTargetEndian<T>( ( T* )PeekPut( ), src );
	 }
	 m_Put += sizeof( T );
	 AddNullTermination( );
  }
}


template <typename T>
inline void CUtlBuffer::PutObjects( T *src, int count ) {
  for( int i = 0; i < count; ++i, ++src ) {
	 PutObject<T>( src );
  }
}


template <typename T>
inline void CUtlBuffer::PutTypeBin( T src ) {
  if( CheckPut( sizeof( T ) ) ) {
	 if( !m_Byteswap.IsSwappingBytes( ) || ( sizeof( T ) == 1 ) ) {
		*( T * )PeekPut( ) = src;
	 } else {
		m_Byteswap.SwapBufferToTargetEndian<T>( ( T* )PeekPut( ), &src );
	 }
	 m_Put += sizeof( T );
	 AddNullTermination( );
  }
}

template <typename T>
inline void CUtlBuffer::PutType( T src, const char *pszFmt ) {
  if( !IsText( ) ) {
	 PutTypeBin( src );
  } else {
	 Printf( pszFmt, src );
  }
}

//-----------------------------------------------------------------------------
// Methods to help with pretty-printing
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::WasLastCharacterCR( ) {
  if( !IsText( ) || ( TellPut( ) == 0 ) )
	 return false;
  return ( *( const char * )PeekPut( -1 ) == '\n' );
}

inline void CUtlBuffer::PutTabs( ) {
  int nTabCount = ( m_Flags & AUTO_TABS_DISABLED ) ? 0 : m_nTab;
  for( int i = nTabCount; --i >= 0; ) {
	 PutTypeBin<char>( '\t' );
  }
}


//-----------------------------------------------------------------------------
// Push/pop pretty-printing tabs
//-----------------------------------------------------------------------------
inline void CUtlBuffer::PushTab( ) {
  ++m_nTab;
}

inline void CUtlBuffer::PopTab( ) {
  if( --m_nTab < 0 ) {
	 m_nTab = 0;
  }
}


//-----------------------------------------------------------------------------
// Temporarily disables pretty print
//-----------------------------------------------------------------------------
inline void CUtlBuffer::EnableTabs( bool bEnable ) {
  if( bEnable ) {
	 m_Flags &= ~AUTO_TABS_DISABLED;
  } else {
	 m_Flags |= AUTO_TABS_DISABLED;
  }
}

inline void CUtlBuffer::PutChar( char c ) {
  if( WasLastCharacterCR( ) ) {
	 PutTabs( );
  }

  PutTypeBin( c );
}

inline void CUtlBuffer::PutUnsignedChar( unsigned char c ) {
  PutType( c, "%u" );
}

inline void  CUtlBuffer::PutShort( short s ) {
  PutType( s, "%d" );
}

inline void CUtlBuffer::PutUnsignedShort( unsigned short s ) {
  PutType( s, "%u" );
}

inline void CUtlBuffer::PutInt( int i ) {
  PutType( i, "%d" );
}

inline void CUtlBuffer::PutUnsignedInt( unsigned int u ) {
  PutType( u, "%u" );
}

inline void CUtlBuffer::PutFloat( float f ) {
  PutType( f, "%f" );
}

inline void CUtlBuffer::PutDouble( double d ) {
  PutType( d, "%f" );
}


//-----------------------------------------------------------------------------
// Am I a text buffer?
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsText( ) const {
  return ( m_Flags & TEXT_BUFFER ) != 0;
}


//-----------------------------------------------------------------------------
// Can I grow if I'm externally allocated?
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsGrowable( ) const {
  return ( m_Flags & EXTERNAL_GROWABLE ) != 0;
}


//-----------------------------------------------------------------------------
// Am I valid? (overflow or underflow error), Once invalid it stays invalid
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsValid( ) const {
  return m_Error == 0;
}


//-----------------------------------------------------------------------------
// Do I contain carriage return/linefeeds? 
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::ContainsCRLF( ) const {
  return IsText( ) && ( ( m_Flags & CONTAINS_CRLF ) != 0 );
}


//-----------------------------------------------------------------------------
// Am I read-only
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsReadOnly( ) const {
  return ( m_Flags & READ_ONLY ) != 0;
}


//-----------------------------------------------------------------------------
// Buffer base and size
//-----------------------------------------------------------------------------
inline const void* CUtlBuffer::Base( ) const {
  return m_Memory.Base( );
}

inline void* CUtlBuffer::Base( ) {
  return m_Memory.Base( );
}

inline int CUtlBuffer::Size( ) const {
  return m_Memory.NumAllocated( );
}


//-----------------------------------------------------------------------------
// Clears out the buffer; frees memory
//-----------------------------------------------------------------------------
inline void CUtlBuffer::Clear( ) {
  m_Get = 0;
  m_Put = 0;
  m_Error = 0;
  m_nOffset = 0;
  m_nMaxPut = -1;
  AddNullTermination( );
}

inline void CUtlBuffer::Purge( ) {
  m_Get = 0;
  m_Put = 0;
  m_nOffset = 0;
  m_nMaxPut = 0;
  m_Error = 0;
  m_Memory.Purge( );
}
#pragma warning(default:4127) //conditional operation is constant

```

`CSGO SDK/SDK/Valve/UtlMap.hpp`:

```hpp
#pragma once
template <typename I>
struct UtlRBTreeLinks_t {
   I m_Left;
   I m_Right;
   I m_Parent;
   I m_Tag;
};

template <typename T, typename I>
struct UtlRBTreeNode_t : UtlRBTreeLinks_t<I> {
   T m_Data;
};

template <typename T, typename I = unsigned short, typename L = bool( * )( const T&, const T& ), typename M = CUtlMemory<UtlRBTreeNode_t<T, I>, I>>
class CUtlRBTree {
public:
   T& Element( I i ) {
	  return m_Elements.Element( i ).m_Data;
   }

   const T& Element( I i ) const {
	  return m_Elements.Element( i ).m_Data;
   }

   I MaxElement( ) const {
	  return I( m_Elements.NumAllocated( ) );
   }

   I LeftChild( I i ) const {
	  return Links( i ).m_Left;
   }

   I RightChild( I i ) const {
	  return Links( i ).m_Right;
   }

   I Parent( I i ) const {
	  return Links( i ).m_Parent;
   }

   bool IsRightChild( I i ) const {
	  return RightChild( Parent( i ) ) == i;
   }

   bool IsValidIndex( I i ) const {
	  if ( i < 0 )
		 return false;

	  if ( i > m_LastAlloc.index )
		 return false;

	  return LeftChild( i ) != i;
   }

   I Find( const T& Search ) const {
	  I Current = m_Root;
	  while ( Current != I( -1 ) ) {
		 if ( m_LessFunc( Search, Element( Current ) ) )
			Current = LeftChild( Current );
		 else if ( m_LessFunc( Element( Current ), Search ) )
			Current = RightChild( Current );
		 else
			break;
	  }

	  return Current;
   }

   I FirstInorder( ) const {
	  I i = m_Root;
	  while ( LeftChild( i ) != I( -1 ) )
		 i = LeftChild( i );

	  return i;
   }

   I NextInorder( I i ) const {
	  if ( RightChild( i ) != I( -1 ) ) {
		 i = RightChild( i );
		 while ( LeftChild( i ) != I( -1 ) )
			i = LeftChild( i );

		 return i;
	  }

	  I p = Parent( i );
	  while ( IsRightChild( i ) ) {
		 i = p;
		 if ( i == I( -1 ) )
			break;

		 p = Parent( i );
	  }

	  return p;
   }

protected:
   const UtlRBTreeLinks_t<I>& Links( I i ) const {
	  static UtlRBTreeLinks_t<I> s_Sentinel = { I( -1 ), I( -1 ), I( -1 ), I( 1 ) };
	  return i == I( -1 ) ? s_Sentinel : *reinterpret_cast< const UtlRBTreeLinks_t<I>* >( &m_Elements.Element( i ) );
   }

   L m_LessFunc;

   M m_Elements;
   I m_Root;
   I m_NumElements;
   I m_FirstFree;
   typename M::Iterator_t m_LastAlloc;

   UtlRBTreeNode_t<T, I>* m_pElements;
};

template <typename K, typename T, typename I = int>
class CUtlMap {
public:
   using LessFunc_t = bool( __cdecl* )( const K&, const K& );

   T& operator[]( I i ) {
	  return m_Tree.Element( i ).Element;
   }

   K& Key( I i ) {
	  return m_Tree.Element( i ).Key;
   }

   const K& Key( I i ) const {
	  return m_Tree.Element( i ).Key;
   }

   I MaxElement( ) const {
	  return m_Tree.MaxElement( );
   }

   bool IsValidIndex( I i ) const {
	  return m_Tree.IsValidIndex( i );
   }

   I Find( const K& Key ) const {
	  Node_t Dummy;
	  Dummy.Key = Key;
	  return m_Tree.Find( Dummy );
   }

   I FirstInorder( ) const {
	  return m_Tree.FirstInorder( );
   }

   I NextInorder( I i ) const {
	  return m_Tree.NextInorder( i );
   }

   struct Node_t {
	  K Key;
	  T Element;
   };

   class CKeyLess {
   public:
	  explicit CKeyLess( LessFunc_t lessFunc ) : m_LessFunc( lessFunc ) { }

	  bool operator!( ) const {
		 return !m_LessFunc;
	  }

	  bool operator()( const Node_t& left, const Node_t& right ) const {
		 return m_LessFunc( left.Key, right.Key );
	  }

	  LessFunc_t m_LessFunc;
   };

protected:
   CUtlRBTree<Node_t, I, CKeyLess> m_Tree;
};
```

`CSGO SDK/SDK/Valve/UtlMemory.hpp`:

```hpp
#pragma once

#include <assert.h>
#include "platform.hpp"

template < class T, class I = int >
class CUtlMemory {
public:
  // constructor, destructor
  CUtlMemory( int nGrowSize = 0, int nInitSize = 0 );
  CUtlMemory( T* pMemory, int numElements );
  CUtlMemory( const T* pMemory, int numElements );
  ~CUtlMemory( );

  // Set the size by which the memory grows
  void Init( int nGrowSize = 0, int nInitSize = 0 );

  class Iterator_t {
  public:
	 Iterator_t( I i ) :
		index( i ) {
	 }
	 I index;

	 bool operator==( const Iterator_t it ) const { return index == it.index; }
	 bool operator!=( const Iterator_t it ) const { return index != it.index; }
  };
  Iterator_t First( ) const { return Iterator_t( IsIdxValid( 0 ) ? 0 : InvalidIndex( ) ); }
  Iterator_t Next( const Iterator_t& it ) const { return Iterator_t( IsIdxValid( it.index + 1 ) ? it.index + 1 : InvalidIndex( ) ); }
  I GetIndex( const Iterator_t& it ) const { return it.index; }
  bool IsIdxAfter( I i, const Iterator_t& it ) const { return i > it.index; }
  bool IsValidIterator( const Iterator_t& it ) const { return IsIdxValid( it.index ); }
  Iterator_t InvalidIterator( ) const { return Iterator_t( InvalidIndex( ) ); }

  // element access
  T& operator[]( I i );
  const T& operator[]( I i ) const;
  T& Element( I i );
  const T& Element( I i ) const;

  bool IsIdxValid( I i ) const;

  static const I INVALID_INDEX = ( I )-1; // For use with COMPILE_TIME_ASSERT
  static I InvalidIndex( ) { return INVALID_INDEX; }

  T* Base( );
  const T* Base( ) const;

  void SetExternalBuffer( T* pMemory, int numElements );
  void SetExternalBuffer( const T* pMemory, int numElements );
  void AssumeMemory( T* pMemory, int nSize );
  T* Detach( );
  void* DetachMemory( );

  void Swap( CUtlMemory< T, I >& mem );
  void ConvertToGrowableMemory( int nGrowSize );
  int NumAllocated( ) const;
  int Count( ) const;
  void Grow( int num = 1 );
  void EnsureCapacity( int num );
  void Purge( );
  void Purge( int numElements );
  bool IsExternallyAllocated( ) const;
  bool IsReadOnly( ) const;
  void SetGrowSize( int size );

protected:
  void ValidateGrowSize( ) {
  }

  enum {
	 EXTERNAL_BUFFER_MARKER = -1,
	 EXTERNAL_CONST_BUFFER_MARKER = -2,
  };

public:
  T* m_pMemory;
  int m_nAllocationCount;
  int m_nGrowSize;
};


//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------

template < class T, class I >
CUtlMemory< T, I >::CUtlMemory( int nGrowSize, int nInitAllocationCount ) :
  m_pMemory( 0 ),
  m_nAllocationCount( nInitAllocationCount ), m_nGrowSize( nGrowSize ) {
  ValidateGrowSize( );
  assert( nGrowSize >= 0 );
  if( m_nAllocationCount ) {
	 m_pMemory = ( T* )MemAlloc_Alloc( m_nAllocationCount * sizeof( T ) );
	 //m_pMemory = (T*)Interfaces::m_pMemAlloc->Alloc(m_nAllocationCount * sizeof(T));
  }
}

template < class T, class I >
CUtlMemory< T, I >::CUtlMemory( T* pMemory, int numElements ) :
  m_pMemory( pMemory ),
  m_nAllocationCount( numElements ) {
  // Special marker indicating externally supplied modifyable memory
  m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template < class T, class I >
CUtlMemory< T, I >::CUtlMemory( const T* pMemory, int numElements ) :
  m_pMemory( ( T* )pMemory ),
  m_nAllocationCount( numElements ) {
  // Special marker indicating externally supplied modifyable memory
  m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template < class T, class I >
CUtlMemory< T, I >::~CUtlMemory( ) {
  Purge( );
}

template < class T, class I >
void CUtlMemory< T, I >::Init( int nGrowSize /*= 0*/, int nInitSize /*= 0*/ ) {
  Purge( );

  m_nGrowSize = nGrowSize;
  m_nAllocationCount = nInitSize;
  ValidateGrowSize( );
  assert( nGrowSize >= 0 );
  if( m_nAllocationCount ) {
	 UTLMEMORY_TRACK_ALLOC( );
	 MEM_ALLOC_CREDIT_CLASS( );
	 m_pMemory = ( T* )MemAlloc_Alloc( m_nAllocationCount * sizeof( T ) );
  }
}

//-----------------------------------------------------------------------------
// Fast swap
//-----------------------------------------------------------------------------
template < class T, class I >
void CUtlMemory< T, I >::Swap( CUtlMemory< T, I >& mem ) {
  V_swap( m_nGrowSize, mem.m_nGrowSize );
  V_swap( m_pMemory, mem.m_pMemory );
  V_swap( m_nAllocationCount, mem.m_nAllocationCount );
}

//-----------------------------------------------------------------------------
// Switches the buffer from an external memory buffer to a reallocatable buffer
//-----------------------------------------------------------------------------
template < class T, class I >
void CUtlMemory< T, I >::ConvertToGrowableMemory( int nGrowSize ) {
  if( !IsExternallyAllocated( ) )
	 return;

  m_nGrowSize = nGrowSize;
  if( m_nAllocationCount ) {
	 int nNumBytes = m_nAllocationCount * sizeof( T );
	 T* pMemory = ( T* )MemAlloc_Alloc( nNumBytes );
	 memcpy( pMemory, m_pMemory, nNumBytes );
	 m_pMemory = pMemory;
  } else {
	 m_pMemory = NULL;
  }
}

//-----------------------------------------------------------------------------
// Attaches the buffer to external memory....
//-----------------------------------------------------------------------------
template < class T, class I >
void CUtlMemory< T, I >::SetExternalBuffer( T* pMemory, int numElements ) {
  // Blow away any existing allocated memory
  Purge( );

  m_pMemory = pMemory;
  m_nAllocationCount = numElements;

  // Indicate that we don't own the memory
  m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template < class T, class I >
void CUtlMemory< T, I >::SetExternalBuffer( const T* pMemory, int numElements ) {
  // Blow away any existing allocated memory
  Purge( );

  m_pMemory = const_cast< T* >( pMemory );
  m_nAllocationCount = numElements;

  // Indicate that we don't own the memory
  m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template < class T, class I >
void CUtlMemory< T, I >::AssumeMemory( T* pMemory, int numElements ) {
  // Blow away any existing allocated memory
  Purge( );

  // Simply take the pointer but don't mark us as external
  m_pMemory = pMemory;
  m_nAllocationCount = numElements;
}

template < class T, class I >
void* CUtlMemory< T, I >::DetachMemory( ) {
  if( IsExternallyAllocated( ) )
	 return NULL;

  void* pMemory = m_pMemory;
  m_pMemory = 0;
  m_nAllocationCount = 0;
  return pMemory;
}

template < class T, class I >
inline T* CUtlMemory< T, I >::Detach( ) {
  return ( T* )DetachMemory( );
}

//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------
template < class T, class I >
inline T& CUtlMemory< T, I >::operator[]( I i ) {
  assert( !IsReadOnly( ) );
  // men 
  // assert( IsIdxValid( i ) );
  return m_pMemory[i];
}

template < class T, class I >
inline const T& CUtlMemory< T, I >::operator[]( I i ) const {
  // can you
  // assert( IsIdxValid( i ) );
  return m_pMemory[i];
}

template < class T, class I >
inline T& CUtlMemory< T, I >::Element( I i ) {
  assert( !IsReadOnly( ) );
  // FUCK
  // assert( IsIdxValid( i ) );
  return m_pMemory[i];
}

template < class T, class I >
inline const T& CUtlMemory< T, I >::Element( I i ) const {
  // my balls ?
  // assert( IsIdxValid( i ) );
  return m_pMemory[i];
}

//-----------------------------------------------------------------------------
// is the memory externally allocated?
//-----------------------------------------------------------------------------
template < class T, class I >
bool CUtlMemory< T, I >::IsExternallyAllocated( ) const {
  return ( m_nGrowSize < 0 );
}

//-----------------------------------------------------------------------------
// is the memory read only?
//-----------------------------------------------------------------------------
template < class T, class I >
bool CUtlMemory< T, I >::IsReadOnly( ) const {
  return ( m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER );
}

template < class T, class I >
void CUtlMemory< T, I >::SetGrowSize( int nSize ) {
  assert( !IsExternallyAllocated( ) );
  assert( nSize >= 0 );
  m_nGrowSize = nSize;
  ValidateGrowSize( );
}

//-----------------------------------------------------------------------------
// Gets the base address (can change when adding elements!)
//-----------------------------------------------------------------------------
template < class T, class I >
inline T* CUtlMemory< T, I >::Base( ) {
  assert( !IsReadOnly( ) );
  return m_pMemory;
}

template < class T, class I >
inline const T* CUtlMemory< T, I >::Base( ) const {
  return m_pMemory;
}

//-----------------------------------------------------------------------------
// Size
//-----------------------------------------------------------------------------
template < class T, class I >
inline int CUtlMemory< T, I >::NumAllocated( ) const {
  return m_nAllocationCount;
}

template < class T, class I >
inline int CUtlMemory< T, I >::Count( ) const {
  return m_nAllocationCount;
}

//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------
template < class T, class I >
inline bool CUtlMemory< T, I >::IsIdxValid( I i ) const {
  // GCC warns if I is an unsigned type and we do a ">= 0" against it (since the comparison is always 0).
  // We Get the warning even if we cast inside the expression. It only goes away if we assign to another variable.
  long x = i;
  return ( x >= 0 ) && ( x < m_nAllocationCount );
}

//-----------------------------------------------------------------------------
// Grows the memory
//-----------------------------------------------------------------------------
inline int UtlMemory_CalcNewAllocationCount( int nAllocationCount, int nGrowSize, int nNewSize, int nBytesItem ) {
  if( nGrowSize ) {
	 nAllocationCount = ( ( 1 + ( ( nNewSize - 1 ) / nGrowSize ) ) * nGrowSize );
  } else {
	 if( !nAllocationCount ) {
		// Compute an allocation which is at least as big as a cache line...
		nAllocationCount = ( 31 + nBytesItem ) / nBytesItem;
	 }

	 while( nAllocationCount < nNewSize ) {
	 #ifndef _X360
		nAllocationCount *= 2;
	 #else
		int nNewAllocationCount = ( nAllocationCount * 9 ) / 8; // 12.5 %
		if( nNewAllocationCount > nAllocationCount )
		  nAllocationCount = nNewAllocationCount;
		else
		  nAllocationCount *= 2;
	 #endif
	 }
  }

  return nAllocationCount;
}

template < class T, class I >
void CUtlMemory< T, I >::Grow( int num ) {
  assert( num > 0 );

  if( IsExternallyAllocated( ) ) {
	 // Can't grow a buffer whose memory was externally allocated
	 assert( 0 );
	 return;
  }

  auto oldAllocationCount = m_nAllocationCount;
  // Make sure we have at least numallocated + num allocations.
  // Use the grow rules specified for this memory (in m_nGrowSize)
  int nAllocationRequested = m_nAllocationCount + num;

  int nNewAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof( T ) );

  // if m_nAllocationRequested wraps index type I, recalculate
  if( ( int )( I )nNewAllocationCount < nAllocationRequested ) {
	 if( ( int )( I )nNewAllocationCount == 0 && ( int )( I )( nNewAllocationCount - 1 ) >= nAllocationRequested ) {
		--nNewAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1
	 } else {
		if( ( int )( I )nAllocationRequested != nAllocationRequested ) {
		  // we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
		  assert( 0 );
		  return;
		}
		while( ( int )( I )nNewAllocationCount < nAllocationRequested ) {
		  nNewAllocationCount = ( nNewAllocationCount + nAllocationRequested ) / 2;
		}
	 }
  }

  m_nAllocationCount = nNewAllocationCount;

  if( m_pMemory ) {
	 auto ptr = ( T* )MemAlloc_Alloc( m_nAllocationCount * sizeof( T ) );

	 memcpy( ptr,
		m_pMemory,
		oldAllocationCount * sizeof( T ) );
	 m_pMemory = ( T* )ptr;
  } else {
	 m_pMemory = ( T* )MemAlloc_Alloc( m_nAllocationCount * sizeof( T ) );
  }
}

//-----------------------------------------------------------------------------
// Makes sure we've got at least this much memory
//-----------------------------------------------------------------------------
template < class T, class I >
inline void CUtlMemory< T, I >::EnsureCapacity( int num ) {
  if( m_nAllocationCount >= num )
	 return;

  if( IsExternallyAllocated( ) ) {
	 // Can't grow a buffer whose memory was externally allocated
	 assert( 0 );
	 return;
  }
  m_nAllocationCount = num;

  if( m_pMemory ) {
	 m_pMemory = ( T* )MemAlloc_Realloc( m_pMemory, m_nAllocationCount * sizeof( T ) );
  } else {
	 m_pMemory = ( T* )MemAlloc_Alloc( m_nAllocationCount * sizeof( T ) );
  }
}

//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------
template < class T, class I >
void CUtlMemory< T, I >::Purge( ) {
  if( !IsExternallyAllocated( ) ) {
	 if( m_pMemory ) {
		MemAlloc_Free( ( void* )m_pMemory );
		m_pMemory = 0;
	 }
	 m_nAllocationCount = 0;
  }
}

template < class T, class I >
void CUtlMemory< T, I >::Purge( int numElements ) {
  assert( numElements >= 0 );

  if( numElements > m_nAllocationCount ) {
	 // Ensure this isn't a grow request in disguise.
	 assert( numElements <= m_nAllocationCount );
	 return;
  }

  // If we have zero elements, simply do a purge:
  if( numElements == 0 ) {
	 Purge( );
	 return;
  }

  if( IsExternallyAllocated( ) ) {
	 // Can't shrink a buffer whose memory was externally allocated, fail silently like purge
	 return;
  }

  // If the number of elements is the same as the allocation count, we are done.
  if( numElements == m_nAllocationCount ) {
	 return;
  }

  if( !m_pMemory ) {
	 // Allocation count is non zero, but memory is null.
	 assert( m_pMemory );
	 return;
  }
  m_nAllocationCount = numElements;
  m_pMemory = ( T* )realloc( m_pMemory, m_nAllocationCount * sizeof( T ) );
}

//-----------------------------------------------------------------------------
// The CUtlMemory class:
// A growable memory class which doubles in size by default.
//-----------------------------------------------------------------------------
template < class T, int nAlignment >
class CUtlMemoryAligned : public CUtlMemory< T > {
public:
  // constructor, destructor
  CUtlMemoryAligned( int nGrowSize = 0, int nInitSize = 0 );
  CUtlMemoryAligned( T* pMemory, int numElements );
  CUtlMemoryAligned( const T* pMemory, int numElements );
  ~CUtlMemoryAligned( );

  // Attaches the buffer to external memory....
  void SetExternalBuffer( T* pMemory, int numElements );
  void SetExternalBuffer( const T* pMemory, int numElements );

  // Grows the memory, so that at least allocated + num elements are allocated
  void Grow( int num = 1 );

  // Makes sure we've got at least this much memory
  void EnsureCapacity( int num );

  // Memory deallocation
  void Purge( );

  // Purge all but the given number of elements (NOT IMPLEMENTED IN CUtlMemoryAligned)
  void Purge( int numElements ) { assert( 0 ); }

private:
  void* Align( const void* pAddr );
};

//-----------------------------------------------------------------------------
// Aligns a pointer
//-----------------------------------------------------------------------------
template < class T, int nAlignment >
void* CUtlMemoryAligned< T, nAlignment >::Align( const void* pAddr ) {
  size_t nAlignmentMask = nAlignment - 1;
  return ( void* )( ( ( size_t )pAddr + nAlignmentMask ) & ( ~nAlignmentMask ) );
}

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------
template < class T, int nAlignment >
CUtlMemoryAligned< T, nAlignment >::CUtlMemoryAligned( int nGrowSize, int nInitAllocationCount ) {
  CUtlMemory< T >::m_pMemory = 0;
  CUtlMemory< T >::m_nAllocationCount = nInitAllocationCount;
  CUtlMemory< T >::m_nGrowSize = nGrowSize;
  this->ValidateGrowSize( );

  // Alignment must be a power of two
  COMPILE_TIME_ASSERT( ( nAlignment & ( nAlignment - 1 ) ) == 0 );
  assert( ( nGrowSize >= 0 ) && ( nGrowSize != CUtlMemory< T >::EXTERNAL_BUFFER_MARKER ) );
  if( CUtlMemory< T >::m_nAllocationCount ) {
	 UTLMEMORY_TRACK_ALLOC( );
	 MEM_ALLOC_CREDIT_CLASS( );
	 CUtlMemory< T >::m_pMemory = ( T* )_aligned_malloc( nInitAllocationCount * sizeof( T ), nAlignment );
  }
}

template < class T, int nAlignment >
CUtlMemoryAligned< T, nAlignment >::CUtlMemoryAligned( T* pMemory, int numElements ) {
  // Special marker indicating externally supplied memory
  CUtlMemory< T >::m_nGrowSize = CUtlMemory< T >::EXTERNAL_BUFFER_MARKER;

  CUtlMemory< T >::m_pMemory = ( T* )Align( pMemory );
  CUtlMemory< T >::m_nAllocationCount = ( ( int )( pMemory + numElements ) - ( int )CUtlMemory< T >::m_pMemory ) / sizeof( T );
}

template < class T, int nAlignment >
CUtlMemoryAligned< T, nAlignment >::CUtlMemoryAligned( const T* pMemory, int numElements ) {
  // Special marker indicating externally supplied memory
  CUtlMemory< T >::m_nGrowSize = CUtlMemory< T >::EXTERNAL_CONST_BUFFER_MARKER;

  CUtlMemory< T >::m_pMemory = ( T* )Align( pMemory );
  CUtlMemory< T >::m_nAllocationCount = ( ( int )( pMemory + numElements ) - ( int )CUtlMemory< T >::m_pMemory ) / sizeof( T );
}

template < class T, int nAlignment >
CUtlMemoryAligned< T, nAlignment >::~CUtlMemoryAligned( ) {
  Purge( );
}

//-----------------------------------------------------------------------------
// Attaches the buffer to external memory....
//-----------------------------------------------------------------------------
template < class T, int nAlignment >
void CUtlMemoryAligned< T, nAlignment >::SetExternalBuffer( T* pMemory, int numElements ) {
  // Blow away any existing allocated memory
  Purge( );

  CUtlMemory< T >::m_pMemory = ( T* )Align( pMemory );
  CUtlMemory< T >::m_nAllocationCount = ( ( int )( pMemory + numElements ) - ( int )CUtlMemory< T >::m_pMemory ) / sizeof( T );

  // Indicate that we don't own the memory
  CUtlMemory< T >::m_nGrowSize = CUtlMemory< T >::EXTERNAL_BUFFER_MARKER;
}

template < class T, int nAlignment >
void CUtlMemoryAligned< T, nAlignment >::SetExternalBuffer( const T* pMemory, int numElements ) {
  // Blow away any existing allocated memory
  Purge( );

  CUtlMemory< T >::m_pMemory = ( T* )Align( pMemory );
  CUtlMemory< T >::m_nAllocationCount = ( ( int )( pMemory + numElements ) - ( int )CUtlMemory< T >::m_pMemory ) / sizeof( T );

  // Indicate that we don't own the memory
  CUtlMemory< T >::m_nGrowSize = CUtlMemory< T >::EXTERNAL_CONST_BUFFER_MARKER;
}

//-----------------------------------------------------------------------------
// Grows the memory
//-----------------------------------------------------------------------------
template < class T, int nAlignment >
void CUtlMemoryAligned< T, nAlignment >::Grow( int num ) {
  assert( num > 0 );

  if( this->IsExternallyAllocated( ) ) {
	 // Can't grow a buffer whose memory was externally allocated
	 assert( 0 );
	 return;
  }

  UTLMEMORY_TRACK_FREE( );

  // Make sure we have at least numallocated + num allocations.
  // Use the grow rules specified for this memory (in m_nGrowSize)
  int nAllocationRequested = CUtlMemory< T >::m_nAllocationCount + num;

  CUtlMemory< T >::m_nAllocationCount = UtlMemory_CalcNewAllocationCount( CUtlMemory< T >::m_nAllocationCount, CUtlMemory< T >::m_nGrowSize, nAllocationRequested, sizeof( T ) );

  UTLMEMORY_TRACK_ALLOC( );

  if( CUtlMemory< T >::m_pMemory ) {
	 MEM_ALLOC_CREDIT_CLASS( );
	 CUtlMemory< T >::m_pMemory = ( T* )MemAlloc_ReallocAligned( CUtlMemory< T >::m_pMemory, CUtlMemory< T >::m_nAllocationCount * sizeof( T ), nAlignment );
	 assert( CUtlMemory< T >::m_pMemory );
  } else {
	 MEM_ALLOC_CREDIT_CLASS( );
	 CUtlMemory< T >::m_pMemory = ( T* )MemAlloc_AllocAligned( CUtlMemory< T >::m_nAllocationCount * sizeof( T ), nAlignment );
	 assert( CUtlMemory< T >::m_pMemory );
  }
}

//-----------------------------------------------------------------------------
// Makes sure we've got at least this much memory
//-----------------------------------------------------------------------------
template < class T, int nAlignment >
inline void CUtlMemoryAligned< T, nAlignment >::EnsureCapacity( int num ) {
  if( CUtlMemory< T >::m_nAllocationCount >= num )
	 return;

  if( this->IsExternallyAllocated( ) ) {
	 // Can't grow a buffer whose memory was externally allocated
	 assert( 0 );
	 return;
  }

  UTLMEMORY_TRACK_FREE( );

  CUtlMemory< T >::m_nAllocationCount = num;

  UTLMEMORY_TRACK_ALLOC( );

  if( CUtlMemory< T >::m_pMemory ) {
	 MEM_ALLOC_CREDIT_CLASS( );
	 CUtlMemory< T >::m_pMemory = ( T* )MemAlloc_ReallocAligned( CUtlMemory< T >::m_pMemory, CUtlMemory< T >::m_nAllocationCount * sizeof( T ), nAlignment );
  } else {
	 MEM_ALLOC_CREDIT_CLASS( );
	 CUtlMemory< T >::m_pMemory = ( T* )MemAlloc_AllocAligned( CUtlMemory< T >::m_nAllocationCount * sizeof( T ), nAlignment );
  }
}

//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------
template < class T, int nAlignment >
void CUtlMemoryAligned< T, nAlignment >::Purge( ) {
  if( !this->IsExternallyAllocated( ) ) {
	 if( CUtlMemory< T >::m_pMemory ) {
		UTLMEMORY_TRACK_FREE( );
		MemAlloc_FreeAligned( CUtlMemory< T >::m_pMemory );
		CUtlMemory< T >::m_pMemory = 0;
	 }
	 CUtlMemory< T >::m_nAllocationCount = 0;
  }
}

```

`CSGO SDK/SDK/Valve/UtlVector.hpp`:

```hpp
#pragma once

#include <cstring>
#include "UtlMemory.hpp"

template < class T, class A = CUtlMemory< T > >
class CUtlVector {
	typedef A CAllocator;

public:
	typedef T ElemType_t;

	// constructor, destructor
	CUtlVector( int growSize = 0, int initSize = 0 );
	CUtlVector( T* pMemory, int allocationCount, int numElements = 0 );
	~CUtlVector( );

	// Copy the array.
	CUtlVector< T, A >& operator=( const CUtlVector< T, A >& other );

	// element access
	T& operator[]( int i );
	const T& operator[]( int i ) const;
	T& Element( int i );
	const T& Element( int i ) const;
	T& Head( );
	const T& Head( ) const;
	T& Tail( );
	const T& Tail( ) const;

	// Gets the base address (can change when adding elements!)
	T* Base( ) { return m_Memory.Base( ); }
	const T* Base( ) const { return m_Memory.Base( ); }
	// Returns the number of elements in the vector
	int Count( ) const;
	// Is element index valid?
	bool IsValidIndex( int i ) const;
	static int InvalidIndex( );
	// Adds an element, uses default constructor
	int AddToHead( );
	int AddToTail( );
	int InsertBefore( int elem );
	int InsertAfter( int elem );
	// Adds an element, uses copy constructor
	int AddToHead( const T& src );
	int AddToTail( const T& src );
	int InsertBefore( int elem, const T& src );
	int InsertAfter( int elem, const T& src );
	// Adds multiple elements, uses default constructor
	int AddMultipleToHead( int num );
	int AddMultipleToTail( int num );
	int AddMultipleToTail( int num, const T* pToCopy );
	int InsertMultipleBefore( int elem, int num );
	int InsertMultipleBefore( int elem, int num, const T* pToCopy );
	int InsertMultipleAfter( int elem, int num );
	// Calls RemoveAll() then AddMultipleToTail.
	void SetSize( int size );
	void SetCount( int count );
	void SetCountNonDestructively( int count );  //sets count by adding or removing elements to tail TODO: This should probably be the default behavior for SetCount
	void CopyArray( const T* pArray, int size ); //Calls SetSize and copies each element.
																// Fast swap
	void Swap( CUtlVector< T, A >& vec );
	// Add the specified array to the tail.
	int AddVectorToTail( CUtlVector< T, A > const& src );
	// Finds an element (element needs operator== defined)
	int GetOffset( const T& src ) const;
	void FillWithValue( const T& src );
	bool HasElement( const T& src ) const;
	// Makes sure we have enough memory allocated to store a requested # of elements
	void EnsureCapacity( int num );
	// Makes sure we have at least this many elements
	void EnsureCount( int num );
	// Element removal
	void FastRemove( int elem );              // doesn't preserve order
	void Remove( int elem );                  // preserves order, shifts elements
	bool FindAndRemove( const T& src );       // removes first occurrence of src, preserves order, shifts elements
	bool FindAndFastRemove( const T& src );   // removes first occurrence of src, doesn't preserve order
	void RemoveMultiple( int elem, int num ); // preserves order, shifts elements
	void RemoveMultipleFromHead( int num );   // removes num elements from tail
	void RemoveMultipleFromTail( int num );   // removes num elements from tail
	void RemoveAll( );                         // doesn't deallocate memory
	void Purge( );                             // Memory deallocation
															// Purges the list and calls delete on each element in it.
	void PurgeAndDeleteElements( );
	// Compacts the vector to the number of elements actually in use
	void Compact( );
	// Set the size by which it grows when it needs to allocate more memory.
	void SetGrowSize( int size ) { m_Memory.SetGrowSize( size ); }
	int NumAllocated( ) const; // Only use this if you really know what you're doing!
	void Sort( int( __cdecl* pfnCompare )( const T*, const T* ) );

	// Can't copy this unless we explicitly do it!
	CUtlVector( CUtlVector const& vec ) { assert( 0 ); }

protected:
	// Grows the vector
	void GrowVector( int num = 1 );

	// Shifts elements....
	void ShiftElementsRight( int elem, int num = 1 );
	void ShiftElementsLeft( int elem, int num = 1 );

public:
	CAllocator m_Memory;
	int m_Size;

	// For easier access to the elements through the debugger
	// it's in release builds so this can be used in libraries correctly
	T* m_pElements;

	inline void ResetDbgInfo( ) {
		m_pElements = Base( );
	}
};

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------
template < typename T, class A >
inline CUtlVector< T, A >::CUtlVector( int growSize, int initSize ) :
	m_Memory( growSize, initSize ), m_Size( 0 ) {
	ResetDbgInfo( );
}

template < typename T, class A >
inline CUtlVector< T, A >::CUtlVector( T* pMemory, int allocationCount, int numElements ) :
	m_Memory( pMemory, allocationCount ), m_Size( numElements ) {
	ResetDbgInfo( );
}

template < typename T, class A >
inline CUtlVector< T, A >::~CUtlVector( ) {
	Purge( );
}

template < typename T, class A >
inline CUtlVector< T, A >& CUtlVector< T, A >::operator=( const CUtlVector< T, A >& other ) {
	int nCount = other.Count( );
	SetSize( nCount );
	for( int i = 0; i < nCount; i++ ) {
		( *this )[ i ] = other[ i ];
	}
	return *this;
}

//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------
template < typename T, class A >
inline T& CUtlVector< T, A >::operator[]( int i ) {
	assert( i < m_Size );
	return m_Memory[ i ];
}

template < typename T, class A >
inline const T& CUtlVector< T, A >::operator[]( int i ) const {
	assert( i < m_Size );
	return m_Memory[ i ];
}

template < typename T, class A >
inline T& CUtlVector< T, A >::Element( int i ) {
	assert( i < m_Size );
	return m_Memory[ i ];
}

template < typename T, class A >
inline const T& CUtlVector< T, A >::Element( int i ) const {
	assert( i < m_Size );
	return m_Memory[ i ];
}

template < typename T, class A >
inline T& CUtlVector< T, A >::Head( ) {
	assert( m_Size > 0 );
	return m_Memory[ 0 ];
}

template < typename T, class A >
inline const T& CUtlVector< T, A >::Head( ) const {
	assert( m_Size > 0 );
	return m_Memory[ 0 ];
}

template < typename T, class A >
inline T& CUtlVector< T, A >::Tail( ) {
	assert( m_Size > 0 );
	return m_Memory[ m_Size - 1 ];
}

template < typename T, class A >
inline const T& CUtlVector< T, A >::Tail( ) const {
	assert( m_Size > 0 );
	return m_Memory[ m_Size - 1 ];
}

//-----------------------------------------------------------------------------
// Count
//-----------------------------------------------------------------------------
template < typename T, class A >
inline int CUtlVector< T, A >::Count( ) const {
	return m_Size;
}

//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------
template < typename T, class A >
inline bool CUtlVector< T, A >::IsValidIndex( int i ) const {
	return ( i >= 0 ) && ( i < m_Size );
}

//-----------------------------------------------------------------------------
// Returns in invalid index
//-----------------------------------------------------------------------------
template < typename T, class A >
inline int CUtlVector< T, A >::InvalidIndex( ) {
	return -1;
}

//-----------------------------------------------------------------------------
// Grows the vector
//-----------------------------------------------------------------------------
template < typename T, class A >
void CUtlVector< T, A >::GrowVector( int num ) {
	if( m_Size + num > m_Memory.NumAllocated( ) ) {
		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated( ) );
	}

	m_Size += num;
	ResetDbgInfo( );
}

//-----------------------------------------------------------------------------
// Sorts the vector
//-----------------------------------------------------------------------------
template < typename T, class A >
void CUtlVector< T, A >::Sort( int( __cdecl* pfnCompare )( const T*, const T* ) ) {
	typedef int( __cdecl* QSortCompareFunc_t )( const void*, const void* );
	if( Count( ) <= 1 )
		return;

	if( Base( ) ) {
		qsort( Base( ), Count( ), sizeof( T ), ( QSortCompareFunc_t )( pfnCompare ) );
	}
	else {
		assert( 0 );
		// this path is untested
		// if you want to sort vectors that use a non-sequential memory allocator,
		// you'll probably want to patch in a quicksort algorithm here
		// I just threw in this bubble sort to have something just in case...

		for( int i = m_Size - 1; i >= 0; --i ) {
			for( int j = 1; j <= i; ++j ) {
				if( pfnCompare( &Element( j - 1 ), &Element( j ) ) < 0 ) {
					V_swap( Element( j - 1 ), Element( j ) );
				}
			}
		}
	}
}

//-----------------------------------------------------------------------------
// Makes sure we have enough memory allocated to store a requested # of elements
//-----------------------------------------------------------------------------
template < typename T, class A >
void CUtlVector< T, A >::EnsureCapacity( int num ) {
	MEM_ALLOC_CREDIT_CLASS( );
	m_Memory.EnsureCapacity( num );
	ResetDbgInfo( );
}

//-----------------------------------------------------------------------------
// Makes sure we have at least this many elements
//-----------------------------------------------------------------------------
template < typename T, class A >
void CUtlVector< T, A >::EnsureCount( int num ) {
	if( Count( ) < num ) {
		AddMultipleToTail( num - Count( ) );
	}
}

//-----------------------------------------------------------------------------
// Shifts elements
//-----------------------------------------------------------------------------
template < typename T, class A >
void CUtlVector< T, A >::ShiftElementsRight( int elem, int num ) {
	assert( IsValidIndex( elem ) || ( m_Size == 0 ) || ( num == 0 ) );
	int numToMove = m_Size - elem - num;
	if( ( numToMove > 0 ) && ( num > 0 ) )
		memmove( &Element( elem + num ), &Element( elem ), numToMove * sizeof( T ) );
}

template < typename T, class A >
void CUtlVector< T, A >::ShiftElementsLeft( int elem, int num ) {
	assert( IsValidIndex( elem ) || ( m_Size == 0 ) || ( num == 0 ) );
	int numToMove = m_Size - elem - num;
	if( ( numToMove > 0 ) && ( num > 0 ) ) {
		memmove( &Element( elem ), &Element( elem + num ), numToMove * sizeof( T ) );

#ifdef _DEBUG
		memset( &Element( m_Size - num ), 0xDD, num * sizeof( T ) );
#endif
	}
}

//-----------------------------------------------------------------------------
// Adds an element, uses default constructor
//-----------------------------------------------------------------------------
template < typename T, class A >
inline int CUtlVector< T, A >::AddToHead( ) {
	return InsertBefore( 0 );
}

template < typename T, class A >
inline int CUtlVector< T, A >::AddToTail( ) {
	return InsertBefore( m_Size );
}

template < typename T, class A >
inline int CUtlVector< T, A >::InsertAfter( int elem ) {
	return InsertBefore( elem + 1 );
}

template < typename T, class A >
int CUtlVector< T, A >::InsertBefore( int elem ) {
	// Can insert at the end
	assert( ( elem == Count( ) ) || IsValidIndex( elem ) );

	GrowVector( );
	ShiftElementsRight( elem );
	Construct( &Element( elem ) );
	return elem;
}

//-----------------------------------------------------------------------------
// Adds an element, uses copy constructor
//-----------------------------------------------------------------------------
template < typename T, class A >
inline int CUtlVector< T, A >::AddToHead( const T& src ) {
	// Can't insert something that's in the list... reallocation may hose us
	assert( ( Base( ) == NULL ) || ( &src < Base( ) ) || ( &src >= ( Base( ) + Count( ) ) ) );
	return InsertBefore( 0, src );
}

template < typename T, class A >
inline int CUtlVector< T, A >::AddToTail( const T& src ) {
	// Can't insert something that's in the list... reallocation may hose us
	assert( ( Base( ) == NULL ) || ( &src < Base( ) ) || ( &src >= ( Base( ) + Count( ) ) ) );
	return InsertBefore( m_Size, src );
}

template < typename T, class A >
inline int CUtlVector< T, A >::InsertAfter( int elem, const T& src ) {
	// Can't insert something that's in the list... reallocation may hose us
	assert( ( Base( ) == NULL ) || ( &src < Base( ) ) || ( &src >= ( Base( ) + Count( ) ) ) );
	return InsertBefore( elem + 1, src );
}

template < typename T, class A >
int CUtlVector< T, A >::InsertBefore( int elem, const T& src ) {
	// Can't insert something that's in the list... reallocation may hose us
	assert( ( Base( ) == NULL ) || ( &src < Base( ) ) || ( &src >= ( Base( ) + Count( ) ) ) );

	// Can insert at the end
	assert( ( elem == Count( ) ) || IsValidIndex( elem ) );

	GrowVector( );
	ShiftElementsRight( elem );
	CopyConstruct( &Element( elem ), src );
	return elem;
}

//-----------------------------------------------------------------------------
// Adds multiple elements, uses default constructor
//-----------------------------------------------------------------------------
template < typename T, class A >
inline int CUtlVector< T, A >::AddMultipleToHead( int num ) {
	return InsertMultipleBefore( 0, num );
}

template < typename T, class A >
inline int CUtlVector< T, A >::AddMultipleToTail( int num ) {
	return InsertMultipleBefore( m_Size, num );
}

template < typename T, class A >
inline int CUtlVector< T, A >::AddMultipleToTail( int num, const T* pToCopy ) {
	// Can't insert something that's in the list... reallocation may hose us
	assert( ( Base( ) == NULL ) || !pToCopy || ( pToCopy + num <= Base( ) ) || ( pToCopy >= ( Base( ) + Count( ) ) ) );

	return InsertMultipleBefore( m_Size, num, pToCopy );
}

template < typename T, class A >
int CUtlVector< T, A >::InsertMultipleAfter( int elem, int num ) {
	return InsertMultipleBefore( elem + 1, num );
}

template < typename T, class A >
void CUtlVector< T, A >::SetCount( int count ) {
	RemoveAll( );
	AddMultipleToTail( count );
}

template < typename T, class A >
inline void CUtlVector< T, A >::SetSize( int size ) {
	SetCount( size );
}

template < typename T, class A >
void CUtlVector< T, A >::SetCountNonDestructively( int count ) {
	int delta = count - m_Size;
	if( delta > 0 )
		AddMultipleToTail( delta );
	else if( delta < 0 )
		RemoveMultipleFromTail( -delta );
}

template < typename T, class A >
void CUtlVector< T, A >::CopyArray( const T* pArray, int size ) {
	// Can't insert something that's in the list... reallocation may hose us
	assert( ( Base( ) == NULL ) || !pArray || ( Base( ) >= ( pArray + size ) ) || ( pArray >= ( Base( ) + Count( ) ) ) );

	SetSize( size );
	for( int i = 0; i < size; i++ ) {
		( *this )[ i ] = pArray[ i ];
	}
}

template < typename T, class A >
void CUtlVector< T, A >::Swap( CUtlVector< T, A >& vec ) {
	m_Memory.Swap( vec.m_Memory );
	V_swap( m_Size, vec.m_Size );
#ifndef _X360
	V_swap( m_pElements, vec.m_pElements );
#endif
}

template < typename T, class A >
int CUtlVector< T, A >::AddVectorToTail( CUtlVector const& src ) {
	assert( &src != this );

	int base = Count( );

	// Make space.
	int nSrcCount = src.Count( );
	EnsureCapacity( base + nSrcCount );

	// Copy the elements.
	m_Size += nSrcCount;
	for( int i = 0; i < nSrcCount; i++ ) {
		CopyConstruct( &Element( base + i ), src[ i ] );
	}
	return base;
}

template < typename T, class A >
inline int CUtlVector< T, A >::InsertMultipleBefore( int elem, int num ) {
	if( num == 0 )
		return elem;

	// Can insert at the end
	assert( ( elem == Count( ) ) || IsValidIndex( elem ) );

	GrowVector( num );
	ShiftElementsRight( elem, num );

	// Invoke default constructors
	for( int i = 0; i < num; ++i ) {
		Construct( &Element( elem + i ) );
	}

	return elem;
}

template < typename T, class A >
inline int CUtlVector< T, A >::InsertMultipleBefore( int elem, int num, const T* pToInsert ) {
	if( num == 0 )
		return elem;

	// Can insert at the end
#ifdef DEV
	assert( ( elem == Count( ) ) || IsValidIndex( elem ) );
#endif

	GrowVector( num );
	ShiftElementsRight( elem, num );

	// Invoke default constructors
	if( !pToInsert ) {
		for( int i = 0; i < num; ++i ) {
			Construct( &Element( elem + i ) );
		}
	}
	else {
		for( int i = 0; i < num; i++ ) {
			CopyConstruct( &Element( elem + i ), pToInsert[ i ] );
		}
	}

	return elem;
}

//-----------------------------------------------------------------------------
// Finds an element (element needs operator== defined)
//-----------------------------------------------------------------------------
template < typename T, class A >
int CUtlVector< T, A >::GetOffset( const T& src ) const {
	for( int i = 0; i < Count( ); ++i ) {
		if( Element( i ) == src )
			return i;
	}
	return -1;
}

template < typename T, class A >
void CUtlVector< T, A >::FillWithValue( const T& src ) {
	for( int i = 0; i < Count( ); i++ ) {
		Element( i ) = src;
	}
}

template < typename T, class A >
bool CUtlVector< T, A >::HasElement( const T& src ) const {
	return ( GetOffset( src ) >= 0 );
}

//-----------------------------------------------------------------------------
// Element removal
//-----------------------------------------------------------------------------
template < typename T, class A >
void CUtlVector< T, A >::FastRemove( int elem ) {
	assert( IsValidIndex( elem ) );

	Destruct( &Element( elem ) );
	if( m_Size > 0 ) {
		if( elem != m_Size - 1 )
			memcpy( &Element( elem ), &Element( m_Size - 1 ), sizeof( T ) );
		--m_Size;
	}
}

template < typename T, class A >
void CUtlVector< T, A >::Remove( int elem ) {
	Destruct( &Element( elem ) );
	ShiftElementsLeft( elem );
	--m_Size;
}

template < typename T, class A >
bool CUtlVector< T, A >::FindAndRemove( const T& src ) {
	int elem = GetOffset( src );
	if( elem != -1 ) {
		Remove( elem );
		return true;
	}
	return false;
}

template < typename T, class A >
bool CUtlVector< T, A >::FindAndFastRemove( const T& src ) {
	int elem = GetOffset( src );
	if( elem != -1 ) {
		FastRemove( elem );
		return true;
	}
	return false;
}

template < typename T, class A >
void CUtlVector< T, A >::RemoveMultiple( int elem, int num ) {
	assert( elem >= 0 );
	assert( elem + num <= Count( ) );

	for( int i = elem + num; --i >= elem; )
		Destruct( &Element( i ) );

	ShiftElementsLeft( elem, num );
	m_Size -= num;
}

template < typename T, class A >
void CUtlVector< T, A >::RemoveMultipleFromHead( int num ) {
	assert( num <= Count( ) );

	for( int i = num; --i >= 0; )
		Destruct( &Element( i ) );

	ShiftElementsLeft( 0, num );
	m_Size -= num;
}

template < typename T, class A >
void CUtlVector< T, A >::RemoveMultipleFromTail( int num ) {
	assert( num <= Count( ) );

	for( int i = m_Size - num; i < m_Size; i++ )
		Destruct( &Element( i ) );

	m_Size -= num;
}

template < typename T, class A >
void CUtlVector< T, A >::RemoveAll( ) {
	for( int i = m_Size; --i >= 0; ) {
		Destruct( &Element( i ) );
	}

	m_Size = 0;
}

//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------

template < typename T, class A >
inline void CUtlVector< T, A >::Purge( ) {
	RemoveAll( );
	m_Memory.Purge( );
	ResetDbgInfo( );
}

template < typename T, class A >
inline void CUtlVector< T, A >::PurgeAndDeleteElements( ) {
	for( int i = 0; i < m_Size; i++ ) {
		MemAlloc_Free( Element( i ) );
	}
	Purge( );
}

template < typename T, class A >
inline void CUtlVector< T, A >::Compact( ) {
	m_Memory.Purge( m_Size );
}

template < typename T, class A >
inline int CUtlVector< T, A >::NumAllocated( ) const {
	return m_Memory.NumAllocated( );
}

//-----------------------------------------------------------------------------
// Data and memory validation
//-----------------------------------------------------------------------------
#ifdef DBGFLAG_VALIDATE
template < typename T, class A >
void CUtlVector< T, A >::Validate( CValidator& validator, char* pchName ) {
	validator.Push( typeid( *this ).name( ), this, pchName );

	m_Memory.Validate( validator, "m_Memory" );

	validator.Pop( );
}
#endif // DBGFLAG_VALIDATE

// A vector class for storing pointers, so that the elements pointed to by the pointers are deleted
// on exit.
template < class T >
class CUtlVectorAutoPurge : public CUtlVector< T, CUtlMemory< T, int > > {
public:
	~CUtlVectorAutoPurge( void ) {
		this->PurgeAndDeleteElements( );
	}
};

// easy string list class with dynamically allocated strings. For use with V_SplitString, etc.
// Frees the dynamic strings in destructor.
class CUtlStringList : public CUtlVectorAutoPurge< char* > {
public:
	void CopyAndAddToTail( char const* pString ) // clone the string and add to the end
	{
		char* pNewStr = new char[ 1 + strlen( pString ) ];
		strcpy_s( pNewStr, 1 + strlen( pString ), pString );
		AddToTail( pNewStr );
	}

	static int __cdecl SortFunc( char* const* sz1, char* const* sz2 ) {
		return strcmp( *sz1, *sz2 );
	}
};

```

`CSGO SDK/SDK/Valve/characterset.cpp`:

```cpp
//========= Copyright © 1996-2005, Valve Corporation, All rights reserved. ============//
//
// Purpose: 
//
// $Workfile:     $
// $Date:         $
//
//-----------------------------------------------------------------------------
// $Log: $
//
// $NoKeywords: $
//=============================================================================

#include <string.h>
#include "characterset.hpp"

//-----------------------------------------------------------------------------
// Purpose: builds a simple lookup table of a group of important characters
// Input  : *pParseGroup - pointer to the buffer for the group
//			*pGroupString - null terminated list of characters to flag
//-----------------------------------------------------------------------------
void CharacterSetBuild( characterset_t *pSetBuffer, const char *pszSetString ) {
  int i = 0;

  // Test our pointers
  if( !pSetBuffer || !pszSetString )
	 return;

  memset( pSetBuffer->Set, 0, sizeof( pSetBuffer->Set ) );

  while( pszSetString[i] ) {
	 pSetBuffer->Set[pszSetString[i]] = 1;
	 i++;
  }

}

```

`CSGO SDK/SDK/Valve/platform.cpp`:

```cpp
#include "platform.hpp"
#include "../source.hpp"

void* MemAlloc_Alloc( int size ) {
  return Interfaces::m_pMemAlloc->Alloc( size );
}

void *MemAlloc_Realloc( void *pMemBlock, int size ) {
  return Interfaces::m_pMemAlloc->Realloc( pMemBlock, size );
}

void MemAlloc_Free( void* pMemBlock ) {
  Interfaces::m_pMemAlloc->Free( pMemBlock );
}

```

`CSGO SDK/SDK/Valve/platform.hpp`:

```hpp
//===== Copyright © 1996-2005, Valve Corporation, All rights reserved. ======//
//
// Purpose:
//
// $NoKeywords: $
//
//===========================================================================//
#pragma once

#include <malloc.h>
#include <limits.h>
#include <float.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <new.h>

#define COMPILER_MSVC

//-----------------------------------------------------------------------------
// NOTE: All compiler defines are Set up in the base VPC scripts
// COMPILER_MSVC, COMPILER_MSVC32, COMPILER_MSVC64, COMPILER_MSVCX360
// COMPILER_GCC
// The rationale for this is that we need COMPILER_MSVC for the pragma blocks
// #pragma once that occur at the top of all header files, therefore we can't
// place the defines for these in here.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Set up platform defines.
//-----------------------------------------------------------------------------
#ifdef _WIN32
#define IsPlatformLinux()	false
#define IsPlatformPosix()	false
#define IsPlatformOSX()		false
#define IsPlatformPS3()		false
#define IsPlatformWindows() true
#ifndef PLATFORM_WINDOWS
#define PLATFORM_WINDOWS	1
#endif

#ifndef _X360
#define IsPlatformX360() false
#define IsPlatformWindowsPC() true
#define PLATFORM_WINDOWS_PC 1

#ifdef _WIN64
#define IsPlatformWindowsPC64() true
#define IsPlatformWindowsPC32() false
#define PLATFORM_WINDOWS_PC64 1
#else
#define IsPlatformWindowsPC64() false
#define IsPlatformWindowsPC32() true
#define PLATFORM_WINDOWS_PC32 1
#endif

#else // _X360

#define IsPlatformWindowsPC()	false
#define IsPlatformWindowsPC64() false
#define IsPlatformWindowsPC32() false
#define IsPlatformX360()		true
#define PLATFORM_X360 1

#endif // _X360

#elif defined(POSIX)
#define IsPlatformX360()		false
#define IsPlatformPS3()			false
#define IsPlatformWindows()		false
#define IsPlatformWindowsPC()	false
#define IsPlatformWindowsPC64()	false
#define IsPlatformWindowsPC32()	false
#define IsPlatformPosix()		true
#ifndef PLATFORM_POSIX
#define PLATFORM_POSIX 1
#endif

#if defined( LINUX )
#define IsPlatformLinux() true
#define IsPlatformOSX() false
#ifndef PLATFORM_LINUX
#define PLATFORM_LINUX 1
#endif
#elif defined ( OSX )
#define IsPlatformLinux() false
#define IsPlatformOSX() true
#ifndef PLATFORM_OSX
#define PLATFORM_OSX 1
#endif
#else
#define IsPlatformLinux() false
#define IsPlatformOSX() false
#endif

#else
#error
#endif

//-----------------------------------------------------------------------------
// Set up platform type defines.
//-----------------------------------------------------------------------------
#ifdef PLATFORM_X360
#ifndef _CONSOLE
#define _CONSOLE
#endif
#define IsPC()		false
#define IsConsole() true
#else
#define IsPC()		true
#define IsConsole() false
#endif



//-----------------------------------------------------------------------------
// Set up build configuration defines.
//-----------------------------------------------------------------------------
#ifdef _CERT
#define IsCert() true
#else
#define IsCert() false
#endif

#ifdef _DEBUG
#define IsRelease() false
#define IsDebug() true
#else
#define IsRelease() true
#define IsDebug() false
#endif

#ifdef _RETAIL
#define IsRetail() true
#else
#define IsRetail() false
#endif

// Maximum and minimum representable values
#if !defined(PLATFORM_OSX) && !defined(__STDC_LIMIT_MACROS)

#ifndef INT8_MAX
#define  INT8_MAX			SCHAR_MAX
#endif
#ifndef INT16_MAX
#define  INT16_MAX			SHRT_MAX
#endif
#ifndef INT32_MAX
#define  INT32_MAX			LONG_MAX
#endif
#ifndef INT64_MAX
#define  INT64_MAX			(((int64_t)~0) >> 1)
#endif

#ifndef INT8_MIN
#define  INT8_MIN			SCHAR_MIN
#endif
#ifndef INT16_MIN
#define  INT16_MIN			SHRT_MIN
#endif
#ifndef INT32_MIN
#define  INT32_MIN			LONG_MIN
#endif
#ifndef INT64_MIN
#define  INT64_MIN			(((int64_t)1) << 63)
#endif

#ifndef UINT8_MAX
#define  UINT8_MAX			((uint8_t)~0)
#endif
#ifndef UINT16_MAX
#define  UINT16_MAX			((uint16)~0)
#endif
#ifndef UINT32_MAX
#define  UINT32_MAX			((uint32_t)~0)
#endif
#ifndef UINT16_MAX
#define  UINT64_MAX			((uint64_t)~0)
#endif

#ifndef UINT8_MIN
#define  UINT8_MIN			0
#endif
#ifndef UINT16_MIN
#define  UINT16_MIN			0
#endif
#ifndef UINT32_MIN
#define  UINT32_MIN			0
#endif
#ifndef UINT64_MIN
#define  UINT64_MIN			0
#endif

#endif // !PLATFORM_OSX && !__STDC_LIMIT_MACROS

#ifndef  UINT_MIN
#define  UINT_MIN			UINT32_MIN
#endif

#define  FLOAT32_MAX		FLT_MAX
#define  FLOAT64_MAX		DBL_MAX

#ifdef GNUC
#undef offsetof
//#define offsetof( type, var ) __builtin_offsetof( type, var ) 
#define offsetof(s,m)	(size_t)&(((s *)0)->m)
#else
#include <stddef.h>
#undef offsetof
#define offsetof(s,m)	(size_t)&(((s *)0)->m)
#endif


#define  FLOAT32_MIN		FLT_MIN
#define  FLOAT64_MIN		DBL_MIN

//-----------------------------------------------------------------------------
// Long is evil because it's treated differently by different compilers
// Preventing its use is nasty however. This #define, which should be
// turned on in individual VPC files, causes you to include tier0/valve_off.h
// before standard C + windows headers, and include tier0/valve_on.h after
// standard C + windows headers. So, there's some painful overhead to disabling long
//-----------------------------------------------------------------------------
#ifdef DISALLOW_USE_OF_LONG
#define long			long_is_the_devil_stop_using_it_use_int32_or_int64
#endif


//-----------------------------------------------------------------------------
// Various compiler-specific keywords
//-----------------------------------------------------------------------------
#ifdef COMPILER_MSVC

#ifdef FORCEINLINE
#undef FORCEINLINE
#endif
#define STDCALL					__stdcall
#ifndef FASTCALL
#define  FASTCALL			__fastcall
#endif
#define FORCEINLINE				__forceinline
#define FORCEINLINE_TEMPLATE	__forceinline
#define NULLTERMINATED			__nullterminated

// This can be used to ensure the size of pointers to members when declaring
// a pointer type for a class that has only been forward declared
#define SINGLE_INHERITANCE		__single_inheritance
#define MULTIPLE_INHERITANCE	__multiple_inheritance
#define EXPLICIT				explicit
#define NO_VTABLE				__declspec( novtable )

// gcc doesn't allow storage specifiers on explicit template instatiation, but visual studio needs them to avoid link errors.
#define TEMPLATE_STATIC			static

// Used for dll exporting and importing
#define DLL_EXPORT				extern "C" __declspec( dllexport )
#define DLL_IMPORT				extern "C" __declspec( dllimport )

// Can't use extern "C" when DLL exporting a class
#define DLL_CLASS_EXPORT		__declspec( dllexport )
#define DLL_CLASS_IMPORT		__declspec( dllimport )

// Can't use extern "C" when DLL exporting a global
#define DLL_GLOBAL_EXPORT		extern __declspec( dllexport )
#define DLL_GLOBAL_IMPORT		extern __declspec( dllimport )

// Pass hints to the compiler to prevent it from generating unnessecary / stupid code
// in certain situations.  Several compilers other than MSVC also have an equivilent
// construct.
//
// Essentially the 'Hint' is that the condition specified is assumed to be true at
// that point in the compilation.  If '0' is passed, then the compiler assumes that
// any subsequent code in the same 'basic block' is unreachable, and thus usually
// removed.
#define HINT(THE_HINT)			__assume((THE_HINT))

// decls for aligning data
#define DECL_ALIGN(x)			__declspec( align( x ) )

// GCC had a few areas where it didn't construct objects in the same order 
// that Windows does. So when CVProfile::CVProfile() would access g_pMemAlloc,
// it would crash because the allocator wasn't initalized yet.
#define CONSTRUCT_EARLY

#define SELECTANY				__declspec(selectany)

#define RESTRICT				__restrict
#define RESTRICT_FUNC			__declspec(restrict)
#define FMTFUNCTION( a, b )
#define NOINLINE

#if !defined( NO_THREAD_LOCAL )
#define DECL_THREAD_LOCAL		__declspec(thread)
#endif 

#define DISABLE_VC_WARNING( x ) __pragma(warning(disable:4310) )
#define DEFAULT_VC_WARNING( x ) __pragma(warning(default:4310) )


#elif defined ( COMPILER_GCC )

#if (CROSS_PLATFORM_VERSION >= 1) && !defined( PLATFORM_64BITS )
#define  STDCALL			__attribute__ ((__stdcall__))
#else
#define  STDCALL
#define  __stdcall			__attribute__ ((__stdcall__))
#endif

#define  FASTCALL
#ifdef _LINUX_DEBUGGABLE
#define  FORCEINLINE
#else
#define  FORCEINLINE		inline
#endif

// GCC 3.4.1 has a bug in supporting forced inline of templated functions
// this macro lets us not force inlining in that case
#define FORCEINLINE_TEMPLATE	inline
#define SINGLE_INHERITANCE
#define MULTIPLE_INHERITANCE
#define EXPLICIT
#define NO_VTABLE

#define NULLTERMINATED			

#define TEMPLATE_STATIC

// Used for dll exporting and importing
#define DLL_EXPORT				extern "C" __attribute__ ((visibility("default")))
#define DLL_IMPORT				extern "C"

// Can't use extern "C" when DLL exporting a class
#define DLL_CLASS_EXPORT		__attribute__ ((visibility("default")))
#define DLL_CLASS_IMPORT

// Can't use extern "C" when DLL exporting a global
#define DLL_GLOBAL_EXPORT		__attribute__((visibility("default")))
#define DLL_GLOBAL_IMPORT		extern

#define HINT(THE_HINT)			0
#define DECL_ALIGN(x)			__attribute__( ( aligned( x ) ) )
#define CONSTRUCT_EARLY			__attribute__((init_priority(101)))
#define SELECTANY				__attribute__((weak))
#define RESTRICT
#define RESTRICT_FUNC
#define FMTFUNCTION( fmtargnumber, firstvarargnumber ) __attribute__ (( format( printf, fmtargnumber, firstvarargnumber )))
#define NOINLINE				__attribute__ ((noinline))

#if !defined( NO_THREAD_LOCAL )
#define DECL_THREAD_LOCAL		__thread
#endif

#define DISABLE_VC_WARNING( x )
#define DEFAULT_VC_WARNING( x )

#else

#define DECL_ALIGN(x)			/* */
#define SELECTANY				static

#endif

#if defined( GNUC )
// gnuc has the align decoration at the end
#define ALIGN4
#define ALIGN8 
#define ALIGN16
#define ALIGN32
#define ALIGN128

#define ALIGN4_POST DECL_ALIGN(4)
#define ALIGN8_POST DECL_ALIGN(8)
#define ALIGN16_POST DECL_ALIGN(16)
#define ALIGN32_POST DECL_ALIGN(32)
#define ALIGN128_POST DECL_ALIGN(128)
#else
// MSVC has the align at the start of the struct
#define ALIGN4 DECL_ALIGN(4)
#define ALIGN8 DECL_ALIGN(8)
#define ALIGN16 DECL_ALIGN(16)
#define ALIGN32 DECL_ALIGN(32)
#define ALIGN128 DECL_ALIGN(128)

#define ALIGN4_POST
#define ALIGN8_POST
#define ALIGN16_POST
#define ALIGN32_POST
#define ALIGN128_POST
#endif


// This can be used to declare an abstract (interface only) class.
// Classes marked abstract should not be instantiated.  If they are, and access violation will occur.
//
// Example of use:
//
// abstract_class CFoo
// {
//      ...
// }
//
// MSDN __declspec(novtable) documentation: http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/_langref_novtable.asp
//
// Note: NJS: This is not enabled for regular PC, due to not knowing the implications of exporting a class with no no vtable.
//       It's probable that this shouldn't be an issue, but an experiment should be done to verify this.
//
#ifndef COMPILER_MSVCX360
#define abstract_class class
#else
#define abstract_class class NO_VTABLE
#endif


//-----------------------------------------------------------------------------
// Why do we need this? It would be nice to make it die die die
//-----------------------------------------------------------------------------
// Alloca defined for this platform
#if defined( COMPILER_MSVC ) && !defined( WINDED )
#if defined(_M_IX86)
#define __i386__	1
#endif
#endif

#if defined __i386__ && !defined __linux__
#define id386	1
#else
#define id386	0
#endif  // __i386__


//-----------------------------------------------------------------------------
// Disable annoying unhelpful warnings
//-----------------------------------------------------------------------------
#ifdef COMPILER_MSVC
// Remove warnings from warning level 4.
#pragma warning(disable : 4514) // warning C4514: 'acosl' : unreferenced inline function has been removed
#pragma warning(disable : 4100) // warning C4100: 'hwnd' : unreferenced formal parameter
#pragma warning(disable : 4127) // warning C4127: conditional expression is constant
#pragma warning(disable : 4512) // warning C4512: 'InFileRIFF' : assignment operator could not be generated
#pragma warning(disable : 4611) // warning C4611: interaction between '_setjmp' and C++ object destruction is non-portable
#pragma warning(disable : 4710) // warning C4710: function 'x' not inlined
#pragma warning(disable : 4702) // warning C4702: unreachable code
#pragma warning(disable : 4505) // unreferenced local function has been removed
#pragma warning(disable : 4239) // nonstandard extension used : 'argument' ( conversion from class Vector to class Vector& )
#pragma warning(disable : 4097) // typedef-name 'BaseClass' used as synonym for class-name 'CFlexCycler::CBaseFlex'
#pragma warning(disable : 4324) // Padding was added at the end of a structure
#pragma warning(disable : 4244) // type conversion warning.
#pragma warning(disable : 4305)	// truncation from 'const double ' to 'float '
#pragma warning(disable : 4786)	// Disable warnings about long symbol names
#pragma warning(disable : 4250) // 'X' : inherits 'Y::Z' via dominance
#pragma warning(disable : 4201) // nonstandard extension used : nameless struct/union

#if _MSC_VER >= 1300
#pragma warning(disable : 4511)	// Disable warnings about private copy constructors
#pragma warning(disable : 4121)	// warning C4121: 'symbol' : alignment of a member was sensitive to packing
#pragma warning(disable : 4530)	// warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc (disabled due to std headers having exception syntax)
#endif

#if _MSC_VER >= 1400
#pragma warning(disable : 4996)	// functions declared deprecated
#endif

// When we port to 64 bit, we'll have to resolve the int, ptr vs size_t 32/64 bit problems...
#if !defined( COMPILER_MSVC64 )
#if ( CROSS_PLATFORM_VERSION < 1 )
#pragma warning( disable : 4267 )	// conversion from 'size_t' to 'int', possible loss of data
#pragma warning( disable : 4311 )	// pointer truncation from 'char *' to 'int'
#pragma warning( disable : 4312 )	// conversion from 'unsigned int' to 'memhandle_t' of greater size
#endif
#endif

#endif


//-----------------------------------------------------------------------------
// Stack-based allocation related helpers
//-----------------------------------------------------------------------------
#if defined( COMPILER_GCC )

#define stackalloc( _size )		alloca( ALIGN_VALUE( _size, 16 ) )

#ifdef PLATFORM_OSX
#define mallocsize( _p )	( malloc_size( _p ) )
#else
#define mallocsize( _p )	( malloc_usable_size( _p ) )
#endif

#elif defined ( COMPILER_MSVC )

#define stackalloc( _size )		_alloca( ALIGN_VALUE( _size, 16 ) )
#define mallocsize( _p )		( _msize( _p ) )

#endif

#define  stackfree( _p )			0


//-----------------------------------------------------------------------------
// Used to break into the debugger
//-----------------------------------------------------------------------------
#ifdef COMPILER_MSVC64
#define DebuggerBreak()		__debugbreak()
#elif COMPILER_MSVC32
#define DebuggerBreak()		__asm { int 3 }
#elif COMPILER_MSVCX360
#define DebuggerBreak()		DebugBreak()
#elif COMPILER_GCC 
#if defined( PLATFORM_CYGWIN ) || defined( PLATFORM_POSIX )
#define DebuggerBreak()		__asm__( "int $0x3;")
#else
#define DebuggerBreak()		asm( "int3" )
#endif
#endif


//-----------------------------------------------------------------------------
// DLL export for platform utilities
//-----------------------------------------------------------------------------
#ifndef STATIC_TIER0

#ifdef TIER0_DLL_EXPORT
#define PLATFORM_INTERFACE	DLL_EXPORT
#define PLATFORM_OVERLOAD	DLL_GLOBAL_EXPORT
#define PLATFORM_CLASS		DLL_CLASS_EXPORT
#else
#define PLATFORM_INTERFACE	DLL_IMPORT
#define PLATFORM_OVERLOAD	DLL_GLOBAL_IMPORT
#define PLATFORM_CLASS		DLL_CLASS_IMPORT
#endif

#else	// BUILD_AS_DLL

#define PLATFORM_INTERFACE	extern
#define PLATFORM_OVERLOAD
#define PLATFORM_CLASS

#endif	// BUILD_AS_DLL

//-----------------------------------------------------------------------------
// Posix platform helpers
//-----------------------------------------------------------------------------
#ifdef PLATFORM_POSIX

// Visual Studio likes to put an underscore in front of anything that looks like a portable function.
#define _strupr strupr
#define _getcwd getcwd
#define _open open
#define _lseek lseek
#define _read read
#define _close close
#define _vsnprintf vsnprintf
#define _stat stat
#define _O_RDONLY O_RDONLY
#define _stricmp strcasecmp
#define _finite finite
#define _unlink unlink
#define _putenv putenv
#define _chdir chdir
#define _access access
#define _strtoi64 strtoll

#if !defined( _snprintf )	// some vpc's define this on the command line
#define _snprintf snprintf
#endif

#include <alloca.h>
#include <unistd.h>											// Get unlink
#include <errno.h>

#endif // PLATFORM_POSIX


//-----------------------------------------------------------------------------
// Generally useful platform-independent macros (move to another file?)
//-----------------------------------------------------------------------------

// need macro for constant expression
#define ALIGN_VALUE( val, alignment ) ( ( val + alignment - 1 ) & ~( alignment - 1 ) ) 

// Force a function call site -not- to inlined. (useful for profiling)
#define DONT_INLINE(a) (((int)(a)+1)?(a):(a))

// Marks the codepath from here until the next branch entry point as unreachable,
// and asserts if any attempt is made to execute it.
#define UNREACHABLE() { Assert(0); HINT(0); }

// In cases where no default is present or appropriate, this causes MSVC to generate
// as little code as possible, and throw an assertion in debug.
#define NO_DEFAULT default: UNREACHABLE();

// Defines MAX_PATH
#ifndef MAX_PATH
#define MAX_PATH  260
#endif


//-----------------------------------------------------------------------------
// FP exception handling
//-----------------------------------------------------------------------------
//#define CHECK_FLOAT_EXCEPTIONS		1
//#define CHECK_FPU_CONTROL_WORD_SET	1	// x360 only

#if defined( COMPILER_MSVC64 )

inline void SetupFPUControlWord( ) {
}

#elif defined ( COMPILER_MSVC32 )

inline void SetupFPUControlWordForceExceptions( ) {
  // use local to Get and store control word
  uint16 tmpCtrlW;
  __asm
  {
	 fnclex						/* clear all current exceptions */
	 fnstcw word ptr[tmpCtrlW]	/* Get current control word */
	 and [tmpCtrlW], 0FCC0h		/* Keep infinity control + rounding control */
	 or [tmpCtrlW], 0230h		/* Set to 53-bit, mask only inexact, underflow */
	 fldcw word ptr[tmpCtrlW]	/* put new control word in FPU */
  }
}

#ifdef CHECK_FLOAT_EXCEPTIONS

inline void SetupFPUControlWord( ) {
  SetupFPUControlWordForceExceptions( );
}

#else

inline void SetupFPUControlWord( ) {
  // use local to Get and store control word
  uint16 tmpCtrlW;
  __asm
  {
	 fnstcw word ptr[tmpCtrlW]	/* Get current control word */
	 and [tmpCtrlW], 0FCC0h		/* Keep infinity control + rounding control */
	 or [tmpCtrlW], 023Fh		/* Set to 53-bit, mask only inexact, underflow */
	 fldcw word ptr[tmpCtrlW]	/* put new control word in FPU */
  }
}

#endif

#elif defined ( COMPILER_GCC )

inline void SetupFPUControlWord( ) {
  __volatile unsigned short int __cw;
  __asm __volatile( "fnstcw %0" : "=m" ( __cw ) );
  __cw = __cw & 0x0FCC0;	// keep infinity control, keep rounding mode
  __cw = __cw | 0x023F;	// Set 53-bit, no exceptions
  __asm __volatile( "fldcw %0" : : "m" ( __cw ) );
}

#elif defined( COMPILER_MSVCX360 )

#ifdef CHECK_FPU_CONTROL_WORD_SET
FORCEINLINE bool IsFPUControlWordSet( ) {
  float f = 0.996f;
  union
  {
	 double flResult;
	 int pResult[2];
  };
  flResult = __fctiw( f );
  return ( pResult[1] == 1 );
}
#else
#define IsFPUControlWordSet() true
#endif

inline void SetupFPUControlWord( ) {
  // Set round-to-nearest in FPSCR
  // (cannot assemble, must use op-code form)
  __emit( 0xFF80010C );	// mtfsfi  7,0

								// Favour compatibility over speed (make sure the VPU Set to Java-compliant mode)
								// NOTE: the VPU *always* uses round-to-nearest
  __vector4  a = { 0.0f, 0.0f, 0.0f, 0.0f };
  a;				//	Avoid compiler warning
  __asm
  {
	 mtvscr a;	// Clear the Vector Status & Control Register to zero
  }
}

#endif // COMPILER_MSVCX360


//-----------------------------------------------------------------------------
// Purpose: Standard functions for handling endian-ness
//-----------------------------------------------------------------------------

//-------------------------------------
// Basic swaps
//-------------------------------------

template <typename T>
inline T WordSwapC( T w ) {
  uint16 temp;

  temp = ( ( *( ( uint16 * )&w ) & 0xff00 ) >> 8 );
  temp |= ( ( *( ( uint16 * )&w ) & 0x00ff ) << 8 );

  return *( ( T* )&temp );
}

template <typename T>
inline T DWordSwapC( T dw ) {
  uint32_t temp;

  temp = *( ( uint32_t * )&dw ) >> 24;
  temp |= ( ( *( ( uint32_t * )&dw ) & 0x00FF0000 ) >> 8 );
  temp |= ( ( *( ( uint32_t * )&dw ) & 0x0000FF00 ) << 8 );
  temp |= ( ( *( ( uint32_t * )&dw ) & 0x000000FF ) << 24 );

  return *( ( T* )&temp );
}

//-------------------------------------
// Fast swaps
//-------------------------------------

#if defined( COMPILER_MSVCX360 )

#define WordSwap  WordSwap360Intr
#define DWordSwap DWordSwap360Intr

template <typename T>
inline T WordSwap360Intr( T w ) {
  T output;
  __storeshortbytereverse( w, 0, &output );
  return output;
}

template <typename T>
inline T DWordSwap360Intr( T dw ) {
  T output;
  __storewordbytereverse( dw, 0, &output );
  return output;
}

#elif defined( COMPILER_MSVC32 )

#define WordSwap  WordSwapAsm
#define DWordSwap DWordSwapAsm

#pragma warning(push)
#pragma warning (disable:4035) // no return value

template <typename T>
inline T WordSwapAsm( T w ) {
  __asm
  {
	 mov ax, w
	 xchg al, ah
  }
}

template <typename T>
inline T DWordSwapAsm( T dw ) {
  __asm
  {
	 mov eax, dw
	 bswap eax
  }
}

#pragma warning(pop)

#else

#define WordSwap  WordSwapC
#define DWordSwap DWordSwapC

#endif

//-------------------------------------
// The typically used methods.
//-------------------------------------

#if defined( _SGI_SOURCE ) || defined( PLATFORM_X360 )
#define	PLAT_BIG_ENDIAN 1
#else
#define PLAT_LITTLE_ENDIAN 1
#endif


// If a swapped float passes through the fpu, the bytes may Get changed.
// Prevent this by swapping floats as DWORDs.
#define SafeSwapFloat( pOut, pIn )	(*((unsigned int*)pOut) = DWordSwap( *((unsigned int*)pIn) ))

#if defined(PLAT_LITTLE_ENDIAN)
#define BigShort( val )				WordSwap( val )
#define BigWord( val )				WordSwap( val )
#define BigLong( val )				DWordSwap( val )
#define BigDWord( val )				DWordSwap( val )
#define LittleShort( val )			( val )
#define LittleWord( val )			( val )
#define LittleLong( val )			( val )
#define LittleDWord( val )			( val )
#define SwapShort( val )			BigShort( val )
#define SwapWord( val )				BigWord( val )
#define SwapLong( val )				BigLong( val )
#define SwapDWord( val )			BigDWord( val )

// Pass floats by pointer for swapping to avoid truncation in the fpu
#define BigFloat( pOut, pIn )		SafeSwapFloat( pOut, pIn )
#define LittleFloat( pOut, pIn )	( *pOut = *pIn )
#define SwapFloat( pOut, pIn )		BigFloat( pOut, pIn )

#elif defined(PLAT_BIG_ENDIAN)

#define BigShort( val )				( val )
#define BigWord( val )				( val )
#define BigLong( val )				( val )
#define BigDWord( val )				( val )
#define LittleShort( val )			WordSwap( val )
#define LittleWord( val )			WordSwap( val )
#define LittleLong( val )			DWordSwap( val )
#define LittleDWord( val )			DWordSwap( val )
#define SwapShort( val )			LittleShort( val )
#define SwapWord( val )				LittleWord( val )
#define SwapLong( val )				LittleLong( val )
#define SwapDWord( val )			LittleDWord( val )

// Pass floats by pointer for swapping to avoid truncation in the fpu
#define BigFloat( pOut, pIn )		( *pOut = *pIn )
#define LittleFloat( pOut, pIn )	SafeSwapFloat( pOut, pIn )
#define SwapFloat( pOut, pIn )		LittleFloat( pOut, pIn )

#else

// @Note (toml 05-02-02): this technique expects the compiler to
// optimize the expression and eliminate the other path. On any new
// platform/compiler this should be tested.
inline short BigShort( short val ) { int test = 1; return ( *( char * )&test == 1 ) ? WordSwap( val ) : val; }
inline uint16 BigWord( uint16 val ) { int test = 1; return ( *( char * )&test == 1 ) ? WordSwap( val ) : val; }
inline long BigLong( long val ) { int test = 1; return ( *( char * )&test == 1 ) ? DWordSwap( val ) : val; }
inline uint32_t BigDWord( uint32_t val ) { int test = 1; return ( *( char * )&test == 1 ) ? DWordSwap( val ) : val; }
inline short LittleShort( short val ) { int test = 1; return ( *( char * )&test == 1 ) ? val : WordSwap( val ); }
inline uint16 LittleWord( uint16 val ) { int test = 1; return ( *( char * )&test == 1 ) ? val : WordSwap( val ); }
inline long LittleLong( long val ) { int test = 1; return ( *( char * )&test == 1 ) ? val : DWordSwap( val ); }
inline uint32_t LittleDWord( uint32_t val ) { int test = 1; return ( *( char * )&test == 1 ) ? val : DWordSwap( val ); }
inline short SwapShort( short val ) { return WordSwap( val ); }
inline uint16 SwapWord( uint16 val ) { return WordSwap( val ); }
inline long SwapLong( long val ) { return DWordSwap( val ); }
inline uint32_t SwapDWord( uint32_t val ) { return DWordSwap( val ); }

// Pass floats by pointer for swapping to avoid truncation in the fpu
inline void BigFloat( float *pOut, const float *pIn ) { int test = 1; ( *( char * )&test == 1 ) ? SafeSwapFloat( pOut, pIn ) : ( *pOut = *pIn ); }
inline void LittleFloat( float *pOut, const float *pIn ) { int test = 1; ( *( char * )&test == 1 ) ? ( *pOut = *pIn ) : SafeSwapFloat( pOut, pIn ); }
inline void SwapFloat( float *pOut, const float *pIn ) { SafeSwapFloat( pOut, pIn ); }

#endif

inline uint32_t LoadLittleDWord( uint32_t *base, unsigned int dwordIndex ) {
  return LittleDWord( base[dwordIndex] );
}

inline void StoreLittleDWord( uint32_t *base, unsigned int dwordIndex, uint32_t dword ) {
  base[dwordIndex] = LittleDWord( dword );
}

// Protect against bad auto operator=
#define DISALLOW_OPERATOR_EQUAL( _classname )			\
	private:											\
		_classname &operator=( const _classname & );	\
	public:

// Define a reasonable operator=
#define IMPLEMENT_OPERATOR_EQUAL( _classname )			\
	public:												\
		_classname &operator=( const _classname &src )	\
		{												\
			memcpy( this, &src, sizeof(_classname) );	\
			return *this;								\
		}

#if _X360
#define Plat_FastMemset XMemSet
#define Plat_FastMemcpy XMemCpy
#else
#define Plat_FastMemset memset
#define Plat_FastMemcpy memcpy
#endif

//-----------------------------------------------------------------------------
// XBOX Components valid in PC compilation space
//-----------------------------------------------------------------------------

#define XBOX_DVD_SECTORSIZE			2048
#define XBOX_DVD_ECC_SIZE			32768 // driver reads in quantum ECC blocks
#define XBOX_HDD_SECTORSIZE			512

// Custom windows messages for Xbox input
#define WM_XREMOTECOMMAND					(WM_USER + 100)
#define WM_XCONTROLLER_KEY					(WM_USER + 101)
#define WM_SYS_UI							(WM_USER + 102)
#define WM_SYS_SIGNINCHANGED				(WM_USER + 103)
#define WM_SYS_STORAGEDEVICESCHANGED		(WM_USER + 104)
#define WM_SYS_PROFILESETTINGCHANGED		(WM_USER + 105)
#define WM_SYS_MUTELISTCHANGED				(WM_USER + 106)
#define WM_SYS_INPUTDEVICESCHANGED			(WM_USER + 107)
#define WM_SYS_INPUTDEVICECONFIGCHANGED		(WM_USER + 108)
#define WM_LIVE_CONNECTIONCHANGED			(WM_USER + 109)
#define WM_LIVE_INVITE_ACCEPTED				(WM_USER + 110)
#define WM_LIVE_LINK_STATE_CHANGED			(WM_USER + 111)
#define WM_LIVE_CONTENT_INSTALLED			(WM_USER + 112)
#define WM_LIVE_MEMBERSHIP_PURCHASED		(WM_USER + 113)
#define WM_LIVE_VOICECHAT_AWAY				(WM_USER + 114)
#define WM_LIVE_PRESENCE_CHANGED			(WM_USER + 115)
#define WM_FRIENDS_PRESENCE_CHANGED			(WM_USER + 116)
#define WM_FRIENDS_FRIEND_ADDED				(WM_USER + 117)
#define WM_FRIENDS_FRIEND_REMOVED			(WM_USER + 118)
#define WM_CUSTOM_GAMEBANNERPRESSED			(WM_USER + 119)
#define WM_CUSTOM_ACTIONPRESSED				(WM_USER + 120)
#define WM_XMP_STATECHANGED					(WM_USER + 121)
#define WM_XMP_PLAYBACKBEHAVIORCHANGED		(WM_USER + 122)
#define WM_XMP_PLAYBACKCONTROLLERCHANGED	(WM_USER + 123)

inline const char *GetPlatformExt( void ) {
  return IsPlatformX360( ) ? ".360" : "";
}

// flat view, 6 hw threads
#define XBOX_PROCESSOR_0			( 1<<0 )
#define XBOX_PROCESSOR_1			( 1<<1 )
#define XBOX_PROCESSOR_2			( 1<<2 )
#define XBOX_PROCESSOR_3			( 1<<3 )
#define XBOX_PROCESSOR_4			( 1<<4 )
#define XBOX_PROCESSOR_5			( 1<<5 )

// core view, 3 cores with 2 hw threads each
#define XBOX_CORE_0_HWTHREAD_0		XBOX_PROCESSOR_0
#define XBOX_CORE_0_HWTHREAD_1		XBOX_PROCESSOR_1
#define XBOX_CORE_1_HWTHREAD_0		XBOX_PROCESSOR_2
#define XBOX_CORE_1_HWTHREAD_1		XBOX_PROCESSOR_3
#define XBOX_CORE_2_HWTHREAD_0		XBOX_PROCESSOR_4
#define XBOX_CORE_2_HWTHREAD_1		XBOX_PROCESSOR_5

//-----------------------------------------------------------------------------
// Include additional dependant header components.
//-----------------------------------------------------------------------------
#if defined( PLATFORM_X360 )
#include "xbox/xbox_core.h"
#endif

//-----------------------------------------------------------------------------
// Methods to invoke the constructor, copy constructor, and destructor
//-----------------------------------------------------------------------------

template <class T>
inline T* Construct( T* pMemory ) {
  return ::new( pMemory ) T;
}

template <class T, typename ARG1>
inline T* Construct( T* pMemory, ARG1 a1 ) {
  return ::new( pMemory ) T( a1 );
}

template <class T, typename ARG1, typename ARG2>
inline T* Construct( T* pMemory, ARG1 a1, ARG2 a2 ) {
  return ::new( pMemory ) T( a1, a2 );
}

template <class T, typename ARG1, typename ARG2, typename ARG3>
inline T* Construct( T* pMemory, ARG1 a1, ARG2 a2, ARG3 a3 ) {
  return ::new( pMemory ) T( a1, a2, a3 );
}

template <class T, typename ARG1, typename ARG2, typename ARG3, typename ARG4>
inline T* Construct( T* pMemory, ARG1 a1, ARG2 a2, ARG3 a3, ARG4 a4 ) {
  return ::new( pMemory ) T( a1, a2, a3, a4 );
}

template <class T, typename ARG1, typename ARG2, typename ARG3, typename ARG4, typename ARG5>
inline T* Construct( T* pMemory, ARG1 a1, ARG2 a2, ARG3 a3, ARG4 a4, ARG5 a5 ) {
  return ::new( pMemory ) T( a1, a2, a3, a4, a5 );
}

template <class T>
inline T* CopyConstruct( T* pMemory, T const& src ) {
  return ::new( pMemory ) T( src );
}

template <class T>
inline void Destruct( T* pMemory ) {
  pMemory->~T( );

#ifdef _DEBUG
  memset( pMemory, 0xDD, sizeof( T ) );
#endif
}


//
// GET_OUTER()
//
// A platform-independent way for a contained class to Get a pointer to its
// owner. If you know a class is exclusively used in the context of some
// "outer" class, this is a much more space efficient way to Get at the outer
// class than having the inner class store a pointer to it.
//
//	class COuter
//	{
//		class CInner // Note: this does not need to be a nested class to work
//		{
//			void PrintAddressOfOuter()
//			{
//				printf( "Outer is at 0x%x\n", GET_OUTER( COuter, m_Inner ) );
//			}
//		};
//
//		CInner m_Inner;
//		friend class CInner;
//	};

#define GET_OUTER( OuterType, OuterMember ) \
   ( ( OuterType * ) ( (uint8_t *)this - offsetof( OuterType, OuterMember ) ) )


/*	TEMPLATE_FUNCTION_TABLE()

(Note added to platform.h so platforms that correctly support templated
functions can handle portions as templated functions rather than wrapped
functions)

Helps automate the process of creating an array of function
templates that are all specialized by a single integer.
This sort of thing is often useful in optimization work.

For example, using TEMPLATE_FUNCTION_TABLE, this:

TEMPLATE_FUNCTION_TABLE(int, Function, ( int blah, int blah ), 10)
{
return argument * argument;
}

is equivilent to the following:

(NOTE: the function has to be wrapped in a class due to code
generation bugs involved with directly specializing a function
based on a constant.)

template<int argument>
class FunctionWrapper
{
public:
int Function( int blah, int blah )
{
return argument*argument;
}
}

typedef int (*FunctionType)( int blah, int blah );

class FunctionName
{
public:
enum { count = 10 };
FunctionType functions[10];
};

FunctionType FunctionName::functions[] =
{
FunctionWrapper<0>::Function,
FunctionWrapper<1>::Function,
FunctionWrapper<2>::Function,
FunctionWrapper<3>::Function,
FunctionWrapper<4>::Function,
FunctionWrapper<5>::Function,
FunctionWrapper<6>::Function,
FunctionWrapper<7>::Function,
FunctionWrapper<8>::Function,
FunctionWrapper<9>::Function
};
*/

PLATFORM_INTERFACE bool vtune( bool resume );


#define TEMPLATE_FUNCTION_TABLE(RETURN_TYPE, NAME, ARGS, COUNT)			  \
                                                                      \
typedef RETURN_TYPE (FASTCALL *__Type_##NAME) ARGS;						        \
																		                                  \
template<const int nArgument>											                    \
struct __Function_##NAME												                      \
{																		                                  \
	static RETURN_TYPE FASTCALL Run ARGS;								                \
};																		                                \
																		                                  \
template <const int i>														                    \
struct __MetaLooper_##NAME : __MetaLooper_##NAME<i-1>					        \
{																		                                  \
	__Type_##NAME func;													                        \
	inline __MetaLooper_##NAME() { func = __Function_##NAME<i>::Run; }	\
};																		                                \
																		                                  \
template<>																                            \
struct __MetaLooper_##NAME<0>											                    \
{																		                                  \
	__Type_##NAME func;													                        \
	inline __MetaLooper_##NAME() { func = __Function_##NAME<0>::Run; }	\
};																		                                \
																		                                  \
class NAME																                            \
{																		                                  \
private:																                              \
    static const __MetaLooper_##NAME<COUNT> m;							          \
public:																	                              \
	enum { count = COUNT };												                      \
	static const __Type_##NAME* functions;								              \
};																		                                \
const __MetaLooper_##NAME<COUNT> NAME::m;								              \
const __Type_##NAME* NAME::functions = (__Type_##NAME*)&m;				    \
template<const int nArgument>													                \
RETURN_TYPE FASTCALL __Function_##NAME<nArgument>::Run ARGS


#define LOOP_INTERCHANGE(BOOLEAN, CODE)\
	if( (BOOLEAN) )\
	{\
		CODE;\
	} else\
	{\
		CODE;\
	}

#ifdef COMPILER_MSVC
FORCEINLINE uint32_t RotateBitsLeft32( uint32_t nValue, int nRotateBits ) {
  return _rotl( nValue, nRotateBits );
}
FORCEINLINE uint64_t RotateBitsLeft64( uint64_t nValue, int nRotateBits ) {
  return _rotl64( nValue, nRotateBits );
}
FORCEINLINE uint32_t RotateBitsRight32( uint32_t nValue, int nRotateBits ) {
  return _rotr( nValue, nRotateBits );
}
FORCEINLINE uint64_t RotateBitsRight64( uint64_t nValue, int nRotateBits ) {
  return _rotr64( nValue, nRotateBits );
}
#endif

void *MemAlloc_Alloc( int size );
void *MemAlloc_Realloc( void *pMemBlock, int size );
void MemAlloc_Free( void *pMemBlock );

```

`CSGO SDK/SDK/Valve/qangle.cpp`:

```cpp
#include "qangle.hpp"
#include "vector.hpp"

QAngle::QAngle( ) {
   this->Set( );
}

QAngle::QAngle( float x, float y, float z ) {
   this->Set( x, y, z );
}

QAngle::QAngle( const QAngle& v ) {
   this->Set( v.x, v.y, v.z );
}

QAngle::QAngle( const float* v ) {
   this->Set( v[ 0 ], v[ 1 ], v[ 2 ] );
}

void QAngle::Set( float x /*= 0.0f*/, float y /*= 0.0f */, float z /*= 0.0f*/ ) {
   this->x = x;
   this->y = y;
   this->z = z;
}

void QAngle::Normalize( ) {
   AngleNormalize( this->x );
   AngleNormalize( this->y );
   AngleNormalize( this->z );
}

void QAngle::Clamp( ) {
   Normalize( );

   LimitValue( this->x, -89.0f, 89.0f );
   LimitValue( this->y, -180.0f, 180.0f );
   LimitValue( this->z, -50.0f, 50.0f );
}

bool QAngle::IsZero( float tolerance /*= 0.01f */ ) {
   return ( this->x > -tolerance && this->x < tolerance &&
	  this->y > -tolerance && this->y < tolerance &&
	  this->z > -tolerance && this->z < tolerance );
}

bool QAngle::AngleAreEqual( QAngle angle, float tolerance ) {
   if ( std::fabsf( this->x - angle.x ) > tolerance )
	  return false;
   if ( std::fabsf( this->y - angle.y ) > tolerance )
	  return false;
   return ( std::fabsf( this->z - angle.z ) <= tolerance );
}

QAngle QAngle::Normalized( ) {
   QAngle copy( *this );
   copy.Normalize( );
   return copy;
}

QAngle QAngle::Clamped( ) {
   QAngle copy( *this );
   copy.Clamp( );
   return copy;
}

Vector QAngle::ToVectors( Vector* side /*= nullptr*/, Vector* up /*= nullptr*/ ) {
   float  rad_pitch = ToRadians( this->x );
   float  rad_yaw = ToRadians( this->y );
   float sin_pitch;
   float sin_yaw;
   float sin_roll;
   float cos_pitch;
   float cos_yaw;
   float cos_roll;

   DirectX::XMScalarSinCos( &sin_pitch, &cos_pitch, rad_pitch );
   DirectX::XMScalarSinCos( &sin_yaw, &cos_yaw, rad_yaw );

   if ( side || up )
	  DirectX::XMScalarSinCos( &sin_roll, &cos_roll, ToRadians( this->z ) );

   if ( side ) {
	  side->x = -1.0f * sin_roll * sin_pitch * cos_yaw + -1.0f * cos_roll * -sin_yaw;
	  side->y = -1.0f * sin_roll * sin_pitch * sin_yaw + -1.0f * cos_roll * cos_yaw;
	  side->z = -1.0f * sin_roll * cos_pitch;
   }

   if ( up ) {
	  up->x = cos_roll * sin_pitch * cos_yaw + -sin_roll * -sin_yaw;
	  up->y = cos_roll * sin_pitch * sin_yaw + -sin_roll * cos_yaw;
	  up->z = cos_roll * cos_pitch;
   }

   return { cos_pitch * cos_yaw, cos_pitch * sin_yaw, -sin_pitch };
}

Vector QAngle::ToVectorsTranspose( Vector* side /*= nullptr*/, Vector* up /*= nullptr*/ ) {
   auto rad_pitch = ToRadians( this->x );
   auto rad_yaw = ToRadians( this->y );
   auto rad_roll = ToRadians( this->z );

   auto sin_pitch = std::sin( rad_pitch );
   auto sin_yaw = std::sin( rad_yaw );
   auto sin_roll = std::sin( rad_roll );

   auto cos_pitch = std::cos( rad_pitch );
   auto cos_yaw = std::cos( rad_yaw );
   auto cos_roll = std::cos( rad_roll );

   if ( side ) {
	  side->x = cos_pitch * sin_yaw;
	  side->y = sin_roll * sin_pitch * sin_yaw + cos_roll * cos_yaw;
	  side->z = cos_roll * sin_pitch * sin_yaw + -sin_roll * cos_yaw;
   }

   if ( up ) {
	  up->x = -sin_pitch;
	  up->y = sin_roll * cos_pitch;
	  up->z = cos_roll * cos_pitch;
   }

   return { cos_pitch * cos_yaw,
			 sin_roll * sin_pitch * cos_yaw + cos_roll * -sin_yaw,
			 cos_roll * sin_pitch * cos_yaw + -sin_roll * -sin_yaw };
}

float QAngle::operator [] ( const std::uint32_t index ) {
   return ( ( ( float* ) this )[ index ] );
}

const float QAngle::operator [] ( const std::uint32_t index ) const {
   return ( ( ( const float* ) this )[ index ] );
}

QAngle& QAngle::operator = ( const QAngle& v ) {
   this->Set( v.x, v.y, v.z );

   return ( *this );
}

QAngle& QAngle::operator = ( const float* v ) {
   this->Set( v[ 0 ], v[ 1 ], v[ 2 ] );

   return ( *this );
}

QAngle& QAngle::operator += ( const QAngle& v ) {
   this->x += v.x;
   this->y += v.y;
   this->z += v.z;

   return ( *this );
}

QAngle& QAngle::operator -= ( const QAngle& v ) {
   this->x -= v.x;
   this->y -= v.y;
   this->z -= v.z;

   return ( *this );
}

QAngle& QAngle::operator *= ( const QAngle& v ) {
   this->x *= v.x;
   this->y *= v.y;
   this->z *= v.z;

   return ( *this );
}

QAngle& QAngle::operator /= ( const QAngle& v ) {
   this->x /= v.x;
   this->y /= v.y;
   this->z /= v.z;

   return ( *this );
}

QAngle& QAngle::operator += ( float fl ) {
   this->x += fl;
   this->y += fl;
   this->z += fl;

   return ( *this );
}

QAngle& QAngle::operator -= ( float fl ) {
   this->x -= fl;
   this->y -= fl;
   this->z -= fl;

   return ( *this );
}

QAngle& QAngle::operator *= ( float fl ) {
   this->x *= fl;
   this->y *= fl;
   this->z *= fl;

   return ( *this );
}

QAngle& QAngle::operator /= ( float fl ) {
   this->x /= fl;
   this->y /= fl;
   this->z /= fl;

   return ( *this );
}

QAngle QAngle::operator + ( const QAngle& v ) const {
   return { this->x + v.x,
			 this->y + v.y,
			 this->z + v.z };
}

QAngle QAngle::operator - ( const QAngle& v ) const {
   return { this->x - v.x,
			 this->y - v.y,
			 this->z - v.z };
}

QAngle QAngle::operator * ( const QAngle& v ) const {
   return { this->x * v.x,
			 this->y * v.y,
			 this->z * v.z };
}

QAngle QAngle::operator / ( const QAngle& v ) const {
   return { this->x / v.x,
			 this->y / v.y,
			 this->z / v.z };
}

QAngle QAngle::operator + ( float fl ) const {
   return { this->x + fl,
			 this->y + fl,
			 this->z + fl };
}

QAngle QAngle::operator - ( float fl ) const {
   return { this->x - fl,
			 this->y - fl,
			 this->z - fl };
}

QAngle QAngle::operator * ( float fl ) const {
   return { this->x * fl,
			 this->y * fl,
			 this->z * fl };
}

QAngle QAngle::operator / ( float fl ) const {
   return { this->x / fl,
			 this->y / fl,
			 this->z / fl };
}

QAngle QAngle::Zero( 0.0f, 0.0f, 0.0f );

```

`CSGO SDK/SDK/Valve/qangle.hpp`:

```hpp
#pragma once

#include "../core.hpp"

class QAngle
{
public:
	QAngle( );
	QAngle( float x, float y, float z );
	QAngle( const QAngle& v );
	QAngle( const float* v );

public:
	void Set( float x = 0.0f, float y = 0.0f, float z = 0.0f );

	void Normalize( );
	void Clamp( );

	bool IsZero( float tolerance = 0.01f );
	bool AngleAreEqual( QAngle angle, float tolerance = 0.01f );

	QAngle Normalized( );
	QAngle Clamped( );

	QAngle Direction( ) {
		return QAngle( cos( y * 3.14159265358979323846 / 180.0f ) * cos( x * 3.14159265358979323846 / 180.0f ), sin( y * 3.14159265358979323846 / 180.0f ) * cos( x * 3.14159265358979323846 / 180.0f ), sin( -x * 3.14159265358979323846 / 180.0f ) ).Normalized( );
	}

	QAngle Forward( ) {
		return Direction( );
	}

	QAngle Up( ) {
		return QAngle( cos( y * 3.14159265358979323846 / 180.0f ) * cos( x * 3.14159265358979323846 / 180.0f ), sin( y * 3.14159265358979323846 / 180.0f ) * cos( x * 3.14159265358979323846 / 180.0f ), sin( -( x - 90.0f ) * 3.14159265358979323846 / 180.0f ) ).Normalized( );
	}

	QAngle Right( ) {
		return QAngle( cos( ( y + 90.f ) * 3.14159265358979323846 / 180.0f ) * cos( x * 3.14159265358979323846 / 180.0f ), sin( ( y + 90.f ) * 3.14159265358979323846 / 180.0f ) * cos( x * 3.14159265358979323846 / 180.0f ), sin( -x * 3.14159265358979323846 / 180.0f ) ).Normalized( );
	}

	Vector ToVectors( Vector* side = nullptr, Vector* up = nullptr );
	Vector ToVectorsTranspose( Vector* side = nullptr, Vector* up = nullptr );

public:
	float operator [] ( const std::uint32_t index );
	const float operator [] ( const std::uint32_t index ) const;

	QAngle& operator = ( const QAngle& v );
	QAngle& operator = ( const float* v );

	QAngle& operator += ( const QAngle& v );
	QAngle& operator -= ( const QAngle& v );
	QAngle& operator *= ( const QAngle& v );
	QAngle& operator /= ( const QAngle& v );

	QAngle& operator += ( float fl );
	QAngle& operator -= ( float fl );
	QAngle& operator *= ( float fl );
	QAngle& operator /= ( float fl );

	QAngle operator + ( const QAngle& v ) const;
	QAngle operator - ( const QAngle& v ) const;
	QAngle operator * ( const QAngle& v ) const;
	QAngle operator / ( const QAngle& v ) const;

	QAngle operator + ( float fl ) const;
	QAngle operator - ( float fl ) const;
	QAngle operator * ( float fl ) const;
	QAngle operator / ( float fl ) const;

public:
	static QAngle Zero;

public:
	union {
		struct {
			float pitch;
			float yaw;
			float roll;
		};

		struct {
			float x;
			float y;
			float z;
		};
	};
};

```

`CSGO SDK/SDK/Valve/recv_swap.hpp`:

```hpp
#pragma once
#include "SDK/sdk.hpp"

class RecvPropHook {
	RecvProp* m_Prop;
	RecvVarProxyFn m_OriginalFn;
public:
	using Shared = std::shared_ptr<RecvPropHook>;

public:
	RecvPropHook( RecvProp* prop, const RecvVarProxyFn hkProxy ) :
		m_Prop( prop ),
		m_OriginalFn( prop->m_ProxyFn ) {
		Hook( hkProxy );
	}

	auto Unhook( ) {
		m_Prop->m_ProxyFn = m_OriginalFn;

		unhooked = true;
	}

	~RecvPropHook( ) {
		if( this && !unhooked ) // was crashing when unloading hack
			Unhook( );
	}

	auto GetOriginalFunction( ) const -> RecvVarProxyFn {
		return m_OriginalFn;
	}

	auto Hook( const RecvVarProxyFn proxy_fn ) const -> void {
		m_Prop->m_ProxyFn = proxy_fn;
	}
private:
	bool unhooked = false;
};

```

`CSGO SDK/SDK/Valve/vector.cpp`:

```cpp
#include "vector.hpp"
#include "vector2d.hpp"
#include "vector4d.hpp"
#include "qangle.hpp"
#include "matrix.hpp"

Vector::Vector( ) {
	this->Set( );
}

Vector::Vector( float x, float y, float z ) {
	this->Set( x, y, z );
}

Vector::Vector( const Vector& v ) {
	this->Set( v.x, v.y, v.z );
}

Vector::Vector( const float* v ) {
	this->Set( v[ 0 ], v[ 1 ], v[ 2 ] );
}

void Vector::Set( float x /*= 0.0f*/, float y /*= 0.0f */, float z /*= 0.0f*/ ) {
	this->x = x;
	this->y = y;
	this->z = z;
}

bool Vector::IsZero( float tolerance /*= 0.01f */ ) const {
	return ( this->x > -tolerance && this->x < tolerance&&
		this->y > -tolerance && this->y < tolerance&&
		this->z > -tolerance && this->z < tolerance );
}

bool Vector::VectorsAreEqual( const Vector& other, float tolerance ) const {
	if( std::fabsf( this->x - other.x ) > tolerance )
		return false;
	if( std::fabsf( this->y - other.y ) > tolerance )
		return false;
	return ( std::fabsf( this->z - other.z ) <= tolerance );
}

float Vector::Normalize( ) {
	auto length = this->Length( );
	if( length > 0.f ) {
		( *this ) /= length;
	}
	return length;
}

float Vector::Dot( const Vector& v ) const {
	return ( this->x * v.x +
		this->y * v.y +
		this->z * v.z );
}

float Vector::LengthSquared( ) const {
	return ( this->Dot( *this ) );
}

float Vector::Length( ) const {
	return ( std::sqrt( this->LengthSquared( ) ) );
}

float Vector::Length2DSquared( ) const {
	return ( x * x + y * y );
}

float Vector::Length2D( ) const {
	return std::sqrt( x * x + y * y );
}

float Vector::DistanceSquared( const Vector& v ) const {
	return ( ( *this - v ).LengthSquared( ) );
}

float Vector::Distance( const Vector& v ) const {
	return ( ( *this - v ).Length( ) );
}

Vector Vector::Transform( const matrix3x4_t& transform ) const {
	return { Dot( transform[ 0 ] ) + transform[ 0 ][ 3 ], Dot( transform[ 1 ] ) + transform[ 1 ][ 3 ], Dot( transform[ 2 ] ) + transform[ 2 ][ 3 ] };
}

Vector Vector::Normalized( ) const {
	Vector copy( *this );
	copy.Normalize( );
	return copy;
}

Vector Vector::Cross( const Vector& v ) const {
	return { this->y * v.z - this->z * v.y,
		this->z * v.x - this->x * v.z,
		this->x * v.y - this->y * v.x };
}

Vector2D Vector::ToVector2D( ) {
	return { this->x, this->y };
}

Vector4D Vector::ToVector4D( float w /*= 0.0f */ ) {
	return { this->x, this->y, this->z, w };
}

QAngle Vector::ToEulerAngles( Vector* pseudoup /*= nullptr*/ ) {
	auto pitch = 0.0f;
	auto yaw = 0.0f;
	auto roll = 0.0f;

	auto length = this->ToVector2D( ).Length( );

	if( pseudoup ) {
		auto left = pseudoup->Cross( *this );

		left.Normalize( );

		pitch = ToDegrees( std::atan2( -this->z, length ) );

		if( pitch < 0.0f )
			pitch += 360.0f;

		if( length > 0.001f ) {
			yaw = ToDegrees( std::atan2( this->y, this->x ) );

			if( yaw < 0.0f )
				yaw += 360.0f;

			auto up_z = ( this->x * left.y ) - ( this->y * left.x );

			roll = ToDegrees( std::atan2( left.z, up_z ) );

			if( roll < 0.0f )
				roll += 360.0f;
		}
		else {
			yaw = ToDegrees( std::atan2( -left.x, left.y ) );

			if( yaw < 0.0f )
				yaw += 360.0f;
		}
	}
	else {
		if( this->x == 0.0f && this->y == 0.0f ) {
			if( this->z > 0.0f )
				pitch = 270.0f;
			else
				pitch = 90.0f;
		}
		else {
			pitch = ToDegrees( std::atan2( -this->z, length ) );

			if( pitch < 0.0f )
				pitch += 360.0f;

			yaw = ToDegrees( std::atan2( this->y, this->x ) );

			if( yaw < 0.0f )
				yaw += 360.0f;
		}
	}

	return { pitch, yaw, roll };
}

Vector Vector::Min( const Vector& other ) {
	return Vector( x < other.x ? x : other.x, y < other.y ? y : other.y, z < other.z ? z : other.z );
}

Vector Vector::Max( const Vector& other ) {
	return Vector( x > other.x ? x : other.x, y > other.y ? y : other.y, z > other.z ? z : other.z );
}

void Vector::GetVectors( Vector& right, Vector& up ) { // VectorVectors
	Vector tmp;
	if( x == 0.f && y == 0.f ) {
		// pitch 90 degrees up/down from identity
		right[ 0 ] = 0.f;
		right[ 1 ] = -1.f;
		right[ 2 ] = 0.f;
		up[ 0 ] = -z;
		up[ 1 ] = 0.f;
		up[ 2 ] = 0.f;
	}
	else {
		tmp[ 0 ] = 0.f;
		tmp[ 1 ] = 0.f;
		tmp[ 2 ] = 1.0f;
		right = Cross( tmp );
		up = right.Cross( *this );

		right.Normalize( );
		up.Normalize( );
	}
}

Vector& Vector::operator = ( const Vector& v ) {
	this->Set( v.x, v.y, v.z );

	return ( *this );
}

Vector& Vector::operator = ( const float* v ) {
	if( v && v != nullptr)
		this->Set( v[ 0 ], v[ 1 ], v[ 2 ] );

	return ( *this );
}

Vector& Vector::operator += ( const Vector& v ) {
	this->x += v.x;
	this->y += v.y;
	this->z += v.z;

	return ( *this );
}

Vector& Vector::operator -= ( const Vector& v ) {
	this->x -= v.x;
	this->y -= v.y;
	this->z -= v.z;

	return ( *this );
}

Vector& Vector::operator *= ( const Vector& v ) {
	this->x *= v.x;
	this->y *= v.y;
	this->z *= v.z;

	return ( *this );
}

Vector& Vector::operator /= ( const Vector& v ) {
	this->x /= v.x;
	this->y /= v.y;
	this->z /= v.z;

	return ( *this );
}

Vector& Vector::operator += ( float fl ) {
	this->x += fl;
	this->y += fl;
	this->z += fl;

	return ( *this );
}

Vector& Vector::operator -= ( float fl ) {
	this->x -= fl;
	this->y -= fl;
	this->z -= fl;

	return ( *this );
}

Vector& Vector::operator *= ( float fl ) {
	this->x *= fl;
	this->y *= fl;
	this->z *= fl;

	return ( *this );
}

Vector& Vector::operator /= ( float fl ) {
	this->x /= fl;
	this->y /= fl;
	this->z /= fl;

	return ( *this );
}

Vector Vector::operator + ( const Vector& v ) const {
	return { this->x + v.x,
		this->y + v.y,
		this->z + v.z };
}

Vector Vector::operator - ( const Vector& v ) const {
	return { this->x - v.x,
		this->y - v.y,
		this->z - v.z };
}

Vector Vector::operator * ( const Vector& v ) const {
	return { this->x * v.x,
		this->y * v.y,
		this->z * v.z };
}

Vector Vector::operator / ( const Vector& v ) const {
	return { this->x / v.x,
		this->y / v.y,
		this->z / v.z };
}

Vector Vector::operator + ( float fl ) const {
	return { this->x + fl,
		this->y + fl,
		this->z + fl };
}

Vector Vector::operator - ( float fl ) const {
	return { this->x - fl,
		this->y - fl,
		this->z - fl };
}

Vector Vector::operator * ( float fl ) const {
	return { this->x * fl,
		this->y * fl,
		this->z * fl };
}

Vector Vector::operator / ( float fl ) const {
	return { this->x / fl,
		this->y / fl,
		this->z / fl };
}

bool Vector::operator < ( const Vector& v ) {
	return { this->x < v.x&&
		this->y < v.y&&
		this->z < v.z };
}

bool Vector::operator > ( const Vector& v ) {
	return { this->x > v.x &&
		this->y > v.y &&
		this->z > v.z };
}

bool Vector::operator<=( const Vector& v ) {
	return { this->x <= v.x &&
		this->y <= v.y &&
		this->z <= v.z };
}

bool Vector::operator>=( const Vector& v ) {
	return { this->x >= v.x &&
		this->y >= v.y &&
		this->z >= v.z };
}

Vector Vector::Zero( 0.0f, 0.0f, 0.0f );

```

`CSGO SDK/SDK/Valve/vector.hpp`:

```hpp
#pragma once

#include "../core.hpp"

class Vector
{
public:
  Vector( );
  Vector( float x, float y, float z );
  Vector( const Vector& v );
  Vector( const float* v );

  void Init( float ix = 0.0f, float iy = 0.0f, float iz = 0.0f ) {
	 x = ix; y = iy; z = iz;
  }

public:
  void Set( float x = 0.0f, float y = 0.0f, float z = 0.0f );

  bool IsZero( float tolerance = 0.01f ) const;
  bool VectorsAreEqual( const Vector& a, float tolerance = 0.01f ) const;

  float Normalize( );

  float Dot( const Vector& v ) const;

  float LengthSquared( ) const;
  float Length( ) const;

  float Length2DSquared( ) const;
  float Length2D( ) const;

  float DistanceSquared( const Vector& vector ) const;
  float Distance( const Vector& vector ) const;

  Vector Transform( const matrix3x4_t& transform ) const;

  Vector Normalized( ) const;
  Vector Cross( const Vector& v ) const;

  Vector2D ToVector2D( );
  Vector4D ToVector4D( float w = 0.0f );

  QAngle ToEulerAngles( Vector* pseudoup = nullptr );

  Vector Min( const Vector& other );
  Vector Max( const Vector& other );

  __inline void MulAdd( const Vector& a, const Vector& b, float scalar ) {
	 x = a.x + b.x * scalar;
  }

  __inline void Mul( float scalar ) {
	 x *= scalar;
	 y *= scalar;
	 z *= scalar;
  }

  void GetVectors( Vector& right, Vector& up );

public:
  float &operator[]( int i ) {
	 return ( ( float* )this )[i];
  }

  float operator[]( int i ) const {
	 return ( ( float* )this )[i];
  }

  bool operator==( const Vector& src ) const {
	 return ( src.x == x ) && ( src.y == y ) && ( src.z == z );
  }
  bool operator!=( const Vector& src ) const {
	 return ( src.x != x ) || ( src.y != y ) || ( src.z != z );
  }

  Vector& operator = ( const Vector& v );
  Vector& operator = ( const float* v );

  Vector& operator += ( const Vector& v );
  Vector& operator -= ( const Vector& v );
  Vector& operator *= ( const Vector& v );
  Vector& operator /= ( const Vector& v );

  Vector& operator += ( float fl );
  Vector& operator -= ( float fl );
  Vector& operator *= ( float fl );
  Vector& operator /= ( float fl );

  Vector operator + ( const Vector& v ) const;
  Vector operator - ( const Vector& v ) const;
  Vector operator * ( const Vector& v ) const;
  Vector operator / ( const Vector& v ) const;

  Vector operator + ( float fl ) const;
  Vector operator - ( float fl ) const;
  Vector operator * ( float fl ) const;
  Vector operator / ( float fl ) const;

  bool operator < ( const Vector& v );
  bool operator > ( const Vector& v );
  bool operator <= ( const Vector& v );
  bool operator >= ( const Vector& v );

public:
  static Vector Zero;

public:
  float x = 0.0f;
  float y = 0.0f;
  float z = 0.0f;
};

class __declspec( align( 16 ) ) VectorAligned : public Vector
{

public:

  inline VectorAligned( void ) { };
  inline VectorAligned( float X, float Y, float Z ) {
	 Init( X, Y, Z );
  }

public:

  explicit VectorAligned( const Vector &vOther ) {
	 Init( vOther.x, vOther.y, vOther.z );
  }

  VectorAligned &operator=( const Vector &vOther ) {
	 Init( vOther.x, vOther.y, vOther.z );
	 return *this;
  }

  VectorAligned &operator=( const VectorAligned &vOther ) {
	 Init( vOther.x, vOther.y, vOther.z );
	 return *this;
  }

  float w;
};

```

`CSGO SDK/SDK/Valve/vector2d.cpp`:

```cpp
#include "vector2d.hpp"

Vector2D::Vector2D( float x, float y ) {
  this->Set( x, y );
}

Vector2D::Vector2D( const Vector2D& v ) {
  this->Set( v.x, v.y );
}

Vector2D::Vector2D( const float* v ) {
  this->Set( v[0], v[1] );
}

void Vector2D::Set( float x /*= 0.0f*/, float y /*= 0.0f */ ) {
  this->x = x;
  this->y = y;
}

float Vector2D::Dot( const Vector2D& v ) const {
  return ( this->x * v.x +
	 this->y * v.y );
}

float Vector2D::LengthSquared( ) const {
  return ( this->Dot( *this ) );
}

float Vector2D::Length( ) const {
  return ( std::sqrt( this->LengthSquared( ) ) );
}

float Vector2D::operator [] ( const std::uint32_t index ) {
  return ( ( ( float* )this )[index] );
}

const float Vector2D::operator [] ( const std::uint32_t index ) const {
  return ( ( ( const float* )this )[index] );
}

Vector2D& Vector2D::operator = ( const Vector2D& v ) {
  this->Set( v.x, v.y );

  return ( *this );
}

Vector2D& Vector2D::operator = ( const float* v ) {
  this->Set( v[0], v[1] );

  return ( *this );
}

Vector2D& Vector2D::operator += ( const Vector2D& v ) {
  this->x += v.x;
  this->y += v.y;

  return ( *this );
}

Vector2D& Vector2D::operator -= ( const Vector2D& v ) {
  this->x -= v.x;
  this->y -= v.y;

  return ( *this );
}

Vector2D& Vector2D::operator *= ( const Vector2D& v ) {
  this->x *= v.x;
  this->y *= v.y;

  return ( *this );
}

Vector2D& Vector2D::operator /= ( const Vector2D& v ) {
  this->x /= v.x;
  this->y /= v.y;

  return ( *this );
}

Vector2D& Vector2D::operator += ( float fl ) {
  this->x += fl;
  this->y += fl;

  return ( *this );
}

Vector2D& Vector2D::operator -= ( float fl ) {
  this->x -= fl;
  this->y -= fl;

  return ( *this );
}

Vector2D& Vector2D::operator *= ( float fl ) {
  this->x *= fl;
  this->y *= fl;

  return ( *this );
}

Vector2D& Vector2D::operator /= ( float fl ) {
  this->x /= fl;
  this->y /= fl;

  return ( *this );
}

bool Vector2D::operator<( const Vector2D& in ) const{
    return ( x < in.x&& y < in.y );
}

bool Vector2D::operator>( const Vector2D& in ) const{
    return ( x > in.x && y > in.y );
}

Vector2D Vector2D::operator + ( const Vector2D& v ) const {
  return { this->x + v.x,
			this->y + v.y };
}

Vector2D Vector2D::operator - ( const Vector2D& v ) const {
  return { this->x - v.x,
			this->y - v.y };
}

Vector2D Vector2D::operator * ( const Vector2D& v ) const {
  return { this->x * v.x,
			this->y * v.y };
}

Vector2D Vector2D::operator / ( const Vector2D& v ) const {
  return { this->x / v.x,
			this->y / v.y };
}

Vector2D Vector2D::operator + ( float fl ) const {
  return { this->x + fl,
			this->y + fl };
}

Vector2D Vector2D::operator - ( float fl ) const {
  return { this->x - fl,
			this->y - fl };
}

Vector2D Vector2D::operator * ( float fl ) const {
  return { this->x * fl,
			this->y * fl };
}

Vector2D Vector2D::operator / ( float fl ) const {
  return { this->x / fl,
			this->y / fl };
}

bool Vector2D::operator==( const Vector2D & v ) const {
  return v.x == x && v.y == y;
}

bool Vector2D::operator==( const float v ) const {
  return x == v && v == y;
}

bool Vector2D::operator!=( const Vector2D & v ) const {
  return v.x != x || v.y != y;
}

bool Vector2D::operator!=( const float v ) const {
  return x != v || v != y;
}

```

`CSGO SDK/SDK/Valve/vector2d.hpp`:

```hpp
#pragma once

#include "../core.hpp"

class Vector2D
{
public:
  Vector2D( float x = 0.0f, float y = 0.0f );
  Vector2D( const Vector2D& v );
  Vector2D( const float* v );

public:
  void Set( float x = 0.0f, float y = 0.0f );

  float Dot( const Vector2D& v ) const;

  float LengthSquared( ) const;
  float Length( ) const;

public:
  float operator [] ( const std::uint32_t index );
  const float operator [] ( const std::uint32_t index ) const;

  Vector2D& operator = ( const Vector2D& v );
  Vector2D& operator = ( const float* v );

  Vector2D& operator += ( const Vector2D& v );
  Vector2D& operator -= ( const Vector2D& v );
  Vector2D& operator *= ( const Vector2D& v );
  Vector2D& operator /= ( const Vector2D& v );

  Vector2D& operator += ( float fl );
  Vector2D& operator -= ( float fl );
  Vector2D& operator *= ( float fl );
  Vector2D& operator /= ( float fl );

  bool operator<( const Vector2D& in ) const;

  bool operator>( const Vector2D& in ) const;

  Vector2D operator + ( const Vector2D& v ) const;
  Vector2D operator - ( const Vector2D& v ) const;
  Vector2D operator * ( const Vector2D& v ) const;
  Vector2D operator / ( const Vector2D& v ) const;

  Vector2D operator + ( float fl ) const;
  Vector2D operator - ( float fl ) const;
  Vector2D operator * ( float fl ) const;
  Vector2D operator / ( float fl ) const;

  bool operator == ( const Vector2D& v ) const;
  bool operator == ( const float v )const;

  bool operator != ( const Vector2D& v ) const;
  bool operator != ( const float v )const;

public:
  float x = 0.0f;
  float y = 0.0f;
};

```

`CSGO SDK/SDK/Valve/vector4d.cpp`:

```cpp
#include "vector2d.hpp"
#include "vector4d.hpp"

Vector4D::Vector4D( ) {
  Set( );
}

Vector4D::Vector4D( float x, float y, float z, float w ) {
  Set( x, y, z, w );
}

Vector4D::Vector4D( const Vector4D& v ) {
  Set( v.x, v.y, v.z, v.w );
}

Vector4D::Vector4D( const float* v ) {
  Set( v[0], v[1], v[2], v[3] );
}

Vector4D::Vector4D( Vector2D a, Vector2D b ) {
  min = a;
  max = b;
}

void Vector4D::Set( float x /*= 0.0f*/, float y /*= 0.0f */, float z /*= 0.0f*/, float w /*= 0.0f*/ ) {
  this->x = x;
  this->y = y;
  this->z = z;
  this->w = w;
}

float Vector4D::Dot( const Vector4D& v ) const {
  return ( this->x * v.x +
	 this->y * v.y +
	 this->z * v.z +
	 this->w * v.w );
}

float Vector4D::LengthSquared( ) const {
  return ( this->Dot( *this ) );
}

float Vector4D::Length( ) const {
  return ( std::sqrt( this->LengthSquared( ) ) );
}

float Vector4D::operator[]( int i ) const {
  return ( ( float* )this )[i];
}

float & Vector4D::operator[]( int i ) {
  return ( ( float* )this )[i];
}

Vector4D& Vector4D::operator += ( const Vector4D& v ) {
  this->x += v.x;
  this->y += v.y;
  this->z += v.z;
  this->w += v.w;

  return ( *this );
}

Vector4D& Vector4D::operator -= ( const Vector4D& v ) {
  this->x -= v.x;
  this->y -= v.y;
  this->z -= v.z;
  this->w -= v.w;

  return ( *this );
}

Vector4D& Vector4D::operator *= ( const Vector4D& v ) {
  this->x *= v.x;
  this->y *= v.y;
  this->z *= v.z;
  this->w *= v.w;

  return ( *this );
}

Vector4D& Vector4D::operator /= ( const Vector4D& v ) {
  this->x /= v.x;
  this->y /= v.y;
  this->z /= v.z;
  this->w /= v.w;

  return ( *this );
}

Vector4D& Vector4D::operator += ( float fl ) {
  this->x += fl;
  this->y += fl;
  this->z += fl;
  this->w += fl;

  return ( *this );
}

Vector4D& Vector4D::operator -= ( float fl ) {
  this->x -= fl;
  this->y -= fl;
  this->z -= fl;
  this->w -= fl;

  return ( *this );
}

Vector4D& Vector4D::operator *= ( float fl ) {
  this->x *= fl;
  this->y *= fl;
  this->z *= fl;
  this->w *= fl;

  return ( *this );
}

Vector4D& Vector4D::operator /= ( float fl ) {
  this->x /= fl;
  this->y /= fl;
  this->z /= fl;
  this->w /= fl;

  return ( *this );
}

Vector4D Vector4D::operator + ( const Vector4D& v ) const {
  return { this->x + v.x,
			this->y + v.y,
			this->z + v.z,
			this->w + v.w };
}

Vector4D Vector4D::operator - ( const Vector4D& v ) const {
  return { this->x - v.x,
			this->y - v.y,
			this->z - v.z,
			this->w - v.w };
}

Vector4D Vector4D::operator * ( const Vector4D& v ) const {
  return { this->x * v.x,
			this->y * v.y,
			this->z * v.z,
			this->w * v.w };
}

Vector4D Vector4D::operator / ( const Vector4D& v ) const {
  return { this->x / v.x,
			this->y / v.y,
			this->z / v.z,
			this->w / v.w };
}

Vector4D Vector4D::operator + ( float fl ) const {
  return { this->x + fl,
			this->y + fl,
			this->z + fl,
			this->w + fl };
}

Vector4D Vector4D::operator - ( float fl ) const {
  return { this->x - fl,
			this->y - fl,
			this->z - fl,
			this->w - fl };
}

Vector4D Vector4D::operator * ( float fl ) const {
  return { this->x * fl,
			this->y * fl,
			this->z * fl,
			this->w * fl };
}

Vector4D Vector4D::operator / ( float fl ) const {
  return { this->x / fl,
			this->y / fl,
			this->z / fl,
			this->w / fl };
}

Vector4D & Vector4D::operator=( const Vector4D & vOther ) {
  x = vOther.x;
  y = vOther.y;
  z = vOther.z;
  w = vOther.w;
  return *this;
}

```

`CSGO SDK/SDK/Valve/vector4d.hpp`:

```hpp
#pragma once

#include "../core.hpp"

class Vector4D
{
public:
  Vector4D( );
  Vector4D( float x, float y, float z, float w );
  Vector4D( const Vector4D& v );
  Vector4D( const float* v );
  Vector4D( Vector2D a, Vector2D b );
  Vector4D( Vector4D&& a );

public:
  void Set( float x = 0.0f, float y = 0.0f, float z = 0.0f, float w = 0.0f );

  float Dot( const Vector4D& v ) const;

  float LengthSquared( ) const;
  float Length( ) const;

  float operator[]( int i ) const;
  float& operator[]( int i );

  float    Height() const { return this->bottom - this->top; }
  float    Width()  const { return this->right - this->left; }
  Vector2D Pos()    const { return Vector2D(left, top);        }   
  Vector2D Mid()    const { return Vector2D((left + right) / 2, (top + bottom) / 2); }
  Vector2D Section()    const { return Vector2D((left + 14), (top)); }
  Vector2D Button()    const { return Vector2D((left + 10), (top + bottom) / 2); }

  const bool ContainsPoint(const Vector2D& pt) const
  {
	 const auto tmp = *this; /* Fixes some weird bux I had */
	 if (tmp.top    > pt.y) return false;
	 if (tmp.bottom < pt.y) return false;
	 if (tmp.left   > pt.x) return false;
	 if (tmp.right  < pt.x) return false;
	 return true;
  }

public:
  Vector4D& operator += ( const Vector4D& v );
  Vector4D& operator -= ( const Vector4D& v );
  Vector4D& operator *= ( const Vector4D& v );
  Vector4D& operator /= ( const Vector4D& v );

  Vector4D& operator += ( float fl );
  Vector4D& operator -= ( float fl );
  Vector4D& operator *= ( float fl );
  Vector4D& operator /= ( float fl );

  Vector4D operator + ( const Vector4D& v ) const;
  Vector4D operator - ( const Vector4D& v ) const;
  Vector4D operator * ( const Vector4D& v ) const;
  Vector4D operator / ( const Vector4D& v ) const;

  Vector4D operator + ( float fl ) const;
  Vector4D operator - ( float fl ) const;
  Vector4D operator * ( float fl ) const;
  Vector4D operator / ( float fl ) const;

  Vector4D& operator=( const Vector4D& vOther );

public:
  // Members
  union {
	 // if vector is rectangle
	 struct {
		float left;
		float top;

		float right;
		float bottom;
	 };

	 struct {
		Vector2D min;
		Vector2D max;
	 };

	 struct {
		float x;
		float y;
		float z;
		float w;
	 };
  };
};

```

`CSGO SDK/SDK/core.cpp`:

```cpp
#include "core.hpp"
#include "sdk.hpp"
#include "../source.hpp"
#include "../Renderer/Render.hpp"
#include <uchar.h>
#include "displacement.hpp"

std::uint8_t* GetServerEdict( int index ) {
	static uintptr_t pServerGlobals = **( uintptr_t** )( Engine::Displacement.Data.m_uServerGlobals );
	int iMaxClients = *( int* )( ( uintptr_t )pServerGlobals + 0x18 );
	if( iMaxClients >= index ) {
		if( index <= iMaxClients ) {
			int v10 = index * 16;
			uintptr_t v11 = *( uintptr_t* )( pServerGlobals + 96 );
			if( v11 ) {
				if( !( ( *( uintptr_t* )( v11 + v10 ) >> 1 ) & 1 ) ) {
					uintptr_t v12 = *( uintptr_t* )( v10 + v11 + 12 );
					if( v12 ) {
						uint8_t* pReturn = nullptr;

						// abusing asm is not good
						__asm
						{
							pushad
							mov ecx, v12
							mov eax, dword ptr[ ecx ]
							call dword ptr[ eax + 0x14 ]
							mov pReturn, eax
							popad
						}

						return pReturn;
					}
				}
			}
		}
	}
	return nullptr;
}

bool screen_transform( const Vector& in, Vector2D& out ) {
	static auto& w2sMatrix = Interfaces::m_pEngine->WorldToScreenMatrix( );

	out.x = w2sMatrix.m[ 0 ][ 0 ] * in.x + w2sMatrix.m[ 0 ][ 1 ] * in.y + w2sMatrix.m[ 0 ][ 2 ] * in.z + w2sMatrix.m[ 0 ][ 3 ];
	out.y = w2sMatrix.m[ 1 ][ 0 ] * in.x + w2sMatrix.m[ 1 ][ 1 ] * in.y + w2sMatrix.m[ 1 ][ 2 ] * in.z + w2sMatrix.m[ 1 ][ 3 ];

	float w = w2sMatrix.m[ 3 ][ 0 ] * in.x + w2sMatrix.m[ 3 ][ 1 ] * in.y + w2sMatrix.m[ 3 ][ 2 ] * in.z + w2sMatrix.m[ 3 ][ 3 ];

	if( w < 0.001f ) {
		return false;
	}

	out.x /= w;
	out.y /= w;

	return true;
}

std::u16string StringtoU16( const std::string& str ) {
	std::u16string wstr = u"";
	char16_t c16str[ 3 ] = u"\0";
	mbstate_t mbs;
	for( const auto& it : str ) {
		memset( &mbs, 0, sizeof( mbs ) );//set shift state to the initial state
		memmove( c16str, u"\0\0\0", 3 );
		mbrtoc16( c16str, &it, 3, &mbs );
		wstr.append( std::u16string( c16str ) );
	}//for
	return wstr;
}

bool WorldToScreen( const Vector& in, Vector2D& out ) {
	if( screen_transform( in, out ) ) {
		Vector2D screen = Render::GetScreenSize( );

		out.x = ( screen.x * 0.5f ) + ( out.x * screen.x ) * 0.5f;
		out.y = ( screen.y * 0.5f ) - ( out.y * screen.y ) * 0.5f;

		return true;
	}
	return false;
}

```

`CSGO SDK/SDK/core.hpp`:

```hpp
#pragma once

#include "Utils/auto.hpp"
#include <DirectXMath.h> // beste trigonometry header

constexpr auto RadPi = 3.14159265358979323846;
constexpr auto DegPi = 180.0;

class Vector2D;
class Vector;
class Vector4D;

class QAngle;

class matrix3x4_t;
class VMatrix;

template<typename T>
T Square( T value ) {
  return ( value * value );
}

template<typename T>
void LimitValue( T& value, const T& min, const T& max ) {
  if( value > max )
	 value = max;
  else if( value < min )
	 value = min;
}

template<typename T>
T ToRadians( T degrees ) {
  return ( degrees * ( static_cast< T >( RadPi ) / static_cast< T >( DegPi ) ) );
}

template<typename T>
T ToDegrees( T radians ) {
  return ( radians * ( static_cast< T >( DegPi ) / static_cast< T >( RadPi ) ) );
}

void FORCEINLINE AngleNormalize( float& angle ) {
  angle = std::fmod( angle, 360.0f );

  if( angle > 180.0f )
	 angle -= 360.0f;
  else if( angle < -180.0f )
	 angle += 360.0f;
}

float FORCEINLINE FastRSqrt( float number ) {
  union {
	 float f;
	 uint32_t i;
  } conv;

  float x2;
  const float threehalfs = 1.5f;

  x2 = number * 0.5f;
  conv.f = number;
  conv.i = 0x5F375A86 - ( conv.i >> 1 );
  conv.f = conv.f * ( threehalfs - ( x2 * conv.f * conv.f ) );
  return conv.f;
}

std::uint8_t* GetServerEdict( int index );
std::u16string StringtoU16( const std::string &str );
bool WorldToScreen( const Vector& in, Vector2D& out );


```

`CSGO SDK/SDK/sdk.cpp`:

```cpp
#include "sdk.hpp"
#include "displacement.hpp"

const char* string_t::ToCStr() const
{
	return ( pszValue ) ? pszValue : "";
}

#pragma region impl_functions
void RandomSeed( unsigned int seed )
{
	using Fn = void ( * )( unsigned int );
	auto Procedure = ( Fn )( Engine::Displacement.Function.m_uRandomSeed );

	if( Procedure )
		Procedure( seed );
}

float RandomFloat( float min, float max )
{
	using Fn = float ( * )( float, float );
	auto Procedure = ( Fn )( Engine::Displacement.Function.m_uRandomFloat );

	return ( Procedure ? Procedure( min, max ) : 0.0f );
}

int RandomInt( int min, int max )
{
	using Fn = int ( * )( int, int );
	auto Procedure = ( Fn )( Engine::Displacement.Function.m_uRandomInt );

	return ( Procedure ? Procedure( min, max ) : 0 );
}

#pragma region impl_crc32
#define CRC32_INIT_VALUE 0xFFFFFFFFUL
#define CRC32_XOR_VALUE  0xFFFFFFFFUL

const CRC32_t pulCRCTable[256] =
{
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
	0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
	0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
	0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
	0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
	0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
	0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
	0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
	0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
	0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
	0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
	0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
	0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
	0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
	0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
	0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
	0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
	0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
	0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
	0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
	0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

void CRC32_Init( CRC32_t* pulCRC )
{
	*pulCRC = CRC32_INIT_VALUE;
}

void CRC32_ProcessBuffer( CRC32_t* pulCRC, const void* p, int len )
{
	CRC32_t ulCrc = *pulCRC;
	unsigned char *pb = (unsigned char *)p;
	unsigned int nFront;
	int nMain;

JustAfew:

	switch (len)
	{
	case 7:
		ulCrc  = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

	case 6:
		ulCrc  = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

	case 5:
		ulCrc  = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

	case 4:
		ulCrc ^= ( *(CRC32_t *)pb );
		ulCrc  = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc  = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc  = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc  = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		*pulCRC = ulCrc;
		return;

	case 3:
		ulCrc  = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

	case 2:
		ulCrc  = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

	case 1:
		ulCrc  = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

	case 0:
		*pulCRC = ulCrc;
		return;
	}

	nFront = ((unsigned int)pb) & 3;
	len -= nFront;
	switch (nFront)
	{
	case 3:
		ulCrc  = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
	case 2:
		ulCrc  = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
	case 1:
		ulCrc  = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
	}

	nMain = len >> 3;
	while (nMain--)
	{
		ulCrc ^= ( *(CRC32_t *)pb );
		ulCrc  = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc  = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc  = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc  = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc ^= ( *(CRC32_t *)(pb + 4) );
		ulCrc  = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc  = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc  = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc  = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		pb += 8;
	}

	len &= 7;
	goto JustAfew;
}

void CRC32_Final( CRC32_t* pulCRC )
{
	*pulCRC ^= CRC32_XOR_VALUE;
}

CRC32_t CRC32_GetTableEntry( unsigned int slot )
{
	return pulCRCTable[ ( unsigned char )slot ];
}


#pragma endregion
#pragma endregion

```

`CSGO SDK/SDK/sdk.hpp`:

```hpp
#pragma once

#include "Includes.hpp"

#include <d3d9.h>
#pragma comment(lib, "d3d9.lib")

#include <d3dx9.h>
#pragma comment(lib, "d3dx9.lib")

#pragma comment(lib, "Urlmon.lib")

#include <playsoundapi.h>
#include <mmeapi.h> 
#pragma comment(lib, "Winmm.lib") 

#include <stdint.h>

#include <string>
#include <sstream>
#include "Valve/vector2d.hpp"
#include "Valve/vector.hpp"
#include "Valve/vector4d.hpp"
#include "Valve/qangle.hpp"
#include "Valve/matrix.hpp"
#include "../Utils/Math.h"
#include "CColor.hpp"
#include "Definitions.hpp"
#include "CVariables.hpp"
#include "Classes/CStudioRender.hpp"
#include <minwindef.h>

using namespace SDK;
#define M_PI 3.1415926535f
#define TIME_TO_TICKS(dt) ((int)( 0.5f + (float)(dt) / Interfaces::m_pGlobalVars->interval_per_tick))
#define TICKS_TO_TIME(t) (Interfaces::m_pGlobalVars->interval_per_tick * (float)(t) )
#define ROUND_TO_TICKS( t ) ( Interfaces::m_pGlobalVars->interval_per_tick * TIME_TO_TICKS( t ) )

#define NUM_ENT_ENTRY_BITS         (11 + 2)
#define NUM_ENT_ENTRIES            (1 << NUM_ENT_ENTRY_BITS)
#define INVALID_EHANDLE_INDEX       0xFFFFFFFF
#define NUM_SERIAL_NUM_BITS        16 // (32 - NUM_ENT_ENTRY_BITS)
#define NUM_SERIAL_NUM_SHIFT_BITS (32 - NUM_SERIAL_NUM_BITS)
#define ENT_ENTRY_MASK             (( 1 << NUM_SERIAL_NUM_BITS) - 1)

#define MAX_COORD_FLOAT ( 16384.0f )
#define MIN_COORD_FLOAT ( -MAX_COORD_FLOAT )

#define DECLARE_POINTER_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#define MAXSTUDIOSKINS		32

#define FRUSTUM_NUMPLANES    6

#ifndef max
#define MIN(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define MAX(a,b)            (((a) < (b)) ? (a) : (b))
#endif

// 
// macros
// 

#define TELEPORT_DISTANCE 4096.f

#pragma region decl_macros
#define MULTIPLAYER_BACKUP 150

#define FL_ONGROUND ( 1 << 0 )
#define FL_DUCKING ( 1 << 1 )

#define IN_ATTACK ( 1 << 0 )
#define IN_JUMP ( 1 << 1 )
#define IN_DUCK ( 1 << 2 )
#define IN_FORWARD ( 1 << 3 )
#define IN_BACK ( 1 << 4 )
#define IN_USE ( 1 << 5 )
#define IN_CANCEL ( 1 << 6 )
#define IN_LEFT ( 1 << 7 )
#define IN_RIGHT ( 1 << 8 )
#define IN_MOVELEFT ( 1 << 9 )
#define IN_MOVERIGHT ( 1 << 10 )
#define IN_ATTACK2 ( 1 << 11 )
#define IN_RUN ( 1 << 12 )
#define IN_RELOAD ( 1 << 13 )
#define IN_ALT1 ( 1 << 14 )
#define IN_ALT2 ( 1 << 15 )
#define IN_SCORE ( 1 << 16 )
#define IN_SPEED ( 1 << 17 )
#define IN_WALK ( 1 << 18 )
#define IN_ZOOM ( 1 << 19 )
#define IN_WEAPON1 ( 1 << 20 )
#define IN_WEAPON2 ( 1 << 21 )
#define IN_BULLRUSH ( 1 << 22 )
#define IN_GRENADE1 ( 1 << 23 )
#define IN_GRENADE2 ( 1 << 24 )
#pragma endregion

#pragma region masks

#define   DISPSURF_FLAG_SURFACE           (1<<0)
#define   DISPSURF_FLAG_WALKABLE          (1<<1)
#define   DISPSURF_FLAG_BUILDABLE         (1<<2)
#define   DISPSURF_FLAG_SURFPROP1         (1<<3)
#define   DISPSURF_FLAG_SURFPROP2         (1<<4)

#define   CONTENTS_EMPTY                0

#define   CONTENTS_SOLID                0x1       
#define   CONTENTS_WINDOW               0x2
#define   CONTENTS_AUX                  0x4
#define   CONTENTS_GRATE                0x8
#define   CONTENTS_SLIME                0x10
#define   CONTENTS_WATER                0x20
#define   CONTENTS_BLOCKLOS             0x40 
#define   CONTENTS_OPAQUE               0x80 
#define   LAST_VISIBLE_CONTENTS         CONTENTS_OPAQUE

#define   ALL_VISIBLE_CONTENTS            (LAST_VISIBLE_CONTENTS | (LAST_VISIBLE_CONTENTS-1))

#define   CONTENTS_TESTFOGVOLUME        0x100
#define   CONTENTS_UNUSED               0x200     
#define   CONTENTS_BLOCKLIGHT           0x400
#define   CONTENTS_TEAM1                0x800 
#define   CONTENTS_TEAM2                0x1000 
#define   CONTENTS_IGNORE_NODRAW_OPAQUE 0x2000
#define   CONTENTS_MOVEABLE             0x4000
#define   CONTENTS_AREAPORTAL           0x8000
#define   CONTENTS_PLAYERCLIP           0x10000
#define   CONTENTS_MONSTERCLIP          0x20000
#define   CONTENTS_CURRENT_0            0x40000
#define   CONTENTS_CURRENT_90           0x80000
#define   CONTENTS_CURRENT_180          0x100000
#define   CONTENTS_CURRENT_270          0x200000
#define   CONTENTS_CURRENT_UP           0x400000
#define   CONTENTS_CURRENT_DOWN         0x800000

#define   CONTENTS_ORIGIN               0x1000000 

#define   CONTENTS_MONSTER              0x2000000 
#define   CONTENTS_DEBRIS               0x4000000
#define   CONTENTS_DETAIL               0x8000000 
#define   CONTENTS_TRANSLUCENT          0x10000000
#define   CONTENTS_LADDER               0x20000000
#define   CONTENTS_HITBOX               0x40000000

#define   SURF_LIGHT                    0x0001 
#define   SURF_SKY2D                    0x0002 
#define   SURF_SKY                      0x0004 
#define   SURF_WARP                     0x0008 
#define   SURF_TRANS                    0x0010
#define   SURF_NOPORTAL                 0x0020 
#define   SURF_TRIGGER                  0x0040 
#define   SURF_NODRAW                   0x0080 

#define   SURF_HINT                     0x0100 

#define   SURF_SKIP                     0x0200   
#define   SURF_NOLIGHT                  0x0400   
#define   SURF_BUMPLIGHT                0x0800   
#define   SURF_NOSHADOWS                0x1000   
#define   SURF_NODECALS                 0x2000   
#define   SURF_NOPAINT                  SURF_NODECALS
#define   SURF_NOCHOP                   0x4000   
#define   SURF_HITBOX                   0x8000   

// -----------------------------------------------------
// spatial content masks - used for spatial queries (traceline,etc.)
// -----------------------------------------------------
#define   MASK_ALL                      (0xFFFFFFFF)
#define   MASK_SOLID                    (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define   MASK_PLAYERSOLID              (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define   MASK_NPCSOLID                 (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define   MASK_NPCFLUID                 (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define   MASK_WATER                    (CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME)
#define   MASK_OPAQUE                   (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE)
#define   MASK_OPAQUE_AND_NPCS          (MASK_OPAQUE|CONTENTS_MONSTER)
#define   MASK_BLOCKLOS                 (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_BLOCKLOS)
#define   MASK_BLOCKLOS_AND_NPCS        (MASK_BLOCKLOS|CONTENTS_MONSTER)
#define   MASK_VISIBLE                  (MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE)
#define   MASK_VISIBLE_AND_NPCS         (MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE)
#define   MASK_SHOT                     (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)
#define   MASK_SHOT_PLAYER              ( MASK_SHOT_HULL | CONTENTS_HITBOX )
#define   MASK_SHOT_BRUSHONLY           (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_DEBRIS)
#define   MASK_SHOT_HULL                (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE)
#define   MASK_SHOT_PORTAL              (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define   MASK_SOLID_BRUSHONLY          (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE)
#define   MASK_PLAYERSOLID_BRUSHONLY    (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE)
#define   MASK_NPCSOLID_BRUSHONLY       (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
#define   MASK_NPCWORLDSTATIC           (CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
#define   MASK_NPCWORLDSTATIC_FLUID     (CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP)
#define   MASK_SPLITAREAPORTAL          (CONTENTS_WATER|CONTENTS_SLIME)
#define   MASK_CURRENT                  (CONTENTS_CURRENT_0|CONTENTS_CURRENT_90|CONTENTS_CURRENT_180|CONTENTS_CURRENT_270|CONTENTS_CURRENT_UP|CONTENTS_CURRENT_DOWN)
#define   MASK_DEADSOLID                (CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_GRATE)
#pragma endregion

#pragma region tex_groups
// These are given to FindMaterial to reference the texture groups that Show up on the 
#define TEXTURE_GROUP_LIGHTMAP						        "Lightmaps"
#define TEXTURE_GROUP_WORLD							          "World textures"
#define TEXTURE_GROUP_MODEL							          "Model textures"
#define TEXTURE_GROUP_VGUI							          "VGUI textures"
#define TEXTURE_GROUP_PARTICLE						        "Particle textures"
#define TEXTURE_GROUP_DECAL							          "Decal textures"
#define TEXTURE_GROUP_SKYBOX						          "SkyBox textures"
#define TEXTURE_GROUP_CLIENT_EFFECTS				      "ClientEffect textures"
#define TEXTURE_GROUP_OTHER							          "Other textures"
#define TEXTURE_GROUP_PRECACHED						        "Precached"
#define TEXTURE_GROUP_CUBE_MAP						        "CubeMap textures"
#define TEXTURE_GROUP_RENDER_TARGET					      "RenderTargets"
#define TEXTURE_GROUP_UNACCOUNTED					        "Unaccounted textures"
//#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER		  "Static Vertex"
#define TEXTURE_GROUP_STATIC_INDEX_BUFFER			    "Static Indices"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_DISP		"Displacement Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_COLOR	"Lighting Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_WORLD	"World Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_MODELS	"Model Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_OTHER	"Other Verts"
#define TEXTURE_GROUP_DYNAMIC_INDEX_BUFFER			  "Dynamic Indices"
#define TEXTURE_GROUP_DYNAMIC_VERTEX_BUFFER			  "Dynamic Verts"
#define TEXTURE_GROUP_DEPTH_BUFFER					      "DepthBuffer"
#define TEXTURE_GROUP_VIEW_MODEL					        "ViewModel"
#define TEXTURE_GROUP_PIXEL_SHADERS					      "Pixel Shaders"
#define TEXTURE_GROUP_VERTEX_SHADERS				      "Vertex Shaders"
#define TEXTURE_GROUP_RENDER_TARGET_SURFACE			  "RenderTarget Surfaces"
#define TEXTURE_GROUP_MORPH_TARGETS					      "Morph Targets"
#pragma endregion

#define NOISE_DIVISIONS		128
#define MAX_BEAM_ENTS		10

#define MAX_VIS_LEAVES    32
#define MAX_AREA_STATE_BYTES        32
#define MAX_AREA_PORTAL_STATE_BYTES 24

#define STUDIO_NONE 0x00000000
#define STUDIO_RENDER 0x00000001
#define STUDIO_VIEWXFORMATTACHMENTS 0x00000002
#define STUDIO_DRAWTRANSLUCENTSUBMODELS 0x00000004
#define STUDIO_TWOPASS 0x00000008
#define STUDIO_STATIC_LIGHTING 0x00000010
#define STUDIO_WIREFRAME 0x00000020
#define STUDIO_ITEM_BLINK 0x00000040
#define STUDIO_NOSHADOWS 0x00000080
#define STUDIO_WIREFRAME_VCOLLIDE 0x00000100

// Not a studio flag, but used to flag model as a non-sorting brush model
#define STUDIO_TRANSPARENCY 0x80000000

// Not a studio flag, but used to flag model as using shadow depth material override
#define STUDIO_SHADOWDEPTHTEXTURE 0x40000000

#define STUDIORENDER_DECAL_INVALID 0x0

__forceinline auto DotProduct( const Vector& a, const Vector& b ) -> float {
	return ( a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ] + a[ 2 ] * b[ 2 ] );
}

// 
// indices
// 
#pragma region decl_indices
namespace Index
{
	namespace IBaseClientDLL
	{
		enum {
			GetAllClasses = 8,
			CreateMove = 22,
			FrameStageNotify = 36,
			IsChatRaised = 90,
		};
	}
	namespace ModelDraw
	{
		enum {
			DrawModelExecute = 21,
		};
	}
	namespace GameEvent
	{
		enum {
			GameEvent = 9,
		};
	}
	namespace StudioRender
	{
		enum {
			DrawModel = 29,
		};
	}
	namespace NetChannel
	{
		enum {
			Shutdown = 27,
			SendNetMsg = 40,
		};
	}
	namespace EngineClient
	{
		enum {
			GetNetChannelInfo = 78,
			IsPlayingDemo = 82,
			IsHltv = 93,
			GetScreenAspectRatio = 101,
		};
	}
	namespace BSPTreeQuery
	{
		enum {
			ListLeavesInBox = 6,
		};
	}
	namespace CClientModeShared
	{
		enum {
			CreateMove = 24,
			DoPostScreenSpaceEffects = 44,
			OverrideView = 18,
			ShouldDrawFog = 17,
			ShouldDrawParticles = 16,
		};
	}
	namespace DirectX
	{
		enum {
			EndScene = 42,
			Reset = 16,
			Present = 17,
		};
	};
	namespace IClientEntityList
	{
		enum {
			GetClientEntity = 3,
			GetClientEntityFromHandle = 4,
			GetHighestEntityIndex = 6,
		};
	}
	namespace IGameMovement
	{
		enum {
			ProcessMovement = 1,
			Reset = 2,
			StartTrackPredictionErrors = 3,
			FinishTrackPredictionErrors = 4,
			GetPlayerMins = 6,
			GetPlayerMaxs = 7,
			GetPlayerViewOffset = 8,
		};
	}
	namespace IPrediction
	{
		enum {
			Update = 3,
			CheckMovingGround = 18,
			RunCommand = 19,
			SetupMove = 20,
			FinishMove = 21,
			InPrediction = 14,
		};
	}
	namespace IMoveHelper
	{
		enum {
			SetHost = 1,
			ProccesImpacts = 4,
		};
	}
	namespace IInput
	{
		enum {
			GetUserCmd = 8,
		};
	}
	namespace IVEngineClient
	{
		enum {
			GetScreenSize = 5,
			GetPlayerInfo = 8,
			GetLocalPlayer = 12,
			Time = 14,
			GetViewAngles = 18,
			SetViewAngles = 19,
			GetMaxClients = 20,
			IsInGame = 26,
			IsConnected = 27,
			WorldToScreenMatrix = 37,
			GetNetChannelInfo = 78,
			ClientCmd_Unrestricted = 114,
		};
	}
	namespace IPanel
	{
		enum {
			GetName = 36,
			PaintTraverse = 41,
		};
	}
	namespace VguiSurface
	{
		enum {
			UnLockCursor = 66,
			LockCursor = 67,
			OnScreenSizeChanged = 116,
		};
	}
	namespace MatSystem
	{
		enum {
			BeginFrame = 42,
		};
	}
}
#pragma endregion

// 
// enums
// 
#pragma region decl_enums
enum MDLCacheDataType_t {
	// Callbacks to Get called when data is loaded or unloaded for these:
	MDLCACHE_STUDIOHDR = 0,
	MDLCACHE_STUDIOHWDATA,
	MDLCACHE_VCOLLIDE,

	// Callbacks NOT called when data is loaded or unloaded for these:
	MDLCACHE_ANIMBLOCK,
	MDLCACHE_VIRTUALMODEL,
	MDLCACHE_VERTEXES,
	MDLCACHE_DECODEDANIMBLOCK
};

enum MDLCacheFlush_t {
	MDLCACHE_FLUSH_STUDIOHDR = 0x01,
	MDLCACHE_FLUSH_STUDIOHWDATA = 0x02,
	MDLCACHE_FLUSH_VCOLLIDE = 0x04,
	MDLCACHE_FLUSH_ANIMBLOCK = 0x08,
	MDLCACHE_FLUSH_VIRTUALMODEL = 0x10,
	MDLCACHE_FLUSH_AUTOPLAY = 0x20,
	MDLCACHE_FLUSH_VERTEXES = 0x40,

	MDLCACHE_FLUSH_IGNORELOCK = 0x80000000,
	MDLCACHE_FLUSH_ALL = 0xFFFFFFFF
};

enum SendPropType {
	DPT_Int = 0,
	DPT_Float,
	DPT_Vector,
	DPT_VectorXY,
	DPT_String,
	DPT_Array,
	DPT_DataTable,
	DPT_NUMSendPropTypes,
};

enum MapLoadType_t {
	MapLoad_NewGame = 0,
	MapLoad_LoadGame,
	MapLoad_Transition,
	MapLoad_Background,
};

enum ClientFrameStage_t {
	FRAME_UNDEFINED = -1,
	FRAME_START,
	FRAME_NET_UPDATE_START,
	FRAME_NET_UPDATE_POSTDATAUPDATE_START,
	FRAME_NET_UPDATE_POSTDATAUPDATE_END,
	FRAME_NET_UPDATE_END,
	FRAME_RENDER_START,
	FRAME_RENDER_END,
};
#pragma endregion

// 
// unimplemented
// 
#pragma region decl_unimplemented
struct model_t;

class SendProp;
#pragma endregion

// 
// types
// 
#pragma region decl_types
using CRC32_t = unsigned int;
using VPANEL = unsigned int;
using ModelInstanceHandle_t = unsigned short;
using ImageFormat = int;
using VertexFormat_t = int;
using MaterialPropertyTypes_t = int;
using OverrideType_t = int;
using LightCacheHandle_t = void*;
using ChangeCallback_t = void( * )( ConVar* var, const char* pOldValue, float flOldValue );
using StudioDecalHandle_t = void*;
using pixelvis_handle_t = int;
using str_32 = char[ 32 ];
using CreateClientClassFn = void* ( * )( int entnum, int serialNum );
using LeafIndex_t = unsigned short;
#pragma endregion

// 
// structs
// 
#pragma region decl_structs
struct string_t;
struct model_t;
struct mstudioanimdesc_t;
struct mstudioseqdesc_t;
struct Ray_t;
struct DrawModelInfo_t;
struct studiohwdata_t;
struct MaterialLightingState_t;
struct ColorMeshInfo_t;
struct MaterialSystem_Config_t;
struct MaterialSystemHWID_t;
struct AspectRatioInfo_t;
struct studiohwdata_t;
struct vcollide_t;
struct virtualmodel_t;
struct vertexFileHeader_t;
class CPhysCollide;
class ISpatialQuery;
class CUtlBuffer;
class CStudioHdr;
struct virtualmodel_t;
struct client_textmessage_t;
class CSentence;
class CAudioSource;
class SurfInfo;
struct Frustum_t;
class IAchievementMgr;
class AudioState_t;
class ISPSharedMemory;
class C_Beam;

struct hud_weapons_t {
	std::int32_t* get_weapon_count( ) {
		return reinterpret_cast< std::int32_t* >( std::uintptr_t( this ) + 0x80 );
	}
};

struct IntRect {
	int x0;
	int y0;
	int x1;
	int y1;
};

struct Vertex_t {
	Vertex_t( ) { }
	Vertex_t( const Vector2D& pos, const Vector2D& coord = Vector2D( 0, 0 ) ) {
		m_Position = pos;
		m_TexCoord = coord;
	}
	void Init( const Vector2D& pos, const Vector2D& coord = Vector2D( 0, 0 ) ) {
		m_Position = pos;
		m_TexCoord = coord;
	}

	Vector2D m_Position;
	Vector2D m_TexCoord;
};

struct DrawModelState_t {
	studiohdr_t* m_pStudioHdr;
	studiohwdata_t* m_pStudioHWData;
	void* m_pRenderable;
	const matrix3x4_t* m_pModelToWorld;
	StudioDecalHandle_t     m_decals;
	int                     m_drawFlags;
	int                     m_lod;
};

struct LightingQuery_t {
	Vector                  m_LightingOrigin;
	ModelInstanceHandle_t   m_InstanceHandle;
	bool                    m_bAmbientBoost;
};

typedef struct InputContextHandle_t__* InputContextHandle_t;

struct BeamTrail_t {
	// NOTE:  Don't add user defined fields except after these four fields.
	BeamTrail_t* next;
	float			die;
	Vector			org;
	Vector			vel;
};

struct cplane_t {
	Vector normal;
	float dist;
	uint8_t type;   // for fast side tests
	uint8_t signbits;  // signx + (signy<<1) + (signz<<1)
	uint8_t pad[ 2 ];

};
struct MaterialVideoMode_t {
	int m_Width;			// if width and height are 0 and you select 
	int m_Height;			// windowed mode, it'll use the window size
	ImageFormat m_Format;	// use ImageFormats (ignored for windowed mode)
	int m_RefreshRate;		// 0 == default (ignored for windowed mode)
};
//-----------------------------------------------------------------------------
// Enumeration interface for EnumerateLinkEntities
//-----------------------------------------------------------------------------
class IEntityEnumerator {
public:
	// This gets called with each handle
	virtual bool EnumEntity( void* pHandleEntity ) = 0;
};

class C_CSPlayer;
struct BeamInfo_t {
	//Beam
	int				m_nType;
	C_CSPlayer* m_pStartEnt;
	int				m_nStartAttachment;
	C_CSPlayer* m_pEndEnt;
	int				m_nEndAttachment;
	Vector			m_vecStart;
	Vector			m_vecEnd;
	int				m_nModelIndex;
	const char* m_pszModelName;
	int				m_nHaloIndex;
	const char* m_pszHaloName;
	float			m_flHaloScale;
	float			m_flLife;
	float			m_flWidth;
	float			m_flEndWidth;
	float			m_flFadeLength;
	float			m_flAmplitude;
	float			m_flBrightness;
	float			m_flSpeed;
	int				m_nStartFrame;
	float			m_flFrameRate;
	float			m_flRed;
	float			m_flGreen;
	float			m_flBlue;
	bool			m_bRenderable;
	int				m_nSegments;
	int				m_nFlags;
	// Rings
	Vector			m_vecCenter;
	float			m_flStartRadius;
	float			m_flEndRadius;

	BeamInfo_t( ) {
		m_nType = TE_BEAMPOINTS;
		m_nSegments = -1;
		m_pszModelName = NULL;
		m_pszHaloName = NULL;
		m_nModelIndex = -1;
		m_nHaloIndex = -1;
		m_bRenderable = true;
		m_nFlags = 0;
	}
};
struct BrushSideInfo_t {
	Vector4D plane;               // The plane of the brush side
	unsigned short bevel;    // Bevel plane?
	unsigned short thin;     // Thin?
};

class CPhysCollide;


struct vcollide_t {
	unsigned short solidCount : 15;
	unsigned short isPacked : 1;
	unsigned short descSize;
	// VPhysicsSolids
	CPhysCollide** solids;
	char* pKeyValues;
	void* pUserData;
};

struct cmodel_t {
	Vector         mins, maxs;
	Vector         origin;        // for sounds or lights
	int            headnode;
	vcollide_t     vcollisionData;
};

struct csurface_t {
	const char* name;
	short          surfaceProps;
	unsigned short flags;         // BUGBUG: These are declared per surface, not per material, but this database is per-material now
};
struct ApplicationInstantCountersInfo_t {
	uint32_t m_nCpuActivityMask;
	uint32_t m_nDeferredWordsAllocated;
};
struct MaterialAdapterInfo_t {
	char m_pDriverName[ MATERIAL_ADAPTER_NAME_LENGTH ];
	unsigned int m_VendorID;
	unsigned int m_DeviceID;
	unsigned int m_SubSysID;
	unsigned int m_Revision;
	int m_nDXSupportLevel;			// This is the *preferred* dx support level
	int m_nMinDXSupportLevel;
	int m_nMaxDXSupportLevel;
	unsigned int m_nDriverVersionHigh;
	unsigned int m_nDriverVersionLow;
};
struct StaticLightingQuery_t : public LightingQuery_t {
	void* m_pRenderable;
};
struct StaticPropRenderInfo_t {
	const matrix3x4_t* pModelToWorld;
	const model_t* pModel;
	void* pRenderable;
	Vector* pLightingOrigin;
	short                   skin;
	ModelInstanceHandle_t   instance;
};

struct VPlane {
	Vector        m_Normal;
	float         m_Dist;
};

#pragma endregion

//typedefs
typedef VPlane Frustum[ FRUSTUM_NUMPLANES ];

// 
// classes
// 
#pragma region decl_classes
class IHandleEntity;
class IClientUnknown;
class ICollideable;
class IClientNetworkable;
class IClientRenderable;
class IClientEntity;
class C_BaseEntity;
class C_BaseAnimating;
class C_BaseCombatCharacter;
class C_BasePlayer;
class C_CSPlayer;
class C_BaseCombatWeapon;
class C_WeaponCSBaseGun;
class bf_write;
class bf_read;
class DVariant;
class CRecvProxyData;
class RecvProp;
class RecvTable;

class ClientClass;
class CUserCmd;
class CVerifiedUserCmd;
class CGlobalVarsBase;
class CGlobalVars;
class CMoveData;
class CGamestatsData;
class ITexture;
class CEnvTonemapContorller {
public:
	bool* m_bUseCustomAutoExposureMax( ) {
		return ( bool* )( ( DWORD )this + ( DWORD )0x9D9 );
	}

	bool* m_bUseCustomAutoExposureMin( ) {
		return ( bool* )( ( DWORD )this + ( DWORD )0x9D8 );
	}

	float* m_flCustomAutoExposureMax( ) {
		return ( float* )( ( DWORD )this + ( DWORD )0x9E0 );
	}

	float* m_flCustomAutoExposureMin( ) {
		return ( float* )( ( DWORD )this + ( DWORD )0x9DC );
	}
	bool* m_bUseCustomBloomScale( ) {
		return ( bool* )( ( DWORD )this + ( DWORD )0x9DA );
	}
	float* m_flCustomBloomScale( ) {
		return ( float* )( ( DWORD )this + ( DWORD )0x9E4 );
	}
	float* m_flCustomBloomScaleMinimum( ) {
		return ( float* )( ( DWORD )this + ( DWORD )0x9E8 );
	}
	float* m_flBloomExponent( ) {
		return ( float* )( ( DWORD )this + ( DWORD )0x9EC );
	}
	float* m_flBloomSaturation( ) {
		return ( float* )( ( DWORD )this + ( DWORD )0x9F0 );
	}
	float* m_flTonemapPercentTarget( ) {
		return ( float* )( ( DWORD )this + ( DWORD )0x9F4 );
	}
	float* m_flTonemapPercentBrightPixels( ) {
		return ( float* )( ( DWORD )this + ( DWORD )0x9F8 );
	}
	float* m_flTonemapMinAvgLum( ) {
		return ( float* )( ( DWORD )this + ( DWORD )0x9FC );
	}
	float* m_flTonemapRate( ) {
		return ( float* )( ( DWORD )this + ( DWORD )0xA00 );
	}
};
class IMaterialVar {
public:
	ITexture* GetTextureValue( ) {
		return Memory::VCall< ITexture* ( __thiscall* )( void* ) >( this, 1 )( this );
	}

	void SetFloatValue( float value ) {
		Memory::VCall< void( __thiscall* )( void*, float ) >( this, 4 )( this, value );
	}

	void SetIntValue( int value ) {
		Memory::VCall< void( __thiscall* )( void*, int ) >( this, 5 )( this, value );
	}

	void SetStringValue( char const* value ) {
		Memory::VCall< void( __thiscall* )( void*, char const* ) >( this, 6 )( this, value );
	}

	void SetVecValue( float value1, float value2, float value3 ) {
		Memory::VCall< void( __thiscall* )( void*, float, float, float ) >( this, 11 )( this, value1, value2, value3 );
	}

	void SetVecComponent( const float value1, const int component ) {
		Memory::VCall< void( __thiscall* )( void*, float, int ) >( this, 26 )( this, value1, component );
	}

	void SetTextureValue( ITexture* tex ) {
		// Memory::VCall< void( __thiscall* )( void*, ITexture* ) >( this, 15 )( this, tex );
	}
};
class KeyValues;
class IMaterialProxyFactory;
class IMaterialSystemHardwareConfig;
class CShadowMgr;
class IShader;
class IMaterial;
class IMatRenderContext;
class DataCacheHandle_t;
class CSteamAPIContext;
class KeyValues;
class CBaseHandle;
class IMatRenderContext {
public:
	auto release( void ) -> int {
		typedef int( __thiscall* original_fn )( void* );
		return Memory::VCall<original_fn>( this, 1 )( this );
	}

	auto set_render_target( ITexture* pTexture ) -> void {
		typedef void( __thiscall* original_fn )( void*, ITexture* );
		return Memory::VCall<original_fn>( this, 6 )( this, pTexture );
	}

	auto draw_screen_space_rect( IMaterial* pMaterial, int destX, int destY, int width, int height, float srcTextureX0, float srcTextureY0, float srcTextureX1, float srcTextureY1, int srcTextureWidth, int srcTextureHeight, void* pClientRenderable, int nXDice, int nYDice ) -> void {
		typedef void( __thiscall* original_fn )( void*, IMaterial*, int, int, int, int, float, float, float, float, int, int, void*, int, int );
		return Memory::VCall<original_fn>( this, 114 )( this, pMaterial, destX, destY, width, height, srcTextureX0, srcTextureY0, srcTextureX1, srcTextureY1, srcTextureWidth, srcTextureHeight, pClientRenderable, nXDice, nYDice );
	}

	auto push_render_target_and_viewport( void ) -> void {
		typedef void( __thiscall* original_fn )( void* );
		return Memory::VCall<original_fn>( this, 119 )( this );
	}

	auto pop_render_target_and_viewport( void ) -> void {
		typedef void( __thiscall* original_fn )( void* );
		return Memory::VCall<original_fn>( this, 120 )( this );
	}
};
#include "Valve/UtlVector.hpp"
class CStudioHdr
{
public:
	mutable studiohdr_t* _m_pStudioHdr;
	mutable virtualmodel_t* m_pVModel;
	mutable uint16_t m_pStudioHdrCache;

	int m_nFrameUnlockCounter;
	int* m_pFrameUnlockCounter;
	uint16_t m_FrameUnlockCounterMutex;

	int unknown;
	CUtlVector<int>		m_boneFlags; //48
	CUtlVector<int>		m_boneParent;

	class CActivityToSequenceMapping /* final */
	{
	public:
		// A tuple of a sequence and its corresponding weight. Lists of these correspond to activities.
		struct SequenceTuple
		{
			short		seqnum;
			short		weight; // the absolute value of the weight from the sequence header
			uint16_t* pActivityModifiers;		// list of activity modifier symbols
			int			iNumActivityModifiers;
			int* iUnknown;
		};

		// The type of the hash's stored data, a composite of both key and value
		// (because that's how CUtlHash works):
		// key: an int, the activity #
		// values: an index into the m_pSequenceTuples array, a count of the
		// total sequences present for an activity, and the sum of their
		// weights.
		// Note this struct is 128-bits wide, exactly coincident to a PowerPC 
		// cache line and VMX register. Please consider very carefully the
		// performance implications before adding any additional fields to this.
		// You could probably do away with totalWeight if you really had to.
		struct HashValueType
		{
			// KEY (hashed)
			int activityIdx;

			// VALUE (not hashed)
			int startingIdx;
			int count;
			int totalWeight;

			HashValueType( int _actIdx, int _stIdx, int _ct, int _tW ) :
				activityIdx( _actIdx ), startingIdx( _stIdx ), count( _ct ), totalWeight( _tW ) {}

			// default ConstructExor (ought not to be actually used)
			HashValueType( ) : activityIdx( -1 ), startingIdx( -1 ), count( -1 ), totalWeight( -1 )
			{
				//AssertMsg(false, "Don't use default HashValueType()!");
			}


			class HashFuncs
			{
			public:
				// dummy ConstructExor (gndn)
				HashFuncs( int ) {}

				// COMPARE
				// compare two entries for uniqueness. We should never have two different
				// entries for the same activity, so we only compare the activity index;
				// this allows us to use the utlhash as a dict by ConstructExing dummy entries
				// as hash lookup keys.
				/*bool operator()( const HashValueType& lhs, const HashValueType& rhs ) const
				{
					return lhs.activityIdx == rhs.activityIdx;
				}
				// HASH
				// We only hash on the activity index; everything else is data.
				unsigned int operator()( const HashValueType& item ) const
				{
					return HashInt( item.activityIdx );
				}*/
			};
		};

		//typedef CUtlHash<HashValueType, HashValueType::HashFuncs, HashValueType::HashFuncs> ActivityToValueIdxHash;

		// These must be here because IFM does not compile/link studio.cpp (?!?)

		// ctor
		CActivityToSequenceMapping( void )
			: m_pSequenceTuples( NULL ), m_iSequenceTuplesCount( 0 ), m_ActToSeqHash( 8, 0, 0 ), m_pStudioHdr( NULL ), m_expectedVModel( NULL )
		{};

		// dtor -- not virtual because this class has no inheritors
		~CActivityToSequenceMapping( )
		{
			if( m_pSequenceTuples != NULL )
			{
				if( m_pSequenceTuples->pActivityModifiers != NULL )
				{
					delete[ ] m_pSequenceTuples->pActivityModifiers;
				}
				delete[ ] m_pSequenceTuples;
			}
		}

		/// Get the list of sequences for an activity. Returns the pointer to the
		/// first sequence tuple. Output parameters are a count of sequences present,
		/// and the total weight of all the sequences. (it would be more LHS-friendly
		/// to return these on registers, if only C++ offered more than one return 
		/// value....)
		/*const SequenceTuple* GetSequences( int forActivity, int* outSequenceCount, int* outTotalWeight );
		/// The number of sequences available for an activity.
		int NumSequencesForActivity( int forActivity );
		static CActivityToSequenceMapping* FindMapping( const CStudioHdr* pstudiohdr );
		static void ReleaseMapping( CActivityToSequenceMapping* pMap );
		static void ResetMappings( );
		//private:
			/// Allocate my internal array. (It is freed in the destructor.) Also,
			/// build the hash of activities to sequences and populate m_pSequenceTuples.
		void Initialize( const CStudioHdr* pstudiohdr );
		/// Force Initialize() to occur again, even if it has already occured.
		void Reinitialize( CStudioHdr* pstudiohdr );
		/// A more efficient version of the old SelectWeightedSequence() function in animation.cpp.
		int SelectWeightedSequence( CStudioHdr* pstudiohdr, int activity, int curSequence );
		// selects the sequence with the most matching modifiers
		int SelectWeightedSequenceFromModifiers( CStudioHdr* pstudiohdr, int activity, CUtlSymbol* pActivityModifiers, int iModifierCount, CBaseEntity* parent );*/

		// Actually a big array, into which the hash values index.
		SequenceTuple* m_pSequenceTuples;
		unsigned int m_iSequenceTuplesCount; // (size of the whole array)

		// we don't store an outer pointer because we can't initialize it at ConstructExion time
		// (warning c4355) -- there are ways around this but it's easier to just pass in a 
		// pointer to the CStudioHdr when we need it, since this class isn't supposed to 
		// export its interface outside the studio header anyway.
		// CStudioHdr * const m_pOuter;

		Vector m_ActToSeqHash;

		const studiohdr_t* m_pStudioHdr;

		// we store these so we can know if the contents of the studiohdr have changed
		// from underneath our feet (this is an emergency data integrity check)
		const void* m_expectedVModel;


		// double-check that the data I point to hasn't changed
		//bool ValidateAgainst( const CStudioHdr* __restrict pstudiohdr );
		//void SetValidation( const CStudioHdr* __restrict pstudiohdr );

		friend class CStudioHdr;
	};

	CActivityToSequenceMapping* m_pActivityToSequence;

	/*mstudioattachment_t& pAttachment( int i );
	int GetNumAttachments( );
	const studiohdr_t* GroupStudioHdr( DWORD group );
	int GetAttachmentBone( int i );*/
	inline int boneFlags( int iBone ) const { return m_boneFlags[ iBone ]; }
	inline int boneParent( int iBone ) const { return m_boneParent[ iBone ]; }
	inline int			numbones( void ) const { return _m_pStudioHdr->numbones; };
	inline mstudiobone_t* pBone( int i ) const { return _m_pStudioHdr->pBone( i ); };
	//there is more, screw the rest for now..

	inline bool IsValid( void ) { return ( _m_pStudioHdr != NULL ); };
	inline bool IsReadyForAccess( void ) const { return ( _m_pStudioHdr != NULL ); };
	//inline const studiohdr_t* GetRenderHdr( void ) const { return _m_pStudioHdr; };
	//int	GetNumPoseParameters( void ) const;
	//const mstudioposeparamdesc_t& pPoseParameter( int i );
	inline int			numikchains( ) const { return _m_pStudioHdr->flags; };
	inline int			GetNumIKChains( void ) const { return _m_pStudioHdr->numikchains; };
	//inline void*	 pIKChain( int i ) const { return _m_pStudioHdr->pIKChain( i ); };
	//mstudioseqdesc_t& pSeqdesc( int seq );
	virtualmodel_t* GetVirtualModel( ) const { return m_pVModel; };
	//inline const byte* GetBoneTableSortedByName( ) const { return _m_pStudioHdr->GetBoneTableSortedByName( ); };
	/*bool SequencesAvailable( );
	int GetNumSeq( void ) const;
	int GetActivityListVersion( );*/
};
class CStudioHdrEx {
public:
	studiohdr_t* studio_hdr;
	virtualmodel_t* virtual_model;
	char pad[ 120 ];

	int m_nPerfAnimatedBones;
	int m_nPerfUsedBones;
	int m_nPerfAnimationLayers;
};
#pragma endregion

// 
// interfaces
// 
#pragma region decl_interfaces
class IBaseClientDLL;
class IClientEntityList;
class IGameMovement;
class IPrediction;
class IMoveHelper;
class IInput;
class ICVar;
class IVEngineClient;
class IGameEventManager;
class IPanel;
class IMDLCache;
#pragma endregion


// 
// function types
// 
#pragma region decl_function_types
using CreateInterfaceFn = void* ( * )( const char*, int* );
using RecvVarProxyFn = void( * )( CRecvProxyData*, void*, void* );
using pfnDemoCustomDataCallback = void( * )( uint8_t* pData, size_t iSize );
#pragma endregion


// 
// implementation
// 

#pragma region impl_structs
struct string_t {
public:
	const char* ToCStr( ) const;
protected:
	const char* pszValue;
};


#pragma endregion

#pragma region impl_classes


class DVariant {
public:
	union {
		float m_Float;
		int m_Int;
		const char* m_pString;
		void* m_pData;
		float m_Vector[ 3 ];
	};
	SendPropType m_Type;
};

class CRecvProxyData {
public:
	const RecvProp* m_pRecvProp;
private:
	std::uint8_t __pad[ 4 ];
public:
	DVariant m_Value;
	int m_iElement;
	int m_ObjectID;
};

class RecvProp {
public:
	const char* m_pVarName;
	SendPropType m_RecvType;
	int m_Flags;
	int m_StringBufferSize;
	bool m_bInsideArray;
	const void* m_pExtraData;
	RecvProp* m_pArrayProp;
	void* m_ArrayLengthProxy;
	RecvVarProxyFn m_ProxyFn;
	void* m_DataTableProxyFn;
	RecvTable* m_pDataTable;
	int m_Offset;
	int m_ElementStride;
	int m_nElements;
	const char* m_pParentArrayPropName;
};


enum class MotionBlurMode_t {
	MOTION_BLUR_DISABLE = 1,
	MOTION_BLUR_GAME = 2,
	MOTION_BLUR_SFM = 3
};

class CViewSetup {
public:
	int x;
	int oldX;
	int y;
	int oldY;
	int width;
	int oldWidth;
	int height;
	int oldHeight;

	bool m_bOrtho;
	float m_OrthoLeft;
	float m_OrthoTop;
	float m_OrthoRight;
	float m_OrthoBottom;

private:
	char pad1[ 0x7C ];

public:
	float fov;
	float fovViewmodel;
	Vector origin;
	QAngle angles;

	float zNear;
	float zFar;
	float zNearViewmodel;
	float zFarViewmodel;

	float m_flAspectRatio;
	float m_flNearBlurDepth;
	float m_flNearFocusDepth;
	float m_flFarFocusDepth;
	float m_flFarBlurDepth;
	float m_flNearBlurRadius;
	float m_flFarBlurRadius;
	int m_nDoFQuality;
	MotionBlurMode_t m_nMotionBlurMode;

	float m_flShutterTime;
	Vector m_vShutterOpenPosition;
	QAngle m_shutterOpenAngles;
	Vector m_vShutterClosePosition;
	QAngle m_shutterCloseAngles;

	float m_flOffCenterTop;
	float m_flOffCenterBottom;
	float m_flOffCenterLeft;
	float m_flOffCenterRight;

	bool m_bOffCenter : 1;
	bool m_bRenderToSubrectOfLargerScreen : 1;
	bool m_bDoBloomAndToneMapping : 1;
	bool m_bDoDepthOfField : 1;
	bool m_bHDRTarget : 1;
	bool m_bDrawWorldNormal : 1;
	bool m_bCullFrontFaces : 1;
	bool m_bCacheFullSceneState : 1;
	bool m_bRenderFlashlightDepthTranslucents : 1;
private:
	char pad2[ 0x40 ];
};

class CCycleCount {
public:
	long long			m_Int64;
};

class CFastTimer {
public:

private:
	CCycleCount	m_Duration;
	bool m_bRunning;		// Are we currently running?
};

struct DrawModelResults_t {
	int m_ActualTriCount;
	int m_TextureMemoryBytes;
	int m_NumHardwareBones;
	int m_NumBatches;
	int m_NumMaterials;
	int m_nLODUsed;
	int m_flLODMetric;
	CFastTimer m_RenderTime;
	char m_Materials[ 0x20 ];
};

struct ModelRenderInfo_t {
	Vector                  origin;
	QAngle                  angles;
	//char					pad[ 0x4 ];
	IClientRenderable* pRenderable;
	const model_t* pModel;
	const matrix3x4_t* pModelToWorld;
	const matrix3x4_t* pLightingOffset;
	const Vector* pLightingOrigin;
	int                     flags;
	int                     entity_index;
	int                     skin;
	int                     body;
	int                     hitboxset;
	ModelInstanceHandle_t   instance;

	ModelRenderInfo_t( ) {
		pModelToWorld = NULL;
		pLightingOffset = NULL;
		pLightingOrigin = NULL;
	}
};
class LightDesc_t {
public:
	LightType_t m_Type;                 //0x0000
	Vector m_Color;                     //0x0004
	Vector m_Position;                  //0x0010
	Vector m_Direction;                 //0x001C
	float m_Range;                      //0x0028
	float m_Falloff;                    //0x002C
	float m_Attenuation0;               //0x0030
	float m_Attenuation1;               //0x0034
	float m_Attenuation2;               //0x0038
	float m_Theta;                      //0x003C
	float m_Phi;                        //0x0040
	float m_ThetaDot;                   //0x0044
	float m_PhiDot;                     //0x0048
	float m_OneOverThetaDotMinusPhiDot; //0x004C
	__int32 m_Flags;                    //0x0050
	float m_RangeSquared;               //0x0054

}; //Size=0x0058

class lightpos_t {
public:
	Vector delta;  //0x0000
	float falloff; //0x000C
	float dot;     //0x0010

}; //Size=0x0014

struct MaterialLightingState_t {
	Vector m_vecAmbientCube[ 6 ]; // ambient, and lights that aren't in locallight[]
	Vector m_vecLightingOrigin; // The position from which lighting state was computed
	int m_nLocalLightCount;
	LightDesc_t m_pLocalLightDesc[ 4 ];
};
struct DrawModelInfo_t {
	studiohdr_t* m_pStudioHdr;
	studiohwdata_t* m_pHardwareData;
	StudioDecalHandle_t m_Decals;
	int m_Skin;
	int m_Body;
	int m_HitboxSet;
	IClientRenderable* m_pClientEntity;
	int m_Lod;
	ColorMeshInfo_t* m_pColorMeshes;
	bool m_bStaticLighting;
	MaterialLightingState_t m_LightingState;
};
class RecvTable {
public:
	RecvProp* m_pProps;
	int m_nProps;
	void* m_pDecoder;
	const char* m_pNetTableName;
	bool m_bInitialized;
	bool m_bInMainList;
};

using CreateEvent_t = void* ( __cdecl* )( );

class ClientClass {
public:
	void* m_pCreateFn;
	CreateEvent_t m_pCreateEventFn;
	const char* m_pNetworkName;
	RecvTable* m_pRecvTable;
	ClientClass* m_pNext;
	int m_ClassID;
};

enum animstate_layer_t {
	ANIMATION_LAYER_AIMMATRIX = 0,
	ANIMATION_LAYER_WEAPON_ACTION,
	ANIMATION_LAYER_WEAPON_ACTION_RECROUCH,
	ANIMATION_LAYER_ADJUST,
	ANIMATION_LAYER_MOVEMENT_JUMP_OR_FALL,  // fixed
	ANIMATION_LAYER_MOVEMENT_LAND_OR_CLIMB, // fixed
	ANIMATION_LAYER_MOVEMENT_MOVE,          // still not fixed
	ANIMATION_LAYER_MOVEMENT_STRAFECHANGE,
	ANIMATION_LAYER_WHOLE_BODY,
	ANIMATION_LAYER_FLASHED,
	ANIMATION_LAYER_FLINCH,
	ANIMATION_LAYER_ALIVELOOP,
	ANIMATION_LAYER_LEAN,
	ANIMATION_LAYER_COUNT,
};

//struct characterset_t
//{
//  char set[256];
//};

#include "Classes/IMemAlloc.hpp"

#include "Classes/IBaseClientDll.hpp"
#include "Classes/CUserCmd.hpp"
#include "Classes/IClientEntityList.hpp"
#include "Classes/IGameMovement.hpp"
#include "Classes/IPanel.hpp"
#include "Classes/IPrediction.hpp"
#include "Classes/IMoveHelper.hpp"
#include "Classes/IVEngineClient.hpp"
#include "Classes/IInput.hpp"
#include "Classes/IInputSystem.hpp"
#include "Classes/ISurface.hpp"
#include "Classes/IConVar.hpp"
#include "Classes/IGameEventManager.hpp"
#include "Classes/IVModelRender.hpp"
#include "Classes/IMaterialSystem.hpp"
#include "Classes/ISteamClient.hpp"
#include "Classes/IPhysics.hpp"
#include "Classes/WeaponInfo.hpp"
#include "Classes/GlowOutlineEffect.hpp"
#include "Classes/IVModelInfo.hpp"
#include "Classes/CClientState.hpp"
#include "Classes/IVDebugOverlay.hpp"
#include "Classes/IEngineSound.hpp"
#include "Classes/IViewRenderBeams.hpp"
#include "Classes/ILocalize.hpp"
#include "Classes/INetChannel.hpp"
#include "Classes/INetMessage.hpp"
#include "Classes/IStudioRender.hpp"
#include "Classes/CPlayerResource.hpp"
#include "Classes/ICenterPrint.hpp"
#include "Classes/IVRenderView.hpp"
#include "Classes/IClientLeafSystem.hpp"
#include "Classes/IViewRender.hpp"

class NonCopyable {
protected:
	NonCopyable( ) { }
	~NonCopyable( ) { }

private:
	NonCopyable( const NonCopyable& ) = delete;
	NonCopyable& operator=( const NonCopyable& ) = delete;

	NonCopyable( NonCopyable&& ) = delete;
	NonCopyable& operator=( NonCopyable&& ) = delete;
};
struct MaterialSystem_SortInfo_t {
	IMaterial* material;
	int			lightmapPageID;
};
class CVerifiedUserCmd {
public:
	CUserCmd m_cmd = { };
	CRC32_t m_crc = 0u;
};
class C_CommandContext {
public:
	bool			needsprocessing;

	CUserCmd		cmd;
	int				command_number;
};
class CGlobalVarsBase {
public:
	float realtime = 0.0f;
	int framecount = 0;
	float absoluteframetime = 0.0f;
	float absoluteframestarttimestddev = 0.0f;
	float curtime = 0.0f;
	float frametime = 0.0f;
	int maxClients = 0;
	int tickcount = 0;
	float interval_per_tick = 0.0f;
	float interpolation_amount = 0.0f;
	int simTicksThisFrame = 0;
	int network_protocol = 0;
	void* pSaveData = nullptr;
	bool m_bClient = false;
	int nTimestampNetworkingBase = 0;
	int nTimestampRandomizeWindow = 0;
};

class CGlobalVars : public CGlobalVarsBase {
public:
	string_t mapname = { };
	string_t mapGroupName = { };
	int mapversion = 0;
	string_t startspot = { };
	MapLoadType_t eLoadType = MapLoad_NewGame;
	bool bMapLoadFailed = false;
	bool deathmatch = false;
	bool coop = false;
	bool teamplay = false;
	int maxEntities = 0;
	int serverCount = 0;
	void* pEdicts = nullptr;
};


class CMoveData {
public:
	bool    m_bFirstRunOfFunctions : 1;
	bool    m_bGameCodeMovedPlayer : 1;
	int     m_nPlayerHandle;        // edict index on server, client entity handle on client=
	int     m_nImpulseCommand;      // Impulse command issued.
	QAngle  m_vecViewAngles;        // Command view angles (local space)
	Vector  m_vecAbsViewAngles;     // Command view angles (world space)
	int     m_nButtons;             // Attack buttons.
	int     m_nOldButtons;          // From host_client->oldbuttons;
	float   m_flForwardMove;
	float   m_flSideMove;
	float   m_flUpMove;
	float   m_flMaxSpeed;
	float   m_flClientMaxSpeed;
	Vector  m_vecVelocity;          // edict::velocity        // Current movement direction.
	QAngle  m_vecAngles;            // edict::angles
	Vector  m_vecOldAngles;
	float   m_outStepHeight;        // how much you climbed this move
	Vector  m_outWishVel;           // This is where you tried 
	Vector  m_outJumpVel;           // This is your jump velocity
	Vector  m_vecConstraintCenter;
	float   m_flConstraintRadius;
	float   m_flConstraintWidth;
	float   m_flConstraintSpeedFactor;
	float   m_flUnknown[ 5 ];
	Vector  m_vecAbsOrigin;
	char pad[ 1000 ] = { };
};

enum SoundServerFlags {
	SV_SND_STATIC_SOUND = ( 1 << 0 ),
	SV_SND_UPDATEPOS = ( 1 << 1 ),
	SV_SND_FROMSERVER = ( 1 << 2 ),
	SV_SND_STOPSOUND = ( 1 << 3 ),
};

struct StartSoundParams_t {
	StartSoundParams_t( ) :
		staticsound( false ),
		soundsource( 0 ),
		entchannel( 0 ),
		pSfx( 0 ),
		fvol( 1.0f ),
		soundlevel( SNDLVL_NORM ),
		flags( 0 ),
		pitch( PITCH_NORM ),
		ServerFlags( 0 ),
		delay( 0.0f ),
		speakerentity( -1 ),
		suppressrecording( false ),
		initialStreamPosition( 0 ) {
		origin.Init( );
		direction.Init( );
	}

	bool staticsound;
	int soundsource;
	int entchannel;
	uintptr_t* pSfx;
	Vector origin;
	Vector direction;
	float fvol;
	soundlevel_t soundlevel;
	int flags;
	int pitch;
	float delay;
	int speakerentity;
	int unk;
	bool suppressrecording;
	int initialStreamPosition;
	int unk01;
	int unk02;
	const char* soundName;
	int unk03;
	int unk04;
	int ServerFlags; // SoundServerFlags
	int unk06;
};
#pragma endregion

#pragma region rain
// How many bits to use to encode an edict.
#define	MAX_EDICT_BITS				11			// # of bits needed to represent max edicts
// Max # of edicts in a level
#define	MAX_EDICTS					(1<<MAX_EDICT_BITS)

// Types of precipitation
enum PrecipitationType_t {
	PRECIPITATION_TYPE_RAIN = 0,
	PRECIPITATION_TYPE_SNOW,
	PRECIPITATION_TYPE_ASH,
	PRECIPITATION_TYPE_SNOWFALL,
	PRECIPITATION_TYPE_PARTICLERAIN,
	PRECIPITATION_TYPE_PARTICLEASH,
	PRECIPITATION_TYPE_PARTICLERAINSTORM,
	PRECIPITATION_TYPE_PARTICLESNOW,
	NUM_PRECIPITATION_TYPES
};

#pragma endregion

#pragma region impl_interfaces
class IMDLCache : public IAppSystem {
public:
	virtual void                SetCacheNotify( void* pNotify ) = 0;
	virtual MDLHandle_t         FindMDL( const char* pMDLRelativePath ) = 0;
	virtual int32_t                 AddRef( MDLHandle_t handle ) = 0;
	virtual int32_t                 Release( MDLHandle_t handle ) = 0;
	virtual int32_t                 GetRef( MDLHandle_t handle ) = 0;
	virtual studiohdr_t* GetStudioHdr( MDLHandle_t handle ) = 0;
	virtual studiohwdata_t* GetHardwareData( MDLHandle_t handle ) = 0;
	virtual vcollide_t* GetVCollide( MDLHandle_t handle ) = 0;
	virtual unsigned char* GetAnimBlock( MDLHandle_t handle, int32_t nBlock ) = 0;
	virtual virtualmodel_t* GetVirtualModel( MDLHandle_t handle ) = 0;
	virtual int32_t                 GetAutoplayList( MDLHandle_t handle, unsigned short** pOut ) = 0;
	virtual vertexFileHeader_t* GetVertexData( MDLHandle_t handle ) = 0;
	virtual void                TouchAllData( MDLHandle_t handle ) = 0;
	virtual void                SetUserData( MDLHandle_t handle, void* pData ) = 0;
	virtual void* GetUserData( MDLHandle_t handle ) = 0;
	virtual bool                IsErrorModel( MDLHandle_t handle ) = 0;
	virtual void                Flush( MDLCacheFlush_t nFlushFlags = MDLCACHE_FLUSH_ALL ) = 0;
	virtual void                Flush( MDLHandle_t handle, int32_t nFlushFlags = MDLCACHE_FLUSH_ALL ) = 0;
	virtual const char* GetModelName( MDLHandle_t handle ) = 0;
	virtual virtualmodel_t* GetVirtualModelFast( const studiohdr_t* pStudioHdr, MDLHandle_t handle ) = 0;
	virtual void                BeginLock( ) = 0;
	virtual void                EndLock( ) = 0;
	virtual int32_t* GetFrameUnlockCounterPtrOLD( ) = 0;
	virtual void                FinishPendingLoads( ) = 0;
	virtual vcollide_t* GetVCollideEx( MDLHandle_t handle, bool synchronousLoad = true ) = 0;
	virtual bool                GetVCollideSize( MDLHandle_t handle, int32_t* pVCollideSize ) = 0;
	virtual bool                GetAsyncLoad( MDLCacheDataType_t type ) = 0;
	virtual bool                SetAsyncLoad( MDLCacheDataType_t type, bool bAsync ) = 0;
	virtual void                BeginMapLoad( ) = 0;
	virtual void                EndMapLoad( ) = 0;
	virtual void                MarkAsLoaded( MDLHandle_t handle ) = 0;
	virtual void                InitPreloadData( bool rebuild ) = 0;
	virtual void                ShutdownPreloadData( ) = 0;
	virtual bool                IsDataLoaded( MDLHandle_t handle, MDLCacheDataType_t type ) = 0;
	virtual int32_t* GetFrameUnlockCounterPtr( MDLCacheDataType_t type ) = 0;
	virtual studiohdr_t* LockStudioHdr( MDLHandle_t handle ) = 0;
	virtual void                UnlockStudioHdr( MDLHandle_t handle ) = 0;
	virtual bool                PreloadModel( MDLHandle_t handle ) = 0;
	virtual void                ResetErrorModelStatus( MDLHandle_t handle ) = 0;
	virtual void                MarkFrame( ) = 0;
	virtual void                BeginCoarseLock( ) = 0;
	virtual void                EndCoarseLock( ) = 0;
	virtual void                ReloadVCollide( MDLHandle_t handle ) = 0;
};
#pragma endregion

#pragma region decl_functions
void RandomSeed( unsigned int seed );
float RandomFloat( float min, float max );
int RandomInt( int min, int max );

void CRC32_Init( CRC32_t* pulCRC );
void CRC32_ProcessBuffer( CRC32_t* pulCRC, const void* p, int len );
void CRC32_Final( CRC32_t* pulCRC );
CRC32_t CRC32_GetTableEntry( unsigned int slot );

template<class T>
static T FindHudElement( const char* name ) {
	static auto pThis = *reinterpret_cast< uintptr_t** >( Engine::Displacement.Data.m_uHudElement );
	if( !pThis )
		return ( T )0;

	static auto find_hud_element = reinterpret_cast< uintptr_t( __thiscall* )( void*, const char* ) >( Engine::Displacement.Function.m_uFindHudElement );
	return ( T )find_hud_element( pThis, name );
}

extern const CRC32_t pulCRCTable[ 256 ];
#pragma endregion

#define XOR_VAL xor_val
#define ADD_VAL 0x74C59A20

#if 1
template<typename T>
class Encrypted_t {
public:
	T* pointer;

	__forceinline Encrypted_t( T* ptr ) {
		pointer = ptr;
	}

	__forceinline  T* Xor( ) const {
		return  pointer;
	}

	__forceinline  T* operator-> ( ) {
		return Xor( );
	}

	__forceinline bool IsValid( ) const {
		return pointer != nullptr;
	}
};
#else
#pragma  optimize( "", off ) 
template<typename T>
class Encrypted_t {
	__forceinline uintptr_t rotate_dec( uintptr_t c ) const {
		return c;
		//return ( ( c & 0xFFFF ) << 16 | ( c & 0xFFFF0000 ) >> 16 );
#if 0
		return ( c & 0xF ) << 28 | ( c & 0xF0000000 ) >> 28
			| ( c & 0xF0 ) << 20 | ( c & 0x0F000000 ) >> 20
			| ( c & 0xF00 ) << 12 | ( c & 0x00F00000 ) >> 12
			| ( c & 0xF000 ) << 4 | ( c & 0x000F0000 ) >> 4;
#endif
	}
public:
	uintptr_t np;
	uintptr_t xor_val;

	__forceinline Encrypted_t( T* ptr ) {
		auto p = &ptr;
		xor_val = rotate_dec( pulCRCTable[ *( ( uint8_t* )p + 1 ) + ( ( ( uintptr_t( ptr ) >> 16 ) & 7 ) << 8 ) ] );
		np = rotate_dec( rotate_dec( xor_val ) ^ ( uintptr_t( ptr ) + ADD_VAL ) );
	}

	__forceinline  T* Xor( ) const {
		return ( T* )( ( uintptr_t )( rotate_dec( np ) ^ rotate_dec( xor_val ) ) - ADD_VAL );
	}

	__forceinline  T* operator-> ( ) {
		return Xor( );
	}

	__forceinline bool IsValid( ) const {
		return ( ( uintptr_t )( rotate_dec( np ) ^ rotate_dec( xor_val ) ) - ADD_VAL ) != 0;
	}
};
#pragma  optimize( "", on )

#endif

class INetGraphPanel {
public:
	char _pad0[ 0x13208 ];
	unsigned long m_font_small;
	unsigned long m_font_proportional;
	unsigned long m_font_font;
};

struct Hit_t {
	char pad0x8[ 0x8 ];
	float x;
	float y;
	float time;
	float z;
};

class NoticeText_t {
public:
	wchar_t m_nString[ 512 ]; //0x0000 
	char pad_0x0400[ 0xC ]; //0x0400
	float set; //0x040C
	float m_flStartTime; //0x0410 
	float m_flStartTime2; //0x0414 
	float m_flLifeTimeModifier; //0x0418 
	char pad_0x041C[ 0x4 ]; //0x041C
}; //Size=0x420

class SFHudDeathNoticeAndBotStatus {
public:
	char pad_0000[ 28 ]; //0x0000
	char* m_szHudName; //0x001C
	char pad_0020[ 64 ]; //0x0020
	float m_flTime; //0x0060
	char pad_0064[ 4 ]; //0x0064
	CUtlVector< NoticeText_t > m_vecDeathNotices;
};

class CHud {
public:
	template< class T >
	T FindHudElement( const char* name ) {
		static auto FindHudElement_t = reinterpret_cast< uintptr_t( __thiscall* )( void*, const char* ) >( Memory::Scan( XorStr( "client.dll" ), XorStr( "55 8B EC 53 8B 5D 08 56 57 8B F9 33 F6 39 77 28" ) ) );

		return reinterpret_cast< T >( FindHudElement_t( this, name ) );
	}
};

#include "../Renderer/Render.hpp"

#include "../Menu/Helpers/Easing.h"
#include "../Menu/Framework/GUI.h"
#include "../Menu/Elements.h"
```

`CSGO SDK/Utils/Config.cpp`:

```cpp
#include "Config.hpp"
#include "../Utils/base64.h"
#include "../Libraries/json.h"
#include <fstream>
#include <iomanip>
#include "../SDK/CVariables.hpp"

#define _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING
#include <experimental/filesystem>

#include <shlobj.h>
#include <sstream>

BOOL ConfigManager::DirectoryExists( LPCTSTR szPath ) {
	DWORD dwAttrib = GetFileAttributes( szPath );

	return ( dwAttrib != INVALID_FILE_ATTRIBUTES &&
		( dwAttrib & FILE_ATTRIBUTE_DIRECTORY ) );
}

std::vector<std::string> ConfigManager::GetConfigs( ) {
	static bool created_cfg = true;
	if( created_cfg ) {
		namespace fs = std::experimental::filesystem;
		fs::path full_path( fs::current_path( ) );
		std::wstring str = full_path.wstring( ) + XorStr( L"\\autism" );

		CreateDirectoryW( str.c_str( ), nullptr );
		str += XorStr( L"\\cfg" );
		CreateDirectoryW( str.c_str( ), nullptr );

		created_cfg = false;
	}

	std::string config_extension = XorStr( ".json" );
	std::vector<std::string> names;

	WIN32_FIND_DATAA find_data;
	HANDLE preset_file = FindFirstFileA( ( XorStr( "autism\\cfg\\*" ) + config_extension ).c_str( ), &find_data );

	if( preset_file != INVALID_HANDLE_VALUE ) {
		do {
			if( find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
				continue;

			std::string s = find_data.cFileName;
			int pos = s.find( XorStr( ".json" ) );

			s.erase( s.begin( ) + pos, s.begin( ) + pos + 5 );

			names.push_back( s.c_str( ) );
		} while( FindNextFileA( preset_file, &find_data ) );

		FindClose( preset_file );
	}

	return names;
}

void ConfigManager::LoadConfig( std::string configname ) {
	std::ifstream input_file = std::ifstream( ( XorStr( "autism\\cfg\\" ) + configname + XorStr( ".json" ) ).c_str( ) );
	if( !input_file.good( ) )
		return;

	try {
		std::stringstream content{ };

		content << input_file.rdbuf( );

		if( content.str( ).empty( ) )
			return;

		auto decoded_string = base64::decode( content.str( ) );
		// this a vader config nigga?
		if( decoded_string[ 0 ] != '[' ||
			decoded_string[ 1 ] != 't' ||
			decoded_string[ 2 ] != 'e' ||
			decoded_string[ 3 ] != 'c' ||
			decoded_string[ 4 ] != 'h' ||
			decoded_string[ 5 ] != ']' ||
			decoded_string[ 6 ] != ' ' ||
			decoded_string[ 7 ] != '-' ||
			decoded_string[ 8 ] != ' ' )
			return;

		// yes it is nigga
		auto parsed_config = nlohmann::json::parse( decoded_string.erase( 0, 8 ) );

		g_Vars.m_json = parsed_config;
		input_file.close( );
	}
	catch( ... ) {
		input_file.close( );
		return;
	}

	for( auto& child : g_Vars.m_children ) {
		child->Load( g_Vars.m_json[ child->GetName( ) ] );
	}
}

void ConfigManager::SaveConfig( std::string configname ) {
	std::ofstream o( ( XorStr( "autism\\cfg\\" ) + configname + XorStr( ".json" ) ).c_str( ) );
	if( !o.is_open( ) )
		return;

	g_Vars.m_json.clear( );
	for( auto& child : g_Vars.m_children ) {
		child->Save( );

		auto json = child->GetJson( );
		g_Vars.m_json[ child->GetName( ) ] = ( json );
	}

	o.clear( );
	auto str = base64::encode( ( std::string( XorStr( "[tech] - " ) ).append( g_Vars.m_json.dump( -1, '~', true ) ) ).c_str( ) );
	o << str;
	o.close( );

	g_Vars.m_json.clear( );
}

void ConfigManager::RemoveConfig( std::string configname ) {
	std::remove( ( XorStr( "autism\\cfg\\" ) + configname + XorStr( ".json" ) ).c_str( ) );
}

void ConfigManager::CreateConfig( std::string configname ) {
	std::ofstream o( ( XorStr( "autism\\cfg\\" ) + configname + XorStr( ".json" ) ).c_str( ) );
}

void ConfigManager::ResetConfig( ) {
	for( auto& child : g_Vars.m_children ) {
		child->Load( g_Vars.m_json_default_cfg[ child->GetName( ) ] );
	}
}

void ConfigManager::OpenConfigFolder( ) {
	namespace fs = std::experimental::filesystem;
	fs::path full_path( fs::current_path( ) );

	std::wstring str = full_path.wstring( ) + XorStr( L"\\autism\\cfg" );

	PIDLIST_ABSOLUTE pidl;
	if( SUCCEEDED( SHParseDisplayName( str.c_str( ), 0, &pidl, 0, 0 ) ) ) {
		// we don't want to actually select anything in the folder, so we pass an empty
		// PIDL in the array. if you want to select one or more items in the opened
		// folder you'd need to build the PIDL array appropriately
		ITEMIDLIST idNull = { 0 };
		LPCITEMIDLIST pidlNull[ 1 ] = { &idNull };
		SHOpenFolderAndSelectItems( pidl, 1, pidlNull, 0 );

		// LIFEEEEHAAAACK BITCH!!! (◣_◢)
		using ILFree_t = void( __stdcall* )( LPITEMIDLIST );
		static ILFree_t ILFree_fn = ( ILFree_t ) GetProcAddress( GetModuleHandleA( XorStr( "SHELL32" ) ), XorStr( "ILFree" ) );
		ILFree_fn( pidl );
	}
}
```

`CSGO SDK/Utils/Config.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <vector>
#include <string>

namespace ConfigManager
{
   BOOL DirectoryExists( LPCTSTR szPath );
   std::vector<std::string> GetConfigs( );
   void LoadConfig( std::string configname );
   void SaveConfig( std::string configname );
   void RemoveConfig( std::string configname );
   void CreateConfig( std::string configname );
   void ResetConfig( );
   void OpenConfigFolder( );
}

```

`CSGO SDK/Utils/CrashHandler.cpp`:

```cpp
#include "CrashHandler.hpp"
#include "LogSystem.hpp"

class CrashHandler : public ICrashHandler {
public:
   long __stdcall OnCrashProgramm( struct _EXCEPTION_POINTERS* ) override;

private:
};

Encrypted_t<ICrashHandler> ICrashHandler::Get( ) {
   static CrashHandler instance;
   return &instance;
}

long __stdcall CrashHandler::OnCrashProgramm( struct _EXCEPTION_POINTERS* ExceptionInfo ) {
   ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "---------------------------------" ) );
   ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "base: 0x%p" ), g_Vars.globals.hModule );
   ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "exception at: 0x%p, magic: %s" ), ExceptionInfo->ExceptionRecord->ExceptionAddress, g_Vars.globals.szLastHookCalled.c_str( ) );

   int m_ExceptionCode = ExceptionInfo->ExceptionRecord->ExceptionCode;
   int m_exceptionInfo_0 = ExceptionInfo->ExceptionRecord->ExceptionInformation[ 0 ];
   int m_exceptionInfo_1 = ExceptionInfo->ExceptionRecord->ExceptionInformation[ 1 ];
   int m_exceptionInfo_2 = ExceptionInfo->ExceptionRecord->ExceptionInformation[ 2 ];

   switch ( m_ExceptionCode ) {
	  case EXCEPTION_ACCESS_VIOLATION:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_ACCESS_VIOLATION" ) );
	  if ( m_exceptionInfo_0 == 0 ) {
		 // bad read
		 ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "Attempted to read from: 0x%08x" ), m_exceptionInfo_1 );
	  } else if ( m_exceptionInfo_0 == 1 ) {
		 // bad write
		 ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "Attempted to write to: 0x%08x" ), m_exceptionInfo_1 );
	  } else if ( m_exceptionInfo_0 == 8 ) {
		 // user-mode data execution prevention (DEP)
		 ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "Data Execution Prevention (DEP) at: 0x%08x" ), m_exceptionInfo_1 );
	  } else {
		 // unknown, shouldn't happen
		 ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "Unknown access violation at: 0x%08x" ), m_exceptionInfo_1 );
	  }
	  break;

	  case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_ARRAY_BOUNDS_EXCEEDED" ) );
	  break;

	  case EXCEPTION_BREAKPOINT:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_BREAKPOINT" ) );
	  break;

	  case EXCEPTION_DATATYPE_MISALIGNMENT:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_DATATYPE_MISALIGNMENT" ) );
	  break;

	  case EXCEPTION_FLT_DENORMAL_OPERAND:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_FLT_DENORMAL_OPERAND" ) );
	  break;

	  case EXCEPTION_FLT_DIVIDE_BY_ZERO:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_FLT_DIVIDE_BY_ZERO" ) );
	  break;

	  case EXCEPTION_FLT_INEXACT_RESULT:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_FLT_INEXACT_RESULT" ) );
	  break;

	  case EXCEPTION_FLT_INVALID_OPERATION:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_FLT_INVALID_OPERATION" ) );
	  break;

	  case EXCEPTION_FLT_OVERFLOW:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_FLT_OVERFLOW" ) );
	  break;

	  case EXCEPTION_FLT_STACK_CHECK:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_FLT_STACK_CHECK" ) );
	  break;

	  case EXCEPTION_FLT_UNDERFLOW:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_FLT_UNDERFLOW" ) );
	  break;

	  case EXCEPTION_ILLEGAL_INSTRUCTION:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_ILLEGAL_INSTRUCTION" ) );
	  break;

	  case EXCEPTION_IN_PAGE_ERROR:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_IN_PAGE_ERROR" ) );
	  if ( m_exceptionInfo_0 == 0 ) {
		 // bad read
		 ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "Attempted to read from: 0x%08x" ), m_exceptionInfo_1 );
	  } else if ( m_exceptionInfo_0 == 1 ) {
		 // bad write
		 ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "Attempted to write to: 0x%08x" ), m_exceptionInfo_1 );
	  } else if ( m_exceptionInfo_0 == 8 ) {
		 // user-mode data execution prevention (DEP)
		 ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "Data Execution Prevention (DEP) at: 0x%08x" ), m_exceptionInfo_1 );
	  } else {
		 // unknown, shouldn't happen
		 ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "Unknown access violation at: 0x%08x" ), m_exceptionInfo_1 );
	  }

	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "NTSTATUS: 0x%08x" ), m_exceptionInfo_2 );
	  break;

	  case EXCEPTION_INT_DIVIDE_BY_ZERO:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_INT_DIVIDE_BY_ZERO" ) );
	  break;

	  case EXCEPTION_INT_OVERFLOW:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_INT_OVERFLOW" ) );
	  break;

	  case EXCEPTION_INVALID_DISPOSITION:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_INVALID_DISPOSITION" ) );
	  break;

	  case EXCEPTION_NONCONTINUABLE_EXCEPTION:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_NONCONTINUABLE_EXCEPTION" ) );
	  break;

	  case EXCEPTION_PRIV_INSTRUCTION:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_PRIV_INSTRUCTION" ) );
	  break;

	  case EXCEPTION_SINGLE_STEP:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_SINGLE_STEP" ) );
	  break;

	  case EXCEPTION_STACK_OVERFLOW:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: EXCEPTION_STACK_OVERFLOW" ) );
	  break;

	  case DBG_CONTROL_C:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: DBG_CONTROL_C" ) );
	  break;

	  default:
	  ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "CODE: %08x" ), m_ExceptionCode );
   }

   ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "---------------------------------" ) );

   ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "asm registers:" ) );
   ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "eax: 0x%08x | esi: 0x%08x" ), ExceptionInfo->ContextRecord->Eax, ExceptionInfo->ContextRecord->Esi );
   ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "ebx: 0x%08x | edi: 0x%08x" ), ExceptionInfo->ContextRecord->Ebx, ExceptionInfo->ContextRecord->Edi );
   ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "ecx: 0x%08x | ebp: 0x%08x" ), ExceptionInfo->ContextRecord->Ecx, ExceptionInfo->ContextRecord->Ebp );
   ILogSystem::Get( )->Log( XorStr( ".ams" ), XorStr( "edx: 0x%08x | esp: 0x%08x" ), ExceptionInfo->ContextRecord->Edx, ExceptionInfo->ContextRecord->Esp );

   return EXCEPTION_CONTINUE_SEARCH;
}

```

`CSGO SDK/Utils/CrashHandler.hpp`:

```hpp
#pragma once
#include "../SDK/sdk.hpp"

class __declspec( novtable ) ICrashHandler : public NonCopyable {
public:
   static Encrypted_t<ICrashHandler> Get( );
   virtual long __stdcall OnCrashProgramm( struct _EXCEPTION_POINTERS* ) = NULL;
   
protected:
   ICrashHandler( ) {

   }
   virtual ~ICrashHandler( ) {

   }
};
```

`CSGO SDK/Utils/FnvHash.hpp`:

```hpp
#pragma once
#include <stdint.h>

//fnv1a 32 and 64 bit hash functions
// key is the data to hash, len is the size of the data (or how much of it to hash against)
// code license: public domain or equivalent
// post: https://notes.underscorediscovery.com/constexpr-fnv1a/

constexpr uint32_t val_32_const = 0x811c9dc5;
constexpr uint32_t prime_32_const = 0x1000193;
constexpr uint64_t val_64_const = 0xcbf29ce484222325;
constexpr uint64_t prime_64_const = 0x100000001b3;

inline const uint32_t hash_32_fnv1a( const void* key, const uint32_t len ) {

  const char* data = ( char* )key;
  uint32_t hash = 0x811c9dc5;
  uint32_t prime = 0x1000193;

  for( int i = 0; i < len; ++i ) {
	 uint8_t value = data[i];
	 hash = hash ^ value;
	 hash *= prime;
  }

  return hash;

} //hash_32_fnv1a

inline const uint64_t hash_64_fnv1a( const void* key, const uint64_t len ) {

  const char* data = ( char* )key;
  uint64_t hash = 0xcbf29ce484222325;
  uint64_t prime = 0x100000001b3;

  for( int i = 0; i < len; ++i ) {
	 uint8_t value = data[i];
	 hash = hash ^ value;
	 hash *= prime;
  }

  return hash;

} //hash_64_fnv1a

inline constexpr uint32_t hash_32_fnv1a_const( const char* const str, const uint32_t value = val_32_const ) noexcept {
  return ( str[0] == '\0' ) ? value : hash_32_fnv1a_const( &str[1], ( value ^ uint32_t( str[0] ) ) * prime_32_const );
}

inline constexpr uint64_t hash_64_fnv1a_const( const char* const str, const uint64_t value = val_64_const ) noexcept {
  return ( str[0] == '\0' ) ? value : hash_64_fnv1a_const( &str[1], ( value ^ uint64_t( str[0] ) ) * prime_64_const );
}

```

`CSGO SDK/Utils/InputSys.cpp`:

```cpp
#define NOMINMAX
#include <Windows.h>
#include <cstdint>
#include <map>
#include <memory>
#include <stdexcept>
#include "InputSys.hpp"
#include "../source.hpp"

#include "../SDK/CVariables.hpp"

class Win32InputSys : public InputSys {
public:
	Win32InputSys( );
	virtual ~Win32InputSys( );

	virtual bool Initialize( IDirect3DDevice9* pDevice );
	virtual void Destroy( );

	virtual void* GetMainWindow( ) const { return ( void* )m_hTargetWindow; }

	virtual KeyState GetKeyState( int vk );
	virtual bool IsKeyDown( int vk );
	virtual bool IsInBox( Vector2D box_pos, Vector2D box_size );
	virtual bool WasKeyPressed( int vk );

	virtual void RegisterHotkey( int vk, std::function< void( void ) > f );
	virtual void RemoveHotkey( int vk );

	virtual Vector2D GetMousePosition( ) {
		return m_MousePos;
	}

	virtual float GetScrollMouse( ) {
		return m_ScrollMouse;
	}

	virtual void SetScrollMouse( float scroll ) {
		m_ScrollMouse = scroll;
	}

private:
	static LRESULT WINAPI WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam );

	bool ProcessMessage( UINT uMsg, WPARAM wParam, LPARAM lParam );
	bool ProcessMouseMessage( UINT uMsg, WPARAM wParam, LPARAM lParam );
	bool ProcessKeybdMessage( UINT uMsg, WPARAM wParam, LPARAM lParam );

	float  m_ScrollMouse = 0.0f;

	HWND m_hTargetWindow;
	LONG_PTR m_ulOldWndProc;
	KeyState m_iKeyMap[ 256 ];

	Vector2D m_MousePos;

	std::function< void( void ) > m_Hotkeys[ 256 ];
};

Encrypted_t<InputSys> InputSys::Get( ) {
	static Win32InputSys instance;
	return &instance;
}

Win32InputSys::Win32InputSys( ) :
	m_hTargetWindow( nullptr ), m_ulOldWndProc( 0 ) {
}

Win32InputSys::~Win32InputSys( ) {
}

bool Win32InputSys::Initialize( IDirect3DDevice9* pDevice ) {
	D3DDEVICE_CREATION_PARAMETERS params;

	if( FAILED( pDevice->GetCreationParameters( &params ) ) ) {
		Win32::Error( XorStr( "GetCreationParameters failed" ) );
		return false;
	}

	m_hTargetWindow = params.hFocusWindow;
	m_ulOldWndProc = SetWindowLongPtr( m_hTargetWindow, GWLP_WNDPROC, ( LONG_PTR )WndProc );

	if( !m_ulOldWndProc ) {
		Win32::Error( XorStr( "SetWindowLongPtr failed" ) );
		return false;
	}

	return true;
}

void Win32InputSys::Destroy( ) {
	if( m_ulOldWndProc )
		SetWindowLongPtr( m_hTargetWindow, GWLP_WNDPROC, m_ulOldWndProc );
	m_ulOldWndProc = 0;
}

LRESULT __stdcall Win32InputSys::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ) {
	auto win32input = static_cast< Win32InputSys* >( Get( ).Xor( ) );
	if( !Interfaces::m_pClient->IsChatRaised( ) && !Interfaces::m_pEngine->Con_IsVisible( ) ) {
		win32input->ProcessMessage( msg, wParam, lParam );
	}

	if( msg == WM_MOUSEMOVE ) {
		win32input->m_MousePos.x = ( signed short )( lParam );
		win32input->m_MousePos.y = ( signed short )( lParam >> 16 );
	}
	else if( msg == WM_MOUSEWHEEL || msg == WM_MOUSEHWHEEL ) {
		win32input->m_ScrollMouse += ( float )GET_WHEEL_DELTA_WPARAM( wParam ) / ( float )WHEEL_DELTA;
	}

	if( g_Vars.globals.menuOpen ) {
		if( msg == WM_MOUSEWHEEL || msg == WM_MOUSEHWHEEL )
			return true;
	}

	return CallWindowProc( ( WNDPROC )win32input->m_ulOldWndProc, hWnd, msg, wParam, lParam );
}

bool Win32InputSys::ProcessMessage( UINT uMsg, WPARAM wParam, LPARAM lParam ) {
	switch( uMsg ) {
	case WM_MBUTTONDBLCLK:
	case WM_RBUTTONDBLCLK:
	case WM_LBUTTONDBLCLK:
	case WM_XBUTTONDBLCLK:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_LBUTTONDOWN:
	case WM_XBUTTONDOWN:
	case WM_MBUTTONUP:
	case WM_RBUTTONUP:
	case WM_LBUTTONUP:
	case WM_XBUTTONUP:
		return ProcessMouseMessage( uMsg, wParam, lParam );
	case WM_KEYDOWN:
	case WM_KEYUP:
	case WM_SYSKEYDOWN:
	case WM_SYSKEYUP:
		return ProcessKeybdMessage( uMsg, wParam, lParam );
	default:
		return false;
	}
}

bool Win32InputSys::ProcessMouseMessage( UINT uMsg, WPARAM wParam, LPARAM lParam ) {
	auto key = VK_LBUTTON;
	auto state = KeyState::None;

	switch( uMsg ) {
	case WM_MBUTTONDOWN:
	case WM_MBUTTONUP:
		state = uMsg == WM_MBUTTONUP ? KeyState::Up : KeyState::Down;
		key = VK_MBUTTON;
		break;
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
		state = uMsg == WM_RBUTTONUP ? KeyState::Up : KeyState::Down;
		key = VK_RBUTTON;
		break;
	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
		state = uMsg == WM_LBUTTONUP ? KeyState::Up : KeyState::Down;
		key = VK_LBUTTON;
		break;
	case WM_XBUTTONDOWN:
	case WM_XBUTTONUP:
		state = uMsg == WM_XBUTTONUP ? KeyState::Up : KeyState::Down;
		key = ( HIWORD( wParam ) == XBUTTON1 ? VK_XBUTTON1 : VK_XBUTTON2 );
		break;
	default:
		return false;
	}

	if( state == KeyState::Up && m_iKeyMap[ key ] == KeyState::Down ) {
		m_iKeyMap[ key ] = KeyState::Pressed;
	}
	else
		m_iKeyMap[ key ] = state;
	return true;
}

bool Win32InputSys::ProcessKeybdMessage( UINT uMsg, WPARAM wParam, LPARAM lParam ) {
	auto key = wParam;
	auto state = KeyState::None;

	switch( uMsg ) {
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		state = KeyState::Down;
		break;
	case WM_KEYUP:
	case WM_SYSKEYUP:
		state = KeyState::Up;
		break;
	default:
		return false;
	}

	if( state == KeyState::Up && m_iKeyMap[ int( key ) ] == KeyState::Down ) {
		m_iKeyMap[ int( key ) ] = KeyState::Pressed;

		auto& hotkey_callback = m_Hotkeys[ key ];

		if( hotkey_callback )
			hotkey_callback( );

	}
	else {
		m_iKeyMap[ int( key ) ] = state;
	}

	return true;
}

KeyState Win32InputSys::GetKeyState( int vk ) {
	return m_iKeyMap[ vk ];
}

bool Win32InputSys::IsKeyDown( int vk ) {
	if( vk <= 0 || vk > 255 )
		return false;

	return m_iKeyMap[ vk ] == KeyState::Down;
}

bool Win32InputSys::IsInBox( Vector2D box_pos, Vector2D box_size ) {
	return (
		m_MousePos.x > box_pos.x &&
		m_MousePos.y > box_pos.y &&
		m_MousePos.x < box_pos.x + box_size.x &&
		m_MousePos.y < box_pos.y + box_size.y
		);
}

bool Win32InputSys::WasKeyPressed( int vk ) {
	if( vk <= 0 || vk > 255 )
		return false;

	if( m_iKeyMap[ vk ] == KeyState::Pressed ) {
		m_iKeyMap[ vk ] = KeyState::Up;
		return true;
	}

	return false;
}

void Win32InputSys::RegisterHotkey( int vk, std::function< void( void ) > f ) {
	m_Hotkeys[ vk ] = f;
}

void Win32InputSys::RemoveHotkey( int vk ) {
	m_Hotkeys[ vk ] = nullptr;
}
```

`CSGO SDK/Utils/InputSys.hpp`:

```hpp
#pragma once

#include <functional>
#include "../SDK/sdk.hpp"

enum class KeyState : int {
   None = 1,
   Down,
   Up,
   Pressed,
};

namespace VirtualKeys
{
   enum {
	  LeftButton = 0x01,
	  RightButton = 0x02,
	  Cancel = 0x03,
	  MiddleButton = 0x04,
	  ExtraButton1 = 0x05,
	  ExtraButton2 = 0x06,
	  Back = 0x08,
	  Tab = 0x09,
	  Clear = 0x0C,
	  Return = 0x0D,
	  Shift = 0x10,
	  Control = 0x11,
	  Menu = 0x12,
	  Pause = 0x13,
	  CapsLock = 0x14,
	  Kana = 0x15,
	  Hangeul = 0x15,
	  Hangul = 0x15,
	  Junja = 0x17,
	  Final = 0x18,
	  Hanja = 0x19,
	  Kanji = 0x19,
	  Escape = 0x1B,
	  Convert = 0x1C,
	  NonConvert = 0x1D,
	  Accept = 0x1E,
	  ModeChange = 0x1F,
	  Space = 0x20,
	  Prior = 0x21,
	  Next = 0x22,
	  End = 0x23,
	  Home = 0x24,
	  Left = 0x25,
	  Up = 0x26,
	  Right = 0x27,
	  Down = 0x28,
	  Select = 0x29,
	  Print = 0x2A,
	  Execute = 0x2B,
	  Snapshot = 0x2C,
	  Insert = 0x2D,
	  Delete = 0x2E,
	  Help = 0x2F,
	  N0 = 0x30,
	  N1 = 0x31,
	  N2 = 0x32,
	  N3 = 0x33,
	  N4 = 0x34,
	  N5 = 0x35,
	  N6 = 0x36,
	  N7 = 0x37,
	  N8 = 0x38,
	  N9 = 0x39,
	  A = 0x41,
	  B = 0x42,
	  C = 0x43,
	  D = 0x44,
	  E = 0x45,
	  F = 0x46,
	  G = 0x47,
	  H = 0x48,
	  I = 0x49,
	  J = 0x4A,
	  K = 0x4B,
	  L = 0x4C,
	  M = 0x4D,
	  N = 0x4E,
	  O = 0x4F,
	  P = 0x50,
	  Q = 0x51,
	  R = 0x52,
	  S = 0x53,
	  T = 0x54,
	  U = 0x55,
	  V = 0x56,
	  W = 0x57,
	  X = 0x58,
	  Y = 0x59,
	  Z = 0x5A,
	  LeftWindows = 0x5B,
	  RightWindows = 0x5C,
	  Application = 0x5D,
	  Sleep = 0x5F,
	  Numpad0 = 0x60,
	  Numpad1 = 0x61,
	  Numpad2 = 0x62,
	  Numpad3 = 0x63,
	  Numpad4 = 0x64,
	  Numpad5 = 0x65,
	  Numpad6 = 0x66,
	  Numpad7 = 0x67,
	  Numpad8 = 0x68,
	  Numpad9 = 0x69,
	  Multiply = 0x6A,
	  Add = 0x6B,
	  Separator = 0x6C,
	  Subtract = 0x6D,
	  Decimal = 0x6E,
	  Divide = 0x6F,
	  F1 = 0x70,
	  F2 = 0x71,
	  F3 = 0x72,
	  F4 = 0x73,
	  F5 = 0x74,
	  F6 = 0x75,
	  F7 = 0x76,
	  F8 = 0x77,
	  F9 = 0x78,
	  F10 = 0x79,
	  F11 = 0x7A,
	  F12 = 0x7B,
	  F13 = 0x7C,
	  F14 = 0x7D,
	  F15 = 0x7E,
	  F16 = 0x7F,
	  F17 = 0x80,
	  F18 = 0x81,
	  F19 = 0x82,
	  F20 = 0x83,
	  F21 = 0x84,
	  F22 = 0x85,
	  F23 = 0x86,
	  F24 = 0x87,
	  NumLock = 0x90,
	  ScrollLock = 0x91,
	  NEC_Equal = 0x92,
	  Fujitsu_Jisho = 0x92,
	  Fujitsu_Masshou = 0x93,
	  Fujitsu_Touroku = 0x94,
	  Fujitsu_Loya = 0x95,
	  Fujitsu_Roya = 0x96,
	  LeftShift = 0xA0,
	  RightShift = 0xA1,
	  LeftControl = 0xA2,
	  RightControl = 0xA3,
	  LeftMenu = 0xA4,
	  RightMenu = 0xA5,
	  BrowserBack = 0xA6,
	  BrowserForward = 0xA7,
	  BrowserRefresh = 0xA8,
	  BrowserStop = 0xA9,
	  BrowserSearch = 0xAA,
	  BrowserFavorites = 0xAB,
	  BrowserHome = 0xAC,
	  VolumeMute = 0xAD,
	  VolumeDown = 0xAE,
	  VolumeUp = 0xAF,
	  MediaNextTrack = 0xB0,
	  MediaPrevTrack = 0xB1,
	  MediaStop = 0xB2,
	  MediaPlayPause = 0xB3,
	  LaunchMail = 0xB4,
	  LaunchMediaSelect = 0xB5,
	  LaunchApplication1 = 0xB6,
	  LaunchApplication2 = 0xB7,
	  OEM1 = 0xBA,
	  OEMPlus = 0xBB,
	  OEMComma = 0xBC,
	  OEMMinus = 0xBD,
	  OEMPeriod = 0xBE,
	  OEM2 = 0xBF,
	  OEM3 = 0xC0,
	  OEM4 = 0xDB,
	  OEM5 = 0xDC,
	  OEM6 = 0xDD,
	  OEM7 = 0xDE,
	  OEM8 = 0xDF,
	  OEMAX = 0xE1,
	  OEM102 = 0xE2,
	  ICOHelp = 0xE3,
	  ICO00 = 0xE4,
	  ProcessKey = 0xE5,
	  ICOClear = 0xE6,
	  Packet = 0xE7,
	  OEMReset = 0xE9,
	  OEMJump = 0xEA,
	  OEMPA1 = 0xEB,
	  OEMPA2 = 0xEC,
	  OEMPA3 = 0xED,
	  OEMWSCtrl = 0xEE,
	  OEMCUSel = 0xEF,
	  OEMATTN = 0xF0,
	  OEMFinish = 0xF1,
	  OEMCopy = 0xF2,
	  OEMAuto = 0xF3,
	  OEMENLW = 0xF4,
	  OEMBackTab = 0xF5,
	  ATTN = 0xF6,
	  CRSel = 0xF7,
	  EXSel = 0xF8,
	  EREOF = 0xF9,
	  Play = 0xFA,
	  Zoom = 0xFB,
	  Noname = 0xFC,
	  PA1 = 0xFD,
	  OEMClear = 0xFE,
   };
}

class InputSys : public NonCopyable {
public:
   static Encrypted_t<InputSys> Get( );

   virtual bool Initialize( IDirect3DDevice9* pDevice ) = 0;
   virtual void Destroy( ) = 0;

   virtual void* GetMainWindow( ) const = 0;
   virtual KeyState GetKeyState( int vk ) = 0;
   virtual bool IsKeyDown( int vk ) = 0;
   virtual bool WasKeyPressed( int vk ) = 0;
   virtual bool IsInBox( Vector2D box_pos, Vector2D box_size ) = 0;
   virtual void RegisterHotkey( int vk, std::function< void( void ) > f ) = 0;
   virtual void RemoveHotkey( int vk ) = 0;

   virtual Vector2D GetMousePosition( ) = 0;
   virtual float GetScrollMouse( ) = 0;
   virtual void SetScrollMouse( float scroll ) = 0;

protected:
   InputSys( ) { };
   virtual ~InputSys( ) { };
};

```

`CSGO SDK/Utils/LogSystem.cpp`:

```cpp
#include "LogSystem.hpp"
#include <fstream>
#include <iomanip>
#include <iostream>

class LogSystem : public ILogSystem {
public:
   void Log( const char* file_fmt, const char* fmt, ... ) override;
private:
   std::string GetTimestamp( );

};

Encrypted_t<ILogSystem> ILogSystem::Get( ) {
   static LogSystem instance;
   return &instance;
}

void LogSystem::Log( const char* file_fmt, const char* fmt, ... ) {
   if ( !fmt ) return;

   va_list va_alist;
   char logBuf[ 1024 ] = { 0 };

   va_start( va_alist, fmt );
   _vsnprintf( logBuf + strlen( logBuf ), sizeof( logBuf ) - strlen( logBuf ), fmt, va_alist );
   va_end( va_alist );

   std::ofstream file;

   file.open( std::string( XorStr( "log" ) ).append( file_fmt ), std::ios::app );

   file << GetTimestamp( ) << " " << logBuf << std::endl;
    
   file.close( );
}

std::string LogSystem::GetTimestamp( ) {
   std::time_t t = std::time( nullptr );
   std::tm tm;
   localtime_s( &tm, &t );
   std::locale loc( std::cout.getloc( ) );

   std::basic_stringstream<char> ss;
   ss.imbue( loc );
   ss << std::put_time( &tm, XorStr( "[%A %b %e %H:%M:%S %Y]" ) );

   return ss.str( );
}

```

`CSGO SDK/Utils/LogSystem.hpp`:

```hpp
#pragma once
#include "../SDK/sdk.hpp"

class __declspec( novtable ) ILogSystem : public NonCopyable {
public:
   static Encrypted_t<ILogSystem> Get( );
   virtual void Log( const char* file_fmt, const char* fmt, ... ) = NULL;

protected:
   ILogSystem( ) {

   }
   virtual ~ILogSystem( ) {
      
   }
};
```

`CSGO SDK/Utils/Math.cpp`:

```cpp
#include "Math.h"
#include "../source.hpp"
#include "../SDK/Classes/Player.hpp"
#include "../SDK/CVariables.hpp"

#include <algorithm>
#include <numeric>
#include <xmmintrin.h>

static Vector DirBetweenLines( const Vector& a, const Vector& b, const Vector& c, const Vector& d ) {
	const Vector d1 = ( b - a );
	const Vector d2 = ( d - c );

	const Vector cross = d1.Cross( d2 );

	const Vector cross1 = d1.Cross( cross );
	const Vector cross2 = d2.Cross( cross );

	const Vector sp = c + d2 * Math::Clamp( ( a - c ).Dot( cross1 ) / ( d2.Dot( cross1 ) ), 0.f, 1.f );
	const Vector ep = a + d1 * Math::Clamp( ( c - a ).Dot( cross2 ) / ( d1.Dot( cross2 ) ), 0.f, 1.f );

	return ep - sp;
}

typedef __declspec( align( 16 ) ) union {
	float f[ 4 ];
	__m128 v;
} m128;

__forceinline __m128 sqrt_ps( const __m128 squared ) {
	return _mm_sqrt_ps( squared );
}

bool Math::IntersectSegmentToSegment( Vector s1, Vector s2, Vector k1, Vector k2, float radius ) {
	static auto constexpr epsilon = 0.00000001;

	auto u = s2 - s1;
	auto v = k2 - k1;
	const auto w = s1 - k1;

	const auto a = u.Dot( u );
	const auto b = u.Dot( v );
	const auto c = v.Dot( v );
	const auto d = u.Dot( w );
	const auto e = v.Dot( w );
	const auto D = a * c - b * b;
	float sn, sd = D;
	float tn, td = D;

	if( D < epsilon ) {
		sn = 0.0;
		sd = 1.0;
		tn = e;
		td = c;
	}
	else {
		sn = b * e - c * d;
		tn = a * e - b * d;

		if( sn < 0.0 ) {
			sn = 0.0;
			tn = e;
			td = c;
		}
		else if( sn > sd ) {
			sn = sd;
			tn = e + b;
			td = c;
		}
	}

	if( tn < 0.0 ) {
		tn = 0.0;

		if( -d < 0.0 )
			sn = 0.0;
		else if( -d > a )
			sn = sd;
		else {
			sn = -d;
			sd = a;
		}
	}
	else if( tn > td ) {
		tn = td;

		if( -d + b < 0.0 )
			sn = 0;
		else if( -d + b > a )
			sn = sd;
		else {
			sn = -d + b;
			sd = a;
		}
	}

	const float sc = abs( sn ) < epsilon ? 0.0 : sn / sd;
	const float tc = abs( tn ) < epsilon ? 0.0 : tn / td;

	m128 n;
	auto dp = w + u * sc - v * tc;
	n.f[ 0 ] = dp.Dot( dp );
	const auto calc = sqrt_ps( n.v );
	auto shit = reinterpret_cast< const m128* >( &calc )->f[ 0 ];
	//printf( "shit %f | rad %f\n", shit, radius );
	return shit < radius;
}

bool Math::CapsuleCollider::Intersect( const Vector& start, const Vector& end ) const {
#if 1
	static auto constexpr epsilon = 0.00000001f;

	const auto s1 = min;
	const auto s2 = max;
	const auto k1 = start;
	const auto k2 = end;

	auto u = s2 - s1;
	auto v = k2 - k1;
	const auto w = s1 - k1;

	const auto a = u.Dot( u );
	const auto b = u.Dot( v );
	const auto c = v.Dot( v );
	const auto d = u.Dot( w );
	const auto e = v.Dot( w );
	const auto D = a * c - b * b;
	float sn, sd = D;
	float tn, td = D;

	if( D < epsilon ) {
		sn = 0.0f;
		sd = 1.0f;
		tn = e;
		td = c;
	}
	else {
		sn = b * e - c * d;
		tn = a * e - b * d;

		if( sn < 0.0f ) {
			sn = 0.0f;
			tn = e;
			td = c;
		}
		else if( sn > sd ) {
			sn = sd;
			tn = e + b;
			td = c;
		}
	}

	if( tn < 0.0f ) {
		tn = 0.0f;

		if( -d < 0.0f )
			sn = 0.0f;
		else if( -d > a )
			sn = sd;
		else {
			sn = -d;
			sd = a;
		}
	}
	else if( tn > td ) {
		tn = td;

		if( -d + b < 0.0f )
			sn = 0.f;
		else if( -d + b > a )
			sn = sd;
		else {
			sn = -d + b;
			sd = a;
		}
	}

	const float sc = abs( sn ) < epsilon ? 0.0f : sn / sd;
	const float tc = abs( tn ) < epsilon ? 0.0f : tn / td;

	m128 n;
	auto dp = w + u * sc - v * tc;
	n.f[ 0 ] = dp.Dot( dp );
	const auto calc = sqrt_ps( n.v );
	return radius < reinterpret_cast< const m128* >( &calc )->f[ 0 ];

	//auto dp = w + u * sc - v * tc;
	//auto scale = dp.Dot( dp );
	//return scale < radius * radius;
#endif

#if 0
	const Vector dir = DirBetweenLines( min, max, start, end );
	return dir.LengthSquared( ) <= radius * radius;


	return IntersectSegmentCapsule( start, end, min, max, radius );
#endif
}

bool Math::IntersectSegmentSphere( const Vector& vecRayOrigin, const Vector& vecRayDelta, const Vector& vecSphereCenter, float flRadius ) {
	// Solve using the ray equation + the sphere equation
	// P = o + dt
	// (x - xc)^2 + (y - yc)^2 + (z - zc)^2 = r^2
	// (ox + dx * t - xc)^2 + (oy + dy * t - yc)^2 + (oz + dz * t - zc)^2 = r^2
	// (ox - xc)^2 + 2 * (ox-xc) * dx * t + dx^2 * t^2 +
	//		(oy - yc)^2 + 2 * (oy-yc) * dy * t + dy^2 * t^2 +
	//		(oz - zc)^2 + 2 * (oz-zc) * dz * t + dz^2 * t^2 = r^2
	// (dx^2 + dy^2 + dz^2) * t^2 + 2 * ((ox-xc)dx + (oy-yc)dy + (oz-zc)dz) t +
	//		(ox-xc)^2 + (oy-yc)^2 + (oz-zc)^2 - r^2 = 0
	// or, t = (-b +/- sqrt( b^2 - 4ac)) / 2a
	// a = DotProduct( vecRayDelta, vecRayDelta );
	// b = 2 * DotProduct( vecRayOrigin - vecCenter, vecRayDelta )
	// c = DotProduct(vecRayOrigin - vecCenter, vecRayOrigin - vecCenter) - flRadius * flRadius;

	Vector vecSphereToRay = vecRayOrigin - vecSphereCenter;

	float a = vecRayDelta.Dot( vecRayDelta );

	// This would occur in the case of a zero-length ray
	if( a == 0.0f )
		return vecSphereToRay.LengthSquared( ) <= flRadius * flRadius;

	float b = 2.f * vecSphereToRay.Dot( vecRayDelta );
	float c = vecSphereToRay.Dot( vecSphereToRay ) - flRadius * flRadius;
	float flDiscrim = b * b - 4.f * a * c;
	return flDiscrim >= 0.0f;
}


bool Math::IntersectSegmentCapsule( const Vector& start, const Vector& end, const Vector& min, const Vector& max, float radius ) {
	Vector d = max - min, m = start - min, n = end - start;
	float md = m.Dot( d );
	float nd = n.Dot( d );
	float dd = d.Dot( d );

	if( md < 0.0f && md + nd < 0.0f ) {
		return IntersectSegmentSphere( start, n, min, radius );
	}
	if( md > dd && md + nd > dd ) {
		return IntersectSegmentSphere( start, n, max, radius );
	}

	float t = 0.0f;
	float nn = n.Dot( n );
	float mn = m.Dot( n );
	float a = dd * nn - nd * nd;
	float k = m.Dot( m ) - radius * radius;
	float c = dd * k - md * md;
	if( std::fabsf( a ) < FLT_EPSILON ) {
		if( c > 0.0f )
			return 0;
		if( md < 0.0f )
			IntersectSegmentSphere( start, n, min, radius );
		else if( md > dd )
			IntersectSegmentSphere( start, n, max, radius );
		else
			t = 0.0f;
		return true;
	}
	float b = dd * mn - nd * md;
	float discr = b * b - a * c;
	if( discr < 0.0f )
		return false;

	t = ( -b - sqrt( discr ) ) / a;
	float t0 = t;
	if( md + t * nd < 0.0f ) {
		return IntersectSegmentSphere( start, n, min, radius );
	}
	else if( md + t * nd > dd ) {

		return IntersectSegmentSphere( start, n, max, radius );
	}
	t = t0;
	return t > 0.0f && t < 1.0f;
}

bool Math::IntersectionBoundingBox( const Vector& src, const Vector& dir, const Vector& min, const Vector& max, Vector* hit_point ) {
	/*
		 Fast Ray-Box Intersection
		 by Andrew Woo
		 from "Graphics Gems", Academic Press, 1990
	 */

	constexpr auto NUMDIM = 3;
	constexpr auto RIGHT = 0;
	constexpr auto LEFT = 1;
	constexpr auto MIDDLE = 2;

	bool inside = true;
	char quadrant[ NUMDIM ];
	int i;

	// Rind candidate planes; this loop can be avoided if
	// rays cast all from the eye(assume perpsective view)
	Vector candidatePlane;
	for( i = 0; i < NUMDIM; i++ ) {
		if( src[ i ] < min[ i ] ) {
			quadrant[ i ] = LEFT;
			candidatePlane[ i ] = min[ i ];
			inside = false;
		}
		else if( src[ i ] > max[ i ] ) {
			quadrant[ i ] = RIGHT;
			candidatePlane[ i ] = max[ i ];
			inside = false;
		}
		else {
			quadrant[ i ] = MIDDLE;
		}
	}

	// Ray origin inside bounding box
	if( inside ) {
		if( hit_point )
			*hit_point = src;
		return true;
	}

	// Calculate T distances to candidate planes
	Vector maxT;
	for( i = 0; i < NUMDIM; i++ ) {
		if( quadrant[ i ] != MIDDLE && dir[ i ] != 0.f )
			maxT[ i ] = ( candidatePlane[ i ] - src[ i ] ) / dir[ i ];
		else
			maxT[ i ] = -1.f;
	}

	// Get largest of the maxT's for final choice of intersection
	int whichPlane = 0;
	for( i = 1; i < NUMDIM; i++ ) {
		if( maxT[ whichPlane ] < maxT[ i ] )
			whichPlane = i;
	}

	// Check final candidate actually inside box
	if( maxT[ whichPlane ] < 0.f )
		return false;

	for( i = 0; i < NUMDIM; i++ ) {
		if( whichPlane != i ) {
			float temp = src[ i ] + maxT[ whichPlane ] * dir[ i ];
			if( temp < min[ i ] || temp > max[ i ] ) {
				return false;
			}
			else if( hit_point ) {
				( *hit_point )[ i ] = temp;
			}
		}
		else if( hit_point ) {
			( *hit_point )[ i ] = candidatePlane[ i ];
		}
	}

	// ray hits box
	return true;
}

void Math::Rotate( std::array< Vector2D, 3 >& points, float rotation ) {
	const auto points_center = ( points.at( 0 ) + points.at( 1 ) + points.at( 2 ) ) / 3;
	for( auto& point : points ) {
		point -= points_center;

		const auto temp_x = point.x;
		const auto temp_y = point.y;

		const auto theta = ToRadians( rotation );
		float c, s;
		DirectX::XMScalarSinCos( &s, &c, theta );

		point.x = temp_x * c - temp_y * s;
		point.y = temp_x * s + temp_y * c;

		point += points_center;
	}
}

void Math::AngleVectors( const QAngle& angles, Vector& forward, Vector& right, Vector& up ) {
	float sr, sp, sy, cr, cp, cy;

	SinCos( DEG2RAD( angles[ 1 ] ), &sy, &cy );
	SinCos( DEG2RAD( angles[ 0 ] ), &sp, &cp );
	SinCos( DEG2RAD( angles[ 2 ] ), &sr, &cr );

	forward.x = ( cp * cy );
	forward.y = ( cp * sy );
	forward.z = ( -sp );
	right.x = ( -1 * sr * sp * cy + -1 * cr * -sy );
	right.y = ( -1 * sr * sp * sy + -1 * cr * cy );
	right.z = ( -1 * sr * cp );
	up.x = ( cr * sp * cy + -sr * -sy );
	up.y = ( cr * sp * sy + -sr * cy );
	up.z = ( cr * cp );
}

void Math::VectorAngles( const Vector& forward, QAngle &angles ) {
	float tmp, yaw, pitch;

	if( forward[ 2 ] == 0.0f && forward[ 0 ] == 0.0f ) {
		yaw = 0;

		if( forward[ 2 ] > 0.0f )
			pitch = 90.0f;
		else
			pitch = 270.0f;
	}
	else {
		yaw = ( atan2( forward[ 1 ], forward[ 0 ] ) * 180 / M_PI );
		if( yaw < 0 )
			yaw += 360;

		tmp = sqrt( forward[ 0 ] * forward[ 0 ] + forward[ 1 ] * forward[ 1 ] );
		pitch = ( atan2( -forward[ 2 ], tmp ) * 180 / M_PI );
		if( pitch < 0 )
			pitch += 360;
	}

	pitch -= floorf( pitch / 360.0f + 0.5f ) * 360.0f;
	yaw -= floorf( yaw / 360.0f + 0.5f ) * 360.0f;

	if( pitch > 89.0f )
		pitch = 89.0f;
	else if( pitch < -89.0f )
		pitch = -89.0f;

	angles.x = pitch;
	angles.y = yaw;
	angles.z = 0;
}

void Math::VectorAngles( const Vector& forward, Vector& angles ) {
	float tmp, yaw, pitch;

	if( forward[ 1 ] == 0 && forward[ 0 ] == 0 ) {
		yaw = 0;
		if( forward[ 2 ] > 0 )
			pitch = 270;
		else
			pitch = 90;
	}
	else {
		yaw = ( atan2( forward[ 1 ], forward[ 0 ] ) * 180 / M_PI );
		if( yaw < 0 )
			yaw += 360;

		tmp = sqrt( forward[ 0 ] * forward[ 0 ] + forward[ 1 ] * forward[ 1 ] );
		pitch = ( atan2( -forward[ 2 ], tmp ) * 180 / M_PI );
		if( pitch < 0 )
			pitch += 360;
	}

	angles[ 0 ] = pitch;
	angles[ 1 ] = yaw;
	angles[ 2 ] = 0;
}

void Math::SinCos( float a, float* s, float* c ) {
	*s = sin( a );
	*c = cos( a );
}

void Math::AngleVectors( const QAngle& angles, Vector* forward ) {
	float	sp, sy, cp, cy;

	SinCos( DEG2RAD( angles[ 1 ] ), &sy, &cy );
	SinCos( DEG2RAD( angles[ 0 ] ), &sp, &cp );

	forward[0].x = cp * cy;
	forward[1].y = cp * sy;
	forward[2].z = -sp;
}

void Math::AngleVectors( const QAngle & angles, Vector & forward ) {
	float	sp, sy, cp, cy;

	SinCos( DEG2RAD( angles[ 1 ] ), &sy, &cy );
	SinCos( DEG2RAD( angles[ 0 ] ), &sp, &cp );

	forward.x = cp * cy;
	forward.y = cp * sy;
	forward.z = -sp;
}

float Math::GetFov( const QAngle& viewAngle, const Vector& start, const Vector& end ) {

	Vector dir, fw;

	// get direction and normalize.
	dir = ( end - start ).Normalized( );

	// get the forward direction vector of the view angles.
	AngleVectors( viewAngle, fw );

	// get the angle between the view angles forward directional vector and the target location.
	return std::max( RAD2DEG( std::acos( fw.Dot( dir ) ) ), 0.f );
}

float Math::AngleNormalize( float angle ) {
	if( angle > 180.f || angle < -180.f ) {
		auto revolutions = round( abs( angle / 360.f ) );

		if( angle < 0.f )
			angle = angle + 360.f * revolutions;
		else
			angle = angle - 360.f * revolutions;
	}

	return angle;
}
float Math::ApproachAngle( float target, float value, float speed ) {
	target = ( target * 182.04445f ) * 0.0054931641f;
	value = ( value * 182.04445f ) * 0.0054931641f;

	// Speed is assumed to be positive
	if( speed < 0 )
		speed = -speed;

	float delta = target - value;
	if( delta < -180.0f )
		delta += 360.0f;
	else if( delta > 180.0f )
		delta -= 360.0f;

	if( delta > speed )
		value += speed;
	else if( delta < -speed )
		value -= speed;
	else
		value = target;

	return value;
}
void Math::VectorTransform( const Vector& in1, const matrix3x4_t& in2, Vector& out ) {
	out[ 0 ] = in1.Dot( in2[ 0 ] ) + in2[ 0 ][ 3 ];
	out[ 1 ] = in1.Dot( in2[ 1 ] ) + in2[ 1 ][ 3 ];
	out[ 2 ] = in1.Dot( in2[ 2 ] ) + in2[ 2 ][ 3 ];
}

void Math::SmoothAngle( QAngle src, QAngle& dst, float factor ) {
	QAngle delta = dst - src;

	delta.Normalize( );

	dst = src + delta / factor;
}

QAngle Math::CalcAngle( Vector src, Vector dst, bool bruh ) {
	//xd
	if( bruh ) {
		Vector qAngles;
		Vector delta = Vector( ( src[ 0 ] - dst[ 0 ] ), ( src[ 1 ] - dst[ 1 ] ), ( src[ 2 ] - dst[ 2 ] ) );
		double hyp = std::sqrtf( delta[ 0 ] * delta[ 0 ] + delta[ 1 ] * delta[ 1 ] );
		qAngles[ 0 ] = ( float )( std::atan( delta[ 2 ] / hyp ) * ( 180.0 / M_PI ) );
		qAngles[ 1 ] = ( float )( std::atan( delta[ 1 ] / delta[ 0 ] ) * ( 180.0 / M_PI ) );
		qAngles[ 2 ] = 0.f;
		if( delta[ 0 ] >= 0.f )
			qAngles[ 1 ] += 180.f;

		return QAngle( qAngles[ 0 ], qAngles[ 1 ], qAngles[ 2 ] );
	}
	else {
		QAngle angles;
		Vector delta = src - dst;

		angles = delta.ToEulerAngles( );

		angles.Normalize( );

		return angles;
	}
}

Vector Math::GetSmoothedVelocity( float min_delta, Vector a, Vector b ) {
	Vector delta = a - b;
	float delta_length = delta.Length( );

	if( delta_length <= min_delta ) {
		Vector result;
		if( -min_delta <= delta_length ) {
			return a;
		}
		else {
			float iradius = 1.0f / ( delta_length + FLT_EPSILON );
			return b - ( ( delta * iradius ) * min_delta );
		}
	}
	else {
		float iradius = 1.0f / ( delta_length + FLT_EPSILON );
		return b + ( ( delta * iradius ) * min_delta );
	}
}

float Math::AngleDiff( float src, float dst ) {
	float i;

	for( ; src > 180.0; src = src - 360.0 )
		;
	for( ; src < -180.0; src = src + 360.0 )
		;
	for( ; dst > 180.0; dst = dst - 360.0 )
		;
	for( ; dst < -180.0; dst = dst + 360.0 )
		;
	for( i = dst - src; i > 180.0; i = i - 360.0 )
		;
	for( ; i < -180.0; i = i + 360.0 )
		;

	return i;
}

```

`CSGO SDK/Utils/Math.h`:

```h
#pragma once
#include "../SDK/sdk.hpp"
#include <DirectXMath.h>

#define RAD2DEG(x) DirectX::XMConvertToDegrees(x)
#define DEG2RAD(x) DirectX::XMConvertToRadians(x)

namespace Math
{
	bool IntersectSegmentToSegment(Vector s1, Vector s2, Vector k1, Vector k2, float radius);
	bool IntersectSegmentSphere(const Vector& vecRayOrigin, const Vector& vecRayDelta, const Vector& vecSphereCenter, float radius);
	bool IntersectSegmentCapsule(const Vector& start, const Vector& end, const Vector& min, const Vector& max, float radius);
	bool IntersectionBoundingBox(const Vector& start, const Vector& dir, const Vector& min, const Vector& max, Vector* hit_point = nullptr);

	void Rotate(std::array<Vector2D, 3>& points, float rotation);

	void AngleVectors(const QAngle& angles, Vector& forward, Vector& right, Vector& up);

	void VectorAngles( const Vector & forward, QAngle & angles );

	void VectorAngles(const Vector& forward, Vector& angles);

	void SinCos(float a, float* s, float* c);

	void AngleVectors( const QAngle& angles, Vector* forward );

	void AngleVectors( const QAngle& angles, Vector& forward );

	float GetFov( const QAngle& viewAngle, const Vector& start, const Vector& end );

	float AngleNormalize(float angle);

	float ApproachAngle(float target, float value, float speed);

	void VectorTransform(const Vector& in1, const matrix3x4_t& in2, Vector& out);

	void SmoothAngle(QAngle src, QAngle& dst, float factor);

	QAngle CalcAngle(Vector src, Vector dst, bool bruh = false);

	Vector GetSmoothedVelocity(float min_delta, Vector a, Vector b);

	float AngleDiff(float src, float dst);

	__forceinline static float Interpolate(const float from, const float to, const float percent) {
		return to * percent + from * (1.f - percent);
	}

	__forceinline static Vector Interpolate(const Vector from, const Vector to, const float percent) {
		return to * percent + from * (1.f - percent);
	}

	__forceinline static void MatrixSetOrigin(Vector pos, matrix3x4_t& matrix) {
		matrix[0][3] = pos.x;
		matrix[1][3] = pos.y;
		matrix[2][3] = pos.z;
	}

	__forceinline static Vector MatrixGetOrigin(const matrix3x4_t& src) {
		return { src[0][3], src[1][3], src[2][3] };
	}

	__forceinline void VectorScale(const float* in, float scale, float* out) {
		out[0] = in[0] * scale;
		out[1] = in[1] * scale;
		out[2] = in[2] * scale;
	}

	struct CapsuleCollider {
		Vector min;
		Vector max;
		float radius;

		bool Intersect(const Vector& a, const Vector& b) const;
	};

	// mixed types involved.
	template < typename T >
	T Clamp(const T& val, const T& minVal, const T& maxVal) {
		if ((T)val < minVal)
			return minVal;
		else if ((T)val > maxVal)
			return maxVal;
		else
			return val;
	}

	template < typename T >
	T Hermite_Spline(
		T p1,
		T p2,
		T d1,
		T d2,
		float t) {
		float tSqr = t * t;
		float tCube = t * tSqr;

		float b1 = 2.0f * tCube - 3.0f * tSqr + 1.0f;
		float b2 = 1.0f - b1; // -2*tCube+3*tSqr;
		float b3 = tCube - 2 * tSqr + t;
		float b4 = tCube - tSqr;

		T output;
		output = p1 * b1;
		output += p2 * b2;
		output += d1 * b3;
		output += d2 * b4;

		return output;
	}

	template < typename T >
	T Hermite_Spline(T p0, T p1, T p2, float t) {
		return Hermite_Spline(p1, p2, p1 - p0, p2 - p1, t);
	}

	// wide -> multi-byte
	__forceinline std::string WideToMultiByte(const std::wstring& str) {
		std::string ret;
		int         str_len;

		// check if not empty str
		if (str.empty())
			return { };

		// count size
		str_len = WideCharToMultiByte(CP_UTF8, 0, str.data(), (int)str.size(), 0, 0, 0, 0);

		// setup return value
		ret = std::string(str_len, 0);

		// final conversion
		WideCharToMultiByte(CP_UTF8, 0, str.data(), (int)str.size(), &ret[0], str_len, 0, 0);

		return ret;
	}

	// multi-byte -> wide
	__forceinline std::wstring MultiByteToWide(const std::string& str) {
		std::wstring    ret;
		int		        str_len;

		// check if not empty str
		if (str.empty())
			return { };

		// count size
		str_len = MultiByteToWideChar(CP_UTF8, 0, str.data(), (int)str.size(), nullptr, 0);

		// setup return value
		ret = std::wstring(str_len, 0);

		// final conversion
		MultiByteToWideChar(CP_UTF8, 0, str.data(), (int)str.size(), &ret[0], str_len);

		return ret;
	}
}

```

`CSGO SDK/Utils/Threading/atomic_lock.cpp`:

```cpp
#include "atomic_lock.h"

AtomicLock::AtomicLock()
{
	lck.clear();
}

AtomicLock::~AtomicLock()
{
}

void AtomicLock::lock()
{
	while (lck.test_and_set(std::memory_order_acquire))
		;
}

bool AtomicLock::trylock()
{
	return !lck.test_and_set(std::memory_order_acquire);
}

void AtomicLock::unlock()
{
	lck.clear(std::memory_order_release);
}

```

`CSGO SDK/Utils/Threading/atomic_lock.h`:

```h
#ifndef ATOMIC_LOCK_H
#define ATOMIC_LOCK_H

#include <atomic>

class AtomicLock
{
  public:
	AtomicLock();
	~AtomicLock();
	void lock();
	bool trylock();
	void unlock();
  private:
	std::atomic_flag lck;
};

#endif

```

`CSGO SDK/Utils/Threading/mutex.cpp`:

```cpp
#include "mutex.h"

#if defined(__linux__) || defined(__APPLE__)
#include <pthread.h>

Mutex::Mutex() {
	int ret = pthread_mutex_init(&lck, nullptr);
#if defined(__cpp_exceptions) || defined(_CPPUNWIND)
	if (ret) {
		throw;
	}
#endif
}

Mutex::~Mutex() {
	pthread_mutex_destroy(&lck);
}

void Mutex::lock() {
	pthread_mutex_lock(&lck);
}

bool Mutex::trylock() {
	return !pthread_mutex_trylock(&lck);
}

void Mutex::unlock() {
	pthread_mutex_unlock(&lck);
}

#else
#include <windows.h>

Mutex::Mutex() {
	::InitializeCriticalSection(&lck);
}

Mutex::~Mutex() {
	::DeleteCriticalSection(&lck);
}

void Mutex::lock() {
	::EnterCriticalSection(&lck);
}

void Mutex::unlock() {
	::LeaveCriticalSection(&lck);
}
#endif

```

`CSGO SDK/Utils/Threading/mutex.h`:

```h
#ifndef MUTEX_H
#define MUTEX_H

#if defined(__linux__) || defined(__APPLE__)
#include <pthread.h>
#else
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif

class Mutex {
  public:
	Mutex();
	~Mutex();
	void lock();
	bool trylock();
	void unlock();
	//private:
#if defined(__linux__) || defined(__APPLE__)
	pthread_mutex_t lck;
#else
	CRITICAL_SECTION lck;
#endif
};

#endif

```

`CSGO SDK/Utils/Threading/packed_heap.cpp`:

```cpp
#include "packed_heap.h"
#include <memory>


PackedAllocator::PackedAllocator(size_t sz, char* b)
{
	if (b)
		buf = b;
	else
		buf = (char*)malloc(sz);

	bufCapacity = sz;
	bufSize = 0;
}

PackedAllocator::PackedAllocator(const PackedAllocator& o)
{
	*this = o;
}

PackedAllocator::PackedAllocator(const PackedAllocator&& o)
{
	*this = o;
}

PackedAllocator::~PackedAllocator()
{
	if (buf)
		free(buf);
	buf = nullptr;
	bufCapacity = 0;
	bufSize = 0;
}

PackedAllocator& PackedAllocator::operator=(const PackedAllocator& o)
{
	totalAllocations = o.totalAllocations;
	totalFrees = o.totalFrees;
	totalResizes = o.totalResizes;
	totalReallocations = o.totalReallocations;

	freeRegionsTree = o.freeRegionsTree;

	if (o.bufSize <= bufCapacity) {
		bufSize = o.bufSize;
	} else {
		if (buf)
			free(buf);
		bufSize = o.bufSize;
		bufCapacity = o.bufCapacity;
		buf = (char*)malloc(bufCapacity);
	}
	memcpy(buf, o.buf, bufSize);

	return *this;
}

PackedAllocator& PackedAllocator::operator=(PackedAllocator&& o)
{
	totalAllocations = o.totalAllocations;
	totalFrees = o.totalFrees;
	totalResizes = o.totalResizes;
	totalReallocations = o.totalReallocations;

	freeRegionsTree = std::move(o.freeRegionsTree);

	if (buf)
		free(buf);

	buf = o.buf;
	o.buf = nullptr;
	bufSize = o.bufSize;
	bufCapacity = o.bufCapacity;

	return *this;
}

idx_t PackedAllocator::_Alloc(idx_t sz, size_t alignment)
{
	alignment = std::max(size_t(4), alignment);

	totalAllocations++;

	size_t allocSize = sz + sizeof(MetaData) * 2;
	if (!freeRegionsTree.empty()) {
		auto reg = freeRegionsTree.lower_bound(sz + alignment - 4);
		if (reg != freeRegionsTree.end()) {
			idx_t address = *reg->second.rbegin();
			idx_t ret = address + sizeof(MetaData);

			//Align the allocated pointer
			size_t delta = ((MetaData*)&buf[address])->size;
			void* ptr = (void*)(size_t)ret;
			idx_t origRet = ret;
			idx_t ret2 = (idx_t)(size_t)std::align(alignment, sz, ptr, delta);
			delta -= sz;
			ret = ret2;
			reg->second.erase(address);

#ifdef PACKED_HEAP_DEBUG
			if (reg->first != ((MetaData*)&buf[address])->size)
				throw std::runtime_error("PackedHeap corruption");
#endif

			*(MetaData*)&buf[ret - sizeof(MetaData)] = {USED_REGION, sz};
			*(MetaData*)&buf[ret + sz] = {USED_REGION, sz};

			if (!reg->second.size())
				freeRegionsTree.erase(reg);

			idx_t lowerHoleStart = origRet;
			idx_t lowerHoleDelta = ret2 - sizeof(MetaData) - lowerHoleStart;

			//The lower holes are to be caused by alignments > 8
			if (lowerHoleDelta && lowerHoleDelta < sz && !FillHole(lowerHoleStart, lowerHoleDelta)) {
				idx_t holeSpotSize = lowerHoleDelta - sizeof(MetaData) * 2;
				*(MetaData*)&buf[lowerHoleStart] = {FREE_REGION, holeSpotSize};
				*(MetaData*)&buf[lowerHoleStart + holeSpotSize + sizeof(MetaData)] = {FREE_REGION, holeSpotSize};
				freeRegionsTree[holeSpotSize].insert(lowerHoleStart);
			}

			idx_t holeStart = ret + allocSize - sizeof(MetaData);

			//Check if the place is small enough for a unallocatable hole
			if (delta && !FillHole(holeStart, delta)) {
				idx_t holeSpotSize = delta - sizeof(MetaData) * 2;
				*(MetaData*)&buf[holeStart] = {FREE_REGION, holeSpotSize};
				*(MetaData*)&buf[holeStart + holeSpotSize + sizeof(MetaData)] = {FREE_REGION, holeSpotSize};
				freeRegionsTree[holeSpotSize].insert(holeStart);
			}

			return ret;
		}
	}

	totalResizes++;

	idx_t baseIdx = bufSize + sizeof(MetaData);
	size_t delta = sz + alignment;
	void* ptr = (void*)(size_t)baseIdx;
	baseIdx = (idx_t)(size_t)std::align(alignment, sz, ptr, delta);

	idx_t lowerHoleStart = bufSize;
	idx_t lowerHoleDelta = baseIdx - sizeof(MetaData) - lowerHoleStart;

	if (lowerHoleDelta && lowerHoleDelta < sz && !FillHole(lowerHoleStart, lowerHoleDelta)) {
		idx_t holeSpotSize = lowerHoleDelta - sizeof(MetaData) * 2;
		*(MetaData*)&buf[lowerHoleStart] = {FREE_REGION, holeSpotSize};
		*(MetaData*)&buf[lowerHoleStart + holeSpotSize + sizeof(MetaData)] = {FREE_REGION, holeSpotSize};
		freeRegionsTree[holeSpotSize].insert(lowerHoleStart);
	}

	if (bufCapacity < baseIdx + sizeof(MetaData) + sz) {
		totalReallocations++;
		bufCapacity = (baseIdx + sizeof(MetaData) + sz) * GROW_FACTOR;
		buf = (char*)malloc(bufCapacity);
	}

	bufSize = baseIdx + sizeof(MetaData) + sz;
	*(MetaData*)&buf[baseIdx - sizeof(MetaData)] = {USED_REGION, sz};
	*(MetaData*)&buf[baseIdx + sz] = {USED_REGION, sz};

	return baseIdx;
}

idx_t PackedAllocator::Alloc(idx_t sz, size_t alignment)
{
	if (!buf) {
		bufCapacity = sz + 2 * sizeof(MetaData);
		buf = (char*)malloc(bufCapacity);
	}

	char* prevBuf = buf;

	idx_t ret = _Alloc(sz, alignment);

	if (buf != prevBuf) {
		memcpy(buf, prevBuf, ret - sizeof(MetaData));
		free(prevBuf);
	}

	return ret;
}

void PackedAllocator::Free(idx_t idx)
{
	if (!idx)
		return;

	totalFrees++;

	MetaData* metaData = (MetaData*)&buf[idx - sizeof(MetaData)];

	if (metaData->used != USED_REGION) {
		if (metaData->used == FREE_REGION)
#ifdef PACKED_HEAP_DEBUG
			throw std::runtime_error("Double free");
#else
			return;
#endif
		else
#if PACKED_HEAP_DEBUG
			throw std::runtime_error("PackedHeap corruption");
#else
			return;
#endif
	}

	idx_t start = idx - sizeof(MetaData);
	idx_t end = idx + sizeof(MetaData) + metaData->size;

	if (*metaData != *(MetaData*)&buf[end - sizeof(MetaData)])
#if PACKED_HEAP_DEBUG
		throw std::runtime_error("PackedHeap corruption");
#else
		return;
#endif

	//Check for a memory hole above the region (this can never occur below)
	if ((unsigned char)buf[end] == HOLE_START)
		while ((unsigned char)buf[end++] != HOLE_END)
			;
	else if ((unsigned char)buf[end] == HOLE_REGION)
		end++;

	MetaData* upperMetaData = (MetaData*)&buf[end - sizeof(MetaData)];

	MetaData* aboveRegion = end + sizeof(MetaData) < bufSize ? (MetaData*)&buf[end] : nullptr;
	MetaData* belowRegion = start >= sizeof(MetaData) * 2 ? (MetaData*)&buf[start - sizeof(MetaData)] : nullptr;

	//Join the nearby free regions
	if (PACKED_HEAP_MERGE_REGIONS && aboveRegion && aboveRegion->used == FREE_REGION) {
		[[maybe_unused]]
			size_t ret = freeRegionsTree[aboveRegion->size].erase(end);

#ifdef PACKED_HEAP_DEBUG
		if (!ret)
			throw std::runtime_error("PackedHeap corruption");

		if (!freeRegionsTree[aboveRegion->size].size())
			freeRegionsTree.erase(aboveRegion->size);
#endif

		upperMetaData = aboveRegion->WalkUp();
	}

	if (PACKED_HEAP_MERGE_REGIONS && belowRegion && belowRegion->used == FREE_REGION) {
		[[maybe_unused]]
			size_t ret = freeRegionsTree[belowRegion->size].erase(start - 2 * sizeof(MetaData) - belowRegion->size);

#ifdef PACKED_HEAP_DEBUG
		if (!ret)
			throw std::runtime_error("PackedHeap corruption");

		if (!freeRegionsTree[belowRegion->size].size())
			freeRegionsTree.erase(belowRegion->size);
#endif

		metaData = belowRegion->WalkDown();
	}

	metaData->used = FREE_REGION;
	metaData->size = (uintptr_t)upperMetaData - (uintptr_t)metaData - sizeof(MetaData);
	*upperMetaData = *metaData;

	freeRegionsTree[metaData->size].insert((idx_t)((uintptr_t)metaData - (uintptr_t)&buf[0]));
}

void PackedAllocator::FreeAll()
{
	totalFrees += totalAllocations - totalFrees;
	bufSize = 0;
}

```

`CSGO SDK/Utils/Threading/packed_heap.h`:

```h
#ifndef PACKED_HEAP_H
#define PACKED_HEAP_H

//At the current moment region merge causes higher overall average memory difference, this is to be investigated
#ifndef PACKED_HEAP_MERGE_REGIONS
#define PACKED_HEAP_MERGE_REGIONS 0
#endif

#include <vector>
#include <map>
#include <set>
#include <algorithm>
#include <stdlib.h>
#include <string.h>

using idx_t = unsigned int;

//A simple, faster than malloc heap method using less memory, but only supports single element allocation
template<typename T>
class PackedHeapL;

//A more complicated heap method with support for continious sized buffer allocation. At the moment 1 / 4th the speed of (glibc) malloc
template<typename T>
class PackedHeap;

template<typename T, typename F>
struct PackedPtr
{
	const F& buf;
	idx_t idx;

	constexpr PackedPtr(const F& b, idx_t i) : buf(b), idx(i)
	{
	}

	constexpr T& operator*() const
	{
		return *(T*)&buf[idx];
	}

	inline T* operator->()
	{
		return (T*)&buf[idx];
	}

	constexpr PackedPtr operator+(int o) const
	{
		return PackedPtr(buf, idx + o);
	}
};

struct MemRegion
{
	idx_t start, end;

	inline bool operator < (const idx_t& o) const
	{
		return start < o;
	}

	inline bool operator > (const idx_t& o) const
	{
		return end > o;
	}

	inline bool operator == (const idx_t& o) const
	{
		return start <= o && end >= o;
	}

	inline bool operator < (const MemRegion& o) const
	{
		return end < o.start;
	}

	inline bool operator > (const MemRegion& o) const
	{
		return start > o.end;
	}

	inline bool operator == (const MemRegion& o) const
	{
		return start == o.start && end == o.end;
	}

	inline bool operator != (const MemRegion& o) const
	{
		return start != o.start || end != o.end;
	}

};

template<typename T>
class PackedHeapL
{
  private:
	std::vector<T> buf;
	std::vector<MemRegion> freeRegions;

  public:
	idx_t Alloc()
	{
		if (freeRegions.size()) {
		    auto end = freeRegions.rbegin();
			idx_t ret = end->end;
			if (end->start == end->end)
				freeRegions.pop_back();
			else
				end->end--;
			return ret;
		}
		buf.resize(buf.size() + 1);
		return (idx_t)buf.size();
	}

	void Free(idx_t idx)
	{
		auto upperReg = std::lower_bound(freeRegions.begin(), freeRegions.end(), idx);
		//Double free!
		if (upperReg != freeRegions.end() && upperReg->start <= idx && upperReg->end <= idx)
#ifdef PACKED_HEAP_DEBUG
			throw std::runtime_error("Double free");
#else
			return;
#endif

		auto lowerReg = upperReg == freeRegions.begin() ? upperReg : upperReg - 1;

		//Join the regions
		if (upperReg != freeRegions.end() && lowerReg->end == idx - 1 && upperReg->start == idx + 1) {
			lowerReg->end = upperReg->end;
			freeRegions.erase(upperReg);
		} else if (upperReg != freeRegions.end() && upperReg->start == idx + 1)
			upperReg->start--;
		else if (lowerReg != freeRegions.end() && lowerReg->end == idx - 1)
			lowerReg->end++;
		else {
			//List was empty
			freeRegions.push_back({idx, idx});
		}
	}

	void Free(T* ptr)
	{
		idx_t idx = (idx_t)(ptr - &buf[0]);
		if (++idx < buf.size())
			Free(idx);
	}

	constexpr void FreeAll()
	{
		freeRegions.clear();
		buf.clear();
	}

	constexpr const T& operator[](idx_t idx) const
	{
		return buf[idx - 1];
	}

    constexpr auto operator+(idx_t idx) const
	{
		return PackedPtr<T, decltype(*this)>(*this, idx);
	}

	constexpr T& operator[](idx_t idx)
	{
		return buf[idx - 1];
	}

    constexpr auto operator+(idx_t idx)
	{
		return PackedPtr<T, decltype(*this)>(*this, idx);
	}
};

class PackedAllocator
{

  protected:

	static const int GROW_FACTOR = 2;
	static const unsigned char USED_REGION = 0xaa;
	static const unsigned char FREE_REGION = 0x88;
	static const unsigned char HOLE_START = 0xba;
	static const unsigned char HOLE_END = 0xab;
	static const unsigned char HOLE_REGION = 0xbb;

	struct MetaData
	{
	    uint8_t used;
		idx_t size;

		inline bool operator==(const MetaData& o) const
		{
			return used == o.used && size == o.size;
		}

		inline bool operator!=(const MetaData& o) const
		{
			return !operator==(o);
		}

		inline MetaData* WalkUp()
		{
			return (MetaData*)((uintptr_t)this + sizeof(MetaData) + size);
		}

		inline MetaData* WalkDown()
		{
			return (MetaData*)((uintptr_t)this - sizeof(MetaData) - size);
		}
	};

	char* buf = nullptr;
	idx_t bufSize = 0;
	idx_t bufCapacity = 0;

	std::map<idx_t, std::set<idx_t>> freeRegionsTree;

	constexpr bool FillHole(idx_t holeStart, idx_t size)
	{
		if (size) {
			if (size == 1) {
				*(unsigned char*)&buf[holeStart] = HOLE_REGION;
				return true;
			} else if (size < 2 * sizeof(MetaData)) {
				*(unsigned char*)&buf[holeStart] = HOLE_START;
				for (idx_t i = 2; i < size; i++)
					*(unsigned char*)&buf[holeStart + i - 1] = 0xff;
				*(unsigned char*)&buf[holeStart + size - 1] = HOLE_END;
				return true;
			}
		}

		return false;
	}

	idx_t _Alloc(idx_t sz, size_t alignment);
  public:

	idx_t totalAllocations = 0;
	idx_t totalFrees = 0;
	idx_t totalResizes = 0;
	idx_t totalReallocations = 0;

	PackedAllocator(size_t sz = 10, char* b = nullptr);
	PackedAllocator(const PackedAllocator& o);
	PackedAllocator(const PackedAllocator&& o);
	~PackedAllocator();

	PackedAllocator& operator=(const PackedAllocator& o);
	PackedAllocator& operator=(PackedAllocator&& o);

	idx_t Alloc(idx_t sz = 1, size_t alignment = 4);
	void Free(idx_t idx);
	void FreeAll();

	constexpr auto& operator[](idx_t idx) const
	{
		return buf[idx];
	}

	constexpr auto operator+(idx_t idx) const
	{
		return PackedPtr<char, char*>(buf, idx);
	}
};

template<typename T>
class PackedHeap : protected PackedAllocator
{
  private:

	template<auto& HoleHandler, auto& ChunkHandler>
	void WalkBuffer(char* prevBuf, idx_t limit)
	{
		idx_t idx = 0;
		while (idx < limit) {
			MetaData* meta = (MetaData*)(uintptr_t)&prevBuf[idx];

			if ((unsigned char)meta->used == HOLE_START) {
				idx_t holeStart = idx;
				while ((unsigned char)prevBuf[idx++] != HOLE_END)
					;
				HoleHandler(buf, prevBuf, holeStart, idx);
				continue;
			} else if ((unsigned char)meta->used == HOLE_REGION) {
				idx++;
				HoleHandler(buf, prevBuf, idx - 1, idx);
				continue;
			}

			ChunkHandler(buf, prevBuf, idx, meta);

			idx += meta->size + sizeof(MetaData) * 2;
		}
	}

	static void HoleCopy(char* buf, char* prevBuf, idx_t start, idx_t end)
	{
		memcpy(buf + start, prevBuf + start, end - start);
	}

	static void HoleNull([[maybe_unused]] char* buf, [[maybe_unused]] char* prevBuf, [[maybe_unused]] idx_t start, [[maybe_unused]] idx_t end) {}

	static void MoveChunk(char* buf, char* prevBuf, idx_t idx, MetaData* meta)
	{
		*(MetaData*)(uintptr_t)&buf[idx] = *meta;
		*((MetaData*)(uintptr_t)&buf[idx])->WalkUp() = *meta->WalkUp();

		if ((unsigned char)meta->used == USED_REGION) {
			size_t cnt = meta->size / sizeof(T);
			for (size_t i = 0; i < cnt; i++) {
				new(buf + idx + sizeof(MetaData) + i * sizeof(T)) T(*(T*)(uintptr_t)&prevBuf[idx + sizeof(MetaData) + i * sizeof(T)]);
				((T*)(uintptr_t)&prevBuf[idx + sizeof(MetaData) + i * sizeof(T)])->~T();
			}
		}
	}

	static void ConstructChunk(char* buf, char* prevBuf, idx_t idx, MetaData* meta)
	{
		*(MetaData*)(uintptr_t)&buf[idx] = *meta;
		*((MetaData*)(uintptr_t)&buf[idx])->WalkUp() = *meta->WalkUp();

		if ((unsigned char)meta->used == USED_REGION) {
			size_t cnt = meta->size / sizeof(T);
			for (size_t i = 0; i < cnt; i++)
				new(buf + idx + sizeof(MetaData) + i * sizeof(T)) T(*(T*)(uintptr_t)&prevBuf[idx + sizeof(MetaData) + i * sizeof(T)]);
		}
	}

	static void DestructChunk([[maybe_unused]] char* buf, char* prevBuf, idx_t idx, MetaData* meta)
	{
		if ((unsigned char)meta->used == USED_REGION) {
			size_t cnt = meta->size / sizeof(T);
			for (size_t i = 0; i < cnt; i++)
				((T*)&prevBuf[idx + sizeof(MetaData) + i * sizeof(T)])->~T();
		}
	}

  public:

	inline auto& operator=(const PackedHeap& o) const
	{
		totalAllocations = o.totalAllocations;
		totalFrees = o.totalFrees;
		totalResizes = o.totalResizes;
		totalReallocations = o.totalReallocations;

		freeRegionsTree = o.freeRegionsTree;

		if (o.bufSize <= bufCapacity) {
			bufSize = o.bufSize;
		} else {
			if (buf) {
				WalkBuffer<HoleNull, DestructChunk>(buf, bufSize);
				free(buf);
			}
			bufSize = o.bufSize;
			bufCapacity = o.bufCapacity;
			buf = (char*)malloc(bufCapacity);
		}

		WalkBuffer<HoleCopy, ConstructChunk>(o.buf, bufSize);
		return *this;
	}

	constexpr auto& operator=(PackedHeap&& o)
	{
		totalAllocations = o.totalAllocations;
		totalFrees = o.totalFrees;
		totalResizes = o.totalResizes;
		totalReallocations = o.totalReallocations;

		freeRegionsTree = std::move(o.freeRegionsTree);

		if (buf) {
			WalkBuffer<HoleNull, DestructChunk>(buf, bufSize);
			free(buf);
		}

		bufSize = o.bufSize;
		bufCapacity = o.bufCapacity;
		buf = o.buf;
		o.buf = nullptr;

		return *this;
	}

	PackedHeap(size_t sz = 10, char* b = nullptr)
		: PackedAllocator(sz * sizeof(T), b) {}

	constexpr PackedHeap(PackedHeap& o)
	{
		*this = o;
	}

	constexpr PackedHeap(PackedHeap&& o)
	{
		*this = o;
	}

	~PackedHeap()
	{
		DeleteAll();
	}

	inline idx_t New(size_t sz = 1)
	{

		if (!buf) {
			bufCapacity = sz * sizeof(T) + 2 * sizeof(MetaData);
			buf = (char*)malloc(bufCapacity);
		}

		char* prevBuf = buf;

		idx_t ret = _Alloc(sz * sizeof(T), std::alignment_of<T>::value);

		//If the buffer was reallocated, we need to call the move constructors on all members and destruct the members of previous buffer
		if (prevBuf != buf) {
			WalkBuffer<HoleCopy, MoveChunk>(prevBuf, std::min(ret, ret - (idx_t)sizeof(MetaData)));
			free(prevBuf);
		}

		if (ret)
			for (size_t i = 0; i < sz; i++)
				new (&buf[ret + i * sizeof(T)]) T();

		return ret;
	}

	inline void Delete(idx_t idx)
	{
		MetaData* meta = (MetaData*)&buf[idx - sizeof(MetaData)];
		size_t cnt = meta->size / sizeof(T);

		for (size_t i = 0; i < cnt; i++)
			((T*)&buf[idx + i * sizeof(T)])->~T();

		Free(idx);
	}

	inline void DeleteAll()
	{
		if (buf) {
			WalkBuffer<HoleNull, DestructChunk>(buf, bufSize > (idx_t)sizeof(MetaData) ? bufSize - (idx_t)sizeof(MetaData) : 0);
			FreeAll();
		}
	}

	//This is significantly faster if the data stored is simple and does not need constructors/destructors
	inline void DeleteAllFreeOnly()
	{
		if (buf)
			FreeAll();
	}

	constexpr auto& operator[](idx_t idx) const
	{
		return *(T*)&buf[idx];
	}

	constexpr auto operator+(idx_t idx) const
	{
		return PackedPtr<T, decltype(*this)>(*this, idx);
	}
};

#endif

```

`CSGO SDK/Utils/Threading/semaphores.cpp`:

```cpp
#include "semaphores.h"

#if defined(__linux__)
#include <fcntl.h>

Semaphore::Semaphore(bool shared) {
	if (sem_init(&sm, (int)shared, 0) == -1)
#if defined(__cpp_exceptions) || defined(_CPPUNWIND)
		throw;
#else
	;
#endif
}

Semaphore::~Semaphore() {
}

int Semaphore::TimedWait(size_t milliseconds)
{
	struct timespec ts;
	if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
		return 1;
	ts.tv_nsec += 1000000ull * milliseconds;
	return sem_timedwait(&sm, &ts);
}

void Semaphore::Wait() {
	sem_wait(&sm);
}

void Semaphore::Post() {
	sem_post(&sm);
}

unsigned long Semaphore::Count()
{
	int val = 0;
	sem_getvalue(&sm, &val);
	return val;
}

#elif defined(__APPLE__)

Semaphore::Semaphore(bool shared) {
	sm = dispatch_semaphore_create(0);
}

Semaphore::~Semaphore() {
	dispatch_release(sm);
}

void Semaphore::Wait() {
	dispatch_semaphore_wait(sm, DISPATCH_TIME_FOREVER);
}

int Semaphore::TimedWait(size_t milliseconds) {
	return dispatch_semaphore_wait(sm, dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_MSEC * milliseconds));
}

void Semaphore::Post() {
	dispatch_semaphore_signal(sm);
}

unsigned long Semaphore::Count()
{
	int val = 0;
	return val;
}

#else

Semaphore::Semaphore(bool shared) {
	// Unnamed shared semaphores do not work on windows
	if (shared)
#if defined(__cpp_exceptions) || defined(_CPPUNWIND)
		throw;
#else
	return;
#endif
	sm = CreateSemaphoreA(nullptr, 0, 0xffff, nullptr);
}

Semaphore::~Semaphore() {
	CloseHandle(sm);
}

void Semaphore::Wait() {
	WaitForSingleObject(sm, INFINITE);
}

int Semaphore::TimedWait(size_t milliseconds)
{
	if (WaitForSingleObject(sm, milliseconds) == WAIT_OBJECT_0)
		return 0;
	return 1;
}

void Semaphore::Post() {
	ReleaseSemaphore(sm, 1, NULL);
}

unsigned long Semaphore::Count()
{
	long previous;
	switch (WaitForSingleObject(sm, 0)) {
	  case WAIT_OBJECT_0:
		  ReleaseSemaphore(sm, 1, &previous);
		  return previous + 1;
	  case WAIT_TIMEOUT:
		  return 0;
	}
	return 0;
}
#endif

```

`CSGO SDK/Utils/Threading/semaphores.h`:

```h
#ifndef SEMAPHORES_H
#define SEMAPHORES_H

#include <stdint.h>
#if defined(__linux__) || defined(__APPLE__)
#include <stddef.h>
#endif

#if defined(__linux__)
#include <semaphore.h>
#include <time.h>
#elif defined(__APPLE__)
#include <dispatch/dispatch.h>
#else
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif

class Semaphore
{
	public:
	Semaphore(bool shared = false);
	~Semaphore();
	void Wait();
	int TimedWait(size_t milliseconds);
	void Post();
	unsigned long Count();
	private:

#if defined(__linux__)
	sem_t sm;
#elif defined(__APPLE__)
	dispatch_semaphore_t sm;
#else
	HANDLE sm;
#endif
};

#endif


```

`CSGO SDK/Utils/Threading/shared_mutex.cpp`:

```cpp
#include "shared_mutex.h"

#if defined(__linux__) || defined(__APPLE__)
#include <pthread.h>

SharedMutex::SharedMutex() {
	lock = PTHREAD_RWLOCK_INITIALIZER;
}

SharedMutex::~SharedMutex() {
	pthread_rwlock_destroy(&lock);
}

void SharedMutex::rlock() {
	pthread_rwlock_rdlock(&lock);
}

bool SharedMutex::tryrlock() {
	int ret = pthread_rwlock_tryrdlock(&lock);
	return !ret;
}

void SharedMutex::runlock() {
	pthread_rwlock_unlock(&lock);
}

void SharedMutex::wlock() {
	pthread_rwlock_wrlock(&lock);
}

bool SharedMutex::trywlock() {
	int ret = pthread_rwlock_trywrlock(&lock);
	return !ret;
}

void SharedMutex::wunlock() {
	pthread_rwlock_unlock(&lock);
}

#else
#include <windows.h>

SharedMutex::SharedMutex() {
	::InitializeSRWLock(&lock);
}

SharedMutex::~SharedMutex() {
	//No release function
}

void SharedMutex::rlock() {
	::AcquireSRWLockShared(&lock);
}

bool SharedMutex::tryrlock() {
	return ::TryAcquireSRWLockShared(&lock);
}

void SharedMutex::runlock() {
	::ReleaseSRWLockShared(&lock);
}

void SharedMutex::wlock() {
	::AcquireSRWLockExclusive(&lock);
}

bool SharedMutex::trywlock() {
	return ::TryAcquireSRWLockExclusive(&lock);
}

void SharedMutex::wunlock() {
	::ReleaseSRWLockExclusive(&lock);
}
#endif

```

`CSGO SDK/Utils/Threading/shared_mutex.h`:

```h
#ifndef SHARED_MUTEX_H
#define SHARED_MUTEX_H

#if defined(__linux__) || defined(__APPLE__)
#include <pthread.h>
#else
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#endif

class SharedMutex {
  public:
	SharedMutex();
	~SharedMutex();
	void rlock();
	bool tryrlock();
	void runlock();
	void wlock();
	bool trywlock();
	void wunlock();
  private:
#if defined(__linux__) || defined(__APPLE__)
	pthread_rwlock_t lock;
#else
	SRWLOCK lock;
#endif
};

#endif

```

`CSGO SDK/Utils/Threading/threading.cpp`:

```cpp
#include "threading.h"
#include <thread>
#include "../Math.h"
static LList<struct Job> jobs;
int Threading::threadID = -1;

uint64_t Threading::_QueueJob( JobFn function, void* data, bool ref, bool priority ) {
   Job job;
   job.args = data;
   job.function = function;
   job.ref = ref;
   uint64_t ret = jobs.Enqueue( job, priority );
   return ret;
}

static void RunJob( struct Job& job ) {
   job.function( job.args );
   if ( !job.ref )
	  free( job.args );
}

static void* __stdcall ThreadLoop( void* t ) {
   struct JobThread* thread = ( struct JobThread* )t;

   Threading::threadID = thread->id;

   struct Job job;
   thread->isRunning = true;
   while ( !thread->shouldQuit ) {
	  if ( job.id ^ ~0ull ) {
		 thread->queueEmpty = false;
		 RunJob( job );
	  } else
		 thread->queueEmpty = true;
	  struct LList<struct Job>* tJobs = thread->jobs;
	  thread->jLock->unlock( );
	  job = tJobs->PopFront( thread->jLock );
   }
   thread->isRunning = false;
   return nullptr;
}

unsigned int Threading::numThreads = 0;
static struct JobThread* threads = nullptr;

static void InitThread( struct JobThread* thread, int id ) {
   thread->id = id;
   thread->jLock = new Mutex( );
   thread->jobs = &jobs;
   thread_t handle = Threading::StartThread( ThreadLoop, thread, false );
   thread->handle = malloc( sizeof( thread_t ) );
   *( thread_t* ) thread->handle = handle;
}

void Threading::InitThreads( ) {
   numThreads = std::thread::hardware_concurrency( );
   numThreads = Math::Clamp<unsigned int>( numThreads, 2, 16 );

   threads = ( struct JobThread* )calloc( numThreads, sizeof( struct JobThread ) );

   for ( unsigned int i = 0; i < numThreads; i++ )
	  InitThread( threads + i, i );
}

int Threading::EndThreads( ) {
   int ret = 0;

   if ( !threads )
	  return ret;

   for ( unsigned int i = 0; i < numThreads; i++ )
	  threads[ i ].shouldQuit = true;

   for ( unsigned int i = 0; i < numThreads; i++ )
	  threads[ i ].jobs->quit = true;

   for ( int o = 0; o < 4; o++ )
	  for ( unsigned int i = 0; i < numThreads; i++ )
		 threads[ i ].jobs->sem.Post( );

   for ( size_t i = 0; i < numThreads; i++ ) {
   #if defined(__linux__) || defined(__APPLE__)
	  void* ret2 = nullptr;
	  pthread_join( *( pthread_t* ) threads[ i ].handle, &ret2 );
   #else
	  ResumeThread( *( HANDLE* ) threads[ i ].handle );
	  if ( WaitForSingleObject( *( HANDLE* ) threads[ i ].handle, 100 ) == WAIT_TIMEOUT && threads[ i ].isRunning )
		 ;
   #endif
	  delete threads[ i ].jLock;
	  threads[ i ].jLock = nullptr;
	  free( threads[ i ].handle );
   }
   free( threads );
   threads = nullptr;

   return ret;
}

void Threading::FinishQueue( bool executeJobs ) {
   if ( !threads )
	  return;

   if ( executeJobs ) {
	  for ( unsigned int i = 0; i < numThreads; i++ ) {
		 auto jobList = &jobs;
		 if ( threads[ i ].jobs )
			jobList = threads[ i ].jobs;
		 while ( 1 ) {
			struct Job job = jobList->TryPopFront( );
			if ( job.id == ~0ull )
			   break;
			RunJob( job );
		 }
	  }
   }

   for ( unsigned int i = 0; i < numThreads; i++ ) {
	  if ( threads[ i ].jobs )
		 while ( !threads[ i ].jobs->IsEmpty( ) );

	  threads[ i ].jLock->lock( );
	  threads[ i ].jLock->unlock( );
   }
}

JobThread* Threading::BindThread( LList<struct Job>* jobsQueue ) {
   for ( size_t i = 0; i < numThreads; i++ ) {
	  if ( threads[ i ].jobs == &jobs || !threads[ i ].jobs ) {
		 threads[ i ].jobs = jobsQueue;
		 for ( size_t o = 0; o < numThreads; o++ )
			jobs.sem.Post( );
		 return threads + i;
	  }
   }
   return nullptr;
}

void Threading::UnbindThread( LList<struct Job>* jobsQueue ) {
   for ( size_t i = 0; i < numThreads; i++ ) {
	  threads[ i ].jLock->lock( );
	  if ( threads[ i ].jobs == jobsQueue )
		 threads[ i ].jobs = &jobs;
	  threads[ i ].jLock->unlock( );
   }
}

thread_t Threading::StartThread( threadFn start, void* arg, bool detached, thread_t* thread ) {
#ifdef _WIN32
   auto hThread = CreateThread( nullptr, 0, ( LPTHREAD_START_ROUTINE ) start, arg, 0, thread );
   SetThreadPriority( hThread, THREAD_PRIORITY_TIME_CRITICAL );

   if( hThread )
	   CloseHandle( hThread );
#else
   pthread_attr_t* attr = nullptr;
   pthread_attr_t tAttr;
   if ( detached ) {
	  pthread_attr_init( &tAttr );
	  pthread_attr_setdetachstate( &tAttr, PTHREAD_CREATE_DETACHED );
	  attr = &tAttr;
   }
   pthread_create( thread, attr, start, arg );
#endif
   return *thread;
}

thread_t Threading::StartThread( threadFn start, void* arg, bool detached ) {
   thread_t thread;
   return StartThread( start, arg, detached, &thread );
}

void Threading::JoinThread( thread_t thread, void** returnVal ) {
#ifdef __posix__
   pthread_join( thread, returnVal );
#else
   WaitForSingleObject( ( void* ) thread, INFINITE );
#endif
}


```

`CSGO SDK/Utils/Threading/threading.h`:

```h
#ifndef THREADING_H
#define THREADING_H

#include "mutex.h"
#include "semaphores.h"
#include "packed_heap.h"
#include "atomic_lock.h"
#include <atomic>

#if defined(__posix__)
#include <unistd.h>
#include <pthread.h>
#include <stdlib.h>
#include <string.h>

typedef pthread_t thread_t;

#else
#define NOMINMAX
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <Psapi.h>
#include "stdint.h"

typedef unsigned long thread_t;

#endif

typedef void(*JobFn)(void*);
typedef void*(__stdcall*threadFn)(void*);

struct Job
{
	JobFn function;
	void* args;
	bool ref;
	uint64_t id;

	Job()
	{
		function = nullptr;
		args = nullptr;
		ref = true;
		id = ~0ull;
	}
};

template <typename T>
struct LList
{

	struct LEntry
	{
		T entry;
		idx_t prev;
		idx_t next;
	};

	PackedHeapL<LEntry> entries;

    Mutex lock;
	bool quit;
	idx_t front;
	idx_t back;
	uint64_t lastID;
	uint64_t lastPopID;

	Semaphore sem;

	LList() {
		front = 0;
		back = 0;
		lastID = 0;
		lastPopID = 0;
	}

	uint64_t Enqueue(const T& data, bool priority = false) {
		lock.lock();
		idx_t entry = entries.Alloc();
		if (priority) {
			entries[entry] = { data, front, 0 };
			entries[entry].entry.id = lastID;
			if (front)
				entries[front].next = entry;
			if (!back) {
				back = entry;
				entries[back].next = 0;
			}
			entries[entry].prev = front;
			front = entry;
		} else {
			entries[entry] = { data, 0, back };
			entries[entry].entry.id = lastID;
			if (back)
				entries[back].prev = entry;
			if (!front) {
				front = entry;
				entries[front].prev = 0;
			}
			entries[entry].next = back;
			back = entry;
		}
		uint64_t id = lastID++;
		lock.unlock();
		sem.Post();
		return id;
	}

	T DoPopFront(Mutex* lck) {
		lock.lock();
		if (!front) {
			lock.unlock();
			return Job();
		}
		if (lck)
			lck->lock();
		LEntry* entry = &entries[front];
		front = entry->prev;
		if (front)
			entries[front].next = 0;
		else
			back = 0;
		T ret = entry->entry;
		lastPopID = ret.id;
		entries.Free(entry);
		lock.unlock();
		return ret;
	}

	T PopFront(Mutex* lck = nullptr) {
		sem.Wait();
		if (quit) {
			sem.Post();
			return Job();
		}
		return DoPopFront(lck);
	}

	T TryPopFront() {
		if (sem.TimedWait(0))
			return Job();

		if (quit) {
			sem.Post();
			return Job();
		}

		return DoPopFront(nullptr);
	}

#ifdef _MSC_VER
	__declspec(noinline)
#else
	__attribute__((noinline))
#endif
	bool IsEmpty()
	{
		static volatile short cnt = 0;
		cnt++;
		return !front;
	}
};

struct JobThread
{
	std::atomic_bool shouldQuit;
	std::atomic_bool isRunning;
	std::atomic_bool queueEmpty;
	Mutex* jLock;
	LList<struct Job>* jobs;
	int id;
	void* handle;
};

namespace Threading
{
	extern unsigned int numThreads;
	extern int threadID;
	uint64_t _QueueJob(JobFn function, void* data, bool ref = false, bool priority = false);
	void InitThreads();
	int EndThreads();
	void FinishQueue(bool executeJobs = false);
	JobThread* BindThread(LList<struct Job>* jobsQueue);
	void UnbindThread(LList<struct Job>* jobsQueue);
	thread_t StartThread(threadFn start, void* param, bool detached = true);
	thread_t StartThread(threadFn start, void* param, bool detached, thread_t* thread);
	void JoinThread(thread_t thread, void** returnVal);

	template<typename N, typename T>
	uint64_t QueueJob(N function, T data, bool priority = false) {
		void* d = malloc(sizeof(T));
		memcpy(d, (void*)&data, sizeof(T));
		return _QueueJob((JobFn)function, d, false, priority);
	}

	template<typename N, typename T>
	uint64_t QueueJobRef(N function, T* data, bool priority = false) {
		return _QueueJob((JobFn)function, (void*)data, true, priority);
	}
}

#endif


```

`CSGO SDK/Utils/XorStr.hpp`:

```hpp
#pragma once


#define DefXorStr(str) str
#define XorStr(str)    str

```

`CSGO SDK/Utils/base64.h`:

```h
#pragma once

#include <string>

class base64 {
public:
	static std::string encode(const std::string data) {
		static constexpr char sEncodingTable[] = {
			'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
			'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
			'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
			'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
			'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
			'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
			'w', 'x', 'y', 'z', '0', '1', '2', '3',
			'4', '5', '6', '7', '8', '9', '+', '/'
		};

		size_t in_len = data.size();
		size_t out_len = 4 * ((in_len + 2) / 3);
		std::string ret(out_len, '\0');
		size_t i;
		char* p = const_cast<char*>(ret.c_str());

		for (i = 0; i < in_len - 2; i += 3) {
			*p++ = sEncodingTable[(data[i] >> 2) & 0x3F];
			*p++ = sEncodingTable[((data[i] & 0x3) << 4) | ((int)(data[i + 1] & 0xF0) >> 4)];
			*p++ = sEncodingTable[((data[i + 1] & 0xF) << 2) | ((int)(data[i + 2] & 0xC0) >> 6)];
			*p++ = sEncodingTable[data[i + 2] & 0x3F];
		}
		if (i < in_len) {
			*p++ = sEncodingTable[(data[i] >> 2) & 0x3F];
			if (i == (in_len - 1)) {
				*p++ = sEncodingTable[((data[i] & 0x3) << 4)];
				*p++ = '=';
			}
			else {
				*p++ = sEncodingTable[((data[i] & 0x3) << 4) | ((int)(data[i + 1] & 0xF0) >> 4)];
				*p++ = sEncodingTable[((data[i + 1] & 0xF) << 2)];
			}
			*p++ = '=';
		}

		return ret;
	}

	static std::string decode(const std::string input) {
		static constexpr unsigned char kDecodingTable[] = {
			64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
			64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
			64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
			52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
			64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
			15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
			64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
			41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
			64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
			64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
			64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
			64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
			64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
			64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
			64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
			64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64
		};

		size_t in_len = input.size();
		if (in_len % 4 != 0) return ("Input data size is not a multiple of 4");

		size_t out_len = in_len / 4 * 3;
		if (input[in_len - 1] == '=') out_len--;
		if (input[in_len - 2] == '=') out_len--;

		std::string out;
		out.resize(out_len);

		for (size_t i = 0, j = 0; i < in_len;) {
			uint32_t a = input[i] == '=' ? 0 & i++ : kDecodingTable[static_cast<int>(input[i++])];
			uint32_t b = input[i] == '=' ? 0 & i++ : kDecodingTable[static_cast<int>(input[i++])];
			uint32_t c = input[i] == '=' ? 0 & i++ : kDecodingTable[static_cast<int>(input[i++])];
			uint32_t d = input[i] == '=' ? 0 & i++ : kDecodingTable[static_cast<int>(input[i++])];

			uint32_t triple = (a << 3 * 6) + (b << 2 * 6) + (c << 1 * 6) + (d << 0 * 6);

			if (j < out_len) out[j++] = (triple >> 2 * 8) & 0xFF;
			if (j < out_len) out[j++] = (triple >> 1 * 8) & 0xFF;
			if (j < out_len) out[j++] = (triple >> 0 * 8) & 0xFF;
		}

		return out;
	}
};
```

`CSGO SDK/Utils/defs.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <Windows.h>
#include <winternl.h>

#define FILE_OPEN 0x00000001
#define FILE_NON_DIRECTORY_FILE 0x00000040
#define FILE_OPEN_BY_FILE_ID 0x00002000

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED 0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH 0x00000002
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET 0x00000020
#define THREAD_CREATE_FLAGS_INITIAL_THREAD 0x00000080

typedef struct _API_SET_NAMESPACE {
   ULONG Version;
   ULONG Size;
   ULONG Flags;
   ULONG Count;
   ULONG EntryOffset;
   ULONG HashOffset;
   ULONG HashFactor;
} API_SET_NAMESPACE, * PAPI_SET_NAMESPACE;

typedef struct _API_SET_NAMESPACE_ENTRY {
   ULONG Flags;
   ULONG NameOffset;
   ULONG NameLength;
   ULONG HashedLength;
   ULONG ValueOffset;
   ULONG ValueCount;
} API_SET_NAMESPACE_ENTRY, * PAPI_SET_NAMESPACE_ENTRY;

typedef struct _RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION {
   HANDLE ReflectionProcessHandle;
   HANDLE ReflectionThreadHandle;
   CLIENT_ID ReflectionClientId;
} RTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION, * PRTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION;

using NtAllocateVirtualMemory = NTSTATUS( NTAPI* )( HANDLE process_handle, PVOID* base_address,
													std::uint32_t* bits, size_t* size, std::uint32_t type, std::uint32_t access );

using NtReadVirtualMemory = NTSTATUS( NTAPI* )( HANDLE process_handle, PVOID base_address, PVOID buffer,
												ULONG number_of_bytes_to_read, PULONG number_of_bytes_readed );

using NtWriteVirtualMemory = NTSTATUS( NTAPI* )( HANDLE process_handle, PVOID base_address, PVOID buffer,
												 ULONG number_of_bytes_to_write, PULONG number_of_bytes_written );

using NtFreeVirtualMemory = NTSTATUS( NTAPI* )( HANDLE process_handle, PVOID* base_address, PSIZE_T region_size, ULONG free_type );

using NtProtectVirtualMemory = NTSTATUS( NTAPI* )( HANDLE process_handle, PVOID* base_address, PULONG number_of_bytes_to_protect,
												   ULONG new_access_protection, PULONG old_access_protection );

using NtYieldExecution = NTSTATUS( NTAPI* )( );

using NtCreateThreadEx = NTSTATUS( NTAPI* )( PHANDLE thread_handle, ACCESS_MASK desired_access, POBJECT_ATTRIBUTES object_attributes,
											 HANDLE process_handle, PVOID start_routine, PVOID argument, ULONG create_flags,
											 ULONG_PTR zero_bits, SIZE_T stack_size, SIZE_T maximum_stack_size, PVOID attribute_list );

using NtResumeThread = NTSTATUS( NTAPI* )( HANDLE thread_handle, PULONG suspend_count );

using NtGetContextThread = NTSTATUS( NTAPI* )( HANDLE thread_handle, PCONTEXT context );

using NtSetContextThread = NTSTATUS( NTAPI* )( HANDLE thread_handle, PCONTEXT context );

using RtlCreateProcessReflection = NTSTATUS( NTAPI* )( HANDLE process_handle, ULONG flags, PVOID start_routine,
													   PVOID start_context, HANDLE event_handle, PRTLP_PROCESS_REFLECTION_REFLECTION_INFORMATION reflection_information );

// ReSharper restore CppInconsistentNaming

static const auto current_process = reinterpret_cast< HANDLE >( -1 );
```

`CSGO SDK/Utils/lazy_importer.hpp`:

```hpp
/*
* Copyright 2018 Justas Masiulis
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

// documentation is available at https://github.com/JustasMasiulis/lazy_importer

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP

#define LI_FN(name) \
    ::li::detail::lazy_function<::li::detail::khash(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<::li::detail::khash(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<::li::detail::khash(name)>()

// NOTE only std::forward is used from this header.
// If there is a need to eliminate this dependency the function itself is very small.
#include <utility>
#include <cstddef>
#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif

#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_TOLOWER(c) (c >= 'A' && c <= 'Z' ? (c | (1 << 5)) : c)
#else
#define LAZY_IMPORTER_TOLOWER(c) (c)
#endif

namespace li { namespace detail {

   template<class First, class Second>
   struct pair {
	  First  first;
	  Second second;
   };

   namespace win {

	  struct LIST_ENTRY_T {
		 const char* Flink;
		 const char* Blink;
	  };

	  struct UNICODE_STRING_T {
		 unsigned short Length;
		 unsigned short MaximumLength;
		 wchar_t*       Buffer;
	  };

	  struct PEB_LDR_DATA_T {
		 unsigned long Length;
		 unsigned long Initialized;
		 const char*   SsHandle;
		 LIST_ENTRY_T  InLoadOrderModuleList;
	  };

	  struct PEB_T {
		 unsigned char   Reserved1[2];
		 unsigned char   BeingDebugged;
		 unsigned char   Reserved2[1];
		 const char*     Reserved3[2];
		 PEB_LDR_DATA_T* Ldr;
	  };

	  struct LDR_DATA_TABLE_ENTRY_T {
		 LIST_ENTRY_T InLoadOrderLinks;
		 LIST_ENTRY_T InMemoryOrderLinks;
		 LIST_ENTRY_T InInitializationOrderLinks;
		 const char*  DllBase;
		 const char*  EntryPoint;
		 union {
			unsigned long SizeOfImage;
			const char*   _dummy;
		 };
		 UNICODE_STRING_T FullDllName;
		 UNICODE_STRING_T BaseDllName;

		 LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
			load_order_next() const noexcept
		 {
			return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
			   InLoadOrderLinks.Flink);
		 }
	  };

	  struct IMAGE_DOS_HEADER { // DOS .EXE header
		 unsigned short e_magic; // Magic number
		 unsigned short e_cblp; // Bytes on last page of file
		 unsigned short e_cp; // Pages in file
		 unsigned short e_crlc; // Relocations
		 unsigned short e_cparhdr; // Size of header in paragraphs
		 unsigned short e_minalloc; // Minimum extra paragraphs needed
		 unsigned short e_maxalloc; // Maximum extra paragraphs needed
		 unsigned short e_ss; // Initial (relative) SS value
		 unsigned short e_sp; // Initial SP value
		 unsigned short e_csum; // Checksum
		 unsigned short e_ip; // Initial IP value
		 unsigned short e_cs; // Initial (relative) CS value
		 unsigned short e_lfarlc; // File address of relocation table
		 unsigned short e_ovno; // Overlay number
		 unsigned short e_res[4]; // Reserved words
		 unsigned short e_oemid; // OEM identifier (for e_oeminfo)
		 unsigned short e_oeminfo; // OEM information; e_oemid specific
		 unsigned short e_res2[10]; // Reserved words
		 long           e_lfanew; // File address of new exe header
	  };

	  struct IMAGE_FILE_HEADER {
		 unsigned short Machine;
		 unsigned short NumberOfSections;
		 unsigned long  TimeDateStamp;
		 unsigned long  PointerToSymbolTable;
		 unsigned long  NumberOfSymbols;
		 unsigned short SizeOfOptionalHeader;
		 unsigned short Characteristics;
	  };

	  struct IMAGE_EXPORT_DIRECTORY {
		 unsigned long  Characteristics;
		 unsigned long  TimeDateStamp;
		 unsigned short MajorVersion;
		 unsigned short MinorVersion;
		 unsigned long  Name;
		 unsigned long  Base;
		 unsigned long  NumberOfFunctions;
		 unsigned long  NumberOfNames;
		 unsigned long  AddressOfFunctions; // RVA from base of image
		 unsigned long  AddressOfNames; // RVA from base of image
		 unsigned long  AddressOfNameOrdinals; // RVA from base of image
	  };

	  struct IMAGE_DATA_DIRECTORY {
		 unsigned long VirtualAddress;
		 unsigned long Size;
	  };

	  struct IMAGE_OPTIONAL_HEADER64 {
		 unsigned short       Magic;
		 unsigned char        MajorLinkerVersion;
		 unsigned char        MinorLinkerVersion;
		 unsigned long        SizeOfCode;
		 unsigned long        SizeOfInitializedData;
		 unsigned long        SizeOfUninitializedData;
		 unsigned long        AddressOfEntryPoint;
		 unsigned long        BaseOfCode;
		 unsigned long long   ImageBase;
		 unsigned long        SectionAlignment;
		 unsigned long        FileAlignment;
		 unsigned short       MajorOperatingSystemVersion;
		 unsigned short       MinorOperatingSystemVersion;
		 unsigned short       MajorImageVersion;
		 unsigned short       MinorImageVersion;
		 unsigned short       MajorSubsystemVersion;
		 unsigned short       MinorSubsystemVersion;
		 unsigned long        Win32VersionValue;
		 unsigned long        SizeOfImage;
		 unsigned long        SizeOfHeaders;
		 unsigned long        CheckSum;
		 unsigned short       Subsystem;
		 unsigned short       DllCharacteristics;
		 unsigned long long   SizeOfStackReserve;
		 unsigned long long   SizeOfStackCommit;
		 unsigned long long   SizeOfHeapReserve;
		 unsigned long long   SizeOfHeapCommit;
		 unsigned long        LoaderFlags;
		 unsigned long        NumberOfRvaAndSizes;
		 IMAGE_DATA_DIRECTORY DataDirectory[16];
	  };

	  struct IMAGE_OPTIONAL_HEADER32 {
		 unsigned short       Magic;
		 unsigned char        MajorLinkerVersion;
		 unsigned char        MinorLinkerVersion;
		 unsigned long        SizeOfCode;
		 unsigned long        SizeOfInitializedData;
		 unsigned long        SizeOfUninitializedData;
		 unsigned long        AddressOfEntryPoint;
		 unsigned long        BaseOfCode;
		 unsigned long        BaseOfData;
		 unsigned long        ImageBase;
		 unsigned long        SectionAlignment;
		 unsigned long        FileAlignment;
		 unsigned short       MajorOperatingSystemVersion;
		 unsigned short       MinorOperatingSystemVersion;
		 unsigned short       MajorImageVersion;
		 unsigned short       MinorImageVersion;
		 unsigned short       MajorSubsystemVersion;
		 unsigned short       MinorSubsystemVersion;
		 unsigned long        Win32VersionValue;
		 unsigned long        SizeOfImage;
		 unsigned long        SizeOfHeaders;
		 unsigned long        CheckSum;
		 unsigned short       Subsystem;
		 unsigned short       DllCharacteristics;
		 unsigned long        SizeOfStackReserve;
		 unsigned long        SizeOfStackCommit;
		 unsigned long        SizeOfHeapReserve;
		 unsigned long        SizeOfHeapCommit;
		 unsigned long        LoaderFlags;
		 unsigned long        NumberOfRvaAndSizes;
		 IMAGE_DATA_DIRECTORY DataDirectory[16];
	  };

	  struct IMAGE_NT_HEADERS {
		 unsigned long     Signature;
		 IMAGE_FILE_HEADER FileHeader;
	  #ifdef _WIN64
		 IMAGE_OPTIONAL_HEADER64 OptionalHeader;
	  #else
		 IMAGE_OPTIONAL_HEADER32 OptionalHeader;
	  #endif
	  };

   } // namespace win

	 // hashing stuff
   struct hash_t {
	  using value_type                            = unsigned long;
	  constexpr static value_type         offset  = 2166136261;
	  constexpr static value_type         prime   = 16777619;
	  constexpr static unsigned long long prime64 = prime;

	  LAZY_IMPORTER_FORCEINLINE constexpr static value_type single(value_type value,
		 char c) noexcept
	  {
		 return static_cast<hash_t::value_type>(
			(value ^ LAZY_IMPORTER_TOLOWER(c)) *
			static_cast<unsigned long long>(prime));
	  }
   };

   template<class CharT = char>
   LAZY_IMPORTER_FORCEINLINE constexpr hash_t::value_type
	  khash(const CharT* str, hash_t::value_type value = hash_t::offset) noexcept
   {
	  return (*str ? khash(str + 1, hash_t::single(value, *str)) : value);
   }

   template<class CharT = char>
   LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(const CharT* str) noexcept
   {
	  hash_t::value_type value = hash_t::offset;

	  for(;;) {
		 char c = *str++;
		 if(!c)
			return value;
		 value = hash_t::single(value, c);
	  }
   }

   LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(
	  const win::UNICODE_STRING_T& str) noexcept
   {
	  auto       first = str.Buffer;
	  const auto last  = first + (str.Length / sizeof(wchar_t));
	  auto       value = hash_t::offset;
	  for(; first != last; ++first)
		 value = hash_t::single(value, static_cast<char>(*first));

	  return value;
   }

   LAZY_IMPORTER_FORCEINLINE pair<hash_t::value_type, hash_t::value_type> hash_forwarded(
	  const char* str) noexcept
   {
	  pair<hash_t::value_type, hash_t::value_type> module_and_function{
		 hash_t::offset, hash_t::offset
	  };

	  for(; *str != '.'; ++str)
		 hash_t::single(module_and_function.first, *str);

	  ++str;

	  for(; *str; ++str)
		 hash_t::single(module_and_function.second, *str);

	  return module_and_function;
   }


   // some helper functions
   LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
   {
   #if defined(_WIN64)
	  return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
   #elif defined(_WIN32)
	  return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
   #else
   #error Unsupported platform. Open an issue and I'll probably add support.
   #endif
   }

   LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
   {
	  return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
   }

   LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
	  const char* base) noexcept
   {
	  return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
		 base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
   }

   LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
	  const char* base) noexcept
   {
	  return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
		 base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
   }

   LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
   {
	  return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
		 ldr()->InLoadOrderModuleList.Flink);
   }

   struct exports_directory {
	  const char*                        _base;
	  const win::IMAGE_EXPORT_DIRECTORY* _ied;
	  unsigned long                      _ied_size;

   public:
	  using size_type = unsigned long;

	  LAZY_IMPORTER_FORCEINLINE
		 exports_directory(const char* base) noexcept : _base(base)
	  {
		 const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
		 _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
			base + ied_data_dir.VirtualAddress);
		 _ied_size = ied_data_dir.Size;
	  }

	  LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
	  {
		 return reinterpret_cast<const char*>(_ied) != _base;
	  }

	  LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
	  {
		 return _ied->NumberOfNames;
	  }

	  LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
	  LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
	  {
		 return _ied;
	  }

	  LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
	  {
		 return reinterpret_cast<const char*>(
			_base + reinterpret_cast<const unsigned long*>(
			_base + _ied->AddressOfNames)[index]);
	  }

	  LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
	  {
		 const auto* const rva_table =
			reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

		 const auto* const ord_table = reinterpret_cast<const unsigned short*>(
			_base + _ied->AddressOfNameOrdinals);

		 return _base + rva_table[ord_table[index]];
	  }

	  LAZY_IMPORTER_FORCEINLINE bool is_forwarded(const char* export_address) const
		 noexcept
	  {
		 const auto ui_ied = reinterpret_cast<const char*>(_ied);
		 return (export_address > ui_ied && export_address < ui_ied + _ied_size);
	  }
   };

   struct safe_module_enumerator {
	  using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
	  value_type*       value;
	  value_type* const head;

	  LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
		 : value(ldr_data_entry()), head(value)
	  {}

	  LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = head; }

	  LAZY_IMPORTER_FORCEINLINE bool next() noexcept
	  {
		 value = value->load_order_next();
		 return value != head && value->DllBase;
	  }
   };

   struct unsafe_module_enumerator {
	  using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
	  value_type value;

	  LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
		 : value(ldr_data_entry())
	  {}

	  LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

	  LAZY_IMPORTER_FORCEINLINE bool next() noexcept
	  {
		 value = value->load_order_next();
		 return true;
	  }
   };

   // provides the cached functions which use Derive classes methods
   template<class Derived, class DefaultType = void*>
   class lazy_base {
   protected:
	  // This function is needed because every templated function
	  // with different args has its own static buffer
	  LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
	  {
		 static void* value = nullptr;
		 return value;
	  }

   public:
	  template<class T = DefaultType>
	  LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
	  {
		 return Derived::template get<T, safe_module_enumerator>();
	  }

	  template<class T = DefaultType, class Enum = unsafe_module_enumerator>
	  LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
	  {
		 auto& cached = _cache();
		 if(!cached)
			cached = Derived::template get<void*, Enum>();

		 return (T)(cached);
	  }

	  template<class T = DefaultType>
	  LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
	  {
		 return cached<T, safe_module_enumerator>();
	  }
   };

   template<hash_t::value_type Hash>
   struct lazy_module : lazy_base<lazy_module<Hash>> {
	  template<class T = void*, class Enum = unsafe_module_enumerator>
	  LAZY_IMPORTER_FORCEINLINE static T get() noexcept
	  {
		 Enum e;
		 do {
			if(hash(e.value->BaseDllName) == Hash)
			   return (T)(e.value->DllBase);
		 } while(e.next());
		 return {};
	  }
   };

   template<hash_t::value_type Hash, class T>
   struct lazy_function : lazy_base<lazy_function<Hash, T>, T> {
	  using base_type = lazy_base<lazy_function<Hash, T>, T>;

	  template<class... Args>
	  LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
	  {
	  #ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
		 return get()(std::forward<Args>(args)...);
	  #else
		 return this->cached()(std::forward<Args>(args)...);
	  #endif
	  }

	  template<class F = T, class Enum = unsafe_module_enumerator>
	  LAZY_IMPORTER_FORCEINLINE static F get() noexcept
	  {
		 // for backwards compatability.
		 // Before 2.0 it was only possible to resolve forwarded exports when
		 // this macro was enabled
	  #ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
		 return forwarded<F, Enum>();
	  #else
		 Enum e;
		 do {
			const exports_directory exports(e.value->DllBase);

			if(exports) {
			   auto export_index = exports.size();
			   while(export_index--)
				  if(hash(exports.name(export_index)) == Hash)
					 return (F)(exports.address(export_index));
			}
		 } while(e.next());
		 return {};
	  #endif
	  }

	  template<class F = T, class Enum = unsafe_module_enumerator>
	  LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
	  {
		 detail::win::UNICODE_STRING_T name;
		 hash_t::value_type            module_hash   = 0;
		 auto                          function_hash = Hash;

		 Enum e;
		 do {
			name = e.value->BaseDllName;
			name.Length -= 8; // get rid of .dll extension

			if(!module_hash || hash(name) == module_hash) {
			   const exports_directory exports(e.value->DllBase);

			   if(exports) {
				  auto export_index = exports.size();
				  while(export_index--)
					 if(hash(exports.name(export_index)) == function_hash) {
						const auto addr = exports.address(export_index);

						if(exports.is_forwarded(addr)) {
						   auto hashes = hash_forwarded(
							  reinterpret_cast<const char*>(addr));

						   function_hash = hashes.second;
						   module_hash   = hashes.first;

						   e.reset();
						   break;
						}
						return (F)(addr);
					 }
			   }
			}
		 } while(e.next());
		 return {};
	  }

	  template<class F = T>
	  LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
	  {
		 return forwarded<F, safe_module_enumerator>();
	  }

	  template<class F = T, class Enum = unsafe_module_enumerator>
	  LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
	  {
		 auto& value = base_type::_cache();
		 if(!value)
			value = forwarded<void*, Enum>();
		 return (F)(value);
	  }

	  template<class F = T>
	  LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
	  {
		 return forwarded_cached<F, safe_module_enumerator>();
	  }

	  template<class F = T, bool IsSafe = false, class Module>
	  LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
	  {
		 if(IsSafe && !m)
			return {};

		 const exports_directory exports((const char*)(m));
		 if(IsSafe && !exports)
			return {};

		 for(unsigned long i{};; ++i) {
			if(IsSafe && i == exports.size())
			   break;

			if(hash(exports.name(i)) == Hash)
			   return (F)(exports.address(i));
		 }
		 return {};
	  }

	  template<class F = T, class Module>
	  LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
	  {
		 return in<F, true>(m);
	  }

	  template<class F = T, bool IsSafe = false, class Module>
	  LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
	  {
		 auto& value = base_type::_cache();
		 if(!value)
			value = in<void*, IsSafe>(m);
		 return (F)(value);
	  }

	  template<class F = T, class Module>
	  LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
	  {
		 return in_cached<F, true>(m);
	  }

	  template<class F = T>
	  LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
	  {
		 return in<F>(ldr_data_entry()->load_order_next()->DllBase);
	  }

	  template<class F = T>
	  LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
	  {
		 return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
	  }

	  template<class F = T>
	  LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
	  {
		 return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
	  }

	  template<class F = T>
	  LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
	  {
		 return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
	  }
   };

}} // namespace li::detail

#endif // include guard

```

`CSGO SDK/Utils/syscall.hpp`:

```hpp
#pragma once

#include <Windows.h>
#include <TlHelp32.h>
#include <cstdint>
#include <vector>
#include <algorithm>
#include <string>
#include <fstream>
#include <wintrust.h>
#include <softpub.h>
#include "defs.hpp"

#pragma comment(lib, "Wintrust.lib")

namespace SystemCall
{
   struct syscall_fn {
	  uint32_t index;
	  uint16_t retn;
   };

   __forceinline uintptr_t get_module_handle( const uint32_t module, const uint32_t process = 0 ) {
	  MODULEENTRY32 entry;
	  entry.dwSize = sizeof( MODULEENTRY32 );

	  const auto snapshot = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, process );

	  if ( Module32First( snapshot, &entry ) )
		 while ( Module32Next( snapshot, &entry ) ) {
			std::string name = entry.szModule;
			std::transform( name.begin( ), name.end( ), name.begin( ), ::tolower );

			if ( hash_32_fnv1a_const( name.c_str( ) ) == module ) {
			   CloseHandle( snapshot );
			   return reinterpret_cast< uintptr_t >( entry.hModule );
			}
		 }

	  CloseHandle( snapshot );
	  return 0;
   }

   __forceinline int32_t rva_2_offset( const uint32_t rva, PIMAGE_NT_HEADERS nt_headers, const bool in_memory = false ) {
	  if ( rva == 0 || !in_memory )
		 return rva;

	  auto sec = IMAGE_FIRST_SECTION( nt_headers );
	  for ( size_t i = 0; i < nt_headers->FileHeader.NumberOfSections; i++ ) {
		 if ( rva >= sec->VirtualAddress && rva < sec->VirtualAddress + sec->Misc.VirtualSize )
			break;
		 sec++;
	  }

	  return rva - sec->VirtualAddress + sec->PointerToRawData;
   }

   __forceinline uintptr_t get_proc_address( const uintptr_t module, const uint32_t function, const bool in_memory = false ) {
	  const auto dos_headers = reinterpret_cast< IMAGE_DOS_HEADER* >( module );
	  if ( dos_headers->e_magic != IMAGE_DOS_SIGNATURE )
		 return 0;

	  const auto nt_headers = reinterpret_cast< IMAGE_NT_HEADERS* >( dos_headers->e_lfanew + module );
	  if ( nt_headers->Signature != IMAGE_NT_SIGNATURE )
		 return 0;

	  const auto exports = reinterpret_cast< IMAGE_EXPORT_DIRECTORY* >(
		 rva_2_offset( nt_headers->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ].VirtualAddress,
		 nt_headers, in_memory ) + module );

	  const auto names = reinterpret_cast< uint32_t* >( rva_2_offset( exports->AddressOfNames, nt_headers, in_memory ) + module );

	  auto ordinal_index = static_cast< uint32_t >( -1 );
	  for ( uint32_t i = 0; i < exports->NumberOfFunctions; i++ ) {
		 const auto function_name = reinterpret_cast< const char* >( rva_2_offset( names[ i ], nt_headers, in_memory ) + module );

		 if ( hash_32_fnv1a_const( function_name ) == function ) {
			ordinal_index = i;
			break;
		 }
	  }

	  if ( ordinal_index > exports->NumberOfFunctions )
		 return 0;

	  const auto ordinals = reinterpret_cast< uint16_t* >( rva_2_offset( exports->AddressOfNameOrdinals, nt_headers, in_memory ) + module );
	  const auto addresses = reinterpret_cast< uint32_t* >( rva_2_offset( exports->AddressOfFunctions, nt_headers, in_memory ) + module );
	  return rva_2_offset( addresses[ ordinals[ ordinal_index ] ], nt_headers, in_memory ) + module;
   }

   __forceinline bool verify_integrity( const char* path ) {
	  std::string source( path );
	  std::wstring file( source.begin( ), source.end( ) );

	  WINTRUST_FILE_INFO file_data;
	  memset( &file_data, 0, sizeof( file_data ) );
	  file_data.cbStruct = sizeof( WINTRUST_FILE_INFO );
	  file_data.pcwszFilePath = file.c_str( );
	  file_data.hFile = nullptr;
	  file_data.pgKnownSubject = nullptr;

	  GUID guid = WINTRUST_ACTION_GENERIC_VERIFY_V2;
	  WINTRUST_DATA wintrust;
	  memset( &wintrust, 0, sizeof( wintrust ) );

	  wintrust.cbStruct = sizeof( wintrust );
	  wintrust.pPolicyCallbackData = nullptr;
	  wintrust.pSIPClientData = nullptr;
	  wintrust.dwUIChoice = WTD_UI_NONE;
	  wintrust.fdwRevocationChecks = WTD_REVOKE_NONE;
	  wintrust.dwUnionChoice = WTD_CHOICE_FILE;
	  wintrust.dwStateAction = WTD_STATEACTION_VERIFY;
	  wintrust.hWVTStateData = nullptr;
	  wintrust.pwszURLReference = nullptr;
	  wintrust.dwUIContext = 0;
	  wintrust.pFile = &file_data;

	  const uint32_t status = WinVerifyTrust( nullptr, &guid, &wintrust );
	  wintrust.dwStateAction = WTD_STATEACTION_CLOSE;
	  WinVerifyTrust( nullptr, &guid, &wintrust );
	  return status == ERROR_SUCCESS;
   }

   __forceinline uint8_t* locate_wow64_transition( ) {
	  static uint8_t* wow64_transition;

	  if ( !wow64_transition )
		 wow64_transition = reinterpret_cast< uint8_t* >( get_proc_address(
		 get_module_handle( hash_32_fnv1a_const( XorStr( "win32u.dll" ) ) ), hash_32_fnv1a_const( XorStr(  "Wow64Transition" ) ) ) );

	  return wow64_transition;
   }

   __forceinline bool verify_call_integrity( const uint8_t* shell ) {
	  const auto jmp_pad_cmp = *reinterpret_cast< uint8_t * * >( &const_cast< uint8_t* >( shell )[ 6 ] );
	  const auto transition_cmp = *reinterpret_cast< uint8_t * * >( &jmp_pad_cmp[ 2 ] );

	  return transition_cmp == locate_wow64_transition( );
   }

   __forceinline syscall_fn extract_syscall( const uint32_t function ) {
	  syscall_fn fn = { };

	  if ( !verify_integrity( XorStr( "C:\\Windows\\SysWOW64\\ntdll.dll" ) ) )
		 return fn;

	  std::ifstream file( XorStr( "C:\\Windows\\SysWOW64\\ntdll.dll" ), std::ios::binary | std::ios::ate );
	  const std::streamsize size = static_cast< uint32_t >( file.tellg( ) );
	  file.seekg( 0, std::ios::beg );

	  std::vector<char> buffer( static_cast< uint32_t >( size ) );
	  if ( file.read( buffer.data( ), size ) ) {
		 const auto proc = get_proc_address( reinterpret_cast< uintptr_t >( buffer.data( ) ), function, true );
		 const auto id = *reinterpret_cast< uint32_t* >( proc + 1 );
		 const auto ret = *reinterpret_cast< uint16_t* >( proc + 0xD );
		 fn = { id, ret };
	  };

	  return fn;
   }

   template <uint32_t module, uint32_t function>
   __forceinline static void* import( ) {
	  static void* fn;

	  if ( !fn )
		 fn = reinterpret_cast< void* >( get_proc_address( get_module_handle( module ), function ) );

	  return fn;
   }

   #define _import(module, name) (reinterpret_cast<name>(SystemCall::import<hash_32_fnv1a_const(module), hash_32_fnv1a_const(#name)>()))

   __forceinline static uint8_t* allocate_proxy( ) {
	  static std::vector<uint8_t> pad =
	  {
			  0xFF, 0x25, 0x00, 0x00, 0x00, 0x00 // far jmp wow64_transition
	  };

	  static std::vector<uint8_t> sys =
	  {
			  0xB8, 0x00, 0x00, 0x00, 0x00, // mov eax, index
			  0xBA, 0x00, 0x00, 0x00, 0x00, // mov edx, wow64_jumppad
			  0xFF, 0xD2, // call wow64_transition
			  0xC2, 0x00, 0x00 // retn error_code
	  };

	  static uint8_t* proxy = nullptr;
	  static uint8_t* jmp_pad = nullptr;

	  if ( proxy )
		 return proxy;

	  // Allocate jumppad
	  auto size = pad.size( );
	  _import( "ntdll.dll" , NtAllocateVirtualMemory )( current_process, reinterpret_cast< PVOID* >( &jmp_pad ), nullptr,
													  &size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );

	  size = pad.size( );
	  *reinterpret_cast< uint32_t* >( &pad[ 2 ] ) = reinterpret_cast< uint32_t >( locate_wow64_transition( ) );
	  memcpy( jmp_pad, &pad[ 0 ], size );

	  // Allocate shellcode
	  uint8_t* sys_code = nullptr;
	  size = sys.size( );
	  _import( "ntdll.dll" , NtAllocateVirtualMemory )( current_process, reinterpret_cast< PVOID* >( &sys_code ), nullptr,
													  &size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );

	  size = sys.size( );
	  *reinterpret_cast< uint32_t* >( &sys[ 6 ] ) = reinterpret_cast< uint32_t >( jmp_pad );
	  memcpy( sys_code, &sys[ 0 ], size );
	  return proxy = sys_code;
   }

   /*
	* Not thread safe, make sure to implement a mutex in the future.
	* We need to make sure that two threads never override the shellcode at the same time.
	* Considering the fact these are native functions, the result might be catastrophic.
	*
	* This also only allows for immediate calls right now.
	*/
   template <uint32_t function>
   __forceinline static void* syscall( ) {
	  static auto proxy = allocate_proxy( );
	  static auto fn = extract_syscall( function );

	  if ( !verify_call_integrity( proxy ) )
		 return nullptr;

	  *reinterpret_cast< uint32_t* >( &proxy[ 1 ] ) = fn.index;
	  *reinterpret_cast< uint32_t* >( &proxy[ 0xD ] ) = fn.retn;

	  return proxy;
   }
}

#define syscall(name) (reinterpret_cast<name>(SystemCall::syscall<hash_32_fnv1a_const(#name)>()))
#define sys(name) (reinterpret_cast<decltype(&(name))>(SystemCall::syscall<hash_32_fnv1a_const(#name)>()))
```

`CSGO SDK/source.cpp`:

```cpp
#include "source.hpp"

#include "Hooking/Hooked.hpp"
#include "Utils/InputSys.hpp"

#include "SDK/Classes/PropManager.hpp"
#include "SDK/Displacement.hpp"

#include "SDK/Classes/Player.hpp"

#include "Features/Visuals/Glow.hpp"
#include "Features/Miscellaneous/GameEvent.hpp"

#include "Renderer/Render.hpp"
#include "Features/Miscellaneous/SkinChanger.hpp"
#include "Features/Miscellaneous/KitParser.hpp"

#include "Hooking/hooker.hpp"

#include "Features/Visuals/CChams.hpp"

#include "Features/Game/Prediction.hpp"

#include <fstream>

extern ClientClass* CCSPlayerClass;
extern CreateClientClassFn oCreateCCSPlayer;

#define CONCAT_IMPL( x, y ) x##y
#define MACRO_CONCAT( x, y ) CONCAT_IMPL( x, y )
#define PAD( size ) uint8_t MACRO_CONCAT( _pad, __COUNTER__ )[ size ];

//56 8D 51 3C BE
matrix3x4_t g_HeadBone;

using FnProcessInterpolatedList = void( __cdecl* )( );
FnProcessInterpolatedList oProcessInterpolatedList;
void __cdecl hkProcessInterpolatedList( ) {
	g_Vars.globals.szLastHookCalled = XorStr( "38" );
	**( bool** )( Engine::Displacement.Data.s_bAllowExtrapolation ) = false;
	oProcessInterpolatedList( );
}

using FnResetGetWaterContentsForPointCache = void( __thiscall* )( void* );
FnResetGetWaterContentsForPointCache oResetGetWaterContentsForPointCache;
void __fastcall hkResetGetWaterContentsForPointCache( void* ecx, void* edx ) {
	g_Vars.globals.szLastHookCalled = XorStr( "39" );
	if( !Engine::Prediction::Instance( )->InPrediction( ) )
		oResetGetWaterContentsForPointCache( ecx );

	return;
}

matrix3x4_t HeadBone;

using FnModifyEyePosition = void( __thiscall* )( C_CSPlayer*, Vector* );
FnModifyEyePosition oModifyEyePoisition;
void __fastcall hkModifyEyePosition( C_CSPlayer* ecx, void* edx, Vector* eye_position ) {
	g_Vars.globals.szLastHookCalled = XorStr( "40" );
	auto local_player = C_CSPlayer::GetLocalPlayer( );
	if( !local_player ) {
		oModifyEyePoisition( ecx, eye_position );
		return;
	}

	if( g_Vars.globals.m_bInCreateMove )
		oModifyEyePoisition( ecx, eye_position );

	return;
};

using FnAddBoxOverlay = void( __thiscall* )( void*, const Vector& origin, const Vector& mins, const Vector& max, QAngle const& orientation, int r, int g, int b, int a, float duration );
FnAddBoxOverlay oAddBoxOverlay;
void __fastcall hkAddBoxOverlay( void* ecx, void* edx, const Vector& origin, const Vector& mins, const Vector& max, QAngle const& orientation, int r, int g, int b, int a, float duration ) {
	g_Vars.globals.szLastHookCalled = XorStr( "41" );

	static uintptr_t fire_bulltes = 0;
	if( !fire_bulltes )
		fire_bulltes = Memory::Scan( XorStr( "client.dll" ), XorStr( "3B 3D ?? ?? ?? ?? 75 4C" ) );

	if( !g_Vars.misc.impacts_spoof || uintptr_t( _ReturnAddress( ) ) != fire_bulltes )
		return oAddBoxOverlay( ecx, origin, mins, max, orientation, r, g, b, a, duration );

	return oAddBoxOverlay( ecx, origin, mins, max, orientation,
		g_Vars.esp.client_impacts.r * 255, g_Vars.esp.client_impacts.g * 255, g_Vars.esp.client_impacts.b * 255, g_Vars.esp.client_impacts.a * 255,
		duration );
}

using FnFireEvents = void( __thiscall* )( void* );
FnFireEvents oFireEvents;
void __fastcall hkFireEvents( void* ecx, void* edx ) {
	g_Vars.globals.szLastHookCalled = XorStr( "42" );
	auto local = C_CSPlayer::GetLocalPlayer( );
	if( local && !local->IsDead( ) ) {
		// get this from CL_FireEvents string "Failed to execute event for classId" in engine.dll
		for( CEventInfo* it{ Interfaces::m_pClientState->m_pEvents( ) }; it != nullptr; it = it->m_next ) {
			if( !it->m_class_id )
				continue;

			// set all delays to instant.
			it->m_fire_delay = 0.f;
		}
	}

	oFireEvents( ecx );
}

using net_showfragments_t = bool( __thiscall* )( void* );
net_showfragments_t o_net_show_fragments;
bool __fastcall net_show_fragments( void* cvar, void* edx ) {
	g_Vars.globals.szLastHookCalled = XorStr( "43" );

	C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer( );

	if( !pLocal || pLocal->IsDead( ) )
		return o_net_show_fragments( cvar );

	if( !Interfaces::m_pEngine->IsInGame( )  )
		return o_net_show_fragments( cvar );

	auto netchannel = Encrypted_t<INetChannel>( Interfaces::m_pEngine->GetNetChannelInfo( ) );
	if( !netchannel.IsValid( ) )
		return o_net_show_fragments( cvar );

	static auto read_sub_channel_data_ret = reinterpret_cast< uintptr_t* >( Memory::Scan( "engine.dll", "85 C0 74 12 53 FF 75 0C 68 ? ? ? ? FF 15 ? ? ? ? 83 C4 0C" ) );
	static auto check_receiving_list_ret = reinterpret_cast< uintptr_t* >( Memory::Scan( "engine.dll", "8B 1D ? ? ? ? 85 C0 74 16 FF B6" ) );

	static uint32_t last_fragment = 0;

	if( _ReturnAddress( ) == reinterpret_cast< void* >( check_receiving_list_ret ) && last_fragment > 0 ) {
		const auto data = &reinterpret_cast< uint32_t* >( netchannel.Xor( ) )[ 0x56 ];
		const auto bytes_fragments = reinterpret_cast< uint32_t* >( data )[ 0x43 ];

		if( bytes_fragments == last_fragment ) {
			auto& buffer = reinterpret_cast< uint32_t* >( data )[ 0x42 ];
			buffer = 0;
		}
	}

	if( _ReturnAddress( ) == read_sub_channel_data_ret ) {
		const auto data = &reinterpret_cast< uint32_t* >( netchannel.Xor( ) )[ 0x56 ];
		const auto bytes_fragments = reinterpret_cast< uint32_t* >( data )[ 0x43 ];

		last_fragment = bytes_fragments;
	}

	return o_net_show_fragments( cvar );
}

struct MaterialSystemConfig_t {
	int m_Width;
	int m_Height;
	int m_Format;
	int m_RefreshRate;

	float m_fMonitorGamma;
	float m_fGammaTVRangeMin;
	float m_fGammaTVRangeMax;
	float m_fGammaTVExponent;
	bool m_bGammaTVEnabled;
	bool m_bTripleBuffered;
	int m_nAASamples;
	int m_nForceAnisotropicLevel;
	int m_nSkipMipLevels;
	int m_nDxSupportLevel;
	int m_nFlags;
	bool m_bEditMode;
	char m_nProxiesTestMode;
	bool m_bCompressedTextures;
	bool m_bFilterLightmaps;
	bool m_bFilterTextures;
	bool m_bReverseDepth;
	bool m_bBufferPrimitives;
	bool m_bDrawFlat;
	bool m_bMeasureFillRate;
	bool m_bVisualizeFillRate;
	bool m_bNoTransparency;
	bool m_bSoftwareLighting;
	bool m_bAllowCheats;
	char m_nShowMipLevels;
	bool m_bShowLowResImage;
	bool m_bShowNormalMap;
	bool m_bMipMapTextures;
	char m_nFullbright;
	bool m_bFastNoBump;
	bool m_bSuppressRendering;
	bool m_bDrawGray;
	bool m_bShowSpecular;
	bool m_bShowDiffuse;
	int m_nWindowedSizeLimitWidth;
	int m_nWindowedSizeLimitHeight;
	int m_nAAQuality;
	bool m_bShadowDepthTexture;
	bool m_bMotionBlur;
	bool m_bSupportFlashlight;
	bool m_bPaintEnabled;
	char pad[ 0xC ];
};


using FnTraceRay = void( __thiscall* )( void*, const Ray_t&, unsigned int, ITraceFilter*, CGameTrace* );
FnTraceRay oTraceRay;

// lol idk I have seen multiple people doing this xd
void __fastcall TraceRay( void* thisptr, void*, const Ray_t& ray, unsigned int fMask, ITraceFilter* pTraceFilter, CGameTrace* pTrace )
{
	if( !g_Vars.globals.m_InHBP )
		return oTraceRay( thisptr, ray, fMask, pTraceFilter, pTrace );

	oTraceRay( thisptr, ray, fMask, pTraceFilter, pTrace );

	pTrace->surface.flags |= SURF_SKY;
}


using FnOverrideConfig = bool( __thiscall* )( IMaterialSystem*, MaterialSystemConfig_t&, bool );
FnOverrideConfig oOverrideConfig;
bool __fastcall OverrideConfig( IMaterialSystem* ecx, void* edx, MaterialSystemConfig_t& config, bool bForceUpdate ) {
	g_Vars.globals.szLastHookCalled = XorStr( "44" );
	if( ecx == Interfaces::m_pMatSystem.Xor( ) && g_Vars.esp.fullbright ) {
		config.m_nFullbright = true;
	}

	return oOverrideConfig( ecx, config, bForceUpdate );
}

enum {
	NO_SCOPE_STATIC,
	NO_SCOPE_DYNAMIC
};

int no_scope_mode = NO_SCOPE_STATIC;

using FnDrawSetColor = void( __thiscall* )( void*, int, int, int, int );
FnDrawSetColor oDrawSetColor;
void __fastcall DrawSetColor( ISurface* thisptr, void* edx, int r, int g, int b, int a ) {
	g_Vars.globals.szLastHookCalled = XorStr( "45" );

	if( !g_Vars.esp.remove_scope ) {
		return oDrawSetColor( thisptr, r, g, b, a );
	}

	const auto return_address = uintptr_t( _ReturnAddress( ) );

	static auto return_to_scope_arc = Memory::Scan( XorStr( "client.dll" ), XorStr( "6A 00 FF 50 3C 8B 0D ? ? ? ? FF B7" ) ) + 5;
	static auto return_to_scope_lens = Memory::Scan( XorStr( "client.dll" ), XorStr( "FF 50 3C 8B 4C 24 20" ) ) + 3;

	static auto return_to_scope_lines_clear = Memory::Scan( XorStr( "client.dll" ), XorStr( "0F 82 ? ? ? ? FF 50 3C" ) ) + 0x9;
	static auto return_to_scope_lines_blurry = Memory::Scan( XorStr( "client.dll" ), XorStr( "FF B7 ? ? ? ? 8B 01 FF 90 ? ? ? ? 8B 4C 24 24" ) ) - 0x6;

	if( return_address == return_to_scope_arc
		|| return_address == return_to_scope_lens ) {
		// We don't want this to draw, so we set the alpha to 0
		return oDrawSetColor( thisptr, r, g, b, 0 );
	}


	if( g_Vars.esp.remove_scope_type == NO_SCOPE_DYNAMIC ||
		( return_address != return_to_scope_lines_clear &&
			return_address != return_to_scope_lines_blurry ) )
		return oDrawSetColor( thisptr, r, g, b, a );

	oDrawSetColor( thisptr, r, g, b, g_Vars.esp.remove_scope_blur ? 0 : a );
}

using FnProcessMovement = void( __thiscall* )( void*, int, uint8_t* );
FnProcessMovement oProcessMovement;
void __fastcall hkProcessMovement( void* pThis, void* edx, int player, uint8_t* moveData ) {
	g_Vars.globals.szLastHookCalled = XorStr( "46" );
	/*if ( !pThis || !edx )
	   return;*/

	*moveData &= 253u;
	oProcessMovement( pThis, player, moveData );
}


using FnDoExtraBonesProccesing = void( __thiscall* )( C_CSPlayer*, CStudioHdr*, Vector*, Quaternion*, matrix3x4_t*, void*, void* );
FnDoExtraBonesProccesing oDoExtraBonesProccesing;
void __fastcall DoExtraBonesProccesing( C_CSPlayer* ecx, void* edx, CStudioHdr* hdr, Vector* pos, Quaternion* rotations, matrix3x4_t* transforma, void* bone_list, void* ik_context ) {
	g_Vars.globals.szLastHookCalled = XorStr( "22" );

	const auto state = ecx->m_PlayerAnimState( );

	if( !state || !state->m_Player )
		return oDoExtraBonesProccesing( ecx, hdr, pos, rotations, transforma, bone_list, ik_context );

	const auto backup_tickcount = state->m_bOnGround;
	state->m_bOnGround = false;
	oDoExtraBonesProccesing( ecx, hdr, pos, rotations, transforma, bone_list, ik_context );
	state->m_bOnGround = backup_tickcount;
}

typedef void( __thiscall* fnBuildTransformations )( C_CSPlayer*, CStudioHdr*, Vector*, Quaternion*, const matrix3x4_t&, const int32_t, BYTE* );
fnBuildTransformations oBuildTransformations;
void __fastcall hkBuildTransformations( C_CSPlayer* pPlayer, uint32_t, CStudioHdr* hdr, Vector* pos, Quaternion* q, const matrix3x4_t& transform, const int32_t mask, BYTE* computed ) {
	C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer( );
	if( !pPlayer || !pLocal || !pPlayer->IsPlayer( ) || pPlayer->EntIndex( ) == pLocal->EntIndex( ) || !g_Vars.rage.enabled )
		return oBuildTransformations( pPlayer, hdr, pos, q, transform, mask, computed );

	// backup jiggle bones.
	const bool m_isJiggleBonesEnabledBackup = *( bool* )( uintptr_t( pPlayer ) + 0x292C );

	// overwrite jiggle bones and refuse the game from calling the
	// code responsible for animating our attachments/weapons.
	*( bool* )( uintptr_t( pPlayer ) + 0x292C ) = false;

	oBuildTransformations( pPlayer, hdr, pos, q, transform, mask, computed );

	// restore jiggle bones
	*( bool* )( uintptr_t( pPlayer ) + 0x292C ) = m_isJiggleBonesEnabledBackup;
}

typedef void( __thiscall* fnStandardBlendingRules )( void*, CStudioHdr*, Vector*, Quaternion*, float currentTime, int boneMask );
fnStandardBlendingRules oStandardBlendingRules;
void __fastcall hkStandardBlendingRules( C_CSPlayer* pPlayer, uint32_t, CStudioHdr* hdr, Vector* pos, Quaternion* q, float currentTime, int boneMask ) {
	C_CSPlayer* pLocal = C_CSPlayer::GetLocalPlayer( );
	if( !pPlayer || !pLocal || !pPlayer->IsPlayer( ) || pPlayer->EntIndex( ) == pLocal->EntIndex( ) ) {
		return oStandardBlendingRules( pPlayer, hdr, pos, q, currentTime, boneMask );;
	}

	//int newBoneMask = boneMask;
	//
	//if( pPlayer->EntIndex( ) != pLocal->EntIndex( ) && g_Vars.rage.enabled )
	//	newBoneMask = BONE_USED_BY_HITBOX;


	if( !( pPlayer->m_fEffects( ) & EF_NOINTERP ) )
		pPlayer->m_fEffects( ) |= EF_NOINTERP;

	oStandardBlendingRules( pPlayer, hdr, pos, q, currentTime, boneMask );

	if( pPlayer->m_fEffects( ) & EF_NOINTERP )
		pPlayer->m_fEffects( ) &= ~EF_NOINTERP;
}

typedef bool( __thiscall* fnIsRenderableInPvs )( void*, IClientRenderable* );
fnIsRenderableInPvs oIsRenderableInPvs;
bool __fastcall hkIsRenderableInPVS( void* ecx, void* edx, IClientRenderable* pRenderable ) {
	if( !ecx || !pRenderable )
		return oIsRenderableInPvs( ecx, pRenderable );

	auto player = reinterpret_cast< C_CSPlayer* >( reinterpret_cast< uintptr_t >( pRenderable ) - 0x4 );

	if( player ) {
		C_CSPlayer* local = C_CSPlayer::GetLocalPlayer( );
		if( local ) {
			if( !player->IsTeammate( local ) )
				return true;
		}
	}

	return oIsRenderableInPvs( ecx, pRenderable );
}

typedef bool( __thiscall* fnAddRenderable )( void*, IClientRenderable*, bool, RenderableTranslucencyType_t, RenderableModelType_t, uint32 );
fnAddRenderable oAddRenderable;
void __fastcall hkAddRenderable( void* ecx, void* edx, IClientRenderable* pRenderable, bool bRenderWithViewModels, RenderableTranslucencyType_t nType, RenderableModelType_t nModelType, uint32 nSplitscreenEnabled ) {
	RenderableTranslucencyType_t type = nType;

	if( uintptr_t( pRenderable ) != 0x4 && uintptr_t( ( pRenderable - 0x4 + 0x64 ) - 1 ) <= 0x3F )
		type = RenderableTranslucencyType_t::RENDERABLE_IS_TRANSLUCENT;

	oAddRenderable( ecx, pRenderable, bRenderWithViewModels, type, nModelType, nSplitscreenEnabled );
}

using PhysicsSimulateFn = void( __thiscall* ) ( void* ecx );
PhysicsSimulateFn oPhysicsSimulate;
void __fastcall hkPhysicsSimulate( void* ecx, void* edx ) {
	/*auto local = ( C_CSPlayer* )Interfaces::m_pEntList->GetClientEntity( Interfaces::m_pEngine->GetLocalPlayer( ) );
	if( !ecx || !local || local->IsDead( ) || local != ecx )
		return oPhysicsSimulate( ecx );

	int nSimulationTick = *( int* )( uintptr_t( ecx ) + 0x2AC );
	auto pCommandContext = ( C_CommandContext* )( uintptr_t( ecx ) + 0x34FC );

	if( !pCommandContext || Interfaces::m_pGlobalVars->tickcount == nSimulationTick || !pCommandContext->needsprocessing )
		return;

	if( pCommandContext->cmd.tick_count >= ( g_Vars.globals.m_pCmd->tick_count + int( 1 / Interfaces::m_pGlobalVars->interval_per_tick ) + g_Vars.sv_max_usercmd_future_ticks->GetInt( ) ) ) {
		nSimulationTick = Interfaces::m_pGlobalVars->tickcount;
		pCommandContext->needsprocessing = false;

		Engine::Prediction::Instance( )->StoreNetvarCompression( &pCommandContext->cmd );
	}
	else {
		Engine::Prediction::Instance( )->RestoreNetvarCompression( &pCommandContext->cmd );
		oPhysicsSimulate( ecx );
		Engine::Prediction::Instance( )->StoreNetvarCompression( &pCommandContext->cmd );
	}*/
}

typedef void( __thiscall* fnCalcViewBob ) ( C_BasePlayer*, Vector& );
fnCalcViewBob oCalcViewBob;
void __fastcall hkCalcViewBob( C_BasePlayer* player, void* edx, Vector& eyeOrigin ) {
	if( !g_Vars.esp.remove_bob )
		oCalcViewBob( player, eyeOrigin );
}


typedef bool( __thiscall* fnIsHltv )( IVEngineClient* );
fnIsHltv oIsHltv;
bool hkIsHltv( IVEngineClient* EngineClient, uint32_t ) {
	static const auto return_to_setup_velocity = Memory::Scan( XorStr( "client.dll" ), XorStr( "84 C0 75 38 8B 0D ? ? ? ? 8B 01 8B 80" ) );
	if( _ReturnAddress( ) == ( void* )return_to_setup_velocity && g_Vars.globals.m_bUpdatingAnimations && Interfaces::m_pEngine->IsInGame( ) )
		return true;

	return oIsHltv( EngineClient );
}

typedef void( __thiscall* fnUpdateClientSideAnimation )( C_CSPlayer* player );
fnUpdateClientSideAnimation oUpdateClientSideAnimation;
void __fastcall hkUpdateClientSideAnimation( C_CSPlayer* player, void* edx ) {
	if( !player || player->IsDead( ) )
		return oUpdateClientSideAnimation( player );

	if( g_Vars.globals.m_bUpdatingAnimations )
		oUpdateClientSideAnimation( player );
}

typedef void( __thiscall* fnVertexBufferLock )( void* ecx, int max_vertex_count, bool append, void* unk );
fnVertexBufferLock oVertexBufferLock;
void __fastcall hkVertexBufferLock( void* ecx, void* edx, int max_vertex_count, bool append, void* unk ) {
	oVertexBufferLock( ecx, std::min( 32767, max_vertex_count ), append, unk );
}

typedef float( __thiscall* fnGetFloat )( void* );
fnGetFloat oRainAlphaGetFloat;
float __fastcall hkRainAlphaGetFloat( void* ecx, void* edx ) {

	if( g_Vars.esp.weather ) {
		return g_Vars.esp.weather_alpha * 0.01f;
	}

	return oRainAlphaGetFloat( ecx );
}

typedef bool( __thiscall* fnGetBool )( void* );
fnGetBool oSvCheatsGetBool;
bool __fastcall sv_cheats_get_bool( void* pConVar, void* edx ) {
	static auto ret_ard = ( uintptr_t )Memory::Scan( "client.dll", "85 C0 75 30 38 86" );
	if( reinterpret_cast< uintptr_t >( _ReturnAddress( ) ) == ret_ard )
		return true;

	return oSvCheatsGetBool( pConVar );
}


namespace Interfaces
{
	Encrypted_t<IBaseClientDLL> m_pClient = nullptr;
	Encrypted_t<IClientEntityList> m_pEntList = nullptr;
	Encrypted_t<IGameMovement> m_pGameMovement = nullptr;
	Encrypted_t<IPrediction> m_pPrediction = nullptr;
	Encrypted_t<IMoveHelper> m_pMoveHelper = nullptr;
	Encrypted_t<IInput> m_pInput = nullptr;
	Encrypted_t<CGlobalVars>  m_pGlobalVars = nullptr;
	Encrypted_t<ISurface> m_pSurface = nullptr;
	Encrypted_t<IVEngineClient> m_pEngine = nullptr;
	Encrypted_t<IClientMode> m_pClientMode = nullptr;
	Encrypted_t<ICVar> m_pCvar = nullptr;
	Encrypted_t<IPanel> m_pPanel = nullptr;
	Encrypted_t<IGameEventManager> m_pGameEvent = nullptr;
	Encrypted_t<IVModelRender> m_pModelRender = nullptr;
	Encrypted_t<IMaterialSystem> m_pMatSystem = nullptr;
	Encrypted_t<ISteamClient> g_pSteamClient = nullptr;
	Encrypted_t<ISteamGameCoordinator> g_pSteamGameCoordinator = nullptr;
	Encrypted_t<ISteamMatchmaking> g_pSteamMatchmaking = nullptr;
	Encrypted_t<ISteamUser> g_pSteamUser = nullptr;
	Encrypted_t<ISteamFriends> g_pSteamFriends = nullptr;
	Encrypted_t<IPhysicsSurfaceProps> m_pPhysSurface = nullptr;
	Encrypted_t<IEngineTrace> m_pEngineTrace = nullptr;
	Encrypted_t<CGlowObjectManager> m_pGlowObjManager = nullptr;
	Encrypted_t<IVModelInfo> m_pModelInfo = nullptr;
	Encrypted_t<CClientState>  m_pClientState = nullptr;
	Encrypted_t<IVDebugOverlay> m_pDebugOverlay = nullptr;
	Encrypted_t<IEngineSound> m_pEngineSound = nullptr;
	Encrypted_t<IMemAlloc> m_pMemAlloc = nullptr;
	Encrypted_t<IViewRenderBeams> m_pRenderBeams = nullptr;
	Encrypted_t<ILocalize> m_pLocalize = nullptr;
	Encrypted_t<IStudioRender> m_pStudioRender = nullptr;
	Encrypted_t<CSPlayerResource*> m_pPlayerResource = nullptr;
	Encrypted_t<ICenterPrint> m_pCenterPrint = nullptr;
	Encrypted_t<IVRenderView> m_pRenderView = nullptr;
	Encrypted_t<IClientLeafSystem> m_pClientLeafSystem = nullptr;
	Encrypted_t<IMDLCache> m_pMDLCache = nullptr;
	Encrypted_t<IViewRender> m_pViewRender = nullptr;
	Encrypted_t<IInputSystem> m_pInputSystem = nullptr;
	Encrypted_t<INetGraphPanel> m_pNetGraphPanel = nullptr;
	Encrypted_t<CHud> m_pHud = nullptr;
	Encrypted_t<SFHudDeathNoticeAndBotStatus> g_pDeathNotices = nullptr;
	Encrypted_t<CNetworkStringTableContainer> g_pClientStringTableContainer = nullptr;

	WNDPROC oldWindowProc;
	HWND hWindow = nullptr;

	RecvPropHook::Shared m_pDidSmokeEffectSwap = nullptr;
	RecvPropHook::Shared m_pFlAbsYawSwap = nullptr;
	RecvPropHook::Shared m_pPlaybackRateSwap = nullptr;
	RecvPropHook::Shared m_bClientSideAnimationSwap = nullptr;

	void m_bDidSmokeEffect( CRecvProxyData* pData, void* pStruct, void* pOut ) {
		Interfaces::m_pDidSmokeEffectSwap->GetOriginalFunction( )( pData, pStruct, pOut );

		if( g_Vars.esp.remove_smoke )
			*( uintptr_t* )( ( uintptr_t )pOut ) = true;
	}

	bool Create( void* reserved ) {
		auto& pPropManager = Engine::PropManager::Instance( );

		m_pClient = ( IBaseClientDLL* )CreateInterface( XorStr( "client.dll" ), XorStr( "VClient018" ) );
		if( !m_pClient.IsValid( ) ) {
			return false;
		}
			
		g_pClientStringTableContainer = ( CNetworkStringTableContainer* )CreateInterface( XorStr( "engine.dll" ), XorStr( "VEngineClientStringTable001" ) );
		if( !g_pClientStringTableContainer.IsValid( ) ) {
			return false;
		}

		if( !pPropManager->Create( m_pClient.Xor( ) ) ) {
			return false;
		}

		m_pEntList = ( IClientEntityList* )CreateInterface( XorStr( "client.dll" ), XorStr( "VClientEntityList003" ) );
		if( !m_pEntList.IsValid( ) ) {
			return false;
		}

		m_pGameMovement = ( IGameMovement* )CreateInterface( XorStr( "client.dll" ), XorStr( "GameMovement001" ) );
		if( !m_pGameMovement.IsValid( ) ) {
			return false;
		}

		m_pPrediction = ( IPrediction* )CreateInterface( XorStr( "client.dll" ), XorStr( "VClientPrediction001" ) );
		if( !m_pPrediction.IsValid( ) ) {
			return false;
		}

		m_pInput = *reinterpret_cast< IInput** > ( ( *reinterpret_cast< uintptr_t** >( m_pClient.Xor( ) ) )[ 15 ] + 0x1 );
		if( !m_pInput.IsValid( ) ) {
			return false;
		}

		m_pGlobalVars = **reinterpret_cast< CGlobalVars*** > ( ( *reinterpret_cast< uintptr_t** > ( m_pClient.Xor( ) ) )[ 0 ] + 0x1B );
		if( !m_pGlobalVars.IsValid( ) ) {
			return false;
		}

		m_pEngine = ( IVEngineClient* )CreateInterface( XorStr( "engine.dll" ), XorStr( "VEngineClient014" ) );
		if( !m_pEngine.IsValid( ) ) {
			return false;
		}

		m_pPanel = ( IPanel* )CreateInterface( XorStr( "vgui2.dll" ), XorStr( "VGUI_Panel009" ) );
		if( !m_pPanel.IsValid( ) ) {
			return false;
		}

		m_pSurface = ( ISurface* )CreateInterface( XorStr( "vguimatsurface.dll" ), XorStr( "VGUI_Surface031" ) );
		if( !m_pSurface.IsValid( ) ) {
			return false;
		}

		m_pClientMode = **( IClientMode*** )( ( *( DWORD** )m_pClient.Xor( ) )[ 10 ] + 0x5 );
		if( !m_pClientMode.IsValid( ) ) {
			return false;
		}

		m_pCvar = ( ICVar* )CreateInterface( XorStr( "vstdlib.dll" ), XorStr( "VEngineCvar007" ) );
		if( !m_pCvar.IsValid( ) ) {
			return false;
		}

		m_pGameEvent = ( IGameEventManager* )CreateInterface( XorStr( "engine.dll" ), XorStr( "GAMEEVENTSMANAGER002" ) );
		if( !m_pGameEvent.IsValid( ) ) {
			return false;
		}

		m_pModelRender = ( IVModelRender* )CreateInterface( XorStr( "engine.dll" ), XorStr( "VEngineModel016" ) );
		if( !m_pModelRender.IsValid( ) ) {
			return false;
		}

		m_pMatSystem = ( IMaterialSystem* )CreateInterface( XorStr( "materialsystem.dll" ), XorStr( "VMaterialSystem080" ) );
		if( !m_pMatSystem.IsValid( ) ) {
			return false;
		}

		m_pPhysSurface = ( IPhysicsSurfaceProps* )CreateInterface( XorStr( "vphysics.dll" ), XorStr( "VPhysicsSurfaceProps001" ) );
		if( !m_pPhysSurface.IsValid( ) ) {
			return false;
		}

		m_pEngineTrace = ( IEngineTrace* )CreateInterface( XorStr( "engine.dll" ), XorStr( "EngineTraceClient004" ) );
		if( !m_pEngineTrace.IsValid( ) ) {
			return false;
		}

		if( !Engine::CreateDisplacement( reserved ) ) {
			return false;
		}

		m_pMoveHelper = ( IMoveHelper* )( Engine::Displacement.Data.m_uMoveHelper );
		if( !m_pMoveHelper.IsValid( ) ) {
			return false;
		}

		m_pGlowObjManager = ( CGlowObjectManager* )Engine::Displacement.Data.m_uGlowObjectManager;
		if( !m_pGlowObjManager.IsValid( ) ) {
			return false;
		}

		m_pModelInfo = ( IVModelInfo* )CreateInterface( XorStr( "engine.dll" ), XorStr( "VModelInfoClient004" ) );
		if( !m_pModelInfo.IsValid( ) ) {
			return false;
		}

		// A1 FC BC 58 10  mov eax, g_ClientState
		m_pClientState = Encrypted_t<CClientState>( **( CClientState*** )( ( *( std::uintptr_t** )m_pEngine.Xor( ) )[ 14 ] + 0x1 ) );
		if( !m_pClientState.IsValid( ) ) {
			return false;
		}

		m_pDebugOverlay = ( IVDebugOverlay* )CreateInterface( XorStr( "engine.dll" ), XorStr( "VDebugOverlay004" ) );
		if( !m_pDebugOverlay.IsValid( ) ) {
			return false;
		}

		m_pMemAlloc = *( IMemAlloc** )( GetProcAddress( GetModuleHandle( XorStr( "tier0.dll" ) ), XorStr( "g_pMemAlloc" ) ) );
		if( !m_pMemAlloc.IsValid( ) ) {
			return false;
		}

		m_pEngineSound = ( IEngineSound* )CreateInterface( XorStr( "engine.dll" ), XorStr( "IEngineSoundClient003" ) );
		if( !m_pEngineSound.IsValid( ) ) {
			return false;
		}

		m_pRenderBeams = *( IViewRenderBeams** )( Engine::Displacement.Data.m_uRenderBeams );
		if( !m_pRenderBeams.IsValid( ) ) {
			return false;
		}

		m_pLocalize = ( ILocalize* )CreateInterface( XorStr( "localize.dll" ), XorStr( "Localize_001" ) );
		if( !m_pLocalize.IsValid( ) ) {
			return false;
		}

		m_pStudioRender = ( IStudioRender* )CreateInterface( XorStr( "studiorender.dll" ), XorStr( "VStudioRender026" ) );
		if( !m_pStudioRender.IsValid( ) ) {
			return false;
		}

		m_pCenterPrint = *( ICenterPrint** )( Engine::Displacement.Data.m_uCenterPrint );
		if( !m_pCenterPrint.IsValid( ) ) {
			return false;
		}

		m_pRenderView = ( IVRenderView* )CreateInterface( XorStr( "engine.dll" ), XorStr( "VEngineRenderView014" ) );
		if( !m_pRenderView.IsValid( ) ) {
			return false;
		}

		m_pClientLeafSystem = ( IClientLeafSystem* )CreateInterface( XorStr( "client.dll" ), XorStr( "ClientLeafSystem002" ) );
		if( !m_pClientLeafSystem.IsValid( ) ) {
			return false;
		}

		m_pMDLCache = ( IMDLCache* )CreateInterface( XorStr( "datacache.dll" ), XorStr( "MDLCache004" ) );
		if( !m_pMDLCache.IsValid( ) ) {
			return false;
		}

		m_pInputSystem = ( IInputSystem* )CreateInterface( XorStr( "inputsystem.dll" ), XorStr( "InputSystemVersion001" ) );
		if( !m_pInputSystem.IsValid( ) ) {
			return false;
		}

		m_pViewRender = **( IViewRender*** )( Memory::Scan( XorStr( "client.dll" ), XorStr( "FF 50 4C 8B 06 8D 4D F4" ) ) - 6 );
		if( !m_pViewRender.IsValid( ) ) {
			return false;
		}

		auto D3DDevice9 = **( IDirect3DDevice9*** )Engine::Displacement.Data.m_D3DDevice;
		if( !D3DDevice9 )
			return false;

		m_pHud = *( CHud** )( Memory::Scan( XorStr( "client.dll" ), XorStr( "B9 ? ? ? ? E8 ? ? ? ? 8B 5D 08" ) ) + 1 );
		if( !m_pHud.IsValid( ) )
			return false;

		g_pDeathNotices = m_pHud->FindHudElement< SFHudDeathNoticeAndBotStatus* >( XorStr( "SFHudDeathNoticeAndBotStatus" ) );
		if( !g_pDeathNotices.IsValid( ) )
			return false;

		// pMethod
		D3DDEVICE_CREATION_PARAMETERS params;
		D3DDevice9->GetCreationParameters( &params );
		hWindow = params.hFocusWindow;

		if( !InputSys::Get( )->Initialize( D3DDevice9 ) ) {
			return false;
		}

		g_pSteamClient = ( ( ISteamClient * ( __cdecl* )( void ) )GetProcAddress( GetModuleHandleA( XorStr( "steam_api.dll" ) ), XorStr( "SteamClient" ) ) )( );
		HSteamUser hSteamUser = reinterpret_cast< HSteamUser( __cdecl* ) ( void ) >( GetProcAddress( GetModuleHandle( XorStr( "steam_api.dll" ) ), XorStr( "SteamAPI_GetHSteamUser" ) ) )( );
		HSteamPipe hSteamPipe = reinterpret_cast< HSteamPipe( __cdecl* ) ( void ) >( GetProcAddress( GetModuleHandle( XorStr( "steam_api.dll" ) ), XorStr( "SteamAPI_GetHSteamPipe" ) ) )( );
		g_pSteamGameCoordinator = ( ISteamGameCoordinator* )g_pSteamClient->GetISteamGenericInterface( hSteamUser, hSteamPipe, XorStr( "SteamGameCoordinator001" ) );

		Render::Engine::Initialise( );
		Render::DirectX::init( D3DDevice9 );

		GameEvent::Get( )->Register( );

		initialize_kits( );

		ISkinChanger::Get( )->Create( );

		for( auto clientclass = Interfaces::m_pClient->GetAllClasses( );
			clientclass != nullptr;
			clientclass = clientclass->m_pNext ) {
			if( !strcmp( clientclass->m_pNetworkName, XorStr( "CCSPlayer" ) ) ) {
				CCSPlayerClass = clientclass;
				oCreateCCSPlayer = ( CreateClientClassFn )clientclass->m_pCreateFn;

				clientclass->m_pCreateFn = Hooked::hkCreateCCSPlayer;
				break;
			}
		}

		if( Interfaces::m_pEngine->IsInGame( ) ) {
			for( int i = 1; i <= Interfaces::m_pGlobalVars->maxClients; ++i ) {
				auto entity = C_CSPlayer::GetPlayerByIndex( i );
				if( !entity || !entity->IsPlayer( ) )
					continue;

				auto& new_hook = Hooked::player_hooks[ i ];
				new_hook.clientHook.Create( entity );
				new_hook.renderableHook.Create( ( void* )( ( uintptr_t )entity + 0x4 ) );
				new_hook.networkableHook.Create( ( void* )( ( uintptr_t )entity + 0x8 ) );
				new_hook.SetHooks( );
			}
		}

		for( ClientClass* pClass = Interfaces::m_pClient->GetAllClasses( ); pClass; pClass = pClass->m_pNext ) {
			if( !strcmp( pClass->m_pNetworkName, XorStr( "CPlayerResource" ) ) ) {
				RecvTable* pClassTable = pClass->m_pRecvTable;

				for( int nIndex = 0; nIndex < pClassTable->m_nProps; nIndex++ ) {
					RecvProp* pProp = &pClassTable->m_pProps[ nIndex ];

					if( !pProp || strcmp( pProp->m_pVarName, XorStr( "m_iTeam" ) ) )
						continue;

					m_pPlayerResource = Encrypted_t<CSPlayerResource*>( *reinterpret_cast< CSPlayerResource*** >( std::uintptr_t( pProp->m_pDataTable->m_pProps->m_ProxyFn ) + 0x10 ) );
					break;
				}
				break;
			}
		}

		// init config system
		g_Vars.Create( );

		g_Vars.viewmodel_fov->fnChangeCallback.m_Size = 0;
		g_Vars.viewmodel_offset_x->fnChangeCallback.m_Size = 0;
		g_Vars.viewmodel_offset_y->fnChangeCallback.m_Size = 0;
		g_Vars.viewmodel_offset_z->fnChangeCallback.m_Size = 0;

		g_Vars.mat_ambient_light_r->fnChangeCallback.m_Size = 0;
		g_Vars.mat_ambient_light_g->fnChangeCallback.m_Size = 0;
		g_Vars.mat_ambient_light_b->fnChangeCallback.m_Size = 0;

		g_Vars.cl_extrapolate->SetValue( 0 );



		g_Vars.host_limitlocal->nFlags &= ~FCVAR_HIDDEN;
		g_Vars.host_limitlocal->nFlags &= ~FCVAR_CHEAT;
		g_Vars.host_limitlocal->nFlags &= ~FCVAR_DEVELOPMENTONLY;
		g_Vars.host_limitlocal->fnChangeCallback.m_Size = 0;
		g_Vars.host_limitlocal->SetValueInt(1);


		RecvProp* prop = nullptr;
		pPropManager->GetProp( XorStr( "DT_SmokeGrenadeProjectile" ), XorStr( "m_bDidSmokeEffect" ), &prop );
		m_pDidSmokeEffectSwap = std::make_shared<RecvPropHook>( prop, &Hooked::m_nSmokeEffectTickBegin );

		pPropManager->GetProp( XorStr( "DT_CSRagdoll" ), XorStr( "m_flAbsYaw" ), &prop );
		m_pFlAbsYawSwap = std::make_shared<RecvPropHook>( prop, &Hooked::RecvProxy_m_flAbsYaw );

		pPropManager->GetProp( XorStr( "DT_BaseAnimating" ), XorStr( "bClientSideAnimation" ), &prop );
		m_bClientSideAnimationSwap = std::make_shared<RecvPropHook>( prop, &Hooked::m_bClientSideAnimation );

		MH_Initialize( );

		using namespace Hooked;

		// kinda clean LOL;
		RunSimulationDetor.m_nAddress = Engine::Displacement.Function.m_RunSimulation;
		if( RunSimulationDetor.m_nAddress ) {
			if( !RunSimulationDetor.Hook( ) ) {
				return false;
			}
		}

		PredictionUpdateDetor.m_nAddress = Engine::Displacement.Function.m_PredictionUpdate;
		if( PredictionUpdateDetor.m_nAddress ) {
			if( !PredictionUpdateDetor.Hook( ) ) {
				return false;
			}
		}

		Hooked::CL_FireEvents = reinterpret_cast< Hooked::CL_FireEventsFn >( Memory::Scan( XorStr( "engine.dll" ), XorStr( "55 8B EC 83 EC 08 53 8B 1D ?? ?? ?? ?? 56 57 83 BB ?? ?? 00 00 06" ) ) );

		if( !Hooked::CL_FireEvents ) {
			MessageBoxA( NULL, XorStr( "error!" ), XorStr( "" ), NULL );
			return false;
		}

		oGetScreenAspectRatio = Hooked::HooksManager.HookVirtual<decltype( oGetScreenAspectRatio )>( m_pEngine.Xor( ), &Hooked::hkGetScreenAspectRatio, Index::EngineClient::GetScreenAspectRatio );
		oIsBoxVisible = Hooked::HooksManager.HookVirtual<decltype( oIsBoxVisible )>( m_pEngine.Xor( ), &Hooked::hkIsBoxVisible, 32 );

		oCreateMove = Hooked::HooksManager.HookVirtual<decltype( oCreateMove )>( m_pClientMode.Xor( ), &Hooked::CreateMove, Index::CClientModeShared::CreateMove );
		oDoPostScreenEffects = Hooked::HooksManager.HookVirtual<decltype( oDoPostScreenEffects )>( m_pClientMode.Xor( ), &Hooked::DoPostScreenEffects, Index::CClientModeShared::DoPostScreenSpaceEffects );
		oOverrideView = Hooked::HooksManager.HookVirtual<decltype( oOverrideView )>( m_pClientMode.Xor( ), &Hooked::OverrideView, Index::CClientModeShared::OverrideView );

		oFrameStageNotify = Hooked::HooksManager.HookVirtual<decltype( oFrameStageNotify )>( m_pClient.Xor( ), &Hooked::FrameStageNotify, Index::IBaseClientDLL::FrameStageNotify );

		oRunCommand = Hooked::HooksManager.HookVirtual<decltype( oRunCommand )>( m_pPrediction.Xor( ), &Hooked::RunCommand, Index::IPrediction::RunCommand );
		oDrawSetColor = Hooked::HooksManager.HookVirtual<decltype( oDrawSetColor )>( m_pSurface.Xor( ), &DrawSetColor, 60 / 4 );
		oPresent = Hooked::HooksManager.HookVirtual<decltype( oPresent )>( D3DDevice9, &Hooked::Present, Index::DirectX::Present );
		oReset = Hooked::HooksManager.HookVirtual<decltype( oReset )>( D3DDevice9, &Hooked::Reset, Index::DirectX::Reset );
		oLockCursor = Hooked::HooksManager.HookVirtual<decltype( oLockCursor )>( m_pSurface.Xor( ), &Hooked::LockCursor, Index::VguiSurface::LockCursor );
		oPaintTraverse = Hooked::HooksManager.HookVirtual<decltype( oPaintTraverse )>( m_pPanel.Xor( ), &Hooked::PaintTraverse, Index::IPanel::PaintTraverse );
		oOverrideConfig = Hooked::HooksManager.HookVirtual<decltype( oOverrideConfig )>( m_pMatSystem.Xor( ), &OverrideConfig, 21 );

		oListLeavesInBox = Hooked::HooksManager.HookVirtual<decltype( oListLeavesInBox )>( Interfaces::m_pEngine->GetBSPTreeQuery( ), &Hooked::ListLeavesInBox, Index::BSPTreeQuery::ListLeavesInBox );

		static auto calc_view_bob = Memory::Scan( XorStr( "client.dll" ), XorStr( "55 8B EC A1 ? ? ? ? 83 EC 10 56 8B F1 B9" ) );
		oCalcViewBob = Hooked::HooksManager.CreateHook<decltype( oCalcViewBob ) >( &hkCalcViewBob, ( void* )calc_view_bob );

		oDrawModelExecute = Hooked::HooksManager.HookVirtual<decltype( oDrawModelExecute )>( m_pModelRender.Xor( ), &Hooked::DrawModelExecute, Index::ModelDraw::DrawModelExecute );

		oAddBoxOverlay = Hooked::HooksManager.HookVirtual<decltype( oAddBoxOverlay )>( m_pDebugOverlay.Xor( ), &hkAddBoxOverlay, 1 );
		
		//sv_cheats_get_bool
		oSvCheatsGetBool = Hooked::HooksManager.HookVirtual<decltype( oSvCheatsGetBool )>( Interfaces::m_pCvar->FindVar("sv_cheats"), &sv_cheats_get_bool, 13 );

		oWriteUsercmdDeltaToBuffer = Hooked::HooksManager.HookVirtual<decltype( oWriteUsercmdDeltaToBuffer )>( m_pClient.Xor( ), &WriteUsercmdDeltaToBuffer, 24 );

		o_net_show_fragments = Hooked::HooksManager.HookVirtual<decltype( o_net_show_fragments )>( Interfaces::m_pCvar->FindVar("net_showfragments"), &net_show_fragments, 13 );

		auto meme = ( void* )( uintptr_t( m_pClientState.Xor( ) ) + 0x8 );
		oPacketStart = Hooked::HooksManager.HookVirtual<decltype( oPacketStart )>( meme, &Hooked::PacketStart, 5 );
		oPacketEnd = Hooked::HooksManager.HookVirtual<decltype( oPacketEnd )>( meme, &Hooked::PacketEnd, 6 );
		oProcessTempEntities = Hooked::HooksManager.HookVirtual<decltype( oProcessTempEntities )>( meme, &Hooked::ProcessTempEntities, 36 );

		auto rel32_resolve = [ ] ( uintptr_t ptr ) {
			auto offset = *( uintptr_t* )( ptr + 0x1 );
			return ( uintptr_t* )( ptr + 5 + offset );
		};

		auto soundservice = *( uintptr_t** )( Engine::Displacement.Data.m_SoundService + 1 );
		auto interpolate = Engine::Displacement.Data.m_InterpolateServerEntities;
		auto reset_contents_cache = Engine::Displacement.Data.m_ResetContentsCache;
		auto process_interpolated_list = Engine::Displacement.Data.m_ProcessInterpolatedList;
		auto reporthit = Memory::Scan( XorStr( "client.dll" ), XorStr( "55 8B EC 8B 55 08 83 EC 1C F6 42 1C 01" ) );

		oModifyEyePoisition = Hooked::HooksManager.CreateHook<decltype( oModifyEyePoisition ) >( &hkModifyEyePosition, ( void* )Engine::Displacement.Data.m_ModifyEyePos );

		//55 8B EC 83 E4 F0 B8 ? ? ? ? E8 ? ? ? ? 56 57 8B F9 89 7C 24 18
		oSendNetMsg = Hooked::HooksManager.CreateHook<decltype( oSendNetMsg ) >( &Hooked::SendNetMsg, ( void* )Engine::Displacement.Data.m_SendNetMsg );
		oSendDatagram = Hooked::HooksManager.CreateHook<decltype( oSendDatagram ) >( &Hooked::SendDatagram, ( void* )Engine::Displacement.Data.SendDatagram );
		oProcessPacket = Hooked::HooksManager.CreateHook<decltype( oProcessPacket ) >( &Hooked::ProcessPacket, ( void* )Engine::Displacement.Data.ProcessPacket );
		oInterpolateServerEntities = Hooked::HooksManager.CreateHook<decltype( oInterpolateServerEntities ) >( &Hooked::InterpolateServerEntities, ( void* )interpolate );
		oProcessInterpolatedList = Hooked::HooksManager.CreateHook<decltype( oProcessInterpolatedList ) >( &hkProcessInterpolatedList, ( void* )process_interpolated_list );
		oReportHit = Hooked::HooksManager.CreateHook<decltype( oReportHit ) >( &ReportHit, ( void* )reporthit );

		auto physics_simulate_adr = rel32_resolve( Memory::Scan( XorStr( "client.dll" ), XorStr( "E8 ? ? ? ? 80 BE ? ? ? ? ? 0F 84 ? ? ? ? 8B 06" ) ) );
		oPhysicsSimulate = Hooked::HooksManager.CreateHook<decltype( oPhysicsSimulate ) >( &hkPhysicsSimulate, ( void* )physics_simulate_adr );

		auto standard_blending_rules_adr = Memory::Scan( XorStr( "client.dll" ), XorStr( "55 8B EC 83 E4 F0 B8 ? ? ? ? E8 ? ? ? ? 56 8B 75 08 57 8B F9 85 F6" ) );
		oStandardBlendingRules = Hooked::HooksManager.CreateHook<decltype( oStandardBlendingRules ) >( &hkStandardBlendingRules, ( void* )standard_blending_rules_adr );

		auto build_transformations_adr = Memory::Scan( XorStr( "client.dll" ), XorStr( "55 8B EC 83 E4 F0 81 EC ? ? ? ? 56 57 8B F9 8B 0D ? ? ? ? 89 7C 24 1C" ) );
		oBuildTransformations = Hooked::HooksManager.CreateHook<decltype( oBuildTransformations ) >( &hkBuildTransformations, ( void* )build_transformations_adr );

		auto debp_adr = Memory::Scan( XorStr( "client.dll" ), XorStr( "55 8B EC 83 E4 F8 81 EC ?? ?? ?? ?? 53 56 8B F1 57 89 74 24 1C" ) );
		oDoExtraBonesProccesing = Hooked::HooksManager.CreateHook<decltype( oDoExtraBonesProccesing ) >( &DoExtraBonesProccesing, ( void* )debp_adr );

		oIsHltv = Hooked::HooksManager.HookVirtual<decltype( oIsHltv )>( m_pEngine.Xor( ), &hkIsHltv, Index::EngineClient::IsHltv );

		auto IsUsingStaticPropDebugModeAddr = rel32_resolve( Memory::Scan( XorStr( "engine.dll" ), XorStr( "E8 ?? ?? ?? ?? 84 C0 8B 45 08" ) ) );
		oIsUsingStaticPropDebugMode = Hooked::HooksManager.CreateHook<decltype( oIsUsingStaticPropDebugMode ) >( &IsUsingStaticPropDebugMode, ( void* )IsUsingStaticPropDebugModeAddr );

		static auto update_client_side_animation = Memory::Scan( XorStr( "client.dll" ), XorStr( "55 8B EC 51 56 8B F1 80 BE ? ? ? ? ? 74 36" ) );
		oUpdateClientSideAnimation = Hooked::HooksManager.CreateHook<decltype( oUpdateClientSideAnimation ) >( &hkUpdateClientSideAnimation, ( void* )update_client_side_animation );

		Hooked::HooksManager.Enable( );
		return true;
	}

	void Destroy( ) {
		Hooked::HooksManager.Restore( );

		CCSPlayerClass->m_pCreateFn = oCreateCCSPlayer;
		Hooked::player_hooks.clear( );

		GameEvent::Get( )->Shutdown( );
		GlowOutline::Get( )->Shutdown( );
		ISkinChanger::Get( )->Destroy( );
		InputSys::Get( )->Destroy( );

		MH_Uninitialize( );

		Interfaces::m_pInputSystem->EnableInput( true );
		Interfaces::m_pClientState->m_nDeltaTick( ) = -1;
	}

	void* CreateInterface(const std::string& image_name, const std::string& name) {
		auto image = GetModuleHandleA(image_name.c_str());
		if (!image)
			return nullptr;

		auto fn = (CreateInterfaceFn)(GetProcAddress(image, ("CreateInterface")));
		if (!fn)
			return nullptr;

		return fn(name.c_str(), nullptr);
	}
}
```

`CSGO SDK/source.hpp`:

```hpp
#pragma once

// little include hack
#include "SDK/Valve/UtlBuffer.hpp"
#include "SDK/Valve/UtlMemory.hpp"
#include "SDK/Valve/UtlVector.hpp"
#include "SDK/Classes/INetworkStringTable.h"

#include "SDK/sdk.hpp"
#include "SDK/Valve/recv_swap.hpp"
#include <windows.h>
#include <shlobj.h>

class IClientMode {
public:
   virtual ~IClientMode( ) { }
   virtual int ClientModeCSNormal( void* ) = 0;
   virtual void Init( ) = 0;
   virtual void InitViewport( ) = 0;
   virtual void Shutdown( ) = 0;
   virtual void Enable( ) = 0;
   virtual void Disable( ) = 0;
   virtual void Layout( ) = 0;
   virtual IPanel* GetViewport( ) = 0;
   virtual void* GetViewportAnimationController( ) = 0;
   virtual void ProcessInput( bool bActive ) = 0;
   virtual bool ShouldDrawDetailObjects( ) = 0;
   virtual bool ShouldDrawEntity( C_BaseEntity* pEnt ) = 0;
   virtual bool ShouldDrawLocalPlayer( C_BaseEntity* pPlayer ) = 0;
   virtual bool ShouldDrawParticles( ) = 0;
   virtual bool ShouldDrawFog( void ) = 0;
   virtual void OverrideView( CViewSetup* pSetup ) = 0;
   virtual int KeyInput( int down, int keynum, const char* pszCurrentBinding ) = 0;
   virtual void StartMessageMode( int iMessageModeType ) = 0;
   virtual IPanel* GetMessagePanel( ) = 0;
   virtual void OverrideMouseInput( float* x, float* y ) = 0;
   virtual bool CreateMove( float flInputSampleTime, void* usercmd ) = 0;
   virtual void LevelInit( const char* newmap ) = 0;
   virtual void LevelShutdown( void ) = 0;
};

namespace Interfaces
{
   extern Encrypted_t<IBaseClientDLL> m_pClient;
   extern Encrypted_t<IClientEntityList> m_pEntList;
   extern Encrypted_t<IGameMovement> m_pGameMovement;
   extern Encrypted_t<IPrediction> m_pPrediction;
   extern Encrypted_t<IMoveHelper> m_pMoveHelper;
   extern Encrypted_t<IInput> m_pInput;
   extern Encrypted_t< CGlobalVars >  m_pGlobalVars;
   extern Encrypted_t<ISurface> m_pSurface;
   extern Encrypted_t<IVEngineClient> m_pEngine;
   extern Encrypted_t<IClientMode> m_pClientMode;
   extern Encrypted_t<ICVar> m_pCvar;
   extern Encrypted_t<IPanel> m_pPanel;
   extern Encrypted_t<IGameEventManager> m_pGameEvent;
   extern Encrypted_t<IVModelRender> m_pModelRender;
   extern Encrypted_t<IMaterialSystem> m_pMatSystem;
   extern Encrypted_t<ISteamClient> g_pSteamClient;
   extern Encrypted_t<ISteamGameCoordinator> g_pSteamGameCoordinator;
   extern Encrypted_t<ISteamMatchmaking> g_pSteamMatchmaking;
   extern Encrypted_t<ISteamUser> g_pSteamUser;
   extern Encrypted_t<ISteamFriends> g_pSteamFriends;
   extern Encrypted_t<IPhysicsSurfaceProps> m_pPhysSurface;
   extern Encrypted_t<IEngineTrace> m_pEngineTrace;
   extern Encrypted_t<CGlowObjectManager> m_pGlowObjManager;
   extern Encrypted_t<IVModelInfo> m_pModelInfo;
   extern Encrypted_t< CClientState >  m_pClientState;
   extern Encrypted_t<IVDebugOverlay> m_pDebugOverlay;
   extern Encrypted_t<IEngineSound> m_pEngineSound;
   extern Encrypted_t<IMemAlloc> m_pMemAlloc;
   extern Encrypted_t<IViewRenderBeams> m_pRenderBeams;
   extern Encrypted_t<ILocalize> m_pLocalize;
   extern Encrypted_t<IStudioRender> m_pStudioRender;
   extern Encrypted_t<CSPlayerResource*>  m_pPlayerResource;
   extern Encrypted_t<ICenterPrint> m_pCenterPrint;
   extern Encrypted_t<IVRenderView> m_pRenderView;
   extern Encrypted_t<IClientLeafSystem> m_pClientLeafSystem;
   extern Encrypted_t<IMDLCache> m_pMDLCache;
   extern Encrypted_t<IViewRender> m_pViewRender;
   extern Encrypted_t<IInputSystem> m_pInputSystem;
   extern Encrypted_t<INetGraphPanel> m_pNetGraphPanel;
   extern Encrypted_t<CHud> m_pHud;
   extern Encrypted_t<SFHudDeathNoticeAndBotStatus> g_pDeathNotices;
   extern Encrypted_t<CNetworkStringTableContainer> g_pClientStringTableContainer;
   extern WNDPROC oldWindowProc;
   extern HWND hWindow;

   // netvar proxies
   extern RecvPropHook::Shared m_pDidSmokeEffectSwap;
   extern RecvPropHook::Shared m_pFlAbsYawSwap;
   extern RecvPropHook::Shared m_pPlaybackRateSwap;
   extern RecvPropHook::Shared m_bClientSideAnimationSwap;

   bool Create( void* reserved );
   void Destroy( );

   void* CreateInterface( const std::string& image_name, const std::string& name );

}

__forceinline std::string GetDocumentsDirectory( ) {
    char my_documents[ MAX_PATH ];
    HRESULT result = SHGetFolderPath( NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, my_documents );

    return std::string( my_documents );
}
```

`README.md`:

```md
**Injecting**

Set your game to windowed fullscreen or you will crash.

**Configs are located in the csgo folder**

-----------------------------------------

**Building from source**

You need to download the DirectX SDK from June 2010: https://www.microsoft.com/en-ca/download/confirmation.aspx?id=6812

Also need to install VS2019 and VS2017 build tools.

Use these settings when opening the solution (an older SDK version will work also).
![image](https://user-images.githubusercontent.com/45910586/196135348-893f8494-66df-4467-ad1b-127a2fa042cd.png)

```