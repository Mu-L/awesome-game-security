Project Path: arc_gmh5225_Mhyprot2DrvControl_58i68hne

Source Tree:

```txt
arc_gmh5225_Mhyprot2DrvControl_58i68hne
├── App.config
├── Driver
│   ├── DrvLoader.cs
│   └── MhyProt2.cs
├── LICENSE
├── MhyProt2Drv.csproj
├── MhyProt2Drv.sln
├── Program.cs
├── Properties
│   └── AssemblyInfo.cs
├── README.md
├── Utils
│   ├── MT64.cs
│   ├── Memory.cs
│   └── NTAPI.cs
├── demo.png
├── killprocessdemo.gif
└── mhyprot2.Sys

```

`App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
    </startup>
</configuration>
```

`Driver/DrvLoader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace MhyProt2Drv.Driver
{
    public class DrvLoader
    {
        private const string DriverDisplayName = "mhyprot2";
        private string DriverFileName = Environment.GetEnvironmentVariable("TEMP") + "\\mhyprot2.Sys";

        private IntPtr g_ServiceHandle;

        public void CopyFiles()
        {
            string currentDir = Environment.CurrentDirectory;
            string loader = System.IO.Path.Combine(currentDir, "mhyprot2.sys");
            try
            {
                System.IO.File.Copy(loader, DriverFileName, true);
            }
            catch (Exception)
            {
                Console.WriteLine($"[!] 无法复制文件到temp文件夹");
            }
        }
        public bool Load()
        {
            CopyFiles();
            IntPtr serviceHandle;
            if (ServiceHelper.OpenService(out serviceHandle, DriverDisplayName, 0x0020/*SERVICE_STOP*/ | 0x00010000/*DELETE*/))
            {
                //Console.WriteLine($"[!] Service already running");

                if (!ServiceHelper.StopService(serviceHandle))
                    //Console.WriteLine($"[!] Couldn't stop service");
                    Console.WriteLine($"[!] 无法停止服务");

                if (!ServiceHelper.DeleteService(serviceHandle))
                    Console.WriteLine($"[!] 无法删除服务");

                ServiceHelper.CloseServiceHandle(serviceHandle);
                return Load();
            }
            Console.WriteLine($"[+] 加载mhyprot2...");
            if (!ServiceHelper.CreateService(
                ref g_ServiceHandle,
                DriverDisplayName, DriverDisplayName,
                DriverFileName,
                (uint)NTAPI.SERVICE_ACCESS.SERVICE_ALL_ACCESS, 1/*SERVICE_KERNEL_DRIVER*/,
                (uint)NTAPI.SERVICE_START.SERVICE_DEMAND_START, 1/*SERVICE_ERROR_NORMAL*/))
            {
                Console.WriteLine($"[!] 无法为mhyprot2创建服务 - {Marshal.GetLastWin32Error():X}");
                return false;
            }
            if (!ServiceHelper.StartService(g_ServiceHandle))
            {
                int errorno = Marshal.GetLastWin32Error();
                if (errorno != 31)
                {
                    Console.WriteLine($"[!] 无法为mhyprot2启动服务 - {errorno:X}");
                    ServiceHelper.DeleteService(g_ServiceHandle);
                    return false;
                }
            }
            Console.WriteLine($"[+] mhyprot2成功启动");
            return true;
        }

        public bool UnLoad()
        {
            if (!ServiceHelper.StopService(g_ServiceHandle))
            {
                Console.WriteLine($"[!] 无法停止mhyprot2服务");
                return false;
            }
            if (!ServiceHelper.DeleteService(g_ServiceHandle))
            {
                Console.WriteLine($"[!] 无法删除mhyprot2服务");
                return false;
            }
            ServiceHelper.CloseServiceHandle(g_ServiceHandle);
            Console.WriteLine($"[+] 已卸载mhyprot2驱动");
            return true;
        }
    }
    public static class ServiceHelper
    {
        public static bool CreateService(
            ref IntPtr hService,
            string ServiceName,
            string DisplayName,
            string BinPath,
            uint DesiredAccess,
            uint ServiceType,
            uint StartType,
            uint ErrorControl)
        {
            IntPtr hSCManager = NTAPI.OpenSCManager(0, 0, 0x0002/*SC_MANAGER_CREATE_SERVICE*/);

            if (hSCManager == IntPtr.Zero)
                return false;

            hService = NTAPI.CreateServiceW(
                hSCManager,
                ServiceName, DisplayName,
                DesiredAccess,
                ServiceType, StartType,
                ErrorControl, BinPath,
                0, 0, 0, 0, 0, 0);

            NTAPI.CloseServiceHandle(hSCManager);

            return hService != IntPtr.Zero;
        }
        public static bool OpenService(out IntPtr hService, string szServiceName, uint DesiredAccess)
        {
            IntPtr hSCManager = NTAPI.OpenSCManager(0, 0, DesiredAccess);
            hService = NTAPI.OpenService(hSCManager, szServiceName, DesiredAccess);
            NTAPI.CloseServiceHandle(hSCManager);
            return hService != IntPtr.Zero;
        }
        public static bool StopService(IntPtr hService)
        {
            NTAPI.SERVICE_STATUS ServiceStatus = new NTAPI.SERVICE_STATUS();
            return NTAPI.ControlService(hService, NTAPI.SERVICE_CONTROL.STOP, ref ServiceStatus);
        }

        public static bool StartService(IntPtr hService) => NTAPI.StartService(hService, 0, null);
        public static bool DeleteService(IntPtr hService) => NTAPI.DeleteService(hService);
        public static void CloseServiceHandle(IntPtr hService) => NTAPI.CloseServiceHandle(hService);

        /// <summary>
        /// Native functions :)
        /// </summary>
    }
}

```

`Driver/MhyProt2.cs`:

```cs
using MhyProt2Drv.Utils;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace MhyProt2Drv.Driver
{
    public enum MhyProt2Ctl : uint
    {
        DrvInit = 0x80034000,
        Mdl = 0x81004000,
        HeartBeat = 0x81014000,
        HeartBeat2 = 0x80024000,
        RWMemory = 0x81074000,
        EnumProcessList = 0x83014000,
        ListProcessModule = 0x81054000,
        Unk1 = 0x82004000,
        EnumDrivers = 0x82024000,
        KillProcess = 0x81034000
    }
    public struct RWMemory
    {
        public uint mode;
        public uint padding1;
        public uint TargetProcessID;
        public uint padding2;
        public IntPtr TargetProcessAddress;
        public IntPtr SourceProcessAddress;
        public uint BufferSize;
        public uint padding3;
    }

    public struct EnumDriver
    {
        public uint status;
        public uint count;
        public IntPtr Addr1;
        public IntPtr Addr2;
        public IntPtr Addr3;
    }
    public struct EnumProcess
    {
        public uint mode;
        public uint maxnum;
    }
    public struct EnumModule
    {
        public uint pid;
        public uint maxnum;
    }
    //680
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 1)]
    public struct MhyProtProcessList
    {
        public uint PID;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
        public string ProcessName;
        private uint Padding1;
        public IntPtr EProcess;
        public IntPtr Padding2;
        public uint Is64Bit;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 132)]
        private byte[] Padding3;
    }
    //792
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 1)]
    public struct MhyProtEnumModule
    {
        public IntPtr BaseAddress;
        public uint SizeOfImage;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
        public string ModuleName;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
        public string ModulePath;
        public uint Padding2;
    }
    public unsafe class MhyProt2
    {
        private IntPtr drvHandle = IntPtr.Zero;
        public ulong seed;
        public ulong pid;
        private static MT64 m = new MT64();
        public bool isInit = false;
        private static ulong mt64res;
        private const string DriverDeviceName = "\\Device\\mhyprot2";
        public void OpenDrv()
        {
            NTAPI.OBJECT_ATTRIBUTES objectAttributes = new NTAPI.OBJECT_ATTRIBUTES();
            NTAPI.UNICODE_STRING deviceName = new NTAPI.UNICODE_STRING(DriverDeviceName);
            NTAPI.IO_STATUS_BLOCK ioStatus;
            objectAttributes.Length = Marshal.SizeOf(typeof(NTAPI.OBJECT_ATTRIBUTES));
            objectAttributes.ObjectName = new IntPtr(&deviceName);

            uint status = 0;
            IntPtr deviceHandle;

            do
            {
                status = NTAPI.NtOpenFile(
                    &deviceHandle,
                    (uint)(NTAPI.ACCESS_MASK.GENERIC_READ | NTAPI.ACCESS_MASK.GENERIC_WRITE | NTAPI.ACCESS_MASK.SYNCHRONIZE),
                    &objectAttributes, &ioStatus, 0, 3/*OPEN_EXISTING*/);

                if (status != 0/*NT_SUCCESS*/)
                {
                    //Console.WriteLine($"[!] NtOpenFile failed! - {status:X}");
                    Console.WriteLine($"[!] Error @ NOF - {status:X}");
                    Thread.Sleep(250);
                }

            } while (status != 0/*NT_SUCCESS*/);

            drvHandle = deviceHandle;
            Console.WriteLine($"[+] hDevice: {drvHandle:X2}");
        }

        public bool InitDrv(ulong pid)
        {
            if (drvHandle == IntPtr.Zero) throw new Exception("[!] Driver handle has not been opened");
            ulong seed = 0x233333333333;
            byte[] initdata = GenInitData(pid, seed);
            IntPtr lpinBuffer = ByteToPtr(initdata);
            IntPtr ret = Marshal.AllocHGlobal(8);
            ulong outlen = 0;
            bool res = NTAPI.DeviceIoControl(drvHandle, (uint)MhyProt2Ctl.DrvInit, lpinBuffer, (uint)initdata.Length, ret, 8, &outlen, 0);
            if (!res) return res;
            ulong retmt64 = Marshal.PtrToStructure<ulong>(ret);
            return retmt64 == mt64res;
        }

        public List<MhyProtEnumModule> EnumProcessModule(uint pid)
        {
            EnumModule req = new EnumModule();
            req.pid = pid;
            req.maxnum = 300;
            byte[] reqdata = MhyEnCrypt(StructureToByte(req), 0x233333333333);
            IntPtr lpinBuffer = ByteToPtr(reqdata);
            IntPtr ret = Marshal.AllocHGlobal(301*792);
            ulong outlen = 0;
            bool res = NTAPI.DeviceIoControl(drvHandle, (uint)MhyProt2Ctl.ListProcessModule, lpinBuffer, (uint)reqdata.Length, ret, 301 * 792, &outlen, 0);
            if (!res) throw new Exception("EnumProcessModule failed on pid: " + pid.ToString());
            byte[] retdata = MhyCrypt(PtrToByte(ret, (uint)outlen));
            uint count = BitConverter.ToUInt32(retdata, 0);
            Console.WriteLine("Count: " + count.ToString());
            List<MhyProtEnumModule> modules = new List<MhyProtEnumModule>();
            for(int i = 0; i < count; i++)
            {
                byte[] singlemodule = new byte[792];
                Array.Copy(retdata, 4 + (i * 792), singlemodule, 0, 792);
                modules.Add(ByteToStructure<MhyProtEnumModule>(singlemodule));
            }
            return modules;
        }

        public uint RWMemory(uint mode, uint pid, IntPtr targetaddr, IntPtr sourceaddr, uint buffersize)
        {
            //mode = 0 : source=selected pid, target=self
            //mode = 1 : source=self, target=selected pid
            RWMemory req = new RWMemory();
            req.mode = mode;
            req.TargetProcessID = pid;
            req.TargetProcessAddress = targetaddr;
            req.SourceProcessAddress = sourceaddr;
            req.BufferSize = buffersize;
            //req.padding3 = 0x7ffb;
            byte[] reqdata = MhyEnCrypt(StructureToByte(req), 0x233333333333);
            IntPtr lpinBuffer = ByteToPtr(reqdata);
            IntPtr ret = Marshal.AllocHGlobal(12);
            ulong outlen = 0;
            bool res = NTAPI.DeviceIoControl(drvHandle, (uint)MhyProt2Ctl.RWMemory, lpinBuffer, (uint)reqdata.Length, ret, 12, &outlen, 0);
            if (!res) throw new Exception("RWMemory failed on pid: " + pid.ToString());
            byte[] retdata = MhyCrypt(PtrToByte(ret, (uint)outlen));
            return BitConverter.ToUInt32(retdata, 0);
        }

        public bool KillProcess(uint pid)
        {
            byte[] reqdata = MhyEnCrypt(BitConverter.GetBytes(pid), 0x233333333333);
            IntPtr lpinBuffer = ByteToPtr(reqdata);
            IntPtr ret = Marshal.AllocHGlobal(12);
            ulong outlen = 0;
            bool res = NTAPI.DeviceIoControl(drvHandle, (uint)MhyProt2Ctl.KillProcess, lpinBuffer, (uint)reqdata.Length, ret, 12, &outlen, 0);
            if (!res) throw new Exception("KillProcess failed on pid: " + pid.ToString());
            byte[] retdata = MhyCrypt(PtrToByte(ret, (uint)outlen));
            return BitConverter.ToUInt32(retdata, 0) == 0;
        }
        private void InitMt64()
        {
            m.rand_mt64_init(seed);
            int i = 7;
            do
            {
                mt64res = m.rand_mt64_get();
                //Console.WriteLine("MT64: " + mt64res.ToString("x2"));
            } while ((--i) != 0);
            isInit = true;
        }
        public byte[] GenInitData(ulong pid, ulong seed)
        {
            byte[] data = new byte[0x10];
            ulong PidData = 0xBAEBAEEC00000000 + pid;
            ulong LOW = seed ^ 0xEBBAAEF4FFF89042;
            ulong HIGH = seed ^ PidData;
            Array.Copy(BitConverter.GetBytes(HIGH), 0, data, 0, 8);
            Array.Copy(BitConverter.GetBytes(LOW), 0, data, 8, 8);
            this.seed = seed;
            InitMt64();
            return data;
        }

        public byte[] MhyEnCrypt(byte[] data, ulong ts)
        {
            m.mt.index = 0;
            m.mt.decodeKey = ts;
            byte[] endata = MT64Cryptor(data);
            byte[] ret = new byte[endata.Length + 8];
            Array.Copy(BitConverter.GetBytes(ts), ret, 8);
            Array.Copy(endata, 0, ret, 8, endata.Length);
            return ret;
        }
        public byte[] MhyCrypt(byte[] data)
        {
            ulong ts = BitConverter.ToUInt64(data, 0);
            byte[] endata = new byte[data.Length - 8];
            Array.Copy(data, 8, endata, 0, data.Length - 8);
            m.mt.index = 0;
            m.mt.decodeKey = ts;
            return MT64Cryptor(endata);
        }

        public byte[] MT64Cryptor(byte[] data)
        {
            byte[] ret = new byte[data.Length];
            int EncryptRound = data.Length >> 3;
            int i = 0;
            if (EncryptRound > 0)
            {
                ulong offset = 0;
                do
                {
                    ulong randNum = m.rand_mt64_get();
                    ulong v14 = m.mt.decodeKey + offset;
                    offset += 16;
                    ulong thisdata = BitConverter.ToUInt64(data, (i * 8));
                    ulong outdata = v14 ^ randNum ^ thisdata;
                    Array.Copy(BitConverter.GetBytes(outdata), 0, ret, (i * 8), 8);
                    m.mt.index %= 312;
                    ++i;
                } while (i < EncryptRound);
                return ret;
            }
            else
            {
                return data;
            }
        }

        /// <summary>
        /// 由结构体转换为byte数组
        /// </summary>
        public static byte[] StructureToByte<T>(T structure)
        {
            int size = Marshal.SizeOf(typeof(T));
            byte[] buffer = new byte[size];
            IntPtr bufferIntPtr = Marshal.AllocHGlobal(size);
            try
            {
                Marshal.StructureToPtr(structure, bufferIntPtr, true);
                Marshal.Copy(bufferIntPtr, buffer, 0, size);
            }
            finally
            {
                Marshal.FreeHGlobal(bufferIntPtr);
            }
            return buffer;
        }

        /// <summary>
        /// 由byte数组转换为结构体
        /// </summary>
        public static T ByteToStructure<T>(byte[] dataBuffer)
        {
            object structure = null;
            int size = Marshal.SizeOf(typeof(T));
            IntPtr allocIntPtr = Marshal.AllocHGlobal(size);
            try
            {
                Marshal.Copy(dataBuffer, 0, allocIntPtr, size);
                structure = Marshal.PtrToStructure(allocIntPtr, typeof(T));
            }
            finally
            {
                Marshal.FreeHGlobal(allocIntPtr);
            }
            return (T)structure;
        }
        public byte[] PtrToByte(IntPtr ptr, uint length)
        {
            byte[] b = new byte[length];
            Marshal.Copy(ptr, b, 0, (int)length);
            Marshal.FreeHGlobal(ptr);
            return b;
        }
        public IntPtr ByteToPtr(byte[] data)
        {
            IntPtr ptr = Marshal.AllocHGlobal(data.Length);
            Marshal.Copy(data, 0, ptr, data.Length);
            return ptr;
        }
        public bool CloseHandle()
        {
            return NTAPI.CloseHandle(drvHandle);
        }
    }
}

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 神楽坂早苗

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`MhyProt2Drv.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{BD96A5E8-6C92-438B-8C85-B2A368273405}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <RootNamespace>MhyProt2Drv</RootNamespace>
    <AssemblyName>MhyProt2Drv</AssemblyName>
    <TargetFrameworkVersion>v4.7.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Driver\DrvLoader.cs" />
    <Compile Include="Driver\MhyProt2.cs" />
    <Compile Include="Utils\Memory.cs" />
    <Compile Include="Utils\MT64.cs" />
    <Compile Include="Utils\NTAPI.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`MhyProt2Drv.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30413.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MhyProt2Drv", "MhyProt2Drv.csproj", "{BD96A5E8-6C92-438B-8C85-B2A368273405}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BD96A5E8-6C92-438B-8C85-B2A368273405}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BD96A5E8-6C92-438B-8C85-B2A368273405}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BD96A5E8-6C92-438B-8C85-B2A368273405}.Debug|x64.ActiveCfg = Debug|x64
		{BD96A5E8-6C92-438B-8C85-B2A368273405}.Debug|x64.Build.0 = Debug|x64
		{BD96A5E8-6C92-438B-8C85-B2A368273405}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BD96A5E8-6C92-438B-8C85-B2A368273405}.Release|Any CPU.Build.0 = Release|Any CPU
		{BD96A5E8-6C92-438B-8C85-B2A368273405}.Release|x64.ActiveCfg = Release|x64
		{BD96A5E8-6C92-438B-8C85-B2A368273405}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {204CBBAA-4ED0-4E95-8D73-F79B624CB722}
	EndGlobalSection
EndGlobal

```

`Program.cs`:

```cs
using MhyProt2Drv.Driver;
using MhyProt2Drv.Utils;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace MhyProt2Drv
{
    class Program
    {
        static void Main(string[] args)
        {
            DrvLoader loader = new DrvLoader();
            loader.Load();
            MhyProt2 mhyprot = new MhyProt2();
            mhyprot.OpenDrv();
            bool res = mhyprot.InitDrv((ulong)Process.GetCurrentProcess().Id);
            if (!res)
            {
                Console.WriteLine("Init Error!");
            }
            else
            {
                Console.WriteLine("Enuming module of csrss.exe");
                uint pid = (uint)Process.GetProcessesByName("csrss")[0].Id;
                List<MhyProtEnumModule> m = mhyprot.EnumProcessModule(pid);
                IntPtr baseAddr = IntPtr.Zero;
                foreach(MhyProtEnumModule sm in m)
                {
                    Console.WriteLine("ModuleName: " + sm.ModuleName + " ModulePath:" + sm.ModulePath + " BaseAddress:0x" + sm.BaseAddress.ToString("x2") + " Size:0x" + sm.SizeOfImage.ToString("x2"));
                    if (sm.ModuleName == "csrss.exe") baseAddr = sm.BaseAddress;
                }
                Memory mem = new Memory(mhyprot, pid);
                long currentTicks = DateTime.Now.Ticks;
                Console.WriteLine("Reading memory of csrss.exe");
                for (int i = 0; i < 1000; i++)
                {
                    mem.Read(baseAddr, 1024);
                }
                Console.WriteLine("Read memory 1000 times tooks total " + ((DateTime.Now.Ticks - currentTicks) / 10000).ToString() + "ms");
            }

            Console.ReadKey();
            mhyprot.CloseHandle();
            loader.UnLoad();
        }
    }
}

```

`Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 有关程序集的一般信息由以下
// 控制。更改这些特性值可修改
// 与程序集关联的信息。
[assembly: AssemblyTitle("MhyProt2Drv")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("MhyProt2Drv")]
[assembly: AssemblyCopyright("Copyright ©  2020")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// 将 ComVisible 设置为 false 会使此程序集中的类型
//对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型
//请将此类型的 ComVisible 特性设置为 true。
[assembly: ComVisible(false)]

// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
[assembly: Guid("bd96a5e8-6c92-438b-8c85-b2a368273405")]

// 程序集的版本信息由下列四个值组成: 
//
//      主版本
//      次版本
//      生成号
//      修订号
//
//可以指定所有这些值，也可以使用“生成号”和“修订号”的默认值
//通过使用 "*"，如下所示:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`README.md`:

```md
# Mhyprot2DrvControl
A lib that allows using mhyprot2 driver for enum process modules, r/w process memory and kill process.

# Usage
Build and run, see Driver\MhyProt2.cs for available function and usage.

# Demo
![Demo](https://raw.githubusercontent.com/kagurazakasanae/Mhyprot2DrvControl/main/demo.png)
![KillProcessDemo](https://raw.githubusercontent.com/kagurazakasanae/Mhyprot2DrvControl/main/killprocessdemo.gif)

```

`Utils/MT64.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MhyProt2Drv.Utils
{
	public struct rand_mt64
	{
		public ulong[] array;
		public ulong index;
		public ulong decodeKey;
	};
	class MT64
	{
		private static ulong RAND_MT64_ARRAY_LEN = 312;
		public rand_mt64 mt;

		public MT64()
		{
			mt = new rand_mt64();
			mt.array = new ulong[RAND_MT64_ARRAY_LEN];
		}
		public void rand_mt64_init(ulong seed)
		{
			ulong f = 0x5851f42d4c957f2d;
			ulong prev_value = seed;
			mt.index = RAND_MT64_ARRAY_LEN;
			mt.array[0] = prev_value;
			for (ulong i = 1; i < RAND_MT64_ARRAY_LEN; i += 1)
			{
				prev_value = i + f * (prev_value ^ (prev_value >> 62));
				mt.array[i] = prev_value;
			}
		}

		public ulong rand_mt64_get()
		{
			ulong m = 156;
			ulong n = RAND_MT64_ARRAY_LEN;
			ulong[] mag01 = new ulong[2] { 0, 0xB5026F5AA96619E9 };
			ulong UM = 0xFFFFFFFF80000000;
			ulong LM = 0x7FFFFFFF;
			ulong x;

			if (mt.index >= n)
			{
				ulong i;

				for (i = 0; i < n - m; i += 1)
				{
					x = (mt.array[i] & UM) | (mt.array[i + 1] & LM);
					mt.array[i] = mt.array[i + m] ^ (x >> 1) ^
						mag01[x & 0x1];
				}
				for (; i < n - 1; i += 1)
				{
					x = (mt.array[i] & UM) | (mt.array[i + 1] & LM);
					mt.array[i] = mt.array[i + (m - n)] ^ (x >> 1) ^
						mag01[x & 0x1];
				}
				x = (mt.array[i] & UM) | (mt.array[0] & LM);
				mt.array[i] = mt.array[m - 1] ^ (x >> 1) ^
					mag01[x & 0x1];

				mt.index = 0;
			}

			x = mt.array[mt.index];
			mt.index += 1;

			x ^= ((x >> 29) & 0x5555555555555555);
			x ^= ((x << 17) & 0x71D67FFFEDA60000);
			x ^= ((x << 37) & 0xFFF7EEE000000000);
			x ^= (x >> 43);

			return x;
		}
	}
}

```

`Utils/Memory.cs`:

```cs
using MhyProt2Drv.Driver;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace MhyProt2Drv.Utils
{
    public class Memory
    {
        private MhyProt2 drv;
        private uint pid;

        public Memory(MhyProt2 drv, uint pid)
        {
            this.drv = drv;
            this.pid = pid;
        }
        public byte[] Read(IntPtr Address, uint length)
        {
            IntPtr readptr = Marshal.AllocHGlobal((IntPtr)length);
            uint read = drv.RWMemory(0, pid, readptr, Address, length);
            if (read == 0) throw new Exception("Read failed");
            return drv.PtrToByte(readptr, read);
        }
        public uint Write(IntPtr Address, byte[] data)
        {
            IntPtr writeptr = drv.ByteToPtr(data);
            uint write = drv.RWMemory(1, pid, Address, writeptr, (uint)data.Length);
            if (write == 0) throw new Exception("Write failed");
            return write;
        }
        public T Read<T>(IntPtr Address)
        {
            var size = (uint)Marshal.SizeOf(typeof(T));
            var data = Read(Address, size);
            return GetStructure<T>(data);
        }
        public void Write<T>(T input, IntPtr Address)
        {
            int size = Marshal.SizeOf(input);
            byte[] arr = new byte[size];

            IntPtr ptr = Marshal.AllocHGlobal(size);
            Marshal.StructureToPtr(input, ptr, true);
            Marshal.Copy(ptr, arr, 0, size);
            Marshal.FreeHGlobal(ptr);
            Write(Address, arr);
        }
        public string ReadString(IntPtr address)
        {
            byte[] numArray = Read(address, 255);
            var str = Encoding.Default.GetString(numArray);

            if (str.Contains('\0'))
                str = str.Substring(0, str.IndexOf('\0'));
            return str;
        }
        public string ReadUnicodeString(IntPtr address)
        {
            byte[] numArray = Read(address, 255);
            var str = Encoding.Unicode.GetString(numArray);

            if (str.Contains('\0'))
                str = str.Substring(0, str.IndexOf('\0'));
            return str;
        }
        public static T GetStructure<T>(byte[] bytes)
        {
            var handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
            var structure = (T)Marshal.PtrToStructure(handle.AddrOfPinnedObject(), typeof(T));
            handle.Free();
            return structure;
        }
        public static T GetStructure<T>(byte[] bytes, int index)
        {
            int size = Marshal.SizeOf(typeof(T));
            byte[] tmp = new byte[size];
            Array.Copy(bytes, index, tmp, 0, size);
            return GetStructure<T>(tmp);
        }
    }
}

```

`Utils/NTAPI.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace MhyProt2Drv
{
    public unsafe static class NTAPI
    {
        [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
        public static extern IntPtr CreateFileA(
              string lpFileName,
              uint dwDesiredAccess,
              uint dwShareMode,
             IntPtr lpSecurityAttributes,
             uint dwCreationDisposition,
             uint dwFlagsAndAttributes,
             IntPtr hTemplateFile);

        [DllImport("advapi32.dll", EntryPoint = "OpenSCManagerW", ExactSpelling = true, CharSet = CharSet.Unicode, SetLastError = true)]
        public static extern IntPtr OpenSCManager(uint machineName, uint databaseName, uint dwAccess);

        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern IntPtr OpenService(IntPtr hSCManager, string lpServiceName, uint dwDesiredAccess);
        [DllImport("ntdll.dll", CharSet = CharSet.Auto)]
        public static extern uint NtOpenFile(IntPtr* FileHandle, uint DesiredAccess, OBJECT_ATTRIBUTES* ObjectAttributes, IO_STATUS_BLOCK* IoStatusBlock, uint ShareAccess, uint OpenOptions);

        [DllImport("advapi32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool CloseServiceHandle(IntPtr hSCObject);

        [DllImport("advapi32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool ControlService(IntPtr hService, SERVICE_CONTROL dwControl, ref SERVICE_STATUS lpServiceStatus);

        [DllImport("advapi32", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool StartService(
            IntPtr hService,
            int dwNumServiceArgs,
            string[] lpServiceArgVectors
        );

        [DllImport("advapi32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool DeleteService(IntPtr hService);
        [DllImport("kernel32.dll", ExactSpelling = true, SetLastError = true, CharSet = CharSet.Auto)]
        public static extern bool DeviceIoControl(
                IntPtr hDevice,
                uint dwIoControlCode,
                void* lpInBuffer,
                uint nInBufferSize,
                void* lpOutBuffer,
                uint nOutBufferSize,
                ulong* lpBytesReturned,
                uint lpOverlapped);

        [DllImport("kernel32.dll", ExactSpelling = true, SetLastError = true, CharSet = CharSet.Auto)]
        public static extern bool DeviceIoControl(IntPtr hDevice, uint dwIoControlCode, IntPtr lpInBuffer, uint nInBufferSize, IntPtr lpOutBuffer, uint nOutBufferSize, ulong* lpBytesReturned, uint lpOverlapped);

        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern IntPtr CreateServiceW(
            IntPtr hSCManager,
            string lpServiceName,
            string lpDisplayName,
            uint dwDesiredAccess,
            uint dwServiceType,
            uint dwStartType,
            uint dwErrorControl,
            string lpBinaryPathName,
            uint lpLoadOrderGroup,
            uint lpdwTagId,
            uint lpdwTagId1,
            uint lpDependencies,
            uint lpServiceStartName,
            uint lpPassword);

        [StructLayout(LayoutKind.Sequential, Pack = 0)]
        public struct SERVICE_STATUS
        {
            public SERVICE_TYPE dwServiceType;
            public SERVICE_STATE dwCurrentState;
            public uint dwControlsAccepted;
            public uint dwWin32ExitCode;
            public uint dwServiceSpecificExitCode;
            public uint dwCheckPoint;
            public uint dwWaitHint;
        }
        [StructLayout(LayoutKind.Sequential, Pack = 0)]
        public struct IO_STATUS_BLOCK
        {
            public uint status;
            public IntPtr information;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct UNICODE_STRING : IDisposable
        {
            public ushort Length;
            public ushort MaximumLength;
            private IntPtr buffer;

            public UNICODE_STRING(string s)
            {
                Length = (ushort)(s.Length * 2);
                MaximumLength = (ushort)(Length + 2);
                buffer = Marshal.StringToHGlobalUni(s);
            }

            public void Dispose()
            {
                Marshal.FreeHGlobal(buffer);
                buffer = IntPtr.Zero;
            }

            public override string ToString()
            {
                return Marshal.PtrToStringUni(buffer);
            }
        }
        [Flags]
        public enum SERVICE_TYPE : int
        {
            SERVICE_KERNEL_DRIVER = 0x00000001,
            SERVICE_FILE_SYSTEM_DRIVER = 0x00000002,
            SERVICE_WIN32_OWN_PROCESS = 0x00000010,
            SERVICE_WIN32_SHARE_PROCESS = 0x00000020,
            SERVICE_INTERACTIVE_PROCESS = 0x00000100
        }
        [Flags]
        public enum SERVICE_CONTROL : uint
        {
            STOP = 0x00000001,
            PAUSE = 0x00000002,
            CONTINUE = 0x00000003,
            INTERROGATE = 0x00000004,
            SHUTDOWN = 0x00000005,
            PARAMCHANGE = 0x00000006,
            NETBINDADD = 0x00000007,
            NETBINDREMOVE = 0x00000008,
            NETBINDENABLE = 0x00000009,
            NETBINDDISABLE = 0x0000000A,
            DEVICEEVENT = 0x0000000B,
            HARDWAREPROFILECHANGE = 0x0000000C,
            POWEREVENT = 0x0000000D,
            SESSIONCHANGE = 0x0000000E
        }
        public enum SERVICE_STATE : uint
        {
            SERVICE_STOPPED = 0x00000001,
            SERVICE_START_PENDING = 0x00000002,
            SERVICE_STOP_PENDING = 0x00000003,
            SERVICE_RUNNING = 0x00000004,
            SERVICE_CONTINUE_PENDING = 0x00000005,
            SERVICE_PAUSE_PENDING = 0x00000006,
            SERVICE_PAUSED = 0x00000007
        }
        public enum SERVICE_ACCESS : uint
        {
            /// <summary>
            /// Required to call the QueryServiceConfig and 
            /// QueryServiceConfig2 functions to query the service configuration.
            /// </summary>
            SERVICE_QUERY_CONFIG = 0x00001,

            /// <summary>
            /// Required to call the ChangeServiceConfig or ChangeServiceConfig2 function 
            /// to change the service configuration. Because this grants the caller 
            /// the right to change the executable file that the system runs, 
            /// it should be granted only to administrators.
            /// </summary>
            SERVICE_CHANGE_CONFIG = 0x00002,

            /// <summary>
            /// Required to call the QueryServiceStatusEx function to ask the service 
            /// control manager about the status of the service.
            /// </summary>
            SERVICE_QUERY_STATUS = 0x00004,

            /// <summary>
            /// Required to call the EnumDependentServices function to enumerate all 
            /// the services dependent on the service.
            /// </summary>
            SERVICE_ENUMERATE_DEPENDENTS = 0x00008,

            /// <summary>
            /// Required to call the StartService function to start the service.
            /// </summary>
            SERVICE_START = 0x00010,

            /// <summary>
            ///     Required to call the ControlService function to stop the service.
            /// </summary>
            SERVICE_STOP = 0x00020,

            /// <summary>
            /// Required to call the ControlService function to pause or continue 
            /// the service.
            /// </summary>
            SERVICE_PAUSE_CONTINUE = 0x00040,

            /// <summary>
            /// Required to call the EnumDependentServices function to enumerate all
            /// the services dependent on the service.
            /// </summary>
            SERVICE_INTERROGATE = 0x00080,

            /// <summary>
            /// Required to call the ControlService function to specify a user-defined
            /// control code.
            /// </summary>
            SERVICE_USER_DEFINED_CONTROL = 0x00100,

            /// <summary>
            /// Includes STANDARD_RIGHTS_REQUIRED in addition to all access rights in this table.
            /// </summary>
            SERVICE_ALL_ACCESS = (ACCESS_MASK.STANDARD_RIGHTS_REQUIRED |
                SERVICE_QUERY_CONFIG |
                SERVICE_CHANGE_CONFIG |
                SERVICE_QUERY_STATUS |
                SERVICE_ENUMERATE_DEPENDENTS |
                SERVICE_START |
                SERVICE_STOP |
                SERVICE_PAUSE_CONTINUE |
                SERVICE_INTERROGATE |
                SERVICE_USER_DEFINED_CONTROL),

            GENERIC_READ = ACCESS_MASK.STANDARD_RIGHTS_READ |
                SERVICE_QUERY_CONFIG |
                SERVICE_QUERY_STATUS |
                SERVICE_INTERROGATE |
                SERVICE_ENUMERATE_DEPENDENTS,

            GENERIC_WRITE = ACCESS_MASK.STANDARD_RIGHTS_WRITE |
                SERVICE_CHANGE_CONFIG,

            GENERIC_EXECUTE = ACCESS_MASK.STANDARD_RIGHTS_EXECUTE |
                SERVICE_START |
                SERVICE_STOP |
                SERVICE_PAUSE_CONTINUE |
                SERVICE_USER_DEFINED_CONTROL,

            /// <summary>
            /// Required to call the QueryServiceObjectSecurity or 
            /// SetServiceObjectSecurity function to access the SACL. The proper
            /// way to obtain this access is to enable the SE_SECURITY_NAME 
            /// privilege in the caller's current access token, open the handle 
            /// for ACCESS_SYSTEM_SECURITY access, and then disable the privilege.
            /// </summary>
            ACCESS_SYSTEM_SECURITY = ACCESS_MASK.ACCESS_SYSTEM_SECURITY,

            /// <summary>
            /// Required to call the DeleteService function to delete the service.
            /// </summary>
            DELETE = ACCESS_MASK.DELETE,

            /// <summary>
            /// Required to call the QueryServiceObjectSecurity function to query
            /// the security descriptor of the service object.
            /// </summary>
            READ_CONTROL = ACCESS_MASK.READ_CONTROL,

            /// <summary>
            /// Required to call the SetServiceObjectSecurity function to modify
            /// the Dacl member of the service object's security descriptor.
            /// </summary>
            WRITE_DAC = ACCESS_MASK.WRITE_DAC,

            /// <summary>
            /// Required to call the SetServiceObjectSecurity function to modify 
            /// the Owner and Group members of the service object's security 
            /// descriptor.
            /// </summary>
            WRITE_OWNER = ACCESS_MASK.WRITE_OWNER,
        }

        [Flags]
        public enum ACCESS_MASK : uint
        {
            DELETE = 0x00010000,
            READ_CONTROL = 0x00020000,
            WRITE_DAC = 0x00040000,
            WRITE_OWNER = 0x00080000,
            SYNCHRONIZE = 0x00100000,

            STANDARD_RIGHTS_REQUIRED = 0x000F0000,

            STANDARD_RIGHTS_READ = 0x00020000,
            STANDARD_RIGHTS_WRITE = 0x00020000,
            STANDARD_RIGHTS_EXECUTE = 0x00020000,

            STANDARD_RIGHTS_ALL = 0x001F0000,

            SPECIFIC_RIGHTS_ALL = 0x0000FFFF,

            ACCESS_SYSTEM_SECURITY = 0x01000000,

            MAXIMUM_ALLOWED = 0x02000000,

            GENERIC_READ = 0x80000000,
            GENERIC_WRITE = 0x40000000,
            GENERIC_EXECUTE = 0x20000000,
            GENERIC_ALL = 0x10000000,

            DESKTOP_READOBJECTS = 0x00000001,
            DESKTOP_CREATEWINDOW = 0x00000002,
            DESKTOP_CREATEMENU = 0x00000004,
            DESKTOP_HOOKCONTROL = 0x00000008,
            DESKTOP_JOURNALRECORD = 0x00000010,
            DESKTOP_JOURNALPLAYBACK = 0x00000020,
            DESKTOP_ENUMERATE = 0x00000040,
            DESKTOP_WRITEOBJECTS = 0x00000080,
            DESKTOP_SWITCHDESKTOP = 0x00000100,

            WINSTA_ENUMDESKTOPS = 0x00000001,
            WINSTA_READATTRIBUTES = 0x00000002,
            WINSTA_ACCESSCLIPBOARD = 0x00000004,
            WINSTA_CREATEDESKTOP = 0x00000008,
            WINSTA_WRITEATTRIBUTES = 0x00000010,
            WINSTA_ACCESSGLOBALATOMS = 0x00000020,
            WINSTA_EXITWINDOWS = 0x00000040,
            WINSTA_ENUMERATE = 0x00000100,
            WINSTA_READSCREEN = 0x00000200,

            WINSTA_ALL_ACCESS = 0x0000037F
        }

        /// <summary>
        /// Service start options
        /// </summary>
        public enum SERVICE_START : uint
        {
            /// <summary>
            /// A device driver started by the system loader. This value is valid
            /// only for driver services.
            /// </summary>
            SERVICE_BOOT_START = 0x00000000,

            /// <summary>
            /// A device driver started by the IoInitSystem function. This value 
            /// is valid only for driver services.
            /// </summary>
            SERVICE_SYSTEM_START = 0x00000001,

            /// <summary>
            /// A service started automatically by the service control manager 
            /// during system startup. For more information, see Automatically 
            /// Starting Services.
            /// </summary>         
            SERVICE_AUTO_START = 0x00000002,

            /// <summary>
            /// A service started by the service control manager when a process 
            /// calls the StartService function. For more information, see 
            /// Starting Services on Demand.
            /// </summary>
            SERVICE_DEMAND_START = 0x00000003,

            /// <summary>
            /// A service that cannot be started. Attempts to start the service
            /// result in the error code ERROR_SERVICE_DISABLED.
            /// </summary>
            SERVICE_DISABLED = 0x00000004,
        }
        [Flags]
        public enum SERVICE_ACCEPT : uint
        {
            STOP = 0x00000001,
            PAUSE_CONTINUE = 0x00000002,
            SHUTDOWN = 0x00000004,
            PARAMCHANGE = 0x00000008,
            NETBINDCHANGE = 0x00000010,
            HARDWAREPROFILECHANGE = 0x00000020,
            POWEREVENT = 0x00000040,
            SESSIONCHANGE = 0x00000080,
        }
        public static uint STATUS_SUCCESS = 0x00000000;
        public static uint STATUS_INFO_LENGTH_MISMATCH = 0xC0000004;
        [DllImport("msvcrt.dll", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr memmove(IntPtr dest, IntPtr src, ulong count);
        [DllImport("ntdll.dll")]
        public static extern int ZwUnmapViewOfSection(IntPtr hProcess, IntPtr BaseAddress);
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr GetCurrentProcess();

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public struct LARGE_INTEGER
        {
            //[FieldOffset(0)] public long QuadPart;
            [FieldOffset(0)] public int LowPart;
            [FieldOffset(4)] public int HighPart;
        }
        [DllImport("ntdll.dll", EntryPoint = "ZwOpenSection")]
        public static extern uint ZwOpenSection(out IntPtr sectionHandle, uint desiredAccess, ref OBJECT_ATTRIBUTES attributes);
        [DllImport("ntdll.dll", EntryPoint = "ZwMapViewOfSection")]
        public unsafe static extern uint ZwMapViewOfSection(IntPtr section, IntPtr process, ref IntPtr baseAddr, int zeroBits, ulong commitSize, LARGE_INTEGER* stuff, ref ulong viewSize, int inheritDispo, uint alloctype, uint prot);
        [DllImport("user32.dll", EntryPoint = "SetWindowPos")]
        public static extern IntPtr SetWindowPos(IntPtr hWnd, int hWndInsertAfter, int x, int Y, int cx, int cy, int wFlags);
        [DllImport("kernel32.dll")]
        public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int dwSize, int lpNumberOfBytesRead);

        [DllImport("kernel32.dll")]
        public static extern bool ReadProcessMemory(IntPtr hProcess, ulong lpBaseAddress, byte[] lpBuffer, uint dwSize, int lpNumberOfBytesRead = 0);

        [DllImport("kernel32.dll")]
        public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int nSize, int lpNumberOfBytesWritten);

        [DllImport("kernel32.dll")]
        public static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("user32.dll", EntryPoint = "FindWindow")]
        public extern static IntPtr FindWindow(string lpClassName, string lpWindowName);

        public delegate bool CallBack(int hwnd, int lParam);

        [DllImport("user32.dll")]
        public static extern int EnumWindows(CallBack x, int y);


        [DllImport("user32.dll")]
        public static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, int dwExtraInfo);


        [DllImport("user32.dll")]
        public static extern int GetWindowText(int hwnd, StringBuilder lptrString, int nMaxCount);


        [DllImport("psapi.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
        /*
        得到指定进程中每个模块的句柄

        需要指定一个大的存储HMODULE值的数组。因为较难预计进程中有多少个模块。比较lpcbNeeded和cb，如果lpcbNeeded大于cb，增加lphModule数组的大小后再调用EnumProcessModules。
        参数

        hProcess	-	[in]进程句柄。
        lphModule	-	[out]指向保存模块句柄数组的指针。
        cb	-	[in]lphmodule数组的大小，字节为单位。
        lpcbNeeded	-	[out]存储所有模块句柄的lphmodule数组的大小，字节为单位。
        返回值

        成功返回非零值，失败返回零。调用GetLastError得到错误信息。
        */
        public static extern bool EnumProcessModules(IntPtr hProcess, [Out] IntPtr lphModule, uint cb, out uint lpcbNeeded);

        [DllImport("psapi.dll")]
        public static extern uint GetModuleFileNameEx(IntPtr hProcess, IntPtr hModule, [Out] StringBuilder lpBaseName, [In][MarshalAs(UnmanagedType.U4)] int nSize);

        [DllImport("psapi.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
        /*
        参数

        hProcess	-	[in]包含模块的进程的句柄。
        hModule	-	[in]模块句柄。
        lpmodinfo	-	[out]指向存放模块信息的MODULEINFO的指针。
        cb	-	[in]MODULEINFO结构的大小，字节为单位。
        返回值

        成功返回非零值。失败返回0。调用GetLastError得到错误信息。
         */
        public static extern bool GetModuleInformation(IntPtr hProcess, IntPtr hModule, out _MODULEINFO lpModInfo, int cb);

        [DllImport("user32.dll", SetLastError = true)]
        public static extern uint GetWindowLong(IntPtr hWnd, int nIndex);

        [DllImport("user32.dll")]
        public static extern int SetWindowLong(IntPtr hWnd, int nIndex, IntPtr dwNewLong);

        [DllImport("user32.dll")]
        public static extern bool SetLayeredWindowAttributes(IntPtr hwnd, uint crKey, byte bAlpha, uint dwFlags);

        [DllImport("dwmapi.dll")]
        public static extern void DwmExtendFrameIntoClientArea(IntPtr hWnd, ref Margins pMargins);

        [DllImport("Gdi32.dll", CharSet = CharSet.Auto, ExactSpelling = true)]
        public static extern int GetDeviceCaps(IntPtr hDC, int nIndex);

        [DllImport("User32.dll")]
        public extern static IntPtr GetDesktopWindow();

        [DllImport("User32.dll")]
        public static extern IntPtr GetDC(IntPtr hWnd);

        [DllImport("ntdll.dll", SetLastError = true)]
        public unsafe static extern uint RtlGetVersion(_OSVERSIONINFOEXW* lpVersionInformation);

        [DllImport("ntdll.dll", SetLastError = true)]
        public unsafe static extern int NtQueryInformationProcess(IntPtr processHandle, int processInformationClass, void* processInformation, int processInformationLength, IntPtr returnLength);

        [DllImport("ntdll.dll", SetLastError = true)]
        public static extern uint NtQuerySystemInformation(uint InfoClass, ulong Info, uint Size, out uint Length);

        [DllImport("ntdll.dll", EntryPoint = "ZwQuerySystemInformation")]
        public static extern uint ZwQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, IntPtr SystemInformation, uint SystemInformationLength, out uint ReturnLength);

        [DllImport("ntdll.dll", EntryPoint = "ZwDuplicateObject")]
        public static extern uint ZwDuplicateObject(IntPtr SourceProcessHandle, IntPtr SourceHandle, IntPtr TargetProcessHandle, out IntPtr TargetHandle, ulong DesiredAccess, ulong HandleAttributes, ulong Options);

        [DllImport("ntdll.dll")]
        public static extern uint RtlNtStatusToDosError(uint Status);

        [DllImport("kernel32", SetLastError = true, CharSet = CharSet.Ansi)]
        public static extern ulong LoadLibrary([MarshalAs(UnmanagedType.LPStr)] string lpFileName);

        [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
        public static extern ulong GetProcAddress(ulong hModule, string procName);

        [DllImport("kernel32.dll", EntryPoint = "GetProcessId", CharSet = CharSet.Auto)]
        public static extern int GetProcessId(IntPtr handle);

        [DllImport("kernel32.dll", EntryPoint = "CloseHandle", SetLastError = true)]
        public static extern bool CloseHandle(IntPtr hObject);
        public enum SYSTEM_INFORMATION_CLASS
        {
            SystemBasicInformation = 0x0000,
            SystemProcessorInformation = 0x0001,
            SystemPerformanceInformation = 0x0002,
            SystemTimeOfDayInformation = 0x0003,
            SystemPathInformation = 0x0004,
            SystemProcessInformation = 0x0005,
            SystemCallCountInformation = 0x0006,
            SystemDeviceInformation = 0x0007,
            SystemProcessorPerformanceInformation = 0x0008,
            SystemFlagsInformation = 0x0009,
            SystemCallTimeInformation = 0x000A,
            SystemModuleInformation = 0x000B,
            SystemLocksInformation = 0x000C,
            SystemStackTraceInformation = 0x000D,
            SystemPagedPoolInformation = 0x000E,
            SystemNonPagedPoolInformation = 0x000F,
            SystemHandleInformation = 0x0010,
            SystemObjectInformation = 0x0011,
            SystemPageFileInformation = 0x0012,
            SystemVdmInstemulInformation = 0x0013,
            SystemVdmBopInformation = 0x0014,
            SystemFileCacheInformation = 0x0015,
            SystemPoolTagInformation = 0x0016,
            SystemInterruptInformation = 0x0017,
            SystemDpcBehaviorInformation = 0x0018,
            SystemFullMemoryInformation = 0x0019,
            SystemLoadGdiDriverInformation = 0x001A,
            SystemUnloadGdiDriverInformation = 0x001B,
            SystemTimeAdjustmentInformation = 0x001C,
            SystemSummaryMemoryInformation = 0x001D,
            SystemMirrorMemoryInformation = 0x001E,
            SystemPerformanceTraceInformation = 0x001F,
            SystemCrashDumpInformation = 0x0020,
            SystemExceptionInformation = 0x0021,
            SystemCrashDumpStateInformation = 0x0022,
            SystemKernelDebuggerInformation = 0x0023,
            SystemContextSwitchInformation = 0x0024,
            SystemRegistryQuotaInformation = 0x0025,
            SystemExtendServiceTableInformation = 0x0026,
            SystemPrioritySeperation = 0x0027,
            SystemVerifierAddDriverInformation = 0x0028,
            SystemVerifierRemoveDriverInformation = 0x0029,
            SystemProcessorIdleInformation = 0x002A,
            SystemLegacyDriverInformation = 0x002B,
            SystemCurrentTimeZoneInformation = 0x002C,
            SystemLookasideInformation = 0x002D,
            SystemTimeSlipNotification = 0x002E,
            SystemSessionCreate = 0x002F,
            SystemSessionDetach = 0x0030,
            SystemSessionInformation = 0x0031,
            SystemRangeStartInformation = 0x0032,
            SystemVerifierInformation = 0x0033,
            SystemVerifierThunkExtend = 0x0034,
            SystemSessionProcessInformation = 0x0035,
            SystemLoadGdiDriverInSystemSpace = 0x0036,
            SystemNumaProcessorMap = 0x0037,
            SystemPrefetcherInformation = 0x0038,
            SystemExtendedProcessInformation = 0x0039,
            SystemRecommendedSharedDataAlignment = 0x003A,
            SystemComPlusPackage = 0x003B,
            SystemNumaAvailableMemory = 0x003C,
            SystemProcessorPowerInformation = 0x003D,
            SystemEmulationBasicInformation = 0x003E,
            SystemEmulationProcessorInformation = 0x003F,
            SystemExtendedHandleInformation = 0x0040,
            SystemLostDelayedWriteInformation = 0x0041,
            SystemBigPoolInformation = 0x0042,
            SystemSessionPoolTagInformation = 0x0043,
            SystemSessionMappedViewInformation = 0x0044,
            SystemHotpatchInformation = 0x0045,
            SystemObjectSecurityMode = 0x0046,
            SystemWatchdogTimerHandler = 0x0047,
            SystemWatchdogTimerInformation = 0x0048,
            SystemLogicalProcessorInformation = 0x0049,
            SystemWow64SharedInformationObsolete = 0x004A,
            SystemRegisterFirmwareTableInformationHandler = 0x004B,
            SystemFirmwareTableInformation = 0x004C,
            SystemModuleInformationEx = 0x004D,
            SystemVerifierTriageInformation = 0x004E,
            SystemSuperfetchInformation = 0x004F,
            SystemMemoryListInformation = 0x0050, // SYSTEM_MEMORY_LIST_INFORMATION
            SystemFileCacheInformationEx = 0x0051,
            SystemThreadPriorityClientIdInformation = 0x0052,
            SystemProcessorIdleCycleTimeInformation = 0x0053,
            SystemVerifierCancellationInformation = 0x0054,
            SystemProcessorPowerInformationEx = 0x0055,
            SystemRefTraceInformation = 0x0056,
            SystemSpecialPoolInformation = 0x0057,
            SystemProcessIdInformation = 0x0058,
            SystemErrorPortInformation = 0x0059,
            SystemBootEnvironmentInformation = 0x005A,
            SystemHypervisorInformation = 0x005B,
            SystemVerifierInformationEx = 0x005C,
            SystemTimeZoneInformation = 0x005D,
            SystemImageFileExecutionOptionsInformation = 0x005E,
            SystemCoverageInformation = 0x005F,
            SystemPrefetchPatchInformation = 0x0060,
            SystemVerifierFaultsInformation = 0x0061,
            SystemSystemPartitionInformation = 0x0062,
            SystemSystemDiskInformation = 0x0063,
            SystemProcessorPerformanceDistribution = 0x0064,
            SystemNumaProximityNodeInformation = 0x0065,
            SystemDynamicTimeZoneInformation = 0x0066,
            SystemCodeIntegrityInformation = 0x0067,
            SystemProcessorMicrocodeUpdateInformation = 0x0068,
            SystemProcessorBrandString = 0x0069,
            SystemVirtualAddressInformation = 0x006A,
            SystemLogicalProcessorAndGroupInformation = 0x006B,
            SystemProcessorCycleTimeInformation = 0x006C,
            SystemStoreInformation = 0x006D,
            SystemRegistryAppendString = 0x006E,
            SystemAitSamplingValue = 0x006F,
            SystemVhdBootInformation = 0x0070,
            SystemCpuQuotaInformation = 0x0071,
            SystemNativeBasicInformation = 0x0072,
            SystemErrorPortTimeouts = 0x0073,
            SystemLowPriorityIoInformation = 0x0074,
            SystemBootEntropyInformation = 0x0075,
            SystemVerifierCountersInformation = 0x0076,
            SystemPagedPoolInformationEx = 0x0077,
            SystemSystemPtesInformationEx = 0x0078,
            SystemNodeDistanceInformation = 0x0079,
            SystemAcpiAuditInformation = 0x007A,
            SystemBasicPerformanceInformation = 0x007B,
            SystemQueryPerformanceCounterInformation = 0x007C,
            SystemSessionBigPoolInformation = 0x007D,
            SystemBootGraphicsInformation = 0x007E,
            SystemScrubPhysicalMemoryInformation = 0x007F,
            SystemBadPageInformation = 0x0080,
            SystemProcessorProfileControlArea = 0x0081,
            SystemCombinePhysicalMemoryInformation = 0x0082,
            SystemEntropyInterruptTimingInformation = 0x0083,
            SystemConsoleInformation = 0x0084,
            SystemPlatformBinaryInformation = 0x0085,
            SystemThrottleNotificationInformation = 0x0086,
            SystemHypervisorProcessorCountInformation = 0x0087,
            SystemDeviceDataInformation = 0x0088,
            SystemDeviceDataEnumerationInformation = 0x0089,
            SystemMemoryTopologyInformation = 0x008A,
            SystemMemoryChannelInformation = 0x008B,
            SystemBootLogoInformation = 0x008C,
            SystemProcessorPerformanceInformationEx = 0x008D,
            SystemSpare0 = 0x008E,
            SystemSecureBootPolicyInformation = 0x008F,
            SystemPageFileInformationEx = 0x0090,
            SystemSecureBootInformation = 0x0091,
            SystemEntropyInterruptTimingRawInformation = 0x0092,
            SystemPortableWorkspaceEfiLauncherInformation = 0x0093,
            SystemFullProcessInformation = 0x0094,
            MaxSystemInfoClass = 0x0095
        }
        public enum DuplicateOptions : ulong
        {
            DUPLICATE_CLOSE_SOURCE = (0x00000001),// Closes the source handle. This occurs regardless of any error status returned.
            DUPLICATE_SAME_ACCESS = (0x00000002) //Ignores the dwDesiredAccess parameter. The duplicate handle has the same access as the source handle.
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SYSTEM_HANDLE_ENTRY
        {
            public int OwnerPid;
            public byte ObjectType;
            public byte HandleFlags;
            public short HandleValue;
            public int ObjectPointer;
            public int AccessMask;
        }


        [StructLayout(LayoutKind.Sequential)]
        public struct SYSTEM_BASIC_INFORMATION
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 24)]
            public byte[] Reserved1;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
            public IntPtr[] Reserved2;
            public Char NumberOfProcessors;
        }


        public struct Margins
        {
            public int Left, Right, Top, Bottom;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct _MODULEINFO
        {
            public IntPtr lpBaseOfDll;
            public uint SizeOfImage;
            public IntPtr EntryPoint;
        }




        [DllImport("user32.dll")]
        public static extern IntPtr SetActiveWindow(IntPtr hwnd);//设置活动窗体

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT
        {
            public int Left;                             //最左坐标
            public int Top;                             //最上坐标
            public int Right;                           //最右坐标
            public int Bottom;                        //最下坐标
        }

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool GetWindowRect(IntPtr hWnd, ref RECT lpRect);

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool GetClientRect(IntPtr hWnd, ref RECT lpRect);

        public const int WS_EX_NOACTIVATE = 0x08000000;

        public const int GWL_EXSTYLE = -20;

        public const int WS_EX_LAYERED = 0x80000;

        public const int WS_EX_TRANSPARENT = 0x20;

        public const int LWA_ALPHA = 0x2;

        public const int LWA_COLORKEY = 0x1;

        [StructLayout(LayoutKind.Sequential)]
        public struct _HANDLE_TABLE_ENTRY
        {
            public ulong Object;
            public ulong GrantedAccess;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct ProcessContext
        {
            public uint ProcessId;
            public ulong DirectoryBase;
            public ulong KernelEntry;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct _OSVERSIONINFOEXW
        {
            public uint dwOSVersionInfoSize;
            public uint dwMajorVersion;
            public uint dwMinorVersion;
            public uint dwBuildNumber;
            public uint dwPlatformId;
            public fixed byte szCSDVersion[128 * 2/*WCHAR*/];     // Maintenance string for PSS usage
            public ushort wServicePackMajor;
            public ushort wServicePackMinor;
            public ushort wSuiteMask;
            public byte wProductType;
            public byte wReserved;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct _RTL_PROCESS_MODULES
        {
            public uint NumberOfModules;
            public _RTL_PROCESS_MODULE_INFORMATION Modules;
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct _RTL_PROCESS_MODULE_INFORMATION
        {
            public void* Section;
            public void* MappedBase;
            public void* ImageBase;
            public uint ImageSize;
            public uint Flags;
            public ushort LoadOrderIndex;
            public ushort InitOrderIndex;
            public ushort LoadCount;
            public ushort OffsetToFileName;
            public fixed sbyte FullPathName[256];
        }
        public struct OBJECT_ATTRIBUTES
        {
            public Int32 Length;
            public IntPtr RootDirectory;
            public IntPtr ObjectName;
            public uint Attributes;
            public IntPtr SecurityDescriptor;
            public IntPtr SecurityQualityOfService;

        }
    }
}

```