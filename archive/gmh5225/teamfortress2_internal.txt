Project Path: arc_gmh5225_teamfortress2_internal_fe2n29_7

Source Tree:

```txt
arc_gmh5225_teamfortress2_internal_fe2n29_7
├── dllmain.cpp
├── enginetrace.cpp
├── enginetrace.h
├── entity.cpp
├── entity.h
├── entitylist.cpp
├── entitylist.h
├── hooks.cpp
├── hooks.h
├── modelinfo.cpp
├── modelinfo.h
├── pch.cpp
├── pch.h
├── teamfortress2_internal.sln
├── teamfortress2_internal.vcxproj
├── teamfortress2_internal.vcxproj.filters
└── usercmd.h

```

`dllmain.cpp`:

```cpp
// dllmain.cpp : Defines the entry point for the DLL application.
#include "pch.h"
#include "entitylist.h"
#include "hooks.h"

DWORD WINAPI main_thread(LPVOID)
{
	using AddListenerEntity_t = void(__thiscall*)(void* thisptr, void* entitylist);
	const auto AddListenerEntity = reinterpret_cast<AddListenerEntity_t>(find_pattern(L"client", "55 8B EC 8B 91 ? ? ? ? 33 C0 56 57 8D B9 ? ? ? ? 85 D2 7E ? 8B 0F 8B 75 ? 8D 64 24 ? 39 31 74 ? 40 83 C1 ? 3B C2 7C ? 8D 45 ? 8B CF 50 E8 ? ? ? ? 5F 5E 5D C2 ? ? 85 C0"));
	AddListenerEntity(**reinterpret_cast<std::byte***>(find_pattern(L"client", "A1 ? ? ? ? 66 8B 80") + 1), &entitylist);

	MH_Initialize();

	MH_CreateHook(find_pattern(L"client", "55 8B EC 83 EC ? A1 ? ? ? ? 56 57 8B F9 89 7D"), hooks::tf_player::create_move::detour, reinterpret_cast<void**>(&hooks::tf_player::create_move::original));

	MH_EnableHook(MH_ALL_HOOKS);

	return 0;
}

BOOL APIENTRY DllMain(HMODULE, const DWORD reason, LPVOID)
{
	if (reason == DLL_PROCESS_ATTACH)
	{
		if (const HANDLE thread = CreateThread(nullptr, 0, main_thread, nullptr, 0, nullptr))
		{
			CloseHandle(thread);
		}
	}

	return TRUE;
}


```

`enginetrace.cpp`:

```cpp
#include "pch.h"
#include "enginetrace.h"
#include "entity.h"

bool trace_filter_t::should_hit_entity(C_BaseEntity* entity, int contents_mask)
{
	return std::find(pass_through.begin(), pass_through.end(), entity) == pass_through.end();
}

enum TraceType_t
{
	TRACE_EVERYTHING = 0,
	TRACE_WORLD_ONLY,
	TRACE_ENTITIES_ONLY,
	TRACE_EVERYTHING_FILTER_PROPS,
};

TraceType_t trace_filter_t::get_trace_type()
{
	return TRACE_EVERYTHING;
}

void engine_trace_t::trace_ray(const Ray_t& ray, unsigned int mask, trace_filter_t* trace_filter, trace_t* trace) noexcept
{
	call_vfunc(this, 4, &ray, mask, trace_filter, trace);
}

```

`enginetrace.h`:

```h
#pragma once

class C_BaseEntity;
enum TraceType_t;

class trace_filter_t
{
	virtual bool should_hit_entity(C_BaseEntity* entity, int contents_mask);
	virtual TraceType_t	get_trace_type();

	std::vector<void*> pass_through{};

public:
	trace_filter_t(std::vector<void*> pass_through_list) : pass_through{ pass_through_list } {}
};

class Ray_t
{
	__declspec(align(16)) glm::vec3 start{};
	__declspec(align(16)) glm::vec3 delta{};
	__declspec(align(16)) glm::vec3 start_offset{};
	__declspec(align(16)) glm::vec3 extents{};
	bool is_ray{};
	bool is_swept{};

public:
	Ray_t(glm::vec3 from, glm::vec3 to) : start{ from }, delta{ to - from }, is_ray{ true }, is_swept{ length(delta) != 0.f } {}
};

class trace_t
{
	std::byte _0[76]{};
public:
	C_BaseEntity* entity{};
	int hitbox{};
};

class engine_trace_t
{
public:
	void trace_ray(const Ray_t& ray, unsigned int mask, trace_filter_t* trace_filter, trace_t* trace) noexcept; // 4
};

inline engine_trace_t* enginetrace{ **reinterpret_cast<engine_trace_t***>(find_pattern(L"client", "A1 ? ? ? ? 8B 4D ? 8B 30 8D 85") + 1) };

// an eye is never valid in a solid
constexpr auto CONTENTS_SOLID = 0x1;
// translucent, but not watery (glass)
constexpr auto CONTENTS_WINDOW = 0x2;
// alpha-tested "grate" textures.  Bullets/sight pass through, but solids don't
constexpr auto CONTENTS_GRATE = 0x8;

// hits entities which are MOVETYPE_PUSH (doors, plats, etc.)
constexpr auto CONTENTS_MOVEABLE = 0x4000;

// should never be on a brush, only in game
constexpr auto CONTENTS_MONSTER = 0x2000000;
constexpr auto CONTENTS_DEBRIS = 0x4000000;
// use accurate hitboxes on trace
constexpr auto CONTENTS_HITBOX = 0x40000000;

// bullets see these as solid
constexpr auto MASK_SHOT = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_WINDOW | CONTENTS_DEBRIS | CONTENTS_HITBOX;


```

`entity.cpp`:

```cpp
#include "pch.h"
#include "entity.h"

model_t* C_BaseEntity::get_model() noexcept
{
	return call_vfunc<model_t*>(IClientRenderable(), 9);
}

bool C_BaseEntity::is_dormant() noexcept
{
	return call_vfunc<bool>(IClientNetworkable(), 8);
}

int C_BaseEntity::get_index() noexcept
{
	return call_vfunc<int>(IClientNetworkable(), 9);
}

const glm::vec3& C_BaseEntity::get_position() noexcept
{
	return call_vfunc<const glm::vec3&>(this, 9);
}

const glm::vec3& C_BaseEntity::get_center() noexcept
{
	return call_vfunc<const glm::vec3&>(this, 66);
}

int C_BaseEntity::get_team_number() noexcept
{
	return call_vfunc<int>(this, 74);
}

bool C_BaseEntity::in_same_team() noexcept
{
	return call_vfunc<bool>(this, 77);
}

bool C_BaseEntity::in_local_team() noexcept
{
	return call_vfunc<bool>(this, 78);
}

bool C_BaseEntity::is_alive() noexcept
{
	return call_vfunc<bool>(this, 130);
}

bool C_BaseEntity::is_player() noexcept
{
	return call_vfunc<bool>(this, 131);
}

bool C_BaseEntity::is_base_combat_character() noexcept
{
	return call_vfunc<bool>(this, 132);
}

bool C_BaseEntity::is_npc() noexcept
{
	return call_vfunc<bool>(this, 133);
}

bool C_BaseEntity::is_next_bot() noexcept
{
	return call_vfunc<bool>(this, 135);
}

bool C_BaseEntity::is_base_object() noexcept
{
	return call_vfunc<bool>(this, 136);
}

bool C_BaseEntity::is_base_combat_weapon() noexcept
{
	return call_vfunc<bool>(this, 137);
}

const glm::vec3& C_BaseEntity::get_view_offset() noexcept
{
	return call_vfunc<const glm::vec3&>(this, 146);
}

glm::vec3 C_BaseAnimating::get_bone_position(int bone)
{
	glm::vec3 origin{};
	glm::vec3 angles{};

	using GetBonePosition_t = void(__thiscall*)(C_BaseAnimating* thisptr, int bone, glm::vec3& origin, glm::vec3& angles);
	static const auto GetBonePosition = reinterpret_cast<GetBonePosition_t>(find_pattern(L"client", "55 8B EC 83 EC ? 56 6A ? 8B F1 E8 ? ? ? ? FF 75"));
	GetBonePosition(this, bone, origin, angles);

	return origin;
}

```

`entity.h`:

```h
#pragma once

class model_t;

class C_BaseEntity
{
	void* IClientRenderable() noexcept { return this + 4; }
	void* IClientNetworkable() noexcept { return this + 8; }
	void* IClientThinkable() noexcept { return this + 12; }

public:
	// IClientRenderable
	model_t* get_model() noexcept; // 9

	// IClientNetworkable
	bool is_dormant() noexcept; // 8
	int get_index() noexcept; // 9

	// C_BaseEntity
	const glm::vec3& get_position() noexcept; // 9
	const glm::vec3& get_center() noexcept; // 66

	int get_team_number() noexcept; // 74
	bool in_same_team() noexcept; // 77
	bool in_local_team() noexcept; // 78

	bool is_alive() noexcept; // 130
	bool is_player() noexcept; // 131
	bool is_base_combat_character() noexcept; // 132
	bool is_npc() noexcept; // 133
	bool is_next_bot() noexcept; // 135
	bool is_base_object() noexcept; // 136
	bool is_base_combat_weapon() noexcept; // 137

	const glm::vec3& get_view_offset() noexcept; // 146

	glm::vec3 get_eye_position() noexcept { return get_position() + get_view_offset(); }
};

class C_BaseAnimating : public C_BaseEntity
{
	void* IModelLoadCallback() noexcept { return this + 1360; }

public:
	glm::vec3 get_bone_position(int bone);
};

class C_BaseCombatCharacter : public C_BaseAnimating
{
	void* IHasLocalToGlobalFlexSettings() noexcept { return this + 2320; }
};

class C_TFPlayer : public C_BaseCombatCharacter
{
	void* CGameEventListener() noexcept { return this + 3528; }
	void* IHasAttributes() noexcept { return this + 5472; }
	void* IInventoryUpdateListener() noexcept { return this + 5476; }
	void* C_TFMvMBossProgressUser() noexcept { return this + 5480; }
};

inline ref_ptr_t localplayer{ *reinterpret_cast<C_TFPlayer***>(find_pattern(L"client", "A1 ? ? ? ? C3 CC CC CC CC CC CC CC CC CC CC A1 ? ? ? ? 83 78") + 1) };

```

`entitylist.cpp`:

```cpp
#include "pch.h"
#include "entitylist.h"

void entitylist_t::on_entity_created(C_BaseEntity* entity)
{
	entities.emplace_back(entity);
}

void entitylist_t::on_entity_deleted(C_BaseEntity* entity)
{
	entities.erase(std::remove(entities.begin(), entities.end(), entity), entities.end());
}

```

`entitylist.h`:

```h
#pragma once

class C_BaseEntity;

class entitylist_t
{
	std::vector<C_BaseEntity*> entities{};

	virtual void on_entity_created(C_BaseEntity* entity);
	virtual void on_entity_deleted(C_BaseEntity* entity);

public:
	const std::vector<C_BaseEntity*>& get_entities() { return entities; }
};

inline entitylist_t entitylist{};

```

`hooks.cpp`:

```cpp
#include "pch.h"
#include "hooks.h"
#include "enginetrace.h"
#include "entity.h"
#include "entitylist.h"
#include "usercmd.h"
#include "modelinfo.h"

bool __fastcall hooks::tf_player::create_move::detour(C_TFPlayer* player_ptr, int32_t, float input_sample_time, CUserCmd* cmd)
{
	if (localplayer == player_ptr && cmd->buttons & IN_ATTACK)
	{
		std::vector<C_BaseEntity*> aim_targets{};
		for (C_BaseEntity* entity : entitylist.get_entities())
		{
			if (localplayer != entity && !entity->is_dormant() && entity->is_alive() && entity->is_player() && !entity->in_local_team())
			{
				aim_targets.push_back(entity);
			}
		}

		std::sort(aim_targets.begin(), aim_targets.end(), [cmd](C_BaseEntity* a, C_BaseEntity* b)
		{
			auto dist_to_crosshair = [cmd](C_BaseEntity* t_entity)
			{
				const glm::vec3 rel_target_pos = t_entity->get_center() - localplayer->get_eye_position();
				const float pitch = glm::degrees(glm::atan(-rel_target_pos.z, hypot(rel_target_pos.x, rel_target_pos.y)));
				const float yaw = glm::degrees(glm::atan(rel_target_pos.y, rel_target_pos.x));

				const float pitch_diff = pitch - cmd->viewangles.x;
				const float yaw_diff = std::remainderf(yaw - cmd->viewangles.y, 360.f);

				return length(glm::vec3{ pitch_diff, yaw_diff, 0.f });
			};

			const float a_dist = dist_to_crosshair(a);
			const float b_dist = dist_to_crosshair(b);

			return a_dist < b_dist;
		});

		for (C_BaseEntity* entity : aim_targets)
		{
			if (model_t* model = entity->get_model())
			{
				if (studiohdr_t* studiohdr = modelinfo->get_studio_model(model))
				{
					if (mstudiohitboxset_t* set = studiohdr->get_hitbox_set(0))
					{
						if (mstudiobbox_t* head_bbox = set->get_hitbox(1))
						{
							C_TFPlayer* player = static_cast<C_TFPlayer*>(entity);
							const glm::vec3 head_position = player->get_bone_position(head_bbox->bone);

							Ray_t ray{ localplayer->get_eye_position(), head_position };
							trace_filter_t tr_filter{ { localplayer } };
							trace_t trace{};
							enginetrace->trace_ray(ray, MASK_SHOT | CONTENTS_GRATE, &tr_filter, &trace);
							if (trace.entity == player)
							{
								const glm::vec3 rel_target_pos = head_position - localplayer->get_eye_position();
								const float pitch = glm::degrees(glm::atan(-rel_target_pos.z, hypot(rel_target_pos.x, rel_target_pos.y)));
								const float yaw = glm::degrees(glm::atan(rel_target_pos.y, rel_target_pos.x));

								cmd->viewangles.x = pitch;
								cmd->viewangles.y = yaw;

								break;
							}
						}
					}
				}
			}
		}
	}

	return original(player_ptr, input_sample_time, cmd);
}

```

`hooks.h`:

```h
#pragma once

class C_TFPlayer;
class CUserCmd;

namespace hooks
{
	namespace tf_player
	{
		namespace create_move
		{
			inline bool(__thiscall* original)(C_TFPlayer* player_ptr, float input_sample_time, CUserCmd* cmd) {};
			bool __fastcall detour(C_TFPlayer* player_ptr, int32_t, float input_sample_time, CUserCmd* cmd);
		}
	}
}

```

`modelinfo.cpp`:

```cpp
#include "pch.h"
#include "modelinfo.h"

studiohdr_t* CModelInfoClient::get_studio_model(model_t* model) noexcept
{
	return call_vfunc<studiohdr_t*>(this, 28, model);
}

```

`modelinfo.h`:

```h
#pragma once

class model_t;

class mstudiobbox_t
{
public:
	int bone{};
};

class mstudiohitboxset_t
{
	std::byte _0[4]{};

public:
	int numhitboxes{};
	int hitboxindex{};
	mstudiobbox_t* get_hitbox(int hitbox) { return reinterpret_cast<mstudiobbox_t*>(reinterpret_cast<std::byte*>(this) + hitboxindex) + hitbox; }
};

class studiohdr_t
{
	std::byte _0[172]{};

public:
	int numhitboxsets{};
	int hitboxsetindex{};

	mstudiohitboxset_t* get_hitbox_set(int set) { return reinterpret_cast<mstudiohitboxset_t*>(reinterpret_cast<std::byte*>(this) + hitboxsetindex) + set; }
};

class CModelInfoClient
{
public:
	studiohdr_t* get_studio_model(model_t* model) noexcept; // 28
};

inline CModelInfoClient* modelinfo{ **reinterpret_cast<CModelInfoClient***>(find_pattern(L"client", "A1 ? ? ? ? 8B 4D ? 8B 5D") + 1) };

```

`pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

std::byte* find_pattern(const wchar_t* mod_name, const char* pattern_str)
{
	if (const HMODULE mod = GetModuleHandle(mod_name))
	{
		MODULEINFO mod_info{};
		GetModuleInformation(GetCurrentProcess(), mod, &mod_info, sizeof(MODULEINFO));

		std::vector<std::pair<std::byte, bool>> pattern{};

		std::stringstream sstream{ pattern_str };
		std::string s{};

		while (sstream >> s)
		{
			if (s.find_first_not_of('?') == std::string::npos)
			{
				pattern.emplace_back(std::byte{}, true);
			}
			else if (s.length() == 2 && std::isxdigit(s.at(0)) && std::isxdigit(s.at(1)))
			{
				pattern.emplace_back(static_cast<std::byte>(std::stoul(s, nullptr, 16)), false);
			}
		}

		const auto start = static_cast<std::byte*>(mod_info.lpBaseOfDll);
		std::byte* end = start + mod_info.SizeOfImage;

		std::byte* result = std::search(start, end, std::default_searcher(pattern.begin(), pattern.end(), [](const std::byte a, const std::pair<std::byte, bool> b)
			{
				return a == b.first || b.second;
			}));

		if (result != end)
		{
			return result;
		}
	}

	return nullptr;
}

```

`pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H

// add headers that you want to pre-compile here

// Exclude rarely-used stuff from Windows headers
#define WIN32_LEAN_AND_MEAN
// Only exposes x, y, z and w components
#define GLM_FORCE_XYZW_ONLY
// Force left handed coordinate system
#define GLM_FORCE_LEFT_HANDED

#include <windows.h>
#include <cstddef>
#include <Psapi.h>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <functional>
#include <array>
#include <MinHook.h>
#include <glm/glm.hpp>
#include <glm/ext.hpp>

std::byte* find_pattern(const wchar_t* mod_name, const char* pattern_str);

template <typename ret_ty = void, typename... args_ty>
ret_ty call_vfunc(void* class_ptr, const size_t offset, args_ty... args) noexcept
{
	return (*static_cast<ret_ty(__thiscall***)(void*, decltype(args)...)>(class_ptr))[offset](class_ptr, args...);
}

template <typename ptr_ty>
class ref_ptr_t
{
	ptr_ty** ptr{};

public:
	ref_ptr_t(ptr_ty** ptr_ptr) : ptr{ ptr_ptr } {}

	ptr_ty* operator ->() { return *ptr; }
	operator ptr_ty*() { return *ptr; }
};

#endif //PCH_H

```

`teamfortress2_internal.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33205.214
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "teamfortress2_internal", "teamfortress2_internal.vcxproj", "{EDFF3E2C-325B-4AAB-B955-A5A29DA846C9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{EDFF3E2C-325B-4AAB-B955-A5A29DA846C9}.Debug|x86.ActiveCfg = Debug|Win32
		{EDFF3E2C-325B-4AAB-B955-A5A29DA846C9}.Debug|x86.Build.0 = Debug|Win32
		{EDFF3E2C-325B-4AAB-B955-A5A29DA846C9}.Release|x86.ActiveCfg = Release|Win32
		{EDFF3E2C-325B-4AAB-B955-A5A29DA846C9}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5E732F85-83C5-4EA1-B10A-A7EF143B17BA}
	EndGlobalSection
EndGlobal

```

`teamfortress2_internal.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{edff3e2c-325b-4aab-b955-a5a29da846c9}</ProjectGuid>
    <RootNamespace>teamfortress2internal</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;TEAMFORTRESS2INTERNAL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;TEAMFORTRESS2INTERNAL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="enginetrace.h" />
    <ClInclude Include="entity.h" />
    <ClInclude Include="entitylist.h" />
    <ClInclude Include="hooks.h" />
    <ClInclude Include="modelinfo.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="usercmd.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="enginetrace.cpp" />
    <ClCompile Include="entity.cpp" />
    <ClCompile Include="entitylist.cpp" />
    <ClCompile Include="hooks.cpp" />
    <ClCompile Include="modelinfo.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`teamfortress2_internal.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="entitylist.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="entity.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hooks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="usercmd.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="entitylist.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="entity.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`usercmd.h`:

```h
#pragma once

class CUserCmd
{
	virtual void _0() = 0;

public:
	// For matching server and client commands for debugging
	int command_number{};

	// the tick the client created this command
	int tick_count{};

	// Player instantaneous view angles
	glm::vec3 viewangles{};

	// forward velocity
	float forwardmove{};
	// sideways velocity
	float sidemove{};
	// upward velocity
	float upmove{};

	// Attack button states
	int buttons{};

	// Impulse command issued
	std::byte impulse{};

	// Current weapon id
	int weaponselect{};
	int weaponsubtype{};

	// For shared random functions
	int random_seed{};
	// Only the server populates this seed
	int server_random_seed{};

	// mouse accum in x from create move
	short mousedx{};
	// mouse accum in y from create move
	short mousedy{};

	// Client only, tracks whether we've predicted this command at least once
	bool hasbeenpredicted{};
};

constexpr auto IN_ATTACK = 1 << 0;
constexpr auto IN_JUMP = 1 << 1;
constexpr auto IN_DUCK = 1 << 2;
constexpr auto IN_FORWARD = 1 << 3;
constexpr auto IN_BACK = 1 << 4;
constexpr auto IN_USE = 1 << 5;
constexpr auto IN_CANCEL = 1 << 6;
constexpr auto IN_LEFT = 1 << 7;
constexpr auto IN_RIGHT = 1 << 8;
constexpr auto IN_MOVELEFT = 1 << 9;
constexpr auto IN_MOVERIGHT = 1 << 10;
constexpr auto IN_ATTACK2 = 1 << 11;
constexpr auto IN_RUN = 1 << 12;
constexpr auto IN_RELOAD = 1 << 13;
constexpr auto IN_ALT1 = 1 << 14;
constexpr auto IN_ALT2 = 1 << 15;
// Used by client.dll for when scoreboard is held down
constexpr auto IN_SCORE = 1 << 16;
// Player is holding the speed key
constexpr auto IN_SPEED = 1 << 17;
// Player holding walk key
constexpr auto IN_WALK = 1 << 18;
// Zoom key for HUD zoom
constexpr auto IN_ZOOM = 1 << 19;
constexpr auto IN_WEAPON1 = 1 << 20;
constexpr auto IN_WEAPON2 = 1 << 21;
constexpr auto IN_BULLRUSH = 1 << 22;
constexpr auto IN_GRENADE1 = 1 << 23;
constexpr auto IN_GRENADE2 = 1 << 24;
constexpr auto IN_ATTACK3 = 1 << 25;

```