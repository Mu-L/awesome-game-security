Project Path: arc_gmh5225_Pubg-Lite-ESP_2jiw2gu8

Source Tree:

```txt
arc_gmh5225_Pubg-Lite-ESP_2jiw2gu8
├── Decrypt.h
├── DirectOverlay.h
├── Includes.h
├── Menu.h
├── Offsets.cpp
├── Offsets.h
├── Project1.sln
├── Project1.vcxproj
├── Project1.vcxproj.filters
├── Project1.vcxproj.user
├── README.md
├── Render.cpp
├── Render.h
├── Settings.h
├── Source.cpp
├── Vector.cpp
├── Vector.h
├── math.h
└── sdk.h

```

`Decrypt.h`:

```h
#pragma once
#include "Includes.h"


```

`DirectOverlay.h`:

```h
/*
	Direct2D Overlay by Coltonon
	Simple library used to make a Direct2d overlay over any application quickly.
	Simply set up your drawing loop, and initialize the overlay.

	Sample use:

-----------------------------------------------------------------------------------------
	#include "DirectOverlay.h"

	void drawLoop(int width, int height) {  // our loop to render in
		DrawString("The quick brown fox jumped over the lazy dog", 48, 100, 20, 0, 1, 1);
	}

	int main(){
		DirectOverlaySetOption(D2DOV_DRAW_FPS | D2DOV_FONT_IMPACT);	// set the font, and draw the fps
		DirectOverlaySetup(drawLoop);		// initialize our overlay
		getchar();	// The overlay operates in it's own thread, ours will continue as normal
	}
-----------------------------------------------------------------------------------------

	The #defines are settings for the window, pass them to the DirectOverlaySetOption function.
	You may OR them together '|', you must set them before calling DirectOverlaySetup.

*/

#include <Windows.h>
#include <string>

// Link the static library (make sure that file is in the same directory as this file)
#pragma comment(lib, "D2DOverlay.lib")

// Requires the targetted window to be active and the foreground window to draw.
#define D2DOV_REQUIRE_FOREGROUND	(1 << 0)

// Draws the FPS of the overlay in the top-right corner
#define D2DOV_DRAW_FPS				(1 << 1)

// Attempts to limit the frametimes so you don't render at 500fps
#define D2DOV_VSYNC					(1 << 2)

// Sets the text font to Calibri
#define D2DOV_FONT_CALIBRI			(1 << 3)

// Sets the text font to Arial
#define D2DOV_FONT_ARIAL			(1 << 4)

// Sets the text font to Courier
#define D2DOV_FONT_COURIER			(1 << 5)

// Sets the text font to Gabriola
#define D2DOV_FONT_GABRIOLA			(1 << 6)

// Sets the text font to Impact
#define D2DOV_FONT_IMPACT			(1 << 7)

// The function you call to set up the above options.  Make sure its called before the DirectOverlaySetup function
void DirectOverlaySetOption(DWORD option);

// typedef for the callback function, where you'll do the drawing.
typedef void(*DirectOverlayCallback)(int width, int height);

// Initializes a the overlay window, and the thread to run it.  Input your callback function.
// Uses the first window in the current process to target.  If you're external, use the next function
void DirectOverlaySetup(DirectOverlayCallback callbackFunction);

// Used to specify the window manually, to be used with externals.
void DirectOverlaySetup(DirectOverlayCallback callbackFunction, HWND targetWindow);

// Draws a line from (x1, y1) to (x2, y2), with a specified thickness.
// Specify the color, and optionally an alpha for the line.
void DrawLine(float x1, float y1, float x2, float y2, float thickness, float r, float g, float b, float a = 1);

// Draws a rectangle on the screen.  Width and height are relative to the coordinates of the box.  
// Use the "filled" bool to make it a solid rectangle; ignore the thickness.
// To just draw the border around the rectangle, specify a thickness and pass "filled" as false.
void DrawBox(float x, float y, float width, float height, float thickness, float r, float g, float b, float a, bool filled);

// Draws a circle.  As with the DrawBox, the "filled" bool will make it a solid circle, and thickness is only used when filled=false.
void DrawCircle(float x, float y, float radius, float thickness, float r, float g, float b, float a, bool filled);

// Allows you to draw an elipse.  Same as a circle, except you have two different radii, for width and height.
void DrawEllipse(float x, float y, float width, float height, float thickness, float r, float g, float b, float a, bool filled);

// Draw a string on the screen.  Input is in the form of an std::string.
void DrawString(std::string str, float fontSize, float x, float y, float r, float g, float b, float a = 1);
```

`Includes.h`:

```h
#ifndef INCLUDES_H
#define INCLUDES_H

#include <Windows.h>
#include <windowsx.h>
#include <winternl.h>
#include <TlHelp32.h>
#include <iostream>
#include <time.h>
#include <dwmapi.h>
#include <Psapi.h>
#include <d3d10.h>
#include <d3d9.h>
#include <d3dx9math.h>
#include <TlHelp32.h>
#include <tchar.h>
#include <stdio.h>
#include <math.h>
#include <vector>
#include <fstream>
#include <string>
#include <ShObjIdl.h>
#define pasteColor(x) x.r, x.g, x.b
#define pasteColorA(x) x.r, x.g, x.b, x.a
#if defined(__GNUC__)
typedef          long long ll;
typedef unsigned long long ull;
#define __int64 long long
#define __int32 int
#define __int16 short
#define __int8  char
#define MAKELL(num) num ## LL
#define FMT_64 "ll"
#elif defined(_MSC_VER)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "I64"
#elif defined (__BORLANDC__)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "L"
#else
#error "unknown compiler"
#endif
typedef unsigned long ulong;
typedef unsigned int uint;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
//typedef unsigned long ulong;

typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef ll              int64;
typedef ll              sint64;
typedef ull             uint64;

// Partially defined types:
#define _BYTE  uint8
#define _WORD  uint16
#define _DWORD uint32
#define _QWORD uint64
#if !defined(_MSC_VER)
#define _LONGLONG __int128
#endif

#ifndef _WINDOWS_
typedef int8 BYTE;
typedef int16 WORD;
typedef int32 DWORD;
typedef int32 LONG;
#endif
typedef int64 QWORD;
#ifndef __cplusplus
typedef int bool;       // we want to use bool in our C programs
#endif

// Some convenience macros to make partial accesses nicer
// first unsigned macros:
#define LOBYTE(x)   (*((_BYTE*)&(x)))   // low byte
#define LOWORD(x)   (*((_WORD*)&(x)))   // low word
#define LODWORD(x)  (*((_DWORD*)&(x)))  // low dword
#define HIBYTE(x)   (*((_BYTE*)&(x)+1))
#define HIWORD(x)   (*((_WORD*)&(x)+1))
#define HIDWORD(x)  (*((_DWORD*)&(x)+1))
#define BYTEn(x, n)   (*((_BYTE*)&(x)+n))
#define WORDn(x, n)   (*((_WORD*)&(x)+n))
#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)
#define BYTE2(x)   BYTEn(x,  2)
#define BYTE3(x)   BYTEn(x,  3)
#define BYTE4(x)   BYTEn(x,  4)
#define BYTE5(x)   BYTEn(x,  5)
#define BYTE6(x)   BYTEn(x,  6)
#define BYTE7(x)   BYTEn(x,  7)
#define BYTE8(x)   BYTEn(x,  8)
#define BYTE9(x)   BYTEn(x,  9)
#define BYTE10(x)  BYTEn(x, 10)
#define BYTE11(x)  BYTEn(x, 11)
#define BYTE12(x)  BYTEn(x, 12)
#define BYTE13(x)  BYTEn(x, 13)
#define BYTE14(x)  BYTEn(x, 14)
#define BYTE15(x)  BYTEn(x, 15)
#define WORD1(x)   WORDn(x,  1)
#define WORD2(x)   WORDn(x,  2)         // third word of the object, unsigned
#define WORD3(x)   WORDn(x,  3)
#define WORD4(x)   WORDn(x,  4)
#define WORD5(x)   WORDn(x,  5)
#define WORD6(x)   WORDn(x,  6)
#define WORD7(x)   WORDn(x,  7)

// now signed macros (the same but with sign extension)
#define SLOBYTE(x)   (*((int8*)&(x)))
#define SLOWORD(x)   (*((int16*)&(x)))
#define SLODWORD(x)  (*((int32*)&(x)))
#define SHIBYTE(x)   (*((int8*)&(x)+1))
#define SHIWORD(x)   (*((int16*)&(x)+1))
#define SHIDWORD(x)  (*((int32*)&(x)+1))
#define SBYTEn(x, n)   (*((int8*)&(x)+n))
#define SWORDn(x, n)   (*((int16*)&(x)+n))
#define SBYTE1(x)   SBYTEn(x,  1)
#define SBYTE2(x)   SBYTEn(x,  2)
#define SBYTE3(x)   SBYTEn(x,  3)
#define SBYTE4(x)   SBYTEn(x,  4)
#define SBYTE5(x)   SBYTEn(x,  5)
#define SBYTE6(x)   SBYTEn(x,  6)
#define SBYTE7(x)   SBYTEn(x,  7)
#define SBYTE8(x)   SBYTEn(x,  8)
#define SBYTE9(x)   SBYTEn(x,  9)
#define SBYTE10(x)  SBYTEn(x, 10)
#define SBYTE11(x)  SBYTEn(x, 11)
#define SBYTE12(x)  SBYTEn(x, 12)
#define SBYTE13(x)  SBYTEn(x, 13)
#define SBYTE14(x)  SBYTEn(x, 14)
#define SBYTE15(x)  SBYTEn(x, 15)
#define SWORD1(x)   SWORDn(x,  1)
#define SWORD2(x)   SWORDn(x,  2)
#define SWORD3(x)   SWORDn(x,  3)
#define SWORD4(x)   SWORDn(x,  4)
#define SWORD5(x)   SWORDn(x,  5)
#define SWORD6(x)   SWORDn(x,  6)
#define SWORD7(x)   SWORDn(x,  7)

#pragma warning (disable : 4018 4172 4244 4267 4996 4554 4311 4312 4700 4800 4995)
#pragma comment(lib, "D3dx9.lib")
#pragma comment(lib, "D3d9.lib")
#pragma comment( lib, "psapi.lib " )
#pragma comment( lib, "dwmapi.lib" )

#include "Vector.h"
#include "Offsets.h"
/*
#include "Vector.h"
#include "Process.h"
#include "Offsets.h"
#include "Engine.h"
#include "Entity.h"
#include "C_SpreadData.h"
#include "C_Spread.h"
#include "Aimbot.h"
#include "Math.h"
*/
#endif
```

`Menu.h`:

```h
#pragma once
#include <vector>
#include <time.h>
#include "Render.h"
#include "settings.h"
int get_frame_rate()
{
	static int i_fps, i_last_fps;
	static float fl_last_tick_count, fl_tick_count;
	fl_tick_count = clock() * 0.001f;
	i_fps++;
	if ((fl_tick_count - fl_last_tick_count) >= 1.0f)
	{
		fl_last_tick_count = fl_tick_count;
		i_last_fps = i_fps;
		i_fps = 0;
	}
	return i_last_fps;
};

class c_menu_framework
{
private:
public:
	float menu_x = 250, menu_y = 290;
	enum item_type : int {
		type_bool = 0,
		type_int = 1,
		type_float = 2
	};
	enum tab_type : int {
		type_on_off = 0,
		type_tab = 1,
		type_dont_draw = 2
	};
	static struct menu_item_t {
		std::string m_title;
		
		float* m_float;
		int* m_int;
		bool* m_bool = 0;
		int increment = 1;
		int minimum = 0;
		int maximum = 1;
		float m_float_step;
		int m_int_step;
		int m_type;
		int tab_type;

		float m_float_min;
		int m_int_min;

		float m_float_max;
		int m_int_max;

		std::string tool_tip;
	};

	//int m_total_items = 0;
	int m_current_pos = 0;
	int menu_page = 0;
	std::vector<menu_item_t> items;
public:

	void add_entry(std::string title, bool* value, int is_tab = 0, std::string tooltip = "") {
		menu_item_t m_item;
		m_item.m_title = title;
		m_item.m_bool = value;
		m_item.m_type = item_type::type_bool;
		m_item.tab_type = is_tab;
		m_item.tool_tip = tooltip;
		items.emplace_back(m_item);
	}

	template <class t>
	void add_entry(std::string title, t* value, t min, t max, t step) {
		menu_item_t m_item;
		m_item.m_title = title;
		if (std::is_same<t, float>()) {
			m_item.m_float = (float*)value;
			m_item.m_float_min = min;
			m_item.m_float_max = max;
			m_item.m_float_step = step;
			m_item.m_type = item_type::type_float;
		}
		else if (std::is_same<t, int>()) {
			m_item.m_int = (int*)value;
			m_item.m_int_min = min;
			m_item.m_int_max = max;
			m_item.m_int_step = step;
			m_item.m_type = item_type::type_int;
		}
		items.emplace_back(m_item);
	}

	void draw()
	{
		this->menu_x = settings::menux;
		this->menu_y = settings::menuy;

		static bool aimbot_tap = false;
		static bool espteam_tap = false;
		static bool espenemy_tab = false;
		static bool color_tab = false;
		static bool misc_tab = false;
		static bool menu_tab = false;
		static bool crosshair_tab = false;

		this->add_entry("AIMBOT", &aimbot_tap, true,"This Option I Thing No Safe");
		if (aimbot_tap) {
			this->add_entry("  Active", &settings::aimbot);
			this->add_entry("  Auto Lock", &settings::autolock);
			this->add_entry("  Aim Knocked", &settings::aimknocked);
			this->add_entry("  Hitbox", &settings::aimbothitbox, 0,2, 1);
			this->add_entry("  Fov", &settings::aimbotfov, 1.f, 100.f, 1.f);
			this->add_entry("  Speed", &settings::aimspeed, 1.f, 100.f, 1.f);
			this->add_entry("  Lock", &settings::aimlock, 0.f, 20.f, 0.1f);
			this->add_entry("  Draw Hitbox", &settings::aimbotdrawhitbox);
			this->add_entry("  Draw Fov", &settings::aimbotdrawfov);

		}

		this->add_entry("TEAM ESP", &espteam_tap, true);
		if (espteam_tap) {
			this->add_entry("  Boxes", &settings::teamBoxes);
			this->add_entry("  Name", &settings::teamName);
			this->add_entry("  Snaplines", &settings::teamSnaplines);
			this->add_entry("  Healthbars", &settings::teamHealth);
			this->add_entry("  Distance", &settings::teamDistance);
			this->add_entry("  FilledBox", &settings::teamFilledbox);
			this->add_entry("  Skeleton", &settings::teamskeleton);

		}

		this->add_entry("ENEMY ESP", &espenemy_tab, true);
		if (espenemy_tab) {
			this->add_entry("  Boxes", &settings::enemyBoxes);
			this->add_entry("  Name", &settings::enemyName);
			this->add_entry("  Snaplines", &settings::enemySnaplines);
			this->add_entry("  Healthbars", &settings::enemyHealth);
			this->add_entry("  Distance", &settings::enemyDistance);
			this->add_entry("  FilledBox", &settings::enemyFilledbox);
			this->add_entry("  Skeleton", &settings::enemyskeleton);

		}
		this->add_entry("CROSSHAIR", &crosshair_tab, true);
		if (crosshair_tab) {
			this->add_entry("  Enable", &settings::c_enable);
			this->add_entry("  Crosshair Style", &settings::crosshair, 0, 4, 1);
			this->add_entry("  Size", &settings::size, 1.f, 20.f, 1.f);
			this->add_entry("  Stroke", &settings::stroke, 1.f, 10.f, 1.f);

		}
		this->add_entry("SETTINGS ESP", &misc_tab, true);
		if (misc_tab) {
			this->add_entry("  ESP Outline", &settings::esp_Outline);
			this->add_entry("  Box Type", &settings::boxtype, 0, 1, 1);
			this->add_entry("  HealthBar Type", &settings::healthbartype, 0, 2, 1);
			this->add_entry("  Players Distance", &settings::playersdis, 1.f, 700.f, 20.f);


		}
		static bool colorteam_tab = false;
		this->add_entry("COLORS", &color_tab, true);
		if (color_tab) {
			static bool colorteambox_tab = false;
			this->add_entry("  Team Box", &colorteambox_tab, true);
			if (colorteambox_tab) {
				static auto prim_r = 0.f, prim_g = 0.f, prim_b = 255.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::FriendBox = D3DXCOLOR(prim_r/ 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);


			}

			static bool colorteamline_tab = false;
			this->add_entry("  Team Line", &colorteamline_tab, true);
			if (colorteamline_tab) {
				static auto prim_r = 0.f, prim_g = 0.f, prim_b = 255.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::FriendLine = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}
			static bool colorteamfillbox_tab = false;
			this->add_entry("  Team FillBox", &colorteamfillbox_tab, true);
			if (colorteamfillbox_tab) {
				static auto prim_r = 0.f, prim_g = 0.f, prim_b = 255.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::FriendFillbox = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}

			static bool colorteamskeleton_tab = false;
			this->add_entry("  Team skeleton", &colorteamskeleton_tab, true);
			if (colorteamskeleton_tab) {
				static auto prim_r = 0.f, prim_g = 0.f, prim_b = 255.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::FriendSkeleton = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}

			static bool colortenemybox_tab = false;
			this->add_entry("  Enemy Box", &colortenemybox_tab, true);
			if (colortenemybox_tab) {
				static auto prim_r = 255.f, prim_g = 0.f, prim_b = 0.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::EnemyBOX = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}

			static bool colortenemyline_tab = false;
			this->add_entry("  Enemy Line", &colortenemyline_tab, true);
			if (colortenemyline_tab) {
				static auto prim_r = 255.f, prim_g = 0.f, prim_b = 0.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::EnemyLine = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}

			static bool colortenemyfillbox_tab = false;
			this->add_entry("  Enemy Fillbox", &colortenemyfillbox_tab, true);
			if (colortenemyfillbox_tab) {
				static auto prim_r = 255.f, prim_g = 0.f, prim_b = 0.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::EnemyFillbox = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}

			static bool colortenemyskeleton_tab = false;
			this->add_entry("  Enemy Skeleton", &colortenemyskeleton_tab, true);
			if (colortenemyskeleton_tab) {
				static auto prim_r = 255.f, prim_g = 255.f, prim_b = 0.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::EnemySkeleton = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}
			static bool colorclosed_tab = false;
			this->add_entry("  CLOSED", &colorclosed_tab, true);
			if (colorclosed_tab) {
				static auto prim_r = 255.f, prim_g = 255.f, prim_b = 0.f;
				this->add_entry("    Primary Red", &prim_r, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Green", &prim_g, 0.f, 255.f, 20.f);
				this->add_entry("    Primary Blue", &prim_b, 0.f, 255.f, 20.f);
				settings::Closed = D3DXCOLOR(prim_r / 255.0f, prim_g / 255.0f, prim_b / 255.0f, 1.f);

			}


		}

		this->add_entry("MENU", &menu_tab, true);
		if (menu_tab) {
			this->add_entry("  Menu x", &settings::menux, 0.f, 2560.f, 50.f);
			this->add_entry("  Menu y", &settings::menuy, 0.f, 1440.f, 50.f);

		}

	}
	 time_t lastTime;
	bool ReadKeyOnce(unsigned int keycode, unsigned int timer) {
		if ((clock() - lastTime > timer) && GetAsyncKeyState(keycode)) {
			lastTime = clock();
			return true;
		}
		return false;
	}
	void do_menu_controls() {
		static bool show = true;
		if (show) {
			this->draw();
			static int item_gap = 14;
			static float alpha = 1.f;
			DrawBox(this->menu_x - 3, this->menu_y - 17, 154, 17, 1.f, 0.10f, 0.10f, 0.10f, alpha, true);
			DrawBox(this->menu_x - 3, this->menu_y - 17, 154, 17, 1.f, 0.4f, 0, 0.8f, alpha, false);

			DrawString("Exit/Hide End/Ins - " + std::to_string(get_frame_rate()), 12, this->menu_x + 9, this->menu_y - 18, 1.f, 1.f, 1.f, alpha);

			DrawBox(this->menu_x - 3, this->menu_y, 154, (items.size() * item_gap), 1.f, 0.12f, 0.12f, 0.12f, alpha, true);
			DrawBox(this->menu_x - 3, this->menu_y, 154, (items.size() * item_gap), 1.f, 0.4f, 0, 0.8f, alpha, false);

			DrawBox(this->menu_x - 3, this->menu_y + (item_gap * m_current_pos), 154, item_gap, 1.f, 0.10f, 0.10f, 0.10f, alpha, true);
			DrawBox(this->menu_x - 3, this->menu_y + (item_gap * m_current_pos), 154, item_gap, 1.f, 0.4f, 0, 0.8f, alpha, false);

			if (items.empty())
				return;
			if (m_current_pos > items.size())
				m_current_pos = items.size();

			if (!items[m_current_pos].tool_tip.empty()) {
				DrawBox(this->menu_x - 3, this->menu_y + (items.size() * item_gap) + 3, 154, 28, 1.0, 0.12f, 0.12f, 0.12f, alpha, true);
				DrawBox(this->menu_x - 3, this->menu_y + (items.size() * item_gap) + 3, 154, 28, 1.0, 0.4, 0.f, 0.8f, alpha, false);

				DrawString("NOTE:", 12, this->menu_x, this->menu_y + (items.size() * item_gap) + 5, 1, 1, 1, alpha);
				DrawString(items[m_current_pos].tool_tip.c_str(), 11, this->menu_x, this->menu_y + (items.size() * item_gap) + 16, 1, 1, 1, alpha);

			}

			for (auto item = 0; item < items.size(); ++item) {
				auto height = this->menu_y + (item_gap * item);
				char txt[1024];
				switch (items[item].m_type)
				{
				case item_type::type_bool: {
					D3DXCOLOR _bool = *items[item].m_bool ? D3DXCOLOR(0, 1.f, 0, alpha) : D3DXCOLOR(1.f, 0, 0, alpha);

					DrawString(items[item].m_title.c_str(), 12, this->menu_x, height, 1, 1, 1, alpha);
					if (items[item].tab_type == tab_type::type_on_off)
						DrawString(*items[item].m_bool ? "ON" : "OFF", 11, this->menu_x + 130, height, _bool.r, _bool.g, _bool.b, _bool.a);
					else if (items[item].tab_type == tab_type::type_tab)
						DrawString(*items[item].m_bool ? "[-]" : "[+]", 11, this->menu_x + 130, height, _bool.r, _bool.g, _bool.b, _bool.a);
					break;
				}
				case item_type::type_int: {
					DrawString(items[item].m_title.c_str(), 11, this->menu_x, height, 1, 1, 1, alpha);
					sprintf(txt, "%i", *items[item].m_int);
					DrawString(txt, 11, this->menu_x + 130, height, 1, 1, 1, alpha);
					break;
				}
				case item_type::type_float: {
					DrawString(items[item].m_title.c_str(), 11, this->menu_x, height, 1.f, 1.f, 1.f, alpha);
					sprintf(txt, "%.1f", *items[item].m_float);
					DrawString(txt, 11, this->menu_x + 130, height, 1, 1, 1, alpha);
					break;
				}
				default:
					break;
				}

				if (ReadKeyOnce(VK_UP,250)) {
					this->m_current_pos -= 1;
					if (this->m_current_pos < 0)
						m_current_pos = (m_current_pos > 0) ? (m_current_pos - 1) : items.size() - 1;
				}
				if (ReadKeyOnce(VK_DOWN,250)) {
					this->m_current_pos += 1;
					if (this->m_current_pos > items.size() - 1)
						this->m_current_pos = 0;
				}

				if (ReadKeyOnce(VK_LEFT, 250)) {
					switch (items[m_current_pos].m_type) {
					case item_type::type_bool: {
						if (*items[m_current_pos].m_bool == 1) {
							*items[m_current_pos].m_bool -= items[m_current_pos].increment;
							if (*items[m_current_pos].m_bool < items[m_current_pos].minimum)
								*items[m_current_pos].m_bool = items[m_current_pos].minimum;
						}
						break;
					}
					case item_type::type_int: {

						*items[m_current_pos].m_int -= items[m_current_pos].m_int_step;
						if (*items[m_current_pos].m_int < items[m_current_pos].m_int_min)
							*items[m_current_pos].m_int = items[m_current_pos].m_int_max;
						break;
					}
					case item_type::type_float: {
						*items[m_current_pos].m_float -= items[m_current_pos].m_float_step;
						if (*items[m_current_pos].m_float < items[m_current_pos].m_float_min)
							*items[m_current_pos].m_float = items[m_current_pos].m_float_max;
						break;
					}
					default:
						break;
					}

				}
				if (ReadKeyOnce(VK_RIGHT, 250)) {
					switch (items[m_current_pos].m_type) {
					case item_type::type_bool: {
						if (*items[m_current_pos].m_bool == 0) {
							*items[m_current_pos].m_bool += items[m_current_pos].increment;
							if (*items[m_current_pos].m_bool > items[m_current_pos].maximum)
								//*items[m_current_pos].m_bool = !*items[m_current_pos].m_bool;
								*items[m_current_pos].m_bool = items[m_current_pos].maximum;
						}
						break;
					}
					case item_type::type_int: {
						*items[m_current_pos].m_int += items[m_current_pos].m_int_step;
						if (*items[m_current_pos].m_int > items[m_current_pos].m_int_max)
							*items[m_current_pos].m_int = items[m_current_pos].m_int_min;
						break;
					}
					case item_type::type_float: {
						*items[m_current_pos].m_float += items[m_current_pos].m_float_step;
						if (*items[m_current_pos].m_float > items[m_current_pos].m_float_max)
							*items[m_current_pos].m_float = items[m_current_pos].m_float_min;
						break;
					}
					default:
						break;
					}


				}
			}
		}
		if (!items.empty())
			items.clear();
		if (GetAsyncKeyState(VK_INSERT)) {
			show = !show;
			Sleep(150);
		}
		if (GetAsyncKeyState(VK_END))
			exit(0);
	}

};



```

`Offsets.cpp`:

```cpp
#include "Includes.h"

HWND hGameWnd;
HWND hOverlayWnd;
RECT wndRect;

uint64 dwUWorld = 0x0;
uint64 dwLocalplayer;
uint64 dwLocalPawn;
uint64 dwLocalMesh;
uint64 dwULevel;
uint64 dwActorArray;
uint64 dwPlayerController;
uint64 dwPlayerCameraManager;
uint64 dwAnimScript;

uint64  Ulevel = 0xB80;
uint64  actorArray = 0x260;
uint64  actorCount = 0x8;
uint64  ObjectID = 0xC;
uint64  UlocalPlayer = 0x100;
uint64  UWorld = 0x44CF998;
uint64  GInstance = 0x2E0;
uint64  ULevel = 0;
uint64  GameInstance = 0;
uint64  LocalPlayer = 0;
uint64  LocalPlayerx = 0;
uint64  ActorArray = 0;
uint64  PlayerController = 0;
uint64  PlayerCamera = 0;
uint64  PlayerCameraCache = 0;
uint64  RootComponent = 0x1F0; // Actor -> RootComponent
uint64  WeaponEntityComp = 0x3C0; // STExtraWeapon -> WeaponEntityComp
uint64  ComponentVelocity = 0x160; // SceneComponent -> ComponentVelocity
uint64  RelativeLocation = 0x108; // SceneComponent -> RelativeLocation
uint64  Mesh = 0x4C8; // Character -> Mesh
uint64  TeamID = 0x818; // UAECharacter -> TeamID
uint64  PlayerName = 0x808; // UAECharacter -> PlayerName
uint64  bIsAI = 0x800; // UAECharacter -> bIsAI
uint64  PlayerKey = 0x7f0; // UAECharacter -> PlayerKey
uint64  SpectatedCount = 0x1d98; // STExtraBaseCharacter -> SpectatedCount
uint64  bIsWeaponFiring = 0x1b3c; // STExtraBaseCharacter -> bIsWeaponFiring
uint64  bHealth = 0x18e4; // STExtraBaseCharacter -> Health
uint64  HealthStatus = 0x1490; // STExtraBaseCharacter -> HealthStatus 0x1478
uint64  VehicleSeatIdx = 0x1450; // STExtraBaseCharacter -> VehicleSeatIdx
uint64  CurrentVehicle = 0x1448; // STExtraBaseCharacter -> CurrentVehicle
uint64  STCharacterMovement = 0x1138; // STExtraBaseCharacter -> STCharacterMovement
uint64  LocalSimulateStates = 0xee8; // STExtraBaseCharacter -> LocalSimulateStates
uint64  WeaponManagerComponent = 0x888; // STExtraBaseCharacter -> WeaponManagerComponent
uint64  SkydivingComponent = 0x2078; // STExtraPlayerCharacter -> SkydivingComponent
uint64  STPlayerController = 0x1F68; // STExtraPlayerCharacter -> STPlayerController 
uint64  PlayerCameraManager = 0x470; // PlayerController -> PlayerCameraManager
uint64  STExtraBaseCharacter = 0xfb0; // STExtraPlayerController -> STExtraBaseCharacter
uint64  CurrentWeaponReplicated = 0x518; // WeaponManagerComponent -> CurrentWeaponReplicated
uint64  RotationVec = 0x574; // MinimalViewInfo -> Rotation
uint64  LocationVec = 0x568; // MinimalViewInfo -> Location
uint64  FOV = 0x560; // MinimalViewInfo -> FOV
uint64  POV = 0x10; // CameraCacheEntry -> POV
uint64  RecoilMultiplierVertical = 0x2b4; // WeaponAttachmentData -> RecoilMultiplierVertical
uint64  MultipleFiringBulletsSpread = 0x70; // WeaponAttachmentData -> MultipleFiringBulletsSpread
uint64  AnimationKickMultiplier = 0x64; // WeaponAttachmentData -> AnimationKickMultiplier
uint64  SwayMultiplier = 0x60; // WeaponAttachmentData -> SwayMultiplier
uint64  JumpZVelocity = 0x1b4; // CharacterMovementComponent -> JumpZVelocity
uint64  MinWalkSpeedModifier = 0x83c; // STCharacterMovementComponent -> MinWalkSpeedModifier
uint64  WalkSpeedCurveScale = 0x82c; // STCharacterMovementComponent -> WalkSpeedCurveScale
uint64  LastRenderTime = 0x318; // PrimitiveComponent -> LastRenderTime
uint64  VehicleShapeType = 0x419; // STExtraVehicleBase -> VehicleShapeType
uint64  CameraCache = 0xF80; // PlayerCameraManager -> CameraCache
uint64  FreefallVelocitySettings = 0xac8; // TslSkydiveComponent -> FreefallVelocitySettings
uint64  ArrTslWeaponAttachmentData = 0x110; // WeaponEntity -> ArrTslWeaponAttachmentData
uint64  BulletFireSpeed = 0x638; // ShootWeaponEntity -> BulletFireSpeed
uint64  bHasAutoFireMode = 0x414; // ShootWeaponEntity -> bHasAutoFireMode
uint64  offset_boneArray = 0x6F8; //+
uint64  offset_ComponentToWorld = 0x1B0;//+
uint64  offset_LocalPawn = 0x450;
uint64  dwLineOfSightTo = 0x10BE7C0;
uint64  GNames = 0x4680CB0;
```

`Offsets.h`:

```h
#pragma once

enum EBoneIndex : int32
{
	Root = 0,
	pelvis = 1,
	spine_01 = 2,
	spine_02 = 3,
	spine_03 = 4,
	neck_01 = 5,
	Head = 6,
	hair_01 = 7,
	hair_02 = 8,
	hair_03 = 9,
	hair_04 = 10,
	R_eye = 11,
	L_eye = 12,
	camera_fpp = 13,
	clavicle_r = 14,
	upperarm_r = 15,
	lowerarm_r = 16,
	lowerarm_twist_01_r = 17,
	hand_r = 18,
	middle_01_r = 19,
	middle_02_r = 20,
	middle_03_r = 21,
	ring_01_r = 22,
	ring_02_r = 23,
	ring_03_r = 24,
	pinky_01_r = 25,
	pinky_02_r = 26,
	pinky_03_r = 27,
	index_01_r = 28,
	index_02_r = 29,
	index_03_r = 30,
	thumb_01_r = 31,
	thumb_02_r = 32,
	thumb_03_r = 33,
	item_r = 34,
	clavicle_l = 35,
	upperarm_l = 36,
	lowerarm_l = 37,
	lowerarm_twist_01_l = 38,
	hand_l = 39,
	thumb_01_l = 40,
	thumb_02_l = 41,
	thumb_03_l = 42,
	index_01_l = 43,
	index_02_l = 44,
	index_03_l = 45,
	middle_01_l = 46,
	middle_02_l = 47,
	middle_03_l = 48,
	ring_01_l = 49,
	ring_02_l = 50,
	ring_03_l = 51,
	pinky_01_l = 52,
	pinky_02_l = 53,
	pinky_03_l = 54,
	item_l = 55,
	thigh_r = 56,
	calf_r = 57,
	foot_r = 58,
	ball_r = 59,
	thigh_l = 60,
	calf_l = 61,
	foot_l = 62,
	ball_l = 63,
	ik_hand_root = 64,
	ik_hand_gun = 65,
	ik_hand_l = 66,
	ik_hand_r = 67,
	camera_tpp = 68,
	VB_Dummy = 69,
};

extern HWND hGameWnd;
extern HWND hOverlayWnd;
extern RECT wndRect;

extern uint64 dwUWorld;
extern uint64 dwLocalplayer;
extern uint64 dwLocalPawn;
extern uint64 dwLocalMesh;
extern uint64 dwULevel;
extern uint64 dwActorArray;
extern uint64 dwPlayerController;
extern uint64 dwPlayerCameraManager;
extern uint64 dwAnimScript;
extern uint64 Ulevel ;
extern uint64 actorArray ;
extern uint64 actorCount ;
extern uint64 ObjectID ;
extern uint64 UlocalPlayer ;
extern uint64 UWorld ;
extern uint64 GInstance ;
extern uint64 ULevel ;//;
extern uint64 GameInstance ;//;
extern uint64 LocalPlayer ;//;
extern uint64 LocalPlayerx ;//;
extern uint64 ActorArray ;//;
extern uint64 PlayerController ;//;
extern uint64 PlayerCamera ;//;
extern uint64 PlayerCameraCache ;//;
extern uint64 RootComponent ;//x1F0; // Actor -> RootComponent
extern uint64 WeaponEntityComp ;//x3c0; // STExtraWeapon -> WeaponEntityComp
extern uint64 ComponentVelocity ;//x160; // SceneComponent -> ComponentVelocity
extern uint64 RelativeLocation ;//x108; // SceneComponent -> RelativeLocation
extern uint64 Mesh ;//x4C8; // Character -> Mesh
extern uint64 TeamID ;//x818; // UAECharacter -> TeamID
extern uint64 PlayerName ;//x808; // UAECharacter -> PlayerName
extern uint64 bIsAI ;//x800; // UAECharacter -> bIsAI
extern uint64 PlayerKey ;//x7f0; // UAECharacter -> PlayerKey
extern uint64 SpectatedCount ;//x1d98; // STExtraBaseCharacter -> SpectatedCount
extern uint64 bIsWeaponFiring ;//x1b3c; // STExtraBaseCharacter -> bIsWeaponFiring
extern uint64 bHealth;//x18e4; // STExtraBaseCharacter -> Health
extern uint64 HealthStatus ;//x1490; // STExtraBaseCharacter -> HealthStatus 0x1478
extern uint64 VehicleSeatIdx ;//x1450; // STExtraBaseCharacter -> VehicleSeatIdx
extern uint64 CurrentVehicle ;//x1448; // STExtraBaseCharacter -> CurrentVehicle
extern uint64 STCharacterMovement ;//x1138; // STExtraBaseCharacter -> STCharacterMovement
extern uint64 LocalSimulateStates ;//xee8; // STExtraBaseCharacter -> LocalSimulateStates
extern uint64 WeaponManagerComponent ;//x888; // STExtraBaseCharacter -> WeaponManagerComponent
extern uint64 SkydivingComponent ;//x2078; // STExtraPlayerCharacter -> SkydivingComponent
extern uint64 STPlayerController ;//x1F68; // STExtraPlayerCharacter -> STPlayerController 
extern uint64 PlayerCameraManager ;//x470; // PlayerController -> PlayerCameraManager
extern uint64 STExtraBaseCharacter ;//xfb0; // STExtraPlayerController -> STExtraBaseCharacter
extern uint64 CurrentWeaponReplicated ;//x518; // WeaponManagerComponent -> CurrentWeaponReplicated
extern uint64 RotationVec ;//x574; // MinimalViewInfo -> Rotation
extern uint64 LocationVec ;//x568; // MinimalViewInfo -> Location
extern uint64 FOV ;//x560; // MinimalViewInfo -> FOV
extern uint64 POV ;//x10; // CameraCacheEntry -> POV
extern uint64 RecoilMultiplierVertical ;//x2b4; // WeaponAttachmentData -> RecoilMultiplierVertical
extern uint64 MultipleFiringBulletsSpread ;//x70; // WeaponAttachmentData -> MultipleFiringBulletsSpread
extern uint64 AnimationKickMultiplier ;//x64; // WeaponAttachmentData -> AnimationKickMultiplier
extern uint64 SwayMultiplier ;//x60; // WeaponAttachmentData -> SwayMultiplier
extern uint64 JumpZVelocity ;//x1b4; // CharacterMovementComponent -> JumpZVelocity
extern uint64 MinWalkSpeedModifier ;//x83c; // STCharacterMovementComponent -> MinWalkSpeedModifier
extern uint64 WalkSpeedCurveScale ;//x82c; // STCharacterMovementComponent -> WalkSpeedCurveScale
extern uint64 LastRenderTime ;//x318; // PrimitiveComponent -> LastRenderTime
extern uint64 VehicleShapeType ;//x419; // STExtraVehicleBase -> VehicleShapeType
extern uint64 CameraCache ;//xF80; // PlayerCameraManager -> CameraCache
extern uint64 FreefallVelocitySettings ;//xac8; // TslSkydiveComponent -> FreefallVelocitySettings
extern uint64 ArrTslWeaponAttachmentData ;//x110; // WeaponEntity -> ArrTslWeaponAttachmentData
extern uint64 BulletFireSpeed ;//x638; // ShootWeaponEntity -> BulletFireSpeed
extern uint64 bHasAutoFireMode ;//x414; // ShootWeaponEntity -> bHasAutoFireMode
extern uint64 offset_boneArray ;//x6F8; //+
extern uint64 offset_ComponentToWorld ;//x1B0;//+
extern uint64 offset_LocalPawn ;//x450;
extern uint64 dwLineOfSightTo ;//x10BE7C0;
extern uint64 GNames ;//x4680CB0;
//#pragma once
//#define Offset_UWorld 0x44CF998 //48 89 05 ? ? ? ? 48 83 C4 28 C3 B8 ? ? ? ? 48 C7 44 24 ? ? ? ? ? 66 C1 C8 08
//#define UWorld_GetCurrentLevel 0xA90
//#define UWorld_GetGameInstance 0x2E0
//#define UGameInstance_GetLocalPlayer 0x100
//#define ULevel_GetActors 0x260
//#define ULocalPlayer_GetPlayerController 0x30
//
//#define offs_uworld 0x44CF998 //48 89 05 ? ? ? ? 48 83 C4 28 C3 B8 ? ? ? ? 48 C7 44 24 ? ? ? ? ? 66 C1 C8 08
//#define offs_localplayer 0x728C0D0 //48 89 3d ? ? ? ? f2 0f 10 05 ? ? ? ?
//#define offs_gnames 0x726FA38 
//#define offs_decrypt 0x4EDEA28
//#define offs_chunk 0x3FC0 //c1 ? ? 8b ? c1 ? 1f 03 ? 69 ? ? ? ? ? 44 2b f8
//
//#define offs_PersistentLevel          0x40 //E8 ? ? ? ? 39 5C 24 48 
//#define offs_ActorsArray              0x98 //E8 ? ? ? ? 39 5C 24 48 7E 29
//#define offs_PlayerControllers        0x38
//#define Offs_LocalPawn				  0x480 //8B 90 ? ? ? ? C1 EA 04 41 84 D4
//#define offs_PlayerCameraManager      0x4A0 //41 ff 90 ? ? ? ? ? 8b ? ? ? ? ? 48 85 c9 74 ? 48 8b 01 4c 8d
//#define offs_Actor_ObjID			  0x8
//#define offs_Actor_Health			  0xC6C //0F 57 C0 0F 2F 81 ? ? ? ? 72 0C
//#define offs_Actor_RootComponent	  0x298 //E8 ? ? ? ? B0 01 48 8B 4D 00 
//#define offs_Actor_TeamNumber		  0xFB8
//#define offs_Mesh					  0x4C0 //48 8B 99 ? ? ? ? 48 ? ? 48 ? ? 0F 84 ? ? ? ? 0F 10
//#define offs_Mesh_BoneArray		      0xAD0 //F3 0F 10 81 ?? ?? ?? ?? F3 0F 10 0D ?? ?? ?? ?? 0F 2F C1
//#define offs_Mesh_ComponentToWorld    0x340 //0F 8D ? ? ? ? 0F 10 9F ? ? ? ?
//#define offs_relativepos			  0x364
//#define offs_absolutepos			  0x350 //48 85 C0 74 23 0F 10 88 ?? ?? 00 00 0F 28 C1
//#define offs_CameraRotation		      0xA10 //f2 0f 10 81 ? ? ? ? f2 41 0f 11 ? 8b 81 ? ? ? ? 41 89 ? ? c3
//#define offs_CameraLocation		      0xF94 //E8 ? ? ? ? 44 8B 8F ? ? ? ? 0F 28 D6
//#define offs_CameraFov			      0xA04 //77 08 F3 0F 10 81 ? ? ? ? C3 CC CC CC CC CC CC CC 48 89 5C 24 ?
//#define offs_UANIMINSTANCE			  0xC78
//#define offs_CONTROL_ROTATION_CP      0x6A8
//#define offs_RECOIL_ADS_ROTATION_CP   0xB48
//#define offs_LastRenderTimeOnScreen   0x778 //0F 2F 83 ? ? ? ? 0F 42 C8
//
////items
//#define offs_DroppedItem              0x1F0
//#define offs_DroppedItemGroup_Count offs_DroppedItem + 0x8
//#define offs_DroppedItemGroup_UItem   0x660 //0F B6 F8 48 85 D2 74 13 4C 8B CE 4C 8B C5 49 8B CE ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
//#define offs_UITEM_ID				  0x270
//#define offs_ITEM_PACKAGE             0x520 //48 8B 8F ? ? ? ? 48 63 D3 48 8B 14 D1 48
//
////prediction
//#define offs_WEAPONPROCESSOR 0x1630
//#define offs_EquippedWeapons 0x2B8
//#define offs_WEAPONTRAJECTORYDATA 0xED0
//#define offs_TRAJECTORYCONFIG 0xB8
//#define offs_COMPONENT_VELOCITY 0x308


```

`Project1.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30011.22
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Project1", "Project1.vcxproj", "{2A1E4141-993B-428A-8969-339FDA2D7AA0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2A1E4141-993B-428A-8969-339FDA2D7AA0}.Debug|x64.ActiveCfg = Debug|x64
		{2A1E4141-993B-428A-8969-339FDA2D7AA0}.Debug|x64.Build.0 = Debug|x64
		{2A1E4141-993B-428A-8969-339FDA2D7AA0}.Debug|x86.ActiveCfg = Debug|Win32
		{2A1E4141-993B-428A-8969-339FDA2D7AA0}.Debug|x86.Build.0 = Debug|Win32
		{2A1E4141-993B-428A-8969-339FDA2D7AA0}.Release|x64.ActiveCfg = Release|x64
		{2A1E4141-993B-428A-8969-339FDA2D7AA0}.Release|x64.Build.0 = Release|x64
		{2A1E4141-993B-428A-8969-339FDA2D7AA0}.Release|x86.ActiveCfg = Release|Win32
		{2A1E4141-993B-428A-8969-339FDA2D7AA0}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7D0FA05F-2F01-43E5-90E0-1D0718DE59C8}
	EndGlobalSection
EndGlobal

```

`Project1.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{2A1E4141-993B-428A-8969-339FDA2D7AA0}</ProjectGuid>
    <RootNamespace>Project1</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x64;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>false</ConformanceMode>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <PrecompiledHeader />
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Decrypt.h" />
    <ClInclude Include="DirectOverlay.h" />
    <ClInclude Include="math.h" />
    <ClInclude Include="Menu.h" />
    <ClInclude Include="Render.h" />
    <ClInclude Include="sdk.h" />
    <ClInclude Include="Includes.h" />
    <ClInclude Include="kRpm.h" />
    <ClInclude Include="Offsets.h" />
    <ClInclude Include="Settings.h" />
    <ClInclude Include="Vector.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Offsets.cpp" />
    <ClCompile Include="Render.cpp" />
    <ClCompile Include="Source.cpp" />
    <ClCompile Include="Vector.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Project1.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="kRpm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DirectOverlay.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Includes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="sdk.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="math.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Vector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Menu.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Settings.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Decrypt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Render.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Offsets.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Source.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Vector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Render.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Project1.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`README.md`:

```md
# Pubg Lite ESP
 D2DOvelay : https://github.com/coltonon/D2DOverlay

```

`Render.cpp`:

```cpp
#include "Render.h"

Renderer* Renderer::m_pInstance;
Renderer::Renderer()
{
}

Renderer::~Renderer()
{
}

void Renderer::DrawHorBar(int x, int y, int w, int h, float Health, float MaxHealth, D3DXCOLOR color1, D3DXCOLOR color2)
{
	if (Health <= 0)
		Health = 1;
	if (MaxHealth < Health)
		MaxHealth = 100;

	int size = (w * Health / (MaxHealth / 100)) / 100;
	DrawBox(x, y, w, h,  1.f, 0.f, 0.f, 0.f, 1.f,false);
	DrawBox(x + 1, y + 1, w - 2, h - 2, 1.f, pasteColorA(color2),true);

	if (size == w)
		DrawBox(x + 1, y + 1, size - 2, h - 2, 1.f, pasteColorA(color1),true);
	else
		DrawBox(x + 1, y + 1, size, h - 2, 1.f, pasteColorA(color1), true);
}

void Renderer::DrawVerBar(int x, int y, int w, int h, float Health, float MaxHealth, D3DXCOLOR color1, D3DXCOLOR color2)
{
	if (Health <= 0)
		Health = 1;

	if (MaxHealth < Health)
		MaxHealth = 100;
	int size = (h * Health / (MaxHealth / 100)) / 100;

	DrawBox(x, y, w, h, 1.f,0.f, 0.f, 0.f, 1.f, false);
	DrawBox(x + 1, y + 1, w - 2, h - 2, 1.f, pasteColorA(color2),true);

	if (size == h)
		DrawBox(x + 1, y + 1 + h - size, w - 2, size - 2, 1.f, pasteColorA(color1), true);
	else
		DrawBox(x + 1, y + 1 + h - size, w - 2, size, 1.f, pasteColorA(color1), true);
}
void Renderer::DrawOutlineBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness)
{
	DrawBox(x, y, w, h, thickness,0.f, 0.f, 0.f, 1.f, false);
	DrawBox(x + 1, y + 1, w - 2, h - 2, thickness, pasteColorA(color), false);
	DrawBox(x + 2, y + 2, w - 4, h - 4, thickness,0.f, 0.f, 0.f, 1.f,false);
}

void Renderer::DrawCoalBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness)
{
	int iw = w / 4;
	int ih = h / 4;
	// top
	DrawLine(x, y, x + iw, y, thickness, pasteColorA(color));					// left
	DrawLine(x + w - iw, y, x + w, y, thickness, pasteColorA(color));			// right
	DrawLine(x, y, x, y + ih, thickness, pasteColorA(color));					// top left
	DrawLine(x + w - 1, y, x + w - 1, y + ih, thickness, pasteColorA(color));	// top right
														// bottom
	DrawLine(x, y + h, x + iw, y + h, thickness, pasteColorA(color));			// left
	DrawLine(x + w - iw, y + h, x + w, y + h, thickness, pasteColorA(color));	// right
	DrawLine(x, y + h - ih, x, y + h, thickness, pasteColorA(color));			// bottom left
	DrawLine(x + w - 1, y + h - ih, x + w - 1, y + h, thickness, pasteColorA(color));	// bottom right
}

void Renderer::DrawOutlineCoalBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness)
{
	int iw = w / 4;
	int ih = h / 4;

	DrawCoalBox(x, y, w, h, D3DXCOLOR(0.f, 0.f, 0.f, 1.f));

	// top left
	DrawLine(x + 1, y + 1, x + iw, y + 1, thickness, pasteColorA(color));
	DrawLine(x + iw, y, x + iw, y + 2, thickness,0.f, 0.f, 0.f, 1.f);
	DrawLine(x + 1, y + 1, x + 1, y + ih, 1.f, pasteColorA(color));
	DrawLine(x, y + ih, x + 2, y + ih, thickness,0.f, 0.f, 0.f, 1.f);

	// top right
	DrawLine(x + w - iw, y + 1, x + w - 1, y + 1, thickness, pasteColorA(color));
	DrawLine(x + w - iw - 1, y, x + w - iw, y + 2, thickness,0.f, 0.f, 0.f, 1.f);
	DrawLine(x + w - 2, y + 1, x + w - 2, y + ih, thickness, pasteColorA(color));
	DrawLine(x + w - 2, y + ih, x + w, y + ih, thickness, 0.f, 0.f, 0.f, 1.f);

	// bottom left
	DrawLine(x + 1, y + h - ih, x + 1, y + h, thickness, pasteColorA(color));
	DrawLine(x, y + h - ih - 1, x + 2, y + h - ih - 1, thickness, 0.f, 0.f, 0.f, 1.f);
	DrawLine(x + 1, y + h - 1, x + iw, y + h - 1, thickness, pasteColorA(color));
	DrawLine(x + iw, y + h - 1, x + iw, y + h + 1, thickness,0.f, 0.f, 0.f, 1.f);

	// bottom right
	DrawLine(x + w - iw, y + h - 1, x + w - 1, y + h - 1, thickness, pasteColorA(color));
	DrawLine(x + w - iw - 1, y + h - 1, x + w - iw, y + h + 1, thickness, 0.f, 0.f, 0.f, 1.f);
	DrawLine(x + w - 2, y + h - ih, x + w - 2, y + h, thickness, pasteColorA(color));
	DrawLine(x + w - 2, y + h - ih - 1, x + w, y + h - ih - 1, thickness,0.f, 0.f, 0.f, 1.f);

	this->DrawCoalBox(x + 2, y + 2, w - 4, h - 4, D3DXCOLOR(0.f, 0.f, 0.f, 1.f));
}

void Renderer::DrawWindow(int x, int y, int w, int h, D3DXCOLOR Border, D3DXCOLOR Background)
{
	DrawBox(x, y, w, h, 1.f, pasteColorA(Border),false);
	DrawBox(x + 1, y + 1, w - 2, h - 2, 1.f,pasteColorA(Background),true);
}

void Renderer::DrawCrosshair(CrosshairStyle style, float x, float y, float size, float stroke, D3DXCOLOR color)
{
	if (style == CrosshairStyle::Dot)
	{
		DrawCircle(x, y, size,1.f, pasteColorA(color),true);
	}
	else if (style == CrosshairStyle::Plus)
	{
		DrawLine(x - size, y, x + size, y, stroke, pasteColorA(color));
		DrawLine(x, y - size, x, y + size, stroke, pasteColorA(color));
	}
	else if (style == CrosshairStyle::Cross)
	{
		DrawLine(x - size, y - size, x + size, y + size, stroke, pasteColorA(color));
		DrawLine(x + size, y - size, x - size, y + size, stroke, pasteColorA(color));
	}
	else if (style == CrosshairStyle::Gap)
	{
		DrawLine(x - size - stroke, y, x - stroke, y, stroke, pasteColorA(color));
		DrawLine(x + size + stroke, y, x + stroke, y, stroke, pasteColorA(color));
		DrawLine(x, y - size - stroke, x, y - stroke, stroke, pasteColorA(color));
		DrawLine(x, y + size + stroke, x, y + stroke, stroke, pasteColorA(color));
	}
	else if (style == CrosshairStyle::Diagonal)
	{
		DrawLine(x - size, y - size, x + size, y + size, stroke, pasteColorA(color));
		DrawLine(x + size, y - size, x - size, y + size, stroke, pasteColorA(color));
	}

}

Renderer* Renderer::GetInstance()
{
	if (!m_pInstance)
		m_pInstance = new Renderer();

	return m_pInstance;
}
```

`Render.h`:

```h
#pragma once
#include "Includes.h"
#include "DirectOverlay.h"

class Renderer
{
public:
	static Renderer* GetInstance();
private:
	Renderer();
	~Renderer();
public:
	enum CrosshairStyle
	{
		Dot,
		Plus,
		Cross,
		Gap,
		Diagonal,
	};

	void DrawHorBar(int x, int y, int w, int h, float Health, float MaxHealth, D3DXCOLOR color1, D3DXCOLOR color2);
	void DrawVerBar(int x, int y, int w, int h, float Health, float MaxHealth, D3DXCOLOR color1, D3DXCOLOR color2);
	void DrawOutlineBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness = 1.0f);
	void DrawCoalBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness = 1.0f);
	void DrawOutlineCoalBox(int x, int y, int w, int h, D3DXCOLOR color, float thickness = 1.0f);
	void DrawWindow(int x, int y, int w, int h, D3DXCOLOR Border, D3DXCOLOR Background);

	void DrawCrosshair(CrosshairStyle style, float x, float y, float size, float stroke, D3DXCOLOR color);
private:
	static Renderer* m_pInstance;
};
```

`Settings.h`:

```h
#pragma once
#include "Includes.h"

namespace settings {
	D3DXCOLOR FriendBox = D3DXCOLOR(0, 0, 1, 1);
	D3DXCOLOR EnemyBOX = D3DXCOLOR(1, 0, 0, 1);

	D3DXCOLOR FriendSkeleton = D3DXCOLOR(0, 0, 1, 1);
	D3DXCOLOR EnemySkeleton = D3DXCOLOR(1, 1, 0, 1);

	D3DXCOLOR FriendLine = D3DXCOLOR(0, 0, 1, 1);
	D3DXCOLOR EnemyLine = D3DXCOLOR(1, 0, 0, 1);

	D3DXCOLOR FriendFillbox = D3DXCOLOR(0, 0, 1, 1);
	D3DXCOLOR EnemyFillbox = D3DXCOLOR(1, 0, 0, 1);

	D3DXCOLOR Closed = D3DXCOLOR(1, 1, 0, 1);

	D3DXCOLOR boot = D3DXCOLOR(0, 0.5, 0.5, 1);

	bool teamBoxes = false;
	bool enemyBoxes = true;
	bool teamName = false;
	bool enemyName = false;
	bool teamDistance = false;
	bool enemyDistance = true;
	bool teamSnaplines = false;
	bool enemySnaplines = true;
	bool teamHealth = false;
	bool enemyHealth = true;
	bool teamFilledbox = false;
	bool enemyFilledbox = false;
	bool teamskeleton = false;
	bool enemyskeleton = false;

	bool aimbot = true;
	bool autolock = false;
	bool aimknocked = false;
	int aimbothitbox = 2;
	float aimspeed = 30;
	float aimbotfov = 9;
	float aimlock = 0.6;
	bool aimbotdrawfov = true;
	bool aimbotdrawhitbox = true;

	bool c_enable = true;
	int crosshair = 6;
	float size = 0;
	float stroke = 0;

	bool esp_Outline = 1;
	int boxtype = 0;
	int healthbartype = 0;
	float playersdis = 250;

	float menux = 0;
	float menuy = 400;

}

```

`Source.cpp`:

```cpp
#include "SDK.h"
#include "Menu.h"
#include <list>
#define checkSetting(teamval, enemyval) (((gm.LocalPlayer.Team == player.Team) && teamval) || ((gm.LocalPlayer.Team != player.Team) && enemyval))
#define pasteColor(x) x.r, x.g, x.b
#define pasteColorA(x) x.r, x.g, x.b, x.a
LPCSTR FilePath = "./Settings.ini";

c_menu_framework* menu_framework = new c_menu_framework;

std::vector<uint64> Players;

static class Text
{
public:
	std::string text;
	int side;
	int size;
	D3DXCOLOR color;
	Text(std::string text, int side, int size, D3DXCOLOR color) : text(text), side(side), size(size), color(color) {}
};

void ShellTaskmanager()
{
	ITaskbarList* pTaskList = NULL;
	HRESULT initRet = CoInitialize(NULL);
	HRESULT createRet = CoCreateInstance(CLSID_TaskbarList,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_ITaskbarList,
		(LPVOID*)&pTaskList);

	if (createRet == S_OK)
	{

		pTaskList->DeleteTab(GetConsoleWindow());

		pTaskList->Release();
	}

	CoUninitialize();
}
void Crosshair()
{
	switch (settings::crosshair)
	{
	case Renderer::CrosshairStyle::Dot:
		Renderer::GetInstance()->DrawCrosshair(Renderer::CrosshairStyle::Dot, S_width / 2, S_height / 2, settings::size, settings::stroke, D3DXCOLOR(0.f, 1.f, 0.f, 1.f));
		break;
	case Renderer::CrosshairStyle::Plus:
		Renderer::GetInstance()->DrawCrosshair(Renderer::CrosshairStyle::Plus, S_width / 2, S_height / 2, settings::size, settings::stroke, D3DXCOLOR(0.f, 1.f, 0.f, 1.f));
		break;
	case Renderer::CrosshairStyle::Cross:
		Renderer::GetInstance()->DrawCrosshair(Renderer::CrosshairStyle::Cross, S_width / 2, S_height / 2, settings::size, settings::stroke, D3DXCOLOR(0.f, 1.f, 0.f, 1.f));
		break;
	case Renderer::CrosshairStyle::Gap:
		Renderer::GetInstance()->DrawCrosshair(Renderer::CrosshairStyle::Gap, S_width / 2, S_height / 2, settings::size, settings::stroke, D3DXCOLOR(0.f, 1.f, 0.f, 1.f));
		break;
	case Renderer::CrosshairStyle::Diagonal:
		Renderer::GetInstance()->DrawCrosshair(Renderer::CrosshairStyle::Diagonal, S_width / 2, S_height / 2, settings::size, settings::stroke, D3DXCOLOR(0.f, 1.f, 0.f, 1.f));
		break;
	default:
		break;
	}
}
DWORD WINAPI TIMER(LPVOID p)
{

	while (true)
	{
		dwUWorld = rpm.read<uint64>(GameModule + UWorld);
		ULevel = Decrypt::ULevelDec(Ulevel);//0xB80
		ActorArray = Decrypt::DecryptActors(rpm.read<uint64>(ULevel + actorArray));
		for (size_t i = 0; i < 1400; i++)
		{
			uint64 Entity = rpm.read<uint64>(rpm.read<uint64>(ActorArray) + i * 0x8);
			uint64 objectID = Decrypt::ObjID(rpm.read<uint64>(Entity + 0xC));
			std::string ObjectName = Decrypt::GetGNamesByObjID(objectID);

			if (ObjectName == "BP_PlayerRifleBulletImpact_C")
				continue;

			if (ObjectName.find("BP_Player") != 0)
				continue;

			Players.push_back(Entity);
		}
		for (int i = 0; i < 1400; i++)
			Paddr[i] = 0;
		PlayerNum = Players.size();
		for (int i = 0; i < PlayerNum; i++)
			Paddr[i] = Players[i];
		
		Players.clear();
	}
	return 1;
}
void DrawSkeleton(Player pPlayer, Manager GM, D3DXCOLOR clr)
{
	std::list<int> upper_part = { EBoneIndex::neck_01, EBoneIndex::Head };
	std::list<int> right_arm = { EBoneIndex::neck_01, EBoneIndex::upperarm_r, EBoneIndex::lowerarm_r, EBoneIndex::hand_r };
	std::list<int> left_arm = { EBoneIndex::neck_01, EBoneIndex::upperarm_l, EBoneIndex::lowerarm_l, EBoneIndex::hand_l };
	std::list<int> spine = { EBoneIndex::neck_01, EBoneIndex::spine_01, EBoneIndex::spine_02, EBoneIndex::pelvis };
	std::list<int> lower_right = { EBoneIndex::pelvis, EBoneIndex::thigh_r, EBoneIndex::calf_r, EBoneIndex::foot_r };
	std::list<int> lower_left = { EBoneIndex::pelvis, EBoneIndex::thigh_l, EBoneIndex::calf_l, EBoneIndex::foot_l };
	std::list<std::list<int>> skeleton = { upper_part, right_arm, left_arm, spine, lower_right, lower_left };

	FVector neckpos = pPlayer.GetBoneWithRotation( EBoneIndex::neck_01);
	FVector pelvispos = pPlayer.GetBoneWithRotation( EBoneIndex::pelvis);
	FVector previous(0, 0, 0);
	FVector current, p1, c1;

	for (auto a : skeleton)
	{
		previous = FVector(0, 0, 0);

		for (int bone : a)
		{
			current = bone == EBoneIndex::neck_01 ? neckpos : (bone == EBoneIndex::pelvis ? pelvispos : pPlayer.GetBoneWithRotation(bone));
			if (previous.X == 0.f)
			{
				previous = current;
				continue;
			}
			p1 = GM.WorldToScreen( previous);
			c1 = GM.WorldToScreen( current);

			DrawLine(p1.X, p1.Y, c1.X, c1.Y,1, pasteColor(clr));
			previous = current;
		}
	}
}
void CoutOffset(LPCSTR name, DWORD offset)
{
	std::cout << "[" << name << "]" << " = 0x" << std::uppercase << std::hex << offset << std::endl;
}
void Coutfloat(LPCSTR name, float option)
{
	std::cout << "[" << name << "]" << " = " << std::dec << option << std::endl;
}

void Coutbool(LPCSTR name, int boolean)
{
	if (boolean == 1)
		std::cout << "[" << name << "]" << " = " << "ON" << std::endl;
	else
		std::cout << "[" << name << "]" << " = " << "OFF" << std::endl;
}
float ReadConfig(LPCSTR Option, bool Float)
{
	if (Float)
	{
		char cfg[10];
		GetPrivateProfileString(TEXT("Config"), Option, TEXT("0"), cfg, 10, FilePath);
		float opt = atof(cfg);
		return opt;
	}
	else
		return GetPrivateProfileInt(TEXT("Config"), Option, NULL, FilePath);
}
DWORD ReadInt(LPCTSTR Offsetname)
{
	DWORD Offset = GetPrivateProfileInt(TEXT("Offsets"), Offsetname, NULL, FilePath);
	CoutOffset(Offsetname, Offset);
	return Offset;
}
void ReadSettings()
{
	settings::aimbot = ReadConfig(TEXT("Active"), false);
	settings::autolock = ReadConfig(TEXT("AutoLock"), false);
	settings::aimknocked = ReadConfig(TEXT("AimKnocket"), false);
	settings::aimbothitbox = ReadConfig(TEXT("HitBox"), true);
	settings::aimspeed = ReadConfig(TEXT("AimSpeed"), true);
	settings::aimbotfov = ReadConfig(TEXT("Fov"), true);
	settings::aimlock = ReadConfig(TEXT("aimlock"), true);

	settings::aimbotdrawfov = ReadConfig(TEXT("DrawFov"), false);
	settings::aimbotdrawhitbox = ReadConfig(TEXT("DrawHitBox"), false);

	settings::teamBoxes = ReadConfig(TEXT("TeamBox"), false);
	settings::teamDistance = ReadConfig(TEXT("TeamDistance"), false);
	settings::teamSnaplines = ReadConfig(TEXT("TeamSnaplines"), false);
	settings::teamHealth = ReadConfig(TEXT("TeamHealth"), false);
	settings::teamFilledbox = ReadConfig(TEXT("TeamFilledbox"), false);
	settings::teamskeleton = ReadConfig(TEXT("TeamSkeleton"), false);

	settings::enemyBoxes = ReadConfig(TEXT("EnemyBoxes"), false);
	settings::enemyDistance = ReadConfig(TEXT("EnemyDistance"), false);
	settings::enemySnaplines = ReadConfig(TEXT("EnemySnaplines"), false);
	settings::enemyHealth = ReadConfig(TEXT("EnemyHealth"), false);
	settings::enemyFilledbox = ReadConfig(TEXT("EnemyFilledbox"), false);
	settings::enemyskeleton = ReadConfig(TEXT("EnemySkeleton"), false);

	settings::c_enable = ReadConfig(TEXT("CrosshairEnable"), false);
	settings::crosshair = ReadConfig(TEXT("CrosshairStyle"), true);
	settings::size = ReadConfig(TEXT("Size"), true);
	settings::stroke = ReadConfig(TEXT("Stroke"), true);

	settings::esp_Outline = ReadConfig(TEXT("Outline"), false);
	settings::boxtype = ReadConfig(TEXT("BoxType"), true);
	settings::healthbartype = ReadConfig(TEXT("HealthbarType"), true);
	settings::playersdis = ReadConfig(TEXT("PlayersDis"), true);

	settings::menux = ReadConfig(TEXT("MenuX"), true);
	settings::menuy = ReadConfig(TEXT("MenuY"), true);

	std::cout << std::endl << std::endl;
	std::cout << "AIMBOT" << std::endl << std::endl;
	Coutbool(TEXT("Active"), settings::aimbot);
	Coutbool(TEXT("AutoLock"), settings::autolock);
	Coutbool(TEXT("AimKnocket"), settings::aimknocked);
	Coutfloat(TEXT("HitBox"), settings::aimbothitbox);
	Coutfloat(TEXT("AimSpeed"), settings::aimspeed);
	Coutfloat(TEXT("Fov"), settings::aimbotfov);
	Coutfloat(TEXT("Lock"), settings::aimlock);
	Coutbool(TEXT("DrawFov"), settings::aimbotdrawfov);
	Coutbool(TEXT("DrawHitBox"), settings::aimbotdrawhitbox);

	std::cout << std::endl << std::endl;
	std::cout << "TEAM ESP" << std::endl << std::endl;
	Coutbool(TEXT("Box"), settings::teamBoxes);
	Coutbool(TEXT("Distance"), settings::teamDistance);
	Coutbool(TEXT("Snaplines"), settings::teamSnaplines);
	Coutbool(TEXT("Health"), settings::teamHealth);
	Coutbool(TEXT("Filledbox"), settings::teamFilledbox);
	Coutbool(TEXT("TeamSkeleton"), settings::teamskeleton);

	std::cout << std::endl << std::endl;
	std::cout << "ENEMY ESP" << std::endl << std::endl;
	Coutbool(TEXT("Box"), settings::enemyBoxes);
	Coutbool(TEXT("Distance"), settings::enemyDistance);
	Coutbool(TEXT("Snaplines"), settings::enemySnaplines);
	Coutbool(TEXT("Health"), settings::enemyHealth);
	Coutbool(TEXT("Filledbox"), settings::enemyFilledbox);
	Coutbool(TEXT("EnemySkeleton"), settings::enemyskeleton);

	std::cout << std::endl << std::endl;
	std::cout << "CROSSHAIR" << std::endl << std::endl;
	Coutbool(TEXT("CrosshairEnable"), settings::c_enable);
	Coutfloat(TEXT("CrosshairStyle"), settings::crosshair);
	Coutfloat(TEXT("Size"), settings::size);
	Coutfloat(TEXT("stroke"), settings::stroke);

	std::cout << std::endl << std::endl;
	std::cout << "SETTINGS ESP" << std::endl << std::endl;
	Coutbool(TEXT("Outline"), settings::esp_Outline);
	Coutfloat(TEXT("BoxType"), settings::boxtype);
	Coutfloat(TEXT("HealthbarType"), settings::healthbartype);
	Coutfloat(TEXT("PlayersDis"), settings::healthbartype);

	std::cout << std::endl << std::endl;
	std::cout << "MENU" << std::endl << std::endl;
	Coutfloat(TEXT("MenuX"), settings::menux);
	Coutfloat(TEXT("MenuY"), settings::menuy);
	std::cout << std::endl << std::endl;
}

void drawLoop(int width, int height)
{

	menu_framework->do_menu_controls();
	if (settings::c_enable)
		Crosshair();

	Manager gm(width, height);
	for (Player& player : gm.Players) {
		FVector footLocation = player.Location;
		FVector headLocation = player.Head;
		FVector ofootLocation;
		FVector oheadLocation;
		D3DXCOLOR PlayerBox = D3DXCOLOR();
		D3DXCOLOR PlayerLine = D3DXCOLOR();
		D3DXCOLOR PlayerFillBox = D3DXCOLOR();
		D3DXCOLOR PlayerSkeleton = D3DXCOLOR();

		if (player.Team == gm.LocalPlayer.Team) {
			PlayerBox = settings::FriendBox;
			PlayerLine = settings::FriendLine;
			PlayerFillBox = settings::FriendFillbox;
			PlayerSkeleton = settings::FriendSkeleton;

		}
		else {
			if (player.Distance < 80) {

				PlayerBox = settings::Closed;
				PlayerLine = settings::Closed;
				PlayerFillBox = settings::Closed;
				PlayerSkeleton = settings::Closed;

			}
			else {
				PlayerBox = settings::EnemyBOX;
				PlayerLine = settings::EnemyLine;
				PlayerFillBox = settings::EnemyFillbox;
				PlayerSkeleton = settings::EnemySkeleton;

			}
		}
		if (player.Team != gm.LocalPlayer.Team) {

			if (gm.ClosestVisibleEnemy.Distance < 80)
			{
				DrawBox((S_width / 2) - 30, 170, 220, 50, 1, 0, 0, 0, 0.5, true);
				DrawString("Enemy Closed " + std::to_string((int)gm.ClosestVisibleEnemy.Distance) + "m", 20, S_width / 2, 180, 1.f, 0.f, 0.f, 1.f);
			}

		}
		ofootLocation = gm.WorldToScreen(footLocation);
		oheadLocation = gm.WorldToScreen( headLocation);
		float w2sHeight = Distance3D(ofootLocation, oheadLocation);
		float w2sWidth = w2sHeight;
		float heightoffset = Distance3D(ofootLocation, oheadLocation);
		float H = w2sHeight;
		float W = H / 2;
		float X = oheadLocation.X - W / 2;
		std::vector< Text > texts;

		if (player.Distance > settings::playersdis) continue;
		if (player.IsAbot)
		{
			PlayerBox = settings::boot;
			PlayerLine = settings::boot;
			PlayerFillBox = settings::boot;

		}
		else
		{
			if checkSetting(settings::teamSnaplines, settings::enemySnaplines) {
				DrawLine(S_width / 2, 0, oheadLocation.X, oheadLocation.Y, 1, pasteColorA(PlayerLine));
			}
			if checkSetting(settings::teamBoxes, settings::enemyBoxes) {
				if (settings::boxtype == 0)
				{
					if (!settings::esp_Outline)
						DrawBox(X, oheadLocation.Y, W, H, 2.f, pasteColorA(PlayerBox), false);
					else if (settings::esp_Outline)
						Renderer::GetInstance()->DrawOutlineBox(X, oheadLocation.Y, W, H, PlayerBox, 2.f);

				}
				else
				{
					if (!settings::esp_Outline)
						Renderer::GetInstance()->DrawCoalBox(X, oheadLocation.Y, W, H, PlayerBox, 2.f);
					else if (settings::esp_Outline)
						Renderer::GetInstance()->DrawOutlineCoalBox(X, oheadLocation.Y, W, H, PlayerBox, 2.f);

				}
			}

			if checkSetting(settings::teamFilledbox, settings::enemyFilledbox) {
				DrawBox(X, oheadLocation.Y, W, H, 1, pasteColor(PlayerFillBox), 0.1, true);

			}

			if checkSetting(settings::teamskeleton, settings::enemyskeleton) {
				DrawSkeleton(player, gm, PlayerSkeleton);
			}
			if checkSetting(settings::teamHealth, settings::enemyHealth) {
				if (settings::healthbartype == 0)
					Renderer::GetInstance()->DrawHorBar(X, oheadLocation.Y - 6, W, 4, (int)player.Health, 120, D3DXCOLOR(.48f, .98f, 0.f, 1.f), D3DXCOLOR(1.f, 0.f, 0.f, 1.f));
				else if (settings::healthbartype == 1)
					Renderer::GetInstance()->DrawVerBar(X - 6, oheadLocation.Y, 4, H, (int)player.Health, 120, D3DXCOLOR(.48f, .98f, 0.f, 1.f), D3DXCOLOR(1.f, 0.f, 0.f, 1.f));
				else
					texts.push_back(Text("Health " + std::to_string((int)player.Health) + "%", 2, 9, D3DXCOLOR(.48f, .98f, 0.f, 1.f)));

			}

			if checkSetting(settings::teamDistance, settings::enemyDistance) {

				texts.push_back(Text(std::to_string((int)player.Distance) + "m", 1, 9, D3DXCOLOR(1.f, 1.f, 1.f, 1.f)));
			}
			if checkSetting(settings::teamName, settings::enemyName) {

				texts.push_back(Text(player.Name(), 0, 9, D3DXCOLOR(1.f, 1.f, 1.f, 1.f)));
			}
		}
		int middle[3] = { ofootLocation.Y,ofootLocation.Y, ofootLocation.X - ofootLocation.Y };
		int Top[3] = { oheadLocation.Y,oheadLocation.X, oheadLocation.X - oheadLocation.Y };
		for (auto text : texts)
		{
			int fontsize = text.size;
			float offset = (text.text.length() * fontsize) / 5;
			switch (text.side)
			{
			case 0:
				DrawString(text.text.c_str(), text.size, oheadLocation.X - offset, Top[1] - (heightoffset / 4) - fontsize, text.color.r, text.color.g, text.color.b);
				Top[1] -= fontsize;
				break;
			case 1:
				DrawString(text.text.c_str(), text.size, ofootLocation.X - offset, middle[1] + fontsize, text.color.r, text.color.g, text.color.b);
				middle[1] += fontsize;
				break;
			case 2:
				DrawString(text.text.c_str(), text.size, oheadLocation.X + (heightoffset / 4) + fontsize, Top[1] - fontsize, text.color.r, text.color.g, text.color.b);
				Top[1] += fontsize;
				break;
			}

		}



	}

	if ((Inputs::keydown(VK_LBUTTON) || settings::autolock) && settings::aimbot)
	{

		FVector BONE = FVector();
		std::vector<int> HitBoxesToScan{};
		switch (settings::aimbothitbox)
		{
		case 0:
			HitBoxesToScan.push_back(EBoneIndex::Head);
			break;
		case 1:
			HitBoxesToScan.push_back(EBoneIndex::neck_01);
			break;
		case 2:
			HitBoxesToScan.push_back(EBoneIndex::spine_01);
			break;
		default:
			break;
		}
		for (auto hitbox : HitBoxesToScan)
		{
			if (hitbox != -1)
			{
				BONE = gm.ClosestCrosshairEnemy.GetBoneWithRotation(hitbox);

					FVector Hitbox = CalcSoldierFuturePos(FVector(BONE.X, BONE.Y, BONE.Z));
					if (GetCrossDistance(Hitbox.X, Hitbox.Y, S_width / 2, S_height / 2) <= settings::aimbotfov * 8)
					{
						auto roundPos = D3DXVECTOR2((float)round(Hitbox.X), (float)round(Hitbox.Y));
						AimAtPosV2(roundPos.x, roundPos.y, settings::aimspeed, false);
						if (settings::aimbotdrawhitbox)
							DrawCircle(roundPos.x, roundPos.y, 3, 3, 1.f, 0.f, 0.f, 1.f, true);

					}
				
			}
		}
	}

	if (settings::aimbotdrawfov)
		DrawCircle(S_width / 2, S_height / 2, settings::aimbotfov * 8, 1, 1.f, 1.f, 1.f, 1.f, false);

}

int main()
{
	ShellTaskmanager();
	//::ShowWindow(::GetConsoleWindow(), SW_HIDE);
	std::cout << "Pubg Lite ESP by Zakaria" << std::endl;
	std::cout << "Initializing Overlay" << std::endl;
	std::cout << "Load Config" << std::endl;
	ReadSettings();
	 GameModule = rpm.KGetImageBase();
	 std::cout << std::hex << GameModule << std::endl;
//	DirectOverlaySetOption(D2DOV_REQUIRE_FOREGROUND);
	 CloseHandle(CreateThread(0, 0, TIMER, 0, 0, 0));
	DirectOverlaySetup(drawLoop, FindWindow(NULL, "PUBG LITE "));
	std::cout << std::endl << std::endl;

	getchar();
	return 1;
}
```

`Vector.cpp`:

```cpp
#include	"Includes.h"


/*
-=-=-=
Colors
-=-=-=
*/
//Color 		CMath::colorBlack			=	Color ( 0,		0,			0,		255	);
//Color 		CMath::colorRed				=	Color ( 200,	0,			0,		255	);
//Color 		CMath::colorGreen			=	Color ( 0,		255,		0,		255	);
//Color 		CMath::colorBlue			=	Color ( 0,		0,			255,	255	);
//Color 		CMath::colorYellow			=	Color ( 255,	255,		0,		255	);
//Color 		CMath::colorOrange			=	Color ( 230,	165,		0,		255	);
//Color 		CMath::colorMagenta			=	Color ( 255,	0,			255,	255	);
//Color 		CMath::colorCyan			=	Color ( 0,		255,		255,	255	);
//Color 		CMath::colorWhite			=	Color ( 255,	255,		255,	255	);
//Color 		CMath::colorLtGrey			=	Color ( 191,	191,		191,	255	);
//Color 		CMath::colorMdGrey			=	Color ( 127,	127,		127,	255	);
//Color 		CMath::colorDkGrey			=	Color ( 63,		63,			63,		255	);
//Color 		CMath::colorMenuHover		=	Color ( 255,	255,		255,	76	);
//Color 		CMath::colorMenuBackground	=	Color ( 20,		20,			20,		155	);//Color ( 0,		0,			0,		76	);
//Color 		CMath::colorAdvert			=	Color ( 255,	255,		0,		127	);
//
///*Color 		CMath::colorBlack_			=	Color ( 0,		0,			0,		155	);
//Color 		CMath::colorRed_			=	Color ( 255,	0,			0,		155	);
//Color 		CMath::colorGreen_			=	Color ( 0,		255,		0,		155	);
//Color 		CMath::colorBlue_			=	Color ( 0,		0,			255,	155	);
//Color 		CMath::colorYellow_			=	Color ( 255,	255,		0,		155	);
//Color 		CMath::colorOrange_			=	Color ( 255,	127,		0,		155	);
//Color 		CMath::colorMagenta_		=	Color ( 255,	0,			255,	155	);
//Color 		CMath::colorCyan_			=	Color ( 0,		255,		255,	155	);
//Color 		CMath::colorWhite_			=	Color ( 255,	255,		255,	155	);
//Color 		CMath::colorLtGrey_			=	Color ( 191,	191,		191,	155	);
//Color 		CMath::colorMdGrey_			=	Color ( 127,	127,		127,	155	);
//Color 		CMath::colorDkGrey_			=	Color ( 63,		63,			63,		155	);*/
//Color 		CMath::colorBlack_			=	Color ( 0,		0,			0,		255	);
//Color 		CMath::colorRed_			=	Color ( 200,	0,			0,		150	);
//Color 		CMath::colorGreen_			=	Color ( 0,		255,		0,		255	);
//Color 		CMath::colorBlue_			=	Color ( 0,		0,			255,	150	);
//Color 		CMath::colorYellow_			=	Color ( 200,	255,		0,		255	);
//Color 		CMath::colorOrange_			=	Color ( 200,	127,		0,		255	);
//Color 		CMath::colorMagenta_		=	Color ( 200,	0,			255,	255	);
//Color 		CMath::colorCyan_			=	Color ( 0,		255,		255,	255	);
//Color 		CMath::colorWhite_			=	Color ( 255,	255,		255,	150	);
//Color 		CMath::colorLtGrey_			=	Color ( 191,	191,		191,	255	);
//Color 		CMath::colorMdGrey_			=	Color ( 127,	127,		127,	255	);
//Color 		CMath::colorDkGrey_			=	Color ( 63,		63,			63,		255	);
FVector FVec;
Color::Color ()
{
	this->R = 0.0f;
	this->G = 0.0f;
	this->B = 0.0f;
	this->A = 0.0f;
}

Color::Color ( int _R, int _G, int _B, int _A )
{
	this->R = ( _R / 255.0f );
	this->G = ( _G / 255.0f );
	this->B = ( _B / 255.0f );
	this->A = ( _A / 255.0f );
}

Color::Color ( float _R, float _G, float _B  )
{
	this->R = _R;
	this->G = _G;
	this->B = _B;
	this->A = 1.0f;
}

float Color::GetRed ()
{
	return this->R;
}

float Color::GetGreen ()
{
	return this->G;
}

float Color::GetBlue ()
{
	return this->B;
}

float Color::GetAlpha ()
{
	return this->A;
}

void Color::SetRed ( float _R )
{
	this->R = _R;
}

void Color::SetGreen ( float _G )
{
	this->G = _G;
}

void Color::SetBlue ( float _B )
{
	this->B = _B;
}

void Color::SetAlpha ( float _A )
{
	this->A = _A;
}

void Color::SetRed ( int _R )
{
	this->R = ( _R / 255.0f );
}

void Color::SetGreen ( int _G )
{
	this->G = ( _G / 255.0f );
}

void Color::SetBlue ( int _B )
{
	this->B = ( _B / 255.0f );
}

void Color::SetAlpha ( int _A )
{
	this->A = ( _A / 255.0f );
}

FRotator::FRotator ()
{
	this->Pitch = 0.0f;
	this->Yaw	= 0.0f;
	this->Roll	= 0.0f;
}

FRotator::FRotator ( float _Pitch, float _Yaw, float _Roll )
{
	this->Pitch = _Pitch;
	this->Yaw 	= _Yaw;
	this->Roll 	= _Roll;
}

float FRotator::GetPitch ()
{
	return this->Pitch;
}

float FRotator::GetYaw ()
{
	return this->Yaw;
}

float FRotator::GetRoll ()
{
	return this->Roll;
}

void FRotator::Normalize ()
{
	while ( this->Yaw > 180.0f )
		this->Yaw -= 360.0f;

	while ( this->Yaw < -180.0f )
		this->Yaw += 360.0f;

	while ( this->Pitch > 180.0f )
		this->Pitch -= 360.0f;

	while ( this->Pitch < -180.0f )
		this->Pitch += 360.0f;
}

FRotator FRotator::operator+ ( const FRotator &A )
{
	return FRotator( this->Pitch + A.Pitch, this->Yaw + A.Yaw, this->Roll + A.Roll );
}

FRotator FRotator::operator- ( const FRotator &A )
{
	return FRotator( this->Pitch - A.Pitch, this->Yaw - A.Yaw, this->Roll - A.Roll );
}

FVector FRotator::ToVector ()
{
	float angle, sr, sp, sy, cr, cp, cy;

	angle = this->Yaw * ( M_PI * 2 / 360 );
	sy = sin( angle );
	cy = cos( angle );

	angle = this->Pitch * ( M_PI * 2 / 360 );
	sp = sin( angle );
	cp = cos( angle );

	angle = this->Roll * ( M_PI * 2 / 360 );
	sr = sin( angle );
	cr = cos( angle );

	return FVector( cp * cy, cp * sy, -sp );
}

void FRotator::GetVectors ( FVector* Forward, FVector* Right, FVector* Up )
{
	static float sr, sp, sy, cr, cp , cy;
	float angle;

	angle = ( float )this->Pitch * ( ( float )M_PI * 2 / 360 );
	sp = sin( angle );
	cp = cos( angle );


	angle = ( float )this->Yaw * ( ( float )M_PI * 2 / 360 );
	sy = sin( angle );
	cy = cos( angle );

	angle = ( float )this->Roll * ( ( float )M_PI * 2 / 360 );
	sr = sin( angle );
	cr = cos( angle );

	if ( Forward )
		*Forward	= FVector( cp * cy, cp * sy, -sp );

	if ( Right )
		*Right		= FVector( -1 * sr * sp * cy +- 1 * cr * -sy, -1 * sr * sp * sy +- 1 * cr * cy, -1 * sr * cp );

	if ( Up )
		*Up			= FVector( cr * sp * cy +- sr * -sy, cr * sp * sy +- sr * cy, cr * cp );
};

FVector::FVector ()
{
	this->X = 0.0f;
	this->Y = 0.0f;
	this->Z = 0.0f;
}

FVector::FVector ( float _X, float _Y, float _Z )
{
	this->X = _X;
	this->Y = _Y;
	this->Z = _Z;
}

FVector FVector::operator+ ( const FVector &A )
{
	return FVector( this->X + A.X, this->Y + A.Y, this->Z + A.Z );
}

FVector FVector::operator+ ( const float A )
{
	return FVector( this->X + A, this->Y + A, this->Z + A );
}

FVector FVector::operator+= ( const FVector &A )
{
	this->X += A.X;
	this->Y += A.Y;
	this->Z += A.Z;
	return *this;
}

FVector FVector::operator+= ( const float A )
{
	this->X += A;
	this->Y += A;
	this->Z += A;
	return *this;
}

FVector FVector::operator- ( const FVector &A )
{
	return FVector( this->X - A.X, this->Y - A.Y, this->Z - A.Z );
}

FVector FVector::operator- ( const float A )
{
	return FVector( this->X - A, this->Y - A, this->Z - A );
}

FVector FVector::operator-= ( const FVector &A )
{
	this->X -= A.X;
	this->Y -= A.Y;
	this->Z -= A.Z;
	return *this;
}

FVector FVector::operator-= ( const float A )
{
	this->X -= A;
	this->Y -= A;
	this->Z -= A;
	return *this;
}

FVector FVector::operator* ( const FVector &A )
{
	return FVector( this->X * A.X, this->Y * A.Y, this->Z * A.Z );
}

FVector FVector::operator* ( const float A )
{
	return FVector( this->X * A, this->Y * A, this->Z * A );
}

FVector FVector::operator*= ( const FVector &A )
{
	this->X *= A.X;
	this->Y *= A.Y;
	this->Z *= A.Z;
	return *this;
}

FVector FVector::operator*= ( const float A )
{
	this->X *= A;
	this->Y *= A;
	this->Z *= A;
	return *this;
}

FVector FVector::operator/ ( const FVector &A )
{
	return FVector( this->X / A.X, this->Y / A.Y, this->Z / A.Z );
}

FVector FVector::operator/ ( const float A )
{
	return FVector( this->X / A, this->Y / A, this->Z / A );
}

FVector FVector::operator/= ( const FVector &A )
{
	this->X /= A.X;
	this->Y /= A.Y;
	this->Z /= A.Z;
	return *this;
}

FVector FVector::operator/= ( const float A )
{
	this->X /= A;
	this->Y /= A;
	this->Z /= A;
	return *this;
}

bool FVector::operator== ( const FVector &A )
{
	if ( this->X == A.X 
		&& this->Y == A.Y
		&& this->Z == A.Z )
		return true;

	return false;
}

bool FVector::operator!= ( const FVector &A )
{
	if ( this->X != A.X 
		|| this->Y != A.Y
		|| this->Z != A.Z )
		return true;

	return false;
}

float FVector::GetX ()
{
	return this->X;
}

float FVector::GetY ()
{
	return this->Y;
}

float FVector::GetZ ()
{
	return this->Z;
}

float FVector::Size ()
{
	return sqrt( ( this->X * this->X ) + ( this->Y * this->Y ) + ( this->Z * this->Z ) );
}
FRotator FRotator::CalcAngle(FVector LocalHeadPosition, FVector AimPosition)
{
	FVector vecDelta = FVector((LocalHeadPosition.X - AimPosition.X), (LocalHeadPosition.Y - AimPosition.Y), (LocalHeadPosition.Z - AimPosition.Z));
	float hyp = (float)sqrt(vecDelta.X * vecDelta.X + vecDelta.Y * vecDelta.Y);

	FRotator ViewAngles = FRotator();
	ViewAngles.Pitch = -(float)atan(vecDelta.Z / hyp) * (float)(180.0f / M_PI);
	ViewAngles.Yaw = (float)atan(vecDelta.Y / vecDelta.X) * (float)(180.0f / M_PI);
	ViewAngles.Roll = (float)0;

	if (vecDelta.X >= 0.0f)
		ViewAngles.Yaw += 180.0f;

	return ViewAngles;
}
FRotator FVector::ToRotator ()
{
	float Yaw;
	float Pitch;
	float Forward;

	if ( this->X == 0.0f
		&& this->Y == 0.0f )
	{
		Yaw = 0.0f;

		if ( this->Z > 0.0f )
			Pitch = 90.0f;

		else
			Pitch = 270.0f;
	}
	else 
	{
		if ( this->X )
			Yaw = ( atan2( this->Y, this->X ) * ( 180.0f / M_PI ) );

		else if ( this->Y > 0 )
			Yaw = 90.0f;

		else 
			Yaw = 270.0f;

		if ( Yaw < 0.0f )
			Yaw += 360.0f;

		Forward = sqrt( ( this->X * this->X ) + ( this->Y * this->Y ) );
		Pitch = ( atan2( this->Z, Forward  ) * ( 180.0f / M_PI ) );

		if ( Pitch < 0.0f )
			Pitch += 360.0f;
	}

	return FRotator( -Pitch, Yaw, 0 );
}

bool FVector::IsValid ()
{
	return *this != FVector( 0, 0, 0 );
}

FVector2D::FVector2D ()
{
	this->X = 0.0f;
	this->Y = 0.0f;
}

FVector2D::FVector2D ( float _X, float _Y )
{
	this->X = _X;
	this->Y = _Y;
}

float FVector2D::GetX ()
{
	return this->X;
}

float FVector2D::GetY ()
{
	return this->Y;
}

float FVector2D::Size ()
{
	return sqrt( ( this->X * this->X ) + ( this->Y * this->Y ) );
}

Matrix::Matrix ()
{
	Forward = Right = Up = FVector( 0, 0, 0 );
}

Matrix::Matrix ( FVector _Forward, FVector _Right, FVector _Up )
{
	Forward = _Forward;
	Right = _Right;
	Up = _Up;
}

//float CMath::GetDistance( centity_t *pEntity, FVector Location )
//{
//	return ( ( pEntity->lerpOrigin - Location ).Size( ) / 36 );
//}

/*
-=-=-=-=-=-=-=-=
3D to 2D Convert
-=-=-=-=-=-=-=-=
*/
float FVector::Dot( FVector pStart, FVector pEnd )
{
	return ( pStart.X * pEnd.X ) + ( pStart.Y * pEnd.Y ) + ( pStart.Z * pEnd.Z );
}
float FVector::Distance(FVector v)
{
	return float(sqrtf(powf(v.X - X, 2.0) + powf(v.Y - Y, 2.0) + powf(v.Z - Z, 2.0)));
}
bool FVector::InAngle( FVector pStart, FVector pEnd, FVector pRotation, int nAngle )
{
	return ( Dot( ( pStart - pEnd ) / ( pStart - pEnd ).Size(), pRotation ) > cos( nAngle * M_PI / 360 ) );
}

int FVector::round( float fValue )
{
	return int( fValue + 0.5f );
}

/*
-=-=-=-=-=-=-=-=
Vector to Origin
-=-=-=-=-=-=-=-=
*/
FVector2D FVector::GetAngleToOrigin(FRotator ViewAngles, FVector vec_Start, FVector vec_End )
{
	FRotator rot_Angle = ( vec_End - vec_Start ).ToRotator( );

	if( rot_Angle.Yaw > 180.0f ) { rot_Angle.Yaw -= 360.0f; }
	else if( rot_Angle.Yaw < -180.0f ) { rot_Angle.Yaw += 360.0f; }

	if( rot_Angle.Pitch > 180.0f ) { rot_Angle.Pitch -= 360.0f; }
	else if( rot_Angle.Pitch < -180.0f ) { rot_Angle.Pitch += 360.0f; }

	rot_Angle.Yaw -= ViewAngles.Yaw;
	rot_Angle.Pitch -= ViewAngles.Pitch;

	if( rot_Angle.Yaw > 180.0f ) { rot_Angle.Yaw -= 360.0f; }
	else if( rot_Angle.Yaw < -180.0f ) { rot_Angle.Yaw += 360.0f; }

	if( rot_Angle.Pitch > 180.0f ) { rot_Angle.Pitch -= 360.0f; }
	else if( rot_Angle.Pitch < -180.0f ) { rot_Angle.Pitch += 360.0f; }

	return FVector2D( rot_Angle.Yaw, rot_Angle.Pitch );
}
```

`Vector.h`:

```h
#ifndef	Q_MATH_H
#define	Q_MATH_H

//Globals
#define M_PI 3.14159265358979323846f
#define ANG_CLIP( ang )		if( ang > 180.0f ) { ang -= 360.0f; } else if( ang <- 180.0f ) { ang += 360.0f; }
#define	GENTITYNUM_BITS		10
#define	MAX_GENTITIES		( 1 << GENTITYNUM_BITS )

struct Color;
struct FVector2D;
struct FVector;
struct Matrix;
struct FRotator;

struct Color
{
	float R;
	float G;
	float B;
	float A;

	Color ();
	Color ( int _R, int _G, int _B, int _A );
	Color ( float _R, float _G, float _B  );

	float GetRed ();
	float GetGreen ();
	float GetBlue ();
	float GetAlpha ();

	void SetRed ( float _R );
	void SetGreen ( float _G );
	void SetBlue ( float _B );
	void SetAlpha ( float _A );

	void SetRed ( int _R );
	void SetGreen ( int _G );
	void SetBlue ( int _B );
	void SetAlpha ( int _A );
};


struct FRotator
{
	float Pitch;
	float Yaw;
	float Roll;

	FRotator ();
	FRotator ( float _Pitch, float _Yaw, float _Roll );

	float GetPitch ();
	float GetYaw ();
	float GetRoll ();

	void Normalize ();
	//FRotator FRotator::Normalize180 ();

	FRotator operator+ ( const FRotator &A );
	FRotator operator- ( const FRotator &A );

	void GetVectors ( FVector* Forward, FVector* Right, FVector* Up );

	FVector ToVector ();

	/*char* ToString ()
	{
		static char buffer[ 256 ];
		ZeroMemory( buffer, 256 );

		sprintf( buffer, "rotator( %.2f, %.2f, %.2f )", this->Pitch, this->Yaw, this->Roll );
		return buffer;
	};*/
	FRotator ClampAngles();
	FRotator CalcAngle(FVector LocalHeadPosition, FVector AimPosition);
};

struct FVector2D
{
	float X;
	float Y;

	FVector2D ();
	FVector2D ( float _X, float _Y );

	float GetX ();
	float GetY ();

	float Size ();
};


struct FVector
{
	float X;
	float Y;
	float Z;

	FVector ();
	FVector ( float _X, float _Y, float _Z );

	FVector operator+ ( const FVector &A );
	FVector operator+ ( const float A );
	FVector operator+= ( const FVector &A );
	FVector operator+= ( const float A );
	FVector operator- ( const FVector &A );
	FVector operator- ( const float A );
	FVector operator-= ( const FVector &A );
	FVector operator-= ( const float A );
	FVector operator* ( const FVector &A );
	FVector operator* ( const float A );
	FVector operator*= ( const FVector &A );
	FVector operator*= ( const float A );
	FVector operator/ ( const FVector &A );
	FVector operator/ ( const float A );
	FVector operator/= ( const FVector &A );
	FVector operator/= ( const float A );

	bool operator== ( const FVector &A );
	bool operator!= ( const FVector &A );

	float GetX ();
	float GetY ();
	float GetZ ();

	float Size ();
	//float Dot (const FVector V1,const FVector V2);
	FRotator ToRotator ();

	/*char* toString ()
	{
		static char buffer[ 256 ];
		ZeroMemory( buffer, 256 );

		sprintf( buffer, "vector( %.2f, %.2f, %.2f )", this->X, this->Y, this->Z );
		return buffer;
	};*/
	float		Distance(FVector v);
	float		Dot(FVector pStart, FVector pEnd);
	bool		InAngle(FVector pStart, FVector pEnd, FVector pRotation, int nAngle);
	int			round(float fValue);
	FVector2D	GetAngleToOrigin(FRotator ViewAngles, FVector vec_Start, FVector vec_End);
	//static	float		GetDistance(centity_t* pEntity, FVector Location);
	//static	bool		WorldToScreen(FVector vec_Location, FVector& vec_Return);

	bool IsValid ();
};

struct Matrix
{
	FVector Forward;
	FVector Right;
	FVector Up;

	Matrix ();
	Matrix ( FVector _Forward, FVector _Right, FVector _Up );
};
struct FQuat
{
	float x;
	float y;
	float z;
	float w;
};

struct FTransform
{
	FQuat rot;
	FVector translation;
	char pad[4];
	FVector scale;
	char pad1[4];

	D3DMATRIX ToMatrixWithScale()
	{
		D3DMATRIX m;
		m._41 = translation.X;
		m._42 = translation.Y;
		m._43 = translation.Z;

		float x2 = rot.x + rot.x;
		float y2 = rot.y + rot.y;
		float z2 = rot.z + rot.z;

		float xx2 = rot.x * x2;
		float yy2 = rot.y * y2;
		float zz2 = rot.z * z2;
		m._11 = (1.0f - (yy2 + zz2)) * scale.X;
		m._22 = (1.0f - (xx2 + zz2)) * scale.Y;
		m._33 = (1.0f - (xx2 + yy2)) * scale.Z;

		float yz2 = rot.y * z2;
		float wx2 = rot.w * x2;
		m._32 = (yz2 - wx2) * scale.Z;
		m._23 = (yz2 + wx2) * scale.Y;

		float xy2 = rot.x * y2;
		float wz2 = rot.w * z2;
		m._21 = (xy2 - wz2) * scale.Y;
		m._12 = (xy2 + wz2) * scale.X;

		float xz2 = rot.x * z2;
		float wy2 = rot.w * y2;
		m._31 = (xz2 + wy2) * scale.Z;
		m._13 = (xz2 - wy2) * scale.X;

		m._14 = 0.0f;
		m._24 = 0.0f;
		m._34 = 0.0f;
		m._44 = 1.0f;

		return m;
	}
};
extern FVector FVec;
#endif
```

`math.h`:

```h
#pragma once
#include "Includes.h"
float Distance3D(FVector  v1, FVector v2)
{
	float x_d = (v2.X - v1.X);
	float y_d = (v2.Y - v1.Y);
	float z_d = (v2.Z - v1.Z);
	return sqrt((x_d * x_d) + (y_d * y_d) + (z_d * z_d));
}
class FMinimalViewInfo
{
public:
	char pad_0x0000[0x560];
	float FOV;
	char pad_0x0564[0x4];
	FVector Location;
	FRotator Rotation;
};
D3DXMATRIX Matrix(FRotator rot, FRotator origin = FRotator(0, 0, 0))
{
	float radPitch = (rot.Pitch * float(M_PI) / 180.f);
	float radYaw = (rot.Yaw * float(M_PI) / 180.f);
	float radRoll = (rot.Roll * float(M_PI) / 180.f);

	float SP = sinf(radPitch);
	float CP = cosf(radPitch);
	float SY = sinf(radYaw);
	float CY = cosf(radYaw);
	float SR = sinf(radRoll);
	float CR = cosf(radRoll);

	D3DMATRIX matrix;
	matrix.m[0][0] = CP * CY;
	matrix.m[0][1] = CP * SY;
	matrix.m[0][2] = SP;
	matrix.m[0][3] = 0.f;

	matrix.m[1][0] = SR * SP * CY - CR * SY;
	matrix.m[1][1] = SR * SP * SY + CR * CY;
	matrix.m[1][2] = -SR * CP;
	matrix.m[1][3] = 0.f;

	matrix.m[2][0] = -(CR * SP * CY + SR * SY);
	matrix.m[2][1] = CY * SR - CR * SP * SY;
	matrix.m[2][2] = CR * CP;
	matrix.m[2][3] = 0.f;

	matrix.m[3][0] = origin.Pitch;
	matrix.m[3][1] = origin.Yaw;
	matrix.m[3][2] = origin.Roll;
	matrix.m[3][3] = 1.f;

	return matrix;
}
D3DMATRIX MatrixMultiplication(D3DMATRIX pM1, D3DMATRIX pM2)
{
	D3DMATRIX pOut;
	pOut._11 = pM1._11 * pM2._11 + pM1._12 * pM2._21 + pM1._13 * pM2._31 + pM1._14 * pM2._41;
	pOut._12 = pM1._11 * pM2._12 + pM1._12 * pM2._22 + pM1._13 * pM2._32 + pM1._14 * pM2._42;
	pOut._13 = pM1._11 * pM2._13 + pM1._12 * pM2._23 + pM1._13 * pM2._33 + pM1._14 * pM2._43;
	pOut._14 = pM1._11 * pM2._14 + pM1._12 * pM2._24 + pM1._13 * pM2._34 + pM1._14 * pM2._44;
	pOut._21 = pM1._21 * pM2._11 + pM1._22 * pM2._21 + pM1._23 * pM2._31 + pM1._24 * pM2._41;
	pOut._22 = pM1._21 * pM2._12 + pM1._22 * pM2._22 + pM1._23 * pM2._32 + pM1._24 * pM2._42;
	pOut._23 = pM1._21 * pM2._13 + pM1._22 * pM2._23 + pM1._23 * pM2._33 + pM1._24 * pM2._43;
	pOut._24 = pM1._21 * pM2._14 + pM1._22 * pM2._24 + pM1._23 * pM2._34 + pM1._24 * pM2._44;
	pOut._31 = pM1._31 * pM2._11 + pM1._32 * pM2._21 + pM1._33 * pM2._31 + pM1._34 * pM2._41;
	pOut._32 = pM1._31 * pM2._12 + pM1._32 * pM2._22 + pM1._33 * pM2._32 + pM1._34 * pM2._42;
	pOut._33 = pM1._31 * pM2._13 + pM1._32 * pM2._23 + pM1._33 * pM2._33 + pM1._34 * pM2._43;
	pOut._34 = pM1._31 * pM2._14 + pM1._32 * pM2._24 + pM1._33 * pM2._34 + pM1._34 * pM2._44;
	pOut._41 = pM1._41 * pM2._11 + pM1._42 * pM2._21 + pM1._43 * pM2._31 + pM1._44 * pM2._41;
	pOut._42 = pM1._41 * pM2._12 + pM1._42 * pM2._22 + pM1._43 * pM2._32 + pM1._44 * pM2._42;
	pOut._43 = pM1._41 * pM2._13 + pM1._42 * pM2._23 + pM1._43 * pM2._33 + pM1._44 * pM2._43;
	pOut._44 = pM1._41 * pM2._14 + pM1._42 * pM2._24 + pM1._43 * pM2._34 + pM1._44 * pM2._44;

	return pOut;
}

```

`sdk.h`:

```h
#pragma once
#include "Settings.h"
#include "math.h"
#include "Offsets.h"
#include "Decrypt.h"
#pragma warning(disable:4996)
static uint64_t GameModule = 0;
static int S_width = 1920, S_height = 1080;
static uint64 Paddr[1500];
static int PlayerNum = 0;
double GetCrossDistance(double x1, double y1, double x2, double y2);
class Inputs {
private:
	static DWORD SendScanCode(WORD scan, BOOL up)
	{
		INPUT inp = { 0 };
		inp.type = INPUT_KEYBOARD;
		inp.ki.wScan = scan;
		inp.ki.dwFlags = KEYEVENTF_SCANCODE | (up ? KEYEVENTF_KEYUP : 0);
		return SendInput(1, &inp, sizeof(inp)) ? NO_ERROR : GetLastError();
	}
public:
	static bool mouse_move(int x, int y)
	{
		INPUT input;
		input.type = INPUT_MOUSE;
		input.mi.mouseData = 0;
		input.mi.time = 0;
		input.mi.dx = x;
		input.mi.dy = y;
		input.mi.dwFlags = MOUSEEVENTF_MOVE;
		SendInput(1, &input, sizeof(input));
		return true;
	}
	static DWORD SendVirtualKey(UINT vk, BOOL up)
	{
		UINT scan = MapVirtualKey(vk, MAPVK_VK_TO_VSC);
		return scan ? SendScanCode(scan, up) : ERROR_NO_UNICODE_TRANSLATION;
	}
	bool static keydown(int key)
	{
		return (GetAsyncKeyState(key) & 0x8000) != 0;
	}
};
namespace Decrypt
{
	template<class T> T __ROL__(T value, int count)
	{
		const unsigned int nbits = sizeof(T) * 8;

		if (count > 0)
		{
			count %= nbits;
			T high = value >> (nbits - count);
			if (T(-1) < 0)
				high &= ~((T(-1) << count));
			value <<= count;
			value |= high;
		}
		else
		{
			count = -count % nbits;
			T low = value << (nbits - count);
			value >>= count;
			value |= low;
		}
		return value;
	}
	ulong v11 = 0;
	inline byte __ROL1__(byte value, int count) { return __ROL__(value, count); }
	inline ushort __ROL2__(ushort value, int count) { return __ROL__(value, count); }
	inline uint __ROL4__(uint value, int count) { return __ROL__(value, count); }
	inline ulong __ROL8__(ulong value, int count) { return __ROL__(value, count); }
	inline byte __ROR1__(byte value, int count) { return __ROL__(value, -count); }
	inline ushort __ROR2__(ushort value, int count) { return __ROL__(value, -count); }
	inline uint __ROR4__(uint value, int count) { return __ROL__(value, -count); }
	inline ulong __ROR8__(ulong value, int count) { return __ROL__(value, -count); }

	// Generate a reference to pair of operands
	template<class T>  int16 __PAIR__(int8  high, T low) { return (((int16)high) << sizeof(high) * 8) | uint8(low); }
	template<class T>  int32 __PAIR__(int16 high, T low) { return (((int32)high) << sizeof(high) * 8) | uint16(low); }
	template<class T>  int64 __PAIR__(int32 high, T low) { return (((int64)high) << sizeof(high) * 8) | uint32(low); }
	template<class T> uint16 __PAIR__(uint8  high, T low) { return (((uint16)high) << sizeof(high) * 8) | uint8(low); }
	template<class T> uint32 __PAIR__(uint16 high, T low) { return (((uint32)high) << sizeof(high) * 8) | uint16(low); }
	template<class T> uint64 __PAIR__(uint32 high, T low) { return (((uint64)high) << sizeof(high) * 8) | uint32(low); }

	uint64 GameInstanceDec(uint64 inst)//++++++++++++++
	{
		__int64 v4;
		int v5;
		unsigned int v6;
		unsigned __int64 v7;
		v4 = rpm.read<uint64>(dwUWorld + inst);
		LODWORD(v7) = (~(_DWORD)v4 + 1425890107) ^ 0x7212461C;
		HIDWORD(v7) = (~(~HIDWORD(v4) + 446092664) + 1651193675) ^ 0xF3FDF33D;
		return v7;
	}
	uint64 DecryptActors(uint64 v5)
	{
		int v6;
		int v7;
		unsigned __int16 v8;
		int v9;
		unsigned __int16 v10;
		int v11;
		unsigned __int16 v12;
		__int64 v31;


		if (!v5) return 0;

		v6 = ((v5 & 0xFFFF0000 | (unsigned __int16)v5 ^ ((unsigned int)v5 >> 16)) - 1629592062) >> 16;
		v7 = v6 ^ (unsigned __int16)((v5 ^ WORD1(v5)) + 26114);
		v8 = __ROR2__(v6, 8);
		v9 = v8;
		v10 = __ROR2__(WORD3(v5), 8);
		LOWORD(v6) = __ROR2__((v5 >> 32) ^ WORD3(v5), 8);
		LODWORD(v31) = (v7 | (v9 << 16)) ^ 0x9EDE6602;
		v11 = ((v10 << 16) | (unsigned __int16)v6) - 1648255678;
		v12 = __ROR2__(v11 ^ HIWORD(v11), 8);
		HIDWORD(v31) = (v11 & 0xFFFF0000 | v12) ^ 0x623E62BE;

		return v31;
	}

	uint64 ULevelDec(uint64 inst)//
	{
		unsigned __int64 v18;
		__int64 v261;
		v18 = rpm.read<uint64>(dwUWorld + inst);
		LODWORD(v261) = (v18 - 1042594514) ^ 0xF0F03010;
		HIDWORD(v261) = (HIDWORD(v18) - 1589798400) ^ 0x10F010F0;
		return v261;
	}
	/*uint64 ULevelDec(uint64 inst)//
	{
		unsigned __int64 v18;
		__int64 v261;
		v18 = inst;
		LODWORD(v261) = (v18 - 1042594514) ^ 0xF0F03010;
		HIDWORD(v261) = (HIDWORD(v18) - 1589798400) ^ 0x10F010F0;
		return v261;
	}*/
	uint64 LocalDec(uint64 inst, uint64 inst2)//+++++++++++++++
	{
		int v2;
		int v3;
		__int64 v5;
		__int64 v6;
		__int64 v1;
		v6 = rpm.read<uint64>(inst + inst2);
		v1 = rpm.read<uint64>(v6);
		v2 = __ROL4__(v1 ^ 0xE9EA03BD, 8);
		LODWORD(v1) = __ROR4__(HIDWORD(v1) ^ 0x4E19C6E8, 16);
		v3 = __ROL4__((v2 - 2080050116) ^ 0x84EA03BD, 8);
		LODWORD(v1) = __ROR4__((v1 - 2084863044) ^ 0xE919C6E8, 16);
		LODWORD(v5) = v3 ^ 0x8404F43C;
		HIDWORD(v5) = v1 ^ 0x7C447C44;
		return v5;
	}
	INT32 ObjID(INT32 ID)//
	{
		int v33;
		v33 = __ROL4__(ID ^ 0xF7B20EA6, 14) ^ (__ROL4__(ID ^ 0xF7B20EA6, 14) << 16) ^ 0xF914F7B2;
		return v33;
	}

	uint64 PlayerControllerDec(uint64 inst, uint64 inst2)//++++++++++++++++
	{
		__int64 v15;
		unsigned __int64 v16;
		unsigned __int16 v17;
		unsigned int v18;
		unsigned __int16 v19;
		unsigned __int16 v20;
		unsigned int v21;
		unsigned __int16 v22;
		__int64 v96;
		v15 = rpm.read<uint64>(inst + inst2);
		v16 = v15 >> 32;
		v17 = __ROR2__(WORD1(v15), 8);
		v18 = ((unsigned __int16)v15 ^ ((unsigned int)v15 >> 16) | (v17 << 16)) - 1195845432;
		v19 = __ROR2__(HIWORD(v18), 8);
		LODWORD(v96) = ((unsigned __int16)v18 ^ (v18 >> 16) | (v19 << 16)) ^ 0xB8B8D8C8;
		v20 = __ROL2__((v15 >> 32) ^ WORD1(v16), 8);
		v21 = (HIDWORD(v15) & 0xFFFF0000 | v20) - 1211648056;
		v22 = __ROL2__((v20 - 18488) ^ HIWORD(v21), 8);
		HIDWORD(v96) = (v21 & 0xFFFF0000 | v22) ^ 0x48384838;
		return v96;
	}

#define GNames 0x4680CB0
#define _DEBUG_
	static bool bPrintOnce = false;

	uint64 InPawnDec(uint64 cryptedOffset)//+
	{
		unsigned __int64 v1;
		int v2;
		int v3;
		__int64 v5;
		v1 = rpm.read<uint64>(cryptedOffset);
		v2 = __ROL4__(v1, 16);
		LODWORD(v1) = __ROR4__(HIDWORD(v1), 8);
		v3 = __ROL4__(v2 - 1675842396, 16);
		LODWORD(v1) = __ROR4__(v1 - 1692165340, 8);
		LODWORD(v5) = v3 ^ 0x9C1CACA4;
		HIDWORD(v5) = v1 ^ 0x64DC64DC;
		return v5;
	}
	template <typename PtrType>
	PtrType Decrypt(ULONG_PTR v1) //GetCurrentLevel, RootComponent, mesh
	{
		int v2;
		int v3;
		__int64 v5;

		if (!v1) return 0;

		v2 = __ROL4__(v1, 16);
		LODWORD(v1) = __ROR4__(HIDWORD(v1), 8);
		v3 = __ROL4__(v2 - 1675842396, 16);
		LODWORD(v1) = __ROR4__(v1 - 1692165340, 8);
		LODWORD(v5) = v3 ^ 0x9C1CACA4;
		HIDWORD(v5) = v1 ^ 0x64DC64DC;

		return (PtrType)v5;
	}
	struct ObjectName
	{
		char data[64];
	};
	uint64 gnames(uint64 GName)
	{
		DWORD64 v42 = 0;
		DWORD64 v4 = rpm.read<DWORD64>(GameModule + GName);
		LODWORD(v42) = __ROL4__(__ROL4__(v4, 16) + 1827421396, 16) ^ 0x6CEC3CD4;
		HIDWORD(v42) = __ROR4__(__ROR4__(HIDWORD(v4), 8) + 1800629076, 8) ^ 0x94AC94AC;

		DWORD64 v43 = 0;
		DWORD64 v22 = rpm.read<DWORD64>(v42);
		LODWORD(v43) = __ROL4__(__ROL4__(v22 + 2129265597, 16) - 207398508, 16) ^ 0xD9B955D7;
		HIDWORD(v43) = __ROR4__(__ROR4__(HIDWORD(v22) - 484849944, 8) - 695197921, 8) ^ 0xA789A7C9;

		DWORD64 v44 = 0;
		DWORD64 v24 = rpm.read<DWORD64>(v43);
		DWORD64 v25 = __PAIR__(((HIDWORD(v24) ^ 0xC3E63917) + 240258770) ^ 0x26B437C5, ((v24 ^ 0x2815FC42) + 223155602) ^ 0x7FA7162C);
		USHORT v27 = __ROL2__(((unsigned int)v25 ^ 0x9EDE6602) >> 16, 8);
		DWORD32 v28 = ((v27 << 16) | (unsigned __int16)v25 ^ 0x6602 ^ v27) + 1629592062;
		DWORD32 v29 = (unsigned __int16)((v25 ^ 0x6602 ^ v27) - 26114) ^ (v28 >> 16);
		DWORD32 v30 = (HIDWORD(v25) ^ 0x623E62BEu) >> 16;
		LODWORD(v44) = v28 & 0xFFFF0000 | v29;
		USHORT v31 = __ROL2__(WORD2(v25) ^ 0x62BE, 8);
		DWORD32 v32 = ((v30 << 16) | v30 ^ v31) + 1648255678;
		LOWORD(v32) = __ROL2__((v30 ^ v31) + 25278, 8);
		LOWORD(v30) = __ROL2__(HIWORD(v32), 8);
		HIDWORD(v44) = ((unsigned __int16)v30 << 16) | (unsigned __int16)v30 ^ (unsigned __int16)v32;

		DWORD64 v36 = 0;
		DWORD64 v9 = v44 >> 32;
		DWORD32 v10 = (v44 & 0xFFFF0000 | (unsigned __int16)v44 ^ ((unsigned int)v44 >> 16)) - 1629592062;
		LODWORD(v36) = ((unsigned __int16)v10 ^ (v10 >> 16) | ((unsigned __int16)__ROR2__(HIWORD(v10), 8) << 16)) ^ 0x9EDE6602;
		DWORD32 v11 = ((unsigned __int16)__ROR2__(WORD2(v44) ^ WORD1(v9), 8) | ((unsigned __int16)__ROR2__(WORD1(v9), 8) << 16)) - 1648255678;
		HIDWORD(v36) = (v11 & 0xFFFF0000 | (unsigned __int16)__ROR2__(v11 ^ HIWORD(v11), 8)) ^ 0x623E62BE;

		DWORD64 v37 = 0;
		DWORD64 v14 = rpm.read<DWORD64>(v36 + 8);
		LODWORD(v37) = __ROR4__(__ROR4__(v14, 8) + 1467423737, 8) ^ 0x57771BF9;
		HIDWORD(v37) = (HIDWORD(v14) - 698820967) ^ 0x29A72967;

		return v37;
	}
	std::string GetGNamesByObjID(int32_t ObjectID)
	{
		uint64 GName = gnames(GNames);
		int64_t fNamePtr = rpm.read<uint64_t>(GName + int(ObjectID / 0x408C) * 0x8);
		int64_t fName = rpm.read<uint64_t>(fNamePtr + int(ObjectID % 0x408C) * 0x8);
		ObjectName pBuffer = rpm.read<ObjectName>(fName + 0x10);
		return std::string(pBuffer.data);
	}

}
struct sPlayerName
{
	char data[64];
};
class Player {
private:

	FTransform GetBoneIndex(uint64 dwbonemesh, int indexnum)
	{
		uint64 bonearray = rpm.read<uint64>(dwbonemesh + offset_boneArray);
		return rpm.read<FTransform>(bonearray + (indexnum * 0x30));
	}

public:
	Player() {}
	Player(uint64 _ptr) {
		this->ptr = _ptr;

		this->Head = GetBoneWithRotation(6);
		this->Location = GetBoneWithRotation(62);
		this->Team = rpm.read<int>(this->ptr + TeamID);
		this->Health = rpm.read<float>(this->ptr + bHealth);
		this->IsAbot = rpm.read<bool>(this->ptr + 0x800);
		this->inVeh = rpm.read<uint64>(this->ptr + CurrentVehicle);
	}
	uint64 ptr = 0;
	float Health = 0;
	INT Team = 0;
	BOOL IsAbot = false;
	uint64 inVeh = 0;
	FVector Head = FVector();
	FVector Location = FVector();
	FLOAT Distance = 0;
	FVector GetBoneWithRotation( int boneindexnum)
	{
		uint64 CurrentActorMesh = Decrypt::Decrypt<uint64>(rpm.read<uint64>(this->ptr + Mesh));
		FTransform bone = GetBoneIndex(CurrentActorMesh, boneindexnum);
		FTransform ComponentToWorld = rpm.read<FTransform>(CurrentActorMesh + offset_ComponentToWorld);
		D3DMATRIX Matrix;
		Matrix = MatrixMultiplication(bone.ToMatrixWithScale(), ComponentToWorld.ToMatrixWithScale());

		return FVector(Matrix._41, Matrix._42, Matrix._43);
	}
	std::string Name()
	{
		uint64 fName = rpm.read<uint64>(this->ptr + PlayerName);
		sPlayerName pBuffer = rpm.read<sPlayerName>(fName);
		sPlayerName pBuffer2 = rpm.read<sPlayerName>(fName + 0x2);
		sPlayerName pBuffer3 = rpm.read<sPlayerName>(fName + 0x4);
		sPlayerName pBuffer4 = rpm.read<sPlayerName>(fName + 0x6);
		sPlayerName pBuffer5 = rpm.read<sPlayerName>(fName + 0x8);
		return std::string(pBuffer.data) + std::string(pBuffer2.data) + std::string(pBuffer3.data) + std::string(pBuffer4.data) + std::string(pBuffer5.data);
	}
	BOOL IsValid() {
		if ((this->Location.X != NULL) &&
			(this->Health > NULL) &&
			(this->ptr != NULL)) return true;
		return false;
	}
};
class Manager {
private:
	uint64	PlayerController = Decrypt::PlayerControllerDec(Decrypt::LocalDec(Decrypt::GameInstanceDec(GInstance), UlocalPlayer), 0x30);
	uint64	PlayerCamera = rpm.read<uint64>(PlayerController + PlayerCameraManager);
	FMinimalViewInfo CameraCacheEntry = rpm.read<FMinimalViewInfo>(PlayerCamera + CameraCache + POV);

public:
	Player LocalPlayer = NULL;
	std::vector<Player> Players = std::vector<Player>();
	Player ClosestVisibleEnemy = NULL;
	Player ClosestCrosshairEnemy = NULL;

	Manager(int width, int height) {
		S_width = width;
		S_height = height;

		uint64 LocalPawn = rpm.read<uint64>(PlayerController + STExtraBaseCharacter);
		this->LocalPlayer = Player(LocalPawn);
		uint64 LocalActorMesh = Decrypt::Decrypt<uint64>(rpm.read<uint64>(this->LocalPlayer.ptr + Mesh));

		for (int i = 0; i < PlayerNum; i++) {
			Player player(Paddr[i]);
			uint64 CurrentActorMesh = Decrypt::Decrypt<uint64>(rpm.read<uint64>(player.ptr + Mesh));

			if (player.ptr != 0);// break;
			if (player.IsValid() && player.ptr != this->LocalPlayer.ptr)
			{
				player.Distance = LocalPlayer.Location.Distance(player.Head) / 100.f;
				this->Players.push_back(player);

			}
		}
		float closestcrosshair = FLT_MAX;
		for (size_t i = 0; i < this->Players.size(); i++)
		{

			FVector out = WorldToScreen(this->Players[i].Location);

				float crossdis = GetCrossDistance(out.X, out.Y, S_width / 2, S_height / 2);
			if ((crossdis < closestcrosshair)) {
				if (this->Players[i].Team != this->LocalPlayer.Team && this->Players[i].Distance < 125) {
					ClosestCrosshairEnemy = this->Players[i];
					closestcrosshair = crossdis;
				}
			}

		}
		float closestdis = FLT_MAX;
		for (int i = 0; i < this->Players.size(); i++) {
			if ((this->Players[i].Distance < closestdis)) {
				if (this->Players[i].Team != this->LocalPlayer.Team) {
					ClosestVisibleEnemy = this->Players[i];
					closestdis = this->Players[i].Distance;
				}
			}
		}


	}
	FVector WorldToScreen( FVector WorldLocation)
	{
		FVector Screenlocation = FVector(0, 0, 0);
		FRotator Rotation = CameraCacheEntry.Rotation;
		D3DMATRIX tempMatrix = Matrix(Rotation);

		FVector vAxisX, vAxisY, vAxisZ;

		vAxisX = FVector(tempMatrix.m[0][0], tempMatrix.m[0][1], tempMatrix.m[0][2]);
		vAxisY = FVector(tempMatrix.m[1][0], tempMatrix.m[1][1], tempMatrix.m[1][2]);
		vAxisZ = FVector(tempMatrix.m[2][0], tempMatrix.m[2][1], tempMatrix.m[2][2]);

		FVector vDelta = WorldLocation - CameraCacheEntry.Location;
		FVector vTransformed = FVector(vDelta.Dot(vDelta, vAxisY), vDelta.Dot(vDelta, vAxisZ), vDelta.Dot(vDelta, vAxisX));

		if (vTransformed.Z < 1.f)
			vTransformed.Z = 1.f;

		float FovAngle = CameraCacheEntry.FOV;

		float ScreenCenterX = S_width / 2;
		float ScreenCenterY = S_height / 2;

		Screenlocation.X = ScreenCenterX + vTransformed.X * (ScreenCenterX / tanf(FovAngle * (float)M_PI / 360.f)) / vTransformed.Z;
		Screenlocation.Y = ScreenCenterY - vTransformed.Y * (ScreenCenterX / tanf(FovAngle * (float)M_PI / 360.f)) / vTransformed.Z;

		return Screenlocation;
	}

};

double GetCrossDistance(double x1, double y1, double x2, double y2)
{
	return sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2));
}
void AimAtPosV2(float x, float y, float speed, bool smooth)
{
	int ScreenCenterX = S_width / 2, ScreenCenterY = S_height / 2;

	float AimSpeed = (float)speed;
	float TargetX = 0;
	float TargetY = 0;

	//X Axis
	if (x != 0)
	{
		if (x > ScreenCenterX)
		{
			TargetX = -(ScreenCenterX - x);
			TargetX /= AimSpeed;
			TargetX += settings::aimlock;
			if (TargetX + ScreenCenterX > ScreenCenterX * 2) TargetX = 0;
		}

		if (x < ScreenCenterX)
		{
			TargetX = x - ScreenCenterX;
			TargetX /= AimSpeed;
			TargetX -= settings::aimlock;
			if (TargetX + ScreenCenterX < 0) TargetX = 0;
		}
	}

	//Y Axis

	if (y != 0)
	{
		if (y > ScreenCenterY)
		{
			TargetY = -(ScreenCenterY - y);
			TargetY /= AimSpeed;
			TargetY += settings::aimlock;
			if (TargetY + ScreenCenterY > ScreenCenterY * 2) TargetY = 0;
		}

		if (y < ScreenCenterY)
		{
			TargetY = y - ScreenCenterY;
			TargetY /= AimSpeed;
			TargetY -= settings::aimlock;
			if (TargetY + ScreenCenterY < 0) TargetY = 0;
		}
	}

	if (!smooth)
	{
		Inputs::mouse_move((int)TargetX, (int)(TargetY));
		return;
	}

	TargetX /= 10;
	TargetY /= 10;

	if (abs(TargetX) < 1)
	{
		if (TargetX > 0)
		{
			TargetX = 1;
		}
		if (TargetX < 0)
		{
			TargetX = -1;
		}
	}
	if (abs(TargetY) < 1)
	{
		if (TargetY > 0)
		{
			TargetY = 1;
		}
		if (TargetY < 0)
		{
			TargetY = -1;
		}
	}
	Inputs::mouse_move((int)TargetX, (int)(TargetY));

}
FVector CalcSoldierFuturePos(FVector InVec)
{
	Manager gm(S_width, S_height);
	FVector NewPos, OutPos;
	NewPos = gm.WorldToScreen(InVec);
		OutPos.X = NewPos.X;
		OutPos.Y = NewPos.Y;
		OutPos.Z = NewPos.Z;	
	return OutPos;
}

```