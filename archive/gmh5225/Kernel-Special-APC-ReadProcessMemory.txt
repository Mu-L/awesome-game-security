Project Path: arc_gmh5225_Kernel-Special-APC-ReadProcessMemory_kjtagfqq

Source Tree:

```txt
arc_gmh5225_Kernel-Special-APC-ReadProcessMemory_kjtagfqq
├── KernelSpecialAPC_ReadProcessMemory
│   ├── Device.c
│   ├── Device.h
│   ├── Head.h
│   ├── KernelSpecialAPC_ReadProcessMemory.sln
│   ├── Process_Thread.c
│   ├── Process_Thread.h
│   ├── Ring0ToRing31.vcxproj
│   ├── Ring0ToRing31.vcxproj.filters
│   ├── kernel_special_APC.c
│   ├── kernel_special_APC.h
│   ├── main.c
│   └── 内核学习.inf
├── Ring3_test_demo
│   ├── APC_Read_Memory.cpp
│   ├── APC_Read_Memory.h
│   ├── Device.cpp
│   ├── Device.h
│   ├── Head.h
│   ├── Ring31.vcxproj
│   ├── Ring31.vcxproj.filters
│   ├── Ring31.vcxproj.user
│   ├── Ring3_test.sln
│   └── main.cpp
├── Test picture
│   ├── 0
│   └── tsapctest.png
└── readme.md

```

`KernelSpecialAPC_ReadProcessMemory/Device.c`:

```c
#include "Head.h"

PDEVICE_OBJECT mydevice = NULL;

NTSTATUS Create_Complete_Routine(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
{
	NTSTATUS Status;

	DbgPrint("创建\n");
	Status = STATUS_SUCCESS;
	pIrp->IoStatus.Status = Status;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
NTSTATUS My_Dispatch(PDEVICE_OBJECT mydevice, PIRP irp)
{

	NTSTATUS status = STATUS_SUCCESS;
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(irp);
	ULONG xh_code = stack->Parameters.DeviceIoControl.IoControlCode;
	ULONG buffer_lenth = 0;
	PUCHAR To_Ring3 = stack->Parameters.DeviceIoControl.Type3InputBuffer;//可以写到应用
	PUCHAR From_Ring3 = irp->UserBuffer;//可以从应用读到
	stack->Parameters.DeviceIoControl.InputBufferLength;
	stack->Parameters.DeviceIoControl.OutputBufferLength;
	irp->IoStatus.Information = 0;

	PR3_Read_Memory PTask = NULL;

	switch (xh_code)
	{
	case TEST://功能测试
	{
		PTask = From_Ring3;
		//DbgBreakPoint();
		if (TRUE == Apc_Read_Process_Memory_By_Pid(PTask->Pid, PTask->Read_Buffer, PTask->Address, PTask->Length)) {
			irp->IoStatus.Information = 1;
		}
		break;
	}
	default:
		break;
	}
	IoCompleteRequest(irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}



NTSTATUS Create_Device(PDRIVER_OBJECT DriverObject) {
	NTSTATUS status = STATUS_SUCCESS;
	UNICODE_STRING device_name, device_link_name, event_name1, event_name2;//设备名，符号链接名，事件名
	RtlInitUnicodeString(&device_name, my_device_name);//初始化设备名
	RtlInitUnicodeString(&device_link_name, my_link_name);//初始化符号链接名

	status = IoCreateDevice(DriverObject, 200, &device_name, FILE_DEVICE_UNKNOWN, 0, 1, &mydevice);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("无法创建设备!\n");
		return status;
	}
	status = IoCreateSymbolicLink(&device_link_name, &device_name);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("无法创建符号链接！\n");
		IoDeleteDevice(mydevice);
		return status;
	}
	DbgPrint("创建成功！\n");
	//main->DriverUnload = Unload;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = Create_Complete_Routine;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = My_Dispatch;
	return STATUS_SUCCESS;
}


```

`KernelSpecialAPC_ReadProcessMemory/Device.h`:

```h
#pragma once
#include<ntifs.h>
#define my_device_name  L"\\Device\\APC_Drv"//设备名
#define my_link_name L"\\??\\APC_Drv"//符号链接名

#define TEST CTL_CODE(FILE_DEVICE_UNKNOWN,0x99f,METHOD_NEITHER,FILE_ANY_ACCESS)//功能测试


NTSTATUS Create_Device(PDRIVER_OBJECT DriverObject);

typedef struct _R3_Read_Memory {
	ULONG64 Pid;
	PUCHAR Read_Buffer;
	ULONG64 Address;
	ULONG64 Length;

}R3_Read_Memory,*PR3_Read_Memory;

```

`KernelSpecialAPC_ReadProcessMemory/Head.h`:

```h
#pragma once
#include "Device.h"
#include"kernel_special_APC.h"
#include"Process_Thread.h"

```

`KernelSpecialAPC_ReadProcessMemory/KernelSpecialAPC_ReadProcessMemory.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Ring0ToRing31", "Ring0ToRing31.vcxproj", "{C4F0E35A-3A78-4C65-AB19-39ACC941573B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Debug|ARM.ActiveCfg = Debug|ARM
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Debug|ARM.Build.0 = Debug|ARM
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Debug|ARM.Deploy.0 = Debug|ARM
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Debug|ARM64.Build.0 = Debug|ARM64
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Debug|x64.ActiveCfg = Debug|x64
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Debug|x64.Build.0 = Debug|x64
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Debug|x64.Deploy.0 = Debug|x64
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Debug|x86.ActiveCfg = Debug|Win32
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Debug|x86.Build.0 = Debug|Win32
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Debug|x86.Deploy.0 = Debug|Win32
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Release|ARM.ActiveCfg = Release|ARM
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Release|ARM.Build.0 = Release|ARM
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Release|ARM.Deploy.0 = Release|ARM
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Release|ARM64.ActiveCfg = Release|ARM64
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Release|ARM64.Build.0 = Release|ARM64
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Release|ARM64.Deploy.0 = Release|ARM64
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Release|x64.ActiveCfg = Release|x64
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Release|x64.Build.0 = Release|x64
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Release|x64.Deploy.0 = Release|x64
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Release|x86.ActiveCfg = Release|Win32
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Release|x86.Build.0 = Release|Win32
		{C4F0E35A-3A78-4C65-AB19-39ACC941573B}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1D433DED-D082-45ED-8063-D23B2E3F6B67}
	EndGlobalSection
EndGlobal

```

`KernelSpecialAPC_ReadProcessMemory/Process_Thread.c`:

```c
#include "Process_Thread.h"


BOOLEAN Get_pEprocess_By_Pid(ULONG64 Pid, PEPROCESS* pProcess) {
	PEPROCESS CurrentEprocess = IoGetCurrentProcess();
	PLIST_ENTRY64 P_ProcessListEntry = (PLIST_ENTRY64)((ULONG64)CurrentEprocess+ ProcessListEntry);
	PLIST_ENTRY64 LS = P_ProcessListEntry->Flink;
	PEPROCESS targetProcess = NULL;
	ULONG64 num = 0;//要是找了500个进程都找不到，就返回错误。（或者查询链表时其他线程有对链表的操作）
	BOOLEAN Find = FALSE;
	__try {
		while (LS != P_ProcessListEntry && num <500)
		{
			targetProcess = (ULONG64)LS - ProcessListEntry;
			if (*((PULONG64)((ULONG64)targetProcess + UniqueProcessId)) == Pid) {
				*pProcess = targetProcess;
				Find = TRUE;
				break;
			}
			LS = LS->Flink;
			num++;
		}
	}except(1) {
		return Find;
	}
	return Find;
}

BOOLEAN Get_APC_pThread_By_Process(PEPROCESS Process, PETHREAD* pThread) {
	PETHREAD targetThread = NULL;
	PLIST_ENTRY64 P_ThreadListHead = (PLIST_ENTRY64)((ULONG64)Process + ThreadListHead);
	PLIST_ENTRY64 LS = P_ThreadListHead->Blink;
	BOOLEAN Find = FALSE;
	__try {
		while (LS != P_ThreadListHead)
		{
			targetThread = (ULONG64)LS - ThreadListEntry;
			if (*(PUCHAR)((ULONG64)targetThrean + Running) == TRUE && *(PUSHORT)((ULONG64)targetThrean + SpecialApcDisable) == 0) {
				//线程正在运行 并且 未关闭APC
				*pThread = targetThread;
				Find = TRUE;
				break;
			}

			LS = LS->Blink;
			//num++;
		}
	}except(1) {
		return Find;
	}
	return Find;
}

```

`KernelSpecialAPC_ReadProcessMemory/Process_Thread.h`:

```h
#pragma once
#include<ntifs.h>


enum  Eprocess_Members_Offset //自己想办法获取进程结构偏移
{
	ThreadListHead = 0x30,//线程链表
	ProcessListEntry = 0x240,//进程链表
	UniqueProcessId = 0x2e0,//进程PID

};

enum Ethread_Members_Offset //自己想办法获取线程结构偏移
{
	Running = 0x71,
	SpecialApcDisable = 0x1e6,
	ThreadListEntry = 0x2f8,
};

BOOLEAN Get_pEprocess_By_Pid(ULONG64 Pid, PEPROCESS* pProcess);

BOOLEAN Get_APC_pThread_By_Process(PEPROCESS Process, PETHREAD* pThread);

```

`KernelSpecialAPC_ReadProcessMemory/Ring0ToRing31.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{c4f0e35a-3a78-4c65-ab19-39acc941573b}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>Ring0ToRing31</RootNamespace>
    <ProjectName>KernelSpecialAPC_ReadProcessMemory</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <SuppressStartupBanner>false</SuppressStartupBanner>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="内核学习.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Device.c" />
    <ClCompile Include="kernel_special_APC.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="Process_Thread.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Device.h" />
    <ClInclude Include="Head.h" />
    <ClInclude Include="kernel_special_APC.h" />
    <ClInclude Include="Process_Thread.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`KernelSpecialAPC_ReadProcessMemory/Ring0ToRing31.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="内核学习.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Device.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="kernel_special_APC.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Process_Thread.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Head.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Device.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kernel_special_APC.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Process_Thread.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`KernelSpecialAPC_ReadProcessMemory/kernel_special_APC.c`:

```c
#include"Head.h"


VOID(*KeInitializeApc)(PKAPC Apc,PETHREAD pKthread,int a3,PVOID KernelRoutine,PVOID RundownRoutine,PVOID NormalRoutine,UCHAR ApcMode,ULONG64 NormalContext) = NULL;
VOID(*KeInsertQueueApc)(PKAPC Apc, ULONG64 SystemArgument1, ULONG64 SystemArgument2, int a4) = NULL;

ULONG64 Old_Pid = NULL;
PEPROCESS Old_Process = NULL;

VOID Apc_Init() {
	PULONG64 P_KeInitializeApc = (PULONG64)&KeInitializeApc;
	PULONG64 P_KeInsertQueueApc = (PULONG64)&KeInsertQueueApc;

	//填入KeInitializeApc函数地址
	*P_KeInitializeApc = 0xfffff8042b62a530;

	//填入KeInsertQueueApc函数地址
	*P_KeInsertQueueApc = 0xfffff8042b63dc10;
}

//被读内存的进程的线程主动调用此函数
VOID Read_Memory(PKAPC APC, PULONG64 NormalRoutine, PReadMemory_Context* PPcontext, PULONG64 Pin_time, PULONG64 s2) {
	//*s2 是NULL
	PReadMemory_Context Pcontext = *PPcontext;
	if ((__rdtsc() - *Pin_time) > 490000000) {
		return;//这个APC触发的时间太晚啦！早就不等它啦！
	}
	__try {
		memcpy(Pcontext->R0Buffer, Pcontext->Address, Pcontext->Length);
		Pcontext->Success = 1;

	}except(1) {
	
		Pcontext->Success = 2;
		Pcontext->ErrorCode = 0xff;
	}
	return;
}

BOOLEAN My_RundownRoutine() {
	return TRUE;//插入APC失败时调用这个函数
}

BOOLEAN New_SpecialApc_Task_Init(PKAPC APC,PETHREAD Thread, PReadMemory_Context Pcontext) {
	//DbgBreakPoint();
	KeInitializeApc(APC, Thread, 0, (PVOID)Read_Memory, NULL, (PVOID)My_RundownRoutine, 0, (ULONG64)Pcontext);
}

//通过PID对象读取内存
BOOLEAN Apc_Read_Process_Memory_By_Pid(ULONG64 Pid, PUCHAR R3_Buffer, ULONG64 Address, ULONG64 Length) {
	PEPROCESS PEProcess = NULL;
	if (Old_Pid == Pid) {
		return Apc_Read_Process_Memory_By_Eprocess(Old_Process, R3_Buffer, Address, Length);
	}
	else {
		if (!Get_pEprocess_By_Pid(Pid, &PEProcess))
			return FALSE;
		return Apc_Read_Process_Memory_By_Eprocess(PEProcess, R3_Buffer, Address, Length);
	}
}

//通过EPROCESS对象读取内存
BOOLEAN Apc_Read_Process_Memory_By_Eprocess(PEPROCESS PEProcess,  PUCHAR R3_Buffer, ULONG64 Address, ULONG64 Length) {
	
	PETHREAD Thread = NULL;
	BOOLEAN Return_Code = FALSE;
	PUCHAR R0_Buffer = ExAllocatePool(NonPagedPool, Length);
	ULONG64 in_time = __rdtsc();//读取当前cpu时间
	ULONG64 into = 0;//不用APC.Inserted来判断是因为它变化的太快，易出bug
	KAPC APC = { 0 };
	ReadMemory_Context context = { 0 };//用于和 kernelroutine 交流的上下文
	context.R0Buffer = R0_Buffer;
	context.Address = Address;
	context.Length = Length;

	if (R0_Buffer == NULL)
		return Return_Code;
	memset(R0_Buffer, 0, Length);

	while ((__rdtsc() - in_time) < 100000000) {//100毫秒都找不到能插的线程，说明这个进程是孤儿，不读他了
		if (!Get_APC_pThread_By_Process(PEProcess, &Thread)) {
			continue;
		}
		New_SpecialApc_Task_Init(&APC, Thread, &context);
		KeInsertQueueApc(&APC, in_time, NULL, 0);
		into = 1;
		break;
	}
	if (into == 0) {//不用APC.Inserted来判断是因为它变化的太快，易出bug
		goto EXIT;
	}
	while (context.Success == FALSE && (__rdtsc() - in_time) < 500000000 );//整个函数最多等待500毫秒
	if (context.Success == TRUE) {
		memcpy(R3_Buffer, R0_Buffer, Length);
		Return_Code = context.Success;
	}
EXIT:
	ExFreePool(R0_Buffer);
	return Return_Code;
}

```

`KernelSpecialAPC_ReadProcessMemory/kernel_special_APC.h`:

```h
#pragma once
#include<ntifs.h>


VOID Apc_Init();

//这个结构指针作为 kernelroutine 的参数
typedef struct _ReadMemory_Context {
	BOOLEAN Success;//是否成功读取
	UCHAR ErrorCode;//超时返回错误
	PUCHAR R0Buffer;//先读到这里，做缓冲区
	ULONG64 Address;//需要读取的地址
	ULONG64 Length;//需要读取的长度
}ReadMemory_Context,*PReadMemory_Context;


//通过PID对象读取内存
BOOLEAN Apc_Read_Process_Memory_By_Pid(ULONG64 Pid, PUCHAR R3_Buffer, ULONG64 Address, ULONG64 Length);

//通过EPROCESS对象读取内存
BOOLEAN Apc_Read_Process_Memory_By_Eprocess(PEPROCESS PEProcess, PUCHAR R3_Buffer, ULONG64 Address, ULONG64 Length);
```

`KernelSpecialAPC_ReadProcessMemory/main.c`:

```c
#include"head.h"

NTSTATUS Exit(DRIVER_OBJECT* DriverObject) {
	UNICODE_STRING symbolLinkName;
	DbgPrint("DriverUnload\n");
	if (DriverObject->DeviceObject)
		IoDeleteDevice(DriverObject->DeviceObject);
	RtlInitUnicodeString(&symbolLinkName, my_link_name);
	IoDeleteSymbolicLink(&symbolLinkName);
	return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(DRIVER_OBJECT* DriverObject, UNICODE_STRING* STR) {
	DriverObject->DriverUnload = Exit;
	NTSTATUS status = STATUS_SUCCESS;
	status = Create_Device(DriverObject);
	Apc_Init();
	if (!NT_SUCCESS(status))
	{
		DbgPrint("Create Device Error.\n");
		goto Exit;
	}

	return status;
	
Exit://Unload Driver
	return Exit(DriverObject);
}
```

`KernelSpecialAPC_ReadProcessMemory/内核学习.inf`:

```inf
;
; 内核学习.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=内核学习.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
内核学习_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
内核学习.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%内核学习.DeviceDesc%=内核学习_Device, Root\内核学习 ; TODO: edit hw-id

[内核学习_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
内核学习.sys

;-------------- Service installation
[内核学习_Device.NT.Services]
AddService = 内核学习,%SPSVCINST_ASSOCSERVICE%, 内核学习_Service_Inst

; -------------- 内核学习 driver install sections
[内核学习_Service_Inst]
DisplayName    = %内核学习.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\内核学习.sys

;
;--- 内核学习_Device Coinstaller installation ------
;

[内核学习_Device.NT.CoInstallers]
AddReg=内核学习_Device_CoInstaller_AddReg
CopyFiles=内核学习_Device_CoInstaller_CopyFiles

[内核学习_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[内核学习_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[内核学习_Device.NT.Wdf]
KmdfService =  内核学习, 内核学习_wdfsect
[内核学习_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "内核学习 Installation Disk"
内核学习.DeviceDesc = "内核学习 Device"
内核学习.SVCDESC = "内核学习 Service"

```

`Ring3_test_demo/APC_Read_Memory.cpp`:

```cpp
#include"Head.h"


BOOLEAN Apc_Read_Process_Memory_By_Pid(ULONG64 Pid, PUCHAR R3_Buffer, ULONG64 Address, ULONG64 Length) {
	R3_Read_Memory test = { 0 };
	test.Pid = Pid;
	test.Address = Address;
	test.Length = Length;
	test.Read_Buffer = R3_Buffer;
	DWORD lent = 0;
	if (!DeviceIoControl(Test_Drv, TEST, NULL, 0, &test, sizeof(R3_Read_Memory), &lent, NULL)) {
		printf("devio error !!!\n");
		return FALSE;
	}
	if(lent!=1){
		return FALSE;
	}
	return TRUE;
	
}
```

`Ring3_test_demo/APC_Read_Memory.h`:

```h
#pragma once
#include<Windows.h>

typedef struct _R3_Read_Memory {
	ULONG64 Pid;
	PUCHAR Read_Buffer;
	ULONG64 Address;
	ULONG64 Length;
}R3_Read_Memory, * PR3_Read_Memory;

BOOLEAN Apc_Read_Process_Memory_By_Pid(ULONG64 Pid, PUCHAR R3_Buffer, ULONG64 Address, ULONG64 Length);
```

`Ring3_test_demo/Device.cpp`:

```cpp
#include "Head.h"

HANDLE Test_Drv = NULL;


BOOLEAN Connecting_Ring0() {
	Test_Drv = CreateFile(DEVICE_NAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, NULL);
	if (Test_Drv == INVALID_HANDLE_VALUE)
	{
		DWORD Error_Code = GetLastError();
		CloseHandle(Test_Drv);
		printf("Connecting_Ring0 ERROR：%d", Error_Code);
		return FALSE;
	}
	return TRUE;

}

```

`Ring3_test_demo/Device.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#define DEVICE_NAME L"\\\\.\\APC_Drv" //符号链接名

#define TEST CTL_CODE(FILE_DEVICE_UNKNOWN,0x99f,METHOD_NEITHER,FILE_ANY_ACCESS)//功能测试



extern HANDLE Test_Drv;


BOOLEAN Connecting_Ring0();
```

`Ring3_test_demo/Head.h`:

```h
#pragma once
#include"Device.h"
#include"APC_Read_Memory.h"



```

`Ring3_test_demo/Ring31.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{bf1067e9-7f12-4125-9696-c4c356256c46}</ProjectGuid>
    <RootNamespace>Ring31</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Ring3_test</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="APC_Read_Memory.cpp" />
    <ClCompile Include="Device.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="APC_Read_Memory.h" />
    <ClInclude Include="Device.h" />
    <ClInclude Include="Head.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Ring3_test_demo/Ring31.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Device.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="APC_Read_Memory.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Head.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Device.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="APC_Read_Memory.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Ring3_test_demo/Ring31.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Ring3_test_demo/Ring3_test.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31911.196
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Ring31", "Ring31.vcxproj", "{BF1067E9-7F12-4125-9696-C4C356256C46}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{BF1067E9-7F12-4125-9696-C4C356256C46}.Debug|x64.ActiveCfg = Debug|x64
		{BF1067E9-7F12-4125-9696-C4C356256C46}.Debug|x64.Build.0 = Debug|x64
		{BF1067E9-7F12-4125-9696-C4C356256C46}.Debug|x86.ActiveCfg = Debug|Win32
		{BF1067E9-7F12-4125-9696-C4C356256C46}.Debug|x86.Build.0 = Debug|Win32
		{BF1067E9-7F12-4125-9696-C4C356256C46}.Release|x64.ActiveCfg = Release|x64
		{BF1067E9-7F12-4125-9696-C4C356256C46}.Release|x64.Build.0 = Release|x64
		{BF1067E9-7F12-4125-9696-C4C356256C46}.Release|x86.ActiveCfg = Release|Win32
		{BF1067E9-7F12-4125-9696-C4C356256C46}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7B8B3482-C5DE-4C49-AE9D-E06FB047CC68}
	EndGlobalSection
EndGlobal

```

`Ring3_test_demo/main.cpp`:

```cpp
#include"Head.h"


int main() {

	Connecting_Ring0();
	system("pause");
	
	ULONG64 time = 0;
	ULONG64 Mytime = 0;
	ULONG64 Nttime = 0;
	
	ULONG64 Mycs = 0;
	ULONG64 Ntcs = 0;

	DWORD PID = 0x1994;
	LPCVOID ADD = (LPCVOID)0x254DE0C6054;
	PUCHAR Mybuffer = (PUCHAR)malloc(0x1000);
	PUCHAR Ntbuffer = (PUCHAR)malloc(0x1000);
	ULONG64 Length = 30;
	if (Mybuffer == NULL || Ntbuffer == NULL)
		return 0;
	memset(Mybuffer, 0, 0x1000);
	memset(Ntbuffer, 0, 0x1000);

	Mytime = GetTickCount64();
	for (int i = 0; i < 1000000; i++) {
		if (!Apc_Read_Process_Memory_By_Pid(PID, Mybuffer, (ULONG64)ADD, Length)) {
			printf("无法读取！\n");
			break;
		}
		else {
			Mycs++;
		}
	}
	Mytime =  GetTickCount64() - Mytime;

	HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 0x1994);
	
	Nttime = GetTickCount64();
	for (int i = 0; i < 1000000; i++) {
		if (!ReadProcessMemory(process, ADD, Ntbuffer, Length, NULL)) {
			printf("Nt无法读取！\n");
			break;
		}
		else {
			Ntcs++;
		}
	}
	Nttime =  GetTickCount64() - Nttime;




	printf("\nAPC读取内存%ld次总时间：%ld \n读取内存为：\n", Mycs, Mytime);
	for (int i = 0; i < Length; i++) {
		printf("%02X  ", Mybuffer[i]);
	}
	printf("\n");
	printf("\nReadProcessMemory读取内存%ld次总时间：%ld \n读取内存为：\n", Ntcs, Nttime);
	for (int i = 0; i < Length; i++) {
		printf("%02X  ", Ntbuffer[i]);
	}
	printf("\n");
	CloseHandle(process);
	CloseHandle(Test_Drv);
	system("pause");
}
```

`Test picture/0`:

```
1

```

`readme.md`:

```md
## 通过插入内核特殊APC读取进程内存

#### Read process memory by inserting kernel special APC

当然了，如何插入内核特殊APC才是该项目的重点，利用内核特殊APC能做到的事情可太多了。

(Of course, how to insert the kernel special APC is the focus of the project. There are too many things that can be done with the kernel special APC.)

### 优点：

不需要获取进程句柄。不需要挂靠进程（线程）。不需要切换CR3。使目标进程主动帮助我们读取内存。

（There is no need to get a process handle. There is no need to attach a process (thread). There is no need to switch CR3. Make the target process actively help us read the memory.）

### 缺点：

因为没有创建新的线程在目标进程上下文，所以，读取内存的时间相比挂靠进程（线程）的方式要慢上许多。（但也可以接受）

（Because no new thread is created in the context of the target process, the time of reading memory is much slower than that of attaching process (thread).(But it is also acceptable)）

![tsapctest](https://github.com/IcEy-999/Kernel-Special-APC-ReadProcessMemory/blob/main/Test%20picture/tsapctest.png)

**读取速度测试（Read speed test）  demo is Ring3_test_demo**：

KernelSpecialAPC ：

读取 1000000 次长度为 30 字节的内存所需时间为：21985 ms

(Time required to read 1000000 times of memory with length of 30 bytes: 21985 ms)

ReadProcessMemory：

读取1000000 次长度为 30 字节的内存所需时间为：890 ms

(The time required to read 1000000 times of memory with a length of 30 bytes is: 890 ms)



**当进程全部线程被挂起时，无法读取内存！**

(Cannot read memory when all threads of the process are suspended!)



### **需要修改的地方（What needs to be modified）**：

一、 kernel_special_APC.c

```c
VOID Apc_Init() {
	PULONG64 P_KeInitializeApc = (PULONG64)&KeInitializeApc;
	PULONG64 P_KeInsertQueueApc = (PULONG64)&KeInsertQueueApc;

	//填入KeInitializeApc函数地址
	*P_KeInitializeApc = 0xfffff8042b62a530;

	//填入KeInsertQueueApc函数地址
	*P_KeInsertQueueApc = 0xfffff8042b63dc10;
}
```

二、Process_Thread.h

```c
enum  Eprocess_Members_Offset //自己想办法获取进程结构偏移
{
	ThreadListHead = 0x30,//线程链表
	ProcessListEntry = 0x240,//进程链表
	UniqueProcessId = 0x2e0,//进程PID

};

enum Ethread_Members_Offset //自己想办法获取线程结构偏移
{
	Running = 0x71,
	SpecialApcDisable = 0x1e6,
	ThreadListEntry = 0x2f8,
};
```

关于如何动态获取上述 函数地址 和 结构偏移，请查看我的另一个项目：[Ntoskrnl_Viewer](https://github.com/IcEy-999/Ntoskrnl_Viewer)

For how to dynamically obtain the above function address and structure offset, please see my other project：[Ntoskrnl_Viewer](https://github.com/IcEy-999/Ntoskrnl_Viewer)




```