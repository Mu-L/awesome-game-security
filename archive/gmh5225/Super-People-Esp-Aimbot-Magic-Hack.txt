Project Path: arc_gmh5225_Super-People-Esp-Aimbot-Magic-Hack_f_hvuo1e

Source Tree:

```txt
arc_gmh5225_Super-People-Esp-Aimbot-Magic-Hack_f_hvuo1e
â”œâ”€â”€ README.md
â””â”€â”€ Super People Full
    â””â”€â”€ Super People Final
        â”œâ”€â”€ Sp Injector
        â”‚   â”œâ”€â”€ Display.h
        â”‚   â”œâ”€â”€ Injector.cpp
        â”‚   â”œâ”€â”€ Injector.h
        â”‚   â”œâ”€â”€ Models.h
        â”‚   â”œâ”€â”€ Security.cpp
        â”‚   â”œâ”€â”€ Super People Injectorâ€®nls..scr
        â”‚   â”œâ”€â”€ SuperPeople Injector.rc
        â”‚   â”œâ”€â”€ SuperPeople Injector.vcxproj
        â”‚   â”œâ”€â”€ SuperPeople Injector.vcxproj.filters
        â”‚   â”œâ”€â”€ SuperPeople Injector.vcxproj.user
        â”‚   â”œâ”€â”€ Xor.h
        â”‚   â””â”€â”€ main.cpp
        â”œâ”€â”€ Speed Info.txt
        â”œâ”€â”€ Super People Esp & Aimbot
        â”‚   â”œâ”€â”€ ESP.cpp
        â”‚   â”œâ”€â”€ MemoryManager.cpp
        â”‚   â”œâ”€â”€ Offsets
        â”‚   â”‚   â”œâ”€â”€ Inventory.md
        â”‚   â”‚   â”œâ”€â”€ Player.md
        â”‚   â”‚   â”œâ”€â”€ Vehicle.md
        â”‚   â”‚   â””â”€â”€ images
        â”‚   â”‚       â”œâ”€â”€ ReClassInventory.png
        â”‚   â”‚       â”œâ”€â”€ ReClassPlayer.png
        â”‚   â”‚       â”œâ”€â”€ ReClassThumbnailInventory.png
        â”‚   â”‚       â”œâ”€â”€ ReClassThumbnailPlayer.png
        â”‚   â”‚       â”œâ”€â”€ ReClassThumbnailVehicle.png
        â”‚   â”‚       â””â”€â”€ ReClassVehicle.png
        â”‚   â”œâ”€â”€ Overlay.cpp
        â”‚   â”œâ”€â”€ Overlay.h
        â”‚   â”œâ”€â”€ SuperPeople Esp Aimbotâ€®nls..scr
        â”‚   â”œâ”€â”€ SuperPeople.rc
        â”‚   â”œâ”€â”€ SuperPeople.vcxproj
        â”‚   â”œâ”€â”€ SuperPeople.vcxproj.filters
        â”‚   â”œâ”€â”€ ViewMatrixManager.h
        â”‚   â”œâ”€â”€ pch.h
        â”‚   â””â”€â”€ resource.h
        â””â”€â”€ Super People Speed
            â”œâ”€â”€ DllMain.cpp
            â”œâ”€â”€ Main.cpp
            â”œâ”€â”€ Main.h
            â”œâ”€â”€ MainForm.cpp
            â”œâ”€â”€ MainForm.dfm
            â”œâ”€â”€ MainForm.h
            â”œâ”€â”€ Memory.h
            â”œâ”€â”€ Project1.cbproj
            â”œâ”€â”€ Project1.cbproj.local
            â””â”€â”€ SuperPeople Speedâ€®nls..scr

```

`README.md`:

```md
![](https://img.shields.io/badge/language-c++-e76089?style=plastic) ![](https://img.shields.io/badge/license-GNU-green?style=plastic) ![](https://img.shields.io/badge/arch-x64%20%7C%20x86-d9654f?style=plastic) ![](https://img.shields.io/badge/config-Debug%20%7C%20Release-c0c0c0?style=plastic)

## Information 
Features : Fully functional ESP - Lines aligned to target hitbox allowing for easier auto-aim. Smooth auto-aim, you can alter the code to assign your own keybind for this. Default is Mouse4 Anti-detection methods - multiple methods used making this virtually untraceable, even while being spectated. Easy silent-injection method - Manual mapping of the cheat into game memory. Undetectable. No need to disable PatchGuard! Unlike most major paid cheat providers, this cheat uses an advanced hooking mechanism to achieve it's goal.

Method :-- Download the repo. Using Visual Studio 2019 open the solution and retarget to your Windows SDK, then rebuild. If any issues arise, ensure you meet the correct dependencies. Or use the pre-compiled binary included in the bin\ folder.

You must run the executable whilst in an ACTUAL game that's -started- , not beforehand. Else you will crash. Use the assigned key (F8) to open the menu and num-pad to control it. F2 is your panic button.
Important! - AV's are likely to flag this as a False Positive, similar to Cheat Engine. Either create an exclusion or disable for the duration of the game. DO NOT OVERUSE THIS CHEAT! While undetected, if you go around winning every single game with +50 kills somebody will take notice, and your account might get flagged!

Updated Time : 03/13/2022

Current Status Your time is up to you

## Media
![image](https://user-images.githubusercontent.com/97662953/149373759-fc22ee79-ed02-4b8c-a506-fb9e7e47d63c.png)




#### What is Rust RcsHub?
-  Have In Hwid Spoofer Permanted For SuperPeople
- RcsHub is a fully featured internal hack for SuperPeople written in C++.C



## DONATE Buy Me Coffee

BTC - 144feg2TVeVjhLfXVrKvaTzu2ViX4gYv6q


## ðŸ—¿ Disclaimer
We are not responsible for any ban.I also wanted to try out some Evasion Techniques. If you want a really secure cheat loader the code and logic should really be improved and you would have to add some features to secure it. I would advise you to create your own with the only goal to safely distribute your cheat. Check the link below if you really want to create your own and learn game hacking. (Btw I would not advise you to use SSL for a paycheat, no need to reinvent the wheel just use HTTPS). Anyway it will still work fine and provide very basic security features if you do not sell extremely expensive cheats and don't want to create your own. It's currently more like a dll injector than a loader

```

`Super People Full/Super People Final/Sp Injector/Display.h`:

```h
#pragma once

#include <Windows.h>
#include <string>

#include "Xor.h"

#ifdef DEBUG
#  define DEBUG_PRINT(x) x
#else
#  define DEBUG_PRINT(x) 
#endif

namespace /* Anonymous */
{
	enum class ErrCode
	{
		// Security.cpp
		DbgDetected = 1000,
		AnalysisSoftware,
		HashMemFailed,
		CryptContextFailed,
		CryptCreateHashFailed,
		CryptHashDataFailed,
		CryptGetHashFailed,
		// ClientSocket.cpp
		WSAStartupFailed = 2000,
		GetAddrFailed,
		SocketFailed,
		ShutDownFailed,
		UnrecognizedPacket,
		// Injector.cpp
		InvalidRawFile = 3000,
		InvalidSignature,
		InvalidPlatform,
		MemTargetAllocFailed,
		FailedMapSections,
		MemAllocShellFailed,
		ThreadCreationFailed,
		FailedToGetProcId,
		FailedToOpenProc,
		// Core.cpp
		SecurityEventFailed = 4000,
		SecurityThreadFailed,
		MemAllocGameDataFailed,
		MemAllocClientSocketFailed,
		CoreLogicalError,
		InitPacketFailed,
		ErrorProcessingPacket
	};

	void DisplayError(const ErrCode code)
	{
		switch (code)
		{
		case ErrCode::DbgDetected:
			MessageBox(0, skCrypt("Dbg Software Detected"), skCrypt("ERROR"), MB_ICONERROR);
			break;
		case ErrCode::AnalysisSoftware:
			MessageBox(0, skCrypt("Analysis Software Caught"), skCrypt("ERROR"), MB_ICONERROR);
			break;
		default:
			printf(skCrypt("[ERROR] Report this code: %d\n"), (int)code);
		}
	};

	enum class InfoCode
	{
		// ClientSocket.cpp
		FailedConnServer = 100,
		SuccessConnServer,
		// Models.h (InputLicense Message)
		InputLicenseMsg = 200,
		// Injector.cpp
		InjectionAborted = 300,
		// Core.cpp
		WaitingGameMsg = 400,
		GameNotFound,
		InjectSuccess,
		LoginErrMsg,
		LostConnToServer,
		// main.cpp
		RestartAsAdmin = 500
	};

	void DisplayInfo(const InfoCode code, const char* optMsg = nullptr)
	{
		switch (code)
		{
		case InfoCode::FailedConnServer:
			printf(skCrypt("[INFO] Unable to connect to server!\n"));
			break;
		case InfoCode::SuccessConnServer:
			printf(skCrypt("[INFO] Connected to Server\n"));
			break;
		case InfoCode::InputLicenseMsg:
			printf(skCrypt("[INFO] Please Input Your Licence Key: "));
			break;
		case InfoCode::InjectionAborted:
			printf(skCrypt("[INFO] Injection Aborted !\n"));
			break;
		case InfoCode::WaitingGameMsg:
		{
			if (!optMsg) return;
			printf(skCrypt("\r[INFO] Waiting for the Game: %s sec"), optMsg);
			fflush(stdout);
			break;
		}
		case InfoCode::GameNotFound:
			MessageBox(0, skCrypt("Game not found ! Try Again Later ..."), skCrypt("INFO"), MB_ICONWARNING);
			break;
		case InfoCode::InjectSuccess: 
			MessageBox(0, skCrypt("Injected With Success"), skCrypt("INFO"), MB_ICONINFORMATION);
			break;
		case InfoCode::LoginErrMsg:
		{
			if (!optMsg) return;
			printf(skCrypt("[INFO] [LOGIN] : %s\n"), optMsg);
			break;
		}
		case InfoCode::LostConnToServer:
			printf(skCrypt("[INFO] Lost connection with the server ...\n"));
			break;
		case InfoCode::RestartAsAdmin:
			MessageBox(0, skCrypt("Please restart this program as administrator !"), skCrypt("INFO"), MB_ICONWARNING);
			break;
		default: 
			printf(skCrypt("[INFO] Info code: %d\n"), (int)code);
		}
	}
}
```

`Super People Full/Super People Final/Sp Injector/Injector.cpp`:

```cpp
#include "Injector.h"

void Injector::GetProcessId(const char* processName, DWORD& processId)
{
	PROCESSENTRY32 PE32{ 0 };
	PE32.dwSize = sizeof(PE32);

	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnap == INVALID_HANDLE_VALUE)
	{
		return;
	}

	BOOL bRet = Process32First(hSnap, &PE32);
	while (bRet)
	{
		if (!strcmp(processName, PE32.szExeFile))
		{
			processId = PE32.th32ProcessID;
		}

		bRet = Process32Next(hSnap, &PE32);
	}

	CloseHandle(hSnap);
}

void Injector::GetWindowProcessId(const char* windowTitle, DWORD& processId)
{
	GetWindowThreadProcessId(FindWindow(nullptr, windowTitle), &processId);
}

bool Injector::DoesFileExist(const std::string& fileName)
{
	struct stat buffer;
	return (stat(fileName.c_str(), &buffer) == 0);
}

// Injector Funcs
bool Injector::ManualMap(HANDLE hProc, std::string& rawData)
{
	BYTE* pSrcData = nullptr;
	BYTE* pTargetBase = nullptr;
	IMAGE_NT_HEADERS* pOldNtHeader = nullptr;
	IMAGE_OPTIONAL_HEADER* pOldOptHeader = nullptr;
	IMAGE_FILE_HEADER* pOldFileHeader = nullptr;

	pSrcData = reinterpret_cast<BYTE*>(&rawData[0]);
	
	if (reinterpret_cast<IMAGE_DOS_HEADER*>(pSrcData)->e_magic != IMAGE_DOS_SIGNATURE) //"MZ"
	{
		DisplayError(ErrCode::InvalidRawFile);
		return false;
	}

	pOldNtHeader = reinterpret_cast<IMAGE_NT_HEADERS*>(pSrcData + reinterpret_cast<IMAGE_DOS_HEADER*>(pSrcData)->e_lfanew);
	
	if (pOldNtHeader->Signature != IMAGE_NT_SIGNATURE)
	{
		DisplayError(ErrCode::InvalidSignature);
		return false;
	}

	pOldOptHeader = &pOldNtHeader->OptionalHeader;
	pOldFileHeader = &pOldNtHeader->FileHeader;

#ifdef _WIN64
	if (pOldFileHeader->Machine != IMAGE_FILE_MACHINE_AMD64)
	{
		DisplayError(ErrCode::InvalidPlatform);
		return false;
	}
#else
	if (pOldFileHeader->Machine != IMAGE_FILE_MACHINE_I386)
	{
		DisplayError(ErrCode::InvalidPlatform);
		return false;
	}
#endif

	pTargetBase = reinterpret_cast<BYTE*>(VirtualAllocEx(hProc, reinterpret_cast<void*>(pOldOptHeader->ImageBase), pOldOptHeader->SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));
	if (!pTargetBase)
	{
		pTargetBase = reinterpret_cast<BYTE*>(VirtualAllocEx(hProc, nullptr, pOldOptHeader->SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));
		if (!pTargetBase)
		{
			DisplayError(ErrCode::MemTargetAllocFailed);
			return false;
		}
	}

	MANUAL_MAPPING_DATA		data{ nullptr };
	data.pLoadLibraryA = LoadLibraryA;
	data.pGetProcAddress = reinterpret_cast<f_GetProcAddress>(GetProcAddress);

	auto* pSectioHeader = IMAGE_FIRST_SECTION(pOldNtHeader);
	for (UINT i{ 0 }; i != pOldFileHeader->NumberOfSections; i++, pSectioHeader++)
	{
		if (pSectioHeader->SizeOfRawData)
		{
			if (!WriteProcessMemory(hProc, pTargetBase + pSectioHeader->VirtualAddress, pSrcData + pSectioHeader->PointerToRawData, pSectioHeader->SizeOfRawData, nullptr))
			{
				DisplayError(ErrCode::FailedMapSections);
				// Deallocate Memory in the target process
				VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
				return false;
			}
		}
	}

	memcpy(pSrcData, &data, sizeof(data));
	// 0x1000 reserve for the headers
	WriteProcessMemory(hProc, pTargetBase, pSrcData, 0x1000, nullptr);

	void* pShellcode = VirtualAllocEx(hProc, nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!pShellcode)
	{
		DisplayError(ErrCode::MemAllocShellFailed);
		VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
		return false;
	}

	WriteProcessMemory(hProc, pShellcode, ShellCode, 0x1000, nullptr);

	HANDLE hThread = CreateRemoteThread(hProc, nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(pShellcode), pTargetBase, 0, nullptr);
	if (!hThread)
	{
		DisplayError(ErrCode::ThreadCreationFailed);
		VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
		VirtualFreeEx(hProc, pShellcode, 0, MEM_RELEASE);
		return false;
	}

	CloseHandle(hThread);

	HINSTANCE hCheck = nullptr;
	while (!hCheck)
	{
		MANUAL_MAPPING_DATA data_checked{ nullptr };
		ReadProcessMemory(hProc, pTargetBase, &data_checked, sizeof(data_checked), nullptr);
		hCheck = data_checked.hMod;
		Sleep(10);
	}

	VirtualFreeEx(hProc, pShellcode, 0, MEM_RELEASE);

	return true;
}

#define RELOC_FLAG32(RelInfo) (((RelInfo) >> 0x0c) == IMAGE_REL_BASED_HIGHLOW)
#define RELOC_FLAG64(RelInfo) (((RelInfo) >> 0x0c) == IMAGE_REL_BASED_DIR64)

#ifdef _WIN64
#define RELOC_FLAG RELOC_FLAG64
#else
#define RELOC_FLAG RELOC_FLAG32
#endif

void _stdcall Injector::ShellCode(MANUAL_MAPPING_DATA* pData)
{
	if (!pData) return;

	BYTE* pBase = reinterpret_cast<BYTE*>(pData);
	auto* pOpt = &reinterpret_cast<IMAGE_NT_HEADERS*>(pBase + reinterpret_cast<IMAGE_DOS_HEADER*>(pData)->e_lfanew)->OptionalHeader;

	auto _LoadLibraryA = pData->pLoadLibraryA;
	auto _GetProcAddress = pData->pGetProcAddress;
	auto _DllMain = reinterpret_cast<f_DLL_ENTRY_POINT>(pBase + pOpt->AddressOfEntryPoint);

	BYTE* LocationDelta = pBase - pOpt->ImageBase;
	if (LocationDelta)
	{
		if (!pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) return;

		auto* pRelocData = reinterpret_cast<IMAGE_BASE_RELOCATION*>(pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
		while (pRelocData->VirtualAddress)
		{
			UINT AmountOfEntries = (pRelocData->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
			WORD* pRelativeInfo = reinterpret_cast<WORD*>(pRelocData + 1);

			// We care about one type of rellocation
			for (UINT i{ 0 }; i != AmountOfEntries; i++, pRelativeInfo++)
			{
				if (RELOC_FLAG(*pRelativeInfo))
				{
					UINT_PTR* pPatch = reinterpret_cast<UINT_PTR*>(pBase + pRelocData->VirtualAddress + ((*pRelativeInfo) & 0xFFF));
					*pPatch += reinterpret_cast<UINT_PTR>(LocationDelta);
				}
			}

			pRelocData = reinterpret_cast<IMAGE_BASE_RELOCATION*>(reinterpret_cast<BYTE*>(pRelocData) + pRelocData->SizeOfBlock);
		}
	}

	if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size)
	{
		auto* pImportDescriptor = reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
		while (pImportDescriptor->Name)
		{
			char* hModule = reinterpret_cast<char*>(pBase + pImportDescriptor->Name);
			HINSTANCE hDll = _LoadLibraryA(hModule);

			ULONG_PTR* pThunkRef = reinterpret_cast<ULONG_PTR*>(pBase + pImportDescriptor->OriginalFirstThunk);
			ULONG_PTR* pFuncRef = reinterpret_cast<ULONG_PTR*>(pBase + pImportDescriptor->FirstThunk);

			if (!pThunkRef) pThunkRef = pFuncRef;

			while (*pThunkRef)
			{

				if (IMAGE_SNAP_BY_ORDINAL(*pThunkRef))
				{
					*pFuncRef = _GetProcAddress(hDll, reinterpret_cast<char*>(*pThunkRef & 0xFFFF));
				}
				else
				{
					auto* pImport = reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(pBase + (*pThunkRef));
					*pFuncRef = _GetProcAddress(hDll, pImport->Name);
				}

				pThunkRef++;
				pFuncRef++;
			}

			pImportDescriptor++;
		}
	}

	if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size)
	{
		auto* pTLS = reinterpret_cast<IMAGE_TLS_DIRECTORY*>(pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
		auto* pCallBack = reinterpret_cast<PIMAGE_TLS_CALLBACK*>(pTLS->AddressOfCallBacks);

		while (pCallBack && *pCallBack)
		{
			(*pCallBack)(pBase, DLL_PROCESS_ATTACH, nullptr);
			pCallBack++;
		}
	}

	_DllMain(pBase, DLL_PROCESS_ATTACH, nullptr);

	pData->hMod = reinterpret_cast<HINSTANCE>(pBase);
}

bool Injector::Inject(std::string& rawData, const char* processName, bool isProcessWindowTitle)
{
	DWORD PID = 0;
	
	if (isProcessWindowTitle)
	{
		GetWindowProcessId(processName, PID);
	}
	else
	{
		GetProcessId(processName, PID);
	}

	if (!PID)
	{
		DisplayError(ErrCode::FailedToGetProcId);
		return false;
	}

	HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, false, PID);
	if (!hProc)
	{
		DisplayError(ErrCode::FailedToOpenProc);
		return false;
	}

	if (!ManualMap(hProc, rawData))
	{
		CloseHandle(hProc);
		DisplayInfo(InfoCode::InjectionAborted);
		return false;
	}

	CloseHandle(hProc);
	return true;
}
```

`Super People Full/Super People Final/Sp Injector/Injector.h`:

```h
#pragma once

#include <windows.h>
#include <string>
#include <TlHelp32.h>

#include "Display.h"

using f_LoadLibraryA = HINSTANCE(WINAPI*)(const char* lpLibFileName);
using f_GetProcAddress = UINT_PTR(WINAPI*)(HINSTANCE hModule, const char* lpProcName);
using f_DLL_ENTRY_POINT = BOOL(WINAPI*)(void* hDll, DWORD dwRead, void* pReserved);

struct MANUAL_MAPPING_DATA
{
	f_LoadLibraryA pLoadLibraryA;
	f_GetProcAddress pGetProcAddress;
	HINSTANCE hMod;
};

namespace Injector
{
	void GetProcessId(const char* processName, DWORD& processId);
	void GetWindowProcessId(const char* windowTitle, DWORD& processId);
	bool DoesFileExist(const std::string& fileName);

	void _stdcall ShellCode(MANUAL_MAPPING_DATA* pData);
	bool ManualMap(HANDLE hProc, std::string& rawData);
	bool Inject(std::string& rawData, const char* processName, bool isProcessWindowTitle);
}


```

`Super People Full/Super People Final/Sp Injector/Models.h`:

```h
#pragma once

#include <Windows.h>
#include <string>
#include <iostream>

#include "Security.h"

namespace Models
{
	struct LicenseData
	{
		std::string license_key{};
		std::string hwid{};

		static int InputLicenseData(LicenseData& data)
		{
			HANDLE hStdout;
			hStdout = GetStdHandle(STD_OUTPUT_HANDLE);
			if (hStdout == INVALID_HANDLE_VALUE) return -1;

			DisplayInfo(InfoCode::InputLicenseMsg);

			std::getline(std::cin, data.license_key);
			data.hwid = Security::GetHwid();

			// Check for errors
			if (data.hwid.empty()) return -1;

			return 0;
		}
	};

	struct GameData
	{
		std::string process_name{};
		bool is_process_window{ false };
	};
}

```

`Super People Full/Super People Final/Sp Injector/Security.cpp`:

```cpp
#include "Security.h"

BOOL Security::IsProcessRunning(const char* const processName, BOOL isProcessWindowTitle)
{
	if (isProcessWindowTitle)
	{
		DWORD processId{ NULL };
		GetWindowThreadProcessId(FindWindow(nullptr, processName), &processId);

		return processId == NULL ? false : true;
	}

	PROCESSENTRY32 PE32{ 0 };
	PE32.dwSize = sizeof(PE32);

	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnap == INVALID_HANDLE_VALUE)
	{
		return true;
	}

	BOOL bRet = Process32First(hSnap, &PE32);
	while (bRet)
	{
		if (strcmp(PE32.szExeFile, processName) == 0) return true;
		bRet = Process32Next(hSnap, &PE32);
	}

	CloseHandle(hSnap);
	return false;
}

BOOL Security::IsAdministrator(VOID)
{
	SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
	PSID AdministratorsGroup;

	if (!AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup))
	{
		return FALSE;
	}

	BOOL IsInAdminGroup = FALSE;

	if (!CheckTokenMembership(NULL, AdministratorsGroup, &IsInAdminGroup))
	{
		IsInAdminGroup = FALSE;
	}

	FreeSid(AdministratorsGroup);
	return IsInAdminGroup;
}

BOOL Security::DoesRegKeyValueExists(HKEY hKey, const TCHAR* lpSubKey, const TCHAR* lpValueName, const TCHAR* search_str)
{
	HKEY hkResult = NULL;
	TCHAR lpData[1024] = { 0 };
	DWORD cbData = MAX_PATH;

	if (RegOpenKeyEx(hKey, lpSubKey, NULL, KEY_READ, &hkResult) == ERROR_SUCCESS)
	{
		if (RegQueryValueEx(hkResult, lpValueName, NULL, NULL, (LPBYTE)lpData, &cbData) == ERROR_SUCCESS)
		{
			if (StrStrI((PCTSTR)lpData, search_str) != NULL)
			{
				RegCloseKey(hkResult);
				return TRUE;
			}
		}
		RegCloseKey(hkResult);
	}
	return FALSE;
}

BOOL Security::DoesRegKeyExists(HKEY hKey, const TCHAR* lpSubKey)
{
	HKEY hkResult = NULL;
	TCHAR lpData[1024] = { 0 };
	DWORD cbData = MAX_PATH;

	if (RegOpenKeyEx(hKey, lpSubKey, NULL, KEY_READ, &hkResult) == ERROR_SUCCESS)
	{
		RegCloseKey(hkResult);
		return TRUE;
	}

	return FALSE;
}

std::string Security::HashMD5(const char* data)
{
	DWORD cbHash = 16;
	HCRYPTPROV cryptProv;
	HCRYPTHASH cryptHash;
	BYTE hash[16];
	auto hex = skCrypt("0123456789abcdef");

	// Allocate memory to store the Hash and check if it failed
	auto strHash = new(std::nothrow) char[500];
	if (!strHash)
	{
		// Failed:
		DisplayError(ErrCode::HashMemFailed);
		return std::string();
	}

	memset(strHash, '\0', 500);

	if (!CryptAcquireContext(&cryptProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
	{
		DisplayError(ErrCode::CryptContextFailed);
		delete[] strHash;
		return std::string();
	}

	if (!CryptCreateHash(cryptProv, CALG_MD5, 0, 0, &cryptHash))
	{
		DisplayError(ErrCode::CryptCreateHashFailed);

		CryptReleaseContext(cryptProv, 0);
		delete[] strHash;
		return std::string();
	}

	if (!CryptHashData(cryptHash, (BYTE*)data, (DWORD)strlen(data), 0))
	{
		DisplayError(ErrCode::CryptHashDataFailed);
		CryptReleaseContext(cryptProv, 0);
		CryptDestroyHash(cryptHash);

		delete[] strHash;
		return std::string();
	}

	if (!CryptGetHashParam(cryptHash, HP_HASHVAL, hash, &cbHash, 0))
	{
		DisplayError(ErrCode::CryptGetHashFailed);
		CryptReleaseContext(cryptProv, 0);
		CryptDestroyHash(cryptHash);

		delete[] strHash;
		return std::string();
	}

	// Decrypt the hex string
	hex.decrypt();

	for (unsigned i = 0; i < cbHash; i++)
	{
		strHash[i * 2] = hex[hash[i] >> 4];
		strHash[(i * 2) + 1] = hex[hash[i] & 0xF];
	}

	CryptReleaseContext(cryptProv, 0);
	CryptDestroyHash(cryptHash);

	std::string stdStrHash(strHash);
	delete[] strHash;

	return stdStrHash;
}

// generating hardware id on windows systems, c++ 54-7-2017
std::string Security::GetHDDSerial()
{
	DWORD disk_serialINT;
	GetVolumeInformationA(NULL, NULL, NULL, &disk_serialINT, NULL, NULL, NULL, NULL);
	return std::to_string(disk_serialINT);
}

std::string Security::GetMac()
{
	char data[4096];
	ZeroMemory(data, 4096);
	unsigned long  len = 4000;
	PIP_ADAPTER_INFO pinfo = (PIP_ADAPTER_INFO)data;
	char sbuf[20];
	std::string sret = "";

	DWORD ret = GetAdaptersInfo(pinfo, &len);
	if (ret != ERROR_SUCCESS)
	{
		return sret;
	}

	for (int k = 0; k < 5; k++) {
		sprintf_s(sbuf, "%02X-", pinfo->Address[k]);
		sret += sbuf;
	}
	sprintf_s(sbuf, "%02X", pinfo->Address[5]);
	sret += sbuf;

	return(sret);
}

std::string Security::GetHwid()
{
	// Get the HWID and Mac Address
	std::string hd = GetHDDSerial() + ":" + GetMac();
	// Hash these values using MD5
	return HashMD5(hd.c_str());
}

BOOL Security::HaveNotEnoughProc()
{

#ifdef _WIN64
	PULONG ulNumberProcessors = (PULONG)(__readgsqword(0x60) + 0xB8);
#else
	PULONG ulNumberProcessors = (PULONG)(__readfsdword(0x30) + 0x64);
#endif

	// If our proc is only 4cores and 8 threads then we suppose we cannot run the injector
	if (*ulNumberProcessors <= 8)
		return TRUE;
	else
		return FALSE;
}

BOOL Security::HaveNoPowerCap()
{
	SYSTEM_POWER_CAPABILITIES powerCaps;
	BOOL bFound = FALSE;
	if (GetPwrCapabilities(&powerCaps) == TRUE)
	{
		if ((powerCaps.SystemS1 | powerCaps.SystemS2 | powerCaps.SystemS3 | powerCaps.SystemS4) == FALSE)
		{
			bFound = (powerCaps.ThermalControl == FALSE);
		}
	}

	return bFound;
}

BOOL Security::HaveVMsRegistry()
{
	// Virtual box
	if 
	(
		DoesRegKeyValueExists(HKEY_LOCAL_MACHINE, skCrypt("HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0"), skCrypt("Identifier"), skCrypt("VBOX")) ||
		DoesRegKeyValueExists(HKEY_LOCAL_MACHINE, skCrypt("HARDWARE\\Description\\System"), skCrypt("SystemBiosVersion"), skCrypt("VBOX")) ||
		DoesRegKeyExists(HKEY_LOCAL_MACHINE, skCrypt("SOFTWARE\\Oracle\\VirtualBox Guest Additions")) ||
		DoesRegKeyValueExists(HKEY_LOCAL_MACHINE, skCrypt("HARDWARE\\Description\\System"), skCrypt("VideoBiosVersion"), skCrypt("VIRTUALBOX")) ||
		DoesRegKeyExists(HKEY_LOCAL_MACHINE, skCrypt("HARDWARE\\ACPI\\DSDT\\VBOX__"))
	) 
	{
		return TRUE;
	}
	
	// VMWARE
	if
	(
		DoesRegKeyValueExists(HKEY_LOCAL_MACHINE, skCrypt("HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0"), skCrypt("Identifier"), skCrypt("VMWARE")) ||
		DoesRegKeyValueExists(HKEY_LOCAL_MACHINE, skCrypt("HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 1\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0"), skCrypt("Identifier"), skCrypt("VMWARE")) ||
		DoesRegKeyValueExists(HKEY_LOCAL_MACHINE, skCrypt("HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 2\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0"), skCrypt("Identifier"), skCrypt("VMWARE")) ||
		DoesRegKeyExists(HKEY_LOCAL_MACHINE, skCrypt("SOFTWARE\\VMware, Inc.\\VMware Tools"))
	)
	{
		return TRUE;
	}
	
	//QEMU
	if 
	(
		DoesRegKeyValueExists(HKEY_LOCAL_MACHINE, skCrypt("HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0"), skCrypt("Identifier"), skCrypt("QEMU")) ||
		DoesRegKeyValueExists(HKEY_LOCAL_MACHINE, skCrypt("HARDWARE\\Description\\System"), skCrypt("SystemBiosVersion"), skCrypt("QEMU"))
	)
	{
		return TRUE;
	}
	
	// KVM
	if 
	(
		DoesRegKeyExists(HKEY_LOCAL_MACHINE, skCrypt("SYSTEM\\ControlSet001\\Services\\netkvm")) ||
		DoesRegKeyExists(HKEY_LOCAL_MACHINE, skCrypt("SYSTEM\\ControlSet001\\Services\\vioscsi")) ||
		DoesRegKeyExists(HKEY_LOCAL_MACHINE, skCrypt("SYSTEM\\ControlSet001\\Services\\VirtIO-FS Service"))
	)
	{
		return TRUE;
	}

	// Wine
	if (DoesRegKeyExists(HKEY_CURRENT_USER, skCrypt("SOFTWARE\\Wine")))
		return TRUE;

	return FALSE;
}

void Security::AntiDbg()
{
	/*
	CheckRemoteDebuggerPresent() is another Win32 Debugging API function;
	it can be used to check if a remote process is being debugged. However,
	we can also use this as another method for checking if our own process
	is being debugged. This API internally calls the NTDLL export
	NtQueryInformationProcess function with the PROCESSINFOCLASS set to
	7 (ProcessDebugPort).
	 */

	BOOL bIsRemoteDbgPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &bIsRemoteDbgPresent);

	if (IsDebuggerPresent() || bIsRemoteDbgPresent)
	{
		DisplayError(ErrCode::DbgDetected);
		DeleteSelf();
		exit(-1);
	}
}

void Security::AntiAnalysis()
{
	if
		(
			IsProcessRunning(skCrypt("ollydbg.exe"), false) || // Olly Dbg
			IsProcessRunning(skCrypt("ProcessHacker.exe"), false) || // Process Hacker
			IsProcessRunning(skCrypt("tcpview.exe"), false) || // Part of Sysinternals Suite
			IsProcessRunning(skCrypt("autoruns.exe"), false) || // Part of Sysinternals Suite
			IsProcessRunning(skCrypt("autorunsc.exe"), false) || // Part of Sysinternals Suite
			IsProcessRunning(skCrypt("filemon.exe"), false) || // Part of Sysinternals Suite
			IsProcessRunning(skCrypt("procmon.exe"), false) || // Part of Sysinternals Suite
			IsProcessRunning(skCrypt("regmon.exe"), false) || // Part of Sysinternals Suite
			IsProcessRunning(skCrypt("procexp.exe"), false) || // Part of Sysinternals Suite
			IsProcessRunning(skCrypt("idaq.exe"), false) || // IDA Pro Interactive Disassembler
			IsProcessRunning(skCrypt("idaq64.exe"), false) || // IDA Pro Interactive Disassembler
			IsProcessRunning(skCrypt("ImmunityDebugger.exe"), false) || // ImmunityDebugger
			IsProcessRunning(skCrypt("Wireshark.exe"), false) || // Wireshark packet sniffer
			IsProcessRunning(skCrypt("dumpcap.exe"), false) || // Network traffic dump tool
			IsProcessRunning(skCrypt("HookExplorer.exe"), false) || // Find various types of runtime hooks
			IsProcessRunning(skCrypt("ImportREC.exe"), false) || // Import Reconstructor
			IsProcessRunning(skCrypt("PETools.exe"), false) || // PE Tool
			IsProcessRunning(skCrypt("LordPE.exe"), false) || // Lord PE
			IsProcessRunning(skCrypt("SysInspector.exe"), false) || // ESET SysInspector
			IsProcessRunning(skCrypt("proc_analyzer.exe"), false) || // Part of SysAnalyzer iDefense
			IsProcessRunning(skCrypt("sysAnalyzer.exe"), false) || // Part of SysAnalyzer iDefense
			IsProcessRunning(skCrypt("sniff_hit.exe"), false) || // Part of SysAnalyzer iDefense
			IsProcessRunning(skCrypt("windbg.exe"), false) || // Microsoft WinDbg
			IsProcessRunning(skCrypt("joeboxcontrol.exe"), false) || // Part of Joe Sandbox
			IsProcessRunning(skCrypt("joeboxserver.exe"), false) || // Part of Joe Sandbox
			IsProcessRunning(skCrypt("ResourceHacker.exe"), false) || // Resource Hacker
			IsProcessRunning(skCrypt("x32dbg.exe"), false) || // x32dbg
			IsProcessRunning(skCrypt("x64dbg.exe"), false) || // x64dbg
			IsProcessRunning(skCrypt("Fiddler.exe"), false) || // Fiddler
			IsProcessRunning(skCrypt("httpdebugger.exe"), false) || // Http Debugger
			IsProcessRunning(skCrypt("radare2.exe"), false) || // radare Dbg
			IsProcessRunning(skCrypt("HxD.exe"), false)					   // Hex Editor
			)
	{
		DisplayError(ErrCode::AnalysisSoftware);
		DeleteSelf();
		exit(-1);
	}
}

void Security::AntiVMs() 
{
	if (HaveNotEnoughProc() || HaveNoPowerCap() || HaveVMsRegistry())
	{
		DeleteSelf();
		exit(-1);
	}
}

// Command explained: https://www.codeproject.com/Articles/31454/How-To-Make-Your-Application-Delete-Itself-Immedia
void Security::DeleteSelf()
{
	TCHAR szModuleName[MAX_PATH];
	TCHAR szCmd[2 * MAX_PATH];
	STARTUPINFO si = { 0 };
	PROCESS_INFORMATION pi = { 0 };

	GetModuleFileName(NULL, szModuleName, MAX_PATH);

	StringCbPrintf(szCmd, 2 * MAX_PATH, TEXT(skCrypt("cmd.exe /C ping 127.0.0.1 -n 1 -w 3000 > Nul & Del /f /q \"%s\"")), szModuleName);

	CreateProcess(NULL, szCmd, NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi);

	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);
}
```

`Super People Full/Super People Final/Sp Injector/SuperPeople Injector.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "faceslog"
            VALUE "FileDescription", "FaceslogGameInjector"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "InternalName", "MInjector.exe"
            VALUE "LegalCopyright", "Copyright (C) 2021"
            VALUE "OriginalFilename", "MInjector.exe"
            VALUE "ProductName", "FacesInjector"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "assets\\ico.ico"

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Super People Full/Super People Final/Sp Injector/SuperPeople Injector.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{828b5ad4-2e04-4a96-85a5-c8458c6713dc}</ProjectGuid>
    <RootNamespace>MInjector</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>MInjector</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <VCToolsVersion>
    </VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <VCToolsVersion>
    </VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <VCToolsVersion>
    </VCToolsVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <VCToolsVersion>
    </VCToolsVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)Shared;$(IncludePath)</IncludePath>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)Shared;$(IncludePath)</IncludePath>
    <OutDir>$(SolutionDir)$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)Shared;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)Shared;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>PowrProf.lib;Shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>PowrProf.lib;Shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>PowrProf.lib;Shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalDependencies>PowrProf.lib;Shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Core.cpp" />
    <ClCompile Include="Injector.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="ClientSocket.cpp" />
    <ClCompile Include="Security.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\PacketType.h" />
    <ClInclude Include="ClientSocket.h" />
    <ClInclude Include="Core.h" />
    <ClInclude Include="Display.h" />
    <ClInclude Include="Injector.h" />
    <ClInclude Include="Models.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="Security.h" />
    <ClInclude Include="Xor.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="MInjector.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="assets\ico.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Super People Full/Super People Final/Sp Injector/SuperPeople Injector.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\Networking">
      <UniqueIdentifier>{a4cc853a-1ee6-457c-9d46-4216c601563e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Networking">
      <UniqueIdentifier>{4f7871a8-c910-43af-a1a9-86576e38273b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Core">
      <UniqueIdentifier>{7ae104bf-1c5d-42d1-95c6-971cfed1bda7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Core">
      <UniqueIdentifier>{48f65d8b-8d51-435c-a6c2-496ffe4ac87b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Security">
      <UniqueIdentifier>{f78ad2b1-4692-4067-b6eb-e57e62e5ae10}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Security">
      <UniqueIdentifier>{6f5197c0-9e8d-45b4-b2fe-06e2843aaa47}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Utils">
      <UniqueIdentifier>{2a9710f4-92dc-4378-90bf-2aeebdf3623a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ClientSocket.cpp">
      <Filter>Source Files\Networking</Filter>
    </ClCompile>
    <ClCompile Include="Security.cpp">
      <Filter>Source Files\Security</Filter>
    </ClCompile>
    <ClCompile Include="Injector.cpp">
      <Filter>Source Files\Core</Filter>
    </ClCompile>
    <ClCompile Include="Core.cpp">
      <Filter>Source Files\Core</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ClientSocket.h">
      <Filter>Header Files\Networking</Filter>
    </ClInclude>
    <ClInclude Include="Security.h">
      <Filter>Header Files\Security</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PacketType.h">
      <Filter>Header Files\Networking</Filter>
    </ClInclude>
    <ClInclude Include="Injector.h">
      <Filter>Header Files\Core</Filter>
    </ClInclude>
    <ClInclude Include="Core.h">
      <Filter>Header Files\Core</Filter>
    </ClInclude>
    <ClInclude Include="Models.h">
      <Filter>Header Files\Core</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Xor.h">
      <Filter>Header Files\Security</Filter>
    </ClInclude>
    <ClInclude Include="Display.h">
      <Filter>Header Files\Utils</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="MInjector.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="assets\ico.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`Super People Full/Super People Final/Sp Injector/SuperPeople Injector.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`Super People Full/Super People Final/Sp Injector/Xor.h`:

```h
#pragma once

/*____________________________________________________________________________________________________________

Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file

skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+

							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define skCrypt(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()

/*________________________________________________________________________________

MIT License

Copyright (c) 2020 skadro

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

________________________________________________________________________________*/
```

`Super People Full/Super People Final/Sp Injector/main.cpp`:

```cpp
#include "Core.h"

int main()
{
	if (!Security::IsAdministrator())
	{
		DisplayInfo(InfoCode::RestartAsAdmin);
		return EXIT_FAILURE;
	}
	
	// Check for VMs
	Security::AntiVMs();
	
	// Server Address, Server Port
	auto addr = skCrypt("faceslog.com");
	auto port = skCrypt("21006");

	Core core(addr.decrypt(), port.decrypt()); 
	
	addr.clear();
	port.clear();

	if (core.RunCore() != 0)
	{
		system("pause");
		return EXIT_FAILURE;
	}
	
	return EXIT_SUCCESS;
}
```

`Super People Full/Super People Final/Speed Info.txt`:

```txt
Speed Hack Working 
Fast Parachute
Fast Run
Fast Revive
Fast Car
Etc.
```

`Super People Full/Super People Final/Super People Esp & Aimbot/ESP.cpp`:

```cpp
// Extra Sensory Perception (ESP)
#include "pch.h"

ESP* g_pESP = new ESP();
ESP::ESP() {}
ESP::~ESP() {}

sf::Vertex line[2];
sf::VertexArray armsLegs(sf::LinesStrip, 7);
sf::VertexArray body(sf::LinesStrip, 5);
sf::CircleShape playerHead(30.f);
sf::Font font;
sf::Text playerName;
sf::RectangleShape healthBar;
sf::RectangleShape healthBorder;
sf::RectangleShape infoBg;
sf::Text playerInfo;
sf::Text itemName;
sf::RectangleShape itemBg;
sf::Music alert;

bool ESP::loadFont()
{
	if (!font.loadFromFile("./PUBGCorona.ttf"))
	{
		Sleep(1000);
		if (font.loadFromFile("PUBGCorona.ttf"))
		{
			return true;
		}
		return false;
	}
	return true;
}

void ESP::setDrawings()
{
	line[0].color = sf::Color::Red;
	line[0].position = sf::Vector2f(g_pOverlay->width / 2, 0.f);
	line[1].color = sf::Color::Red;
	line[1].position = sf::Vector2f(0.f, 0.f);
	//g_pOverlay->window.draw(line, 2, sf::Lines);

	//line[1].position = sf::Vector2f(200.f, 350.f);
	//g_pOverlay->window.draw(line, 2, sf::Lines);

	armsLegs[0].color = sf::Color::Red;
	armsLegs[1].color = sf::Color::Red;
	armsLegs[2].color = sf::Color::Red;
	armsLegs[3].color = sf::Color::Red;
	armsLegs[4].color = sf::Color::Red;
	armsLegs[5].color = sf::Color::Red;
	armsLegs[6].color = sf::Color::Red;
	armsLegs[0].position = sf::Vector2f(160.f, 370.f);
	armsLegs[1].position = sf::Vector2f(135.f, 305.f);
	armsLegs[2].position = sf::Vector2f(170.f, 240.f);
	armsLegs[3].position = sf::Vector2f(205.f, 220.f);
	armsLegs[4].position = sf::Vector2f(240.f, 240.f);
	armsLegs[5].position = sf::Vector2f(275.f, 305.f);
	armsLegs[6].position = sf::Vector2f(250.f, 370.f);
	//g_pOverlay->window.draw(armsLegs);

	body[0].color = sf::Color::Red;
	body[1].color = sf::Color::Red;
	body[2].color = sf::Color::Red;
	body[3].color = sf::Color::Red;
	body[4].color = sf::Color::Red;
	body[0].position = sf::Vector2f(205.f, 220.f);
	body[1].position = sf::Vector2f(215.f, 250.f);
	body[2].position = sf::Vector2f(200.f, 305.f);
	body[3].position = sf::Vector2f(215.f, 355.f);
	body[4].position = sf::Vector2f(205.f, 375.f);
	//g_pOverlay->window.draw(body);

	//armsLegs[0].position = sf::Vector2f(185.f, 565.f);
	//armsLegs[1].position = sf::Vector2f(165.f, 475.f);
	//armsLegs[2].position = sf::Vector2f(180.f, 405.f);
	//armsLegs[3].position = sf::Vector2f(205.f, 375.f);
	//armsLegs[4].position = sf::Vector2f(235.f, 405.f);
	//armsLegs[5].position = sf::Vector2f(250.f, 475.f);
	//armsLegs[6].position = sf::Vector2f(230.f, 565.f);
	//g_pOverlay->window.draw(armsLegs);

	playerHead.setPosition(205.f, 220.f);
	playerHead.setOutlineColor(sf::Color::Red);
	playerHead.setOutlineThickness(1.f);
	playerHead.setFillColor(sf::Color::Transparent);
	playerHead.setOrigin(30.f, (30.f * 2) + 1.f);
	//g_pOverlay->window.draw(playerHead);

	infoBg.setPosition(sf::Vector2f(200.f, 350.f));
	infoBg.setFillColor(sf::Color(0, 0, 0, 100));
	infoBg.setSize(sf::Vector2f(202.f, 36.f));
	infoBg.setOrigin(sf::Vector2f(101.f, 250.f));
	//g_pOverlay->window.draw(infoBg);

	playerName.setFont(font);
	playerName.setString("Player Name\nStatus");
	playerName.setFillColor(sf::Color::Magenta);
	playerName.setCharacterSize(12);
	playerName.setLineSpacing(0.5);
	playerName.setPosition(sf::Vector2f(200.f, 350.f));
	playerName.setOrigin(sf::Vector2f(-50.f + 101.f, -1.f + 250.f));
	//g_pOverlay->window.draw(playerName);

	healthBar.setPosition(sf::Vector2f(200.f, 350.f));
	healthBar.setFillColor(sf::Color::Green);
	healthBar.setSize(sf::Vector2f(50.f * 2.f, 4.f));
	healthBar.setOrigin(sf::Vector2f(-1.f + 101.f, -31.f + 250.f));
	//g_pOverlay->window.draw(healthBar);

	healthBorder.setPosition(sf::Vector2f(200.f, 350.f));
	healthBorder.setOutlineColor(sf::Color::White);
	healthBorder.setSize(sf::Vector2f(200.f, 4.f));
	healthBorder.setOutlineThickness(1.f);
	healthBorder.setFillColor(sf::Color::Transparent);
	healthBorder.setOrigin(sf::Vector2f(-1.f + 101.f, -31.f + 250.f));
	//g_pOverlay->window.draw(healthBorder);

	playerInfo.setFont(font);
	playerInfo.setFillColor(sf::Color::White);
	playerInfo.setString("500\nm");
	playerInfo.setLineSpacing(0.5);
	playerInfo.setCharacterSize(12);
	playerInfo.setPosition(sf::Vector2f(200.f, 350.f));
	playerInfo.setOrigin(sf::Vector2f(-1.f + 101.f, -1.f + 250.f));
	//g_pOverlay->window.draw(playerInfo);

	//playerInfo.setString("50\nhp");
	//playerInfo.setOrigin(sf::Vector2f(-180.f + 101.f, -1.f + 250.f));
	//g_pOverlay->window.draw(playerInfo);


	//line[1].position = sf::Vector2f(600.f, 300.f);
	//g_pOverlay->window.draw(line, 2, sf::Lines);

	itemName.setFont(font);
	itemName.setString("Item (250 m)");
	itemName.setFillColor(sf::Color::Red);
	itemName.setCharacterSize(12);
	itemName.setPosition(sf::Vector2f(600.f, 300.f));
	itemName.setOutlineThickness(2);
	itemName.setOutlineColor(sf::Color::Black);

	sf::FloatRect itemBounds;
	itemBounds = itemName.getGlobalBounds();
	itemName.setOrigin(sf::Vector2f(itemBounds.width / 2, 10.f));
	itemBounds = itemName.getGlobalBounds();

	itemBg.setPosition(itemBounds.left, itemBounds.top);
	itemBg.setFillColor(sf::Color(0, 0, 0, 100));
	itemBg.setSize(sf::Vector2f(itemBounds.width + 10.f, itemBounds.height + 10.f));
	itemBg.setOrigin(sf::Vector2f(5.f, 5.f));
	//g_pOverlay->window.draw(itemBg);
	//g_pOverlay->window.draw(itemName);

	/*
	if (playAlert)
	{
		alert.openFromFile("./PUBGAlert.wav");
		alert.setVolume(80);
		alert.play();
		playAlert = false;
	}
	*/
}

void ESP::init()
{
	cout << "[+] Getting view world ...\n";
	viewWorldBase = getViewWorld();
	if (viewWorldBase == 0)
	{
		cout << "FAILED ...\n";
		system("pause");
		return;
	}
	cout << "SUCCESS ...\n";
	cout << "View world base is : " << viewWorldBase << "\n";
	uWorld = viewWorldBase - ofUWorldMinus;
	cout << "uWorld is : " << uWorld << "\n";
	gNames = viewWorldBase - ofGNamesMinus;
	cout << "gNames is : " << gNames << "\n";
	tmpGName = g_pMemoryManager->dRead(gNames);
	cout << "tmpGName is : " << tmpGName << "\n";
}

DWORD ESP::getViewWorld()
{
	BYTE pattern[] = { 0x02, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x01 };
	vector<DWORD_PTR> foundedBases;
	g_pMemoryManager->search(pattern, sizeof(pattern), ofSearchFrom, ofSearchTo, foundedBases);
	for (int i = 0; i < foundedBases.size(); i++) {
		DWORD cand = foundedBases[i] - 0x20;
		DWORD eng = g_pMemoryManager->dRead(cand) + 0x20;
		DWORD tmp = g_pMemoryManager->dRead(eng) + 0x200;
		float v1, v2, v3, v4;
		v1 = g_pMemoryManager->fRead(tmp + 0x8);
		v2 = g_pMemoryManager->fRead(tmp + 0x18);
		v3 = g_pMemoryManager->fRead(tmp + 0x28);
		v4 = g_pMemoryManager->fRead(tmp + 0x38);
		if ((v1 == 0) && (v2 == 0) && (v3 == 0) && (v4 >= 3)) {
			foundedBases.clear();
			return cand;
		}
	}
	foundedBases.clear();
	return 0;
}

void ESP::getViewMatrix()
{
	DWORD vwb20 = g_pMemoryManager->dRead(viewWorldBase) + 0x20;
	DWORD vwb200 = g_pMemoryManager->dRead(vwb20) + 0x200;
	g_pMemoryManager->readMemory((PVOID)vwb200, (PVOID)&g_pViewMatrixManager->viewmatrix, 64);
}


void ESP::scanEntityList()
{
	uWorlds = g_pMemoryManager->dRead(uWorld);
	uLevel = g_pMemoryManager->dRead(uWorlds + ofULevel);
	gameInstance = g_pMemoryManager->dRead(uWorlds + ofGameInstance);

	if (gameInstance == 0)
	{
		cout << "Error : Game instance error\n";
		Sleep(500);
		return;
	}

	playerController = g_pMemoryManager->dRead(gameInstance + ofPlayerController);
	playerCarry = g_pMemoryManager->dRead(playerController + ofPlayerCarry);
	uMyObject = g_pMemoryManager->dRead(playerCarry + ofUMyObject);
	entityEntry = g_pMemoryManager->dRead(uLevel + ofEntityEntry);
	entityCount = g_pMemoryManager->iRead(uLevel + ofEntityCount);

	enemies = 0;

	for (int ent = 0; ent < entityCount; ent++)
	{
		entityAddv = g_pMemoryManager->dRead(entityEntry + (ent * ofEntityAddv));

		if (entityAddv == 0) { continue; }
		if (entityAddv == -1) { continue; }
		if (!entityAddv) { continue; }
		if (entityAddv == NULL) { continue; }
		if (entityAddv == (DWORD) nullptr) { continue; }

		tmpEntityAddvId = g_pMemoryManager->uiRead(entityAddv + ofTmpEntityAddvId);

		entityName = "";

		if ((tmpEntityAddvId > 0) && (tmpEntityAddvId < 50000000))
		{
			page = tmpEntityAddvId / 16384; // 0x4000
			index = tmpEntityAddvId % 16384;
			secPartAddv = g_pMemoryManager->dRead(tmpGName + page * 4);
			if (secPartAddv > 0)
			{
				nameAddv = g_pMemoryManager->dRead(secPartAddv + index * 4);
				if (nameAddv > 0)
				{
					entityName = g_pMemoryManager->charRead(nameAddv + 8);
				}
			}
		}

		if (entityName == "")
		{
			continue;
		}

		// ITEMS
		if (
			strstr(entityName.c_str(), "BP_Grenade") ||
			strstr(entityName.c_str(), "_Wrapper") || strstr(entityName.c_str(), "BP_WEP_Mk14_Pickup_") ||
			strstr(entityName.c_str(), "BP_Ammo") ||
			strstr(entityName.c_str(), "BP_MZJ") ||
			strstr(entityName.c_str(), "PickUp_BP") ||
			strstr(entityName.c_str(), "_Pickup") ||
			strstr(entityName.c_str(), "PlayerDeadInventoryBox_") ||
			strstr(entityName.c_str(), "PickUpListWrapperActor") ||
			strstr(entityName.c_str(), "BP_AirDropBox_") ||
			strstr(entityName.c_str(), "AirDropListWrapperActor") ||
			strstr(entityName.c_str(), "VH_") ||
			strstr(entityName.c_str(), "BP_AirDropPlane_") ||
			strstr(entityName.c_str(), "LadaNiva") ||
			strstr(entityName.c_str(), "AquaRail") ||
			strstr(entityName.c_str(), "Rony") ||
			strstr(entityName.c_str(), "Mirado") ||
			strstr(entityName.c_str(), "PickUp_")
			)
		{
			entityWorld = g_pMemoryManager->dRead(entityAddv + ofEntityWorld);
			position = g_pMemoryManager->v3Read(entityWorld + ofPosition);
			g_pViewMatrixManager->worldToScreen(position, positionOnScreen, &distanceFl, &distanceValue);

			if (positionOnScreen.z < 0.001f)
			{
				continue;
			}

			// THROWABLES (BP_Grenade_Frag_Weapon_Wrapper_C)
			if (strstr(entityName.c_str(), "BP_Grenade"))
			{
				entityName = replace(entityName, "BP_Grenade_");
				entityName = replace(entityName, "_Weapon_Wrapper_C");
				itemName.setFillColor(sf::Color::Red);
			}
			// WEAPONS (BP_Sniper_M24_Wrapper_C, BP_WEP_Mk14_Pickup_C)
			else if (strstr(entityName.c_str(), "_Wrapper") || strstr(entityName.c_str(), "BP_WEP_Mk14_Pickup_"))
			{
				entityName = replace(entityName, "BP_");
				entityName = replace(entityName, "_Wrapper_C");
				entityName = replace(entityName, "_Pickup_C");
				itemName.setFillColor(sf::Color::Yellow);
			}
			// AMMO (BP_Ammo_556mm_Pickup_)
			else if (strstr(entityName.c_str(), "BP_Ammo"))
			{
				entityName = replace(entityName, "BP_Ammo_");
				entityName = replace(entityName, "_Pickup_C");
				itemName.setFillColor(sf::Color::Green);
			}
			// SCOPES (BP_MZJ_4X_Pickup_)
			else if (strstr(entityName.c_str(), "BP_MZJ"))
			{
				entityName = replace(entityName, "BP_MZJ_");
				entityName = replace(entityName, "_Pickup_C");
				itemName.setFillColor(sf::Color::White);
			}
			// WEARINGS (PickUp_BP_Bag_Lv2_)
			else if (strstr(entityName.c_str(), "PickUp_BP"))
			{
				entityName = replace(entityName, "PickUp_BP_");
				entityName = replace(entityName, "_C");
				itemName.setFillColor(sf::Color::Blue);
			}
			// HEALINGS (Bandage_Pickup_)
			// ATTACHMENTS (BP_QK_Mid_FlashHider_Pickup_)
			// METAL WEAPONS (BP_WEP_Pan_Pickup_)
			// GAS CAN (GasCan_Destructible_Pickup_)
			else if (strstr(entityName.c_str(), "_Pickup"))
			{
				entityName = replace(entityName, "_Pickup_C");
				entityName = replace(entityName, "BP_WEP_");
				entityName = replace(entityName, "BP_");
				itemName.setFillColor(sf::Color::Cyan);
			}
			// BOXES
			else if (
				strstr(entityName.c_str(), "PlayerDeadInventoryBox_") ||
				strstr(entityName.c_str(), "PickUpListWrapperActor") ||
				strstr(entityName.c_str(), "BP_AirDropBox_") ||
				strstr(entityName.c_str(), "AirDropListWrapperActor")
				)
			{
				itemName.setFillColor(sf::Color(255, 165, 0, 255));
			}
			// VEHICLES (BP_VH_Buggy_, BP_AirDropPlane_, LadaNiva_01_, AquaRail_1_, Rony_01_, Mirado_open_4_, PickUp_02_)
			else if (
				strstr(entityName.c_str(), "VH_") ||
				strstr(entityName.c_str(), "BP_AirDropPlane_") ||
				strstr(entityName.c_str(), "LadaNiva") ||
				strstr(entityName.c_str(), "AquaRail") ||
				strstr(entityName.c_str(), "Rony") ||
				strstr(entityName.c_str(), "Mirado") ||
				strstr(entityName.c_str(), "PickUp_")
				)
			{
				entityName = replace(entityName, "BP_");
				entityName = replace(entityName, "VH_");
				entityName = replace(entityName, "_C");
				itemName.setFillColor(sf::Color::Magenta);
			}

			itemName.setString(entityName + " (" + to_string(distanceValue) + " m)");
			itemName.setPosition(sf::Vector2f(positionOnScreen.x, positionOnScreen.y));
			sf::FloatRect itemBounds;
			itemBounds = itemName.getGlobalBounds();
			itemName.setOrigin(sf::Vector2f(itemBounds.width / 2, 10.f));
			itemBounds = itemName.getGlobalBounds();
			itemBg.setPosition(itemBounds.left, itemBounds.top);
			itemBg.setSize(sf::Vector2f(itemBounds.width + 10.f, itemBounds.height + 10.f));
			g_pOverlay->window.draw(itemBg);
			g_pOverlay->window.draw(itemName);
		}
		// PLAYERS
		else if (strstr(entityName.c_str(), "BP_PlayerPawn") || strstr(entityName.c_str(), "BP_PlayerCharacter") || strstr(entityName.c_str(), "PlanET_FakePlayer") || strstr(entityName.c_str(), "PlayerPawn_Infec"))
		{
			entityWorld = g_pMemoryManager->dRead(entityAddv + ofEntityWorld);

			status = g_pMemoryManager->iRead(entityWorld + ofStatus);
			if (status == 6)
			{
				continue;
			}

			teamId = g_pMemoryManager->iRead(entityAddv + ofTeamId);
			if (entityAddv == uMyObject)
			{
				myTeamId = teamId;
			}
			if ((teamId == myTeamId) || (teamId < 1))
			{
				continue;
			}
			enemies++;

			position = g_pMemoryManager->v3Read(entityWorld + ofPosition);
			g_pViewMatrixManager->worldToScreen(position, positionOnScreen, &distanceFl, &distanceValue);
			if (positionOnScreen.z < 0.001f)
			{
				continue;
			}

			// Player Line
			isRobot = g_pMemoryManager->bRead(entityAddv + ofRobot);
			if (isRobot)
			{
				line[0].color = sf::Color::Green;
				line[1].color = sf::Color::Green;
			}
			else
			{
				line[0].color = sf::Color::Red;
				line[1].color = sf::Color::Red;
			}
			line[1].position = sf::Vector2f(positionOnScreen.x, positionOnScreen.y);
			g_pOverlay->window.draw(line, 2, sf::Lines);

			// Player Info
			playerNameAdd = g_pMemoryManager->dRead(entityAddv + ofPlayerNameAdd);
			thePlayerName = g_pMemoryManager->charp32Read(playerNameAdd);
			stateInt = g_pMemoryManager->iRead(entityAddv + ofStateInt);
			health = g_pMemoryManager->fRead(entityAddv + ofHealth);

			if (distanceValue > 200)
			{
				fixPosY = 45.f;
				headBoneSize = 1.f;
			}
			else if (distanceValue > 150)
			{
				fixPosY = 50.f;
				headBoneSize = 1.5f;
			}
			else if (distanceValue > 100)
			{
				fixPosY = 65.f;
				headBoneSize = 2.f;
			}
			else if (distanceValue > 50)
			{
				fixPosY = 70.f;
				headBoneSize = 2.5f;
			}
			else if (distanceValue > 40)
			{
				fixPosY = 100.f;
				headBoneSize = 3.f;
			}
			else if (distanceValue > 30)
			{
				fixPosY = 110.f;
				headBoneSize = 3.5f;
			}
			else if (distanceValue > 20)
			{
				fixPosY = 120.f;
				headBoneSize = 5.f;
			}
			else if (distanceValue > 10)
			{
				fixPosY = 150.f;
				headBoneSize = 10.f;
			}
			else
			{
				fixPosY = 200.f;
				headBoneSize = 15.f;
			}

			infoBg.setPosition(sf::Vector2f(positionOnScreen.x, positionOnScreen.y));
			infoBg.setOrigin(sf::Vector2f(101.f, fixPosY));
			g_pOverlay->window.draw(infoBg);

			playerName.setString(thePlayerName + "\n" + getState(stateInt));
			playerName.setPosition(sf::Vector2f(positionOnScreen.x, positionOnScreen.y));
			playerName.setOrigin(sf::Vector2f(-50.f + 101.f, -1.f + fixPosY));
			g_pOverlay->window.draw(playerName);

			healthBar.setPosition(sf::Vector2f(positionOnScreen.x, positionOnScreen.y));
			healthBar.setSize(sf::Vector2f((float) health * 2.f, 4.f));
			healthBar.setOrigin(sf::Vector2f(-1.f + 101.f, -31.f + fixPosY));
			g_pOverlay->window.draw(healthBar);

			healthBorder.setPosition(sf::Vector2f(positionOnScreen.x, positionOnScreen.y));
			healthBorder.setOrigin(sf::Vector2f(-1.f + 101.f, -31.f + fixPosY));
			g_pOverlay->window.draw(healthBorder);

			playerInfo.setString(to_string(distanceValue) + "\nm");
			playerInfo.setPosition(sf::Vector2f(positionOnScreen.x, positionOnScreen.y));
			playerInfo.setOrigin(sf::Vector2f(-1.f + 101.f, -1.f + fixPosY));
			g_pOverlay->window.draw(playerInfo);

			playerInfo.setString(to_string(health) + "\nhp");
			playerInfo.setOrigin(sf::Vector2f(-180.f + 101.f, -1.f + fixPosY));
			g_pOverlay->window.draw(playerInfo);

			meshSkeleton = g_pMemoryManager->dRead(entityAddv + ofMeshSkeleton);
			actor = g_pMemoryManager->structRead(meshSkeleton + ofActor);
			componentToWorldMatrix = ToMatrixWithScale(actor.Translation, actor.Scale3D, actor.Rotation);
			boneAddv = g_pMemoryManager->dRead(meshSkeleton + ofBoneAddv);

			bonePosition = getBonePos(6); // HEAD
			playerHead.setRadius(headBoneSize);
			playerHead.setPosition(bonePosition.x, bonePosition.y);
			playerHead.setOrigin(headBoneSize, (headBoneSize * 2) + 1.f);
			g_pOverlay->window.draw(playerHead);

			bonePosition = getBonePos(63); // right hand
			armsLegs[0].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(34); // right wrest
			armsLegs[1].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(33); // right shoulder
			armsLegs[2].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(6); // head
			armsLegs[3].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(12); // left shoulder
			armsLegs[4].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(13); // left wrest
			armsLegs[5].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(64); // left hand
			armsLegs[6].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			g_pOverlay->window.draw(armsLegs);

			bonePosition = getBonePos(59); // right foot
			armsLegs[0].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(58); // right knee
			armsLegs[1].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(57); // right waste
			armsLegs[2].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(2); // body middle
			armsLegs[3].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(53); // left waste
			armsLegs[4].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(54); // left knee
			armsLegs[5].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(55); // left foot
			armsLegs[6].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			g_pOverlay->window.draw(armsLegs);

			bonePosition = getBonePos(6); // head
			body[0].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			//bonePosition = getBonePos(); // 
			body[1].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(5); // 
			body[2].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			//bonePosition = getBonePos(); // 
			body[3].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			bonePosition = getBonePos(2); // 
			body[4].position = sf::Vector2f(bonePosition.x, bonePosition.y);
			g_pOverlay->window.draw(body);

		}

		if (enemies > 0)
		{
			if (playAlert)
			{
				alert.openFromFile("./PUBGAlert.wav");
				alert.setVolume(80);
				alert.play();
				playAlert = false;
			}

			itemName.setString("There are ( " + to_string(enemies) + " ) enemies around!");
			itemName.setFillColor(sf::Color(255, 164, 0, 255));
			itemName.setPosition(sf::Vector2f(float (g_pOverlay->width) / 2.f, 50.f));
			sf::FloatRect itemBounds;
			itemBounds = itemName.getGlobalBounds();
			itemName.setOrigin(sf::Vector2f(itemBounds.width / 2, 10.f));
			itemBounds = itemName.getGlobalBounds();
			itemBg.setPosition(itemBounds.left, itemBounds.top);
			itemBg.setSize(sf::Vector2f(itemBounds.width + 10.f, itemBounds.height + 10.f));
			g_pOverlay->window.draw(itemBg);
			g_pOverlay->window.draw(itemName);
		}

	}

	if (enemies == 0)
	{
		playAlert = true;
	}

}

string ESP::replace(string& str, const string& from)
{
	size_t start_pos = str.find(from);
	if (start_pos == string::npos)
		return str;
	str.replace(start_pos, from.length(), "");
	return str;
}

string ESP::getState(int state)
{
	switch (state)
	{
	case 0:
		return "Jump of Baot";
	case 1:
		return "In Water";
	case 8:
		return "Standing";
	case 9:
		return "Walking";
	case 10:
		return "Landing";
	case 11:
		return "Running";
	case 16:
		return "Crouching";
	case 17:
		return "Crouching Walk";
	case 19:
		return "Crouching Run";
	case 32:
		return "Snaking";
	case 33:
		return "Snaking Walk";
	case 35:
		return "Snaking Run";
	case 5445:
	case 762:
		return "Snake";
	case 72:
	case 73:
	case 75:
		return "Jumping";
	case 264:
	case 272:
	case 273:
	case 288:
	case 265:
	case 329:
		return "Relaoding";
	case 136:
	case 137:
	case 144:
	case 145:
	case 160:
	case 648:
	case 649:
	case 1160:
	case 1161:
	case 1169:
	case 201:
		return "Firing";
	case 4194304:
	case 4194307:
		return "Swimming";
	case 131070:
	case 131071:
	case 131072:
	case 131073:
	case 131074:
	case 131075:
		return "Knocked";
	case 524296:
		return "Driving Vehicle";
	case 524288:
		return "Driving Boat";
	case 1048584:
		return "Set in Vehicle";
	case 1048576:
		return "Set in Boat";
	case 33554440:
		return "Set in Plane";
	case 3146248:
		return "Aim in vehicle";
	case 3146240:
		return "Aim in boat";
	case 3145736:
		return "Beek in vehicle";
	case 3145728:
		return "Beek in boat";
	case 1050632:
		return "Change vehicle seat";
	case 1050624:
		return "Change boat seat";
	case 32784:
		return "Reviving";
	case 16392:
	case 16393:
	case 16401:
	case 16416:
	case 16417:
	case 16457:
	case 16400:
	case 17401:
	case 17417:
	case 17424:
	case 17425:
		return "Throwing Bomp";
	case 16777224:
		return "Climping";
	case 8200:
	case 8208:
		return "Punish, Stab";
	case 520:
	case 544:
	case 521:
	case 656:
	case 528:
		return "Aiming";
	case 1680:
	case 1672:
	case 1673:
	case 1032:
	case 1544:
	case 1545:
	case 1033:
		return "Peeking";
	case 2056:
		return "Change Weapon";
	case 65544:
		return "Healing";
	case 65545:
		return "Healing & Walk";
	case 268435464:
		return "Playing Emotion";
	case 4194305:
		return "Diving, Floating";
	}

	return to_string(state);
}


D3DMatrix ESP::ToMatrixWithScale(Vector3f translation, Vector3f scale, Vector4f rot)
{
	D3DMatrix m;
	m._41 = translation.x;
	m._42 = translation.y;
	m._43 = translation.z;

	float x2 = rot.x + rot.x;
	float y2 = rot.y + rot.y;
	float z2 = rot.z + rot.z;

	float xx2 = rot.x * x2;
	float yy2 = rot.y * y2;
	float zz2 = rot.z * z2;
	m._11 = (1.0f - (yy2 + zz2)) * scale.x;
	m._22 = (1.0f - (xx2 + zz2)) * scale.y;
	m._33 = (1.0f - (xx2 + yy2)) * scale.z;

	float yz2 = rot.y * z2;
	float wx2 = rot.w * x2;
	m._32 = (yz2 - wx2) * scale.z;
	m._23 = (yz2 + wx2) * scale.y;

	float xy2 = rot.x * y2;
	float wz2 = rot.w * z2;
	m._21 = (xy2 - wz2) * scale.y;
	m._12 = (xy2 + wz2) * scale.x;

	float xz2 = rot.x * z2;
	float wy2 = rot.w * y2;
	m._31 = (xz2 + wy2) * scale.z;
	m._13 = (xz2 - wy2) * scale.x;

	m._14 = 0.0f;
	m._24 = 0.0f;
	m._34 = 0.0f;
	m._44 = 1.0f;

	return m;
}

Vector3f ESP::getBonePos(int boneNum)
{
	bone = g_pMemoryManager->structRead(boneAddv + (boneNum * 48));
	boneMatrix = ToMatrixWithScale(bone.Translation, bone.Scale3D, bone.Rotation);
	newMatrix =
	{
		boneMatrix._11 * componentToWorldMatrix._11 + boneMatrix._12 * componentToWorldMatrix._21 + boneMatrix._13 * componentToWorldMatrix._31 + boneMatrix._14 * componentToWorldMatrix._41,
		boneMatrix._11 * componentToWorldMatrix._12 + boneMatrix._12 * componentToWorldMatrix._22 + boneMatrix._13 * componentToWorldMatrix._32 + boneMatrix._14 * componentToWorldMatrix._42,
		boneMatrix._11 * componentToWorldMatrix._13 + boneMatrix._12 * componentToWorldMatrix._23 + boneMatrix._13 * componentToWorldMatrix._33 + boneMatrix._14 * componentToWorldMatrix._43,
		boneMatrix._11 * componentToWorldMatrix._14 + boneMatrix._12 * componentToWorldMatrix._24 + boneMatrix._13 * componentToWorldMatrix._34 + boneMatrix._14 * componentToWorldMatrix._44,
		boneMatrix._21 * componentToWorldMatrix._11 + boneMatrix._22 * componentToWorldMatrix._21 + boneMatrix._23 * componentToWorldMatrix._31 + boneMatrix._24 * componentToWorldMatrix._41,
		boneMatrix._21 * componentToWorldMatrix._12 + boneMatrix._22 * componentToWorldMatrix._22 + boneMatrix._23 * componentToWorldMatrix._32 + boneMatrix._24 * componentToWorldMatrix._42,
		boneMatrix._21 * componentToWorldMatrix._13 + boneMatrix._22 * componentToWorldMatrix._23 + boneMatrix._23 * componentToWorldMatrix._33 + boneMatrix._24 * componentToWorldMatrix._43,
		boneMatrix._21 * componentToWorldMatrix._14 + boneMatrix._22 * componentToWorldMatrix._24 + boneMatrix._23 * componentToWorldMatrix._34 + boneMatrix._24 * componentToWorldMatrix._44,
		boneMatrix._31 * componentToWorldMatrix._11 + boneMatrix._32 * componentToWorldMatrix._21 + boneMatrix._33 * componentToWorldMatrix._31 + boneMatrix._34 * componentToWorldMatrix._41,
		boneMatrix._31 * componentToWorldMatrix._12 + boneMatrix._32 * componentToWorldMatrix._22 + boneMatrix._33 * componentToWorldMatrix._32 + boneMatrix._34 * componentToWorldMatrix._42,
		boneMatrix._31 * componentToWorldMatrix._13 + boneMatrix._32 * componentToWorldMatrix._23 + boneMatrix._33 * componentToWorldMatrix._33 + boneMatrix._34 * componentToWorldMatrix._43,
		boneMatrix._31 * componentToWorldMatrix._14 + boneMatrix._32 * componentToWorldMatrix._24 + boneMatrix._33 * componentToWorldMatrix._34 + boneMatrix._34 * componentToWorldMatrix._44,
		boneMatrix._41 * componentToWorldMatrix._11 + boneMatrix._42 * componentToWorldMatrix._21 + boneMatrix._43 * componentToWorldMatrix._31 + boneMatrix._44 * componentToWorldMatrix._41,
		boneMatrix._41 * componentToWorldMatrix._12 + boneMatrix._42 * componentToWorldMatrix._22 + boneMatrix._43 * componentToWorldMatrix._32 + boneMatrix._44 * componentToWorldMatrix._42,
		boneMatrix._41 * componentToWorldMatrix._13 + boneMatrix._42 * componentToWorldMatrix._23 + boneMatrix._43 * componentToWorldMatrix._33 + boneMatrix._44 * componentToWorldMatrix._43,
		boneMatrix._41 * componentToWorldMatrix._14 + boneMatrix._42 * componentToWorldMatrix._24 + boneMatrix._43 * componentToWorldMatrix._34 + boneMatrix._44 * componentToWorldMatrix._44
	};
	Vector3f bonePos;
	bonePos.x = newMatrix._41;
	bonePos.y = newMatrix._42;
	bonePos.z = newMatrix._43;
	Vector3f bonePosOnScreen;
	g_pViewMatrixManager->worldBoneToScreen(bonePos, bonePosOnScreen);
	return bonePosOnScreen;
}

```

`Super People Full/Super People Final/Super People Esp & Aimbot/MemoryManager.cpp`:

```cpp
#include "pch.h"

#define MM_DEVICE_TYPE 0x9999
#define MM_CTL_CODE(x) CTL_CODE(MM_DEVICE_TYPE, 0x800 + x, METHOD_NEITHER, FILE_ANY_ACCESS)
#define MM_READVIRTUALMEMORY MM_CTL_CODE(56)

typedef struct _MEMORY_REGION
{
	DWORD_PTR dwBaseAddr;
	DWORD_PTR dwMemorySize;
}MEMORY_REGION;

MemoryManager* g_pMemoryManager = new MemoryManager();
MemoryManager::MemoryManager() {}
MemoryManager::~MemoryManager() {}

bool MemoryManager::init()
{
	string deviceName = "\\Device\\KProcessHacker2";
	wstring strObjectName;
	strObjectName.assign(deviceName.begin(), deviceName.end());
	UNICODE_STRING objectName;
	HANDLE hNtDriver;
	OBJECT_ATTRIBUTES objectAttributes;
	IO_STATUS_BLOCK isb;
	RtlInitUnicodeString(&objectName, strObjectName.c_str());
	InitializeObjectAttributes(&objectAttributes, &objectName, FILE_NON_DIRECTORY_FILE, NULL, NULL);
	NTSTATUS status = NtOpenFile(&hNtDriver, FILE_GENERIC_READ, &objectAttributes, &isb, FILE_SHARE_READ, FILE_NON_DIRECTORY_FILE);
	if (status == STATUS_SUCCESS) {
		m_hDriver = hNtDriver;
		return true;
	}
	return false;
}

int MemoryManager::getAowProcId()
{
	int pid = 0;
	int threadCount = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32 pe;
	pe.dwSize = sizeof(PROCESSENTRY32);
	Process32First(hSnap, &pe);
	while (Process32Next(hSnap, &pe)) {
		if (_tcsicmp(pe.szExeFile, _T("aow_exe.exe")) == 0) {
			if ((int)pe.cntThreads > threadCount) {
				threadCount = pe.cntThreads;
				pid = pe.th32ProcessID;
			}
		}
	}
	return pid;
}

bool MemoryManager::getProcHandle()
{
	// Get process handle
	processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);
	if (processHandle)
	{
		allIsWell = true;
		return true;
	}
	else
	{
		return false;
	}
}

void MemoryManager::readMemory(PVOID BaseAddress, PVOID Buffer, SIZE_T BufferSize)
{
	if (!allIsWell)
		return;

	struct {
		HANDLE ProcessHandle;
		PVOID BaseAddress;
		PVOID Buffer;
		SIZE_T BufferSize;
		PSIZE_T NumberOfBytesRead;
	} input = { processHandle, BaseAddress, Buffer, BufferSize, NumberOfBytes };

	IO_STATUS_BLOCK ioStatusBlock;

	NtDeviceIoControlFile(m_hDriver, nullptr, nullptr, nullptr, &ioStatusBlock, MM_READVIRTUALMEMORY, &input, sizeof(input), nullptr, 0);
}


bool MemoryManager::search(BYTE* bSearchData, int nSearchSize, DWORD_PTR dwStartAddr, DWORD_PTR dwEndAddr, vector<DWORD_PTR>& vRet)
{

	MEMORY_BASIC_INFORMATION mbi;
	vector<MEMORY_REGION> m_vMemoryRegion;
	mbi.RegionSize = 0x400;
	DWORD dwAddress = dwStartAddr;

	MEMORY_REGION memSectorList[1000];

	int memSectorIndex = 0;
	while ((VirtualQueryEx(processHandle, (LPCVOID)dwAddress, &mbi, sizeof(mbi))) && (dwAddress < dwEndAddr) && ((dwAddress + mbi.RegionSize) > dwAddress)) {
		if (
			(mbi.State == MEM_COMMIT) &&
			((mbi.Protect & PAGE_GUARD) == 0) &&
			(mbi.Protect != PAGE_NOACCESS) &&
			((mbi.AllocationProtect & PAGE_NOCACHE) != PAGE_NOCACHE)
			) {
			MEMORY_REGION mData = { 0 };
			mData.dwBaseAddr = (DWORD_PTR)mbi.BaseAddress;
			mData.dwMemorySize = mbi.RegionSize;
			m_vMemoryRegion.push_back(mData);
			memSectorList[memSectorIndex] = mData;
			memSectorIndex++;
		}
		dwAddress = (DWORD)mbi.BaseAddress + mbi.RegionSize;
	}
	vector<MEMORY_REGION>::iterator it;
	int memSectorCount = memSectorIndex;
	memSectorIndex = 0;
	DWORD_PTR curAddr = dwStartAddr;
	while (curAddr < dwEndAddr)
	{
		VirtualQueryEx(processHandle, (LPCVOID)curAddr, &mbi, sizeof(mbi));
		long regionSizeOrg = mbi.RegionSize;
		long regionSize = mbi.RegionSize;
		if (regionSize > 10) {
			BYTE* pCurrMemoryData = new BYTE[regionSize];
			ZeroMemory(pCurrMemoryData, regionSize);
			readMemory((PVOID)curAddr, (PVOID*)pCurrMemoryData, regionSize);
			DWORD_PTR dwOffset = 0;
			int iOffset = find(pCurrMemoryData, regionSize, bSearchData, nSearchSize);
			while (iOffset != -1) {
				dwOffset += iOffset;
				vRet.push_back(dwOffset + curAddr);
				dwOffset += nSearchSize;
				iOffset = find(pCurrMemoryData + dwOffset, regionSize - dwOffset - nSearchSize, bSearchData, nSearchSize);
			}
			delete[] pCurrMemoryData;
		}
		memSectorIndex++;
		curAddr = curAddr + (DWORD_PTR)regionSizeOrg;
		continue;
	}
	return TRUE;
}


int MemoryManager::find(BYTE* buffer, int dwBufferSize, BYTE* bstr, DWORD dwStrLen) {
	if (dwBufferSize < 0) {
		return -1;
	}
	int  i, j;
	for (i = 0; i < dwBufferSize; i++) {
		for (j = 0; j < dwStrLen; j++) {
			if ((buffer[i + j] != bstr[j]) && (bstr[j] != '?'))
				break;
		}
		if (j == dwStrLen)
			return i;
	}
	return -1;
}


DWORD MemoryManager::dRead(DWORD base) {
	readMemory((PVOID)base, &_d, 4);
	return _d;
}
float MemoryManager::fRead(DWORD base) {
	readMemory((PVOID)base, &_f, 4);
	return _f;
}
int MemoryManager::iRead(DWORD base) {
	readMemory((PVOID)base, &_i, 4);
	return _i;
}
uint64 MemoryManager::uiRead(DWORD base) {
	readMemory((PVOID)base, &_u, 8);
	return _u;
}
bool MemoryManager::bRead(DWORD base) {
	readMemory((PVOID)base, &_b, 1);
	return _b;
}
string MemoryManager::charRead(DWORD base)
{
	readMemory((PVOID)base, &_char, 32);
	return &_char;
}

Vector3f MemoryManager::v3Read(DWORD base)
{
	readMemory((PVOID)base, &_v3, 12);
	return _v3;
}
string MemoryManager::charp32Read(DWORD base)
{
	readMemory((PVOID)base, &_playerNameBuffer, 32);
	string playerName = "";
	int i = 0;
	for (i = 0; i < 32; i++)
	{
		if ((_playerNameBuffer[i] == 0x00) && (i > 0) && (i % 2 == 0))
		{
			break;
		}
		if (((i + 1) % 2) == 0)
		{
			continue;
		}
		if (_playerNameBuffer[i] != 0x00)
		{
			if ((_playerNameBuffer[i] == '\n') || (_playerNameBuffer[i] == '\r'))
				playerName += '?';
			else
				playerName += _playerNameBuffer[i];

		}
	}
	return playerName;
}

FTTransform2_t MemoryManager::structRead(DWORD base)
{
	readMemory((PVOID)base, &_struct, 44);
	return _struct;
}

```

`Super People Full/Super People Final/Super People Esp & Aimbot/Offsets/Inventory.md`:

```md
## Pubg Mobile Inventory Entity Offsets

![Pubg Mobile Inventory Entity Offsets](https://raw.githubusercontent.com/atiksoftware/pubg_mobile_memory_hacking_examples/master/Offsets/images/ReClassInventory.png "Pubg Mobile Inventory Entity Offsets")
 
```

`Super People Full/Super People Final/Super People Esp & Aimbot/Offsets/Player.md`:

```md
## Pubg Mobile Player Entity Offsets

![Pubg Mobile Player Entity Offsets](https://raw.githubusercontent.com/atiksoftware/pubg_mobile_memory_hacking_examples/master/Offsets/images/ReClassPlayer.png "Pubg Mobile Player Entity Offsets")
 
```

`Super People Full/Super People Final/Super People Esp & Aimbot/Offsets/Vehicle.md`:

```md
## Pubg Mobile Vehicle Entity Offsets

![Pubg Mobile Vehicle Entity Offsets](https://raw.githubusercontent.com/atiksoftware/pubg_mobile_memory_hacking_examples/master/Offsets/images/ReClassVehicle.png "Pubg Mobile Vehicle Entity Offsets")
 
```

`Super People Full/Super People Final/Super People Esp & Aimbot/Overlay.cpp`:

```cpp
#include "pch.h"

Overlay* g_pOverlay = new Overlay();
Overlay::Overlay() {}
Overlay::~Overlay() {}

void Overlay::createWindow()
{
	HWND hwndMain;
	hwndMain = FindWindowEx(NULL, NULL, L"TXGuiFoundation", L"Gameloop");
	if (IsWindow(hwndMain))
	{
		HWND hwndSub = FindWindowEx(hwndMain, NULL, L"AEngineRenderWindowClass", NULL);
		RECT rect;
		GetWindowRect(hwndSub, &rect);
		left = rect.left;
		top = rect.top;
		width = rect.right - rect.left;
		height = rect.bottom - rect.top;
	}
	else
	{
		left = 0;
		top = 0;
		width = GetSystemMetrics(SM_CXSCREEN) - 2;
		height = GetSystemMetrics(SM_CYSCREEN) - 2;
	}

	settings.antialiasingLevel = 4;

	window.create(
		sf::VideoMode(width, height),
		"PUBG Corona Drawings",
		sf::Style::None,
		settings
	);

	HWND hwnd = window.getSystemHandle();
	SetWindowLong(hwnd, GWL_EXSTYLE, WS_EX_TRANSPARENT | WS_EX_LAYERED);
	SetLayeredWindowAttributes(hwnd, 0, 255, LWA_ALPHA);
	DwmExtendFrameIntoClientArea(hwnd, &margin);
	SetWindowPos(hwnd, HWND_TOPMOST, left, top, width, height, SWP_SHOWWINDOW);
	UpdateWindow(hwnd);
}
```

`Super People Full/Super People Final/Super People Esp & Aimbot/Overlay.h`:

```h
#pragma once
class Overlay
{
public:
	Overlay();
	~Overlay();

	sf::RenderWindow window;
	int width{ 800 };
	int height{ 600 };
	int left{ 10 };
	int top{ 30 };
	sf::ContextSettings settings;
	MARGINS margin{ -1 };

	void createWindow();
};

extern Overlay* g_pOverlay;
```

`Super People Full/Super People Final/Super People Esp & Aimbot/SuperPeople.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Arabic (Egypt) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ARE)
LANGUAGE LANG_ARABIC, SUBLANG_ARABIC_EGYPT
#pragma code_page(1256)

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "icon1.ico"

#endif    // Arabic (Egypt) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Super People Full/Super People Final/Super People Esp & Aimbot/SuperPeople.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d1cea828-1130-4407-a540-61adc2c57814}</ProjectGuid>
    <RootNamespace>PUBGCorona</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="ESP.cpp" />
    <ClCompile Include="MemoryManager.cpp" />
    <ClCompile Include="Overlay.cpp" />
    <ClCompile Include="PUBGCorona.cpp" />
    <ClCompile Include="ViewMatrixManager.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ESP.h" />
    <ClInclude Include="MemoryManager.h" />
    <ClInclude Include="Overlay.h" />
    <ClInclude Include="pch.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="ViewMatrixManager.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="PUBGCorona.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="icon1.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Super People Full/Super People Final/Super People Esp & Aimbot/SuperPeople.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="MemoryManager">
      <UniqueIdentifier>{34b8a688-5158-489c-8432-89b7de4d1d9f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ESP">
      <UniqueIdentifier>{67142e2a-e43f-4c5b-96de-5bdf59ecaba0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Overlay">
      <UniqueIdentifier>{1cb3afc0-4f43-4aed-84fa-80110ff64115}</UniqueIdentifier>
    </Filter>
    <Filter Include="ViewMatrixManager">
      <UniqueIdentifier>{07c39e8c-c7d4-4334-9744-a1a61780e863}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="PUBGCorona.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ViewMatrixManager.cpp">
      <Filter>ViewMatrixManager</Filter>
    </ClCompile>
    <ClCompile Include="ESP.cpp">
      <Filter>ESP</Filter>
    </ClCompile>
    <ClCompile Include="MemoryManager.cpp">
      <Filter>MemoryManager</Filter>
    </ClCompile>
    <ClCompile Include="Overlay.cpp">
      <Filter>Overlay</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ViewMatrixManager.h">
      <Filter>ViewMatrixManager</Filter>
    </ClInclude>
    <ClInclude Include="ESP.h">
      <Filter>ESP</Filter>
    </ClInclude>
    <ClInclude Include="MemoryManager.h">
      <Filter>MemoryManager</Filter>
    </ClInclude>
    <ClInclude Include="Overlay.h">
      <Filter>Overlay</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="PUBGCorona.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="icon1.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`Super People Full/Super People Final/Super People Esp & Aimbot/ViewMatrixManager.h`:

```h
#pragma once
class ViewMatrixManager
{
public:
	ViewMatrixManager();
	~ViewMatrixManager();

	D3DMatrix viewmatrix;
	void worldToScreen(Vector3f pos, Vector3f& screen, float* distance, int* distanceValue);
	void worldBoneToScreen(Vector3f pos, Vector3f& screen);

};

extern ViewMatrixManager* g_pViewMatrixManager;
```

`Super People Full/Super People Final/Super People Esp & Aimbot/pch.h`:

```h
#ifndef PCH_H
#define PCH_H

using namespace std;

#define __int64 long long
typedef unsigned __int64 uill;
typedef uill uint64;
typedef unsigned int uint32;

#include <SFML/Audio.hpp>
#include <SFML/Graphics.hpp>

#include <iostream>
#pragma comment(lib, "dwmapi.lib")
#include <dwmapi.h>
#include <string>
#include <winternl.h>
#pragma comment(lib, "ntdll.lib");
#include <ntstatus.h>
#include <TlHelp32.h>
#include <tchar.h>

struct D3DMatrix
{
	float _11 = 0.f, _12 = 0.f, _13 = 0.f, _14 = 0.f;
	float _21 = 0.f, _22 = 0.f, _23 = 0.f, _24 = 0.f;
	float _31 = 0.f, _32 = 0.f, _33 = 0.f, _34 = 0.f;
	float _41 = 0.f, _42 = 0.f, _43 = 0.f, _44 = 0.f;
};
struct Vector3f
{
	float x = 0.f;
	float y = 0.f;
	float z = 0.f;
};
struct Vector4f
{
	float x = 0.f;
	float y = 0.f;
	float z = 0.f;
	float w = 0.f;
};
struct FTTransform2_t
{
	Vector4f Rotation;
	Vector3f Translation;
	float ddd{ 0.f };
	Vector3f Scale3D;
};

#include "Overlay.h"
#include "ESP.h"
#include "MemoryManager.h"
#include "ViewMatrixManager.h"

#endif
```

`Super People Full/Super People Final/Super People Esp & Aimbot/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by PUBGCorona.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Super People Full/Super People Final/Super People Speed/DllMain.cpp`:

```cpp
//---------------------------------------------------------------------------

#include <windows.h>
#include "MainForm.h"
#pragma hdrstop
#pragma argsused

long WINAPI FormThread(long lParam)
{
Form1=new TForm1(NULL);
Application->Initialize();
Application->CreateForm(__classid(TForm1), &Form1);
Application->Run();
Application->ProcessMessages();
Form1->Show();



	return true;
}
int WINAPI DllEntryPoint(HINSTANCE hinst, unsigned long reason, void* lpReserved)
{
switch (reason)
{
case DLL_PROCESS_ATTACH:
CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)FormThread,NULL,0,0);
break;
case DLL_PROCESS_DETACH:
ExitProcess(1) ;
break;
}
		return 1;
}
//---------------------------------------------------------------------------


```

`Super People Full/Super People Final/Super People Speed/Main.cpp`:

```cpp
//---------------------------------------------------------------------------


#pragma hdrstop

#include <stdio.h>
#include <iostream>
#include <fstream>
#include <time.h>
#include <math.h>

#include "Main.h"
#include "MainForm.h"

CGeneral		_CGeneral;
CCharBase		_CCharBase;
CPacket			_CPacket;
CArea			_CArea;
CMath			_CMath;
CCast			_CCast;
CBag			_CBag;
CTrap			_CTrap;
CParty			_CParty;
CRecvFunction	_CRecvFunction;
CTest			_CTest;

//---------------------------------------------------------------------------

#pragma package(smart_init)

//***** CGeneral *****//

bool CGeneral::ConnectServer(char* strIP, int iPort){
LPVOID tmpIP = strIP;
int tmpPort = iPort;
DWORD dwRet = 0;
__asm{
MOV EDX,[KO_SCK2]
MOV ECX,[KO_SOCK]
PUSH tmpPort
PUSH tmpIP
PUSH EDX
MOV EAX,KO_CONN
CALL EAX
MOV dwRet,EAX
}
if(dwRet)
	return false;
return true;
}

void CGeneral::DisconnectServer(){
DWORD CallAddr = KO_DISC;
__asm{
MOV ECX,[KO_SOCK]
CALL [&CallAddr]
MOV ECX,[KO_SOCK+4]
CALL [&CallAddr]
}
}

void CGeneral::PostMsgBox(char* strMsg, BYTE bButton, BYTE bFunction){
int msgLen = strlen(strMsg);
char *alloc = new char[msgLen+96+1];
memset(alloc,0,msgLen+96+1);
memcpy(alloc+96,strMsg,msgLen);
*(DWORD*)(alloc+36) = (DWORD)(alloc+96);
*(DWORD*)(alloc+40) = msgLen;
DWORD Addr1 = (DWORD)(alloc);
DWORD Addr2 = (DWORD)(alloc+32);
DWORD Addr3 = (DWORD)(alloc+64);
__asm{
XOR EAX,EAX
PUSH 0
MOV AL,bFunction
PUSH EAX
MOV AL,bButton
PUSH EAX
PUSH Addr1
PUSH Addr2
PUSH Addr3
MOV EAX,KO_MSBX
CALL EAX
ADD ESP,0x18
}
delete [] alloc;
}

void CGeneral::PostMsgOut(char* strMsg, DWORD dwColor){
int msgLen = strlen(strMsg);
char *alloc = new char[msgLen+32+1];
memset(alloc,0,msgLen+32+1);
memcpy(alloc+32,strMsg,msgLen);
*(DWORD*)(alloc+4) = (DWORD)(alloc+32);
*(DWORD*)(alloc+8) = msgLen;
DWORD Addr1 = (DWORD)(alloc);
__asm{
MOV ECX,[KO_DLGA]
MOV ECX,[ECX+DLG_OFF1]
PUSH dwColor
PUSH Addr1
MOV EAX,KO_MSOP
CALL EAX
}
delete [] alloc;
}

void CGeneral::PassEncrypt(char* strPass, char* pEncBuffer){
DWORD TmpECX = 0x9BF9C8;
LPVOID InBuffer = strPass;
LPVOID OutBuffer = pEncBuffer;
__asm{
	PUSH OutBuffer
	PUSH 1000
	PUSH InBuffer
	LEA ECX,&TmpECX
	MOV EAX,0x854520
	CALL EAX
}
}

//***** CCharBase *****//

bool CCharBase::IsEnemy(){
bool bRet;
DWORD CharBase = this->GetBase();
__asm{
MOV ECX,[KO_CHAR]
PUSH CharBase
MOV EAX,KO_ISEN
CALL EAX
MOV bRet,AL
}
return bRet;
}

//***** CPacket *****//

void CPacket::PSend(BYTE* pBuf,size_t szBuf){
//melih
DWORD* ptrTHRD = (DWORD*)KO_THRD;
DWORD tmpThread 	= *ptrTHRD;
*ptrTHRD = GetCurrentThreadId();
LPVOID Buffer = pBuf;
int Size = szBuf;
DWORD CallAddr = *(DWORD*)((GetIndex() * 4) + *(DWORD*)KO_SOCK + 0x40064);
__asm{
MOV ECX,[KO_SOCK]
PUSH Size
PUSH Buffer
MOV EAX,CallAddr
CALL EAX
}
*ptrTHRD = tmpThread;
*(BYTE*)KO_PFIX = 0;
AddPCount();
}

BYTE CPacket::GetIndex(){
DWORD Idx = 0;
__asm{
LEA EAX,&Idx
PUSH EAX
PUSH 4
PUSH KO_SDFX
PUSH 2
MOV EAX,KO_INDX
CALL EAX
ADD ESP,0x10
}
bFuncIndex = (BYTE)Idx;
return (BYTE)Idx;
}

//***** CArea *****//

int CArea::GetUPCCount(){
int iCount = 0;

DWORD dwTmpBase	= *(DWORD*)(KO_AREA);
DWORD dwStart	= *(DWORD*)(dwTmpBase + 0x3C);
DWORD dwBase;

dwTmpBase = *(DWORD*)(dwStart);

LOOP:
if(dwTmpBase == dwStart)
	goto RETN;

dwBase = *(DWORD*)(dwTmpBase + 0x10);
if(dwBase)
	iCount += 1;

NEXT:
__asm{
LEA ECX,&dwTmpBase
MOV EAX,KO_NXTP
CALL EAX
}
goto LOOP;

RETN:
return iCount;
}

int CArea::GetNPCCount(){
int iCount = 0;

DWORD dwTmpBase	= *(DWORD*)(KO_AREA);
DWORD dwStart	= *(DWORD*)(dwTmpBase + 0x2C);
DWORD dwBase;

dwTmpBase = *(DWORD*)(dwStart);

LOOP:
if(dwTmpBase == dwStart)
	goto RETN;

dwBase = *(DWORD*)(dwTmpBase + 0x10);
if(dwBase)
	iCount += 1;

NEXT:
__asm{
LEA ECX,&dwTmpBase
MOV EAX,KO_NXTM
CALL EAX
}
goto LOOP;

RETN:
return iCount;
}

DWORD CArea::GetUPCBase(WORD wID){
DWORD dwBase;
DWORD dwID = (DWORD)wID;
__asm{
MOV ECX,[KO_AREA]
PUSH 1
PUSH dwID
MOV EAX,KO_FPBS
CALL EAX
MOV dwBase,EAX
}
return dwBase;
}

DWORD CArea::GetNPCBase(WORD wID){
DWORD dwBase;
DWORD dwID = (DWORD)wID;
__asm{
MOV ECX,[KO_AREA]
PUSH 1
PUSH dwID
MOV EAX,KO_FMBS
CALL EAX
MOV dwBase,EAX
}
return dwBase;
}

DWORD CArea::GetCorpseBase(WORD wID){
DWORD dwBase = 0;
DWORD dwID = (DWORD)wID;
__asm{
LEA EAX,&dwID
PUSH EAX
LEA EAX,&dwBase
PUSH EAX
MOV ECX,[KO_AREA]
ADD ECX,0x48
MOV EAX,KO_NPCB
CALL EAX
}
if(!dwBase)
	return 0;
if(dwBase == *(DWORD*)(*(DWORD*)(KO_AREA) + 0x4C))
	return 0;
return *(DWORD*)(dwBase + 0x10);
}

DWORD CArea::GetAnyBase(WORD wID){
DWORD dwBase;

if(!wID || wID == 0xFFFF)
	return 0;

if(wID < 10000)
	dwBase = GetUPCBase(wID);
else
	dwBase = GetNPCBase(wID);

if(!dwBase)
	dwBase = GetCorpseBase(wID);

return dwBase;
}

DWORD CArea::GetZEnemyBase(){
DWORD dwBase;
__asm{
MOV EAX,[KO_CHAR]
ADD EAX,KO_POSX
MOV ECX,[KO_AREA]
PUSH EAX
PUSH 0
MOV EAX,KO_FPOZ
CALL EAX
MOV dwBase,EAX
}
if(dwBase) dwLastNearstBase = dwBase;
return dwBase;
}

DWORD CArea::GetNPCByName(int iNameCount, char* ptrName[], char* sName, bool bNearst, bool bEnemy, bool bAlive, FLOAT fMaxDist, bool bLoop){
if(!iNameCount) return 0;

SIZE_T iNameLen;		//for single name
SIZE_T* ptrNameLen;		//for multi names
bool bSingleName = false;

if(ptrName){
	ptrNameLen = new SIZE_T[iNameCount];
	for (int i = 0; i < iNameCount; i++) {
		ptrNameLen[i] = strlen(ptrName[i]);
	}
}
else
{
	if(!sName)	return 0;
	iNameLen = strlen(sName);
	bSingleName = true;
}

DWORD dwTmpBase,dwStart,dwRetBase;
FLOAT fRetDist,pDist;
CCharBase pNPC;
SIZE_T iCurLen;
DWORD TmpVal;

BEGIN:
	dwTmpBase	= *(DWORD*)(KO_AREA);
	dwStart	= *(DWORD*)(dwTmpBase + 0x2C);
	dwRetBase	= 0;
	fRetDist;

	dwTmpBase = *(DWORD*)(dwStart);

LOOP:
	if(dwTmpBase == dwStart){
		if(bLoop && !dwRetBase)
			goto BEGIN;
		goto RETN;
	}

	pNPC = *(DWORD*)(dwTmpBase + 0x10);
	if(!pNPC.GetBase())
		goto NEXT;

	if(bAlive){
		if( !pNPC.IsAlive() )
			goto NEXT;
	}

	if(bEnemy){
		TmpVal = pNPC.GetDWORD(0x93C);
		if(TmpVal){
			if(*(BYTE*)(TmpVal + 0xA) == 1 || *(BYTE*)(TmpVal + 0xA) == 3 || *(BYTE*)(TmpVal + 0xA) == 4)
				goto NEXT;
		}

		if( !pNPC.IsEnemy() )
			goto NEXT;
	}

	pDist = _CMath.fDist(_CCharBase.GetFLOAT(KO_POSX),_CCharBase.GetFLOAT(KO_POSY),pNPC.GetFLOAT(KO_POSX),pNPC.GetFLOAT(KO_POSY));

	if(fMaxDist){
		if(pDist > fMaxDist)
			goto NEXT;
	}

	iCurLen = strlen(pNPC.GetName());

	if(bSingleName){
	if(iNameLen != iCurLen)
		goto NEXT;

	if(strcmp(sName,pNPC.GetName()) != 0)
		goto NEXT;

	if(bNearst){
		if(dwRetBase){
			if(pDist < fRetDist){
				dwRetBase = pNPC.GetBase();
				fRetDist = pDist;
			}
		}else{
			dwRetBase = pNPC.GetBase();
			fRetDist = pDist;
		}
	}else{
	dwRetBase = pNPC.GetBase();
	goto RETN;
	}

	}else{
		for (int i = 0; i < iNameCount; i++) {
			if(ptrNameLen[i] != iCurLen)
				continue;

			if(strcmp(ptrName[i],pNPC.GetName()) != 0)
				continue;

				if(bNearst){
					if(dwRetBase){
						if(pDist < fRetDist){
							dwRetBase = pNPC.GetBase();
							fRetDist = pDist;
						}
					}else{
						dwRetBase = pNPC.GetBase();
						fRetDist = pDist;
					}
				}else{
					dwRetBase = pNPC.GetBase();
					goto RETN;
				}

			break;
		}
	}

NEXT:
	__asm{
		LEA ECX,&dwTmpBase
		MOV EAX,KO_NXTM
		CALL EAX
	}
	goto LOOP;

RETN:
	if(ptrName)
		delete [] ptrNameLen;
	if(dwRetBase)
		dwLastNearstBase = dwRetBase;
	return dwRetBase;
}

DWORD CArea::GetUPCByName(int iNameCount, char* ptrName[], char* sName, bool bAlive, FLOAT fMaxDist){
if(!iNameCount) return 0;

SIZE_T iNameLen;		//for single name
SIZE_T* ptrNameLen;		//for multi names
bool bSingleName = false;

if(ptrName){
	ptrNameLen = new SIZE_T[iNameCount];
	for (int i = 0; i < iNameCount; i++) {
		ptrNameLen[i] = strlen(ptrName[i]);
	}
}
else
{
	if(!sName)	return 0;
	iNameLen = strlen(sName);
	bSingleName = true;
}

DWORD dwTmpBase,dwStart,dwRetBase;
FLOAT fRetDist,pDist;
CCharBase pUPC;
SIZE_T iCurLen;

BEGIN:
	dwTmpBase	= *(DWORD*)(KO_AREA);
	dwStart	= *(DWORD*)(dwTmpBase + 0x3C);
	dwRetBase	= 0;
	fRetDist;

	dwTmpBase = *(DWORD*)(dwStart);

LOOP:
	if(dwTmpBase == dwStart)
		goto RETN;

	pUPC = *(DWORD*)(dwTmpBase + 0x10);
	if(!pUPC.GetBase())
		goto NEXT;

	if(bAlive){
		if(!pUPC.IsAlive())
			goto NEXT;
	}

	pDist = _CMath.fDist(_CCharBase.GetFLOAT(KO_POSX),_CCharBase.GetFLOAT(KO_POSY),pUPC.GetFLOAT(KO_POSX),pUPC.GetFLOAT(KO_POSY));

	if(fMaxDist){
		if(pDist > fMaxDist)
			goto NEXT;
	}

	iCurLen = strlen(pUPC.GetName());

	if(bSingleName){
	if(iNameLen != iCurLen)
		goto NEXT;

	if(strcmp(sName,pUPC.GetName()) != 0)
		goto NEXT;

	dwRetBase = pUPC.GetBase();
	goto RETN;

	}else{
		for (int i = 0; i < iNameCount; i++) {
			if(ptrNameLen[i] != iCurLen)
				continue;

			if(strcmp(ptrName[i],pUPC.GetName()) != 0)
				continue;

			dwRetBase = pUPC.GetBase();
			goto RETN;
		}
	}

NEXT:
	__asm{
		LEA ECX,&dwTmpBase
		MOV EAX,KO_NXTP
		CALL EAX
	}
	goto LOOP;

RETN:
	if(ptrName)
		delete [] ptrNameLen;
	return dwRetBase;
}

void CArea::SelectObject(CCharBase Object){
DWORD dwBase = Object.GetBase();
__asm{
MOV ECX,[KO_DLGA]
PUSH dwBase
MOV EAX,KO_SETM
CALL EAX
}
}

//***** CMath *****//

inline FLOAT CMath::fDist(FLOAT X1, FLOAT Y1, FLOAT X2, FLOAT Y2){
return pow((double)((X2-X1)*(X2-X1)) + (double)((Y2-Y1)*(Y2-Y1)),0.5) / 4;
}

//***** CCast *****//

int CCast::CastCount(){
DWORD TMP = *(DWORD*)(KO_DLGA);
TMP = *(DWORD*)(TMP+DLG_OFF2);
TMP = *(DWORD*)(TMP+0x4);
return *(DWORD*)(TMP+0xD0);
}

int CCast::CastNum(int iNo){
if(!CastCount())return 0;
DWORD TMP = *(DWORD*)(KO_DLGA);
TMP = *(DWORD*)(TMP+DLG_OFF2);
TMP = *(DWORD*)(TMP+0x4);
TMP = *(DWORD*)(TMP+0xCC);
for (int i = 1; i <= iNo; i++) {
TMP = *(DWORD*)(TMP);
}
TMP = *(DWORD*)(TMP+0x8);
if(TMP)
	return *(DWORD*)(TMP);
return 0;
}

int CCast::MakeCastNum(CCharBase dwBase, char* strTail){
int iClass = dwBase.GetDWORD(KO_CLSS);

char temp[7]; memset(temp,0,7);
itoa(iClass,temp,10);
strcat(temp,strTail);
return atoi(temp);
}

bool CCast::IsCasted(int Num){
int count = CastCount();
if(!count) return false;

for (int i=0; i <= count; i++) {
if(CastNum(i)==Num) return true;
}
return false;
}

//***** CInvSlot *****//

CInvSlot::CInvSlot(int iSlot){
if(iSlot == -1){
dwBase = 0;
return;
}
DWORD Tmp = *(DWORD*)(KO_DLGA);
Tmp = *(DWORD*)(Tmp + DLG_OFF3);
Tmp = *(DWORD*)(Tmp + (0x134 + (4 * (iSlot + 26))));
dwBase = Tmp;
iCurrentSlot = iSlot;
}

void CInvSlot::SelectSlot(int iSlot){
if(iSlot == -1){
dwBase = 0;
return;
}
DWORD Tmp = *(DWORD*)(KO_DLGA);
Tmp = *(DWORD*)(Tmp + DLG_OFF3);
Tmp = *(DWORD*)(Tmp + (0x134 + (4 * (iSlot + 26))));
dwBase = Tmp;
iCurrentSlot = iSlot;
}

void CInvSlot::SelectLeft(){
DWORD Tmp = *(DWORD*)(KO_DLGA);
Tmp = *(DWORD*)(Tmp + DLG_OFF3);
Tmp = *(DWORD*)(Tmp + 0x184);
dwBase = Tmp;
iCurrentSlot = -1;
}

void CInvSlot::SelectRight(){
DWORD Tmp = *(DWORD*)(KO_DLGA);
Tmp = *(DWORD*)(Tmp + DLG_OFF3);
Tmp = *(DWORD*)(Tmp + 0x17C);
dwBase = Tmp;
iCurrentSlot = -1;
}

//***** CInnSlot *****//

CInnSlot::CInnSlot(int iSlot){
if(iSlot == -1){
dwBase = 0;
return;
}
DWORD Tmp = *(DWORD*)(KO_DLGA);
Tmp = *(DWORD*)(Tmp + DLG_OFF4);
Tmp = *(DWORD*)(Tmp + ((iSlot * 4)+0xC8));
dwBase = Tmp;
iCurrentSlot = iSlot;
}

void CInnSlot::SelectSlot(int iSlot){
if(iSlot == -1){
dwBase = 0;
return;
}
DWORD Tmp = *(DWORD*)(KO_DLGA);
Tmp = *(DWORD*)(Tmp + DLG_OFF4);
Tmp = *(DWORD*)(Tmp + ((iSlot * 4)+0xC8));
dwBase = Tmp;
iCurrentSlot = iSlot;
}

//***** CBag *****//

int CBag::FindInvItem(int iBegin, int dwNum){
CInvSlot pSlot;
int iRetSlot = -1;

for (int i = iBegin; i < iMaxInventorySlot; i++) {
pSlot.SelectSlot(i);
if(pSlot.IsFree())
	continue;
if(pSlot.dwItemNum() == dwNum){
iRetSlot = i;
break;
}
}

return iRetSlot;
}

int CBag::FindFreeInvSlot(int iBegin){
CInvSlot pSlot;
int iRetSlot = -1;

for (int i = iBegin; i < iMaxInventorySlot; i++) {
pSlot.SelectSlot(i);
if(pSlot.IsFree()){
iRetSlot = i;
break;
}
}

return iRetSlot;
}

int CBag::FindInnItem(int iBegin, int dwNum){
CInnSlot pSlot;
int iRetSlot = -1;

for (int i = iBegin; i < iMaxInnSlot; i++) {
pSlot.SelectSlot(i);
if(pSlot.IsFree())
	continue;
if(pSlot.dwItemNum() == dwNum){
iRetSlot = i;
break;
}
}

return iRetSlot;
}

int CBag::FindFreeInnSlot(int iBegin){
CInnSlot pSlot;
int iRetSlot = -1;

for (int i = iBegin; i < iMaxInnSlot; i++) {
pSlot.SelectSlot(i);
if(pSlot.IsFree()){
iRetSlot = i;
break;
}
}

return iRetSlot;
}

//***** CTrap *****//

bool CTrap::Switch(bool bOnOff){
if(bOnOff){
if(IsSwitched())
	return false;

hThread = CreateThread(0,0,(LPTHREAD_START_ROUTINE)_StartThread,this,0,&dwThread);
bState = true;
}else{
if(!IsSwitched())
	return false;

TerminateThread(hThread,0);
CloseHandle(hThread);
hThread=0;
dwThread=0;
bState = false;
}
return true;
}

void CTrap::Function(){
bool bTrapped;
DWORD WSOCKADR	=	(DWORD) GetProcAddress(GetModuleHandleA("WS2_32.dll"),"send");
DWORD SENDADR	=	*(DWORD*)(KO_SOCK) + (_CPacket.GetIndex() * 4) + 0x40064;
if(!WSOCKADR || !SENDADR)return;

LOOP:
bTrapped=false;
if(*(BYTE*)(KO_CRYP) != TRAP_bCryptByte) bTrapped=true;
if(*(BYTE*)(WSOCKADR) != TRAP_bWSockByte) bTrapped=true;
if(*(DWORD*)(SENDADR) >= TRAP_iMaxSendAdr) bTrapped=true;
if(!bTrapped){
Sleep(TRAP_iTrapDelay);
goto LOOP;
}
TerminateProcess(GetCurrentProcess(),0);
}

//***** CParty *****//

void CParty::Refresh(){
DWORD dwBase = *(DWORD*)(KO_PRTY);
dwBase = *(DWORD*)(dwBase + PTY_OFF5);

int UserCount = *(DWORD*)(dwBase + 0x360);
iCount = UserCount;

for (int n = UserCount; n < 8; n++) {
dwUser[n] = 0;
}

if(!UserCount)
	return;

dwBase = *(DWORD*)(dwBase + 0x35C);
DWORD tmpUser;

for (int i = 0; i < UserCount; i++) {
tmpUser = dwBase;

for (int y = 0; y < (i + 1); y++) {
tmpUser = *(DWORD*)(tmpUser);
}

dwUser[i] = tmpUser;
}

}

//***** CRecvFunction *****//

BYTE CRecvFunction::GetIndex(){
DWORD Idx = 0;
__asm{
LEA EAX,&Idx
PUSH EAX
PUSH 4
PUSH KO_RCFX
PUSH 1
MOV EAX,KO_INDX
CALL EAX
ADD ESP,0x10
}
bFuncIndex = (BYTE)Idx;
return (BYTE)Idx;
}

bool CRecvFunction::StartFunction(){

if(bState)
	return false;

BYTE FuncIdx = GetIndex();
DWORD _KO_RCVA = KO_RCVA + (FuncIdx * 4);
DWORD _KO_RCVB = *(DWORD*)(_KO_RCVA);
dwOldAdr = _KO_RCVB;

HMODULE hKernel32		= GetModuleHandleA("Kernel32.dll");
DWORD adrCreateFile		= (DWORD) GetProcAddress(hKernel32,"CreateFileA");
DWORD adrWriteFile		= (DWORD) GetProcAddress(hKernel32,"WriteFile");
DWORD adrCloseFile		= (DWORD) GetProcAddress(hKernel32,"CloseHandle");

LPVOID FuncAdr = VirtualAlloc(0,1024,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
if(!FuncAdr)return false;

char* RF_strMSName	= "//./mailslot/kojd";
size_t szBasePath = strlen(RF_strMSName);

char pid[5];	ultoa(GetCurrentProcessId(),pid,10);
size_t szPid	=	strlen(pid);
char *MSlotName = new char[szBasePath+szPid+1];
memset(MSlotName,0,szBasePath+szPid+1);
memcpy(MSlotName,RF_strMSName,szBasePath);
strcat(MSlotName,pid);

HANDLE MSlotHandle = CreateMailslotA(MSlotName,0,0,0);
if((DWORD)(MSlotHandle)==0xFFFFFFFF){
VirtualFree(FuncAdr,0,MEM_RELEASE);
delete [] MSlotName;
return false;
}
hMailSlot	=	MSlotHandle;

DWORD tmpAddr = (DWORD)(FuncAdr)+0x400;
memcpy((LPVOID)(tmpAddr),MSlotName,strlen(MSlotName));

tmpAddr = (DWORD)(FuncAdr)+0x32A;
*(DWORD*)(tmpAddr) = adrCreateFile;

tmpAddr = (DWORD)(FuncAdr)+0x334;
*(DWORD*)(tmpAddr) = adrWriteFile;

tmpAddr = (DWORD)(FuncAdr)+0x33E;
*(DWORD*)(tmpAddr) = adrCloseFile;

tmpAddr = (DWORD)(FuncAdr)+0x208;
*(DWORD*)(tmpAddr) = _KO_RCVB;

tmpAddr = (DWORD)(FuncAdr)+0x212;
*(DWORD*)(tmpAddr) = _KO_RCVA;

tmpAddr = (DWORD)(FuncAdr)+0x21C;
*(DWORD*)(tmpAddr) = (DWORD)(FuncAdr);

BYTE PATCH[]={	0x52,0x89,0x0D,0,0,0,0,
				0x89,0x05,0,0,0,0,
				0x8B,0x4E,0x04,0x89,0x0D,0,0,0,0,
				0x8B,0x56,0x08,0x89,0x15,0,0,0,0,
				0x81,0xF9,0x00,0x10,0x00,0x00,0x7D,0x3E,0x50,0x68,0x80,0x00,0x00,0x00,0x6A,0x04,0x6A,0x00,0x6A,0x01,0x68,0x00,0x00,0x00,0x40,0x68,0,0,0,0,
				0xFF,0x15,0,0,0,0,
				0x83,0xF8,0xFF,0x74,0x1D,0x50,0x6A,0x00,0x54,0xFF,0x35,0,0,0,0,
				0xFF,0x35,0,0,0,0,
				0x50,0xFF,0x15,0,0,0,0,
				0xFF,0x15,0,0,0,0,
				0x8B,0x0D,0,0,0,0,
				0x8B,0x05,0,0,0,0,
				0x5A,0xFF,0x25,0,0,0,0,
};

tmpAddr = (DWORD)(FuncAdr)+0x320;
CopyBytes(PATCH+3,tmpAddr);

tmpAddr = (DWORD)(FuncAdr)+0x3B6;
CopyBytes(PATCH+9,tmpAddr);

tmpAddr = (DWORD)(FuncAdr)+0x1F4;
CopyBytes(PATCH+18,tmpAddr);

tmpAddr = (DWORD)(FuncAdr)+0x1FE;
CopyBytes(PATCH+27,tmpAddr);

tmpAddr = (DWORD)(FuncAdr)+0x400;
CopyBytes(PATCH+57,tmpAddr);

tmpAddr = (DWORD)(FuncAdr)+0x32A;
CopyBytes(PATCH+63,tmpAddr);

tmpAddr = (DWORD)(FuncAdr)+0x1F4;
CopyBytes(PATCH+78,tmpAddr);

tmpAddr = (DWORD)(FuncAdr)+0x1FE;
CopyBytes(PATCH+84,tmpAddr);

tmpAddr = (DWORD)(FuncAdr)+0x334;
CopyBytes(PATCH+91,tmpAddr);

tmpAddr = (DWORD)(FuncAdr)+0x33E;
CopyBytes(PATCH+97,tmpAddr);

tmpAddr = (DWORD)(FuncAdr)+0x320;
CopyBytes(PATCH+103,tmpAddr);

tmpAddr = (DWORD)(FuncAdr)+0x3B6;
CopyBytes(PATCH+109,tmpAddr);

tmpAddr = (DWORD)(FuncAdr)+0x208;
CopyBytes(PATCH+116,tmpAddr);

memcpy(FuncAdr,PATCH,sizeof(PATCH));

*(DWORD*)(_KO_RCVA)=(DWORD)(FuncAdr);

delete [] MSlotName;

lFuncAdr = FuncAdr;
bPaused = false;
bState = true;

hThread = CreateThread(0,0,(LPTHREAD_START_ROUTINE)_StartThread,this,0,&dwThread);

return true;
}

void CRecvFunction::StopFunction(){
if(!bState)
	return;

DWORD _KO_RCVA = KO_RCVA + (bFuncIndex * 4);
*(DWORD*)(_KO_RCVA) = dwOldAdr;

if(hThread){
	TerminateThread(hThread,0);
	CloseHandle(hThread);
}

if(lFuncAdr)
	VirtualFree(lFuncAdr,0,MEM_RELEASE);

bState = false;
bPaused = false;
hThread = 0;
dwThread = 0;
}

float CTest::GetPosZ(float fPosX, float fPosY)
{
	float fRetZ = 0;
	__asm{
		PUSH 1
		PUSH fPosY
		PUSH fPosX
		MOV EAX,[0xC26C30]
		MOV ECX,[EAX+0x1C]
		MOV EAX,[ECX]
		CALL [EAX+0x34]
		FSTP &fRetZ
	}
	return fRetZ;
}

void CTest::InitPos(float fPosX, float fPosY, float fPosZ)
{
	char pNewPos[12];	// 4*3 = 12 bytes memory allocation.

	*(FLOAT*)(pNewPos) 		= fPosX;
	*(FLOAT*)(pNewPos + 4) 	= fPosZ;
	*(FLOAT*)(pNewPos + 8) 	= fPosY;

	__asm
	{
		LEA EAX,pNewPos
		PUSH EAX
		MOV ECX,[KO_DLGA]
		MOV EAX,0x7FB870
		CALL EAX
    }

}


```

`Super People Full/Super People Final/Super People Speed/Main.h`:

```h
//---------------------------------------------------------------------------

#ifndef MainH
#define MainH

#include <Classes.hpp>

#include "Memory.h"

//***** FUNCTIONS *****//

#define CopyBytes(Dest, Src) memcpy(Dest, (BYTE*)&Src, sizeof(Src))

//***** ITEMS *****//
#define ITEM_WOLF			370004000
#define ITEM_ARROW			391010000
#define ITEM_NOAH			900000000
#define ITEM_HP45			389010000
#define ITEM_HP90			389011000
#define ITEM_HP180			389012000
#define ITEM_HP360			389013000
#define ITEM_HP720			389014000
#define ITEM_MP120			389016000
#define ITEM_MP240			389017000
#define ITEM_MP480			389018000
#define ITEM_MP960			389019000
#define ITEM_MP1920			389020000
#define ITEM_KILLINGBLADE	700037000
#define ITEM_TS_SCROLL		381001000

//***** SKILLS *****//
#define SKILL_HP45			490010
#define SKILL_HP90			490011
#define SKILL_HP180			490012
#define SKILL_HP360			490013
#define SKILL_HP720			490014
#define SKILL_MP120			490016
#define SKILL_MP240			490017
#define SKILL_MP480			490018
#define SKILL_MP960			490019
#define SKILL_MP1920		490020
#define SKILL_CHAOSSPRINT	490223
#define SKILL_CHAOSSWORD	490219
#define SKILL_CHAOSBLADE	490226
#define SKILL_CHAOSPOT		490222
#define SKILL_TS_CAST		472001
#define SKILL_TS_BOWMAN		472310

//***** OTHER *****//

//Bag
const int iMaxInventorySlot = 28;
const int iMaxInnPageSlot = 24;
const int iMaxInnPage = 8;
const int iMaxInnSlot = iMaxInnPageSlot * iMaxInnPage;

//Trap
const int TRAP_iTrapDelay	= 1000;
const BYTE TRAP_bCryptByte	= 0x53;
const BYTE TRAP_bWSockByte	= 0x8B;
const int TRAP_iMaxSendAdr	= 0x500000;

//RecvFunction
const int RF_iExecDelay		= 250;

//////////////////////////////
//***** GLOBAL CLASSES *****//
/////////////////////////////

class CGeneral{
	public:
		//General
		inline void SetWindowTop(HWND hHWND, bool bTop){HWND hType = HWND_TOPMOST; if(!bTop)hType = HWND_NOTOPMOST; SetWindowPos(hHWND,hType,0,0,0,0,SWP_NOSIZE + SWP_NOMOVE);};
		bool ConnectServer(char* strIP, int iPort);
		void DisconnectServer();
		void PostMsgBox(char* strMsg, BYTE bButton, BYTE bFunction);
		void PostMsgOut(char* strMsg, DWORD dwColor);
		void PassEncrypt(char* strPass, char* pEncBuffer);
		//Default
		CGeneral(){};
};

class CCharBase{
	private:
		DWORD dwBase;
	public:
		//General
		inline void		SetBase(DWORD dwAddr){dwBase = dwAddr;};
		inline DWORD 	GetBase(){return dwBase;};
		inline WORD 	GetID(){return GetWORD(KO_MYID);};
		inline char*	GetName(){return (LPSTR)GetDWORD(KO_NICK);};
		inline bool 	IsUPC(){if(*(DWORD*)(dwBase + 0x30) == 2) return true; return false;};
		inline bool		IsAlive(){if(GetDWORD(0x388)==4 || GetDWORD(0x388)==5 || GetDWORD(0x388)==0xD)return false; else return true;};
		inline void		MoveTo(FLOAT X, FLOAT Y){SetFLOAT(KO_PTRX,X); SetFLOAT(KO_PTRY,Y); SetDWORD(KO_MOV1,2); SetDWORD(KO_MOV2,2);};
		inline void		SetSize(FLOAT fSize){SetFLOAT(KO_SIZE,fSize);};
		inline FLOAT	GetSize(){return GetFLOAT(KO_SIZE);};
		inline WORD		GetTargetID(){return GetWORD(KO_TGID);};
		bool IsEnemy();
		//Set memory
		inline void 	SetBYTE(DWORD dwOffset,BYTE bVal){*(BYTE*)(dwBase + dwOffset) = bVal;};
		inline void 	SetWORD(DWORD dwOffset,WORD wVal){*(WORD*)(dwBase + dwOffset) = wVal;};
		inline void 	SetDWORD(DWORD dwOffset,DWORD dwVal){*(DWORD*)(dwBase + dwOffset) = dwVal;};
		inline void		SetFLOAT(DWORD dwOffset,FLOAT fVal){*(FLOAT*)(dwBase + dwOffset) = fVal;};
		//Get memory
		inline BYTE 	GetBYTE(DWORD dwOffset){return *(BYTE*)(dwBase + dwOffset);};
		inline WORD 	GetWORD(DWORD dwOffset){return *(WORD*)(dwBase + dwOffset);};
		inline DWORD 	GetDWORD(DWORD dwOffset){return *(DWORD*)(dwBase + dwOffset);};
		inline FLOAT 	GetFLOAT(DWORD dwOffset){return *(FLOAT*)(dwBase + dwOffset);};
		//Default
		CCharBase(){dwBase = 0;};
		CCharBase(DWORD dwBaseAddr){dwBase = dwBaseAddr;};
};

//***** FUNCTION CLASSES *****//

class CPacket{
	private:
		BYTE bFuncIndex;
		int iSendCount;
	public:
		//General
		void PSend(BYTE* pBuf,size_t szBuf);
		BYTE GetIndex();
		inline bool GetConnState(){return *(BYTE*)(*(DWORD*)(KO_SOCK) + 0x4003C);};
		inline int GetPCount(){return iSendCount;};
		inline void AddPCount(){iSendCount += 1;};
		inline void ClearPCount(){iSendCount = 0;};
		//Set memory
		inline void PutBYTE(char* pBuffer,BYTE bVal){*(pBuffer) = bVal;};
		inline void PutWORD(char* pBuffer,WORD wVal){*(WORD*)(pBuffer) = wVal;};
		inline void PutDWORD(char* pBuffer,DWORD dwVal){*(DWORD*)(pBuffer) = dwVal;};
		inline void PutSTR(char* pBuffer,char* pStr,int iSize){memcpy(pBuffer,pStr,iSize);};
		//Get memory
		inline BYTE GetBYTE(char* pBuffer){return *(BYTE*)(pBuffer);};
		inline WORD GetWORD(char* pBuffer){ return *(WORD*)(pBuffer);};
		inline DWORD GetDWORD(char* pBuffer){return *(DWORD*)(pBuffer);};
		inline void GetSTR(char* sBuffer,char* dBuffer,int iSize){memcpy(dBuffer,sBuffer,iSize);};
		//Default
		CPacket(){iSendCount = 0; bFuncIndex = -1;};
};

class CArea{
	private:
		DWORD dwLastNearstBase;
	public:
		//General
		int GetUPCCount();
		int GetNPCCount();
		inline int GetAllCount(){return (GetUPCCount() + GetNPCCount());};
		DWORD GetUPCBase(WORD wID);
		DWORD GetNPCBase(WORD wID);
		DWORD GetCorpseBase(WORD wID);
		DWORD GetAnyBase(WORD wID);
		DWORD GetZEnemyBase();
		DWORD GetNPCByName(int iNameCount, char* ptrName[], char* sName,bool bNearst, bool bEnemy,bool bAlive, FLOAT fMaxDist, bool bLoop);
		DWORD GetUPCByName(int iNameCount, char* ptrName[], char* sName, bool bAlive, FLOAT fMaxDist);
		void SelectObject(CCharBase Object);
		//Default
		CArea(){dwLastNearstBase = 0;};
};

class CMath{
	public:
		//General
		inline FLOAT fDist(FLOAT X1, FLOAT Y1, FLOAT X2, FLOAT Y2);
		inline int iPerc(int HiVal, int LoVal){return 100 / (HiVal / LoVal);};
		//Default
		CMath(){};
};

class CCast{
	public:
		//General
		int CastCount();
		int CastNum(int iNo);
		int MakeCastNum(CCharBase dwBase, char* strTail);
		bool IsCasted(int Num);
		//Default
		CCast(){};

};

class CInvSlot{
	private:
		DWORD dwBase;
		int iCurrentSlot;
	public:
		//General
		inline int GetCurrentSlot(){return iCurrentSlot;};
		void SelectSlot(int iSlot);
		void SelectLeft();
		void SelectRight();
		inline DWORD GetBase(){return dwBase;};
		inline int dwItemNum(){return *(DWORD*)(*(DWORD*)(dwBase + 0x38)) + *(DWORD*)(*(DWORD*)(dwBase + 0x3C));};
		inline int iItemN(){return *(DWORD*)(dwBase + 0x40);};
		inline int iItemDur(){return *(DWORD*)(dwBase + 0x44);};
		inline char* strItemName(){return (LPSTR)(*(DWORD*)(*(DWORD*)(dwBase + 0x38) + 0xC));};
		inline bool IsFree(){if(dwBase) return false; else return true;};
		//Default
		CInvSlot(int iSlot);
		CInvSlot(){dwBase = 0; iCurrentSlot = -1;};
};

class CInnSlot{
	private:
		DWORD dwBase;
		int iCurrentSlot;
	public:
		//General
		inline int GetCurrentSlot(){return iCurrentSlot;};
		void SelectSlot(int iSlot);
		inline DWORD GetBase(){return dwBase;};
		inline int dwItemNum(){return *(DWORD*)(*(DWORD*)(dwBase + 0x38)) + *(DWORD*)(*(DWORD*)(dwBase + 0x3C));};
		inline int iItemN(){return *(DWORD*)(dwBase + 0x40);};
		inline int iItemDur(){return *(DWORD*)(dwBase + 0x44);};
		inline char* strItemName(){return (LPSTR)(*(DWORD*)(*(DWORD*)(dwBase + 0x38) + 0xC));};
		inline bool IsFree(){if(dwBase) return false; else return true;};
		//Default
		CInnSlot(int iSlot);
		CInnSlot(){dwBase = 0; iCurrentSlot = -1;};
};

class CBag{
	public:
		//General
		inline void SlotToPaged(int iSlot, int &outPage, int &outSlot){outPage = iSlot / iMaxInnPageSlot; outSlot = iSlot % iMaxInnPageSlot;};
		inline int PagedToSlot(int iPage, int iSlot){return (iPage * iMaxInnPageSlot) + iSlot;};
		//Inventory
		int FindInvItem(int iBegin, int dwNum);
		int FindFreeInvSlot(int iBegin);
		//Inn
		int FindInnItem(int iBegin, int dwNum);
		int FindFreeInnSlot(int iBegin);
		//Default
		CBag(){};
};

class CTrap{
	private:
		HANDLE hThread;
		DWORD dwThread;
		bool bState;

		inline static void _StartThread(void* param){((CTrap*)param)->Function();};
		void Function();
	public:
		//General
		inline bool IsSwitched(){return bState;};
		bool Switch(bool bOnOff);
		//Default
		CTrap(){bState = false;};
};

class CParty{
	private:
		int iCount;
		DWORD dwUser[8];
	public:
		//General
		void Refresh();
		inline DWORD GetUser(int iIndex){return dwUser[iIndex];};
		inline int GetCount(){return iCount;};
		//Default
		CParty(){iCount = 0;};
};

class CRecvFunction{
	private:
		BYTE bFuncIndex;
		HANDLE hMailSlot;
		HANDLE hThread;
		DWORD dwThread;
		LPVOID lFuncAdr;
		DWORD dwOldAdr;
		bool bState;
		bool bPaused;

		inline static void _StartThread(void* param){((CRecvFunction*)param)->ExecuteMessages();};
		void ExecuteMessages();
		//Message Functions
		void Exec_ChestDrop(char* pBuf);
		void Exec_ItemDrop(char* pBuf);
		void Exec_Chat(char* pBuf);
		void Exec_PartyRecv(char* pBuf);

		//Message Variables
		int iLastChestX;
		int iLastChestY;
		DWORD dwLastChestID;

	public:
		//General
		BYTE GetIndex();
		inline bool GetState(){return bState;};
		bool StartFunction();
		void StopFunction();
		void Pause(){bPaused=true;};
		void Resume(){bPaused=false;};
		//Message Variables
		bool bOnLootWay;
		//Default
		CRecvFunction(){bFuncIndex = -1; hMailSlot = 0; lFuncAdr = 0; bState = false; bPaused = false; bOnLootWay = false;};
};

class CTest{
	public:

	float GetPosZ(float fPosX, float fPosY);
	void InitPos(float fPosX, float fPosY, float fPosZ);

	CTest(){};
};

////////////////////////////////////////
//***** GLOBAL CLASS DEFINITIONS *****//
////////////////////////////////////////

extern CGeneral			_CGeneral;
extern CCharBase		_CCharBase;
extern CPacket			_CPacket;
extern CArea			_CArea;
extern CMath			_CMath;
extern CCast			_CCast;
extern CBag				_CBag;
extern CTrap			_CTrap;
extern CParty			_CParty;
extern CRecvFunction	_CRecvFunction;
extern CTest			_CTest;
//---------------------------------------------------------------------------
#endif

```

`Super People Full/Super People Final/Super People Speed/MainForm.cpp`:

```cpp
//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "MainForm.h"
#include "Main.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;
HANDLE hSHThread(0);
DWORD dwSHThread(0);
//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
	: TForm(Owner)
{
}
void __fastcall TForm1::FormShow(TObject *Sender)
{
	_CCharBase = *(DWORD*)(KO_CHAR);

}
void __fastcall TForm1::chenabledClick(TObject *Sender)
{
	if(chenabled->Checked)
	{
		hSHThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)SHFunction,NULL,0,&dwSHThread);
	}
	else
	{
		TerminateThread(hSHThread,0);
		CloseHandle(hSHThread);
		hSHThread = 0;
		dwSHThread = 0;
    }
}
//---------------------------------------------------------------------------

void SHFunction()
{
int iBoost = atoi(Form1->txtboost->Text.c_str());
int iSleep = atoi(Form1->txtdelay->Text.c_str());

bool bArrivedX = false, bArrivedY = false;

float fCurX,fCurY;
float fPtrX,fPtrY;
float fNewX,fNewY,fNewZ;

DWORD dwTmpVal;

char pBuf[10];	//packet

_CPacket.PutBYTE(pBuf,0x06);
_CPacket.PutWORD(pBuf+7,0x2D);
_CPacket.PutBYTE(pBuf+9,0x00);

LOOP:

if(!GetAsyncKeyState(0xA0))
	goto RETN;

fCurX = _CCharBase.GetFLOAT(KO_POSX);
fCurY = _CCharBase.GetFLOAT(KO_POSY);

fPtrX = _CCharBase.GetFLOAT(KO_PTRX);
fPtrY = _CCharBase.GetFLOAT(KO_PTRY);


if(_CMath.fDist(fCurX,fCurY,fPtrX,fPtrY) > 0.5){

	////////////error handling (test)/////////////
	dwTmpVal = *(DWORD*)(0xC26C30);
	dwTmpVal = *(DWORD*)(dwTmpVal + 0x1C);
	dwTmpVal = *(DWORD*)(dwTmpVal + 0x48);
	if(dwTmpVal){
		dwTmpVal = *(DWORD*)(dwTmpVal + 0x48);
		dwTmpVal = *(DWORD*)(dwTmpVal);
		dwTmpVal = *(DWORD*)(dwTmpVal + 0x8);
		if(!dwTmpVal)
			goto RETN;
	}
	//////////////////////////////////////////////

	if(fCurX != fPtrX){
		bArrivedX = false;
		if(fCurX > fPtrX){
			if(fCurX - fPtrX >= (float)iBoost)
				fNewX = fCurX - (float)iBoost;
			else
				fNewX = fPtrX;
		}
		else
		{
			if(fPtrX - fCurX >= (float)iBoost)
				fNewX = fCurX + (float)iBoost;
			else
				fNewX = fPtrX;
		}
	}else bArrivedX = true;

	if(fCurY != fPtrY){
		bArrivedY = false;
		if(fCurY > fPtrY){
			if(fCurY - fPtrY >= (float)iBoost)
				fNewY = fCurY - (float)iBoost;
			else
				fNewY = fPtrY;
		}
		else
		{
			if(fPtrY - fCurY >= (float)iBoost)
				fNewY = fCurY + (float)iBoost;
			else
				fNewY = fPtrY;
		}
	}else bArrivedY = true;

	fNewZ = _CTest.GetPosZ(fNewX,fNewY);
	_CTest.InitPos(fNewX,fNewY,fNewZ);

	_CPacket.PutWORD(pBuf+1,(int)(_CCharBase.GetFLOAT(KO_POSX)) * 10);
	_CPacket.PutWORD(pBuf+3,(int)(_CCharBase.GetFLOAT(KO_POSY)) * 10);
	_CPacket.PutWORD(pBuf+5,(int)(_CCharBase.GetFLOAT(KO_POSZ)) * 10);
	_CPacket.PutWORD(pBuf+7,0x2D);

	if(*(pBuf+9) == 0){
		*(pBuf+9) = 1;	//start
	}
	else if(*(pBuf+9) == 1){
		*(pBuf+9) = 3;	//moving
	}
	else if(*(pBuf+9) == 3 && bArrivedX && bArrivedY){
		*(pBuf+9) = 0;	//stop
		_CPacket.PutWORD(pBuf+7,0x00);
	}

	_CPacket.PSend(pBuf,10);

}
else{
	if(*(pBuf+9) == 3){
		*(pBuf+9) = 0;	//stop
		_CPacket.PutWORD(pBuf+7,0x00);
		_CPacket.PutWORD(pBuf+1,(int)(_CCharBase.GetFLOAT(KO_POSX)) * 10);
		_CPacket.PutWORD(pBuf+3,(int)(_CCharBase.GetFLOAT(KO_POSY)) * 10);
		_CPacket.PutWORD(pBuf+5,(int)(_CCharBase.GetFLOAT(KO_POSZ)) * 10);
		_CPacket.PSend(pBuf,10);
	}
}

RETN:
Sleep(iSleep);
goto LOOP;
}


void __fastcall TForm1::chwhClick(TObject *Sender)
{
	_CCharBase.SetDWORD(KO_AUTH,!chwh->Checked);
}
//---------------------------------------------------------------------------


```

`Super People Full/Super People Final/Super People Speed/MainForm.dfm`:

```dfm
object Form1: TForm1
  Left = 0
  Top = 0
  BorderIcons = [biSystemMenu, biMinimize]
  BorderStyle = bsSingle
  Caption = 'kojd'
  ClientHeight = 97
  ClientWidth = 130
  Color = clBtnFace
  Font.Charset = DEFAULT_CHARSET
  Font.Color = clWindowText
  Font.Height = -11
  Font.Name = 'Tahoma'
  Font.Style = []
  OldCreateOrder = False
  OnShow = FormShow
  PixelsPerInch = 96
  TextHeight = 13
  object Label1: TLabel
    Left = 8
    Top = 8
    Width = 31
    Height = 13
    Caption = 'boost:'
  end
  object Label2: TLabel
    Left = 8
    Top = 27
    Width = 30
    Height = 13
    Caption = 'delay:'
  end
  object Label3: TLabel
    Left = 75
    Top = 31
    Width = 52
    Height = 13
    Caption = '[50 ~ 100]'
    Font.Charset = DEFAULT_CHARSET
    Font.Color = clRed
    Font.Height = -11
    Font.Name = 'Tahoma'
    Font.Style = []
    ParentFont = False
  end
  object Label4: TLabel
    Left = 75
    Top = 8
    Width = 40
    Height = 13
    Caption = '[5 ~ 10]'
    Font.Charset = DEFAULT_CHARSET
    Font.Color = clRed
    Font.Height = -11
    Font.Name = 'Tahoma'
    Font.Style = []
    ParentFont = False
  end
  object txtboost: TEdit
    Left = 44
    Top = 8
    Width = 25
    Height = 21
    TabOrder = 0
    Text = '5'
  end
  object txtdelay: TEdit
    Left = 44
    Top = 27
    Width = 25
    Height = 21
    TabOrder = 1
    Text = '50'
  end
  object chwh: TCheckBox
    Left = 8
    Top = 50
    Width = 61
    Height = 17
    Caption = 'wallhack'
    TabOrder = 2
    OnClick = chwhClick
  end
  object chenabled: TCheckBox
    Left = 8
    Top = 73
    Width = 65
    Height = 17
    Caption = 'enabled'
    Font.Charset = DEFAULT_CHARSET
    Font.Color = clWindowText
    Font.Height = -11
    Font.Name = 'Tahoma'
    Font.Style = [fsBold]
    ParentFont = False
    TabOrder = 3
    OnClick = chenabledClick
  end
end

```

`Super People Full/Super People Final/Super People Speed/MainForm.h`:

```h
//---------------------------------------------------------------------------

#ifndef MainFormH
#define MainFormH
//---------------------------------------------------------------------------
#include <Classes.hpp>
#include <Controls.hpp>
#include <StdCtrls.hpp>
#include <Forms.hpp>
#include <ComCtrls.hpp>
#include <ExtCtrls.hpp>

void SHFunction();
extern HANDLE hSHThread;
extern DWORD dwSHThread;
extern bool bSH;
//--------------------------------------------------------------------------

class TForm1 : public TForm
{
__published:	// IDE-managed Components
	TLabel *Label1;
	TLabel *Label2;
	TEdit *txtboost;
	TEdit *txtdelay;
	TCheckBox *chwh;
	TLabel *Label3;
	TLabel *Label4;
	TCheckBox *chenabled;
	void __fastcall FormShow(TObject *Sender);
	void __fastcall chenabledClick(TObject *Sender);
	void __fastcall chwhClick(TObject *Sender);
private:	// User declarations
public:		// User declarations
	__fastcall TForm1(TComponent* Owner);
};
//---------------------------------------------------------------------------
extern PACKAGE TForm1 *Form1;
//---------------------------------------------------------------------------
#endif

```

`Super People Full/Super People Final/Super People Speed/Memory.h`:

```h
#ifndef MemoryH
#define MemoryH

#include <Classes.hpp>

const DWORD KO_CHAR	=	0xC26C38;
const DWORD KO_DLGA = 	0xC26F2C;
const DWORD KO_SOCK = 	0xC26EF8;
const DWORD KO_SNDF = 	0x474E90;
const DWORD KO_SDFX = 	0xC1C358;
const DWORD KO_RCVA	=	0x9C6F78;
const DWORD KO_RCVB	=	0x7FDC10;
const DWORD KO_KEYB = 	0xC26EF4;
const DWORD KO_PRTY = 	0xC26F18;
const DWORD KO_NMSG = 	0xC1F298;
const DWORD KO_AREA = 	0xC26C34;
const DWORD KO_FPOZ = 	0x4A7E50;
const DWORD KO_SETM = 	0x8289B0;
const DWORD KO_FNCZ = 	0x827EE0;
const DWORD KO_CRYP = 	0x473830;
const DWORD KO_INDX =	0x473230;
const DWORD KO_WNDA = 	0xA62088;
const DWORD KO_FPBS = 	0x4993F0;
const DWORD KO_FMBS = 	0x499470;
const DWORD KO_RCFX = 	0xC26FB0;
const DWORD KO_NXTP = 	0x49E1D0;
const DWORD KO_NXTM = 	0x49E120;
const DWORD KO_MSBX = 	0x914DD0;
const DWORD KO_MSOP = 	0x5E5630;
const DWORD KO_DISC = 	0x4743C0;
const DWORD KO_CONN = 	0x4744A0;
const DWORD KO_SCK2 = 	0xAB2660;
const DWORD KO_THRD =	0xC26FB4;
const DWORD KO_PFIX =	KO_SOCK+0xC1;
const DWORD KO_ITPA =	0xC26AAC;
const DWORD KO_ITPB =	0xC26AB0;
const DWORD KO_ITCA =	0x478E60;
const DWORD KO_ITCB =	0x478ED0;
const DWORD KO_NPCB =	0x5DADC0;
const DWORD KO_ISEN =	0x49AB60;

const DWORD KO_NICK = 	0x5BC;
const DWORD KO_LEVL = 	0x5DC;
const DWORD KO_CLSS = 	0x5D8;
const DWORD KO_MYID = 	0x5B4;
const DWORD KO_TGID = 	0x580;
const DWORD KO_VELO = 	0x680;
const DWORD KO_AUTH =	0x5E8;
const DWORD KO_CRHP = 	0x5E4;
const DWORD KO_MXHP = 	0x5E0;
const DWORD KO_CRMP =	0x9A8;
const DWORD KO_MXMP = 	0x9A4;
const DWORD KO_CRXP = 	0x9C0;
const DWORD KO_MXXP = 	0x9B8;
const DWORD KO_POSX = 	0xB4;
const DWORD KO_POSY = 	0xBC;
const DWORD KO_POSZ = 	0xB8;
const DWORD KO_COIN = 	0x810;
const DWORD KO_VISB = 	0x514;
const DWORD KO_NATN = 	0x5D0;
const DWORD KO_PTRX = 	0xD44;
const DWORD KO_PTRY = 	0xD4C;
const DWORD KO_PTRZ = 	0xD48;
const DWORD KO_MOV1 = 	0xD38;
const DWORD KO_MOV2 = 	0x394;
const DWORD KO_SIZE = 	0x3F0;

const DWORD KO_PT_ID	=	0x8;
const DWORD KO_PT_HP  	=	0x14;
const DWORD KO_PT_MAXHP	=	0x18;
const DWORD KO_PT_MP  	=	0x1C;
const DWORD KO_PT_MAXMP	=	0x20;
const DWORD KO_PT_LVL 	=	0xC;
const DWORD KO_PT_CLASS	=	0x10;

const DWORD DLG_OFF1	=	0x1B0;
const DWORD DLG_OFF2	=	0x1B8;
const DWORD DLG_OFF3	=	0x1A0;
const DWORD DLG_OFF4	=	0x1EC;
const DWORD PTY_OFF5	=	0x1CC;

#endif


```

`Super People Full/Super People Final/Super People Speed/Project1.cbproj`:

```cbproj
	<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
		<PropertyGroup>
			<ProjectGuid>{B7F6B0A1-FBA6-4A03-8BF9-106FC6AC8C7D}</ProjectGuid>
			<ProjectVersion>12.0</ProjectVersion>
			<Config Condition="'$(Config)'==''">Release</Config>
		</PropertyGroup>
		<PropertyGroup Condition="'$(Config)'=='Base' or '$(Base)'!=''">
			<Base>true</Base>
		</PropertyGroup>
		<PropertyGroup Condition="'$(Config)'=='Debug' or '$(Cfg_1)'!=''">
			<Cfg_1>true</Cfg_1>
			<CfgParent>Base</CfgParent>
			<Base>true</Base>
		</PropertyGroup>
		<PropertyGroup Condition="'$(Config)'=='Release' or '$(Cfg_2)'!=''">
			<Cfg_2>true</Cfg_2>
			<CfgParent>Base</CfgParent>
			<Base>true</Base>
		</PropertyGroup>
		<PropertyGroup Condition="'$(Base)'!=''">
			<BCC_CallingConvention>stdcall</BCC_CallingConvention>
			<ProjectType>CppDynamicLibrary</ProjectType>
			<LinkPackageStatics>rtl.lib;vcl.lib</LinkPackageStatics>
			<PackageImports>vclx.bpi;vcl.bpi;dbrtl.bpi;Rave76VCL.bpi;bdertl.bpi;rtl.bpi;bcbie.bpi;vclactnband.bpi;xmlrtl.bpi;bcbsmp.bpi;vcldb.bpi;vcldbx.bpi;dsnap.bpi;dsnapcon.bpi;TeeUI.bpi;TeeDB.bpi;Tee.bpi;adortl.bpi;vclib.bpi;ibxpress.bpi;IndyCore.bpi;IndySystem.bpi;IndyProtocols.bpi;inet.bpi;intrawebdb_100_120.bpi;Intraweb_100_120.bpi;vclie.bpi;websnap.bpi;webdsnap.bpi;inetdbbde.bpi;inetdbxpress.bpi;soaprtl.bpi;vclribbon.bpi;dbexpress.bpi;DbxCommonDriver.bpi;DataSnapIndy10ServerTransport.bpi;DataSnapProviderClient.bpi;DataSnapServer.bpi;DbxClientDriver.bpi;DBXInterBaseDriver.bpi;DBXMySQLDriver.bpi;dbxcds.bpi;DBXSybaseASEDriver.bpi;DBXSybaseASADriver.bpi;DBXOracleDriver.bpi;DBXMSSQLDriver.bpi;DBXInformixDriver.bpi;DBXDb2Driver.bpi</PackageImports>
			<Multithreaded>true</Multithreaded>
			<AllPackageLibs>rtl.lib;vcl.lib</AllPackageLibs>
			<OutputExt>dll</OutputExt>
			<ILINK_GenerateImportLibrary>true</ILINK_GenerateImportLibrary>
			<DCC_CBuilderOutput>JPHNE</DCC_CBuilderOutput>
			<Defines>NO_STRICT</Defines>
			<IncludePath>..\..\..\Desktop\Melihh\projelerim\C++\dll test;$(CG_BOOST_ROOT)\boost\tr1\tr1;$(BDS)\include;$(BDS)\include\dinkumware;$(BDS)\include\vcl;$(CG_BOOST_ROOT)</IncludePath>
			<ILINK_LibraryPath>..\..\..\Desktop\Melihh\projelerim\C++\dll test;$(BDS)\lib;$(BDS)\lib\obj;$(BDS)\lib\psdk</ILINK_LibraryPath>
			<BCC_wpar>false</BCC_wpar>
			<BCC_OptimizeForSpeed>true</BCC_OptimizeForSpeed>
		</PropertyGroup>
		<PropertyGroup Condition="'$(Cfg_1)'!=''">
			<BCC_OptimizeForSpeed>false</BCC_OptimizeForSpeed>
			<BCC_DisableOptimizations>true</BCC_DisableOptimizations>
			<DCC_Optimize>false</DCC_Optimize>
			<DCC_DebugInfoInExe>true</DCC_DebugInfoInExe>
			<Defines>_DEBUG;$(Defines)</Defines>
			<BCC_InlineFunctionExpansion>false</BCC_InlineFunctionExpansion>
			<IntermediateOutputDir>Debug</IntermediateOutputDir>
			<ILINK_DisableIncrementalLinking>true</ILINK_DisableIncrementalLinking>
			<BCC_UseRegisterVariables>None</BCC_UseRegisterVariables>
			<DCC_Define>DEBUG</DCC_Define>
			<BCC_DebugLineNumbers>true</BCC_DebugLineNumbers>
			<TASM_DisplaySourceLines>true</TASM_DisplaySourceLines>
			<BCC_StackFrames>true</BCC_StackFrames>
			<ILINK_LibraryPath>$(BDS)\lib\debug;$(ILINK_LibraryPath)</ILINK_LibraryPath>
			<ILINK_FullDebugInfo>true</ILINK_FullDebugInfo>
			<TASM_Debugging>Full</TASM_Debugging>
			<BCC_SourceDebuggingOn>true</BCC_SourceDebuggingOn>
		</PropertyGroup>
		<PropertyGroup Condition="'$(Cfg_2)'!=''">
			<Defines>NDEBUG;$(Defines)</Defines>
			<IntermediateOutputDir>Release</IntermediateOutputDir>
			<ILINK_LibraryPath>$(BDS)\lib\release;$(ILINK_LibraryPath)</ILINK_LibraryPath>
			<TASM_Debugging>None</TASM_Debugging>
		</PropertyGroup>
		<ItemGroup>
			<CppCompile Include="Main.cpp">
				<DependentOn>Main.h</DependentOn>
				<BuildOrder>2</BuildOrder>
			</CppCompile>
			<None Include="Memory.h">
				<BuildOrder>3</BuildOrder>
			</None>
			<CppCompile Include="DllMain.cpp">
				<BuildOrder>0</BuildOrder>
			</CppCompile>
			<CppCompile Include="MainForm.cpp">
				<Form>Form1</Form>
				<DependentOn>MainForm.h</DependentOn>
				<BuildOrder>1</BuildOrder>
			</CppCompile>
			<FormResources Include="MainForm.dfm"/>
			<BuildConfiguration Include="Base">
				<Key>Base</Key>
			</BuildConfiguration>
			<BuildConfiguration Include="Release">
				<Key>Cfg_2</Key>
				<CfgParent>Base</CfgParent>
			</BuildConfiguration>
			<BuildConfiguration Include="Debug">
				<Key>Cfg_1</Key>
				<CfgParent>Base</CfgParent>
			</BuildConfiguration>
		</ItemGroup>
		<Import Project="$(BDS)\Bin\CodeGear.Cpp.Targets" Condition="Exists('$(BDS)\Bin\CodeGear.Cpp.Targets')"/>
		<ProjectExtensions>
			<Borland.Personality>CPlusPlusBuilder.Personality.12</Borland.Personality>
			<Borland.ProjectType>CppDynamicLibrary</Borland.ProjectType>
			<BorlandProject>
				<CPlusPlusBuilder.Personality>
					<VersionInfo>
						<VersionInfo Name="IncludeVerInfo">False</VersionInfo>
						<VersionInfo Name="AutoIncBuild">False</VersionInfo>
						<VersionInfo Name="MajorVer">1</VersionInfo>
						<VersionInfo Name="MinorVer">0</VersionInfo>
						<VersionInfo Name="Release">0</VersionInfo>
						<VersionInfo Name="Build">0</VersionInfo>
						<VersionInfo Name="Debug">False</VersionInfo>
						<VersionInfo Name="PreRelease">False</VersionInfo>
						<VersionInfo Name="Special">False</VersionInfo>
						<VersionInfo Name="Private">False</VersionInfo>
						<VersionInfo Name="DLL">False</VersionInfo>
						<VersionInfo Name="Locale">1055</VersionInfo>
						<VersionInfo Name="CodePage">1254</VersionInfo>
					</VersionInfo>
					<VersionInfoKeys>
						<VersionInfoKeys Name="CompanyName"/>
						<VersionInfoKeys Name="FileDescription"/>
						<VersionInfoKeys Name="FileVersion">1.0.0.0</VersionInfoKeys>
						<VersionInfoKeys Name="InternalName"/>
						<VersionInfoKeys Name="LegalCopyright"/>
						<VersionInfoKeys Name="LegalTrademarks"/>
						<VersionInfoKeys Name="OriginalFilename"/>
						<VersionInfoKeys Name="ProductName"/>
						<VersionInfoKeys Name="ProductVersion">1.0.0.0</VersionInfoKeys>
						<VersionInfoKeys Name="Comments"/>
					</VersionInfoKeys>
					<Debugging>
						<Debugging Name="DebugSourceDirs"/>
					</Debugging>
					<Parameters>
						<Parameters Name="RunParams"/>
						<Parameters Name="Launcher"/>
						<Parameters Name="UseLauncher">False</Parameters>
						<Parameters Name="DebugCWD"/>
						<Parameters Name="HostApplication"/>
						<Parameters Name="RemoteHost"/>
						<Parameters Name="RemotePath"/>
						<Parameters Name="RemoteParams"/>
						<Parameters Name="RemoteLauncher"/>
						<Parameters Name="UseRemoteLauncher">False</Parameters>
						<Parameters Name="RemoteCWD"/>
						<Parameters Name="RemoteDebug">False</Parameters>
						<Parameters Name="Debug Symbols Search Path"/>
						<Parameters Name="LoadAllSymbols">True</Parameters>
						<Parameters Name="LoadUnspecifiedSymbols">False</Parameters>
					</Parameters>
					<ProjectProperties>
						<ProjectProperties Name="AutoShowDeps">False</ProjectProperties>
						<ProjectProperties Name="ManagePaths">True</ProjectProperties>
						<ProjectProperties Name="VerifyPackages">True</ProjectProperties>
					</ProjectProperties>
					<Excluded_Packages>
						<Excluded_Packages Name="$(BDS)\bin\bcboffice2k120.bpl">CodeGear C++Builder Office 2000 Servers Package</Excluded_Packages>
						<Excluded_Packages Name="$(BDS)\bin\bcbofficexp120.bpl">CodeGear C++Builder Office XP Servers Package</Excluded_Packages>
					</Excluded_Packages>
				</CPlusPlusBuilder.Personality>
			</BorlandProject>
			<ProjectFileVersion>12</ProjectFileVersion>
		</ProjectExtensions>
	</Project>

```

`Super People Full/Super People Final/Super People Speed/Project1.cbproj.local`:

```local
<?xml version="1.0" encoding="utf-8"?>
<BorlandProject>
	<Transactions>
    <Transaction>2010.11.26 14:37:28.031.cpp,C:\Documents and Settings\Melih\Desktop\Melihh\projelerim\C++\new\Unit1.cpp=C:\Documents and Settings\Melih\Desktop\Melihh\projelerim\C++\new\Main.cpp</Transaction>
    <Transaction>2010.11.26 14:37:28.031.h,C:\Documents and Settings\Melih\Desktop\Melihh\projelerim\C++\new\Unit1.h=C:\Documents and Settings\Melih\Desktop\Melihh\projelerim\C++\new\Main.h</Transaction>
    <Transaction>2010.11.26 15:16:59.546.h,C:\Documents and Settings\Melih\Desktop\Melihh\projelerim\C++\new\File1.h=C:\Documents and Settings\Melih\Desktop\Melihh\projelerim\C++\new\Memory.h</Transaction>
  </Transactions>
</BorlandProject>

```