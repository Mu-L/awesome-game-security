Project Path: arc_gmh5225_UE-Plugin-SCUE4-Plugin_dzgn9sdb

Source Tree:

```txt
arc_gmh5225_UE-Plugin-SCUE4-Plugin_dzgn9sdb
├── LICENSE
├── LICENSE.txt
├── Plugins
│   └── SCUE4
│       ├── Config
│       │   └── FilterPlugin.ini
│       ├── Content
│       │   └── Icons
│       │       ├── Bool_16x.png
│       │       ├── Byte_16x.png
│       │       ├── Color_16x.png
│       │       ├── Float_16x.png
│       │       ├── Int_16x.png
│       │       ├── Name_16x.png
│       │       ├── Rotator_16x.png
│       │       ├── SCUE4_128x.png
│       │       ├── String_16x.png
│       │       ├── Text_16x.png
│       │       ├── Transform_16x.png
│       │       └── Vector_16x.png
│       ├── Resources
│       │   └── Icon128.png
│       ├── SCUE4.uplugin
│       └── Source
│           ├── SCUE4
│           │   ├── Private
│           │   │   ├── Blueprints
│           │   │   │   ├── SCLibrary.cpp
│           │   │   │   └── SCLibrary.h
│           │   │   ├── ISCUE4.cpp
│           │   │   ├── SCUE4.cpp
│           │   │   └── SCUE4PrivatePCH.h
│           │   ├── Public
│           │   │   ├── ISCUE4.h
│           │   │   └── SCUE4.h
│           │   └── SCUE4.Build.cs
│           ├── Settings
│           │   ├── Private
│           │   │   ├── SCUE4Commands.cpp
│           │   │   ├── SCUE4Editor.cpp
│           │   │   ├── SCUE4EditorPrivatePCH.h
│           │   │   └── SCUE4EditorStyle.cpp
│           │   ├── Public
│           │   │   ├── SCUE4Editor.h
│           │   │   ├── SCUE4EditorCommands.h
│           │   │   └── SCUE4EditorStyle.h
│           │   └── SCUE4Editor.Build.cs
│           └── ThirdParty
│               ├── SCUE4X.Build.cs
│               └── SCUE4_Key-Generator.exe
└── README.md

```

`LICENSE`:

```
AS OF DECEMBER 21st 2016

THIS SYSTEM IS NOW PUBLISH ON UNREAL ENGINE's MARKETPLACE
AND THE SAME THERMS FROM THEM APPLIES HERE.

Please check Epic Games' therms here:
https://publish.unrealengine.com/faq


Unreal Marketplace page:
https://www.unrealengine.com/marketplace/scue4-anti-cheat-solution
```

`LICENSE.txt`:

```txt
AS OF DECEMBER 21st 2016

THIS SYSTEM IS NOW PUBLISHED ON UNREAL ENGINE's MARKETPLACE
AND THE SAME THERMS FROM THEM APPLIES HERE.

Please check Epic Games' therms here:
https://publish.unrealengine.com/faq


Unreal Marketplace page:
<<<<<<< HEAD
https://www.unrealengine.com/marketplace/scue4-anti-cheat-solution
=======
https://www.unrealengine.com/marketplace/scue4-anti-cheat-solution
>>>>>>> origin/master

```

`Plugins/SCUE4/Config/FilterPlugin.ini`:

```ini
[FilterPlugin]
Source/ThirdParty/*.exe
Source/ThirdParty/x64/*.*
Source/ThirdParty/x86/*.*
```

`Plugins/SCUE4/SCUE4.uplugin`:

```uplugin
{
	"FileVersion": 1,
	"Version": 1,
	"VersionName": "2.0.3",
	"EngineVersion" : "4.26.0",
	"FriendlyName": "Secure-Client UE4",
	"Description": "Secure-Client is an Encryption Plugin, a C++ system designed to provide intuitive anti-cheat capability for PC Games developed on Unreal Engine 4.",
	"Category": "SYNAPTECH",
	"CreatedBy": "(C) Bruno Xavier Leite",
	"CreatedByURL": "https://brunoxavierleite.wordpress.com",
	"DocsURL": "https://forums.unrealengine.com/showthread.php?97229-Plugin-Anti-Cheat-System",
	"MarketplaceURL": "com.epicgames.launcher://ue/marketplace/content/cff7ca410375488fb0d13221b7446041",
	"SupportURL": "mailto:bruno_xavier_@msn.com",
	"CanContainContent": false,
	"EnabledByDefault": true,
	"IsBetaVersion": false,
	"Installed": true,
	"Modules": [
		{
			"Name": "SCUE4",
			"Type": "Runtime",
			"LoadingPhase": "PreDefault",
			"WhitelistPlatforms": [
				"Win64",
				"Win32"
			]
		},
		{
			"Name": "SCUE4Editor",
			"Type": "Editor",
			"LoadingPhase": "PostEngineInit",
			"WhitelistPlatforms": [
				"Win64"
			]
		}
	]
}
```

`Plugins/SCUE4/Source/SCUE4/Private/Blueprints/SCLibrary.cpp`:

```cpp
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//		Copyright 2016 (C) Bruno Xavier B. Leite
//////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "SCLibrary.h"
#include "SCUE4PrivatePCH.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

FString USCLibrary::SCL_Callable_GetRawSafeBool(FSafeBool &SB) {
	return SB.GetRaw();
}

bool USCLibrary::SCL_Pure_GetSafeBool(FSafeBool &SB) {
	return SB.GetValue();
}

bool USCLibrary::SCL_Pure_GetSafeBoolWithKey(FSafeBool &SB, FString Key) {
	return SB.GetValue(Key);
}

bool USCLibrary::SCL_Callable_GetSafeBool(FSafeBool &SB) {
	return SB.GetValue();
}

bool USCLibrary::SCL_Callable_GetSafeBoolWithKey(FSafeBool &SB, FString Key) {
	return SB.GetValue(Key);
}

//

bool USCLibrary::SCL_Callable_SetRawSafeBool(FSafeBool &SB, FString Value) {
	SB.SetRaw(&Value); return SB.GetValue();
}

bool USCLibrary::SCL_Pure_SetSafeBool(FSafeBool &SB, const bool Value) {
	SB.SetValue(Value); return SB.GetValue();
}

bool USCLibrary::SCL_Pure_SetSafeBoolWithKey(FSafeBool &SB, FString Key, const bool Value) {
	SB.SetValue(Key,Value); return SB.GetValue();
}

bool USCLibrary::SCL_Callable_SetSafeBool(FSafeBool &SB, const bool Value) {
	SB.SetValue(Value); return SB.GetValue();
}

bool USCLibrary::SCL_Callable_SetSafeBoolWithKey(FSafeBool &SB, FString Key, const bool Value) {
	SB.SetValue(Key,Value); return SB.GetValue();
}

//

FString USCLibrary::SCL_Callable_GetRawSafeInt(FSafeInt &SI) {
	return SI.GetRaw();
}

int32 USCLibrary::SCL_Pure_GetSafeInt(FSafeInt &SI) {
	return SI.GetValue();
}

int32 USCLibrary::SCL_Pure_GetSafeIntWithKey(FSafeInt &SI, FString Key) {
	return SI.GetValue(Key);
}

int32 USCLibrary::SCL_Callable_GetSafeInt(FSafeInt &SI) {
	return SI.GetValue();
}

int32 USCLibrary::SCL_Callable_GetSafeIntWithKey(FSafeInt &SI, FString Key) {
	return SI.GetValue(Key);
}

//

int32 USCLibrary::SCL_Callable_SetRawSafeInt(FSafeInt &SI, FString Value) {
	SI.SetRaw(&Value); return SI.GetValue();
}

int32 USCLibrary::SCL_Pure_SetSafeInt(FSafeInt &SI, const int32 Value) {
	SI.SetValue(Value); return SI.GetValue();
}

int32 USCLibrary::SCL_Pure_SetSafeIntWithKey(FSafeInt &SI, FString Key, const int32 Value) {
	SI.SetValue(Key,Value); return SI.GetValue(Key);
}

int32 USCLibrary::SCL_Callable_SetSafeInt(FSafeInt &SI, const int32 Value) {
	SI.SetValue(Value); return SI.GetValue();
}

int32 USCLibrary::SCL_Callable_SetSafeIntWithKey(FSafeInt &SI, FString Key, const int32 Value) {
	SI.SetValue(Key,Value); return SI.GetValue(Key);
}

//

FString USCLibrary::SCL_Callable_GetRawSafeByte(FSafeByte &SB) {
	return SB.GetRaw();
}

uint8 USCLibrary::SCL_Pure_GetSafeByte(FSafeByte &SB) {
	return SB.GetValue();
}

uint8 USCLibrary::SCL_Pure_GetSafeByteWithKey(FSafeByte &SB, FString Key) {
	return SB.GetValue(Key);
}

uint8 USCLibrary::SCL_Callable_GetSafeByte(FSafeByte &SB) {
	return SB.GetValue();
}

uint8 USCLibrary::SCL_Callable_GetSafeByteWithKey(FSafeByte &SB, FString Key) {
	return SB.GetValue(Key);
}

//

uint8 USCLibrary::SCL_Callable_SetRawSafeByte(FSafeByte &SB, FString Value) {
	SB.SetRaw(&Value); return SB.GetValue();
}

uint8 USCLibrary::SCL_Pure_SetSafeByte(FSafeByte &SB, const uint8 Value) {
	SB.SetValue(Value); return SB.GetValue();
}

uint8 USCLibrary::SCL_Pure_SetSafeByteWithKey(FSafeByte &SB, FString Key, const uint8 Value) {
	SB.SetValue(Key,Value); return SB.GetValue(Key);
}

uint8 USCLibrary::SCL_Callable_SetSafeByte(FSafeByte &SB, const uint8 Value) {
	SB.SetValue(Value); return SB.GetValue();
}

uint8 USCLibrary::SCL_Callable_SetSafeByteWithKey(FSafeByte &SB, FString Key, const uint8 Value) {
	SB.SetValue(Key,Value); return SB.GetValue(Key);
}

//

FString USCLibrary::SCL_Callable_GetRawSafeFloat(FSafeFloat &SF) {
	return SF.GetRaw();
}

float USCLibrary::SCL_Pure_GetSafeFloat(FSafeFloat &SF) {
	return SF.GetValue();
}

float USCLibrary::SCL_Pure_GetSafeFloatWithKey(FSafeFloat &SF, FString Key) {
	return SF.GetValue(Key);
}

float USCLibrary::SCL_Callable_GetSafeFloat(FSafeFloat &SF) {
	return SF.GetValue();
}

float USCLibrary::SCL_Callable_GetSafeFloatWithKey(FSafeFloat &SF, FString Key) {
	return SF.GetValue(Key);
}

//

float USCLibrary::SCL_Callable_SetRawSafeFloat(FSafeFloat &SF, FString Value) {
	SF.SetRaw(&Value); return SF.GetValue();
}

float USCLibrary::SCL_Pure_SetSafeFloat(FSafeFloat &SF, const float Value) {
	SF.SetValue(Value); return SF.GetValue();
}

float USCLibrary::SCL_Pure_SetSafeFloatWithKey(FSafeFloat &SF, FString Key, const float Value) {
	SF.SetValue(Key,Value); return SF.GetValue(Key);
}

float USCLibrary::SCL_Callable_SetSafeFloat(FSafeFloat &SF, const float Value) {
	SF.SetValue(Value); return SF.GetValue();
}

float USCLibrary::SCL_Callable_SetSafeFloatWithKey(FSafeFloat &SF, FString Key, const float Value) {
	SF.SetValue(Key,Value); return SF.GetValue(Key);
}

FString USCLibrary::SCL_Callable_GetRawSafeName(FSafeName &SN) {
	return SN.GetRaw();
}

//

FName USCLibrary::SCL_Pure_GetSafeName(FSafeName &SN) {
	return SN.GetValue();
}

FName USCLibrary::SCL_Pure_GetSafeNameWithKey(FSafeName &SN, FString Key) {
	return SN.GetValue(Key);
}

FName USCLibrary::SCL_Callable_GetSafeName(FSafeName &SN) {
	return SN.GetValue();
}

FName USCLibrary::SCL_Callable_GetSafeNameWithKey(FSafeName &SN, FString Key) {
	return SN.GetValue(Key);
}

//

FName USCLibrary::SCL_Callable_SetRawSafeName(FSafeName &SN, FString Value) {
	SN.SetRaw(&Value); return SN.GetValue();
}

FName USCLibrary::SCL_Pure_SetSafeName(FSafeName &SN, const FName Value) {
	SN.SetValue(Value); return SN.GetValue();
}

FName USCLibrary::SCL_Pure_SetSafeNameWithKey(FSafeName &SN, FString Key, const FName Value) {
	SN.SetValue(Key,Value); return SN.GetValue(Key);
}

FName USCLibrary::SCL_Callable_SetSafeName(FSafeName &SN, const FName Value) {
	SN.SetValue(Value); return SN.GetValue();
}

FName USCLibrary::SCL_Callable_SetSafeNameWithKey(FSafeName &SN, FString Key, const FName Value) {
	SN.SetValue(Key,Value); return SN.GetValue(Key);
}

//

FString USCLibrary::SCL_Callable_GetRawSafeString(FSafeString &SS) {
	return SS.GetRaw();
}

FString USCLibrary::SCL_Pure_GetSafeString(FSafeString &SS) {
	return SS.GetValue();
}

FString USCLibrary::SCL_Pure_GetSafeStringWithKey(FSafeString &SS, FString Key) {
	return SS.GetValue(Key);
}

FString USCLibrary::SCL_Callable_GetSafeString(FSafeString &SS) {
	return SS.GetValue();
}

FString USCLibrary::SCL_Callable_GetSafeStringWithKey(FSafeString &SS, FString Key) {
	return SS.GetValue(Key);
}

//

FString USCLibrary::SCL_Callable_SetRawSafeString(FSafeString &SS, FString Value) {
	SS.SetRaw(&Value); return SS.GetValue();
}

FString USCLibrary::SCL_Pure_SetSafeString(FSafeString &SS, const FString Value) {
	SS.SetValue(Value); return SS.GetValue();
}

FString USCLibrary::SCL_Pure_SetSafeStringWithKey(FSafeString &SS, FString Key, const FString Value) {
	SS.SetValue(Key,Value); return SS.GetValue(Key);
}

FString USCLibrary::SCL_Callable_SetSafeString(FSafeString &SS, const FString Value) {
	SS.SetValue(Value); return SS.GetValue();
}

FString USCLibrary::SCL_Callable_SetSafeStringWithKey(FSafeString &SS, FString Key, const FString Value) {
	SS.SetValue(Key,Value); return SS.GetValue(Key);
}

//

FString USCLibrary::SCL_Callable_GetRawSafeText(FSafeText &ST) {
	return ST.GetRaw();
}

FText USCLibrary::SCL_Pure_GetSafeText(FSafeText &ST) {
	return ST.GetValue();
}

FText USCLibrary::SCL_Pure_GetSafeTextWithKey(FSafeText &ST, FString Key) {
	return ST.GetValue(Key);
}

FText USCLibrary::SCL_Callable_GetSafeText(FSafeText &ST) {
	return ST.GetValue();
}

FText USCLibrary::SCL_Callable_GetSafeTextWithKey(FSafeText &ST, FString Key) {
	return ST.GetValue(Key);
}

//

FText USCLibrary::SCL_Callable_SetRawSafeText(FSafeText &ST, FString Value) {
	ST.SetRaw(&Value); return ST.GetValue();
}

FText USCLibrary::SCL_Pure_SetSafeText(FSafeText &ST, const FText Value) {
	ST.SetValue(Value); return ST.GetValue();
}

FText USCLibrary::SCL_Pure_SetSafeTextWithKey(FSafeText &ST, FString Key, const FText Value) {
	ST.SetValue(Key,Value); return ST.GetValue(Key);
}

FText USCLibrary::SCL_Callable_SetSafeText(FSafeText &ST, const FText Value) {
	ST.SetValue(Value); return ST.GetValue();
}

FText USCLibrary::SCL_Callable_SetSafeTextWithKey(FSafeText &ST, FString Key, const FText Value) {
	ST.SetValue(Key,Value); return ST.GetValue(Key);
}

//

FVector2D USCLibrary::SCL_Pure_GetSafeVector2D(FSafeVector2D &SV) {
	return SV.GetValue();
}

FVector2D USCLibrary::SCL_Pure_GetSafeVector2DWithKey(FSafeVector2D &SV, FString Key) {
	return SV.GetValue(Key);
}

FVector2D USCLibrary::SCL_Callable_GetSafeVector2D(FSafeVector2D &SV) {
	return SV.GetValue();
}

FVector2D USCLibrary::SCL_Callable_GetSafeVector2DWithKey(FSafeVector2D &SV, FString Key) {
	return SV.GetValue(Key);
}

//

FVector2D USCLibrary::SCL_Pure_SetSafeVector2D(FSafeVector2D &SV, const FVector2D Value) {
	SV.SetValue(Value); return SV.GetValue();
}

FVector2D USCLibrary::SCL_Pure_SetSafeVector2DWithKey(FSafeVector2D &SV, FString Key, const FVector2D Value) {
	SV.SetValue(Key,Value); return SV.GetValue(Key);
}

FVector2D USCLibrary::SCL_Callable_SetSafeVector2D(FSafeVector2D &SV, const FVector2D Value) {
	SV.SetValue(Value); return SV.GetValue();
}

FVector2D USCLibrary::SCL_Callable_SetSafeVector2DWithKey(FSafeVector2D &SV, FString Key, const FVector2D Value) {
	SV.SetValue(Key,Value); return SV.GetValue(Key);
}

//

FVector USCLibrary::SCL_Pure_GetSafeVector3D(FSafeVector3D &SV) {
	return SV.GetValue();
}

FVector USCLibrary::SCL_Pure_GetSafeVector3DWithKey(FSafeVector3D &SV, FString Key) {
	return SV.GetValue(Key);
}

FVector USCLibrary::SCL_Callable_GetSafeVector3D(FSafeVector3D &SV) {
	return SV.GetValue();
}

FVector USCLibrary::SCL_Callable_GetSafeVector3DWithKey(FSafeVector3D &SV, FString Key) {
	return SV.GetValue(Key);
}

//

FVector USCLibrary::SCL_Pure_SetSafeVector3D(FSafeVector3D &SV, const FVector Value) {
	SV.SetValue(Value); return SV.GetValue();
}

FVector USCLibrary::SCL_Pure_SetSafeVector3DWithKey(FSafeVector3D &SV, FString Key, const FVector Value) {
	SV.SetValue(Key,Value); return SV.GetValue(Key);
}

FVector USCLibrary::SCL_Callable_SetSafeVector3D(FSafeVector3D &SV, const FVector Value) {
	SV.SetValue(Value); return SV.GetValue();
}

FVector USCLibrary::SCL_Callable_SetSafeVector3DWithKey(FSafeVector3D &SV, FString Key, const FVector Value) {
	SV.SetValue(Key,Value); return SV.GetValue(Key);
}

//

FVector4 USCLibrary::SCL_Pure_GetSafeVector4D(FSafeVector4D &SV) {
	return SV.GetValue();
}

FVector4 USCLibrary::SCL_Pure_GetSafeVector4DWithKey(FSafeVector4D &SV, FString Key) {
	return SV.GetValue(Key);
}

FVector4 USCLibrary::SCL_Callable_GetSafeVector4D(FSafeVector4D &SV) {
	return SV.GetValue();
}

FVector4 USCLibrary::SCL_Callable_GetSafeVector4DWithKey(FSafeVector4D &SV, FString Key) {
	return SV.GetValue(Key);
}

//

FVector4 USCLibrary::SCL_Pure_SetSafeVector4D(FSafeVector4D &SV, FVector4& Value) {
	SV.SetValue(&Value); return SV.GetValue();
}

FVector4 USCLibrary::SCL_Pure_SetSafeVector4DWithKey(FSafeVector4D &SV, FString Key, FVector4& Value) {
	SV.SetValue(Key,&Value); return SV.GetValue(Key);
}

FVector4 USCLibrary::SCL_Callable_SetSafeVector4D(FSafeVector4D &SV, FVector4& Value) {
	SV.SetValue(&Value); return SV.GetValue();
}

FVector4 USCLibrary::SCL_Callable_SetSafeVector4DWithKey(FSafeVector4D &SV, FString Key, FVector4& Value) {
	SV.SetValue(Key,&Value); return SV.GetValue(Key);
}

//

FLinearColor USCLibrary::SCL_Pure_GetSafeColor(FSafeColor &SC) {
	return SC.GetValue();
}

FLinearColor USCLibrary::SCL_Pure_GetSafeColorWithKey(FSafeColor &SC, FString Key) {
	return SC.GetValue(Key);
}

FLinearColor USCLibrary::SCL_Callable_GetSafeColor(FSafeColor &SC) {
	return SC.GetValue();
}

FLinearColor USCLibrary::SCL_Callable_GetSafeColorWithKey(FSafeColor &SC, FString Key) {
	return SC.GetValue(Key);
}

//

FLinearColor USCLibrary::SCL_Pure_SetSafeColor(FSafeColor &SC, FLinearColor& Value) {
	SC.SetValue(&Value); return SC.GetValue();
}

FLinearColor USCLibrary::SCL_Pure_SetSafeColorWithKey(FSafeColor &SC, FString Key, FLinearColor& Value) {
	SC.SetValue(Key,&Value); return SC.GetValue(Key);
}

FLinearColor USCLibrary::SCL_Callable_SetSafeColor(FSafeColor &SC, FLinearColor& Value) {
	SC.SetValue(&Value); return SC.GetValue();
}

FLinearColor USCLibrary::SCL_Callable_SetSafeColorWithKey(FSafeColor &SC, FString Key, FLinearColor& Value) {
	SC.SetValue(Key,&Value); return SC.GetValue(Key);
}

//

FRotator USCLibrary::SCL_Pure_GetSafeRotator(FSafeRotator &SR) {
	return SR.GetValue();
}

FRotator USCLibrary::SCL_Pure_GetSafeRotatorWithKey(FSafeRotator &SR, FString Key) {
	return SR.GetValue(Key);
}

FRotator USCLibrary::SCL_Callable_GetSafeRotator(FSafeRotator &SR) {
	return SR.GetValue();
}

FRotator USCLibrary::SCL_Callable_GetSafeRotatorWithKey(FSafeRotator &SR, FString Key) {
	return SR.GetValue(Key);
}

//

FRotator USCLibrary::SCL_Pure_SetSafeRotator(FSafeRotator &SR, const FRotator Value) {
	SR.SetValue(Value); return SR.GetValue();
}

FRotator USCLibrary::SCL_Pure_SetSafeRotatorWithKey(FSafeRotator &SR, FString Key, const FRotator Value) {
	SR.SetValue(Key,Value); return SR.GetValue(Key);
}

FRotator USCLibrary::SCL_Callable_SetSafeRotator(FSafeRotator &SR, const FRotator Value) {
	SR.SetValue(Value); return SR.GetValue();
}

FRotator USCLibrary::SCL_Callable_SetSafeRotatorWithKey(FSafeRotator &SR, FString Key, const FRotator Value) {
	SR.SetValue(Key,Value); return SR.GetValue(Key);
}

//

FTransform USCLibrary::SCL_Pure_GetSafeTransform(FSafeTransform &ST) {
	return ST.GetValue();
}

FTransform USCLibrary::SCL_Pure_GetSafeTransformWithKey(FSafeTransform &ST, FString Key) {
	return ST.GetValue(Key);
}

FTransform USCLibrary::SCL_Callable_GetSafeTransform(FSafeTransform &ST) {
	return ST.GetValue();
}

FTransform USCLibrary::SCL_Callable_GetSafeTransformWithKey(FSafeTransform &ST, FString Key) {
	return ST.GetValue(Key);
}

//

FTransform USCLibrary::SCL_Pure_SetSafeTransform(FSafeTransform &ST, FTransform& Value) {
	ST.SetValue(&Value); return ST.GetValue();
}

FTransform USCLibrary::SCL_Pure_SetSafeTransformWithKey(FSafeTransform &ST, FString Key, FTransform& Value) {
	ST.SetValue(Key,&Value); return ST.GetValue();
}

FTransform USCLibrary::SCL_Callable_SetSafeTransform(FSafeTransform &ST, FTransform& Value) {
	ST.SetValue(&Value); return ST.GetValue();
}

FTransform USCLibrary::SCL_Callable_SetSafeTransformWithKey(FSafeTransform &ST, FString Key, FTransform& Value) {
	ST.SetValue(Key,&Value); return ST.GetValue();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// FSBool

/* FSafe -> FSafe */

FSafeBool USCLibrary::SCO_Pure_SetSafeBoolEqualFSB(FSafeBool &FSB, FSafeBool &SSB, bool &Output) {
	FSB = SSB; Output = FSB.GetValue(); return FSB;
}

FSafeBool USCLibrary::SCO_Pure_GetSafeBoolEqualFSB(FSafeBool &FSB, FSafeBool &SSB, bool &Output) {
	Output = (FSB == SSB); return FSafeBool(Output);
}

FSafeBool USCLibrary::SCO_Pure_GetSafeBoolNotEqualFSB(FSafeBool &FSB, FSafeBool &SSB, bool &Output) {
	Output = (FSB != SSB); return FSafeBool(Output);
}

FSafeBool USCLibrary::SCO_Pure_GetSafeBoolAndFSB(FSafeBool &FSB, FSafeBool &SSB, bool &Output) {
	Output = (FSB && SSB); return FSafeBool(Output);
}

FSafeBool USCLibrary::SCO_Pure_GetSafeBoolOrFSB(FSafeBool &FSB, FSafeBool &SSB, bool &Output) {
	Output = (FSB || SSB); return FSafeBool(Output);
}

/* Native -> FSafe */

FSafeBool USCLibrary::SCO_Pure_SetSafeBoolEqualBool(FSafeBool &FSB, bool &NB, bool &Output) {
	FSB = NB; Output = FSB.GetValue(); return FSB;
}

FSafeBool USCLibrary::SCO_Pure_GetSafeBoolEqualBool(FSafeBool &FSB, bool &NB, bool &Output) {
	Output = (FSB == NB); return FSafeBool(Output);
}

FSafeBool USCLibrary::SCO_Pure_GetSafeBoolNotEqualBool(FSafeBool &FSB, bool &NB, bool &Output) {
	Output = (FSB != NB); return FSafeBool(Output);
}

FSafeBool USCLibrary::SCO_Pure_GetSafeBoolAndBool(FSafeBool &FSB, bool &NB, bool &Output) {
	Output = (FSB && NB); return FSafeBool(Output);
}

FSafeBool USCLibrary::SCO_Pure_GetSafeBoolOrBool(FSafeBool &FSB, bool &NB, bool &Output) {
	Output = (FSB || NB); return FSafeBool(Output);
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_SetBoolEqualFSB(bool &NB, FSafeBool &FSB) {
	return (NB = FSB.GetValue());
}

bool USCLibrary::SCO_Pure_GetBoolEqualFSB(bool &NB, FSafeBool &FSB) {
	return (NB == FSB);
}

bool USCLibrary::SCO_Pure_GetBoolNotEqualFSB(bool &NB, FSafeBool &FSB) {
	return (NB != FSB);
}

bool USCLibrary::SCO_Pure_GetBoolAndFSB(bool &NB, FSafeBool &FSB) {
	return (NB && FSB);
}

bool USCLibrary::SCO_Pure_GetBoolOrFSB(bool &NB, FSafeBool &FSB) {
	return (NB || FSB);
}

// FSByte

/* FSafe -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeByteEqualFSB(FSafeByte &FSB, FSafeByte &SSB) {
	return (FSB == SSB);
}

bool USCLibrary::SCO_Pure_GetSafeByteNotEqualFSB(FSafeByte &FSB, FSafeByte &SSB) {
	return (FSB != SSB);
}

bool USCLibrary::SCO_Pure_GetSafeByteGreaterFSB(FSafeByte &FSB, FSafeByte &SSB) {
	return (FSB > SSB);
}

bool USCLibrary::SCO_Pure_GetSafeByteSmallerFSB(FSafeByte &FSB, FSafeByte &SSB) {
	return (FSB < SSB);
}

bool USCLibrary::SCO_Pure_GetSafeByteGreaterEqualFSB(FSafeByte &FSB, FSafeByte &SSB) {
	return (FSB >= SSB);
}

bool USCLibrary::SCO_Pure_GetSafeByteSmallerEqualFSB(FSafeByte &FSB, FSafeByte &SSB) {
	return (FSB <= SSB);
}

FSafeByte USCLibrary::SCO_Pure_SetSafeByteEqualFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	FSB = SSB; Output = FSB.GetValue(); return FSB;
}

FSafeByte USCLibrary::SCO_Pure_GetSafeBytePlusFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	Output = (FSB + SSB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteMinusFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	Output = (FSB - SSB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteTimesFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	Output = (FSB * SSB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteDivideFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	Output = (FSB / SSB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteIncreaseFSB(FSafeByte &FSB, uint8 &Output) {
	Output = (++ FSB).GetValue(); return FSB;
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteDecreaseFSB(FSafeByte &FSB, uint8 &Output) {
	Output = (-- FSB).GetValue(); return FSB;
}

FSafeByte USCLibrary::SCO_Pure_GetSafeBytePlusEqualFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	FSB += SSB; Output = FSB.GetValue(); return FSB;
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteMinusEqualFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	FSB -= SSB; Output = FSB.GetValue(); return FSB;
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteNotFSB(FSafeByte &FSB, uint8 &Output) {
	Output = ( ~ FSB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteModFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	Output = (FSB % SSB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteAndFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	Output = (FSB & SSB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteOrFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	Output = (FSB | SSB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteXorFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	Output = (FSB ^ SSB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteShiftRFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	Output = (FSB >> SSB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteShiftLFSB(FSafeByte &FSB, FSafeByte &SSB, uint8 &Output) {
	Output = (FSB << SSB).GetValue(); return FSafeByte(Output);
}

/* Native -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeByteEqualByte(FSafeByte &FSB, uint8 &NB) {
	return (FSB == NB);
}

bool USCLibrary::SCO_Pure_GetSafeByteNotEqualByte(FSafeByte &FSB, uint8 &NB) {
	return (FSB != NB);
}

bool USCLibrary::SCO_Pure_GetSafeByteGreaterByte(FSafeByte &FSB, uint8 &NB) {
	return (FSB > NB);
}

bool USCLibrary::SCO_Pure_GetSafeByteSmallerByte(FSafeByte &FSB, uint8 &NB) {
	return (FSB < NB);
}

bool USCLibrary::SCO_Pure_GetSafeByteGreaterEqualByte(FSafeByte &FSB, uint8 &NB) {
	return (FSB >= NB);
}

bool USCLibrary::SCO_Pure_GetSafeByteSmallerEqualByte(FSafeByte &FSB, uint8 &NB) {
	return (FSB <= NB);
}

FSafeByte USCLibrary::SCO_Pure_SetSafeByteEqualByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	FSB = NB; Output = FSB.GetValue(); return FSB;
}

FSafeByte USCLibrary::SCO_Pure_GetSafeBytePlusByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	Output = (FSB + NB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteMinusByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	Output = (FSB - NB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteTimesByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	Output = (FSB * NB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteDivideByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	Output = (FSB / NB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeBytePlusEqualByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	FSB += NB; Output = FSB.GetValue(); return FSB;
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteMinusEqualByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	FSB -= NB; Output = FSB.GetValue(); return FSB;
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteNotByte(uint8 &NB, uint8 &Output) {
	Output = ( ~ NB); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteModByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	Output = (FSB % NB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteAndByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	Output = (FSB & NB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteOrByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	Output = (FSB | NB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteXorByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	Output = (FSB ^ NB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteShiftRByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	Output = (FSB >> NB).GetValue(); return FSafeByte(Output);
}

FSafeByte USCLibrary::SCO_Pure_GetSafeByteShiftLByte(FSafeByte &FSB, uint8 &NB, uint8 &Output) {
	Output = (FSB << NB).GetValue(); return FSafeByte(Output);
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_GetByteEqualFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB == FSB);
}

bool USCLibrary::SCO_Pure_GetByteNotEqualFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB != FSB);
}

bool USCLibrary::SCO_Pure_GetByteGreaterFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB > FSB);
}

bool USCLibrary::SCO_Pure_GetByteSmallerFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB < FSB);
}

bool USCLibrary::SCO_Pure_GetByteGreaterEqualFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB >= FSB);
}

bool USCLibrary::SCO_Pure_GetByteSmallerEqualFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB <= FSB);
}

uint8 USCLibrary::SCO_Pure_SetByteEqualFSB(uint8 &NB, FSafeByte &FSB) {
	NB = FSB.GetValue(); return NB;
}

uint8 USCLibrary::SCO_Pure_GetBytePlusFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB + FSB);
}

uint8 USCLibrary::SCO_Pure_GetByteMinusFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB - FSB);
}

uint8 USCLibrary::SCO_Pure_GetByteTimesFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB * FSB);
}

uint8 USCLibrary::SCO_Pure_GetByteDivideFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB / FSB);
}

uint8 USCLibrary::SCO_Pure_GetByteModFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB % FSB);
}

uint8 USCLibrary::SCO_Pure_GetByteAndFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB & FSB);
}

uint8 USCLibrary::SCO_Pure_GetByteOrFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB | FSB);
}

uint8 USCLibrary::SCO_Pure_GetByteXorFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB ^ FSB);
}

uint8 USCLibrary::SCO_Pure_GetByteShiftRFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB >> FSB);
}

uint8 USCLibrary::SCO_Pure_GetByteShiftLFSB(uint8 &NB, FSafeByte &FSB) {
	return (NB << FSB);
}


// FSInt

/* FSafe -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeIntEqualFSI(FSafeInt &FSI, FSafeInt &SSI) {
	return (FSI == SSI);
}

bool USCLibrary::SCO_Pure_GetSafeIntNotEqualFSI(FSafeInt &FSI, FSafeInt &SSI) {
	return (FSI != SSI);
}

bool USCLibrary::SCO_Pure_GetSafeIntGreaterFSI(FSafeInt &FSI, FSafeInt &SSI) {
	return (FSI > SSI);
}

bool USCLibrary::SCO_Pure_GetSafeIntSmallerFSI(FSafeInt &FSI, FSafeInt &SSI) {
	return (FSI < SSI);
}

bool USCLibrary::SCO_Pure_GetSafeIntGreaterEqualFSI(FSafeInt &FSI, FSafeInt &SSI) {
	return (FSI >= SSI);
}

bool USCLibrary::SCO_Pure_GetSafeIntSmallerEqualFSI(FSafeInt &FSI, FSafeInt &SSI) {
	return (FSI <= SSI);
}

FSafeInt USCLibrary::SCO_Pure_SetSafeIntEqualFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	FSI = SSI; Output = FSI.GetValue(); return FSI;
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntPlusFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	Output = (FSI + SSI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntMinusFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	Output = (FSI - SSI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntTimesFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	Output = (FSI * SSI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntDivideFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	Output = (FSI / SSI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntIncreaseFSI(FSafeInt &FSI, int32 &Output) {
	Output = (++ FSI).GetValue(); return FSI;
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntDecreaseFSI(FSafeInt &FSI, int32 &Output) {
	Output = (-- FSI).GetValue(); return FSI;
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntPlusEqualFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	FSI += SSI; Output = FSI.GetValue(); return FSI;
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntMinusEqualFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	FSI -= SSI; Output = FSI.GetValue(); return FSI;
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntNotFSI(FSafeInt &FSI, int32 &Output) {
	Output = ( ~ FSI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntModFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	Output = (FSI % SSI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntAndFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	Output = (FSI & SSI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntOrFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	Output = (FSI | SSI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntXorFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	Output = (FSI ^ SSI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntShiftRFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	Output = (FSI >> SSI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntShiftLFSI(FSafeInt &FSI, FSafeInt &SSI, int32 &Output) {
	Output = (FSI << SSI).GetValue(); return FSafeInt(Output);
}

/* Native -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeIntEqualInt(FSafeInt &FSI, int32 &NI) {
	return (FSI == NI);
}

bool USCLibrary::SCO_Pure_GetSafeIntNotEqualInt(FSafeInt &FSI, int32 &NI) {
	return (FSI != NI);
}

bool USCLibrary::SCO_Pure_GetSafeIntGreaterInt(FSafeInt &FSI, int32 &NI) {
	return (FSI > NI);
}

bool USCLibrary::SCO_Pure_GetSafeIntSmallerInt(FSafeInt &FSI, int32 &NI) {
	return (FSI < NI);
}

bool USCLibrary::SCO_Pure_GetSafeIntGreaterEqualInt(FSafeInt &FSI, int32 &NI) {
	return (FSI >= NI);
}

bool USCLibrary::SCO_Pure_GetSafeIntSmallerEqualInt(FSafeInt &FSI, int32 &NI) {
	return (FSI <= NI);
}

FSafeInt USCLibrary::SCO_Pure_SetSafeIntEqualInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	FSI = NI; Output = FSI.GetValue(); return FSI;
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntPlusInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	Output = (FSI + NI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntMinusInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	Output = (FSI - NI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntTimesInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	Output = (FSI * NI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntDivideInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	Output = (FSI / NI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntPlusEqualInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	FSI += NI; Output = FSI.GetValue(); return FSI;
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntMinusEqualInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	FSI -= NI; Output = FSI.GetValue(); return FSI;
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntNotInt(int32 &NI, int32 &Output) {
	Output = ( ~ NI); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntModInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	Output = (FSI % NI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntAndInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	Output = (FSI & NI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntOrInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	Output = (FSI | NI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntXorInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	Output = (FSI ^ NI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntShiftRInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	Output = (FSI >> NI).GetValue(); return FSafeInt(Output);
}

FSafeInt USCLibrary::SCO_Pure_GetSafeIntShiftLInt(FSafeInt &FSI, int32 &NI, int32 &Output) {
	Output = (FSI << NI).GetValue(); return FSafeInt(Output);
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_GetIntEqualFSI(int32 &NI, FSafeInt &FSI) {
	return (NI == FSI);
}

bool USCLibrary::SCO_Pure_GetIntNotEqualFSI(int32 &NI, FSafeInt &FSI) {
	return (NI != FSI);
}

bool USCLibrary::SCO_Pure_GetIntGreaterFSI(int32 &NI, FSafeInt &FSI) {
	return (NI > FSI);
}

bool USCLibrary::SCO_Pure_GetIntSmallerFSI(int32 &NI, FSafeInt &FSI) {
	return (NI < FSI);
}

bool USCLibrary::SCO_Pure_GetIntGreaterEqualFSI(int32 &NI, FSafeInt &FSI) {
	return (NI >= FSI);
}

bool USCLibrary::SCO_Pure_GetIntSmallerEqualFSI(int32 &NI, FSafeInt &FSI) {
	return (NI <= FSI);
}

int32 USCLibrary::SCO_Pure_SetIntEqualFSI(int32 &NI, FSafeInt &FSI) {
	NI = FSI.GetValue(); return NI;
}

int32 USCLibrary::SCO_Pure_GetIntPlusFSI(int32 &NI, FSafeInt &FSI) {
	return (NI + FSI);
}

int32 USCLibrary::SCO_Pure_GetIntMinusFSI(int32 &NI, FSafeInt &FSI) {
	return (NI - FSI);
}

int32 USCLibrary::SCO_Pure_GetIntTimesFSI(int32 &NI, FSafeInt &FSI) {
	return (NI * FSI);
}

int32 USCLibrary::SCO_Pure_GetIntDivideFSI(int32 &NI, FSafeInt &FSI) {
	return (NI / FSI);
}

int32 USCLibrary::SCO_Pure_GetIntModFSI(int32 &NI, FSafeInt &FSI) {
	return (NI % FSI);
}

int32 USCLibrary::SCO_Pure_GetIntAndFSI(int32 &NI, FSafeInt &FSI) {
	return (NI & FSI);
}

int32 USCLibrary::SCO_Pure_GetIntOrFSI(int32 &NI, FSafeInt &FSI) {
	return (NI | FSI);
}

int32 USCLibrary::SCO_Pure_GetIntXorFSI(int32 &NI, FSafeInt &FSI) {
	return (NI ^ FSI);
}

int32 USCLibrary::SCO_Pure_GetIntShiftRFSI(int32 &NI, FSafeInt &FSI) {
	return (NI >> FSI);
}

int32 USCLibrary::SCO_Pure_GetIntShiftLFSI(int32 &NI, FSafeInt &FSI) {
	return (NI << FSI);
}

// FSFloat

/* FSafe -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeFloatEqualFSF(FSafeFloat &FSF, FSafeFloat &SSF) {
	return (FSF == SSF);
}

bool USCLibrary::SCO_Pure_GetSafeFloatNotEqualFSF(FSafeFloat &FSF, FSafeFloat &SSF) {
	return (FSF != SSF);
}

bool USCLibrary::SCO_Pure_GetSafeFloatGreaterFSF(FSafeFloat &FSF, FSafeFloat &SSF) {
	return (FSF > SSF);
}

bool USCLibrary::SCO_Pure_GetSafeFloatSmallerFSF(FSafeFloat &FSF, FSafeFloat &SSF) {
	return (FSF < SSF);
}

bool USCLibrary::SCO_Pure_GetSafeFloatGreaterEqualFSF(FSafeFloat &FSF, FSafeFloat &SSF) {
	return (FSF >= SSF);
}

bool USCLibrary::SCO_Pure_GetSafeFloatSmallerEqualFSF(FSafeFloat &FSF, FSafeFloat &SSF) {
	return (FSF <= SSF);
}

FSafeFloat USCLibrary::SCO_Pure_SetSafeFloatEqualFSF(FSafeFloat &FSF, FSafeFloat &SSF, float &Output) {
	FSF = SSF; Output = FSF.GetValue(); return FSF;
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatPlusFSF(FSafeFloat &FSF, FSafeFloat &SSF, float &Output) {
	Output = (FSF + SSF).GetValue(); return FSafeFloat(Output);
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatMinusFSF(FSafeFloat &FSF, FSafeFloat &SSF, float &Output) {
	Output = (FSF - SSF).GetValue(); return FSafeFloat(Output);
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatTimesFSF(FSafeFloat &FSF, FSafeFloat &SSF, float &Output) {
	Output = (FSF * SSF).GetValue(); return FSafeFloat(Output);
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatDivideFSF(FSafeFloat &FSF, FSafeFloat &SSF, float &Output) {
	Output = (FSF / SSF).GetValue(); return FSafeFloat(Output);
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatIncreaseFSF(FSafeFloat &FSF, float &Output) {
	Output = (++ FSF).GetValue(); return FSF;
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatDecreaseFSF(FSafeFloat &FSF, float &Output) {
	Output = (-- FSF).GetValue(); return FSF;
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatPlusEqualFSF(FSafeFloat &FSF, FSafeFloat &SSF, float &Output) {
	FSF += SSF; Output = FSF.GetValue(); return FSF;
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatMinusEqualFSF(FSafeFloat &FSF, FSafeFloat &SSF, float &Output) {
	FSF -= SSF; Output = FSF.GetValue(); return FSF;
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatModFSF(FSafeFloat &FSF, FSafeFloat &SSF, float &Output) {
	Output = (FSF % SSF).GetValue(); return FSafeFloat(Output);
}

/* Native -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeFloatEqualFloat(FSafeFloat &FSF, float &NF) {
	return (FSF == NF);
}

bool USCLibrary::SCO_Pure_GetSafeFloatNotEqualFloat(FSafeFloat &FSF, float &NF) {
	return (FSF != NF);
}

bool USCLibrary::SCO_Pure_GetSafeFloatGreaterFloat(FSafeFloat &FSF, float &NF) {
	return (FSF > NF);
}

bool USCLibrary::SCO_Pure_GetSafeFloatSmallerFloat(FSafeFloat &FSF, float &NF) {
	return (FSF < NF);
}

bool USCLibrary::SCO_Pure_GetSafeFloatGreaterEqualFloat(FSafeFloat &FSF, float &NF) {
	return (FSF >= NF);
}

bool USCLibrary::SCO_Pure_GetSafeFloatSmallerEqualFloat(FSafeFloat &FSF, float &NF) {
	return (FSF <= NF);
}

FSafeFloat USCLibrary::SCO_Pure_SetSafeFloatEqualFloat(FSafeFloat &FSF, float &NF, float &Output) {
	FSF = NF; Output = FSF.GetValue(); return FSF;
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatPlusFloat(FSafeFloat &FSF, float &NF, float &Output) {
	Output = (FSF + NF).GetValue(); return FSafeFloat(Output);
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatMinusFloat(FSafeFloat &FSF, float &NF, float &Output) {
	Output = (FSF - NF).GetValue(); return FSafeFloat(Output);
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatTimesFloat(FSafeFloat &FSF, float &NF, float &Output) {
	Output = (FSF * NF).GetValue(); return FSafeFloat(Output);
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatDivideFloat(FSafeFloat &FSF, float &NF, float &Output) {
	Output = (FSF / NF).GetValue(); return FSafeFloat(Output);
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatPlusEqualFloat(FSafeFloat &FSF, float &NF, float &Output) {
	FSF += NF; Output = FSF.GetValue(); return FSF;
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatMinusEqualFloat(FSafeFloat &FSF, float &NF, float &Output) {
	FSF -= NF; Output = FSF.GetValue(); return FSF;
}

FSafeFloat USCLibrary::SCO_Pure_GetSafeFloatModFloat(FSafeFloat &FSF, float &NF, float &Output) {
	Output = (FSF % NF).GetValue(); return FSafeFloat(Output);
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_GetFloatEqualFSF(float &NF, FSafeFloat &FSF) {
	return (NF == FSF);
}

bool USCLibrary::SCO_Pure_GetFloatNotEqualFSF(float &NF, FSafeFloat &FSF) {
	return (NF != FSF);
}

bool USCLibrary::SCO_Pure_GetFloatGreaterFSF(float &NF, FSafeFloat &FSF) {
	return (NF > FSF);
}

bool USCLibrary::SCO_Pure_GetFloatSmallerFSF(float &NF, FSafeFloat &FSF) {
	return (NF < FSF);
}

bool USCLibrary::SCO_Pure_GetFloatGreaterEqualFSF(float &NF, FSafeFloat &FSF) {
	return (NF >= FSF);
}

bool USCLibrary::SCO_Pure_GetFloatSmallerEqualFSF(float &NF, FSafeFloat &FSF) {
	return (NF <= FSF);
}

float USCLibrary::SCO_Pure_SetFloatEqualFSF(float &NF, FSafeFloat &FSF) {
	NF = FSF.GetValue(); return NF;
}

float USCLibrary::SCO_Pure_GetFloatPlusFSF(float &NF, FSafeFloat &FSF) {
	return (NF + FSF);
}

float USCLibrary::SCO_Pure_GetFloatMinusFSF(float &NF, FSafeFloat &FSF) {
	return (NF - FSF);
}

float USCLibrary::SCO_Pure_GetFloatTimesFSF(float &NF, FSafeFloat &FSF) {
	return (NF * FSF);
}

float USCLibrary::SCO_Pure_GetFloatDivideFSF(float &NF, FSafeFloat &FSF) {
	return (NF / FSF);
}

float USCLibrary::SCO_Pure_GetFloatModFSF(float &NF, FSafeFloat &FSF) {
	return (NF % FSF);
}

// FSName

/* FSafe -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeNameEqualFSN(FSafeName &FSN, FSafeName &SSN) {
	return (FSN == SSN);
}

bool USCLibrary::SCO_Pure_GetSafeNameNotEqualFSN(FSafeName &FSN, FSafeName &SSN) {
	return (FSN != SSN);
}

bool USCLibrary::SCO_Pure_GetSafeNameGreaterFSN(FSafeName &FSN, FSafeName &SSN) {
	return (FSN > SSN);
}

bool USCLibrary::SCO_Pure_GetSafeNameSmallerFSN(FSafeName &FSN, FSafeName &SSN) {
	return (FSN < SSN);
}

FSafeName USCLibrary::SCO_Pure_SetSafeNameEqualFSN(FSafeName &FSN, FSafeName &SSN, FName &Output) {
	FSN = SSN; Output = FSN.GetValue(); return FSN;
}

FSafeName USCLibrary::SCO_Pure_GetSafeNamePlusFSN(FSafeName &FSN, FSafeName &SSN, FName &Output) {
	Output = (FSN + SSN).GetValue(); return FSafeName(Output);
}

/* Native -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeNameEqualName(FSafeName &FSN, FName &NN) {
	return (FSN == NN);
}

bool USCLibrary::SCO_Pure_GetSafeNameNotEqualName(FSafeName &FSN, FName &NN) {
	return (FSN != NN);
}

bool USCLibrary::SCO_Pure_GetSafeNameGreaterName(FSafeName &FSN, FName &NN) {
	return (FSN > NN);
}

bool USCLibrary::SCO_Pure_GetSafeNameSmallerName(FSafeName &FSN, FName &NN) {
	return (FSN < NN);
}

FSafeName USCLibrary::SCO_Pure_SetSafeNameEqualName(FSafeName &FSN, FName &NN, FName &Output) {
	FSN = NN; Output = FSN.GetValue(); return FSN;
}

FSafeName USCLibrary::SCO_Pure_GetSafeNamePlusName(FSafeName &FSN, FName &NN, FName &Output) {
	Output = (FSN + NN).GetValue(); return FSafeName(Output);
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_GetNameEqualFSN(FName &NN, FSafeName &FSN) {
	return (NN == FSN);
}

bool USCLibrary::SCO_Pure_GetNameNotEqualFSN(FName &NN, FSafeName &FSN) {
	return (NN != FSN);
}

bool USCLibrary::SCO_Pure_GetNameGreaterFSN(FName &NN, FSafeName &FSN) {
	return (NN > FSN);
}

bool USCLibrary::SCO_Pure_GetNameSmallerFSN(FName &NN, FSafeName &FSN) {
	return (NN < FSN);
}

FName USCLibrary::SCO_Pure_SetNameEqualFSN(FName &NN, FSafeName &FSN) {
	NN = FSN.GetValue(); return NN;
}

FName USCLibrary::SCO_Pure_GetNamePlusFSN(FName &NN, FSafeName &FSN) {
	return (NN + FSN);
}

// FSText

/* FSafe -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeTextEqualFST(FSafeText &FST, FSafeText &ST) {
	return (FST == ST);
}

bool USCLibrary::SCO_Pure_GetSafeTextNotEqualFST(FSafeText &FST, FSafeText &ST) {
	return (FST != ST);
}

bool USCLibrary::SCO_Pure_GetSafeTextGreaterFST(FSafeText &FST, FSafeText &ST) {
	return (FST > ST);
}

bool USCLibrary::SCO_Pure_GetSafeTextSmallerFST(FSafeText &FST, FSafeText &ST) {
	return (FST < ST);
}

FSafeText USCLibrary::SCO_Pure_SetSafeTextEqualFST(FSafeText &FST, FSafeText &ST, FText &Output) {
	FST = ST; Output = FST.GetValue(); return FST;
}

FSafeText USCLibrary::SCO_Pure_GetSafeTextPlusFST(FSafeText &FST, FSafeText &ST, FText &Output) {
	Output = (FST + ST).GetValue(); return FSafeText(Output);
}

/* Native -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeTextEqualText(FSafeText &FST, FText &NT) {
	return (FST == NT);
}

bool USCLibrary::SCO_Pure_GetSafeTextNotEqualText(FSafeText &FST, FText &NT) {
	return (FST != NT);
}

bool USCLibrary::SCO_Pure_GetSafeTextGreaterText(FSafeText &FST, FText &NT) {
	return (FST > NT);
}

bool USCLibrary::SCO_Pure_GetSafeTextSmallerText(FSafeText &FST, FText &NT) {
	return (FST < NT);
}

FSafeText USCLibrary::SCO_Pure_SetSafeTextEqualText(FSafeText &FST, FText &NT, FText &Output) {
	FST = NT; Output = FST.GetValue(); return FST;
}

FSafeText USCLibrary::SCO_Pure_GetSafeTextPlusText(FSafeText &FST, FText &NT, FText &Output) {
	Output = (FST + NT).GetValue(); return FSafeText(Output);
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_GetTextEqualFST(FText &NT, FSafeText &FST) {
	return (NT == FST);
}

bool USCLibrary::SCO_Pure_GetTextNotEqualFST(FText &NT, FSafeText &FST) {
	return (NT != FST);
}

bool USCLibrary::SCO_Pure_GetTextGreaterFST(FText &NT, FSafeText &FST) {
	return (NT > FST);
}

bool USCLibrary::SCO_Pure_GetTextSmallerFST(FText &NT, FSafeText &FST) {
	return (NT < FST);
}

FText USCLibrary::SCO_Pure_SetTextEqualFST(FText &NT, FSafeText &FST) {
	NT = FST.GetValue(); return NT;
}

FText USCLibrary::SCO_Pure_GetTextPlusFST(FText &NT, FSafeText &FST) {
	return (NT + FST);
}

// FSString

/* FSafe -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeStringEqualFSS(FSafeString &FSS, FSafeString &SSN) {
	return (FSS == SSN);
}

bool USCLibrary::SCO_Pure_GetSafeStringNotEqualFSS(FSafeString &FSS, FSafeString &SSN) {
	return (FSS != SSN);
}

bool USCLibrary::SCO_Pure_GetSafeStringGreaterFSS(FSafeString &FSS, FSafeString &SSN) {
	return (FSS > SSN);
}

bool USCLibrary::SCO_Pure_GetSafeStringSmallerFSS(FSafeString &FSS, FSafeString &SSN) {
	return (FSS < SSN);
}

FSafeString USCLibrary::SCO_Pure_SetSafeStringEqualFSS(FSafeString &FSS, FSafeString &SSN, FString &Output) {
	FSS = SSN; Output = FSS.GetValue(); return FSS;
}

FSafeString USCLibrary::SCO_Pure_GetSafeStringPlusFSS(FSafeString &FSS, FSafeString &SSN, FString &Output) {
	Output = (FSS + SSN).GetValue(); return FSafeString(Output);
}

/* Native -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeStringEqualString(FSafeString &FSS, FString &NS) {
	return (FSS == NS);
}

bool USCLibrary::SCO_Pure_GetSafeStringNotEqualString(FSafeString &FSS, FString &NS) {
	return (FSS != NS);
}

bool USCLibrary::SCO_Pure_GetSafeStringGreaterString(FSafeString &FSS, FString &NS) {
	return (FSS > NS);
}

bool USCLibrary::SCO_Pure_GetSafeStringSmallerString(FSafeString &FSS, FString &NS) {
	return (FSS < NS);
}

FSafeString USCLibrary::SCO_Pure_SetSafeStringEqualString(FSafeString &FSS, FString &NS, FString &Output) {
	FSS = NS; Output = FSS.GetValue(); return FSS;
}

FSafeString USCLibrary::SCO_Pure_GetSafeStringPlusString(FSafeString &FSS, FString &NS, FString &Output) {
	Output = (FSS + NS).GetValue(); return FSafeString(Output);
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_GetStringEqualFSS(FString &NS, FSafeString &FSS) {
	return (NS == FSS);
}

bool USCLibrary::SCO_Pure_GetStringNotEqualFSS(FString &NS, FSafeString &FSS) {
	return (NS != FSS);
}

bool USCLibrary::SCO_Pure_GetStringGreaterFSS(FString &NS, FSafeString &FSS) {
	return (NS > FSS);
}

bool USCLibrary::SCO_Pure_GetStringSmallerFSS(FString &NS, FSafeString &FSS) {
	return (NS < FSS);
}

FString USCLibrary::SCO_Pure_SetStringEqualFSS(FString &NS, FSafeString &FSS) {
	NS = FSS.GetValue(); return NS;
}

FString USCLibrary::SCO_Pure_GetStringPlusFSS(FString &NS, FSafeString &FSS) {
	return (NS + FSS);
}

// FSVector2D

/* FSafe -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeVector2DEqualFSV(FSafeVector2D &FSV, FSafeVector2D &SSV) {
	return (FSV == SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector2DNotEqualFSV(FSafeVector2D &FSV, FSafeVector2D &SSV) {
	return (FSV != SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector2DGreaterFSV(FSafeVector2D &FSV, FSafeVector2D &SSV) {
	return (FSV > SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector2DSmallerFSV(FSafeVector2D &FSV, FSafeVector2D &SSV) {
	return (FSV < SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector2DGreaterEqualFSV(FSafeVector2D &FSV, FSafeVector2D &SSV) {
	return (FSV >= SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector2DSmallerEqualFSV(FSafeVector2D &FSV, FSafeVector2D &SSV) {
	return (FSV <= SSV);
}

FSafeVector2D USCLibrary::SCO_Pure_SetSafeVector2DEqualFSV(FSafeVector2D &FSV, FSafeVector2D &SSV, FVector2D &Output) {
	FSV = SSV; Output = FSV.GetValue(); return FSV;
}

FSafeVector2D USCLibrary::SCO_Pure_GetSafeVector2DPlusFSV(FSafeVector2D &FSV, FSafeVector2D &SSV, FVector2D &Output) {
	Output = (FSV + SSV).GetValue(); return FSafeVector2D(Output);
}

FSafeVector2D USCLibrary::SCO_Pure_GetSafeVector2DMinusFSV(FSafeVector2D &FSV, FSafeVector2D &SSV, FVector2D &Output) {
	Output = (FSV - SSV).GetValue(); return FSafeVector2D(Output);
}

FSafeVector2D USCLibrary::SCO_Pure_GetSafeVector2DTimesFSV(FSafeVector2D &FSV, FSafeVector2D &SSV, FVector2D &Output) {
	Output = (FSV * SSV).GetValue(); return FSafeVector2D(Output);
}

FSafeVector2D USCLibrary::SCO_Pure_GetSafeVector2DDivideFSV(FSafeVector2D &FSV, FSafeVector2D &SSV, FVector2D &Output) {
	Output = (FSV / SSV).GetValue(); return FSafeVector2D(Output);
}

FSafeVector2D USCLibrary::SCO_Pure_GetSafeVector2DModFSV(FSafeVector2D &FSV, FSafeVector2D &SSV, FVector2D &Output) {
	Output = (FSV % SSV).GetValue(); return FSafeVector2D(Output);
}

/* Native -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeVector2DEqualVector2D(FSafeVector2D &FSV, FVector2D &NV) {
	return (FSV == NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector2DNotEqualVector2D(FSafeVector2D &FSV, FVector2D &NV) {
	return (FSV != NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector2DGreaterVector2D(FSafeVector2D &FSV, FVector2D &NV) {
	return (FSV > NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector2DSmallerVector2D(FSafeVector2D &FSV, FVector2D &NV) {
	return (FSV < NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector2DGreaterEqualVector2D(FSafeVector2D &FSV, FVector2D &NV) {
	return (FSV >= NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector2DSmallerEqualVector2D(FSafeVector2D &FSV, FVector2D &NV) {
	return (FSV <= NV);
}

FSafeVector2D USCLibrary::SCO_Pure_SetSafeVector2DEqualVector2D(FSafeVector2D &FSV, FVector2D &NV, FVector2D &Output) {
	FSV = NV; Output = FSV.GetValue(); return FSV;
}

FSafeVector2D USCLibrary::SCO_Pure_GetSafeVector2DPlusVector2D(FSafeVector2D &FSV, FVector2D &NV, FVector2D &Output) {
	Output = (FSV + NV).GetValue(); return FSafeVector2D(Output);
}

FSafeVector2D USCLibrary::SCO_Pure_GetSafeVector2DMinusVector2D(FSafeVector2D &FSV, FVector2D &NV, FVector2D &Output) {
	Output = (FSV - NV).GetValue(); return FSafeVector2D(Output);
}

FSafeVector2D USCLibrary::SCO_Pure_GetSafeVector2DTimesVector2D(FSafeVector2D &FSV, FVector2D &NV, FVector2D &Output) {
	Output = (FSV * NV).GetValue(); return FSafeVector2D(Output);
}

FSafeVector2D USCLibrary::SCO_Pure_GetSafeVector2DDivideVector2D(FSafeVector2D &FSV, FVector2D &NV, FVector2D &Output) {
	Output = (FSV / NV).GetValue(); return FSafeVector2D(Output);
}

FSafeVector2D USCLibrary::SCO_Pure_GetSafeVector2DModVector2D(FSafeVector2D &FSV, FVector2D &NV, FVector2D &Output) {
	Output = (FSV % NV).GetValue(); return FSafeVector2D(Output);
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_GetVector2DEqualFSV(FVector2D &NV, FSafeVector2D &FSV) {
	return (NV == FSV);
}

bool USCLibrary::SCO_Pure_GetVector2DNotEqualFSV(FVector2D &NV, FSafeVector2D &FSV) {
	return (NV != FSV);
}

bool USCLibrary::SCO_Pure_GetVector2DGreaterFSV(FVector2D &NV, FSafeVector2D &FSV) {
	return (NV > FSV);
}

bool USCLibrary::SCO_Pure_GetVector2DSmallerFSV(FVector2D &NV, FSafeVector2D &FSV) {
	return (NV < FSV);
}

bool USCLibrary::SCO_Pure_GetVector2DGreaterEqualFSV(FVector2D &NV, FSafeVector2D &FSV) {
	return (NV >= FSV);
}

bool USCLibrary::SCO_Pure_GetVector2DSmallerEqualFSV(FVector2D &NV, FSafeVector2D &FSV) {
	return (NV <= FSV);
}

FVector2D USCLibrary::SCO_Pure_SetVector2DEqualFSV(FVector2D &NV, FSafeVector2D &FSV) {
	NV = FSV.GetValue(); return NV;
}

FVector2D USCLibrary::SCO_Pure_GetVector2DPlusFSV(FVector2D &NV, FSafeVector2D &FSV) {
	return (NV + FSV);
}

FVector2D USCLibrary::SCO_Pure_GetVector2DMinusFSV(FVector2D &NV, FSafeVector2D &FSV) {
	return (NV - FSV);
}

FVector2D USCLibrary::SCO_Pure_GetVector2DTimesFSV(FVector2D &NV, FSafeVector2D &FSV) {
	return (NV * FSV);
}

FVector2D USCLibrary::SCO_Pure_GetVector2DDivideFSV(FVector2D &NV, FSafeVector2D &FSV) {
	return (NV / FSV);
}

FVector2D USCLibrary::SCO_Pure_GetVector2DModFSV(FVector2D &NV, FSafeVector2D &FSV) {
	return (NV % FSV);
}

// FSVector3D

/* FSafe -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeVector3DEqualFSV(FSafeVector3D &FSV, FSafeVector3D &SSV) {
	return (FSV == SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector3DNotEqualFSV(FSafeVector3D &FSV, FSafeVector3D &SSV) {
	return (FSV != SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector3DGreaterFSV(FSafeVector3D &FSV, FSafeVector3D &SSV) {
	return (FSV > SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector3DSmallerFSV(FSafeVector3D &FSV, FSafeVector3D &SSV) {
	return (FSV < SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector3DGreaterEqualFSV(FSafeVector3D &FSV, FSafeVector3D &SSV) {
	return (FSV >= SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector3DSmallerEqualFSV(FSafeVector3D &FSV, FSafeVector3D &SSV) {
	return (FSV <= SSV);
}

FSafeVector3D USCLibrary::SCO_Pure_SetSafeVector3DEqualFSV(FSafeVector3D &FSV, FSafeVector3D &SSV, FVector &Output) {
	FSV = SSV; Output = FSV.GetValue(); return FSV;
}

FSafeVector3D USCLibrary::SCO_Pure_GetSafeVector3DPlusFSV(FSafeVector3D &FSV, FSafeVector3D &SSV, FVector &Output) {
	Output = (FSV + SSV).GetValue(); return FSafeVector3D(Output);
}

FSafeVector3D USCLibrary::SCO_Pure_GetSafeVector3DMinusFSV(FSafeVector3D &FSV, FSafeVector3D &SSV, FVector &Output) {
	Output = (FSV - SSV).GetValue(); return FSafeVector3D(Output);
}

FSafeVector3D USCLibrary::SCO_Pure_GetSafeVector3DTimesFSV(FSafeVector3D &FSV, FSafeVector3D &SSV, FVector &Output) {
	Output = (FSV * SSV).GetValue(); return FSafeVector3D(Output);
}

FSafeVector3D USCLibrary::SCO_Pure_GetSafeVector3DDivideFSV(FSafeVector3D &FSV, FSafeVector3D &SSV, FVector &Output) {
	Output = (FSV / SSV).GetValue(); return FSafeVector3D(Output);
}

FSafeVector3D USCLibrary::SCO_Pure_GetSafeVector3DModFSV(FSafeVector3D &FSV, FSafeVector3D &SSV, FVector &Output) {
	Output = (FSV % SSV).GetValue(); return FSafeVector3D(Output);
}

/* Native -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeVector3DEqualVector3D(FSafeVector3D &FSV, FVector &NV) {
	return (FSV == NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector3DNotEqualVector3D(FSafeVector3D &FSV, FVector &NV) {
	return (FSV != NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector3DGreaterVector3D(FSafeVector3D &FSV, FVector &NV) {
	return (FSV > NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector3DSmallerVector3D(FSafeVector3D &FSV, FVector &NV) {
	return (FSV < NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector3DGreaterEqualVector3D(FSafeVector3D &FSV, FVector &NV) {
	return (FSV >= NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector3DSmallerEqualVector3D(FSafeVector3D &FSV, FVector &NV) {
	return (FSV <= NV);
}

FSafeVector3D USCLibrary::SCO_Pure_SetSafeVector3DEqualVector3D(FSafeVector3D &FSV, FVector &NV, FVector &Output) {
	FSV = NV; Output = FSV.GetValue(); return FSV;
}

FSafeVector3D USCLibrary::SCO_Pure_GetSafeVector3DPlusVector3D(FSafeVector3D &FSV, FVector &NV, FVector &Output) {
	Output = (FSV + NV).GetValue(); return FSafeVector3D(Output);
}

FSafeVector3D USCLibrary::SCO_Pure_GetSafeVector3DMinusVector3D(FSafeVector3D &FSV, FVector &NV, FVector &Output) {
	Output = (FSV - NV).GetValue(); return FSafeVector3D(Output);
}

FSafeVector3D USCLibrary::SCO_Pure_GetSafeVector3DTimesVector3D(FSafeVector3D &FSV, FVector &NV, FVector &Output) {
	Output = (FSV * NV).GetValue(); return FSafeVector3D(Output);
}

FSafeVector3D USCLibrary::SCO_Pure_GetSafeVector3DDivideVector3D(FSafeVector3D &FSV, FVector &NV, FVector &Output) {
	Output = (FSV / NV).GetValue(); return FSafeVector3D(Output);
}

FSafeVector3D USCLibrary::SCO_Pure_GetSafeVector3DModVector3D(FSafeVector3D &FSV, FVector &NV, FVector &Output) {
	Output = (FSV % NV).GetValue(); return FSafeVector3D(Output);
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_GetVector3DEqualFSV(FVector &NV, FSafeVector3D &FSV) {
	return (NV == FSV);
}

bool USCLibrary::SCO_Pure_GetVector3DNotEqualFSV(FVector &NV, FSafeVector3D &FSV) {
	return (NV != FSV);
}

bool USCLibrary::SCO_Pure_GetVector3DGreaterFSV(FVector &NV, FSafeVector3D &FSV) {
	return (NV > FSV);
}

bool USCLibrary::SCO_Pure_GetVector3DSmallerFSV(FVector &NV, FSafeVector3D &FSV) {
	return (NV < FSV);
}

bool USCLibrary::SCO_Pure_GetVector3DGreaterEqualFSV(FVector &NV, FSafeVector3D &FSV) {
	return (NV >= FSV);
}

bool USCLibrary::SCO_Pure_GetVector3DSmallerEqualFSV(FVector &NV, FSafeVector3D &FSV) {
	return (NV <= FSV);
}

FVector USCLibrary::SCO_Pure_SetVector3DEqualFSV(FVector &NV, FSafeVector3D &FSV) {
	NV = FSV.GetValue(); return NV;
}

FVector USCLibrary::SCO_Pure_GetVector3DPlusFSV(FVector &NV, FSafeVector3D &FSV) {
	return (NV + FSV);
}

FVector USCLibrary::SCO_Pure_GetVector3DMinusFSV(FVector &NV, FSafeVector3D &FSV) {
	return (NV - FSV);
}

FVector USCLibrary::SCO_Pure_GetVector3DTimesFSV(FVector &NV, FSafeVector3D &FSV) {
	return (NV * FSV);
}

FVector USCLibrary::SCO_Pure_GetVector3DDivideFSV(FVector &NV, FSafeVector3D &FSV) {
	return (NV / FSV);
}

FVector USCLibrary::SCO_Pure_GetVector3DModFSV(FVector &NV, FSafeVector3D &FSV) {
	return (NV % FSV);
}

// FSVector4D

/* FSafe -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeVector4DEqualFSV(FSafeVector4D &FSV, FSafeVector4D &SSV) {
	return (FSV == SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector4DNotEqualFSV(FSafeVector4D &FSV, FSafeVector4D &SSV) {
	return (FSV != SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector4DGreaterFSV(FSafeVector4D &FSV, FSafeVector4D &SSV) {
	return (FSV > SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector4DSmallerFSV(FSafeVector4D &FSV, FSafeVector4D &SSV) {
	return (FSV < SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector4DGreaterEqualFSV(FSafeVector4D &FSV, FSafeVector4D &SSV) {
	return (FSV >= SSV);
}

bool USCLibrary::SCO_Pure_GetSafeVector4DSmallerEqualFSV(FSafeVector4D &FSV, FSafeVector4D &SSV) {
	return (FSV <= SSV);
}

FSafeVector4D USCLibrary::SCO_Pure_SetSafeVector4DEqualFSV(FSafeVector4D &FSV, FSafeVector4D &SSV, FVector4 &Output) {
	FSV = SSV; Output = FSV.GetValue(); return FSV;
}

FSafeVector4D USCLibrary::SCO_Pure_GetSafeVector4DPlusFSV(FSafeVector4D &FSV, FSafeVector4D &SSV, FVector4 &Output) {
	Output = (FSV + SSV).GetValue(); return FSafeVector4D(&Output);
}

FSafeVector4D USCLibrary::SCO_Pure_GetSafeVector4DMinusFSV(FSafeVector4D &FSV, FSafeVector4D &SSV, FVector4 &Output) {
	Output = (FSV - SSV).GetValue(); return FSafeVector4D(&Output);
}

FSafeVector4D USCLibrary::SCO_Pure_GetSafeVector4DTimesFSV(FSafeVector4D &FSV, FSafeVector4D &SSV, FVector4 &Output) {
	Output = (FSV * SSV).GetValue(); return FSafeVector4D(&Output);
}

FSafeVector4D USCLibrary::SCO_Pure_GetSafeVector4DDivideFSV(FSafeVector4D &FSV, FSafeVector4D &SSV, FVector4 &Output) {
	Output = (FSV / SSV).GetValue(); return FSafeVector4D(&Output);
}

FSafeVector4D USCLibrary::SCO_Pure_GetSafeVector4DModFSV(FSafeVector4D &FSV, FSafeVector4D &SSV, FVector4 &Output) {
	Output = (FSV % SSV).GetValue(); return FSafeVector4D(&Output);
}

/* Native -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeVector4DEqualVector4D(FSafeVector4D &FSV, FVector4 &NV) {
	return (FSV == NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector4DNotEqualVector4D(FSafeVector4D &FSV, FVector4 &NV) {
	return (FSV != NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector4DGreaterVector4D(FSafeVector4D &FSV, FVector4 &NV) {
	return (FSV > NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector4DSmallerVector4D(FSafeVector4D &FSV, FVector4 &NV) {
	return (FSV < NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector4DGreaterEqualVector4D(FSafeVector4D &FSV, FVector4 &NV) {
	return (FSV >= NV);
}

bool USCLibrary::SCO_Pure_GetSafeVector4DSmallerEqualVector4D(FSafeVector4D &FSV, FVector4 &NV) {
	return (FSV <= NV);
}

FSafeVector4D USCLibrary::SCO_Pure_SetSafeVector4DEqualVector4D(FSafeVector4D &FSV, FVector4 &NV, FVector4 &Output) {
	FSV = NV; Output = FSV.GetValue(); return FSV;
}

FSafeVector4D USCLibrary::SCO_Pure_GetSafeVector4DPlusVector4D(FSafeVector4D &FSV, FVector4 &NV, FVector4 &Output) {
	Output = (FSV + NV).GetValue(); return FSafeVector4D(&Output);
}

FSafeVector4D USCLibrary::SCO_Pure_GetSafeVector4DMinusVector4D(FSafeVector4D &FSV, FVector4 &NV, FVector4 &Output) {
	Output = (FSV - NV).GetValue(); return FSafeVector4D(&Output);
}

FSafeVector4D USCLibrary::SCO_Pure_GetSafeVector4DTimesVector4D(FSafeVector4D &FSV, FVector4 &NV, FVector4 &Output) {
	Output = (FSV * NV).GetValue(); return FSafeVector4D(&Output);
}

FSafeVector4D USCLibrary::SCO_Pure_GetSafeVector4DDivideVector4D(FSafeVector4D &FSV, FVector4 &NV, FVector4 &Output) {
	Output = (FSV / NV).GetValue(); return FSafeVector4D(&Output);
}

FSafeVector4D USCLibrary::SCO_Pure_GetSafeVector4DModVector4D(FSafeVector4D &FSV, FVector4 &NV, FVector4 &Output) {
	Output = (FSV % NV).GetValue(); return FSafeVector4D(&Output);
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_GetVector4DEqualFSV(FVector4 &NV, FSafeVector4D &FSV) {
	return (NV == FSV);
}

bool USCLibrary::SCO_Pure_GetVector4DNotEqualFSV(FVector4 &NV, FSafeVector4D &FSV) {
	return (NV != FSV);
}

bool USCLibrary::SCO_Pure_GetVector4DGreaterFSV(FVector4 &NV, FSafeVector4D &FSV) {
	return (NV > FSV);
}

bool USCLibrary::SCO_Pure_GetVector4DSmallerFSV(FVector4 &NV, FSafeVector4D &FSV) {
	return (NV < FSV);
}

bool USCLibrary::SCO_Pure_GetVector4DGreaterEqualFSV(FVector4 &NV, FSafeVector4D &FSV) {
	return (NV >= FSV);
}

bool USCLibrary::SCO_Pure_GetVector4DSmallerEqualFSV(FVector4 &NV, FSafeVector4D &FSV) {
	return (NV <= FSV);
}

FVector4 USCLibrary::SCO_Pure_SetVector4DEqualFSV(FVector4 &NV, FSafeVector4D &FSV) {
	NV = FSV.GetValue(); return NV;
}

FVector4 USCLibrary::SCO_Pure_GetVector4DPlusFSV(FVector4 &NV, FSafeVector4D &FSV) {
	return (NV + FSV);
}

FVector4 USCLibrary::SCO_Pure_GetVector4DMinusFSV(FVector4 &NV, FSafeVector4D &FSV) {
	return (NV - FSV);
}

FVector4 USCLibrary::SCO_Pure_GetVector4DTimesFSV(FVector4 &NV, FSafeVector4D &FSV) {
	return (NV * FSV);
}

FVector4 USCLibrary::SCO_Pure_GetVector4DDivideFSV(FVector4 &NV, FSafeVector4D &FSV) {
	return (NV / FSV);
}

FVector4 USCLibrary::SCO_Pure_GetVector4DModFSV(FVector4 &NV, FSafeVector4D &FSV) {
	return (NV % FSV);
}

// FSColor

/* FSafe -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeColorEqualFSC(FSafeColor &FSC, FSafeColor &SSC) {
	return (FSC == SSC);
}

bool USCLibrary::SCO_Pure_GetSafeColorNotEqualFSC(FSafeColor &FSC, FSafeColor &SSC) {
	return (FSC != SSC);
}

FSafeColor USCLibrary::SCO_Pure_SetSafeColorEqualFSC(FSafeColor &FSC, FSafeColor &SSC, FLinearColor &Output) {
	FSC = SSC; Output = FSC.GetValue(); return FSC;
}

/* Native -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeColorEqualColor(FSafeColor &FSC, FLinearColor &NC) {
	return (FSC == NC);
}

bool USCLibrary::SCO_Pure_GetSafeColorNotEqualColor(FSafeColor &FSC, FLinearColor &NC) {
	return (FSC != NC);
}

FSafeColor USCLibrary::SCO_Pure_SetSafeColorEqualColor(FSafeColor &FSC, FLinearColor &NC, FLinearColor &Output) {
	FSC = NC; Output = FSC.GetValue(); return FSC;
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_GetColorEqualFSC(FLinearColor &NC, FSafeColor &FSC) {
	return (NC == FSC);
}

bool USCLibrary::SCO_Pure_GetColorNotEqualFSC(FLinearColor &NC, FSafeColor &FSC) {
	return (NC != FSC);
}

FLinearColor USCLibrary::SCO_Pure_SetColorEqualFSC(FLinearColor &NC, FSafeColor &FSC) {
	NC = FSC.GetValue(); return NC;
}

// FSRotator

/* FSafe -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeRotatorEqualFSR(FSafeRotator &FSR, FSafeRotator &SSR) {
	return (FSR == SSR);
}

bool USCLibrary::SCO_Pure_GetSafeRotatorNotEqualFSR(FSafeRotator &FSR, FSafeRotator &SSR) {
	return (FSR != SSR);
}

bool USCLibrary::SCO_Pure_GetSafeRotatorGreaterFSR(FSafeRotator &FSR, FSafeRotator &SSR) {
	return (FSR > SSR);
}

bool USCLibrary::SCO_Pure_GetSafeRotatorSmallerFSR(FSafeRotator &FSR, FSafeRotator &SSR) {
	return (FSR < SSR);
}

bool USCLibrary::SCO_Pure_GetSafeRotatorGreaterEqualFSR(FSafeRotator &FSR, FSafeRotator &SSR) {
	return (FSR >= SSR);
}

bool USCLibrary::SCO_Pure_GetSafeRotatorSmallerEqualFSR(FSafeRotator &FSR, FSafeRotator &SSR) {
	return (FSR <= SSR);
}

FSafeRotator USCLibrary::SCO_Pure_SetSafeRotatorEqualFSR(FSafeRotator &FSR, FSafeRotator &SSR, FRotator &Output) {
	FSR = SSR; Output = FSR.GetValue(); return FSR;
}

FSafeRotator USCLibrary::SCO_Pure_GetSafeRotatorPlusFSR(FSafeRotator &FSR, FSafeRotator &SSR, FRotator &Output) {
	Output = (FSR + SSR).GetValue(); return FSafeRotator(Output);
}

FSafeRotator USCLibrary::SCO_Pure_GetSafeRotatorMinusFSR(FSafeRotator &FSR, FSafeRotator &SSR, FRotator &Output) {
	Output = (FSR - SSR).GetValue(); return FSafeRotator(Output);
}

FSafeRotator USCLibrary::SCO_Pure_GetSafeRotatorTimesFSR(FSafeRotator &FSR, FSafeRotator &SSR, FRotator &Output) {
	Output = (FSR * SSR).GetValue(); return FSafeRotator(Output);
}

FSafeRotator USCLibrary::SCO_Pure_GetSafeRotatorDivideFSR(FSafeRotator &FSR, FSafeRotator &SSR, FRotator &Output) {
	Output = (FSR / SSR).GetValue(); return FSafeRotator(Output);
}

FSafeRotator USCLibrary::SCO_Pure_GetSafeRotatorModFSR(FSafeRotator &FSR, FSafeRotator &SSR, FRotator &Output) {
	Output = (FSR % SSR).GetValue(); return FSafeRotator(Output);
}

/* Native -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeRotatorEqualRotator(FSafeRotator &FSR, FRotator &NR) {
	return (FSR == NR);
}

bool USCLibrary::SCO_Pure_GetSafeRotatorNotEqualRotator(FSafeRotator &FSR, FRotator &NR) {
	return (FSR != NR);
}

bool USCLibrary::SCO_Pure_GetSafeRotatorGreaterRotator(FSafeRotator &FSR, FRotator &NR) {
	return (FSR > NR);
}

bool USCLibrary::SCO_Pure_GetSafeRotatorSmallerRotator(FSafeRotator &FSR, FRotator &NR) {
	return (FSR < NR);
}

bool USCLibrary::SCO_Pure_GetSafeRotatorGreaterEqualRotator(FSafeRotator &FSR, FRotator &NR) {
	return (FSR >= NR);
}

bool USCLibrary::SCO_Pure_GetSafeRotatorSmallerEqualRotator(FSafeRotator &FSR, FRotator &NR) {
	return (FSR <= NR);
}

FSafeRotator USCLibrary::SCO_Pure_SetSafeRotatorEqualRotator(FSafeRotator &FSR, FRotator &NR, FRotator &Output) {
	FSR = NR; Output = FSR.GetValue(); return FSR;
}

FSafeRotator USCLibrary::SCO_Pure_GetSafeRotatorPlusRotator(FSafeRotator &FSR, FRotator &NR, FRotator &Output) {
	Output = (FSR + NR).GetValue(); return FSafeRotator(Output);
}

FSafeRotator USCLibrary::SCO_Pure_GetSafeRotatorMinusRotator(FSafeRotator &FSR, FRotator &NR, FRotator &Output) {
	Output = (FSR - NR).GetValue(); return FSafeRotator(Output);
}

FSafeRotator USCLibrary::SCO_Pure_GetSafeRotatorTimesRotator(FSafeRotator &FSR, FRotator &NR, FRotator &Output) {
	Output = (FSR * NR).GetValue(); return FSafeRotator(Output);
}

FSafeRotator USCLibrary::SCO_Pure_GetSafeRotatorDivideRotator(FSafeRotator &FSR, FRotator &NR, FRotator &Output) {
	Output = (FSR / NR).GetValue(); return FSafeRotator(Output);
}

FSafeRotator USCLibrary::SCO_Pure_GetSafeRotatorModRotator(FSafeRotator &FSR, FRotator &NR, FRotator &Output) {
	Output = (FSR % NR).GetValue(); return FSafeRotator(Output);
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_GetRotatorEqualFSR(FRotator &NR, FSafeRotator &FSR) {
	return (NR == FSR);
}

bool USCLibrary::SCO_Pure_GetRotatorNotEqualFSR(FRotator &NR, FSafeRotator &FSR) {
	return (NR != FSR);
}

bool USCLibrary::SCO_Pure_GetRotatorGreaterFSR(FRotator &NR, FSafeRotator &FSR) {
	return (NR > FSR);
}

bool USCLibrary::SCO_Pure_GetRotatorSmallerFSR(FRotator &NR, FSafeRotator &FSR) {
	return (NR < FSR);
}

bool USCLibrary::SCO_Pure_GetRotatorGreaterEqualFSR(FRotator &NR, FSafeRotator &FSR) {
	return (NR >= FSR);
}

bool USCLibrary::SCO_Pure_GetRotatorSmallerEqualFSR(FRotator &NR, FSafeRotator &FSR) {
	return (NR <= FSR);
}

FRotator USCLibrary::SCO_Pure_SetRotatorEqualFSR(FRotator &NR, FSafeRotator &FSR) {
	NR = FSR.GetValue(); return NR;
}

FRotator USCLibrary::SCO_Pure_GetRotatorPlusFSR(FRotator &NR, FSafeRotator &FSR) {
	return (NR + FSR);
}

FRotator USCLibrary::SCO_Pure_GetRotatorMinusFSR(FRotator &NR, FSafeRotator &FSR) {
	return (NR - FSR);
}

FRotator USCLibrary::SCO_Pure_GetRotatorTimesFSR(FRotator &NR, FSafeRotator &FSR) {
	return (NR * FSR);
}

FRotator USCLibrary::SCO_Pure_GetRotatorDivideFSR(FRotator &NR, FSafeRotator &FSR) {
	return (NR / FSR);
}

FRotator USCLibrary::SCO_Pure_GetRotatorModFSR(FRotator &NR, FSafeRotator &FSR) {
	return (NR % FSR);
}

// FSTransform

/* FSafe -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeTransformEqualFST(FSafeTransform &FST, FSafeTransform &SST) {
	return (FST == SST);
}

bool USCLibrary::SCO_Pure_GetSafeTransformNotEqualFST(FSafeTransform &FST, FSafeTransform &SST) {
	return (FST != SST);
}

FSafeTransform USCLibrary::SCO_Pure_SetSafeTransformEqualFST(FSafeTransform &FST, FSafeTransform &SST, FTransform &Output) {
	FST = SST; Output = FST.GetValue(); return FST;
}

/* Native -> FSafe */

bool USCLibrary::SCO_Pure_GetSafeTransformEqualTransform(FSafeTransform &FST, FTransform &NT) {
	return (FST == NT);
}

bool USCLibrary::SCO_Pure_GetSafeTransformNotEqualTransform(FSafeTransform &FST, FTransform &NT) {
	return (FST != NT);
}

FSafeTransform USCLibrary::SCO_Pure_SetSafeTransformEqualTransform(FSafeTransform &FST, FTransform &NT, FTransform &Output) {
	FST = NT; Output = FST.GetValue(); return FST;
}

/* FSafe -> Native */

bool USCLibrary::SCO_Pure_GetTransformEqualFST(FTransform &NT, FSafeTransform &FST) {
	return (NT == FST);
}

bool USCLibrary::SCO_Pure_GetTransformNotEqualFST(FTransform &NT, FSafeTransform &FST) {
	return (NT != FST);
}

FTransform USCLibrary::SCO_Pure_SetTransformEqualFST(FTransform &NT, FSafeTransform &FST) {
	NT = FST.GetValue(); return NT;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/SCUE4/Private/Blueprints/SCLibrary.h`:

```h
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//		Copyright 2016 (C) Bruno Xavier B. Leite
//////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "SCUE4.h"
#include "Runtime/CoreUObject/Public/UObject/TextProperty.h"
#include "Runtime/Engine/Classes/Kismet/BlueprintFunctionLibrary.h"
#include "SCLibrary.generated.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

UCLASS()
class SCUE4_API USCLibrary : public UBlueprintFunctionLibrary {
	GENERATED_BODY()
public:

	/** Pure:: Gets hidden value from 'Safe Bool Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Bool", Keywords = "Security Get Safe Bool"))
	static bool SCL_Pure_GetSafeBool(UPARAM(Ref)FSafeBool &SB);
	//
	/** Pure:: Gets hidden value from 'Safe Bool Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Bool", Keywords = "Security Get Safe Bool"))
	static bool SCL_Pure_GetSafeBoolWithKey(UPARAM(Ref)FSafeBool &SB, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Bool Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Bool", Keywords = "Security Get Safe Bool"))
	static bool SCL_Pure_SetSafeBool(UPARAM(Ref)FSafeBool &SB, const bool Value);
	//
	/**	Pure:: Sets, and hides in memory, value for 'Safe Bool Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Bool", Keywords = "Security Get Safe Bool"))
	static bool SCL_Pure_SetSafeBoolWithKey(UPARAM(Ref)FSafeBool &SB, FString Key, const bool Value);

	//

	/** Pure:: Gets hidden value from 'Safe Int Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Int", Keywords = "Security Get Safe Int"))
	static int32 SCL_Pure_GetSafeInt(UPARAM(Ref)FSafeInt &SI);
	//
	/**	Pure:: Gets hidden value from 'Safe Int Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Int", Keywords = "Security Get Safe Int"))
	static int32 SCL_Pure_GetSafeIntWithKey(UPARAM(Ref)FSafeInt &SI, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Int Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Int", Keywords = "Security Get Safe Int"))
	static int32 SCL_Pure_SetSafeInt(UPARAM(Ref)FSafeInt &SI, const int32 Value);
	//
	/**	Pure:: Sets, and hides in memory, value for 'Safe Int Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Int", Keywords = "Security Get Safe Int"))
	static int32 SCL_Pure_SetSafeIntWithKey(UPARAM(Ref)FSafeInt &SI, FString Key, const int32 Value);

	//
	
	/** Pure:: Gets hidden value from 'Safe Byte Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Byte", Keywords = "Security Get Safe Byte"))
	static uint8 SCL_Pure_GetSafeByte(UPARAM(Ref)FSafeByte &SB);
	//
	/**	Pure:: Gets hidden value from 'Safe Byte Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Byte", Keywords = "Security Get Safe Byte"))
	static uint8 SCL_Pure_GetSafeByteWithKey(UPARAM(Ref)FSafeByte &SB, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Byte Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Byte", Keywords = "Security Get Safe Byte"))
	static uint8 SCL_Pure_SetSafeByte(UPARAM(Ref)FSafeByte &SB, const uint8 Value);
	//
	/**	Pure:: Sets, and hides in memory, value for 'Safe Byte Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Byte", Keywords = "Security Get Safe Byte"))
	static uint8 SCL_Pure_SetSafeByteWithKey(UPARAM(Ref)FSafeByte &SB, FString Key, const uint8 Value);

	//
	
	/** Pure:: Gets hidden value from 'Safe Float Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Float", Keywords = "Security Get Safe Float"))
	static float SCL_Pure_GetSafeFloat(UPARAM(Ref)FSafeFloat &SF);
	//
	/**	Pure:: Gets hidden value from 'Safe Float Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Float", Keywords = "Security Get Safe Float"))
	static float SCL_Pure_GetSafeFloatWithKey(UPARAM(Ref)FSafeFloat &SF, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Float Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Float", Keywords = "Security Get Safe Float"))
	static float SCL_Pure_SetSafeFloat(UPARAM(Ref)FSafeFloat &SF, const float Value);
	//
	/**	Pure:: Sets, and hides in memory, value for 'Safe Float Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Float", Keywords = "Security Get Safe Float"))
	static float SCL_Pure_SetSafeFloatWithKey(UPARAM(Ref)FSafeFloat &SF, FString Key, const float Value);

	//
	
	/** Pure:: Gets hidden value from 'Safe Name Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Name", Keywords = "Security Get Safe Name"))
	static FName SCL_Pure_GetSafeName(UPARAM(Ref)FSafeName &SN);
	//
	/**	Pure:: Gets hidden value from 'Safe Name Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Name", Keywords = "Security Get Safe Name"))
	static FName SCL_Pure_GetSafeNameWithKey(UPARAM(Ref)FSafeName &SN, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Name Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Name", Keywords = "Security Get Safe Name"))
	static FName SCL_Pure_SetSafeName(UPARAM(Ref)FSafeName &SN, const FName Value);
	//
	/**	Pure:: Sets, and hides in memory, value for 'Safe Name Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Name", Keywords = "Security Get Safe Name"))
	static FName SCL_Pure_SetSafeNameWithKey(UPARAM(Ref)FSafeName &SN, FString Key, const FName Value);

	//
	
	/** Pure:: Gets hidden value from 'Safe String Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe String", Keywords = "Security Get Safe String"))
	static FString SCL_Pure_GetSafeString(UPARAM(Ref)FSafeString &SS);
	//
	/**	Pure:: Gets hidden value from 'Safe String Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe String", Keywords = "Security Get Safe String"))
	static FString SCL_Pure_GetSafeStringWithKey(UPARAM(Ref)FSafeString &SS, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe String Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe String", Keywords = "Security Get Safe String"))
	static FString SCL_Pure_SetSafeString(UPARAM(Ref)FSafeString &SS, const FString Value);
	//
	/**	Pure:: Sets, and hides in memory, value for 'Safe String Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe String", Keywords = "Security Get Safe String"))
	static FString SCL_Pure_SetSafeStringWithKey(UPARAM(Ref)FSafeString &SS, FString Key, const FString Value);

	//
	
	/** Pure:: Gets hidden value from 'Safe Text Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Text", Keywords = "Security Get Safe Text"))
	static FText SCL_Pure_GetSafeText(UPARAM(Ref)FSafeText &ST);
	//
	/**	Pure:: Gets hidden value from 'Safe Text Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Text", Keywords = "Security Get Safe Text"))
	static FText SCL_Pure_GetSafeTextWithKey(UPARAM(Ref)FSafeText &ST, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Text Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Text", Keywords = "Security Get Safe Text"))
	static FText SCL_Pure_SetSafeText(UPARAM(Ref)FSafeText &ST, const FText Value);
	//
	/**	Pure:: Sets, and hides in memory, value for 'Safe Text Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Text", Keywords = "Security Get Safe Text"))
	static FText SCL_Pure_SetSafeTextWithKey(UPARAM(Ref)FSafeText &ST, FString Key, const FText Value);

	//
	
	/** Pure:: Gets hidden value from 'Safe Vector2D Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Vector2D", Keywords = "Security Get Safe Vector2D"))
	static FVector2D SCL_Pure_GetSafeVector2D(UPARAM(Ref)FSafeVector2D &SV);
	//
	/**	Pure:: Gets hidden value from 'Safe Vector2D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Vector2D", Keywords = "Security Get Safe Vector2D"))
	static FVector2D SCL_Pure_GetSafeVector2DWithKey(UPARAM(Ref)FSafeVector2D &SV, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Vector2D Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Vector2D", Keywords = "Security Get Safe Vector2D"))
	static FVector2D SCL_Pure_SetSafeVector2D(UPARAM(Ref)FSafeVector2D &SV, const FVector2D Value);
	//
	/**	Pure:: Sets, and hides in memory, value for 'Safe Vector2D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Vector2D", Keywords = "Security Get Safe Vector2D"))
	static FVector2D SCL_Pure_SetSafeVector2DWithKey(UPARAM(Ref)FSafeVector2D &SV, FString Key, const FVector2D Value);

	//
	
	/** Pure:: Gets hidden value from 'Safe Vector3D Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Vector3D", Keywords = "Security Get Safe Vector3D"))
	static FVector SCL_Pure_GetSafeVector3D(UPARAM(Ref)FSafeVector3D &SV);
	//
	/**	Pure:: Gets hidden value from 'Safe Vector3D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Vector3D", Keywords = "Security Get Safe Vector3D"))
	static FVector SCL_Pure_GetSafeVector3DWithKey(UPARAM(Ref)FSafeVector3D &SV, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Vector3D Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Vector3D", Keywords = "Security Get Safe Vector3D"))
	static FVector SCL_Pure_SetSafeVector3D(UPARAM(Ref)FSafeVector3D &SV, const FVector Value);
	//
	/**	Pure:: Sets, and hides in memory, value for 'Safe Vector3D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Vector3D", Keywords = "Security Get Safe Vector3D"))
	static FVector SCL_Pure_SetSafeVector3DWithKey(UPARAM(Ref)FSafeVector3D &SV, FString Key, const FVector Value);

	//
	
	/** Pure:: Gets hidden value from 'Safe Vector4D Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Vector4D", Keywords = "Security Get Safe Vector4D"))
	static FVector4 SCL_Pure_GetSafeVector4D(UPARAM(Ref)FSafeVector4D &SV);
	//
	/**	Pure:: Gets hidden value from 'Safe Vector4D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Vector4D", Keywords = "Security Get Safe Vector4D"))
	static FVector4 SCL_Pure_GetSafeVector4DWithKey(UPARAM(Ref)FSafeVector4D &SV, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Vector4D Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Vector4D", Keywords = "Security Get Safe Vector4D"))
	static FVector4 SCL_Pure_SetSafeVector4D(UPARAM(Ref)FSafeVector4D &SV, UPARAM(Ref)FVector4 &Value);
	//
	/**	Pure:: Sets, and hides in memory, value for 'Safe Vector4D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Vector4D", Keywords = "Security Get Safe Vector4D"))
	static FVector4 SCL_Pure_SetSafeVector4DWithKey(UPARAM(Ref)FSafeVector4D &SV, FString Key, UPARAM(Ref)FVector4 &Value);

	//
	
	/** Pure:: Gets hidden value from 'Safe Color Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Color", Keywords = "Security Get Safe Color"))
	static FLinearColor SCL_Pure_GetSafeColor(UPARAM(Ref)FSafeColor &SC);
	//
	/**	Pure:: Gets hidden value from 'Safe Color Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Color", Keywords = "Security Get Safe Color"))
	static FLinearColor SCL_Pure_GetSafeColorWithKey(UPARAM(Ref)FSafeColor &SC, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Color Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Color", Keywords = "Security Get Safe Color"))
	static FLinearColor SCL_Pure_SetSafeColor(UPARAM(Ref)FSafeColor &SC, UPARAM(Ref)FLinearColor& Value);
	//
	/**	Pure:: Sets, and hides in memory, value for 'Safe Color Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Color", Keywords = "Security Get Safe Color"))
	static FLinearColor SCL_Pure_SetSafeColorWithKey(UPARAM(Ref)FSafeColor &SC, FString Key, UPARAM(Ref)FLinearColor& Value);

	//
	
	/** Pure:: Gets hidden value from 'Safe Rotator Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Rotator", Keywords = "Security Get Safe Rotator"))
	static FRotator SCL_Pure_GetSafeRotator(UPARAM(Ref)FSafeRotator &SR);
	//
	/**	Pure:: Gets hidden value from 'Safe Rotator Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Rotator", Keywords = "Security Get Safe Rotator"))
	static FRotator SCL_Pure_GetSafeRotatorWithKey(UPARAM(Ref)FSafeRotator &SR, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Rotator Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Rotator", Keywords = "Security Get Safe Rotator"))
	static FRotator SCL_Pure_SetSafeRotator(UPARAM(Ref)FSafeRotator &SR, const FRotator Value);
	//
	/**	Pure:: Sets, and hides in memory, value for 'Safe Rotator Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Rotator", Keywords = "Security Get Safe Rotator"))
	static FRotator SCL_Pure_SetSafeRotatorWithKey(UPARAM(Ref)FSafeRotator &SR, FString Key, const FRotator Value);

	//
	
	/** Pure:: Gets hidden value from 'Safe Transform Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Transform", Keywords = "Security Get Safe Transform"))
	static FTransform SCL_Pure_GetSafeTransform(UPARAM(Ref)FSafeTransform &ST);
	//
	/** Pure:: Gets hidden value from 'Safe Transform Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Get Safe Transform", Keywords = "Security Get Safe Transform"))
	static FTransform SCL_Pure_GetSafeTransformWithKey(UPARAM(Ref)FSafeTransform &ST, FString Key);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Transform Struct'. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Transform", Keywords = "Security Get Safe Transform"))
	static FTransform SCL_Pure_SetSafeTransform(UPARAM(Ref)FSafeTransform &ST, UPARAM(Ref)FTransform &Value);
	//
	/** Pure:: Sets, and hides in memory, value for 'Safe Transform Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintPure, Category = "Security", meta = (DisplayName = "Set Safe Transform", Keywords = "Security Get Safe Transform"))
	static FTransform SCL_Pure_SetSafeTransformWithKey(UPARAM(Ref)FSafeTransform &ST, FString Key, UPARAM(Ref)FTransform &Value);

	//
	//
	
	/** Callable:: Gets raw value from 'Safe Bool Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Bool (Raw Value)", Keywords = "Security Get Safe Bool"))
	static FString SCL_Callable_GetRawSafeBool(UPARAM(Ref)FSafeBool &SB);
	//
	/** Callable:: Gets hidden value from 'Safe Bool Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Bool", Keywords = "Security Get Safe Bool"))
	static bool SCL_Callable_GetSafeBool(UPARAM(Ref)FSafeBool &SB);
	//
	/**	Callable:: Gets hidden value from 'Safe Bool Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Bool", Keywords = "Security Get Safe Bool"))
	static bool SCL_Callable_GetSafeBoolWithKey(UPARAM(Ref)FSafeBool &SB, FString Key);
	//
	/** Callable:: Sets, and hides in memory, raw value for 'Safe Bool Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Bool (Raw Value)", Keywords = "Security Get Safe Bool"))
	static bool SCL_Callable_SetRawSafeBool(UPARAM(Ref)FSafeBool &SB, FString Value);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Bool Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Bool", Keywords = "Security Get Safe Bool"))
	static bool SCL_Callable_SetSafeBool(UPARAM(Ref)FSafeBool &SB, const bool Value);
	//
	/**	Callable:: Sets, and hides in memory, value for 'Safe Bool Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Bool", Keywords = "Security Get Safe Bool"))
	static bool SCL_Callable_SetSafeBoolWithKey(UPARAM(Ref)FSafeBool &SB, FString Key, const bool Value);

	//

	/** Callable:: Gets raw value from 'Safe Int Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Int (Raw Value)", Keywords = "Security Get Safe Int"))
	static FString SCL_Callable_GetRawSafeInt(UPARAM(Ref)FSafeInt &SI);
	//
	/** Callable:: Gets hidden value from 'Safe Int Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Int", Keywords = "Security Get Safe Int"))
	static int32 SCL_Callable_GetSafeInt(UPARAM(Ref)FSafeInt &SI);
	//
	/**	Gets hidden value from 'Safe Int Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Int", Keywords = "Security Get Safe Int"))
	static int32 SCL_Callable_GetSafeIntWithKey(UPARAM(Ref)FSafeInt &SI, FString Key);
	//
	/** Callable:: Sets, and hides in memory, raw value for 'Safe Int Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Int (Raw Value)", Keywords = "Security Get Safe Int"))
	static int32 SCL_Callable_SetRawSafeInt(UPARAM(Ref)FSafeInt &SI, FString Value);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Int Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Int", Keywords = "Security Get Safe Int"))
	static int32 SCL_Callable_SetSafeInt(UPARAM(Ref)FSafeInt &SI, const int32 Value);
	//
	/**	Callable:: Sets, and hides in memory, value for 'Safe Int Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Int", Keywords = "Security Get Safe Int"))
	static int32 SCL_Callable_SetSafeIntWithKey(UPARAM(Ref)FSafeInt &SI, FString Key, const int32 Value);

	//
	
	/** Callable:: Gets raw value from 'Safe Byte Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Byte (Raw Value)", Keywords = "Security Get Safe Byte"))
	static FString SCL_Callable_GetRawSafeByte(UPARAM(Ref)FSafeByte &SB);
	//
	/** Callable:: Gets hidden value from 'Safe Byte Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Byte", Keywords = "Security Get Safe Byte"))
	static uint8 SCL_Callable_GetSafeByte(UPARAM(Ref)FSafeByte &SB);
	//
	/**	Gets hidden value from 'Safe Byte Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Byte", Keywords = "Security Get Safe Byte"))
	static uint8 SCL_Callable_GetSafeByteWithKey(UPARAM(Ref)FSafeByte &SB, FString Key);
	//
	/** Callable:: Sets, and hides in memory, raw value for 'Safe Byte Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Byte (Raw Value)", Keywords = "Security Get Safe Byte"))
	static uint8 SCL_Callable_SetRawSafeByte(UPARAM(Ref)FSafeByte &SB, FString Value);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Byte Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Byte", Keywords = "Security Get Safe Byte"))
	static uint8 SCL_Callable_SetSafeByte(UPARAM(Ref)FSafeByte &SB, const uint8 Value);
	//
	/**	Callable:: Sets, and hides in memory, value for 'Safe Byte Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Byte", Keywords = "Security Get Safe Byte"))
	static uint8 SCL_Callable_SetSafeByteWithKey(UPARAM(Ref)FSafeByte &SB, FString Key, const uint8 Value);

	//
	
	/** Callable:: Gets raw value from 'Safe Float Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Float (Raw Value)", Keywords = "Security Get Safe Float"))
	static FString SCL_Callable_GetRawSafeFloat(UPARAM(Ref)FSafeFloat &SF);
	//
	/** Callable:: Gets hidden value from 'Safe Float Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Float", Keywords = "Security Get Safe Float"))
	static float SCL_Callable_GetSafeFloat(UPARAM(Ref)FSafeFloat &SF);
	//
	/**	Callable:: Gets hidden value from 'Safe Float Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Float", Keywords = "Security Get Safe Float"))
	static float SCL_Callable_GetSafeFloatWithKey(UPARAM(Ref)FSafeFloat &SF, FString Key);
	//
	/** Callable:: Sets, and hides in memory, raw value for 'Safe Float Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Float (Raw Value)", Keywords = "Security Get Safe Float"))
	static float SCL_Callable_SetRawSafeFloat(UPARAM(Ref)FSafeFloat &SF, FString Value);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Float Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Float", Keywords = "Security Get Safe Float"))
	static float SCL_Callable_SetSafeFloat(UPARAM(Ref)FSafeFloat &SF, const float Value);
	//
	/**	Callable:: Sets, and hides in memory, value for 'Safe Float Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Float", Keywords = "Security Get Safe Float"))
	static float SCL_Callable_SetSafeFloatWithKey(UPARAM(Ref)FSafeFloat &SF, FString Key, const float Value);

	//
	
	/** Callable:: Gets raw value from 'Safe Name Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Name (Raw Value)", Keywords = "Security Get Safe Name"))
	static FString SCL_Callable_GetRawSafeName(UPARAM(Ref)FSafeName &SN);
	//
	/** Callable:: Gets hidden value from 'Safe Name Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Name", Keywords = "Security Get Safe Name"))
	static FName SCL_Callable_GetSafeName(UPARAM(Ref)FSafeName &SN);
	//
	/**	Callable:: Gets hidden value from 'Safe Name Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Name", Keywords = "Security Get Safe Name"))
	static FName SCL_Callable_GetSafeNameWithKey(UPARAM(Ref)FSafeName &SN, FString Key);
	//
	/** Callable:: Sets, and hides in memory, raw value for 'Safe Name Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Name (Raw Value)", Keywords = "Security Get Safe Name"))
	static FName SCL_Callable_SetRawSafeName(UPARAM(Ref)FSafeName &SN, FString Value);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Name Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Name", Keywords = "Security Get Safe Name"))
	static FName SCL_Callable_SetSafeName(UPARAM(Ref)FSafeName &SN, const FName Value);
	//
	/**	Callable:: Sets, and hides in memory, value for 'Safe Name Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Name", Keywords = "Security Get Safe Name"))
	static FName SCL_Callable_SetSafeNameWithKey(UPARAM(Ref)FSafeName &SN, FString Key, const FName Value);

	//
	
	/** Callable:: Gets raw value from 'Safe String Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe String (Raw Value)", Keywords = "Security Get Safe String"))
	static FString SCL_Callable_GetRawSafeString(UPARAM(Ref)FSafeString &SS);
	//
	/** Callable:: Gets hidden value from 'Safe String Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe String", Keywords = "Security Get Safe String"))
	static FString SCL_Callable_GetSafeString(UPARAM(Ref)FSafeString &SS);
	//
	/**	Callable:: Gets hidden value from 'Safe String Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe String", Keywords = "Security Get Safe String"))
	static FString SCL_Callable_GetSafeStringWithKey(UPARAM(Ref)FSafeString &SS, FString Key);
	//
	/** Callable:: Sets, and hides in memory, raw value for 'Safe String Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe String (Raw Value)", Keywords = "Security Get Safe String"))
	static FString SCL_Callable_SetRawSafeString(UPARAM(Ref)FSafeString &SS, FString Value);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe String Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe String", Keywords = "Security Get Safe String"))
	static FString SCL_Callable_SetSafeString(UPARAM(Ref)FSafeString &SS, FString Value);
	//
	/**	Callable:: Sets, and hides in memory, value for 'Safe String Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe String", Keywords = "Security Get Safe String"))
	static FString SCL_Callable_SetSafeStringWithKey(UPARAM(Ref)FSafeString &SS, FString Key, FString Value);

	//
	
	/** Callable:: Gets raw value from 'Safe Text Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Text (Raw Value)", Keywords = "Security Get Safe Text"))
	static FString SCL_Callable_GetRawSafeText(UPARAM(Ref)FSafeText &ST);
	//
	/** Callable:: Gets hidden value from 'Safe Text Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Text", Keywords = "Security Get Safe Text"))
	static FText SCL_Callable_GetSafeText(UPARAM(Ref)FSafeText &ST);
	//
	/**	Callable:: Gets hidden value from 'Safe Text Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Text", Keywords = "Security Get Safe Text"))
	static FText SCL_Callable_GetSafeTextWithKey(UPARAM(Ref)FSafeText &ST, FString Key);
	//
	/** Callable:: Sets, and hides in memory, raw value for 'Safe Text Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Text (Raw Value)", Keywords = "Security Get Safe Text"))
	static FText SCL_Callable_SetRawSafeText(UPARAM(Ref)FSafeText &ST, FString Value);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Text Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Text", Keywords = "Security Get Safe Text"))
	static FText SCL_Callable_SetSafeText(UPARAM(Ref)FSafeText &ST, const FText Value);
	//
	/**	Callable:: Sets, and hides in memory, value for 'Safe Text Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Text", Keywords = "Security Get Safe Text"))
	static FText SCL_Callable_SetSafeTextWithKey(UPARAM(Ref)FSafeText &ST, FString Key, const FText Value);

	//
	
	/** Callable:: Gets hidden value from 'Safe Vector2D Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Vector2D", Keywords = "Security Get Safe Vector2D"))
	static FVector2D SCL_Callable_GetSafeVector2D(UPARAM(Ref)FSafeVector2D &SV);
	//
	/**	Callable:: Gets hidden value from 'Safe Vector2D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Vector2D", Keywords = "Security Get Safe Vector2D"))
	static FVector2D SCL_Callable_GetSafeVector2DWithKey(UPARAM(Ref)FSafeVector2D &SV, FString Key);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Vector2D Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Vector2D", Keywords = "Security Get Safe Vector2D"))
	static FVector2D SCL_Callable_SetSafeVector2D(UPARAM(Ref)FSafeVector2D &SV, const FVector2D Value);
	//
	/**	Callable:: Sets, and hides in memory, value for 'Safe Vector2D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Vector2D", Keywords = "Security Get Safe Vector2D"))
	static FVector2D SCL_Callable_SetSafeVector2DWithKey(UPARAM(Ref)FSafeVector2D &SV, FString Key, const FVector2D Value);

	//
	
	/** Callable:: Gets hidden value from 'Safe Vector3D Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Vector3D", Keywords = "Security Get Safe Vector3D"))
	static FVector SCL_Callable_GetSafeVector3D(UPARAM(Ref)FSafeVector3D &SV);
	//
	/**	Callable:: Gets hidden value from 'Safe Vector3D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Vector3D", Keywords = "Security Get Safe Vector3D"))
	static FVector SCL_Callable_GetSafeVector3DWithKey(UPARAM(Ref)FSafeVector3D &SV, FString Key);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Vector3D Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Vector3D", Keywords = "Security Get Safe Vector3D"))
	static FVector SCL_Callable_SetSafeVector3D(UPARAM(Ref)FSafeVector3D &SV, const FVector Value);
	//
	/**	Callable:: Sets, and hides in memory, value for 'Safe Vector3D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Vector3D", Keywords = "Security Get Safe Vector3D"))
	static FVector SCL_Callable_SetSafeVector3DWithKey(UPARAM(Ref)FSafeVector3D &SV, FString Key, const FVector Value);

	//
	
	/** Callable:: Gets hidden value from 'Safe Vector4D Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Vector4D", Keywords = "Security Get Safe Vector4D"))
	static FVector4 SCL_Callable_GetSafeVector4D(UPARAM(Ref)FSafeVector4D &SV);
	//
	/**	Callable:: Gets hidden value from 'Safe Vector4D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Vector4D", Keywords = "Security Get Safe Vector4D"))
	static FVector4 SCL_Callable_GetSafeVector4DWithKey(UPARAM(Ref)FSafeVector4D &SV, FString Key);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Vector4D Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Vector4D", Keywords = "Security Get Safe Vector4D"))
	static FVector4 SCL_Callable_SetSafeVector4D(UPARAM(Ref)FSafeVector4D &SV, UPARAM(Ref)FVector4& Value);
	//
	/**	Callable:: Sets, and hides in memory, value for 'Safe Vector4D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Vector4D", Keywords = "Security Get Safe Vector4D"))
	static FVector4 SCL_Callable_SetSafeVector4DWithKey(UPARAM(Ref)FSafeVector4D &SV, FString Key, UPARAM(Ref)FVector4& Value);

	//
	
	/** Callable:: Gets hidden value from 'Safe Rotator Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Rotator", Keywords = "Security Get Safe Rotator"))
	static FRotator SCL_Callable_GetSafeRotator(UPARAM(Ref)FSafeRotator &SR);
	//
	/**	Callable:: Gets hidden value from 'Safe Vector4D Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Rotator", Keywords = "Security Get Safe Rotator"))
	static FRotator SCL_Callable_GetSafeRotatorWithKey(UPARAM(Ref)FSafeRotator &SR, FString Key);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Rotator Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Rotator", Keywords = "Security Get Safe Rotator"))
	static FRotator SCL_Callable_SetSafeRotator(UPARAM(Ref)FSafeRotator &SR, const FRotator Value);
	//
	/**	Callable:: Sets, and hides in memory, value for 'Safe Rotator Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Rotator", Keywords = "Security Get Safe Rotator"))
	static FRotator SCL_Callable_SetSafeRotatorWithKey(UPARAM(Ref)FSafeRotator &SR, FString Key, const FRotator Value);

	//
	
	/** Callable:: Gets hidden value from 'Safe Color Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Color", Keywords = "Security Get Safe Color"))
	static FLinearColor SCL_Callable_GetSafeColor(UPARAM(Ref)FSafeColor &SC);
	//
	/**	Callable:: Gets hidden value from 'Safe Color Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Color", Keywords = "Security Get Safe Color"))
	static FLinearColor SCL_Callable_GetSafeColorWithKey(UPARAM(Ref)FSafeColor &SC, FString Key);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Color Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Color", Keywords = "Security Get Safe Color"))
	static FLinearColor SCL_Callable_SetSafeColor(UPARAM(Ref)FSafeColor &SC, UPARAM(Ref)FLinearColor& Value);
	//
	/**	Callable:: Sets, and hides in memory, value for 'Safe Color Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Color", Keywords = "Security Get Safe Color"))
	static FLinearColor SCL_Callable_SetSafeColorWithKey(UPARAM(Ref)FSafeColor &SC, FString Key, UPARAM(Ref)FLinearColor& Value);

	//
	
	/** Callable:: Gets hidden value from 'Safe Transform Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Transform", Keywords = "Security Get Safe Transform"))
	static FTransform SCL_Callable_GetSafeTransform(UPARAM(Ref)FSafeTransform &ST);
	//
	/** Callable:: Gets hidden value from 'Safe Transform Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Get Safe Transform", Keywords = "Security Get Safe Transform"))
	static FTransform SCL_Callable_GetSafeTransformWithKey(UPARAM(Ref)FSafeTransform &ST, FString Key);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Transform Struct'. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Transform", Keywords = "Security Get Safe Transform"))
	static FTransform SCL_Callable_SetSafeTransform(UPARAM(Ref)FSafeTransform &ST, UPARAM(Ref)FTransform &Value);
	//
	/** Callable:: Sets, and hides in memory, value for 'Safe Transform Struct'.
	Custom Key Required: If have custom encryption Key, attach to Key input value. */
	UFUNCTION(BlueprintCallable, Category = "Security", meta = (DisplayName = "Set Safe Transform", Keywords = "Security Get Safe Transform"))
	static FTransform SCL_Callable_SetSafeTransformWithKey(UPARAM(Ref)FSafeTransform &ST, FString Key, UPARAM(Ref)FTransform &Value);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// FSBool

	/* FSafe -> FSafe */

	/** Set:: Safe Bool = Safe Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Bool)", CompactNodeTitle = "=", Keywords = "Security Set Safe Bool EQUAL ="))
	static FSafeBool SCO_Pure_SetSafeBoolEqualFSB(UPARAM(Ref)FSafeBool &FSB, UPARAM(Ref)FSafeBool &SSB, bool &Output);

	/** Get:: Safe Bool == Safe Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Bool)", CompactNodeTitle = "==", Keywords = "Security Get Safe Bool EQUAL =="))
	static FSafeBool SCO_Pure_GetSafeBoolEqualFSB(UPARAM(Ref)FSafeBool &FSB, UPARAM(Ref)FSafeBool &SSB, bool &Output);

	/** Get:: Safe Bool != Safe Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Bool)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Bool NOT !="))
	static FSafeBool SCO_Pure_GetSafeBoolNotEqualFSB(UPARAM(Ref)FSafeBool &FSB, UPARAM(Ref)FSafeBool &SSB, bool &Output);

	/** Get:: Safe Bool && Safe Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "&& (Safe Bool)", CompactNodeTitle = "&&", Keywords = "Security Get Safe Bool AND &&"))
	static FSafeBool SCO_Pure_GetSafeBoolAndFSB(UPARAM(Ref)FSafeBool &FSB, UPARAM(Ref)FSafeBool &SSB, bool &Output);

	/** Get:: Safe Bool || Safe Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "|| (Safe Bool)", CompactNodeTitle = "||", Keywords = "Security Get Safe Bool OR ||"))
	static FSafeBool SCO_Pure_GetSafeBoolOrFSB(UPARAM(Ref)FSafeBool &FSB, UPARAM(Ref)FSafeBool &SSB, bool &Output);
	
	/* Native -> FSafe */

	/** Set:: Safe Bool = Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Bool)", CompactNodeTitle = "=", Keywords = "Security Set Safe Bool EQUAL ="))
	static FSafeBool SCO_Pure_SetSafeBoolEqualBool(UPARAM(Ref)FSafeBool &FSB, UPARAM(Ref)bool &NB, bool &Output);

	/** Get:: Safe Bool == Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Bool)", CompactNodeTitle = "==", Keywords = "Security Get Safe Bool EQUAL =="))
	static FSafeBool SCO_Pure_GetSafeBoolEqualBool(UPARAM(Ref)FSafeBool &FSB, UPARAM(Ref)bool &NB, bool &Output);

	/** Get:: Safe Bool != Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Bool)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Bool NOT !="))
	static FSafeBool SCO_Pure_GetSafeBoolNotEqualBool(UPARAM(Ref)FSafeBool &FSB, UPARAM(Ref)bool &NB, bool &Output);

	/** Get:: Safe Bool && Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "&& (Bool)", CompactNodeTitle = "&&", Keywords = "Security Get Safe Bool AND &&"))
	static FSafeBool SCO_Pure_GetSafeBoolAndBool(UPARAM(Ref)FSafeBool &FSB, UPARAM(Ref)bool &NB, bool &Output);

	/** Get:: Safe Bool || Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "|| (Bool)", CompactNodeTitle = "||", Keywords = "Security Get Safe Bool OR ||"))
	static FSafeBool SCO_Pure_GetSafeBoolOrBool(UPARAM(Ref)FSafeBool &FSB, UPARAM(Ref)bool &NB, bool &Output);
	
	/* FSafe -> Native */

	/** Set:: Bool = Safe Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Bool)", CompactNodeTitle = "=", Keywords = "Security Set Safe Bool EQUAL ="))
	static bool SCO_Pure_SetBoolEqualFSB(UPARAM(Ref)bool &NB, UPARAM(Ref)FSafeBool &FSB);

	/** Get:: Bool == Safe Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Bool)", CompactNodeTitle = "==", Keywords = "Security Get Safe Bool EQUAL =="))
	static bool SCO_Pure_GetBoolEqualFSB(UPARAM(Ref)bool &NB, UPARAM(Ref)FSafeBool &FSB);

	/** Get:: Bool != Safe Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Bool)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Bool NOT !="))
	static bool SCO_Pure_GetBoolNotEqualFSB(UPARAM(Ref)bool &NB, UPARAM(Ref)FSafeBool &FSB);

	/** Get:: Bool && Safe Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "&& (Safe Bool)", CompactNodeTitle = "&&", Keywords = "Security Get Safe Bool AND &&"))
	static bool SCO_Pure_GetBoolAndFSB(UPARAM(Ref)bool &NB, UPARAM(Ref)FSafeBool &FSB);

	/** Get:: Bool || Safe Bool */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "|| (Safe Bool)", CompactNodeTitle = "||", Keywords = "Security Get Safe Bool OR ||"))
	static bool SCO_Pure_GetBoolOrFSB(UPARAM(Ref)bool &NB, UPARAM(Ref)FSafeBool &FSB);

	// FSByte

	/* FSafe -> FSafe */

	/** Get:: Safe Byte == Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Byte)", CompactNodeTitle = "==", Keywords = "Security Get Safe Byte EQUAL =="))
	static bool SCO_Pure_GetSafeByteEqualFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB);

	/** Get:: Safe Byte != Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Byte)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Byte NOT !="))
	static bool SCO_Pure_GetSafeByteNotEqualFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB);

	/** Get:: Safe Byte > Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Byte)", CompactNodeTitle = ">", Keywords = "Security Get Safe Byte GREATER >"))
	static bool SCO_Pure_GetSafeByteGreaterFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB);

	/** Get:: Safe Byte < Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Byte)", CompactNodeTitle = "<", Keywords = "Security Get Safe Byte LESS <"))
	static bool SCO_Pure_GetSafeByteSmallerFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB);

	/** Get:: Safe Byte >= Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Byte)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Byte GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeByteGreaterEqualFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB);

	/** Get:: Safe Byte <= Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Byte)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Byte LESS EQUAL <="))
	static bool SCO_Pure_GetSafeByteSmallerEqualFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB);

	/** Set:: Safe Byte = Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Byte)", CompactNodeTitle = "=", Keywords = "Security Set Safe Byte EQUAL ="))
	static FSafeByte SCO_Pure_SetSafeByteEqualFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/** Get:: Safe Byte + Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Byte)", CompactNodeTitle = "+", Keywords = "Security Get Safe Byte PLUS +"))
	static FSafeByte SCO_Pure_GetSafeBytePlusFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/** Get:: Safe Byte - Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Byte)", CompactNodeTitle = "-", Keywords = "Security Get Safe Byte MINUS -"))
	static FSafeByte SCO_Pure_GetSafeByteMinusFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/** Get:: Safe Byte * Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Byte)", CompactNodeTitle = "*", Keywords = "Security Get Safe Byte TIMES *"))
	static FSafeByte SCO_Pure_GetSafeByteTimesFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/** Get:: Safe Byte / Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Byte)", CompactNodeTitle = "/", Keywords = "Security Get Safe Byte DIVIDE /"))
	static FSafeByte SCO_Pure_GetSafeByteDivideFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/** Get:: Safe Byte ++ */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "++ (Safe Byte)", CompactNodeTitle = "++", Keywords = "Security Get Safe Byte ADD PLUS ++"))
	static FSafeByte SCO_Pure_GetSafeByteIncreaseFSB(UPARAM(Ref)FSafeByte &FSB, uint8 &Output);

	/** Get:: Safe Byte -- */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "-- (Safe Byte)", CompactNodeTitle = "--", Keywords = "Security Get Safe Byte LESS --"))
	static FSafeByte SCO_Pure_GetSafeByteDecreaseFSB(UPARAM(Ref)FSafeByte &FSB, uint8 &Output);

	/** Get:: Safe Byte += Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+= (Safe Byte)", CompactNodeTitle = "+=", Keywords = "Security Get Safe Byte PLUS EQUAL +="))
	static FSafeByte SCO_Pure_GetSafeBytePlusEqualFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/** Get:: Safe Byte -= Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "-= (Safe Byte)", CompactNodeTitle = "-=", Keywords = "Security Get Safe Byte MINUS EQUAL -="))
	static FSafeByte SCO_Pure_GetSafeByteMinusEqualFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/** Get:: Safe Byte ~ */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "~ (Safe Byte)", CompactNodeTitle = "~", Keywords = "Security Get Safe Byte NOT ~"))
	static FSafeByte SCO_Pure_GetSafeByteNotFSB(UPARAM(Ref)FSafeByte &FSB, uint8 &Output);

	/** Get:: Safe Byte % Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Byte)", CompactNodeTitle = "%", Keywords = "Security Get Safe Byte MOD %"))
	static FSafeByte SCO_Pure_GetSafeByteModFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/** Get:: Safe Byte & Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "& (Safe Byte)", CompactNodeTitle = "&", Keywords = "Security Get Safe Byte AND &"))
	static FSafeByte SCO_Pure_GetSafeByteAndFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/** Get:: Safe Byte | Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "| (Safe Byte)", CompactNodeTitle = "|", Keywords = "Security Get Safe Byte OR |"))
	static FSafeByte SCO_Pure_GetSafeByteOrFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/** Get:: Safe Byte ^ Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "^ (Safe Byte)", CompactNodeTitle = "^", Keywords = "Security Get Safe Byte XOR ^"))
	static FSafeByte SCO_Pure_GetSafeByteXorFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/** Get:: Safe Byte >> Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">> (Safe Byte)", CompactNodeTitle = ">>", Keywords = "Security Get Safe Byte SHIFT >>"))
	static FSafeByte SCO_Pure_GetSafeByteShiftRFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/** Get:: Safe Byte << Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<< (Safe Byte)", CompactNodeTitle = "<<", Keywords = "Security Get Safe Byte SHIFT <<"))
	static FSafeByte SCO_Pure_GetSafeByteShiftLFSB(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)FSafeByte &SSB, uint8 &Output);

	/* Native -> FSafe */

	/** Get:: Safe Byte == Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Byte)", CompactNodeTitle = "==", Keywords = "Security Get Safe Byte EQUAL =="))
	static bool SCO_Pure_GetSafeByteEqualByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB);

	/** Get:: Safe Byte != Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Byte)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Byte NOT !="))
	static bool SCO_Pure_GetSafeByteNotEqualByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB);

	/** Get:: Safe Byte > Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Byte)", CompactNodeTitle = ">", Keywords = "Security Get Safe Byte GREATER >"))
	static bool SCO_Pure_GetSafeByteGreaterByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB);

	/** Get:: Safe Byte < Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Byte)", CompactNodeTitle = "<", Keywords = "Security Get Safe Byte LESS <"))
	static bool SCO_Pure_GetSafeByteSmallerByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB);

	/** Get:: Safe Byte >= Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Byte)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Byte GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeByteGreaterEqualByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB);

	/** Get:: Safe Byte <= Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Byte)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Byte LESS EQUAL <="))
	static bool SCO_Pure_GetSafeByteSmallerEqualByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB);

	/** Set:: Safe Byte = Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Byte)", CompactNodeTitle = "=", Keywords = "Security Set Safe Byte EQUAL ="))
	static FSafeByte SCO_Pure_SetSafeByteEqualByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte + Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Byte)", CompactNodeTitle = "+", Keywords = "Security Get Safe Byte PLUS +"))
	static FSafeByte SCO_Pure_GetSafeBytePlusByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte - Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Byte)", CompactNodeTitle = "-", Keywords = "Security Get Safe Byte MINUS -"))
	static FSafeByte SCO_Pure_GetSafeByteMinusByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte * Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Byte)", CompactNodeTitle = "*", Keywords = "Security Get Safe Byte TIMES *"))
	static FSafeByte SCO_Pure_GetSafeByteTimesByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte / Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Byte)", CompactNodeTitle = "/", Keywords = "Security Get Safe Byte DIVIDE /"))
	static FSafeByte SCO_Pure_GetSafeByteDivideByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte += Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+= (Byte)", CompactNodeTitle = "+=", Keywords = "Security Get Safe Byte PLUS EQUAL +="))
	static FSafeByte SCO_Pure_GetSafeBytePlusEqualByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte -= Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "-= (Byte)", CompactNodeTitle = "-=", Keywords = "Security Get Safe Byte MINUS EQUAL -="))
	static FSafeByte SCO_Pure_GetSafeByteMinusEqualByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte ~ */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "~ (Safe Byte)", CompactNodeTitle = "~", Keywords = "Security Get Safe Byte NOT ~"))
	static FSafeByte SCO_Pure_GetSafeByteNotByte(UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte % Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Byte)", CompactNodeTitle = "%", Keywords = "Security Get Safe Byte MOD %"))
	static FSafeByte SCO_Pure_GetSafeByteModByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte & Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "& (Byte)", CompactNodeTitle = "&", Keywords = "Security Get Safe Byte AND &"))
	static FSafeByte SCO_Pure_GetSafeByteAndByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte | Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "| (Byte)", CompactNodeTitle = "|", Keywords = "Security Get Safe Byte OR |"))
	static FSafeByte SCO_Pure_GetSafeByteOrByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte ^ Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "^ (Byte)", CompactNodeTitle = "^", Keywords = "Security Get Safe Byte XOR ^"))
	static FSafeByte SCO_Pure_GetSafeByteXorByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte >> Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">> (Byte)", CompactNodeTitle = ">>", Keywords = "Security Get Safe Byte SHIFT >>"))
	static FSafeByte SCO_Pure_GetSafeByteShiftRByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/** Get:: Safe Byte << Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<< (Byte)", CompactNodeTitle = "<<", Keywords = "Security Get Safe Byte SHIFT <<"))
	static FSafeByte SCO_Pure_GetSafeByteShiftLByte(UPARAM(Ref)FSafeByte &FSB, UPARAM(Ref)uint8 &NB, uint8 &Output);

	/* FSafe -> Native */

	/** Get:: Byte == Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Byte)", CompactNodeTitle = "==", Keywords = "Security Get Safe Byte EQUAL =="))
	static bool SCO_Pure_GetByteEqualFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte != Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Byte)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Byte NOT !="))
	static bool SCO_Pure_GetByteNotEqualFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte > Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Byte)", CompactNodeTitle = ">", Keywords = "Security Get Safe Byte GREATER >"))
	static bool SCO_Pure_GetByteGreaterFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte < Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Byte)", CompactNodeTitle = "<", Keywords = "Security Get Safe Byte LESS <"))
	static bool SCO_Pure_GetByteSmallerFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte >= Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Byte)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Byte GREATER EQUAL >="))
	static bool SCO_Pure_GetByteGreaterEqualFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte <= Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Byte)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Byte LESS EQUAL <="))
	static bool SCO_Pure_GetByteSmallerEqualFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Set:: Byte = Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Byte)", CompactNodeTitle = "=", Keywords = "Security Set Safe Byte EQUAL ="))
	static uint8 SCO_Pure_SetByteEqualFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte + Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Byte)", CompactNodeTitle = "+", Keywords = "Security Get Safe Byte PLUS +"))
	static uint8 SCO_Pure_GetBytePlusFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte - Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Byte)", CompactNodeTitle = "-", Keywords = "Security Get Safe Byte MINUS -"))
	static uint8 SCO_Pure_GetByteMinusFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte * Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Byte)", CompactNodeTitle = "*", Keywords = "Security Get Safe Byte TIMES *"))
	static uint8 SCO_Pure_GetByteTimesFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte / Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Byte)", CompactNodeTitle = "/", Keywords = "Security Get Safe Byte DIVIDE /"))
	static uint8 SCO_Pure_GetByteDivideFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);
	
	/** Get:: Byte % Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Byte)", CompactNodeTitle = "%", Keywords = "Security Get Safe Byte MOD %"))
	static uint8 SCO_Pure_GetByteModFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte & Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "& (Safe Byte)", CompactNodeTitle = "&", Keywords = "Security Get Safe Byte AND &"))
	static uint8 SCO_Pure_GetByteAndFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte | Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "| (Safe Byte)", CompactNodeTitle = "|", Keywords = "Security Get Safe Byte OR |"))
	static uint8 SCO_Pure_GetByteOrFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte ^ Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "^ (Safe Byte)", CompactNodeTitle = "^", Keywords = "Security Get Safe Byte XOR ^"))
	static uint8 SCO_Pure_GetByteXorFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte >> Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">> (Safe Byte)", CompactNodeTitle = ">>", Keywords = "Security Get Safe Byte SHIFT >>"))
	static uint8 SCO_Pure_GetByteShiftRFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	/** Get:: Byte << Safe Byte */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<< (Safe Byte)", CompactNodeTitle = "<<", Keywords = "Security Get Safe Byte SHIFT <<"))
	static uint8 SCO_Pure_GetByteShiftLFSB(UPARAM(Ref)uint8 &NB, UPARAM(Ref)FSafeByte &FSB);

	// FSInt

	/* FSafe -> FSafe */

	/** Get:: Safe Integer == Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Integer)", CompactNodeTitle = "==", Keywords = "Security Get Safe Integer EQUAL =="))
	static bool SCO_Pure_GetSafeIntEqualFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI);

	/** Get:: Safe Integer != Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Integer)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Integer NOT !="))
	static bool SCO_Pure_GetSafeIntNotEqualFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI);

	/** Get:: Safe Integer > Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Integer)", CompactNodeTitle = ">", Keywords = "Security Get Safe Integer GREATER >"))
	static bool SCO_Pure_GetSafeIntGreaterFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI);

	/** Get:: Safe Integer < Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Integer)", CompactNodeTitle = "<", Keywords = "Security Get Safe Integer LESS <"))
	static bool SCO_Pure_GetSafeIntSmallerFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI);

	/** Get:: Safe Integer >= Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Integer)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Integer GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeIntGreaterEqualFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI);

	/** Get:: Safe Integer <= Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Integer)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Integer LESS EQUAL <="))
	static bool SCO_Pure_GetSafeIntSmallerEqualFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI);

	/** Set:: Safe Integer = Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Integer)", CompactNodeTitle = "=", Keywords = "Security Set Safe Integer EQUAL ="))
	static FSafeInt SCO_Pure_SetSafeIntEqualFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/** Get:: Safe Integer + Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Integer)", CompactNodeTitle = "+", Keywords = "Security Get Safe Integer PLUS +"))
	static FSafeInt SCO_Pure_GetSafeIntPlusFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/** Get:: Safe Integer - Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Integer)", CompactNodeTitle = "-", Keywords = "Security Get Safe Integer MINUS -"))
	static FSafeInt SCO_Pure_GetSafeIntMinusFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/** Get:: Safe Integer * Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Integer)", CompactNodeTitle = "*", Keywords = "Security Get Safe Integer TIMES *"))
	static FSafeInt SCO_Pure_GetSafeIntTimesFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/** Get:: Safe Integer / Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Integer)", CompactNodeTitle = "/", Keywords = "Security Get Safe Integer DIVIDE /"))
	static FSafeInt SCO_Pure_GetSafeIntDivideFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/** Get:: Safe Integer ++ */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "++ (Safe Integer)", CompactNodeTitle = "++", Keywords = "Security Get Safe Integer ADD PLUS ++"))
	static FSafeInt SCO_Pure_GetSafeIntIncreaseFSI(UPARAM(Ref)FSafeInt &FSI, int32 &Output);

	/** Get:: Safe Integer -- */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "-- (Safe Integer)", CompactNodeTitle = "--", Keywords = "Security Get Safe Integer LESS --"))
	static FSafeInt SCO_Pure_GetSafeIntDecreaseFSI(UPARAM(Ref)FSafeInt &FSI, int32 &Output);

	/** Get:: Safe Integer += Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+= (Safe Integer)", CompactNodeTitle = "+=", Keywords = "Security Get Safe Integer PLUS EQUAL +="))
	static FSafeInt SCO_Pure_GetSafeIntPlusEqualFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/** Get:: Safe Integer -= Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "-= (Safe Integer)", CompactNodeTitle = "-=", Keywords = "Security Get Safe Integer MINUS EQUAL -="))
	static FSafeInt SCO_Pure_GetSafeIntMinusEqualFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/** Get:: Safe Integer ~ */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "~ (Safe Integer)", CompactNodeTitle = "~", Keywords = "Security Get Safe Integer NOT ~"))
	static FSafeInt SCO_Pure_GetSafeIntNotFSI(UPARAM(Ref)FSafeInt &FSI, int32 &Output);

	/** Get:: Safe Integer % Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Integer)", CompactNodeTitle = "%", Keywords = "Security Get Safe Integer MOD %"))
	static FSafeInt SCO_Pure_GetSafeIntModFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/** Get:: Safe Integer & Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "& (Safe Integer)", CompactNodeTitle = "&", Keywords = "Security Get Safe Integer AND &"))
	static FSafeInt SCO_Pure_GetSafeIntAndFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/** Get:: Safe Integer | Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "| (Safe Integer)", CompactNodeTitle = "|", Keywords = "Security Get Safe Integer OR |"))
	static FSafeInt SCO_Pure_GetSafeIntOrFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/** Get:: Safe Integer ^ Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "^ (Safe Integer)", CompactNodeTitle = "^", Keywords = "Security Get Safe Integer XOR ^"))
	static FSafeInt SCO_Pure_GetSafeIntXorFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/** Get:: Safe Integer >> Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">> (Safe Integer)", CompactNodeTitle = ">>", Keywords = "Security Get Safe Integer SHIFT >>"))
	static FSafeInt SCO_Pure_GetSafeIntShiftRFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/** Get:: Safe Integer << Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<< (Safe Integer)", CompactNodeTitle = "<<", Keywords = "Security Get Safe Integer SHIFT <<"))
	static FSafeInt SCO_Pure_GetSafeIntShiftLFSI(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)FSafeInt &SSI, int32 &Output);

	/* Native -> FSafe */

	/** Get:: Safe Integer == Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Integer)", CompactNodeTitle = "==", Keywords = "Security Get Safe Integer EQUAL =="))
	static bool SCO_Pure_GetSafeIntEqualInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI);

	/** Get:: Safe Integer != Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Integer)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Integer NOT !="))
	static bool SCO_Pure_GetSafeIntNotEqualInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI);

	/** Get:: Safe Integer > Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Integer)", CompactNodeTitle = ">", Keywords = "Security Get Safe Integer GREATER >"))
	static bool SCO_Pure_GetSafeIntGreaterInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI);

	/** Get:: Safe Integer < Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Integer)", CompactNodeTitle = "<", Keywords = "Security Get Safe Integer LESS <"))
	static bool SCO_Pure_GetSafeIntSmallerInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI);

	/** Get:: Safe Integer >= Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Integer)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Integer GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeIntGreaterEqualInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI);

	/** Get:: Safe Integer <= Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Integer)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Integer LESS EQUAL <="))
	static bool SCO_Pure_GetSafeIntSmallerEqualInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI);

	/** Set:: Safe Integer = Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Integer)", CompactNodeTitle = "=", Keywords = "Security Set Safe Integer EQUAL ="))
	static FSafeInt SCO_Pure_SetSafeIntEqualInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer + Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Integer)", CompactNodeTitle = "+", Keywords = "Security Get Safe Integer PLUS +"))
	static FSafeInt SCO_Pure_GetSafeIntPlusInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer - Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Integer)", CompactNodeTitle = "-", Keywords = "Security Get Safe Integer MINUS -"))
	static FSafeInt SCO_Pure_GetSafeIntMinusInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer * Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Integer)", CompactNodeTitle = "*", Keywords = "Security Get Safe Integer TIMES *"))
	static FSafeInt SCO_Pure_GetSafeIntTimesInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer / Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Integer)", CompactNodeTitle = "/", Keywords = "Security Get Safe Integer DIVIDE /"))
	static FSafeInt SCO_Pure_GetSafeIntDivideInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer += Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+= (Integer)", CompactNodeTitle = "+=", Keywords = "Security Get Safe Integer PLUS EQUAL +="))
	static FSafeInt SCO_Pure_GetSafeIntPlusEqualInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer -= Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "-= (Integer)", CompactNodeTitle = "-=", Keywords = "Security Get Safe Integer MINUS EQUAL -="))
	static FSafeInt SCO_Pure_GetSafeIntMinusEqualInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer ~ */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "~ (Safe Integer)", CompactNodeTitle = "~", Keywords = "Security Get Safe Integer NOT ~"))
	static FSafeInt SCO_Pure_GetSafeIntNotInt(UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer % Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Integer)", CompactNodeTitle = "%", Keywords = "Security Get Safe Integer MOD %"))
	static FSafeInt SCO_Pure_GetSafeIntModInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer & Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "& (Integer)", CompactNodeTitle = "&", Keywords = "Security Get Safe Integer AND &"))
	static FSafeInt SCO_Pure_GetSafeIntAndInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer | Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "| (Integer)", CompactNodeTitle = "|", Keywords = "Security Get Safe Integer OR |"))
	static FSafeInt SCO_Pure_GetSafeIntOrInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer ^ Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "^ (Integer)", CompactNodeTitle = "^", Keywords = "Security Get Safe Integer XOR ^"))
	static FSafeInt SCO_Pure_GetSafeIntXorInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer >> Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">> (Integer)", CompactNodeTitle = ">>", Keywords = "Security Get Safe Integer SHIFT >>"))
	static FSafeInt SCO_Pure_GetSafeIntShiftRInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/** Get:: Safe Integer << Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<< (Integer)", CompactNodeTitle = "<<", Keywords = "Security Get Safe Integer SHIFT <<"))
	static FSafeInt SCO_Pure_GetSafeIntShiftLInt(UPARAM(Ref)FSafeInt &FSI, UPARAM(Ref)int32 &NI, int32 &Output);

	/* FSafe -> Native */

	/** Get:: Integer == Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Integer)", CompactNodeTitle = "==", Keywords = "Security Get Safe Integer EQUAL =="))
	static bool SCO_Pure_GetIntEqualFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer != Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Integer)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Integer NOT !="))
	static bool SCO_Pure_GetIntNotEqualFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer > Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Integer)", CompactNodeTitle = ">", Keywords = "Security Get Safe Integer GREATER >"))
	static bool SCO_Pure_GetIntGreaterFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer < Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Integer)", CompactNodeTitle = "<", Keywords = "Security Get Safe Integer LESS <"))
	static bool SCO_Pure_GetIntSmallerFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer >= Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Integer)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Integer GREATER EQUAL >="))
	static bool SCO_Pure_GetIntGreaterEqualFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer <= Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Integer)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Integer LESS EQUAL <="))
	static bool SCO_Pure_GetIntSmallerEqualFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Set:: Integer = Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Integer)", CompactNodeTitle = "=", Keywords = "Security Set Safe Integer EQUAL ="))
	static int32 SCO_Pure_SetIntEqualFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer + Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Integer)", CompactNodeTitle = "+", Keywords = "Security Get Safe Integer PLUS +"))
	static int32 SCO_Pure_GetIntPlusFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer - Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Integer)", CompactNodeTitle = "-", Keywords = "Security Get Safe Integer MINUS -"))
	static int32 SCO_Pure_GetIntMinusFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer * Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Integer)", CompactNodeTitle = "*", Keywords = "Security Get Safe Integer TIMES *"))
	static int32 SCO_Pure_GetIntTimesFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer / Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Integer)", CompactNodeTitle = "/", Keywords = "Security Get Safe Integer DIVIDE /"))
	static int32 SCO_Pure_GetIntDivideFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer % Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Integer)", CompactNodeTitle = "%", Keywords = "Security Get Safe Integer MOD %"))
	static int32 SCO_Pure_GetIntModFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer & Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "& (Safe Integer)", CompactNodeTitle = "&", Keywords = "Security Get Safe Integer AND &"))
	static int32 SCO_Pure_GetIntAndFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer | Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "| (Safe Integer)", CompactNodeTitle = "|", Keywords = "Security Get Safe Integer OR |"))
	static int32 SCO_Pure_GetIntOrFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer ^ Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "^ (Safe Integer)", CompactNodeTitle = "^", Keywords = "Security Get Safe Integer XOR ^"))
	static int32 SCO_Pure_GetIntXorFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer >> Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">> (Safe Integer)", CompactNodeTitle = ">>", Keywords = "Security Get Safe Integer SHIFT >>"))
	static int32 SCO_Pure_GetIntShiftRFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	/** Get:: Integer << Safe Integer */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<< (Safe Integer)", CompactNodeTitle = "<<", Keywords = "Security Get Safe Integer SHIFT <<"))
	static int32 SCO_Pure_GetIntShiftLFSI(UPARAM(Ref)int32 &NI, UPARAM(Ref)FSafeInt &FSI);

	// FSFloat

	/* FSafe -> FSafe */

	/** Get:: Safe Float == Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Float)", CompactNodeTitle = "==", Keywords = "Security Get Safe Float EQUAL =="))
	static bool SCO_Pure_GetSafeFloatEqualFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF);

	/** Get:: Safe Float != Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Float)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Float NOT !="))
	static bool SCO_Pure_GetSafeFloatNotEqualFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF);

	/** Get:: Safe Float > Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Float)", CompactNodeTitle = ">", Keywords = "Security Get Safe Float GREATER >"))
	static bool SCO_Pure_GetSafeFloatGreaterFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF);

	/** Get:: Safe Float < Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Float)", CompactNodeTitle = "<", Keywords = "Security Get Safe Float LESS <"))
	static bool SCO_Pure_GetSafeFloatSmallerFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF);

	/** Get:: Safe Float >= Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Float)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Float GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeFloatGreaterEqualFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF);

	/** Get:: Safe Float <= Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Float)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Float LESS EQUAL <="))
	static bool SCO_Pure_GetSafeFloatSmallerEqualFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF);

	/** Set:: Safe Float = Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Float)", CompactNodeTitle = "=", Keywords = "Security Set Safe Float EQUAL ="))
	static FSafeFloat SCO_Pure_SetSafeFloatEqualFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF, float &Output);

	/** Get:: Safe Float + Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Float)", CompactNodeTitle = "+", Keywords = "Security Get Safe Float PLUS +"))
	static FSafeFloat SCO_Pure_GetSafeFloatPlusFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF, float &Output);

	/** Get:: Safe Float - Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Float)", CompactNodeTitle = "-", Keywords = "Security Get Safe Float MINUS -"))
	static FSafeFloat SCO_Pure_GetSafeFloatMinusFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF, float &Output);

	/** Get:: Safe Float * Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Float)", CompactNodeTitle = "*", Keywords = "Security Get Safe Float TIMES *"))
	static FSafeFloat SCO_Pure_GetSafeFloatTimesFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF, float &Output);

	/** Get:: Safe Float / Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Float)", CompactNodeTitle = "/", Keywords = "Security Get Safe Float DIVIDE /"))
	static FSafeFloat SCO_Pure_GetSafeFloatDivideFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF, float &Output);

	/** Get:: Safe Float ++ */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "++ (Safe Float)", CompactNodeTitle = "++", Keywords = "Security Get Safe Float ADD PLUS ++"))
	static FSafeFloat SCO_Pure_GetSafeFloatIncreaseFSF(UPARAM(Ref)FSafeFloat &FSF, float &Output);

	/** Get:: Safe Float -- */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "-- (Safe Float)", CompactNodeTitle = "--", Keywords = "Security Get Safe Float LESS --"))
	static FSafeFloat SCO_Pure_GetSafeFloatDecreaseFSF(UPARAM(Ref)FSafeFloat &FSF, float &Output);

	/** Get:: Safe Float += Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+= (Safe Float)", CompactNodeTitle = "+=", Keywords = "Security Get Safe Float PLUS EQUAL +="))
	static FSafeFloat SCO_Pure_GetSafeFloatPlusEqualFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF, float &Output);

	/** Get:: Safe Float -= Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "-= (Safe Float)", CompactNodeTitle = "-=", Keywords = "Security Get Safe Float MINUS EQUAL -="))
	static FSafeFloat SCO_Pure_GetSafeFloatMinusEqualFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF, float &Output);

	/** Get:: Safe Float % Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Float)", CompactNodeTitle = "%", Keywords = "Security Get Safe Float MOD %"))
	static FSafeFloat SCO_Pure_GetSafeFloatModFSF(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)FSafeFloat &SSF, float &Output);

	/* Native -> FSafe */

	/** Get:: Safe Float == Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Float)", CompactNodeTitle = "==", Keywords = "Security Get Safe Float EQUAL =="))
	static bool SCO_Pure_GetSafeFloatEqualFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF);

	/** Get:: Safe Float != Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Float)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Float NOT !="))
	static bool SCO_Pure_GetSafeFloatNotEqualFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF);

	/** Get:: Safe Float > Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Float)", CompactNodeTitle = ">", Keywords = "Security Get Safe Float GREATER >"))
	static bool SCO_Pure_GetSafeFloatGreaterFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF);

	/** Get:: Safe Float < Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Float)", CompactNodeTitle = "<", Keywords = "Security Get Safe Float LESS <"))
	static bool SCO_Pure_GetSafeFloatSmallerFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF);

	/** Get:: Safe Float >= Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Float)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Float GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeFloatGreaterEqualFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF);

	/** Get:: Safe Float <= Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Float)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Float LESS EQUAL <="))
	static bool SCO_Pure_GetSafeFloatSmallerEqualFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF);

	/** Set:: Safe Float = Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Float)", CompactNodeTitle = "=", Keywords = "Security Set Safe Float EQUAL ="))
	static FSafeFloat SCO_Pure_SetSafeFloatEqualFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF, float &Output);

	/** Get:: Safe Float + Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Float)", CompactNodeTitle = "+", Keywords = "Security Get Safe Float PLUS +"))
	static FSafeFloat SCO_Pure_GetSafeFloatPlusFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF, float &Output);

	/** Get:: Safe Float - Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Float)", CompactNodeTitle = "-", Keywords = "Security Get Safe Float MINUS -"))
	static FSafeFloat SCO_Pure_GetSafeFloatMinusFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF, float &Output);

	/** Get:: Safe Float * Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Float)", CompactNodeTitle = "*", Keywords = "Security Get Safe Float TIMES *"))
	static FSafeFloat SCO_Pure_GetSafeFloatTimesFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF, float &Output);

	/** Get:: Safe Float / Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Float)", CompactNodeTitle = "/", Keywords = "Security Get Safe Float DIVIDE /"))
	static FSafeFloat SCO_Pure_GetSafeFloatDivideFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF, float &Output);

	/** Get:: Safe Float += Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+= (Float)", CompactNodeTitle = "+=", Keywords = "Security Get Safe Float PLUS EQUAL +="))
	static FSafeFloat SCO_Pure_GetSafeFloatPlusEqualFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF, float &Output);

	/** Get:: Safe Float -= Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "-= (Float)", CompactNodeTitle = "-=", Keywords = "Security Get Safe Float MINUS EQUAL -="))
	static FSafeFloat SCO_Pure_GetSafeFloatMinusEqualFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF, float &Output);

	/** Get:: Safe Float % Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Float)", CompactNodeTitle = "%", Keywords = "Security Get Safe Float MOD %"))
	static FSafeFloat SCO_Pure_GetSafeFloatModFloat(UPARAM(Ref)FSafeFloat &FSF, UPARAM(Ref)float &NF, float &Output);

	/* FSafe -> Native */

	/** Get:: Float == Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Float)", CompactNodeTitle = "==", Keywords = "Security Get Safe Float EQUAL =="))
	static bool SCO_Pure_GetFloatEqualFSF(UPARAM(Ref)float &NF, UPARAM(Ref)FSafeFloat &FSF);

	/** Get:: Float != Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Float)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Float NOT !="))
	static bool SCO_Pure_GetFloatNotEqualFSF(UPARAM(Ref)float &NF, UPARAM(Ref)FSafeFloat &FSF);

	/** Get:: Float > Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Float)", CompactNodeTitle = ">", Keywords = "Security Get Safe Float GREATER >"))
	static bool SCO_Pure_GetFloatGreaterFSF(UPARAM(Ref)float &NF, UPARAM(Ref)FSafeFloat &FSF);

	/** Get:: Float < Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Float)", CompactNodeTitle = "<", Keywords = "Security Get Safe Float LESS <"))
	static bool SCO_Pure_GetFloatSmallerFSF(UPARAM(Ref)float &NF, UPARAM(Ref)FSafeFloat &FSF);

	/** Get:: Float >= Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Float)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Float GREATER EQUAL >="))
	static bool SCO_Pure_GetFloatGreaterEqualFSF(UPARAM(Ref)float &NF, UPARAM(Ref)FSafeFloat &FSF);

	/** Get:: Float <= Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Float)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Float LESS EQUAL <="))
	static bool SCO_Pure_GetFloatSmallerEqualFSF(UPARAM(Ref)float &NF, UPARAM(Ref)FSafeFloat &FSF);

	/** Set:: Float = Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Float)", CompactNodeTitle = "=", Keywords = "Security Set Safe Float EQUAL ="))
	static float SCO_Pure_SetFloatEqualFSF(UPARAM(Ref)float &NF, UPARAM(Ref)FSafeFloat &FSF);

	/** Get:: Float + Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Float)", CompactNodeTitle = "+", Keywords = "Security Get Safe Float PLUS +"))
	static float SCO_Pure_GetFloatPlusFSF(UPARAM(Ref)float &NF, UPARAM(Ref)FSafeFloat &FSF);

	/** Get:: Float - Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Float)", CompactNodeTitle = "-", Keywords = "Security Get Safe Float MINUS -"))
	static float SCO_Pure_GetFloatMinusFSF(UPARAM(Ref)float &NF, UPARAM(Ref)FSafeFloat &FSF);

	/** Get:: Float * Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Float)", CompactNodeTitle = "*", Keywords = "Security Get Safe Float TIMES *"))
	static float SCO_Pure_GetFloatTimesFSF(UPARAM(Ref)float &NF, UPARAM(Ref)FSafeFloat &FSF);

	/** Get:: Float / Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Float)", CompactNodeTitle = "/", Keywords = "Security Get Safe Float DIVIDE /"))
	static float SCO_Pure_GetFloatDivideFSF(UPARAM(Ref)float &NF, UPARAM(Ref)FSafeFloat &FSF);

	/** Get:: Float % Safe Float */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Float)", CompactNodeTitle = "%", Keywords = "Security Get Safe Float MOD %"))
	static float SCO_Pure_GetFloatModFSF(UPARAM(Ref)float &NF, UPARAM(Ref)FSafeFloat &FSF);

	// FSName

	/* FSafe -> FSafe */

	/** Get:: Safe Name == Safe Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Name)", CompactNodeTitle = "==", Keywords = "Security Get Safe Name EQUAL =="))
	static bool SCO_Pure_GetSafeNameEqualFSN(UPARAM(Ref)FSafeName &FSN, UPARAM(Ref)FSafeName &SSN);

	/** Get:: Safe Name != Safe Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Name)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Name NOT !="))
	static bool SCO_Pure_GetSafeNameNotEqualFSN(UPARAM(Ref)FSafeName &FSN, UPARAM(Ref)FSafeName &SSN);

	/** Get:: Safe Name > Safe Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Name)", CompactNodeTitle = ">", Keywords = "Security Get Safe Name GREATER >"))
	static bool SCO_Pure_GetSafeNameGreaterFSN(UPARAM(Ref)FSafeName &FSN, UPARAM(Ref)FSafeName &SSN);

	/** Get:: Safe Name < Safe Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Name)", CompactNodeTitle = "<", Keywords = "Security Get Safe Name LESS <"))
	static bool SCO_Pure_GetSafeNameSmallerFSN(UPARAM(Ref)FSafeName &FSN, UPARAM(Ref)FSafeName &SSN);

	/** Set:: Safe Name = Safe Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Name)", CompactNodeTitle = "=", Keywords = "Security Set Safe Name EQUAL ="))
	static FSafeName SCO_Pure_SetSafeNameEqualFSN(UPARAM(Ref)FSafeName &FSN, UPARAM(Ref)FSafeName &SSN, FName &Output);

	/** Get:: Safe Name + Safe Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Name)", CompactNodeTitle = "+", Keywords = "Security Get Safe Name PLUS +"))
	static FSafeName SCO_Pure_GetSafeNamePlusFSN(UPARAM(Ref)FSafeName &FSN, UPARAM(Ref)FSafeName &SSN, FName &Output);
	
	/* Native -> FSafe */

	/** Get:: Safe Name == Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Name)", CompactNodeTitle = "==", Keywords = "Security Get Safe Name EQUAL =="))
	static bool SCO_Pure_GetSafeNameEqualName(UPARAM(Ref)FSafeName &FSN, UPARAM(Ref)FName &NN);

	/** Get:: Safe Name != Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Name)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Name NOT !="))
	static bool SCO_Pure_GetSafeNameNotEqualName(UPARAM(Ref)FSafeName &FSN, UPARAM(Ref)FName &NN);

	/** Get:: Safe Name > Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Name)", CompactNodeTitle = ">", Keywords = "Security Get Safe Name GREATER >"))
	static bool SCO_Pure_GetSafeNameGreaterName(UPARAM(Ref)FSafeName &FSN, UPARAM(Ref)FName &NN);

	/** Get:: Safe Name < Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Name)", CompactNodeTitle = "<", Keywords = "Security Get Safe Name LESS <"))
	static bool SCO_Pure_GetSafeNameSmallerName(UPARAM(Ref)FSafeName &FSN, UPARAM(Ref)FName &NN);

	/** Set:: Safe Name = Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Name)", CompactNodeTitle = "=", Keywords = "Security Set Safe Name EQUAL ="))
	static FSafeName SCO_Pure_SetSafeNameEqualName(UPARAM(Ref)FSafeName &FSN, UPARAM(Ref)FName &NN, FName &Output);

	/** Get:: Safe Name + Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Name)", CompactNodeTitle = "+", Keywords = "Security Get Safe Name PLUS +"))
	static FSafeName SCO_Pure_GetSafeNamePlusName(UPARAM(Ref)FSafeName &FSN, UPARAM(Ref)FName &NN, FName &Output);
		
	/* FSafe -> Native */

	/** Get:: Name == Safe Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Name)", CompactNodeTitle = "==", Keywords = "Security Get Safe Name EQUAL =="))
	static bool SCO_Pure_GetNameEqualFSN(UPARAM(Ref)FName &NN, UPARAM(Ref)FSafeName &FSN);

	/** Get:: Name != Safe Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Name)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Name NOT !="))
	static bool SCO_Pure_GetNameNotEqualFSN(UPARAM(Ref)FName &NN, UPARAM(Ref)FSafeName &FSN);

	/** Get:: Name > Safe Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Name)", CompactNodeTitle = ">", Keywords = "Security Get Safe Name GREATER >"))
	static bool SCO_Pure_GetNameGreaterFSN(UPARAM(Ref)FName &NN, UPARAM(Ref)FSafeName &FSN);

	/** Get:: Name < Safe Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Name)", CompactNodeTitle = "<", Keywords = "Security Get Safe Name LESS <"))
	static bool SCO_Pure_GetNameSmallerFSN(UPARAM(Ref)FName &NN, UPARAM(Ref)FSafeName &FSN);

	/** Set:: Name = Safe Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Name)", CompactNodeTitle = "=", Keywords = "Security Set Safe Name EQUAL ="))
	static FName SCO_Pure_SetNameEqualFSN(UPARAM(Ref)FName &NN, UPARAM(Ref)FSafeName &FSN);

	/** Get:: Name + Safe Name */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Name)", CompactNodeTitle = "+", Keywords = "Security Get Safe Name PLUS +"))
	static FName SCO_Pure_GetNamePlusFSN(UPARAM(Ref)FName &NN, UPARAM(Ref)FSafeName &FSN);
	
	// FSText

	/* FSafe -> FSafe */

	/** Get:: Safe Text == Safe Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Text)", CompactNodeTitle = "==", Keywords = "Security Get Safe Text EQUAL =="))
	static bool SCO_Pure_GetSafeTextEqualFST(UPARAM(Ref)FSafeText &FST, UPARAM(Ref)FSafeText &ST);

	/** Get:: Safe Text != Safe Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Text)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Text NOT !="))
	static bool SCO_Pure_GetSafeTextNotEqualFST(UPARAM(Ref)FSafeText &FST, UPARAM(Ref)FSafeText &ST);

	/** Get:: Safe Text > Safe Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Text)", CompactNodeTitle = ">", Keywords = "Security Get Safe Text GREATER >"))
	static bool SCO_Pure_GetSafeTextGreaterFST(UPARAM(Ref)FSafeText &FST, UPARAM(Ref)FSafeText &ST);

	/** Get:: Safe Text < Safe Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Text)", CompactNodeTitle = "<", Keywords = "Security Get Safe Text LEST <"))
	static bool SCO_Pure_GetSafeTextSmallerFST(UPARAM(Ref)FSafeText &FST, UPARAM(Ref)FSafeText &ST);

	/** Set:: Safe Text = Safe Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Text)", CompactNodeTitle = "=", Keywords = "Security Set Safe Text EQUAL ="))
	static FSafeText SCO_Pure_SetSafeTextEqualFST(UPARAM(Ref)FSafeText &FST, UPARAM(Ref)FSafeText &ST, FText &Output);

	/** Get:: Safe Text + Safe Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Text)", CompactNodeTitle = "+", Keywords = "Security Get Safe Text PLUS +"))
	static FSafeText SCO_Pure_GetSafeTextPlusFST(UPARAM(Ref)FSafeText &FST, UPARAM(Ref)FSafeText &ST, FText &Output);
	
	/* Native -> FSafe */

	/** Get:: Safe Text == Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Text)", CompactNodeTitle = "==", Keywords = "Security Get Safe Text EQUAL =="))
	static bool SCO_Pure_GetSafeTextEqualText(UPARAM(Ref)FSafeText &FST, UPARAM(Ref)FText &NT);

	/** Get:: Safe Text != Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Text)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Text NOT !="))
	static bool SCO_Pure_GetSafeTextNotEqualText(UPARAM(Ref)FSafeText &FST, UPARAM(Ref)FText &NT);

	/** Get:: Safe Text > Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Text)", CompactNodeTitle = ">", Keywords = "Security Get Safe Text GREATER >"))
	static bool SCO_Pure_GetSafeTextGreaterText(UPARAM(Ref)FSafeText &FST, UPARAM(Ref)FText &NT);

	/** Get:: Safe Text < Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Text)", CompactNodeTitle = "<", Keywords = "Security Get Safe Text LEST <"))
	static bool SCO_Pure_GetSafeTextSmallerText(UPARAM(Ref)FSafeText &FST, UPARAM(Ref)FText &NT);

	/** Set:: Safe Text = Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Text)", CompactNodeTitle = "=", Keywords = "Security Set Safe Text EQUAL ="))
	static FSafeText SCO_Pure_SetSafeTextEqualText(UPARAM(Ref)FSafeText &FST, UPARAM(Ref)FText &NT, FText &Output);

	/** Get:: Safe Text + Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Text)", CompactNodeTitle = "+", Keywords = "Security Get Safe Text PLUS +"))
	static FSafeText SCO_Pure_GetSafeTextPlusText(UPARAM(Ref)FSafeText &FST, UPARAM(Ref)FText &NT, FText &Output);
	
	/* FSafe -> Native */

	/** Get:: Text == Safe Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Text)", CompactNodeTitle = "==", Keywords = "Security Get Safe Text EQUAL =="))
	static bool SCO_Pure_GetTextEqualFST(UPARAM(Ref)FText &NT, UPARAM(Ref)FSafeText &FST);

	/** Get:: Text != Safe Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Text)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Text NOT !="))
	static bool SCO_Pure_GetTextNotEqualFST(UPARAM(Ref)FText &NT, UPARAM(Ref)FSafeText &FST);

	/** Get:: Text > Safe Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Text)", CompactNodeTitle = ">", Keywords = "Security Get Safe Text GREATER >"))
	static bool SCO_Pure_GetTextGreaterFST(UPARAM(Ref)FText &NT, UPARAM(Ref)FSafeText &FST);

	/** Get:: Text < Safe Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Text)", CompactNodeTitle = "<", Keywords = "Security Get Safe Text LEST <"))
	static bool SCO_Pure_GetTextSmallerFST(UPARAM(Ref)FText &NT, UPARAM(Ref)FSafeText &FST);

	/** Set:: Text = Safe Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Text)", CompactNodeTitle = "=", Keywords = "Security Set Safe Text EQUAL ="))
	static FText SCO_Pure_SetTextEqualFST(UPARAM(Ref)FText &NT, UPARAM(Ref)FSafeText &FST);

	/** Get:: Text + Safe Text */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Text)", CompactNodeTitle = "+", Keywords = "Security Get Safe Text PLUS +"))
	static FText SCO_Pure_GetTextPlusFST(UPARAM(Ref)FText &NT, UPARAM(Ref)FSafeText &FST);

	// FSString

	/* FSafe -> FSafe */

	/** Get:: Safe String == Safe String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe String)", CompactNodeTitle = "==", Keywords = "Security Get Safe String EQUAL =="))
	static bool SCO_Pure_GetSafeStringEqualFSS(UPARAM(Ref)FSafeString &FSS, UPARAM(Ref)FSafeString &SS);

	/** Get:: Safe String != Safe String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe String)", CompactNodeTitle = "!=", Keywords = "Security Get Safe String NOT !="))
	static bool SCO_Pure_GetSafeStringNotEqualFSS(UPARAM(Ref)FSafeString &FSS, UPARAM(Ref)FSafeString &SS);

	/** Get:: Safe String > Safe String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe String)", CompactNodeTitle = ">", Keywords = "Security Get Safe String GREATER >"))
	static bool SCO_Pure_GetSafeStringGreaterFSS(UPARAM(Ref)FSafeString &FSS, UPARAM(Ref)FSafeString &SS);

	/** Get:: Safe String < Safe String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe String)", CompactNodeTitle = "<", Keywords = "Security Get Safe String LESS <"))
	static bool SCO_Pure_GetSafeStringSmallerFSS(UPARAM(Ref)FSafeString &FSS, UPARAM(Ref)FSafeString &SS);

	/** Set:: Safe String = Safe String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe String)", CompactNodeTitle = "=", Keywords = "Security Set Safe String EQUAL ="))
	static FSafeString SCO_Pure_SetSafeStringEqualFSS(UPARAM(Ref)FSafeString &FSS, UPARAM(Ref)FSafeString &SS, FString &Output);

	/** Get:: Safe String + Safe String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe String)", CompactNodeTitle = "+", Keywords = "Security Get Safe String PLUS +"))
	static FSafeString SCO_Pure_GetSafeStringPlusFSS(UPARAM(Ref)FSafeString &FSS, UPARAM(Ref)FSafeString &SS, FString &Output);
	
	/* Native -> FSafe */

	/** Get:: Safe String == String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (String)", CompactNodeTitle = "==", Keywords = "Security Get Safe String EQUAL =="))
	static bool SCO_Pure_GetSafeStringEqualString(UPARAM(Ref)FSafeString &FSS, UPARAM(Ref)FString &NS);

	/** Get:: Safe String != String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (String)", CompactNodeTitle = "!=", Keywords = "Security Get Safe String NOT !="))
	static bool SCO_Pure_GetSafeStringNotEqualString(UPARAM(Ref)FSafeString &FSS, UPARAM(Ref)FString &NS);

	/** Get:: Safe String > String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (String)", CompactNodeTitle = ">", Keywords = "Security Get Safe String GREATER >"))
	static bool SCO_Pure_GetSafeStringGreaterString(UPARAM(Ref)FSafeString &FSS, UPARAM(Ref)FString &NS);

	/** Get:: Safe String < String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (String)", CompactNodeTitle = "<", Keywords = "Security Get Safe String LESS <"))
	static bool SCO_Pure_GetSafeStringSmallerString(UPARAM(Ref)FSafeString &FSS, UPARAM(Ref)FString &NS);

	/** Set:: Safe String = String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (String)", CompactNodeTitle = "=", Keywords = "Security Set Safe String EQUAL ="))
	static FSafeString SCO_Pure_SetSafeStringEqualString(UPARAM(Ref)FSafeString &FSS, UPARAM(Ref)FString &NS, FString &Output);

	/** Get:: Safe String + String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (String)", CompactNodeTitle = "+", Keywords = "Security Get Safe String PLUS +"))
	static FSafeString SCO_Pure_GetSafeStringPlusString(UPARAM(Ref)FSafeString &FSS, UPARAM(Ref)FString &NS, FString &Output);
	
	/* FSafe -> Native */

	/** Get:: String == Safe String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe String)", CompactNodeTitle = "==", Keywords = "Security Get Safe String EQUAL =="))
	static bool SCO_Pure_GetStringEqualFSS(UPARAM(Ref)FString &NS, UPARAM(Ref)FSafeString &FSS);

	/** Get:: String != Safe String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe String)", CompactNodeTitle = "!=", Keywords = "Security Get Safe String NOT !="))
	static bool SCO_Pure_GetStringNotEqualFSS(UPARAM(Ref)FString &NS, UPARAM(Ref)FSafeString &FSS);

	/** Get:: String > Safe String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe String)", CompactNodeTitle = ">", Keywords = "Security Get Safe String GREATER >"))
	static bool SCO_Pure_GetStringGreaterFSS(UPARAM(Ref)FString &NS, UPARAM(Ref)FSafeString &FSS);

	/** Get:: String < Safe String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe String)", CompactNodeTitle = "<", Keywords = "Security Get Safe String LESS <"))
	static bool SCO_Pure_GetStringSmallerFSS(UPARAM(Ref)FString &NS, UPARAM(Ref)FSafeString &FSS);

	/** Set:: String = Safe String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe String)", CompactNodeTitle = "=", Keywords = "Security Set Safe String EQUAL ="))
	static FString SCO_Pure_SetStringEqualFSS(UPARAM(Ref)FString &NS, UPARAM(Ref)FSafeString &FSS);

	/** Get:: String + Safe String */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe String)", CompactNodeTitle = "+", Keywords = "Security Get Safe String PLUS +"))
	static FString SCO_Pure_GetStringPlusFSS(UPARAM(Ref)FString &NS, UPARAM(Ref)FSafeString &FSS);

	// FSVector2D

	/* FSafe -> FSafe */

	/** Get:: Safe Vector2D == Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Vector2D)", CompactNodeTitle = "==", Keywords = "Security Get Safe Vector2D EQUAL =="))
	static bool SCO_Pure_GetSafeVector2DEqualFSV(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FSafeVector2D &SSV);

	/** Get:: Safe Vector2D != Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Vector2D)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Vector2D NOT !="))
	static bool SCO_Pure_GetSafeVector2DNotEqualFSV(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FSafeVector2D &SSV);

	/** Get:: Safe Vector2D > Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Vector2D)", CompactNodeTitle = ">", Keywords = "Security Get Safe Vector2D GREATER >"))
	static bool SCO_Pure_GetSafeVector2DGreaterFSV(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FSafeVector2D &SSV);

	/** Get:: Safe Vector2D < Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Vector2D)", CompactNodeTitle = "<", Keywords = "Security Get Safe Vector2D LESS <"))
	static bool SCO_Pure_GetSafeVector2DSmallerFSV(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FSafeVector2D &SSV);

	/** Get:: Safe Vector2D >= Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Vector2D)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Vector2D GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeVector2DGreaterEqualFSV(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FSafeVector2D &SSV);

	/** Get:: Safe Vector2D <= Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Vector2D)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Vector2D LESS EQUAL <="))
	static bool SCO_Pure_GetSafeVector2DSmallerEqualFSV(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FSafeVector2D &SSV);

	/** Set:: Safe Vector2D = Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Vector2D)", CompactNodeTitle = "=", Keywords = "Security Set Safe Vector2D EQUAL ="))
	static FSafeVector2D SCO_Pure_SetSafeVector2DEqualFSV(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FSafeVector2D &SSV, FVector2D &Output);

	/** Get:: Safe Vector2D + Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Vector2D)", CompactNodeTitle = "+", Keywords = "Security Get Safe Vector2D PLUS +"))
	static FSafeVector2D SCO_Pure_GetSafeVector2DPlusFSV(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FSafeVector2D &SSV, FVector2D &Output);

	/** Get:: Safe Vector2D - Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Vector2D)", CompactNodeTitle = "-", Keywords = "Security Get Safe Vector2D MINUS -"))
	static FSafeVector2D SCO_Pure_GetSafeVector2DMinusFSV(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FSafeVector2D &SSV, FVector2D &Output);

	/** Get:: Safe Vector2D * Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Vector2D)", CompactNodeTitle = "*", Keywords = "Security Get Safe Vector2D TIMES *"))
	static FSafeVector2D SCO_Pure_GetSafeVector2DTimesFSV(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FSafeVector2D &SSV, FVector2D &Output);

	/** Get:: Safe Vector2D / Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Vector2D)", CompactNodeTitle = "/", Keywords = "Security Get Safe Vector2D DIVIDE /"))
	static FSafeVector2D SCO_Pure_GetSafeVector2DDivideFSV(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FSafeVector2D &SSV, FVector2D &Output);

	/** Get:: Safe Vector2D % Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Vector2D)", CompactNodeTitle = "%", Keywords = "Security Get Safe Vector2D MOD %"))
	static FSafeVector2D SCO_Pure_GetSafeVector2DModFSV(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FSafeVector2D &SSV, FVector2D &Output);

	/* Native -> FSafe */

	/** Get:: Safe Vector2D == Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Vector2D)", CompactNodeTitle = "==", Keywords = "Security Get Safe Vector2D EQUAL =="))
	static bool SCO_Pure_GetSafeVector2DEqualVector2D(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FVector2D &NV);

	/** Get:: Safe Vector2D != Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Vector2D)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Vector2D NOT !="))
	static bool SCO_Pure_GetSafeVector2DNotEqualVector2D(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FVector2D &NV);

	/** Get:: Safe Vector2D > Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Vector2D)", CompactNodeTitle = ">", Keywords = "Security Get Safe Vector2D GREATER >"))
	static bool SCO_Pure_GetSafeVector2DGreaterVector2D(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FVector2D &NV);

	/** Get:: Safe Vector2D < Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Vector2D)", CompactNodeTitle = "<", Keywords = "Security Get Safe Vector2D LESS <"))
	static bool SCO_Pure_GetSafeVector2DSmallerVector2D(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FVector2D &NV);

	/** Get:: Safe Vector2D >= Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Vector2D)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Vector2D GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeVector2DGreaterEqualVector2D(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FVector2D &NV);

	/** Get:: Safe Vector2D <= Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Vector2D)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Vector2D LESS EQUAL <="))
	static bool SCO_Pure_GetSafeVector2DSmallerEqualVector2D(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FVector2D &NV);

	/** Set:: Safe Vector2D = Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Vector2D)", CompactNodeTitle = "=", Keywords = "Security Set Safe Vector2D EQUAL ="))
	static FSafeVector2D SCO_Pure_SetSafeVector2DEqualVector2D(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FVector2D &NV, FVector2D &Output);

	/** Get:: Safe Vector2D + Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Vector2D)", CompactNodeTitle = "+", Keywords = "Security Get Safe Vector2D PLUS +"))
	static FSafeVector2D SCO_Pure_GetSafeVector2DPlusVector2D(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FVector2D &NV, FVector2D &Output);

	/** Get:: Safe Vector2D - Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Vector2D)", CompactNodeTitle = "-", Keywords = "Security Get Safe Vector2D MINUS -"))
	static FSafeVector2D SCO_Pure_GetSafeVector2DMinusVector2D(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FVector2D &NV, FVector2D &Output);

	/** Get:: Safe Vector2D * Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Vector2D)", CompactNodeTitle = "*", Keywords = "Security Get Safe Vector2D TIMES *"))
	static FSafeVector2D SCO_Pure_GetSafeVector2DTimesVector2D(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FVector2D &NV, FVector2D &Output);

	/** Get:: Safe Vector2D / Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Vector2D)", CompactNodeTitle = "/", Keywords = "Security Get Safe Vector2D DIVIDE /"))
	static FSafeVector2D SCO_Pure_GetSafeVector2DDivideVector2D(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FVector2D &NV, FVector2D &Output);

	/** Get:: Safe Vector2D % Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Vector2D)", CompactNodeTitle = "%", Keywords = "Security Get Safe Vector2D MOD %"))
	static FSafeVector2D SCO_Pure_GetSafeVector2DModVector2D(UPARAM(Ref)FSafeVector2D &FSV, UPARAM(Ref)FVector2D &NV, FVector2D &Output);

	/* FSafe -> Native */

	/** Get:: Vector2D == Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Vector2D)", CompactNodeTitle = "==", Keywords = "Security Get Safe Vector2D EQUAL =="))
	static bool SCO_Pure_GetVector2DEqualFSV(UPARAM(Ref)FVector2D &NV, UPARAM(Ref)FSafeVector2D &FSV);

	/** Get:: Vector2D != Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Vector2D)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Vector2D NOT !="))
	static bool SCO_Pure_GetVector2DNotEqualFSV(UPARAM(Ref)FVector2D &NV, UPARAM(Ref)FSafeVector2D &FSV);

	/** Get:: Vector2D > Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Vector2D)", CompactNodeTitle = ">", Keywords = "Security Get Safe Vector2D GREATER >"))
	static bool SCO_Pure_GetVector2DGreaterFSV(UPARAM(Ref)FVector2D &NV, UPARAM(Ref)FSafeVector2D &FSV);

	/** Get:: Vector2D < Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Vector2D)", CompactNodeTitle = "<", Keywords = "Security Get Safe Vector2D LESS <"))
	static bool SCO_Pure_GetVector2DSmallerFSV(UPARAM(Ref)FVector2D &NV, UPARAM(Ref)FSafeVector2D &FSV);

	/** Get:: Vector2D >= Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Vector2D)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Vector2D GREATER EQUAL >="))
	static bool SCO_Pure_GetVector2DGreaterEqualFSV(UPARAM(Ref)FVector2D &NV, UPARAM(Ref)FSafeVector2D &FSV);

	/** Get:: Vector2D <= Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Vector2D)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Vector2D LESS EQUAL <="))
	static bool SCO_Pure_GetVector2DSmallerEqualFSV(UPARAM(Ref)FVector2D &NV, UPARAM(Ref)FSafeVector2D &FSV);

	/** Set:: Vector2D = Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Vector2D)", CompactNodeTitle = "=", Keywords = "Security Set Safe Vector2D EQUAL ="))
	static FVector2D SCO_Pure_SetVector2DEqualFSV(UPARAM(Ref)FVector2D &NV, UPARAM(Ref)FSafeVector2D &FSV);

	/** Get:: Vector2D + Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Vector2D)", CompactNodeTitle = "+", Keywords = "Security Get Safe Vector2D PLUS +"))
	static FVector2D SCO_Pure_GetVector2DPlusFSV(UPARAM(Ref)FVector2D &NV, UPARAM(Ref)FSafeVector2D &FSV);

	/** Get:: Vector2D - Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Vector2D)", CompactNodeTitle = "-", Keywords = "Security Get Safe Vector2D MINUS -"))
	static FVector2D SCO_Pure_GetVector2DMinusFSV(UPARAM(Ref)FVector2D &NV, UPARAM(Ref)FSafeVector2D &FSV);

	/** Get:: Vector2D * Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Vector2D)", CompactNodeTitle = "*", Keywords = "Security Get Safe Vector2D TIMES *"))
	static FVector2D SCO_Pure_GetVector2DTimesFSV(UPARAM(Ref)FVector2D &NV, UPARAM(Ref)FSafeVector2D &FSV);

	/** Get:: Vector2D / Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Vector2D)", CompactNodeTitle = "/", Keywords = "Security Get Safe Vector2D DIVIDE /"))
	static FVector2D SCO_Pure_GetVector2DDivideFSV(UPARAM(Ref)FVector2D &NV, UPARAM(Ref)FSafeVector2D &FSV);

	/** Get:: Vector2D % Safe Vector2D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Vector2D)", CompactNodeTitle = "%", Keywords = "Security Get Safe Vector2D MOD %"))
	static FVector2D SCO_Pure_GetVector2DModFSV(UPARAM(Ref)FVector2D &NV, UPARAM(Ref)FSafeVector2D &FSV);

	// FSVector3D

	/* FSafe -> FSafe */

	/** Get:: Safe Vector3D == Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Vector3D)", CompactNodeTitle = "==", Keywords = "Security Get Safe Vector3D EQUAL =="))
	static bool SCO_Pure_GetSafeVector3DEqualFSV(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FSafeVector3D &SSV);

	/** Get:: Safe Vector3D != Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Vector3D)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Vector3D NOT !="))
	static bool SCO_Pure_GetSafeVector3DNotEqualFSV(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FSafeVector3D &SSV);

	/** Get:: Safe Vector3D > Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Vector3D)", CompactNodeTitle = ">", Keywords = "Security Get Safe Vector3D GREATER >"))
	static bool SCO_Pure_GetSafeVector3DGreaterFSV(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FSafeVector3D &SSV);

	/** Get:: Safe Vector3D < Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Vector3D)", CompactNodeTitle = "<", Keywords = "Security Get Safe Vector3D LESS <"))
	static bool SCO_Pure_GetSafeVector3DSmallerFSV(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FSafeVector3D &SSV);

	/** Get:: Safe Vector3D >= Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Vector3D)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Vector3D GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeVector3DGreaterEqualFSV(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FSafeVector3D &SSV);

	/** Get:: Safe Vector3D <= Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Vector3D)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Vector3D LESS EQUAL <="))
	static bool SCO_Pure_GetSafeVector3DSmallerEqualFSV(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FSafeVector3D &SSV);

	/** Set:: Safe Vector3D = Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Vector3D)", CompactNodeTitle = "=", Keywords = "Security Set Safe Vector3D EQUAL ="))
	static FSafeVector3D SCO_Pure_SetSafeVector3DEqualFSV(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FSafeVector3D &SSV, FVector &Output);

	/** Get:: Safe Vector3D + Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Vector3D)", CompactNodeTitle = "+", Keywords = "Security Get Safe Vector3D PLUS +"))
	static FSafeVector3D SCO_Pure_GetSafeVector3DPlusFSV(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FSafeVector3D &SSV, FVector &Output);

	/** Get:: Safe Vector3D - Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Vector3D)", CompactNodeTitle = "-", Keywords = "Security Get Safe Vector3D MINUS -"))
	static FSafeVector3D SCO_Pure_GetSafeVector3DMinusFSV(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FSafeVector3D &SSV, FVector &Output);

	/** Get:: Safe Vector3D * Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Vector3D)", CompactNodeTitle = "*", Keywords = "Security Get Safe Vector3D TIMES *"))
	static FSafeVector3D SCO_Pure_GetSafeVector3DTimesFSV(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FSafeVector3D &SSV, FVector &Output);

	/** Get:: Safe Vector3D / Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Vector3D)", CompactNodeTitle = "/", Keywords = "Security Get Safe Vector3D DIVIDE /"))
	static FSafeVector3D SCO_Pure_GetSafeVector3DDivideFSV(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FSafeVector3D &SSV, FVector &Output);

	/** Get:: Safe Vector3D % Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Vector3D)", CompactNodeTitle = "%", Keywords = "Security Get Safe Vector3D MOD %"))
	static FSafeVector3D SCO_Pure_GetSafeVector3DModFSV(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FSafeVector3D &SSV, FVector &Output);

	/* Native -> FSafe */

	/** Get:: Safe Vector3D == Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Vector3D)", CompactNodeTitle = "==", Keywords = "Security Get Safe Vector3D EQUAL =="))
	static bool SCO_Pure_GetSafeVector3DEqualVector3D(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FVector &NV);

	/** Get:: Safe Vector3D != Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Vector3D)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Vector3D NOT !="))
	static bool SCO_Pure_GetSafeVector3DNotEqualVector3D(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FVector &NV);

	/** Get:: Safe Vector3D > Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Vector3D)", CompactNodeTitle = ">", Keywords = "Security Get Safe Vector3D GREATER >"))
	static bool SCO_Pure_GetSafeVector3DGreaterVector3D(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FVector &NV);

	/** Get:: Safe Vector3D < Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Vector3D)", CompactNodeTitle = "<", Keywords = "Security Get Safe Vector3D LESS <"))
	static bool SCO_Pure_GetSafeVector3DSmallerVector3D(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FVector &NV);

	/** Get:: Safe Vector3D >= Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Vector3D)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Vector3D GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeVector3DGreaterEqualVector3D(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FVector &NV);

	/** Get:: Safe Vector3D <= Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Vector3D)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Vector3D LESS EQUAL <="))
	static bool SCO_Pure_GetSafeVector3DSmallerEqualVector3D(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FVector &NV);

	/** Set:: Safe Vector3D = Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Vector3D)", CompactNodeTitle = "=", Keywords = "Security Set Safe Vector3D EQUAL ="))
	static FSafeVector3D SCO_Pure_SetSafeVector3DEqualVector3D(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FVector &NV, FVector &Output);

	/** Get:: Safe Vector3D + Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Vector3D)", CompactNodeTitle = "+", Keywords = "Security Get Safe Vector3D PLUS +"))
	static FSafeVector3D SCO_Pure_GetSafeVector3DPlusVector3D(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FVector &NV, FVector &Output);

	/** Get:: Safe Vector3D - Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Vector3D)", CompactNodeTitle = "-", Keywords = "Security Get Safe Vector3D MINUS -"))
	static FSafeVector3D SCO_Pure_GetSafeVector3DMinusVector3D(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FVector &NV, FVector &Output);

	/** Get:: Safe Vector3D * Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Vector3D)", CompactNodeTitle = "*", Keywords = "Security Get Safe Vector3D TIMES *"))
	static FSafeVector3D SCO_Pure_GetSafeVector3DTimesVector3D(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FVector &NV, FVector &Output);

	/** Get:: Safe Vector3D / Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Vector3D)", CompactNodeTitle = "/", Keywords = "Security Get Safe Vector3D DIVIDE /"))
	static FSafeVector3D SCO_Pure_GetSafeVector3DDivideVector3D(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FVector &NV, FVector &Output);

	/** Get:: Safe Vector3D % Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Vector3D)", CompactNodeTitle = "%", Keywords = "Security Get Safe Vector3D MOD %"))
	static FSafeVector3D SCO_Pure_GetSafeVector3DModVector3D(UPARAM(Ref)FSafeVector3D &FSV, UPARAM(Ref)FVector &NV, FVector &Output);

	/* FSafe -> Native */

	/** Get:: Vector3D == Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Vector3D)", CompactNodeTitle = "==", Keywords = "Security Get Safe Vector3D EQUAL =="))
	static bool SCO_Pure_GetVector3DEqualFSV(UPARAM(Ref)FVector &NV, UPARAM(Ref)FSafeVector3D &FSV);

	/** Get:: Vector3D != Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Vector3D)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Vector3D NOT !="))
	static bool SCO_Pure_GetVector3DNotEqualFSV(UPARAM(Ref)FVector &NV, UPARAM(Ref)FSafeVector3D &FSV);

	/** Get:: Vector3D > Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Vector3D)", CompactNodeTitle = ">", Keywords = "Security Get Safe Vector3D GREATER >"))
	static bool SCO_Pure_GetVector3DGreaterFSV(UPARAM(Ref)FVector &NV, UPARAM(Ref)FSafeVector3D &FSV);

	/** Get:: Vector3D < Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Vector3D)", CompactNodeTitle = "<", Keywords = "Security Get Safe Vector3D LESS <"))
	static bool SCO_Pure_GetVector3DSmallerFSV(UPARAM(Ref)FVector &NV, UPARAM(Ref)FSafeVector3D &FSV);

	/** Get:: Vector3D >= Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Vector3D)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Vector3D GREATER EQUAL >="))
	static bool SCO_Pure_GetVector3DGreaterEqualFSV(UPARAM(Ref)FVector &NV, UPARAM(Ref)FSafeVector3D &FSV);

	/** Get:: Vector3D <= Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Vector3D)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Vector3D LESS EQUAL <="))
	static bool SCO_Pure_GetVector3DSmallerEqualFSV(UPARAM(Ref)FVector &NV, UPARAM(Ref)FSafeVector3D &FSV);

	/** Set:: Vector3D = Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Vector3D)", CompactNodeTitle = "=", Keywords = "Security Set Safe Vector3D EQUAL ="))
	static FVector SCO_Pure_SetVector3DEqualFSV(UPARAM(Ref)FVector &NV, UPARAM(Ref)FSafeVector3D &FSV);

	/** Get:: Vector3D + Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Vector3D)", CompactNodeTitle = "+", Keywords = "Security Get Safe Vector3D PLUS +"))
	static FVector SCO_Pure_GetVector3DPlusFSV(UPARAM(Ref)FVector &NV, UPARAM(Ref)FSafeVector3D &FSV);

	/** Get:: Vector3D - Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Vector3D)", CompactNodeTitle = "-", Keywords = "Security Get Safe Vector3D MINUS -"))
	static FVector SCO_Pure_GetVector3DMinusFSV(UPARAM(Ref)FVector &NV, UPARAM(Ref)FSafeVector3D &FSV);

	/** Get:: Vector3D * Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Vector3D)", CompactNodeTitle = "*", Keywords = "Security Get Safe Vector3D TIMES *"))
	static FVector SCO_Pure_GetVector3DTimesFSV(UPARAM(Ref)FVector &NV, UPARAM(Ref)FSafeVector3D &FSV);

	/** Get:: Vector3D / Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Vector3D)", CompactNodeTitle = "/", Keywords = "Security Get Safe Vector3D DIVIDE /"))
	static FVector SCO_Pure_GetVector3DDivideFSV(UPARAM(Ref)FVector &NV, UPARAM(Ref)FSafeVector3D &FSV);

	/** Get:: Vector3D % Safe Vector3D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Vector3D)", CompactNodeTitle = "%", Keywords = "Security Get Safe Vector3D MOD %"))
	static FVector SCO_Pure_GetVector3DModFSV(UPARAM(Ref)FVector &NV, UPARAM(Ref)FSafeVector3D &FSV);

	// FSVector4D

	/* FSafe -> FSafe */

	/** Get:: Safe Vector4D == Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Vector4D)", CompactNodeTitle = "==", Keywords = "Security Get Safe Vector4D EQUAL =="))
	static bool SCO_Pure_GetSafeVector4DEqualFSV(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FSafeVector4D &SSV);

	/** Get:: Safe Vector4D != Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Vector4D)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Vector4D NOT !="))
	static bool SCO_Pure_GetSafeVector4DNotEqualFSV(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FSafeVector4D &SSV);

	/** Get:: Safe Vector4D > Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Vector4D)", CompactNodeTitle = ">", Keywords = "Security Get Safe Vector4D GREATER >"))
	static bool SCO_Pure_GetSafeVector4DGreaterFSV(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FSafeVector4D &SSV);

	/** Get:: Safe Vector4D < Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Vector4D)", CompactNodeTitle = "<", Keywords = "Security Get Safe Vector4D LESS <"))
	static bool SCO_Pure_GetSafeVector4DSmallerFSV(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FSafeVector4D &SSV);

	/** Get:: Safe Vector4D >= Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Vector4D)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Vector4D GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeVector4DGreaterEqualFSV(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FSafeVector4D &SSV);

	/** Get:: Safe Vector4D <= Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Vector4D)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Vector4D LESS EQUAL <="))
	static bool SCO_Pure_GetSafeVector4DSmallerEqualFSV(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FSafeVector4D &SSV);

	/** Set:: Safe Vector4D = Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Vector4D)", CompactNodeTitle = "=", Keywords = "Security Set Safe Vector4D EQUAL ="))
	static FSafeVector4D SCO_Pure_SetSafeVector4DEqualFSV(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FSafeVector4D &SSV, FVector4 &Output);

	/** Get:: Safe Vector4D + Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Vector4D)", CompactNodeTitle = "+", Keywords = "Security Get Safe Vector4D PLUS +"))
	static FSafeVector4D SCO_Pure_GetSafeVector4DPlusFSV(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FSafeVector4D &SSV, FVector4 &Output);

	/** Get:: Safe Vector4D - Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Vector4D)", CompactNodeTitle = "-", Keywords = "Security Get Safe Vector4D MINUS -"))
	static FSafeVector4D SCO_Pure_GetSafeVector4DMinusFSV(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FSafeVector4D &SSV, FVector4 &Output);

	/** Get:: Safe Vector4D * Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Vector4D)", CompactNodeTitle = "*", Keywords = "Security Get Safe Vector4D TIMES *"))
	static FSafeVector4D SCO_Pure_GetSafeVector4DTimesFSV(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FSafeVector4D &SSV, FVector4 &Output);

	/** Get:: Safe Vector4D / Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Vector4D)", CompactNodeTitle = "/", Keywords = "Security Get Safe Vector4D DIVIDE /"))
	static FSafeVector4D SCO_Pure_GetSafeVector4DDivideFSV(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FSafeVector4D &SSV, FVector4 &Output);

	/** Get:: Safe Vector4D % Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Vector4D)", CompactNodeTitle = "%", Keywords = "Security Get Safe Vector4D MOD %"))
	static FSafeVector4D SCO_Pure_GetSafeVector4DModFSV(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FSafeVector4D &SSV, FVector4 &Output);

	/* Native -> FSafe */

	/** Get:: Safe Vector4D == Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Vector4D)", CompactNodeTitle = "==", Keywords = "Security Get Safe Vector4D EQUAL =="))
	static bool SCO_Pure_GetSafeVector4DEqualVector4D(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FVector4 &NV);

	/** Get:: Safe Vector4D != Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Vector4D)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Vector4D NOT !="))
	static bool SCO_Pure_GetSafeVector4DNotEqualVector4D(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FVector4 &NV);

	/** Get:: Safe Vector4D > Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Vector4D)", CompactNodeTitle = ">", Keywords = "Security Get Safe Vector4D GREATER >"))
	static bool SCO_Pure_GetSafeVector4DGreaterVector4D(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FVector4 &NV);

	/** Get:: Safe Vector4D < Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Vector4D)", CompactNodeTitle = "<", Keywords = "Security Get Safe Vector4D LESS <"))
	static bool SCO_Pure_GetSafeVector4DSmallerVector4D(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FVector4 &NV);

	/** Get:: Safe Vector4D >= Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Vector4D)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Vector4D GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeVector4DGreaterEqualVector4D(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FVector4 &NV);

	/** Get:: Safe Vector4D <= Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Vector4D)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Vector4D LESS EQUAL <="))
	static bool SCO_Pure_GetSafeVector4DSmallerEqualVector4D(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FVector4 &NV);

	/** Set:: Safe Vector4D = Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Vector4D)", CompactNodeTitle = "=", Keywords = "Security Set Safe Vector4D EQUAL ="))
	static FSafeVector4D SCO_Pure_SetSafeVector4DEqualVector4D(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FVector4 &NV, FVector4 &Output);

	/** Get:: Safe Vector4D + Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Vector4D)", CompactNodeTitle = "+", Keywords = "Security Get Safe Vector4D PLUS +"))
	static FSafeVector4D SCO_Pure_GetSafeVector4DPlusVector4D(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FVector4 &NV, FVector4 &Output);

	/** Get:: Safe Vector4D - Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Vector4D)", CompactNodeTitle = "-", Keywords = "Security Get Safe Vector4D MINUS -"))
	static FSafeVector4D SCO_Pure_GetSafeVector4DMinusVector4D(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FVector4 &NV, FVector4 &Output);

	/** Get:: Safe Vector4D * Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Vector4D)", CompactNodeTitle = "*", Keywords = "Security Get Safe Vector4D TIMES *"))
	static FSafeVector4D SCO_Pure_GetSafeVector4DTimesVector4D(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FVector4 &NV, FVector4 &Output);

	/** Get:: Safe Vector4D / Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Vector4D)", CompactNodeTitle = "/", Keywords = "Security Get Safe Vector4D DIVIDE /"))
	static FSafeVector4D SCO_Pure_GetSafeVector4DDivideVector4D(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FVector4 &NV, FVector4 &Output);

	/** Get:: Safe Vector4D % Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Vector4D)", CompactNodeTitle = "%", Keywords = "Security Get Safe Vector4D MOD %"))
	static FSafeVector4D SCO_Pure_GetSafeVector4DModVector4D(UPARAM(Ref)FSafeVector4D &FSV, UPARAM(Ref)FVector4 &NV, FVector4 &Output);

	/* FSafe -> Native */

	/** Get:: Vector4D == Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Vector4D)", CompactNodeTitle = "==", Keywords = "Security Get Safe Vector4D EQUAL =="))
	static bool SCO_Pure_GetVector4DEqualFSV(UPARAM(Ref)FVector4 &NV, UPARAM(Ref)FSafeVector4D &FSV);

	/** Get:: Vector4D != Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Vector4D)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Vector4D NOT !="))
	static bool SCO_Pure_GetVector4DNotEqualFSV(UPARAM(Ref)FVector4 &NV, UPARAM(Ref)FSafeVector4D &FSV);

	/** Get:: Vector4D > Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Vector4D)", CompactNodeTitle = ">", Keywords = "Security Get Safe Vector4D GREATER >"))
	static bool SCO_Pure_GetVector4DGreaterFSV(UPARAM(Ref)FVector4 &NV, UPARAM(Ref)FSafeVector4D &FSV);

	/** Get:: Vector4D < Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Vector4D)", CompactNodeTitle = "<", Keywords = "Security Get Safe Vector4D LESS <"))
	static bool SCO_Pure_GetVector4DSmallerFSV(UPARAM(Ref)FVector4 &NV, UPARAM(Ref)FSafeVector4D &FSV);

	/** Get:: Vector4D >= Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Vector4D)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Vector4D GREATER EQUAL >="))
	static bool SCO_Pure_GetVector4DGreaterEqualFSV(UPARAM(Ref)FVector4 &NV, UPARAM(Ref)FSafeVector4D &FSV);

	/** Get:: Vector4D <= Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Vector4D)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Vector4D LESS EQUAL <="))
	static bool SCO_Pure_GetVector4DSmallerEqualFSV(UPARAM(Ref)FVector4 &NV, UPARAM(Ref)FSafeVector4D &FSV);

	/** Set:: Vector4D = Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Vector4D)", CompactNodeTitle = "=", Keywords = "Security Set Safe Vector4D EQUAL ="))
	static FVector4 SCO_Pure_SetVector4DEqualFSV(UPARAM(Ref)FVector4 &NV, UPARAM(Ref)FSafeVector4D &FSV);

	/** Get:: Vector4D + Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Vector4D)", CompactNodeTitle = "+", Keywords = "Security Get Safe Vector4D PLUS +"))
	static FVector4 SCO_Pure_GetVector4DPlusFSV(UPARAM(Ref)FVector4 &NV, UPARAM(Ref)FSafeVector4D &FSV);

	/** Get:: Vector4D - Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Vector4D)", CompactNodeTitle = "-", Keywords = "Security Get Safe Vector4D MINUS -"))
	static FVector4 SCO_Pure_GetVector4DMinusFSV(UPARAM(Ref)FVector4 &NV, UPARAM(Ref)FSafeVector4D &FSV);

	/** Get:: Vector4D * Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Vector4D)", CompactNodeTitle = "*", Keywords = "Security Get Safe Vector4D TIMES *"))
	static FVector4 SCO_Pure_GetVector4DTimesFSV(UPARAM(Ref)FVector4 &NV, UPARAM(Ref)FSafeVector4D &FSV);

	/** Get:: Vector4D / Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Vector4D)", CompactNodeTitle = "/", Keywords = "Security Get Safe Vector4D DIVIDE /"))
	static FVector4 SCO_Pure_GetVector4DDivideFSV(UPARAM(Ref)FVector4 &NV, UPARAM(Ref)FSafeVector4D &FSV);

	/** Get:: Vector4D % Safe Vector4D */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Vector4D)", CompactNodeTitle = "%", Keywords = "Security Get Safe Vector4D MOD %"))
	static FVector4 SCO_Pure_GetVector4DModFSV(UPARAM(Ref)FVector4 &NV, UPARAM(Ref)FSafeVector4D &FSV);

	// FSColor

	/* FSafe -> FSafe */

	/** Get:: Safe Color == Safe Color */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Color)", CompactNodeTitle = "==", Keywords = "Security Get Safe Color EQUAL =="))
	static bool SCO_Pure_GetSafeColorEqualFSC(UPARAM(Ref)FSafeColor &FSC, UPARAM(Ref)FSafeColor &SSC);

	/** Get:: Safe Color != Safe Color */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Color)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Color NOT !="))
	static bool SCO_Pure_GetSafeColorNotEqualFSC(UPARAM(Ref)FSafeColor &FSC, UPARAM(Ref)FSafeColor &SSC);

	/** Set:: Safe Color = Safe Color */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Color)", CompactNodeTitle = "=", Keywords = "Security Set Safe Color EQUAL ="))
	static FSafeColor SCO_Pure_SetSafeColorEqualFSC(UPARAM(Ref)FSafeColor &FSC, UPARAM(Ref)FSafeColor &SSC, FLinearColor &Output);
	
	/* Native -> FSafe */

	/** Get:: Safe Color == Color */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Color)", CompactNodeTitle = "==", Keywords = "Security Get Safe Color EQUAL =="))
	static bool SCO_Pure_GetSafeColorEqualColor(UPARAM(Ref)FSafeColor &FSC, UPARAM(Ref)FLinearColor &NC);

	/** Get:: Safe Color != Color */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Color)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Color NOT !="))
	static bool SCO_Pure_GetSafeColorNotEqualColor(UPARAM(Ref)FSafeColor &FSC, UPARAM(Ref)FLinearColor &NC);

	/** Set:: Safe Color = Color */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Color)", CompactNodeTitle = "=", Keywords = "Security Set Safe Color EQUAL ="))
	static FSafeColor SCO_Pure_SetSafeColorEqualColor(UPARAM(Ref)FSafeColor &FSC, UPARAM(Ref)FLinearColor &SSC, FLinearColor &Output);

	/* FSafe -> Native */

	/** Get:: Color == Safe Color */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Color)", CompactNodeTitle = "==", Keywords = "Security Get Safe Color EQUAL =="))
	static bool SCO_Pure_GetColorEqualFSC(UPARAM(Ref)FLinearColor &NC, UPARAM(Ref)FSafeColor &FSC);

	/** Get:: Color != Safe Color */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Color)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Color NOT !="))
	static bool SCO_Pure_GetColorNotEqualFSC(UPARAM(Ref)FLinearColor &NC, UPARAM(Ref)FSafeColor &FSC);

	/** Set:: Color = Safe Color */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Color)", CompactNodeTitle = "=", Keywords = "Security Set Safe Color EQUAL ="))
	static FLinearColor SCO_Pure_SetColorEqualFSC(UPARAM(Ref)FLinearColor &NC, UPARAM(Ref)FSafeColor &FSC);

	// FSRotator

	/* FSafe -> FSafe */

	/** Get:: Safe Rotator == Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Rotator)", CompactNodeTitle = "==", Keywords = "Security Get Safe Rotator EQUAL =="))
	static bool SCO_Pure_GetSafeRotatorEqualFSR(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FSafeRotator &SSR);

	/** Get:: Safe Rotator != Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Rotator)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Rotator NOT !="))
	static bool SCO_Pure_GetSafeRotatorNotEqualFSR(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FSafeRotator &SSR);

	/** Get:: Safe Rotator > Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Rotator)", CompactNodeTitle = ">", Keywords = "Security Get Safe Rotator GREATER >"))
	static bool SCO_Pure_GetSafeRotatorGreaterFSR(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FSafeRotator &SSR);

	/** Get:: Safe Rotator < Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Rotator)", CompactNodeTitle = "<", Keywords = "Security Get Safe Rotator LESS <"))
	static bool SCO_Pure_GetSafeRotatorSmallerFSR(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FSafeRotator &SSR);

	/** Get:: Safe Rotator >= Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Rotator)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Rotator GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeRotatorGreaterEqualFSR(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FSafeRotator &SSR);

	/** Get:: Safe Rotator <= Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Rotator)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Rotator LESS EQUAL <="))
	static bool SCO_Pure_GetSafeRotatorSmallerEqualFSR(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FSafeRotator &SSR);

	/** Set:: Safe Rotator = Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Rotator)", CompactNodeTitle = "=", Keywords = "Security Set Safe Rotator EQUAL ="))
	static FSafeRotator SCO_Pure_SetSafeRotatorEqualFSR(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FSafeRotator &SSR, FRotator &Output);

	/** Get:: Safe Rotator + Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Rotator)", CompactNodeTitle = "+", Keywords = "Security Get Safe Rotator PLUS +"))
	static FSafeRotator SCO_Pure_GetSafeRotatorPlusFSR(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FSafeRotator &SSR, FRotator &Output);

	/** Get:: Safe Rotator - Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Rotator)", CompactNodeTitle = "-", Keywords = "Security Get Safe Rotator MINUS -"))
	static FSafeRotator SCO_Pure_GetSafeRotatorMinusFSR(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FSafeRotator &SSR, FRotator &Output);

	/** Get:: Safe Rotator * Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Rotator)", CompactNodeTitle = "*", Keywords = "Security Get Safe Rotator TIMES *"))
	static FSafeRotator SCO_Pure_GetSafeRotatorTimesFSR(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FSafeRotator &SSR, FRotator &Output);

	/** Get:: Safe Rotator / Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Rotator)", CompactNodeTitle = "/", Keywords = "Security Get Safe Rotator DIVIDE /"))
	static FSafeRotator SCO_Pure_GetSafeRotatorDivideFSR(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FSafeRotator &SSR, FRotator &Output);

	/** Get:: Safe Rotator % Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Rotator)", CompactNodeTitle = "%", Keywords = "Security Get Safe Rotator MOD %"))
	static FSafeRotator SCO_Pure_GetSafeRotatorModFSR(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FSafeRotator &SSR, FRotator &Output);

	/* Native -> FSafe */

	/** Get:: Safe Rotator == Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Rotator)", CompactNodeTitle = "==", Keywords = "Security Get Safe Rotator EQUAL =="))
	static bool SCO_Pure_GetSafeRotatorEqualRotator(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FRotator &NR);

	/** Get:: Safe Rotator != Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Rotator)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Rotator NOT !="))
	static bool SCO_Pure_GetSafeRotatorNotEqualRotator(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FRotator &NR);

	/** Get:: Safe Rotator > Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Rotator)", CompactNodeTitle = ">", Keywords = "Security Get Safe Rotator GREATER >"))
	static bool SCO_Pure_GetSafeRotatorGreaterRotator(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FRotator &NR);

	/** Get:: Safe Rotator < Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Rotator)", CompactNodeTitle = "<", Keywords = "Security Get Safe Rotator LESS <"))
	static bool SCO_Pure_GetSafeRotatorSmallerRotator(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FRotator &NR);

	/** Get:: Safe Rotator >= Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Rotator)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Rotator GREATER EQUAL >="))
	static bool SCO_Pure_GetSafeRotatorGreaterEqualRotator(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FRotator &NR);

	/** Get:: Safe Rotator <= Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Rotator)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Rotator LESS EQUAL <="))
	static bool SCO_Pure_GetSafeRotatorSmallerEqualRotator(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FRotator &NR);

	/** Set:: Safe Rotator = Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Rotator)", CompactNodeTitle = "=", Keywords = "Security Set Safe Rotator EQUAL ="))
	static FSafeRotator SCO_Pure_SetSafeRotatorEqualRotator(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FRotator &NR, FRotator &Output);

	/** Get:: Safe Rotator + Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Rotator)", CompactNodeTitle = "+", Keywords = "Security Get Safe Rotator PLUS +"))
	static FSafeRotator SCO_Pure_GetSafeRotatorPlusRotator(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FRotator &NR, FRotator &Output);

	/** Get:: Safe Rotator - Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Rotator)", CompactNodeTitle = "-", Keywords = "Security Get Safe Rotator MINUS -"))
	static FSafeRotator SCO_Pure_GetSafeRotatorMinusRotator(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FRotator &NR, FRotator &Output);

	/** Get:: Safe Rotator * Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Rotator)", CompactNodeTitle = "*", Keywords = "Security Get Safe Rotator TIMES *"))
	static FSafeRotator SCO_Pure_GetSafeRotatorTimesRotator(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FRotator &NR, FRotator &Output);

	/** Get:: Safe Rotator / Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Rotator)", CompactNodeTitle = "/", Keywords = "Security Get Safe Rotator DIVIDE /"))
	static FSafeRotator SCO_Pure_GetSafeRotatorDivideRotator(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FRotator &NR, FRotator &Output);

	/** Get:: Safe Rotator % Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Rotator)", CompactNodeTitle = "%", Keywords = "Security Get Safe Rotator MOD %"))
	static FSafeRotator SCO_Pure_GetSafeRotatorModRotator(UPARAM(Ref)FSafeRotator &FSR, UPARAM(Ref)FRotator &NR, FRotator &Output);

	/* FSafe -> Native */

	/** Get:: Rotator == Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Rotator)", CompactNodeTitle = "==", Keywords = "Security Get Safe Rotator EQUAL =="))
	static bool SCO_Pure_GetRotatorEqualFSR(UPARAM(Ref)FRotator &NR, UPARAM(Ref)FSafeRotator &FSR);

	/** Get:: Rotator != Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Rotator)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Rotator NOT !="))
	static bool SCO_Pure_GetRotatorNotEqualFSR(UPARAM(Ref)FRotator &NR, UPARAM(Ref)FSafeRotator &FSR);

	/** Get:: Rotator > Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "> (Safe Rotator)", CompactNodeTitle = ">", Keywords = "Security Get Safe Rotator GREATER >"))
	static bool SCO_Pure_GetRotatorGreaterFSR(UPARAM(Ref)FRotator &NR, UPARAM(Ref)FSafeRotator &FSR);

	/** Get:: Rotator < Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "< (Safe Rotator)", CompactNodeTitle = "<", Keywords = "Security Get Safe Rotator LESS <"))
	static bool SCO_Pure_GetRotatorSmallerFSR(UPARAM(Ref)FRotator &NR, UPARAM(Ref)FSafeRotator &FSR);

	/** Get:: Rotator >= Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = ">= (Safe Rotator)", CompactNodeTitle = ">=", Keywords = "Security Get Safe Rotator GREATER EQUAL >="))
	static bool SCO_Pure_GetRotatorGreaterEqualFSR(UPARAM(Ref)FRotator &NR, UPARAM(Ref)FSafeRotator &FSR);

	/** Get:: Rotator <= Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "<= (Safe Rotator)", CompactNodeTitle = "<=", Keywords = "Security Get Safe Rotator LESS EQUAL <="))
	static bool SCO_Pure_GetRotatorSmallerEqualFSR(UPARAM(Ref)FRotator &NR, UPARAM(Ref)FSafeRotator &FSR);

	/** Set:: Rotator = Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Rotator)", CompactNodeTitle = "=", Keywords = "Security Set Safe Rotator EQUAL ="))
	static FRotator SCO_Pure_SetRotatorEqualFSR(UPARAM(Ref)FRotator &NR, UPARAM(Ref)FSafeRotator &FSR);

	/** Get:: Rotator + Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "+ (Safe Rotator)", CompactNodeTitle = "+", Keywords = "Security Get Safe Rotator PLUS +"))
	static FRotator SCO_Pure_GetRotatorPlusFSR(UPARAM(Ref)FRotator &NR, UPARAM(Ref)FSafeRotator &FSR);

	/** Get:: Rotator - Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "- (Safe Rotator)", CompactNodeTitle = "-", Keywords = "Security Get Safe Rotator MINUS -"))
	static FRotator SCO_Pure_GetRotatorMinusFSR(UPARAM(Ref)FRotator &NR, UPARAM(Ref)FSafeRotator &FSR);

	/** Get:: Rotator * Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "* (Safe Rotator)", CompactNodeTitle = "*", Keywords = "Security Get Safe Rotator TIMES *"))
	static FRotator SCO_Pure_GetRotatorTimesFSR(UPARAM(Ref)FRotator &NR, UPARAM(Ref)FSafeRotator &FSR);

	/** Get:: Rotator / Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "/ (Safe Rotator)", CompactNodeTitle = "/", Keywords = "Security Get Safe Rotator DIVIDE /"))
	static FRotator SCO_Pure_GetRotatorDivideFSR(UPARAM(Ref)FRotator &NR, UPARAM(Ref)FSafeRotator &FSR);

	/** Get:: Rotator % Safe Rotator */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "% (Safe Rotator)", CompactNodeTitle = "%", Keywords = "Security Get Safe Rotator MOD %"))
	static FRotator SCO_Pure_GetRotatorModFSR(UPARAM(Ref)FRotator &NR, UPARAM(Ref)FSafeRotator &FSR);

	// FSTransform

	/* FSafe -> FSafe */

	/** Get:: Safe Transform == Safe Transform */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Transform)", CompactNodeTitle = "==", Keywords = "Security Get Safe Transform EQUAL =="))
	static bool SCO_Pure_GetSafeTransformEqualFST(UPARAM(Ref)FSafeTransform &FST, UPARAM(Ref)FSafeTransform &SST);

	/** Get:: Safe Transform != Safe Transform */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Transform)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Transform NOT !="))
	static bool SCO_Pure_GetSafeTransformNotEqualFST(UPARAM(Ref)FSafeTransform &FST, UPARAM(Ref)FSafeTransform &SST);

	/** Set:: Safe Transform = Safe Transform */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Transform)", CompactNodeTitle = "=", Keywords = "Security Set Safe Transform EQUAL ="))
	static FSafeTransform SCO_Pure_SetSafeTransformEqualFST(UPARAM(Ref)FSafeTransform &FST, UPARAM(Ref)FSafeTransform &SST, FTransform &Output);
	
	/* Native -> FSafe */

	/** Get:: Safe Transform == Transform */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Transform)", CompactNodeTitle = "==", Keywords = "Security Get Safe Transform EQUAL =="))
	static bool SCO_Pure_GetSafeTransformEqualTransform(UPARAM(Ref)FSafeTransform &FST, UPARAM(Ref)FTransform &NT);

	/** Get:: Safe Transform != Transform */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Transform)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Transform NOT !="))
	static bool SCO_Pure_GetSafeTransformNotEqualTransform(UPARAM(Ref)FSafeTransform &FST, UPARAM(Ref)FTransform &NT);

	/** Set:: Safe Transform = Transform */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Transform)", CompactNodeTitle = "=", Keywords = "Security Set Safe Transform EQUAL ="))
	static FSafeTransform SCO_Pure_SetSafeTransformEqualTransform(UPARAM(Ref)FSafeTransform &FST, UPARAM(Ref)FTransform &SST, FTransform &Output);

	/* FSafe -> Native */

	/** Get:: Transform == Safe Transform */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "== (Safe Transform)", CompactNodeTitle = "==", Keywords = "Security Get Safe Transform EQUAL =="))
	static bool SCO_Pure_GetTransformEqualFST(UPARAM(Ref)FTransform &NT, UPARAM(Ref)FSafeTransform &FST);

	/** Get:: Transform != Safe Transform */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "!= (Safe Transform)", CompactNodeTitle = "!=", Keywords = "Security Get Safe Transform NOT !="))
	static bool SCO_Pure_GetTransformNotEqualFST(UPARAM(Ref)FTransform &NT, UPARAM(Ref)FSafeTransform &FST);

	/** Set:: Transform = Safe Transform */
	UFUNCTION(BlueprintPure, Category = "Variables|Security", meta = (DisplayName = "= (Safe Transform)", CompactNodeTitle = "=", Keywords = "Security Set Safe Transform EQUAL ="))
	static FTransform SCO_Pure_SetTransformEqualFST(UPARAM(Ref)FTransform &NT, UPARAM(Ref)FSafeTransform &FST);

};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/SCUE4/Private/ISCUE4.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//		Copyright 2016 (C) Bruno Xavier B. Leite
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "ISCUE4.h"
#include "SCUE4.h"
#include "SCUE4PrivatePCH.h"
	
#if WITH_EDITORONLY_DATA
 #include "ISettingsModule.h"
 #include "ISettingsSection.h"
 #include "ISettingsContainer.h"
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define LOCTEXT_NAMESPACE "Synaptech"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FSCUE4 : public ISCUE4 {
private:
	bool HandleSettingsSaved() {
	  #if WITH_EDITORONLY_DATA
		const auto &Settings = GetMutableDefault<USCUE4Settings>();
		Settings->SaveConfig(); return true;
	  #endif
	return false;}
	//
	void RegisterSettings() {
	  #if WITH_EDITORONLY_DATA
		if (ISettingsModule* SettingsModule = FModuleManager::GetModulePtr<ISettingsModule>("Settings")) {
			ISettingsContainerPtr SettingsContainer = SettingsModule->GetContainer("Project");
			SettingsContainer->DescribeCategory("Synaptech",LOCTEXT("SynaptechCategoryName","Synaptech"),
			LOCTEXT("SynaptechCategoryDescription","Configuration of Synaptech Systems."));
			//
			ISettingsSectionPtr SettingsSection = SettingsModule->RegisterSettings("Project","Synaptech","SCUE4Settings",
				LOCTEXT("SCUE4SettingsName","Anti-Cheat Settings"),
				LOCTEXT("SCUE4SettingsDescription","General settings for the SCUE4 Plugin"),
			GetMutableDefault<USCUE4Settings>());
			//
			if (SettingsSection.IsValid()) {SettingsSection->OnModified().BindRaw(this,&FSCUE4::HandleSettingsSaved);}
		}
	  #endif
	}
	//
	void UnregisterSettings() {
	  #if WITH_EDITORONLY_DATA
		if (ISettingsModule* SettingsModule = FModuleManager::GetModulePtr<ISettingsModule>("Settings")) {
			SettingsModule->UnregisterSettings("Project","Synaptech","SCUE4Settings");
		}
	  #endif
	}
	//
public:
	virtual void StartupModule() override {RegisterSettings(); UE_LOG(LogTemp,Warning,TEXT("{S}:: Initializing Secure-Client Plugin [Anti-Cheat]."));}
	virtual void ShutdownModule() override {if (UObjectInitialized()) {UnregisterSettings();}}
	virtual bool SupportsDynamicReloading() override {return true;}
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#undef LOCTEXT_NAMESPACE

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_GAME_MODULE(FSCUE4,SCUE4);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/SCUE4/Private/SCUE4.cpp`:

```cpp
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//		Copyright 2016 (C) Bruno Xavier B. Leite
//////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "SCUE4.h"
#include "SCUE4PrivatePCH.h"
#include "Interfaces/IPluginManager.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

USCUE4Settings::USCUE4Settings(const FObjectInitializer& OBJ) : Super(OBJ) {
	KeyGeneratorPath = FPaths::Combine(*IPluginManager::Get().FindPlugin(TEXT("SCUE4"))->GetBaseDir(),TEXT("Source/ThirdParty/"),TEXT("SCUE4_Key-Generator.exe"));
	//
	IllegalKeywords.AddUnique(FString(TEXT("spy")));
	IllegalKeywords.AddUnique(FString(TEXT("autohotkey")));
	IllegalKeywords.AddUnique(FString(TEXT("artmoney")));
	IllegalKeywords.AddUnique(FString(TEXT("injector")));
	IllegalKeywords.AddUnique(FString(TEXT("cheat")));
	IllegalKeywords.AddUnique(FString(TEXT("hack")));
	IllegalKeywords.AddUnique(FString(TEXT("crack")));
	IllegalKeywords.AddUnique(FString(TEXT("ccdebug")));
	IllegalKeywords.AddUnique(FString(TEXT("debugger")));
	IllegalKeywords.AddUnique(FString(TEXT("decompile")));
	IllegalKeywords.AddUnique(FString(TEXT("dotpeek")));
	IllegalKeywords.AddUnique(FString(TEXT("eclipse")));
	IllegalKeywords.AddUnique(FString(TEXT("eztest")));
	IllegalKeywords.AddUnique(FString(TEXT("fusion")));
	IllegalKeywords.AddUnique(FString(TEXT("codeview")));
	IllegalKeywords.AddUnique(FString(TEXT("haxplorer")));
	IllegalKeywords.AddUnique(FString(TEXT("hookshark")));
	IllegalKeywords.AddUnique(FString(TEXT("memory editor")));
	IllegalKeywords.AddUnique(FString(TEXT("monodevelop")));
	IllegalKeywords.AddUnique(FString(TEXT("ollydbg")));
	IllegalKeywords.AddUnique(FString(TEXT("reflector")));
	IllegalKeywords.AddUnique(FString(TEXT("slickedit")));
	IllegalKeywords.AddUnique(FString(TEXT("totalview")));
	IllegalKeywords.AddUnique(FString(TEXT("trainer")));
	IllegalKeywords.AddUnique(FString(TEXT("windbg")));
	IllegalKeywords.AddUnique(FString(TEXT("xdebug")));
	IllegalKeywords.AddUnique(FString(TEXT("x64dbg")));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if PLATFORM_WINDOWS
#include "Windows/AllowWindowsPlatformTypes.h"
//
BOOL CALLBACK ScanProcesses(HWND Hwnd, LPARAM Param) {
	const auto &Settings = GetMutableDefault<USCUE4Settings>();
	//
	char TBuffer[512];
	int TXT = GetWindowTextA(Hwnd,TBuffer,sizeof(TBuffer));
	FString FST = FString(ANSI_TO_TCHAR(TBuffer)).ToLower();
	//
	TCHAR LPS[512];
	GetClassNameW(Hwnd,LPS,512);
	FString FSN = FString(LPS).ToLower();
	//
	for (auto SC : Settings->IllegalKeywords) {
		if (FSN.Contains(SC)) {*(HWND*)Param = Hwnd; return FALSE;}
		if (TXT && FST.Contains(SC) && !FST.Contains(TEXT("internet")) && !FST.Contains(TEXT("edge")) && !FST.Contains(TEXT("chrome"))
		&& !FST.Contains(TEXT("firefox")) && !FST.Contains(TEXT("opera")) && !FST.Contains(TEXT("safari")) && !FST.Contains(TEXT("torch")))
	{*(HWND*)Param = Hwnd; return FALSE;}}
	//
	return TRUE;
}///
//
void FSCUE4_Enumerate() {
	HWND Hwnd = NULL;
	if (!EnumWindows(ScanProcesses,reinterpret_cast<LPARAM>(&Hwnd))) {
	  #if UE_BUILD_SHIPPING
		char TBuffer[512];
		int TXT = GetWindowTextA(Hwnd,TBuffer,sizeof(TBuffer));
		int msgboxID = MessageBox( NULL,
			(LPCWSTR)L"Running application conflict detected; Game will close;\nPlease close conflicting software before playing.",
			(LPCWSTR)ANSI_TO_TCHAR(TBuffer),
			MB_ICONWARNING | MB_OK | MB_DEFBUTTON1
		); FGenericPlatformMisc::RequestExit(false);
	  #endif
	}///
}///
//
#include "Windows/HideWindowsPlatformTypes.h"
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void USafeGameInstanceSubsystem::Initialize(FSubsystemCollectionBase &Collection) {
	AllowDebugging = !UE_BUILD_SHIPPING;
	//
	#if PLATFORM_WINDOWS
	 const FTimerDelegate TimerScanProcesses = FTimerDelegate::CreateUObject(this,&USafeGameInstanceSubsystem::ScanProcesses);
	 const FTimerDelegate TimerInvokeGuard = FTimerDelegate::CreateUObject(this,&USafeGameInstanceSubsystem::GameGuard);
	 //
	 GetGameInstance()->GetTimerManager().SetTimer(THScanner,TimerScanProcesses,ScannerInterval,true);
	 GetGameInstance()->GetTimerManager().SetTimer(THInvokeGuard,TimerInvokeGuard,5,true);
	 //
	 InvokeGuard();
	#endif
}

void USafeGameInstanceSubsystem::Deinitialize() {
	#if PLATFORM_WINDOWS
	 FPlatformProcess::TerminateProc(GuardProcess);
	#endif
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void USafeGameInstanceSubsystem::HideGameGuardConsole(bool Set) {
	this->HideGameGuard = Set;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/SCUE4/Private/SCUE4PrivatePCH.h`:

```h
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//		Copyright 2016 (C) Bruno Xavier B. Leite      //
//////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "UObject/WeakObjectPtr.h"
#include "Runtime/Engine/Classes/Engine/Engine.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/SCUE4/Public/ISCUE4.h`:

```h
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//		Copyright 2016 (C) Bruno Xavier B. Leite
//////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "Modules/ModuleManager.h"

class ISCUE4 : public IModuleInterface {
public:
	static inline ISCUE4& Get() {
		return FModuleManager::LoadModuleChecked<ISCUE4>("SCUE4");
	}
	static inline bool IsAvailable() {
		return FModuleManager::Get().IsModuleLoaded("SCUE4");
	}
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/SCUE4/Public/SCUE4.h`:

```h
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//		Copyright 2016 (C) Bruno Xavier B. Leite
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if PLATFORM_WINDOWS
 #include "Windows/AllowWindowsPlatformTypes.h"
 #include <Windows.h>
 #include <Winuser.h>
 #include "Windows/HideWindowsPlatformTypes.h"
#endif

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "UObject/WeakObjectPtr.h"
#include "Subsystems/GameInstanceSubsystem.h"
#include "Runtime/Engine/Classes/Engine/Engine.h"

#include "Runtime/Core/Public/Misc/App.h"
#include "Runtime/Engine/Public/TimerManager.h"
#include "Runtime/Core/Public/Windows/WindowsPlatformProcess.h"
#include "Runtime/Core/Public/GenericPlatform/GenericPlatformProcess.h"
#include "Runtime/Core/Public/Misc/Paths.h"

#include "SCUE4.generated.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Default SCUE4 Settings

UCLASS(ClassGroup = Synaptech, Category = "Synaptech", config = Game)
class SCUE4_API USCUE4Settings : public UObject {
	GENERATED_UCLASS_BODY()
public:
	/** Path to the Editor's Key Generator standalone executable. */
	UPROPERTY(Category = "General Settings", config, EditAnywhere, BlueprintReadOnly)
	FString KeyGeneratorPath;
	//
	/** List of illegal process words that internal scanner shall look for. */
	UPROPERTY(Category = "General Settings", config, EditAnywhere, BlueprintReadOnly)
	TArray<FString> IllegalKeywords;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Encryption:: Caesar Cipher ^ Byte Mangling

static const FString ASCII_DIC = TEXT("0123456789aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ@~!#$%^&*()_-=+/|[]{}`;:,<>?.\\");
static const FString ASCII_KEY = TEXT(":.,@#}{[=^otTxmY+_!)*rACbfklpKVFWz]%Ju8ZgIi/HXGqj$>2MhPwDd1BS7-(3sEn06c5yRe?9U`L&|OvaNQ;4~<\\");

static FORCEINLINE FString FEncode(FString Input) {
	for (int I = 0; I<Input.Len(); I++) {
		int ID = -1; for (auto CH : ASCII_DIC) {
			ID++; if (Input[I]==CH) {Input[I]=ASCII_KEY[ID]; ID=-1; break;}
		}///
	}///
	//
	return *Input;
}

static FORCEINLINE FString FDecode(FString Input) {
	for (int I = 0; I<Input.Len(); I++) {
		int ID = -1; for (auto CH : ASCII_KEY) {
			ID++; if (Input[I]==CH) {Input[I]=ASCII_DIC[ID]; ID=-1; break;}
		}///
	}///
	//
	return *Input;
}

static FORCEINLINE FString FEncode(FString Key, FString Input) {
	for (int I = 0; I<Input.Len(); I++) {
		int ID = -1; for (auto CH : ASCII_DIC) {
			ID++; if (Input[I]==CH) {Input[I]=Key[ID]; ID=-1; break;}
		}///
	}///
	//
	return *Input;
}

static FORCEINLINE FString FDecode(FString Key, FString Input) {
	for (int I = 0; I<Input.Len(); I++) {
		int ID = -1; for (auto CH : Key) {
			ID++; if (Input[I]==CH) {Input[I]=ASCII_DIC[ID]; ID=-1; break;}
		}///
	}///
	//
	return *Input;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Enumerator:: Internal Process Scanner

#if PLATFORM_WINDOWS
	void FSCUE4_Enumerate();
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Structs:: Custom 'Safe Types' for run-time data encryption

/** Safe Boolean Property;
 Use this data format to store sensible Bool values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeBool {
	GENERATED_USTRUCT_BODY()
private:
	/** Internal Key. Can be replaced each operation if wanted. */
	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Internal;
	//
	/** Default Memory Address. */
	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Base;
	//
	/** Alternative Memory Address. */
	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Shift;
	//
	/** Flag will take the value from Address, clear it and shift them,
	then copy value to previous Address and set it as default container. */
	UPROPERTY(SaveGame)
	uint8 Flag;
public:
	////////////////////////////////////////////////////////////
	/// Accessors
	//
	FString GetRaw() {
		if (Shift.Len()>0) {return Shift;} else {return Base;}
	}///
	//
	void SetRaw(FString* Value) {
		Shift = *Value;
		Base = *Value;
	}///
	//
	/** Gets value using Global Key. */
	bool GetValue() {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1; Shift = Base; Base.Empty();
					return FCString::ToBool(*FDecode(Shift));
				} break;
				case 1:
				{
					Flag = 0; Base = Shift; Shift.Empty();
					return FCString::ToBool(*FDecode(Base));
				} break;
			default: return false;}
		}///
	}///
	//
	bool GetValue() const {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
					return FCString::ToBool(*FDecode(Base));
				break;
				case 1:
					return FCString::ToBool(*FDecode(Shift));
				break;
			default: return false;}
		}///
	}///
	//
	/** Gets value from Custom Key. */
	bool GetValue(const FString &Key) {
		switch (Flag) {
			case 0:
			{
				Flag = 1; Shift = Base; Base.Empty();
				return FCString::ToBool(*FDecode(Key,Shift));
			} break;
			case 1:
			{
				Flag = 0; Base = Shift; Shift.Empty();
				return FCString::ToBool(*FDecode(Key,Base));
			} break;
		default: return false;}
	}///
	//
	bool GetValue(const FString &Key) const {
		switch (Flag) {
			case 0:
				return FCString::ToBool(*FDecode(Key,Base));
			break;
			case 1:
				return FCString::ToBool(*FDecode(Key,Shift));
			break;
		default: return false;}
	}///
	//
	/** Sets value using Internal or Global Key. */
	void SetValue(const bool Input) {
		if (!Internal.IsEmpty()) {SetValue(Internal,Input);} else {
			switch (Flag) {
				case 0:
				{
					Shift = FEncode((Input?TEXT("true"):TEXT("false")));
					Flag = 1; Base.Empty();
				} break;
				case 1:
				{
					Base = FEncode((Input?TEXT("true"):TEXT("false")));
					Flag = 0; Shift.Empty();
				} break;
			}///
		}///
	}///
	//
	/** Sets value from Custom Key. */
	void SetValue(const FString &Key, const bool Input) {
		switch (Flag) {
			case 0:
			{
				Shift = FEncode(Key,(Input?TEXT("true"):TEXT("false")));
				Flag = 1; Base.Empty();
			} break;
			case 1:
			{
				Base = FEncode(Key,(Input?TEXT("true"):TEXT("false")));
				Flag = 0; Shift.Empty();
			} break;
		default: return;}
	}///
	//
	////////////////////////////////////////////////////////////
	/// Constructors
	//
	FSafeBool() {
		Internal = FString();
		Base = TEXT("false");
		Shift = TEXT("false");
		Flag = 0;
	}///
	//
	FSafeBool(const bool Input) {
		Internal = FString();
		Base = FEncode((Input?TEXT("true"):TEXT("false")));
		Shift = FEncode((Input?TEXT("true"):TEXT("false")));
		Flag = 0;
	}///
	//
	FSafeBool(const FString &Key, const bool Input) {
		Internal = FString(Key);
		Base = FEncode(Key,(Input?TEXT("true"):TEXT("false")));
		Shift = FEncode(Key,(Input?TEXT("true"):TEXT("false")));
		Flag = 0;
	}///
	//
	////////////////////////////////////////////////////////////
	/// Operators
	//
	FORCEINLINE FSafeBool &operator = (const FSafeBool &B) {
		Internal = B.Internal;
		Shift = B.Shift;
		Base = B.Base;
		Flag = B.Flag;
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeBool &operator = (const bool &B) {
		SetValue(B); return *this;
	}///
	//
	FORCEINLINE FArchive &operator << (FArchive &AR) {
		AR << Internal;
		AR << Shift;
		AR << Base;
		AR << Flag;
		//
		return AR;
	}///
	//
	friend FORCEINLINE uint32 GetTypeHash(const FSafeBool &B) {
		return FCrc::MemCrc32(&B,sizeof(FSafeBool));
	}///
};

/** Safe Byte Property;
 Use this data format to store sensible Byte values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeByte {
	GENERATED_USTRUCT_BODY()
private:
	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Internal;
	//
	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Base;
	//
	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Shift;
	//
	UPROPERTY(SaveGame)
	uint8 Flag;
public:
	////////////////////////////////////////////////////////////
	/// Accessors
	//
	FString GetRaw() {
		if (Shift.Len()>0) {return Shift;} else {return Base;}
	}///
	//
	void SetRaw(FString* Value) {
		Shift = *Value;
		Base = *Value;
	}///
	//
	uint8 GetValue() {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1; Shift = Base; Base.Empty();
					return FCString::Atoi(*FDecode(Shift));
				} break;
				case 1:
				{
					Flag = 0; Base = Shift; Shift.Empty();
					return FCString::Atoi(*FDecode(Base));
				} break;
			default: return 0;}
		}///
	}///
	//
	uint8 GetValue() const {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
					return FCString::Atoi(*FDecode(Base));
				break;
				case 1:
					return FCString::Atoi(*FDecode(Shift));
				break;
			default: return 0;}
		}///
	}///
	//
	uint8 GetValue(const FString &Key) {
		switch (Flag) {
			case 0:
			{
				Flag = 1; Shift = Base; Base.Empty();
				return FCString::Atoi(*FDecode(Key,Shift));
			} break;
			case 1:
			{
				Flag = 0; Base = Shift; Shift.Empty();
				return FCString::Atoi(*FDecode(Key,Base));
			} break;
		default: return 0;}
	}///
	//
	uint8 GetValue(const FString &Key) const {
		switch (Flag) {
			case 0:
				return FCString::Atoi(*FDecode(Key,Base));
			break;
			case 1:
				return FCString::Atoi(*FDecode(Key,Shift));
			break;
		default: return 0;}
	}///
	//
	void SetValue(uint8 Input) {
		if (!Internal.IsEmpty()) {SetValue(Internal,Input);} else {
			switch (Flag) {
				case 0:
				{
					Shift = FEncode(FString::FromInt(Input));
					Flag = 1; Base.Empty();
				} break;
				case 1:
				{
					Base = FEncode(FString::FromInt(Input));
					Flag = 0; Shift.Empty();
				} break;
			default: return;}
		}///
	}///
	//
	void SetValue(const FString &Key, uint8 Input) {
		switch (Flag) {
			case 0:
			{
				Shift = FEncode(Key,FString::FromInt(Input));
				Flag = 1; Base.Empty();
			} break;
			case 1:
			{
				Base = FEncode(Key,FString::FromInt(Input));
				Flag = 0; Shift.Empty();
			} break;
		default: return;}
	}///
	//
	////////////////////////////////////////////////////////////
	/// Constructors
	//
	FSafeByte() {
		Internal = FString();
		Base = TEXT("0");
		Shift = TEXT("0");
		Flag = 0;
	}///
	//
	FSafeByte(const uint8 Input) {
		Internal = FString();
		Base = FEncode(FString::FromInt(Input));
		Shift = FEncode(FString::FromInt(Input));
		Flag = 0;
	}///
	//
	FSafeByte(const FString &Key, const uint8 Input) {
		Internal = FString(Key);
		Base = FEncode(Key,FString::FromInt(Input));
		Shift = FEncode(Key,FString::FromInt(Input));
		Flag = 0;
	}///
	//
	////////////////////////////////////////////////////////////
	/// Operators
	//
	FORCEINLINE FSafeByte &operator = (const FSafeByte &B) {
		Internal = B.Internal;
		Shift = B.Shift;
		Base = B.Base;
		Flag = B.Flag;
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeByte &operator = (const uint8 &B) {
		SetValue(B); return *this;
	}///
	//
	FORCEINLINE FSafeByte &operator += (const uint8 &B) {
		uint8 I = (GetValue() + B);
		SetValue(I);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeByte &operator -= (const uint8 &B) {
		uint8 I = (GetValue() - B);
		SetValue(I);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeByte &operator += (const FSafeByte &B) {
		uint8 I = (GetValue() + B.GetValue());
		SetValue(I);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeByte &operator -= (const FSafeByte &B) {
		uint8 I = (GetValue() - B.GetValue());
		SetValue(I);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeByte operator ++ (int) {
		FSafeByte SB = *this; (++ *this);
		//
		return SB;
	}///
	//
	FORCEINLINE FSafeByte operator -- (int) {
		FSafeByte SB = *this; (-- *this);
		//
		return SB;
	}///
	//
	FORCEINLINE FSafeByte &operator ++ () {
		uint8 I = GetValue(); I++;
		SetValue(I);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeByte &operator -- () {
		uint8 I = GetValue(); I--;
		SetValue(I);
		//
		return *this;
	}///
	//
	FORCEINLINE FArchive &operator << (FArchive &AR) {
		AR << Internal;
		AR << Shift;
		AR << Base;
		AR << Flag;
		//
		return AR;
	}///
	//
	friend FORCEINLINE uint32 GetTypeHash(const FSafeByte &B) {
		return FCrc::MemCrc32(&B,sizeof(FSafeByte));
	}///
};

/** Safe Int32 Property;
 Use this data format to store sensible Int values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeInt {
	GENERATED_USTRUCT_BODY()
private:
	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Internal;
	//
	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Base;
	//
	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Shift;
	//
	UPROPERTY(SaveGame)
	uint8 Flag;
public:
	////////////////////////////////////////////////////////////
	/// Accessors
	//
	FString GetRaw() {
		if (Shift.Len()>0) {return Shift;} else {return Base;}
	}///
	//
	void SetRaw(FString* Value) {
		Shift = *Value;
		Base = *Value;
	}///
	//
	int32 GetValue() {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1; Shift = Base; Base.Empty();
					return FCString::Atoi(*FDecode(Shift));
				} break;
				case 1:
				{
					Flag = 0; Base = Shift; Shift.Empty();
					return FCString::Atoi(*FDecode(Base));
				} break;
			default: return 0;}
		}///
	}///
	//
	int32 GetValue() const {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
					return FCString::Atoi(*FDecode(Base));
				break;
				case 1:
					return FCString::Atoi(*FDecode(Shift));
				break;
			default: return 0;}
		}///
	}///
	//
	int32 GetValue(const FString &Key) {
		switch (Flag) {
			case 0:
			{
				Flag = 1; Shift = Base; Base.Empty();
				return FCString::Atoi(*FDecode(Key,Shift));
			} break;
			case 1:
			{
				Flag = 0; Base = Shift; Shift.Empty();
				return FCString::Atoi(*FDecode(Key,Base));
			} break;
		default: return 0;}
	}///
	//
	int32 GetValue(const FString &Key) const {
		switch (Flag) {
			case 0:
				return FCString::Atoi(*FDecode(Key,Base));
			break;
			case 1:
				return FCString::Atoi(*FDecode(Key,Shift));
			break;
		default: return 0;}
	}///
	//
	void SetValue(int32 Input) {
		if (!Internal.IsEmpty()) {SetValue(Internal,Input);} else {
			switch (Flag) {
				case 0:
					Shift = FEncode(FString::FromInt(Input));
					Flag = 1; Base.Empty();
				case 1:
					Base = FEncode(FString::FromInt(Input));
					Flag = 0; Shift.Empty();
			default: return;}
		}///
	}///
	//
	void SetValue(const FString &Key, int32 Input) {
		switch (Flag) {
			case 0:
			{
				Shift = FEncode(Key,FString::FromInt(Input));
				Flag = 1; Base.Empty();
			} break;
			case 1:
			{
				Base = FEncode(Key,FString::FromInt(Input));
				Flag = 0; Shift.Empty();
			} break;
		default: return;}
	}///
	//
	////////////////////////////////////////////////////////////
	/// Constructors
	//
	FSafeInt() {
		Internal = FString();
		Base = TEXT("0");
		Shift = TEXT("0");
		Flag = 0;
	}///
	//
	FSafeInt(const int32 Input) {
		Internal = FString();
		Base = FEncode(FString::FromInt(Input));
		Shift = FEncode(FString::FromInt(Input));
		Flag = 0;
	}///
	//
	FSafeInt(const FString &Key, const int32 Input) {
		Internal = FString(Key);
		Base = FEncode(Key,FString::FromInt(Input));
		Shift = FEncode(Key,FString::FromInt(Input));
		Flag = 0;
	}///
	//
	////////////////////////////////////////////////////////////
	/// Operators
	//
	FORCEINLINE FSafeInt &operator = (const FSafeInt &I) {
		Internal = I.Internal;
		Shift = I.Shift;
		Flag = I.Flag;
		Base = I.Base;
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeInt &operator = (const int32 &I) {
		SetValue(I); return *this;
	}///
	//
	FORCEINLINE FSafeInt &operator += (const FSafeInt &IT) {
		const int32 I = (GetValue() + IT.GetValue());
		SetValue(I);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeInt &operator -= (const FSafeInt &IT) {
		const int32 I = (GetValue() - IT.GetValue());
		SetValue(I);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeInt &operator += (const int32 &IT) {
		const int32 I = (GetValue() + IT);
		SetValue(I);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeInt &operator -= (const int32 &IT) {
		const int32 I = (GetValue() - IT);
		SetValue(I);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeInt operator ++ (int) {
		FSafeInt SI = *this; (++ *this);
		//
		return SI;
	}///
	//
	FORCEINLINE FSafeInt operator -- (int) {
		FSafeInt SI = *this; (-- *this);
		//
		return SI;
	}///
	//
	FORCEINLINE FSafeInt &operator ++ () {
		int32 I = GetValue(); I++;
		SetValue(I);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeInt &operator -- () {
		int32 I = GetValue(); I--;
		SetValue(I);
		//
		return *this;
	}///
	//
	FORCEINLINE FArchive &operator << (FArchive &AR) {
		AR << Internal;
		AR << Shift;
		AR << Base;
		AR << Flag;
		//
		return AR;
	}///
	//
	friend FORCEINLINE uint32 GetTypeHash(const FSafeInt &I) {
		return FCrc::MemCrc32(&I,sizeof(FSafeInt));
	}///
};

/** Safe Float Property;
 Use this data format to store sensible Float values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeFloat {
	GENERATED_USTRUCT_BODY()
private:
	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Internal;
	//
	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Base;
	//
	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Shift;
	//
	UPROPERTY(SaveGame)
	uint8 Flag;
public:
	////////////////////////////////////////////////////////////
	/// Accessors
	//
	FString GetRaw() {
		if (Shift.Len()>0) {return Shift;} else {return Base;}
	}///
	//
	void SetRaw(FString* Value) {
		Shift = *Value;
		Base = *Value;
	}///
	//
	float GetValue() {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1; Shift = Base; Base.Empty();
					return FCString::Atof(*FDecode(Shift));
				} break;
				case 1:
				{
					Flag = 0; Base = Shift; Shift.Empty();
					return FCString::Atof(*FDecode(Base));
				} break;
			default: return 0.f;}
		}///
	}///
	//
	float GetValue() const {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
					return FCString::Atof(*FDecode(Base));
				break;
				case 1:
					return FCString::Atof(*FDecode(Shift));
				break;
			default: return 0.f;}
		}///
	}///
	//
	float GetValue(const FString &Key) {
		switch (Flag) {
			case 0:
			{
				Flag = 1; Shift = Base; Base.Empty();
				return FCString::Atof(*FDecode(Key,Shift));
			} break;
			case 1:
			{
				Flag = 0; Base = Shift; Shift.Empty();
				return FCString::Atof(*FDecode(Key,Base));
			} break;
		default: return 0.f;}
	}///
	//
	float GetValue(const FString &Key) const {
		switch (Flag) {
			case 0:
				return FCString::Atof(*FDecode(Key,Base));
			break;
			case 1:
				return FCString::Atof(*FDecode(Key,Shift));
			break;
		default: return 0.f;}
	}///
	//
	void SetValue(float Input) {
		if (!Internal.IsEmpty()) {SetValue(Internal,Input);} else {
			switch (Flag) {
				case 0:
				{
					Shift = FEncode(FString::Printf(TEXT("%f"),Input));
					Flag = 1; Base.Empty();
				} break;
				case 1:
				{
					Base = FEncode(FString::Printf(TEXT("%f"),Input));
					Flag = 0; Shift.Empty();
				} break;
			default: return;}
		}///
	}///
	//
	void SetValue(const FString &Key, float Input) {
		switch (Flag) {
			case 0:
			{
				Shift = FEncode(Key,FString::Printf(TEXT("%f"),Input));
				Flag = 1; Base.Empty();
			} break;
			case 1:
			{
				Base = FEncode(Key,FString::Printf(TEXT("%f"),Input));
				Flag = 0; Shift.Empty();
			} break;
		default: return;}
	}///
	//
	////////////////////////////////////////////////////////////
	/// Constructors
	//
	FSafeFloat() {
		Internal = FString();
		Base = TEXT("0.0");
		Shift = TEXT("0.0");
		Flag = 0;
	}///
	//
	FSafeFloat(const float Input) {
		Internal = FString();
		Base = FEncode(FString::Printf(TEXT("%f"),Input));
		Shift = FEncode(FString::Printf(TEXT("%f"),Input));
		Flag = 0;
	}///
	///
	FSafeFloat(const FString &Key, const float Input) {
		Internal = FString(Key);
		Base = FEncode(Key,FString::Printf(TEXT("%f"),Input));
		Shift = FEncode(Key,FString::Printf(TEXT("%f"),Input));
		Flag = 0;
	}///
	//
	////////////////////////////////////////////////////////////
	/// Operators
	//
	FORCEINLINE FSafeFloat &operator = (const FSafeFloat &F) {
		Internal = F.Internal;
		Base = F.Base;
		Shift = F.Shift;
		Flag = F.Flag;
		return *this;
	}///
	//
	FORCEINLINE FSafeFloat &operator = (const float &F) {
		SetValue(F); return *this;
	}///
	//
	FORCEINLINE FSafeFloat &operator += (const FSafeFloat &F) {
		const float SF = (GetValue() + F.GetValue());
		SetValue(SF);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeFloat &operator -= (const FSafeFloat &F) {
		const float SF = (GetValue() - F.GetValue());
		SetValue(SF);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeFloat &operator += (const float &F) {
		const float SF = (GetValue() + F);
		SetValue(SF);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeFloat &operator -= (const float &F) {
		const float SF = (GetValue() - F);
		SetValue(SF);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeFloat operator ++ (int) {
		FSafeFloat SF = *this; (++ *this);
		//
		return SF;
	}///
	//
	FORCEINLINE FSafeFloat operator -- (int) {
		FSafeFloat SF = *this; (-- *this);
		//
		return SF;
	}///
	//
	FORCEINLINE FSafeFloat &operator ++ () {
		float F = GetValue(); F++;
		SetValue(F);
		//
		return *this;
	}///
	//
	FORCEINLINE FSafeFloat &operator -- () {
		float F = GetValue(); F--;
		SetValue(F);
		//
		return *this;
	}///
	//
	FORCEINLINE FArchive &operator << (FArchive &AR) {
		AR << Internal;
		AR << Shift;
		AR << Base;
		AR << Flag;
		//
		return AR;
	}///
	//
	friend FORCEINLINE uint32 GetTypeHash(const FSafeFloat &I) {
		return FCrc::MemCrc32(&I,sizeof(FSafeFloat));
	}///
};

/** Safe Name Property;
 Use this data format to store sensible Name values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeName {
	GENERATED_USTRUCT_BODY()
private:

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Internal;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Base;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Shift;

	UPROPERTY(SaveGame)
	uint8 Flag;

public:

	////////////////////////////////////////////////////////////
	/// Accessors

	FString GetRaw() {
		if (Shift.Len()>0) {return Shift;} else {return Base;}
	}

	void SetRaw(FString* Value) {
		Shift = *Value;
		Base = *Value;
	}

	FName GetValue() {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
			case 0:
			{
				Flag = 1; Shift = Base; Base.Empty();
				return FName(*FDecode(Shift));
			} break;
			case 1:
			{
				Flag = 0; Base = Shift; Shift.Empty();
				return FName(*FDecode(Base));
			} break;
			default: return TEXT("");}
		}
	}

	FName GetValue(const FString &Key) {
		switch (Flag) {
			case 0:
			{
				Flag = 1; Shift = Base; Base.Empty();
				return FName(*FDecode(Key,Shift));
			} break;
			case 1:
			{
				Flag = 0; Base = Shift; Shift.Empty();
				return FName(*FDecode(Key,Base));
			} break;
		default: return TEXT("");}
	}

	void SetValue(FName Input) {
		if (!Internal.IsEmpty()) {SetValue(Internal,Input);} else {
			switch (Flag) {
				case 0:
				{
					Shift = *FEncode(Input.ToString());
					Flag = 1; Base.Empty();
				} break;
				case 1:
				{
					Base = *FEncode(Input.ToString());
					Flag = 0; Shift.Empty();
				} break;
			default: return;}
		}
	}

	void SetValue(const FString &Key, FName Input) {
		switch (Flag) {
			case 0:
			{
				Shift = *FEncode(Key,Input.ToString());
				Flag = 1; Base.Empty();
			} break;
			case 1:
			{
				Base = *FEncode(Key,Input.ToString());
				Flag = 0; Shift.Empty();
			} break;
		default: return;}
	}

	////////////////////////////////////////////////////////////
	/// Constructors

	FSafeName() {
		Internal = FString();
		Base = TEXT("");
		Shift = TEXT("");
		Flag = 0;
	}

	FSafeName(const FName Input) {
		Internal = FString();
		Base = *FEncode(Input.ToString());
		Shift = *FEncode(Input.ToString());
		Flag = 0;
	}

	FSafeName(const FString &Key, const FName Input) {
		Internal = FString(Key);
		Base = *FEncode(Key,Input.ToString());
		Shift = *FEncode(Key,Input.ToString());
		Flag = 0;
	}

	////////////////////////////////////////////////////////////
	/// Operators

	FORCEINLINE FSafeName &operator = (const FSafeName &N) {
		Internal = N.Internal;
		Base = N.Base;
		Shift = N.Shift;
		Flag = N.Flag;
		return *this;
	}
	
	FORCEINLINE FSafeName &operator = (const FName &N) {
		SetValue(N); return *this;
	}

	FORCEINLINE FArchive &operator << (FArchive &Ar) { 
		Ar << Flag;
		Ar << Base;
		Ar << Shift;
		Ar << Internal;
		return Ar;
	}

	friend FORCEINLINE uint32 GetTypeHash(const FSafeName &N) {
		return FCrc::MemCrc32(&N,sizeof(FSafeName));
	}

};

/** Safe String Property;
 Use this data format to store sensible String values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeString {
	GENERATED_USTRUCT_BODY()
private:

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Internal;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Base;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Shift;

	UPROPERTY(SaveGame)
	uint8 Flag;

public:

	////////////////////////////////////////////////////////////
	/// Accessors

	FString GetRaw() {
		if (Shift.Len()>0) {return Shift;} else {return Base;}
	}

	void SetRaw(FString* Value) {
		Shift = *Value;
		Base = *Value;
	}

	FString GetValue() {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1; Shift = Base; Base.Empty();
					return FString(*FDecode(Shift));
				} break;
				case 1:
				{
					Flag = 0; Base = Shift; Shift.Empty();
					return FString(*FDecode(Base));
				} break;
			default: return TEXT("");}
		}
	}

	FString GetValue(const FString &Key) {
		switch (Flag) {
			case 0:
			{
				Flag = 1; Shift = Base; Base.Empty();
				return FString(*FDecode(Key,Shift));
			} break;
			case 1:
			{
				Flag = 0; Base = Shift; Shift.Empty();
				return FString(*FDecode(Key,Base));
			} break;
		default: return TEXT("");}
	}

	void SetValue(FString Input) {
		if (!Internal.IsEmpty()) {SetValue(Internal,Input);} else {
			switch (Flag) {
				case 0:
				{
					Shift = *FEncode(Input);
					Flag = 1; Base.Empty();
				} break;
				case 1:
				{
					Base = *FEncode(Input);
					Flag = 0; Shift.Empty();
				} break;
			default: return;}
		}
	}

	void SetValue(const FString &Key, FString Input) {
		switch (Flag) {
			case 0:
			{
				Shift = *FEncode(Key,Input);
				Flag = 1; Base.Empty();
			} break;
			case 1:
			{
				Base = *FEncode(Key,Input);
				Flag = 0; Shift.Empty();
			} break;
		}
	}

	////////////////////////////////////////////////////////////
	/// Constructors

	FSafeString() {
		Internal = FString();
		Base = TEXT("");
		Shift = TEXT("");
		Flag = 0;
	}

	FSafeString(const FString Input) {
		Internal = FString();
		Base = *FEncode(Input);
		Shift = *FEncode(Input);
		Flag = 0;
	}

	FSafeString(const FString &Key, const FString Input) {
		Internal = FString(Key);
		Base = *FEncode(Key,Input);
		Shift = *FEncode(Key,Input);
		Flag = 0;
	}

	////////////////////////////////////////////////////////////
	/// Operators

	FORCEINLINE FSafeString &operator = (const FSafeString &S) {
		Internal = S.Internal;
		Base = S.Base;
		Shift = S.Shift;
		Flag = S.Flag;
		return *this;
	}
	
	FORCEINLINE FSafeString &operator = (const FString &S) {
		SetValue(S); return *this;
	}

	FORCEINLINE FArchive &operator << (FArchive &Ar) { 
		Ar << Flag;
		Ar << Base;
		Ar << Shift;
		Ar << Internal;
		return Ar;
	}

	friend FORCEINLINE uint32 GetTypeHash(const FSafeString &S) {
		return FCrc::MemCrc32(&S,sizeof(FSafeString));
	}

};

/** Safe Text Property;
 Use this data format to store sensible Text values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeText {
	GENERATED_USTRUCT_BODY()
private:

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Internal;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Base;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Shift;

	UPROPERTY(SaveGame)
	uint8 Flag;

public:

	////////////////////////////////////////////////////////////
	/// Accessors

	FString GetRaw() {
		if (Shift.Len()>0) {return Shift;} else {return Base;}
	}

	void SetRaw(FString* Value) {
		Shift = *Value;
		Base = *Value;
	}

	FText GetValue() {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1; Shift = Base; Base.Empty();
					return FText::FromString(FDecode(Shift));
				} break;
				case 1:
				{
					Flag = 0; Base = Shift; Shift.Empty();
					return FText::FromString(FDecode(Base));
				} break;
			default: return FText::GetEmpty();}
		}
	}

	FText GetValue(const FString &Key) {
		switch (Flag) {
			case 0:
			{
				Flag = 1; Shift = Base; Base.Empty();
				return FText::FromString(FDecode(Key,Shift));
			} break;
			case 1:
			{
				Flag = 0; Base = Shift; Shift.Empty();
				return FText::FromString(FDecode(Key,Base));
			} break;
		default: return FText::GetEmpty();}
	}

	void SetValue(FText Input) {
		if (!Internal.IsEmpty()) {SetValue(Internal,Input);} else {
			switch (Flag) {
				case 0:
				{
					Shift = *FEncode(Input.ToString());
					Flag = 1; Base.Empty();
				} break;
				case 1:
				{
					Base = *FEncode(Input.ToString());
					Flag = 0; Shift.Empty();
				} break;
			default: return;}
		}
	}

	void SetValue(const FString &Key, FText Input) {
		switch (Flag) {
			case 0:
			{
				Shift = *FEncode(Key,Input.ToString());
				Flag = 1; Base.Empty();
			} break;
			case 1:
			{
				Base = *FEncode(Key,Input.ToString());
				Flag = 0; Shift.Empty();
			} break;
		default: return;}
	}

	////////////////////////////////////////////////////////////
	/// Constructors

	FSafeText() {
		Internal = FString();
		Base = TEXT("");
		Shift = TEXT("");
		Flag = 0;
	}

	FSafeText(const FText Input) {
		Internal = FString();
		Base = *FEncode(Input.ToString());
		Shift = *FEncode(Input.ToString());
		Flag = 0;
	}

	FSafeText(const FString &Key, const FText Input) {
		Internal = FString(Key);
		Base = *FEncode(Key,Input.ToString());
		Shift = *FEncode(Key,Input.ToString());
		Flag = 0;
	}

	////////////////////////////////////////////////////////////
	/// Operators

	FORCEINLINE FSafeText &operator = (const FSafeText &T) {
		Internal = T.Internal;
		Base = T.Base;
		Shift = T.Shift;
		Flag = T.Flag;
		return *this;
	}
	
	FORCEINLINE FSafeText &operator = (const FText &T) {
		SetValue(T); return *this;
	}

	FORCEINLINE FArchive &operator << (FArchive &Ar) { 
		Ar << Flag;
		Ar << Base;
		Ar << Shift;
		Ar << Internal;
		return Ar;
	}

};

/** Safe Vector2D Property;
 Use this data format to store sensible Vector2D values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeVector2D {
	GENERATED_USTRUCT_BODY()
private:

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Internal;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueX;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueY;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftX;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftY;

	UPROPERTY(SaveGame)
	uint8 Flag;

public:

	////////////////////////////////////////////////////////////
	/// Accessors

	FVector2D GetValue() {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1;
					ShiftX = TrueX; ShiftY = TrueY;
					TrueX.Empty(); TrueY.Empty();
					return FVector2D(FCString::Atof(*FDecode(ShiftX)),FCString::Atof(*FDecode(ShiftY)));
				} break;
				case 1:
				{
					Flag = 0;
					TrueX = ShiftX; TrueY = ShiftY;
					ShiftX.Empty(); ShiftY.Empty();
					return FVector2D(FCString::Atof(*FDecode(TrueX)),FCString::Atof(*FDecode(TrueY)));
				} break;
			default: return FVector2D::ZeroVector;}
		}
	}

	FVector2D GetValue(const FString &Key) {
		switch (Flag) {
			case 0:
			{
				Flag = 1;
				ShiftX = TrueX; ShiftY = TrueY;
				TrueX.Empty(); TrueY.Empty();
				return FVector2D(FCString::Atof(*FDecode(Key,ShiftX)),FCString::Atof(*FDecode(Key,ShiftY)));
			} break;
			case 1:
			{
				Flag = 0;
				TrueX = ShiftX; TrueY = ShiftY;
				ShiftX.Empty(); ShiftY.Empty();
				return FVector2D(FCString::Atof(*FDecode(Key,TrueX)),FCString::Atof(*FDecode(Key,TrueY)));
			} break;
		default: return FVector2D::ZeroVector;}
	}

	void SetValue(FVector2D Input) {
		if (!Internal.IsEmpty()) {SetValue(Internal,Input);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1;
					ShiftX = *FEncode(FString::Printf(TEXT("%f"),Input.X));
					ShiftY = *FEncode(FString::Printf(TEXT("%f"),Input.Y));
					TrueX.Empty(); TrueY.Empty();
				} break;
				case 1:
				{
					Flag = 0;
					TrueX = *FEncode(FString::Printf(TEXT("%f"),Input.X));
					TrueY = *FEncode(FString::Printf(TEXT("%f"),Input.Y));
					ShiftX.Empty(); ShiftY.Empty();
				} break;
			default: return;}
		}
	}

	void SetValue(const FString &Key, FVector2D Input) {
		switch (Flag) {
			case 0:
			{
				Flag = 1;
				ShiftX = *FEncode(Key,FString::Printf(TEXT("%f"),Input.X));
				ShiftY = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Y));
				TrueX.Empty(); TrueY.Empty();
			} break;
			case 1:
			{
				Flag = 0;
				TrueX = *FEncode(Key,FString::Printf(TEXT("%f"),Input.X));
				TrueY = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Y));
				ShiftX.Empty(); ShiftY.Empty();
			} break;
		default: return;}
	}

	////////////////////////////////////////////////////////////
	/// Constructors

	FSafeVector2D() {
		Internal = FString();
		TrueX = TEXT(""); TrueY = TEXT("");
		ShiftX = TEXT(""); ShiftY = TEXT("");
		Flag = 0;
	}

	FSafeVector2D(const float X, const float Y) {
		Internal = FString();
		TrueX = *FEncode(FString::Printf(TEXT("%f"),X));
		TrueY = *FEncode(FString::Printf(TEXT("%f"),Y));
		ShiftX = *FEncode(FString::Printf(TEXT("%f"),X));
		ShiftY = *FEncode(FString::Printf(TEXT("%f"),Y));
		Flag = 0;
	}

	FSafeVector2D(const FVector2D Input) {
		Internal = FString();
		TrueX = *FEncode(FString::Printf(TEXT("%f"),Input.X));
		TrueY = *FEncode(FString::Printf(TEXT("%f"),Input.Y));
		ShiftX = *FEncode(FString::Printf(TEXT("%f"),Input.X));
		ShiftY = *FEncode(FString::Printf(TEXT("%f"),Input.Y));
		Flag = 0;
	}

	FSafeVector2D(const FString &Key, const FVector2D Input) {
		Internal = FString(Key);
		TrueX = *FEncode(Key,FString::Printf(TEXT("%f"),Input.X));
		TrueY = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Y));
		ShiftX = *FEncode(Key,FString::Printf(TEXT("%f"),Input.X));
		ShiftY = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Y));
		Flag = 0;
	}

	////////////////////////////////////////////////////////////
	/// Operators

	FORCEINLINE FSafeVector2D &operator = (const FSafeVector2D &V) {
		Internal = V.Internal;
		TrueX = V.TrueX; TrueY = V.TrueY;
		ShiftX = V.ShiftX; ShiftY = V.ShiftY;
		Flag = V.Flag;
		return *this;
	}
	
	FORCEINLINE FSafeVector2D &operator = (const FVector2D &V) {
		SetValue(V); return *this;
	}

	FORCEINLINE FArchive &operator << (FArchive &Ar) { 
		Ar << Flag;
		Ar << TrueX;
		Ar << TrueY;
		Ar << ShiftX;
		Ar << ShiftY;
		Ar << Internal;
		return Ar;
	}

	friend FORCEINLINE uint32 GetTypeHash(const FSafeVector2D &V) {
		return FCrc::MemCrc32(&V,sizeof(FSafeVector2D));
	}

};

/** Safe Vector3D Property;
 Use this data format to store sensible Vector3D values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeVector3D {
	GENERATED_USTRUCT_BODY()
private:

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Internal;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueX;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueY;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueZ;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftX;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftY;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftZ;

	UPROPERTY(SaveGame)
	uint8 Flag;

public:

	////////////////////////////////////////////////////////////

	FVector GetValue() {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1;
					ShiftX = TrueX; ShiftY = TrueY; ShiftZ = TrueZ;
					TrueX.Empty(); TrueY.Empty(); TrueZ.Empty();
					return FVector(FCString::Atof(*FDecode(ShiftX)),FCString::Atof(*FDecode(ShiftY)),FCString::Atof(*FDecode(ShiftZ)));
				} break;
				case 1:
				{
					Flag = 0;
					TrueX = ShiftX; TrueY = ShiftY; TrueZ = ShiftZ;
					ShiftX.Empty(); ShiftY.Empty(); ShiftZ.Empty();
					return FVector(FCString::Atof(*FDecode(TrueX)),FCString::Atof(*FDecode(TrueY)),FCString::Atof(*FDecode(TrueZ)));
				} break;
			default: return FVector::ZeroVector;}
		}
	}

	FVector GetValue(const FString &Key) {
		switch (Flag) {
			case 0:
			{
				Flag = 1;
				ShiftX = TrueX; ShiftY = TrueY; ShiftZ = TrueZ;
				TrueX.Empty(); TrueY.Empty(); TrueZ.Empty();
				return FVector(FCString::Atof(*FDecode(Key,ShiftX)),FCString::Atof(*FDecode(Key,ShiftY)),FCString::Atof(*FDecode(Key,ShiftZ)));
			} break;
			case 1:
			{
				Flag = 0;
				TrueX = ShiftX; TrueY = ShiftY; TrueZ = ShiftZ;
				ShiftX.Empty(); ShiftY.Empty(); ShiftZ.Empty();
				return FVector(FCString::Atof(*FDecode(Key,TrueX)),FCString::Atof(*FDecode(Key,TrueY)),FCString::Atof(*FDecode(Key,TrueZ)));
			} break;
		default: return FVector::ZeroVector;}
	}

	void SetValue(FVector Input) {
		if (!Internal.IsEmpty()) {SetValue(Internal,Input);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1;
					ShiftX = *FEncode(FString::Printf(TEXT("%f"),Input.X));
					ShiftY = *FEncode(FString::Printf(TEXT("%f"),Input.Y));
					ShiftZ = *FEncode(FString::Printf(TEXT("%f"),Input.Z));
					TrueX.Empty(); TrueY.Empty(); TrueZ.Empty();
				} break;
				case 1:
				{
					Flag = 0;
					TrueX = *FEncode(FString::Printf(TEXT("%f"),Input.X));
					TrueY = *FEncode(FString::Printf(TEXT("%f"),Input.Y));
					TrueZ = *FEncode(FString::Printf(TEXT("%f"),Input.Z));
					ShiftX.Empty(); ShiftY.Empty(); ShiftZ.Empty();
				} break;
			default: return;}
		}
	}

	void SetValue(const FString &Key, FVector Input) {
		switch (Flag) {
			case 0:
			{
				Flag = 1;
				ShiftX = *FEncode(Key,FString::Printf(TEXT("%f"),Input.X));
				ShiftY = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Y));
				ShiftZ = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Z));
				TrueX.Empty(); TrueY.Empty(); TrueZ.Empty();
			} break;
			case 1:
			{
				Flag = 0;
				TrueX = *FEncode(Key,FString::Printf(TEXT("%f"),Input.X));
				TrueY = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Y));
				TrueZ = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Z));
				ShiftX.Empty(); ShiftY.Empty(); ShiftZ.Empty();
			} break;
		default: return;}
	}

	////////////////////////////////////////////////////////////
	/// Constructors

	FSafeVector3D() {
		Internal = FString();
		TrueX = TEXT(""); TrueY = TEXT(""); TrueZ = TEXT("");
		ShiftX = TEXT(""); ShiftY = TEXT(""); ShiftZ = TEXT("");
		Flag = 0;
	}

	FSafeVector3D(const float X, const float Y, const float Z) {
		Internal = FString();
		TrueX = *FEncode(FString::Printf(TEXT("%f"),X));
		TrueY = *FEncode(FString::Printf(TEXT("%f"),Y));
		TrueZ = *FEncode(FString::Printf(TEXT("%f"),Z));
		ShiftX = *FEncode(FString::Printf(TEXT("%f"),X));
		ShiftY = *FEncode(FString::Printf(TEXT("%f"),Y));
		ShiftZ = *FEncode(FString::Printf(TEXT("%f"),Z));
		Flag = 0;
	}

	FSafeVector3D(const FVector Input) {
		Internal = FString();
		TrueX = *FEncode(FString::Printf(TEXT("%f"),Input.X));
		TrueY = *FEncode(FString::Printf(TEXT("%f"),Input.Y));
		TrueZ = *FEncode(FString::Printf(TEXT("%f"),Input.Z));
		ShiftX = *FEncode(FString::Printf(TEXT("%f"),Input.X));
		ShiftY = *FEncode(FString::Printf(TEXT("%f"),Input.Y));
		ShiftZ = *FEncode(FString::Printf(TEXT("%f"),Input.Z));
		Flag = 0;
	}

	FSafeVector3D(const FString &Key, const FVector Input) {
		Internal = FString(Key);
		TrueX = *FEncode(Key,FString::Printf(TEXT("%f"),Input.X));
		TrueY = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Y));
		TrueZ = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Z));
		ShiftX = *FEncode(Key,FString::Printf(TEXT("%f"),Input.X));
		ShiftY = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Y));
		ShiftZ = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Z));
		Flag = 0;
	}

	////////////////////////////////////////////////////////////
	/// Operators

	FORCEINLINE FSafeVector3D &operator = (const FSafeVector3D &V) {
		Internal = V.Internal;
		TrueX = V.TrueX; TrueY = V.TrueY; TrueZ = V.TrueZ;
		ShiftX = V.ShiftX; ShiftY = V.ShiftY; ShiftZ = V.ShiftZ;
		Flag = V.Flag;
		return *this;
	}
	
	FORCEINLINE FSafeVector3D &operator = (const FVector &V) {
		SetValue(V); return *this;
	}

	FORCEINLINE FArchive &operator << (FArchive &Ar) { 
		Ar << Flag;
		Ar << TrueX;
		Ar << TrueY;
		Ar << TrueZ;
		Ar << ShiftX;
		Ar << ShiftY;
		Ar << ShiftZ;
		Ar << Internal;
		return Ar;
	}

	friend FORCEINLINE uint32 GetTypeHash(const FSafeVector3D &V) {
		return FCrc::MemCrc32(&V,sizeof(FSafeVector3D));
	}

};

/** Safe Vector4D Property;
 Use this data format to store sensible Vector4D values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeVector4D {
	GENERATED_USTRUCT_BODY()
private:

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Internal;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueX;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueY;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueZ;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueW;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftX;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftY;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftZ;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftW;

	UPROPERTY(SaveGame)
	uint8 Flag;

public:

	////////////////////////////////////////////////////////////
	/// Accessors

	FVector4 GetValue() {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1;
					ShiftX = TrueX; ShiftY = TrueY; ShiftZ = TrueZ; ShiftW = TrueW;
					TrueX.Empty(); TrueY.Empty(); TrueZ.Empty(); TrueW.Empty();
					return FVector4(FCString::Atof(*FDecode(ShiftX)),FCString::Atof(*FDecode(ShiftY)),FCString::Atof(*FDecode(ShiftZ)),FCString::Atof(*FDecode(ShiftW)));
				} break;
				case 1:
				{
					Flag = 0;
					TrueX = ShiftX; TrueY = ShiftY; TrueZ = ShiftZ; TrueW = ShiftW;
					ShiftX.Empty(); ShiftY.Empty(); ShiftZ.Empty(); ShiftW.Empty();
					return FVector4(FCString::Atof(*FDecode(TrueX)),FCString::Atof(*FDecode(TrueY)),FCString::Atof(*FDecode(TrueZ)),FCString::Atof(*FDecode(TrueW)));
				} break;
			default: return FVector4(FVector2D::ZeroVector,FVector2D::ZeroVector);}
		}
	}

	FVector4 GetValue(const FString &Key) {
		switch (Flag) {
			case 0:
			{
				Flag = 1;
				ShiftX = TrueX; ShiftY = TrueY; ShiftZ = TrueZ; ShiftW = TrueW;
				TrueX.Empty(); TrueY.Empty(); TrueZ.Empty(); TrueW.Empty();
				return FVector4(FCString::Atof(*FDecode(Key,ShiftX)),FCString::Atof(*FDecode(Key,ShiftY)),FCString::Atof(*FDecode(Key,ShiftZ)),FCString::Atof(*FDecode(Key,ShiftW)));
			} break;
			case 1:
			{
				Flag = 0;
				TrueX = ShiftX; TrueY = ShiftY; TrueZ = ShiftZ; TrueW = ShiftW;
				ShiftX.Empty(); ShiftY.Empty(); ShiftZ.Empty(); ShiftW.Empty();
				return FVector4(FCString::Atof(*FDecode(Key,TrueX)),FCString::Atof(*FDecode(Key,TrueY)),FCString::Atof(*FDecode(Key,TrueZ)),FCString::Atof(*FDecode(Key,TrueW)));
			} break;
		default: return FVector4(FVector2D::ZeroVector,FVector2D::ZeroVector);}
	}

	void SetValue(FVector4* Input) {
		if (!Internal.IsEmpty()) {SetValue(Internal,Input);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1;
					ShiftX = *FEncode(FString::Printf(TEXT("%f"),Input->X));
					ShiftY = *FEncode(FString::Printf(TEXT("%f"),Input->Y));
					ShiftZ = *FEncode(FString::Printf(TEXT("%f"),Input->Z));
					ShiftW = *FEncode(FString::Printf(TEXT("%f"),Input->W));
					TrueX.Empty(); TrueY.Empty(); TrueZ.Empty(); TrueW.Empty();
				} break;
				case 1:
				{
					Flag = 0;
					TrueX = *FEncode(FString::Printf(TEXT("%f"),Input->X));
					TrueY = *FEncode(FString::Printf(TEXT("%f"),Input->Y));
					TrueZ = *FEncode(FString::Printf(TEXT("%f"),Input->Z));
					TrueW = *FEncode(FString::Printf(TEXT("%f"),Input->W));
					ShiftX.Empty(); ShiftY.Empty(); ShiftZ.Empty(); ShiftW.Empty();
				} break;
			default: return;}
		}
	}

	void SetValue(const FString &Key, FVector4* Input) {
		switch (Flag) {
			case 0:
			{
				Flag = 1;
				ShiftX = *FEncode(Key,FString::Printf(TEXT("%f"),Input->X));
				ShiftY = *FEncode(Key,FString::Printf(TEXT("%f"),Input->Y));
				ShiftZ = *FEncode(Key,FString::Printf(TEXT("%f"),Input->Z));
				ShiftW = *FEncode(Key,FString::Printf(TEXT("%f"),Input->W));
				TrueX.Empty(); TrueY.Empty(); TrueZ.Empty(); TrueW.Empty();
			} break;
			case 1:
			{
				Flag = 0;
				TrueX = *FEncode(Key,FString::Printf(TEXT("%f"),Input->X));
				TrueY = *FEncode(Key,FString::Printf(TEXT("%f"),Input->Y));
				TrueZ = *FEncode(Key,FString::Printf(TEXT("%f"),Input->Z));
				TrueW = *FEncode(Key,FString::Printf(TEXT("%f"),Input->W));
				ShiftX.Empty(); ShiftY.Empty(); ShiftZ.Empty(); ShiftW.Empty();
			} break;
		default: return;}
	}

	////////////////////////////////////////////////////////////
	/// Constructors

	FSafeVector4D() {
		Internal = FString();
		TrueX = TEXT(""); TrueY = TEXT(""); TrueZ = TEXT(""); TrueW = TEXT("");
		ShiftX = TEXT(""); ShiftY = TEXT(""); ShiftZ = TEXT(""); ShiftW = TEXT("");
		Flag = 0;
	}

	FSafeVector4D(const float X, const float Y, const float Z, const float W) {
		Internal = FString();
		TrueX = *FEncode(FString::Printf(TEXT("%f"),X));
		TrueY = *FEncode(FString::Printf(TEXT("%f"),Y));
		TrueZ = *FEncode(FString::Printf(TEXT("%f"),Z));
		TrueW = *FEncode(FString::Printf(TEXT("%f"),W));
		ShiftX = *FEncode(FString::Printf(TEXT("%f"),X));
		ShiftY = *FEncode(FString::Printf(TEXT("%f"),Y));
		ShiftZ = *FEncode(FString::Printf(TEXT("%f"),Z));
		ShiftW = *FEncode(FString::Printf(TEXT("%f"),W));
		Flag = 0;
	}

	FSafeVector4D(FVector4* Input) {
		Internal = FString();
		TrueX = *FEncode(FString::Printf(TEXT("%f"),Input->X));
		TrueY = *FEncode(FString::Printf(TEXT("%f"),Input->Y));
		TrueZ = *FEncode(FString::Printf(TEXT("%f"),Input->Z));
		TrueW = *FEncode(FString::Printf(TEXT("%f"),Input->W));
		ShiftX = *FEncode(FString::Printf(TEXT("%f"),Input->X));
		ShiftY = *FEncode(FString::Printf(TEXT("%f"),Input->Y));
		ShiftZ = *FEncode(FString::Printf(TEXT("%f"),Input->Z));
		ShiftW = *FEncode(FString::Printf(TEXT("%f"),Input->W));
		Flag = 0;
	}

	FSafeVector4D(const FString &Key, FVector4* Input) {
		Internal = FString(Key);
		TrueX = *FEncode(Key,FString::Printf(TEXT("%f"),Input->X));
		TrueY = *FEncode(Key,FString::Printf(TEXT("%f"),Input->Y));
		TrueZ = *FEncode(Key,FString::Printf(TEXT("%f"),Input->Z));
		TrueW = *FEncode(Key,FString::Printf(TEXT("%f"),Input->W));
		ShiftX = *FEncode(Key,FString::Printf(TEXT("%f"),Input->X));
		ShiftY = *FEncode(Key,FString::Printf(TEXT("%f"),Input->Y));
		ShiftZ = *FEncode(Key,FString::Printf(TEXT("%f"),Input->Z));
		ShiftW = *FEncode(Key,FString::Printf(TEXT("%f"),Input->W));
		Flag = 0;
	}

	////////////////////////////////////////////////////////////
	/// Operators

	FORCEINLINE FSafeVector4D &operator = (const FSafeVector4D &V) {
		Internal = V.Internal;
		TrueX = V.TrueX; TrueY = V.TrueY; TrueZ = V.TrueZ; TrueW = V.TrueW;
		ShiftX = V.ShiftX; ShiftY = V.ShiftY; ShiftZ = V.ShiftZ; ShiftW = V.ShiftW;
		Flag = V.Flag;
		return *this;
	}
	
	FORCEINLINE FSafeVector4D &operator = (FVector4 &V) {
		SetValue(&V); return *this;
	}

	FORCEINLINE FArchive &operator << (FArchive &Ar) { 
		Ar << Flag;
		Ar << TrueX;
		Ar << TrueY;
		Ar << TrueZ;
		Ar << TrueW;
		Ar << ShiftX;
		Ar << ShiftY;
		Ar << ShiftZ;
		Ar << ShiftW;
		Ar << Internal;
		return Ar;
	}

	friend FORCEINLINE uint32 GetTypeHash(const FSafeVector4D &V) {
		return FCrc::MemCrc32(&V,sizeof(FSafeVector4D));
	}

};

/** Safe Color Property;
 Use this data format to store sensible Linear Color values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeColor {
	GENERATED_USTRUCT_BODY()
private:

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Internal;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueR;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueG;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueB;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueA;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftR;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftG;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftB;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftA;

	UPROPERTY(SaveGame)
	uint8 Flag;

public:

	////////////////////////////////////////////////////////////
	/// Accessors

	FLinearColor GetValue() {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1;
					ShiftR = TrueR; ShiftG = TrueG; ShiftB = TrueB; ShiftA = TrueA;
					TrueR.Empty(); TrueG.Empty(); TrueB.Empty(); TrueA.Empty();
					return FLinearColor(FCString::Atof(*FDecode(ShiftR)),FCString::Atof(*FDecode(ShiftG)),FCString::Atof(*FDecode(ShiftB)),FCString::Atof(*FDecode(ShiftA)));
				} break;
				case 1:
				{
					Flag = 0;
					TrueR = ShiftR; TrueG = ShiftG; TrueB = ShiftB; TrueA = ShiftA;
					ShiftR.Empty(); ShiftG.Empty(); ShiftB.Empty(); ShiftA.Empty();
					return FLinearColor(FCString::Atof(*FDecode(TrueR)),FCString::Atof(*FDecode(TrueG)),FCString::Atof(*FDecode(TrueB)),FCString::Atof(*FDecode(TrueA)));
				} break;
				default: return FLinearColor::Black;}
		}
	}

	FLinearColor GetValue(const FString &Key) {
		switch (Flag) {
			case 0:
			{
				Flag = 1;
				ShiftR = TrueR; ShiftG = TrueG; ShiftB = TrueB; ShiftA = TrueA;
				TrueR.Empty(); TrueG.Empty(); TrueB.Empty(); TrueA.Empty();
				return FLinearColor(FCString::Atof(*FDecode(Key,ShiftR)),FCString::Atof(*FDecode(Key,ShiftG)),FCString::Atof(*FDecode(Key,ShiftB)),FCString::Atof(*FDecode(Key,ShiftA)));
			} break;
			case 1:
			{
				Flag = 0;
				TrueR = ShiftR; TrueG = ShiftG; TrueB = ShiftB; TrueA = ShiftA;
				ShiftR.Empty(); ShiftG.Empty(); ShiftB.Empty(); ShiftA.Empty();
				return FLinearColor(FCString::Atof(*FDecode(Key,TrueR)),FCString::Atof(*FDecode(Key,TrueG)),FCString::Atof(*FDecode(Key,TrueB)),FCString::Atof(*FDecode(Key,TrueA)));
			} break;
		default: return FLinearColor::Black;}
	}

	void SetValue(FLinearColor* Input) {
		if (!Internal.IsEmpty()) {SetValue(Internal,Input);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1;
					ShiftR = *FEncode(FString::Printf(TEXT("%f"),Input->R));
					ShiftG = *FEncode(FString::Printf(TEXT("%f"),Input->G));
					ShiftB = *FEncode(FString::Printf(TEXT("%f"),Input->B));
					ShiftA = *FEncode(FString::Printf(TEXT("%f"),Input->A));
					TrueR.Empty(); TrueG.Empty(); TrueB.Empty(); TrueA.Empty();
				} break;
				case 1:
				{
					Flag = 0;
					TrueR = *FEncode(FString::Printf(TEXT("%f"),Input->R));
					TrueG = *FEncode(FString::Printf(TEXT("%f"),Input->G));
					TrueB = *FEncode(FString::Printf(TEXT("%f"),Input->B));
					TrueA = *FEncode(FString::Printf(TEXT("%f"),Input->A));
					ShiftR.Empty(); ShiftG.Empty(); ShiftB.Empty(); ShiftA.Empty();
				} break;
			default: return;}
		}
	}

	void SetValue(const FString &Key, FLinearColor* Input) {
		switch (Flag) {
			case 0:
			{
				Flag = 1;
				ShiftR = *FEncode(Key,FString::Printf(TEXT("%f"),Input->R));
				ShiftG = *FEncode(Key,FString::Printf(TEXT("%f"),Input->G));
				ShiftB = *FEncode(Key,FString::Printf(TEXT("%f"),Input->B));
				ShiftA = *FEncode(FString::Printf(TEXT("%f"),Input->A));
				TrueR.Empty(); TrueG.Empty(); TrueB.Empty(); TrueA.Empty();
			} break;
			case 1:
			{
				Flag = 0;
				TrueR = *FEncode(Key,FString::Printf(TEXT("%f"),Input->R));
				TrueG = *FEncode(Key,FString::Printf(TEXT("%f"),Input->G));
				TrueB = *FEncode(Key,FString::Printf(TEXT("%f"),Input->B));
				TrueA = *FEncode(Key,FString::Printf(TEXT("%f"),Input->A));
				ShiftR.Empty(); ShiftG.Empty(); ShiftB.Empty(); ShiftA.Empty();
			} break;
		default: return;}
	}

	////////////////////////////////////////////////////////////
	/// Constructors

	FSafeColor() {
		Internal = FString();
		TrueR = TEXT(""); TrueG = TEXT(""); TrueB = TEXT(""); TrueA = TEXT("");
		ShiftR = TEXT(""); ShiftG = TEXT(""); ShiftB = TEXT(""); ShiftA = TEXT("");
		Flag = 0;
	}

	FSafeColor(const FLinearColor Input) {
		Internal = FString();
		TrueR = *FEncode(FString::Printf(TEXT("%f"),Input.R));
		TrueG = *FEncode(FString::Printf(TEXT("%f"),Input.G));
		TrueB = *FEncode(FString::Printf(TEXT("%f"),Input.B));
		TrueA = *FEncode(FString::Printf(TEXT("%f"),Input.A));
		ShiftR = *FEncode(FString::Printf(TEXT("%f"),Input.R));
		ShiftG = *FEncode(FString::Printf(TEXT("%f"),Input.G));
		ShiftB = *FEncode(FString::Printf(TEXT("%f"),Input.B));
		ShiftA = *FEncode(FString::Printf(TEXT("%f"),Input.A));
		Flag = 0;
	}

	FSafeColor(const FString &Key, const FLinearColor Input) {
		Internal = FString(Key);
		TrueR = *FEncode(Key,FString::Printf(TEXT("%f"),Input.R));
		TrueG = *FEncode(Key,FString::Printf(TEXT("%f"),Input.G));
		TrueB = *FEncode(Key,FString::Printf(TEXT("%f"),Input.B));
		TrueA = *FEncode(Key,FString::Printf(TEXT("%f"),Input.A));
		ShiftR = *FEncode(Key,FString::Printf(TEXT("%f"),Input.R));
		ShiftG = *FEncode(Key,FString::Printf(TEXT("%f"),Input.G));
		ShiftB = *FEncode(Key,FString::Printf(TEXT("%f"),Input.B));
		ShiftA = *FEncode(Key,FString::Printf(TEXT("%f"),Input.A));
		Flag = 0;
	}

	////////////////////////////////////////////////////////////
	/// Operators

	FORCEINLINE FSafeColor &operator = (const FSafeColor &C) {
		Internal = C.Internal;
		TrueR = C.TrueR; TrueG = C.TrueG; TrueB = C.TrueB; TrueA = C.TrueA;
		ShiftR = C.ShiftR; ShiftG = C.ShiftG; ShiftB = C.ShiftB; ShiftA = C.ShiftA;
		Flag = C.Flag;
		return *this;
	}
	
	FORCEINLINE FSafeColor &operator = (FLinearColor &C) {
		SetValue(&C); return *this;
	}

	FORCEINLINE FArchive &operator << (FArchive &Ar) { 
		Ar << Flag;
		Ar << TrueR;
		Ar << TrueG;
		Ar << TrueB;
		Ar << TrueA;
		Ar << ShiftR;
		Ar << ShiftG;
		Ar << ShiftB;
		Ar << ShiftA;
		Ar << Internal;
		return Ar;
	}

	friend FORCEINLINE uint32 GetTypeHash(const FSafeColor &C) {
		return FCrc::MemCrc32(&C,sizeof(FSafeColor));
	}

};

/** Safe Rotator Property;
 Use this data format to store sensible Rotator values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeRotator {
	GENERATED_USTRUCT_BODY()
private:

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString Internal;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueX;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueY;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString TrueZ;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftX;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftY;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FString ShiftZ;

	UPROPERTY(SaveGame)
	uint8 Flag;

public:

	////////////////////////////////////////////////////////////
	/// Accessors

	FRotator GetValue() {
		if (!Internal.IsEmpty()) {return GetValue(Internal);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1;
					ShiftX = TrueX; ShiftY = TrueY; ShiftZ = TrueZ;
					TrueX.Empty(); TrueY.Empty(); TrueZ.Empty();
					return FRotator(FCString::Atof(*FDecode(ShiftX)),FCString::Atof(*FDecode(ShiftY)),FCString::Atof(*FDecode(ShiftZ)));
				} break;
				case 1:
				{
					Flag = 0;
					TrueX = ShiftX; TrueY = ShiftY; TrueZ = ShiftZ;
					ShiftX.Empty(); ShiftY.Empty(); ShiftZ.Empty();
					return FRotator(FCString::Atof(*FDecode(TrueX)),FCString::Atof(*FDecode(TrueY)),FCString::Atof(*FDecode(TrueZ)));
				} break;
			default: return FRotator::ZeroRotator;}
		}
	}

	FRotator GetValue(const FString &Key) {
		switch (Flag) {
			case 0:
			{
				Flag = 1;
				ShiftX = TrueX; ShiftY = TrueY; ShiftZ = TrueZ;
				TrueX.Empty(); TrueY.Empty(); TrueZ.Empty();
				return FRotator(FCString::Atof(*FDecode(Key,ShiftX)),FCString::Atof(*FDecode(Key,ShiftY)),FCString::Atof(*FDecode(Key,ShiftZ)));
			} break;
			case 1:
			{
				Flag = 0;
				TrueX = ShiftX; TrueY = ShiftY; TrueZ = ShiftZ;
				ShiftX.Empty(); ShiftY.Empty(); ShiftZ.Empty();
				return FRotator(FCString::Atof(*FDecode(Key,TrueX)),FCString::Atof(*FDecode(Key,TrueY)),FCString::Atof(*FDecode(Key,TrueZ)));
			} break;
		default: return FRotator::ZeroRotator;}
	}

	void SetValue(FRotator Input) {
		if (!Internal.IsEmpty()) {SetValue(Internal,Input);} else {
			switch (Flag) {
				case 0:
				{
					Flag = 1;
					ShiftX = *FEncode(FString::Printf(TEXT("%f"),Input.Pitch));
					ShiftY = *FEncode(FString::Printf(TEXT("%f"),Input.Yaw));
					ShiftZ = *FEncode(FString::Printf(TEXT("%f"),Input.Roll));
					TrueX.Empty(); TrueY.Empty(); TrueZ.Empty();
				} break;
				case 1:
				{
					Flag = 0;
					TrueX = *FEncode(FString::Printf(TEXT("%f"),Input.Pitch));
					TrueY = *FEncode(FString::Printf(TEXT("%f"),Input.Yaw));
					TrueZ = *FEncode(FString::Printf(TEXT("%f"),Input.Roll));
					ShiftX.Empty(); ShiftY.Empty(); ShiftZ.Empty();
				} break;
			default: return;}
		}
	}

	void SetValue(const FString &Key, FRotator Input) {
		switch (Flag) {
			case 0:
			{
				Flag = 1;
				ShiftX = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Pitch));
				ShiftY = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Yaw));
				ShiftZ = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Roll));
				TrueX.Empty(); TrueY.Empty(); TrueZ.Empty();
			} break;
			case 1:
			{
				Flag = 0;
				TrueX = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Pitch));
				TrueY = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Yaw));
				TrueZ = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Roll));
				ShiftX.Empty(); ShiftY.Empty(); ShiftZ.Empty();
			} break;
		default: return;}
	}

	////////////////////////////////////////////////////////////
	/// Constructors

	FSafeRotator() {
		Internal = FString();
		TrueX = TEXT(""); TrueY = TEXT(""); TrueZ = TEXT("");
		ShiftX = TEXT(""); ShiftY = TEXT(""); ShiftZ = TEXT("");
		Flag = 0;
	}

	FSafeRotator(const float Pitch, const float Yall, const float Roll) {
		Internal = FString();
		TrueX = *FEncode(FString::Printf(TEXT("%f"),Pitch));
		TrueY = *FEncode(FString::Printf(TEXT("%f"),Yall));
		TrueZ = *FEncode(FString::Printf(TEXT("%f"),Roll));
		ShiftX = *FEncode(FString::Printf(TEXT("%f"),Pitch));
		ShiftY = *FEncode(FString::Printf(TEXT("%f"),Yall));
		ShiftZ = *FEncode(FString::Printf(TEXT("%f"),Roll));
		Flag = 0;
	}

	FSafeRotator(const FRotator Input) {
		Internal = FString();
		TrueX = *FEncode(FString::Printf(TEXT("%f"),Input.Pitch));
		TrueY = *FEncode(FString::Printf(TEXT("%f"),Input.Yaw));
		TrueZ = *FEncode(FString::Printf(TEXT("%f"),Input.Roll));
		ShiftX = *FEncode(FString::Printf(TEXT("%f"),Input.Pitch));
		ShiftY = *FEncode(FString::Printf(TEXT("%f"),Input.Yaw));
		ShiftZ = *FEncode(FString::Printf(TEXT("%f"),Input.Roll));
		Flag = 0;
	}

	FSafeRotator(const FString &Key, const FRotator Input) {
		Internal = FString(Key);
		TrueX = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Pitch));
		TrueY = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Yaw));
		TrueZ = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Roll));
		ShiftX = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Pitch));
		ShiftY = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Yaw));
		ShiftZ = *FEncode(Key,FString::Printf(TEXT("%f"),Input.Roll));
		Flag = 0;
	}

	////////////////////////////////////////////////////////////
	/// Operators

	FORCEINLINE FSafeRotator &operator = (const FSafeRotator &R) {
		Internal = R.Internal;
		TrueX = R.TrueX; TrueY = R.TrueY; TrueZ = R.TrueZ;
		ShiftX = R.ShiftX; ShiftY = R.ShiftY; ShiftZ = R.ShiftZ;
		Flag = R.Flag;
		return *this;
	}
	
	FORCEINLINE FSafeRotator &operator = (const FRotator &R) {
		SetValue(R); return *this;
	}

	FORCEINLINE FArchive &operator << (FArchive &Ar) { 
		Ar << Flag;
		Ar << TrueX;
		Ar << TrueY;
		Ar << TrueZ;
		Ar << ShiftX;
		Ar << ShiftY;
		Ar << ShiftZ;
		Ar << Internal;
		return Ar;
	}

	friend FORCEINLINE uint32 GetTypeHash(const FSafeRotator &R) {
		return FCrc::MemCrc32(&R,sizeof(FSafeRotator));
	}

};

/** Safe Transform Property;
 Use this data format to store sensible Transform values you need protected against memory hackers. */
USTRUCT(BlueprintType)
struct SCUE4_API FSafeTransform {
	GENERATED_USTRUCT_BODY()
private:

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FSafeVector3D Scale;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FSafeVector3D Position;

	UPROPERTY(Category = "Security", VisibleAnywhere, SaveGame)
	FSafeRotator Rotation;

public:

	////////////////////////////////////////////////////////////

	FTransform GetValue() {
		return FTransform(Rotation.GetValue(),Position.GetValue(),Scale.GetValue());
	}

	FTransform GetValue(const FString &Key) {
		return FTransform(Rotation.GetValue(*&Key),Position.GetValue(*&Key),Scale.GetValue(*&Key));
	}

	void SetValue(FTransform* Input) {
		Scale.SetValue(Input->GetScale3D());
		Position.SetValue(Input->GetLocation());
		Rotation.SetValue(Input->GetRotation().Rotator());
	}

	void SetValue(const FString &Key, FTransform* Input) {
		Scale.SetValue(*&Key,Input->GetScale3D());
		Position.SetValue(*&Key,Input->GetLocation());
		Rotation.SetValue(*&Key,Input->GetRotation().Rotator());
	}

	////////////////////////////////////////////////////////////
	/// Constructors

	FSafeTransform() {
		Scale = FSafeVector3D::FSafeVector3D();
		Position = FSafeVector3D::FSafeVector3D();
		Rotation = FSafeRotator::FSafeRotator();
	}

	FSafeTransform(FTransform* Input) {
		Scale = FSafeVector3D::FSafeVector3D(Input->GetScale3D());
		Position = FSafeVector3D::FSafeVector3D(Input->GetLocation());
		Rotation = FSafeRotator::FSafeRotator(Input->Rotator());
	}

	FSafeTransform(const FString &Key, FTransform* Input) {
		Scale = FSafeVector3D::FSafeVector3D(*&Key,Input->GetScale3D());
		Position = FSafeVector3D::FSafeVector3D(*&Key,Input->GetLocation());
		Rotation = FSafeRotator::FSafeRotator(*&Key,Input->Rotator());
	}

	////////////////////////////////////////////////////////////
	/// Operators

	FORCEINLINE FSafeTransform &operator = (const FSafeTransform &T) {
		Scale = T.Scale;
		Position = T.Position;
		Rotation = T.Rotation;
		return *this;
	}
	
	FORCEINLINE FSafeTransform &operator = (const FTransform &T) {
		Scale = T.GetScale3D();
		Position = T.GetLocation();
		Rotation = T.Rotator();
		return *this;
	}

	friend FORCEINLINE uint32 GetTypeHash(const FSafeTransform &T) {
		return FCrc::MemCrc32(&T,sizeof(FSafeTransform));
	}

};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Operators:: Adding support for custom 'Safe Type' operations

// FSBool

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeBool &FSB, FSafeBool &B) {
	return  (FSB.GetValue()==B.GetValue());
}

FORCEINLINE bool operator != (FSafeBool &FSB, FSafeBool &B) {
	return (FSB.GetValue()!=B.GetValue());
}

FORCEINLINE bool operator && (FSafeBool &FSB, FSafeBool &B) {
	return (FSB.GetValue()&&B.GetValue());
}

FORCEINLINE bool operator || (FSafeBool &FSB, FSafeBool &B) {
	return (FSB.GetValue()||B.GetValue());
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeBool &FSB, const bool &B) {
	return (FSB.GetValue()==B);
}

FORCEINLINE bool operator != (FSafeBool &FSB, const bool &B) {
	return (FSB.GetValue()!=B);
}

FORCEINLINE bool operator && (FSafeBool &FSB, const bool &B) {
	return (FSB.GetValue()&&B);
}

FORCEINLINE bool operator || (FSafeBool &FSB, const bool &B) {
	return (FSB.GetValue()||B);
}

/* FSafe -> Native */

FORCEINLINE bool operator == (const bool &B, FSafeBool &FSB) {
	return (B==FSB.GetValue());
}

FORCEINLINE bool operator != (const bool &B, FSafeBool &FSB) {
	return (B!=FSB.GetValue());
}

FORCEINLINE bool operator && (const bool &B, FSafeBool &FSB) {
	return (B&&FSB.GetValue());
}

FORCEINLINE bool operator || (const bool &B, FSafeBool &FSB) {
	return (B||FSB.GetValue());
}

// FSByte

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeByte &FSB, FSafeByte &B) {
	return (FSB.GetValue()==B.GetValue());
}

FORCEINLINE bool operator != (FSafeByte &FSB, FSafeByte &B) {
	return (FSB.GetValue()!=B.GetValue());
}

FORCEINLINE bool operator > (FSafeByte &FSB, FSafeByte &B) {
	return (FSB.GetValue()>B.GetValue());
}

FORCEINLINE bool operator < (FSafeByte &FSB, FSafeByte &B) {
	return (FSB.GetValue()<B.GetValue());
}

FORCEINLINE bool operator >= (FSafeByte &FSB, FSafeByte &B) {
	return (FSB.GetValue()>=B.GetValue());
}

FORCEINLINE bool operator <= (FSafeByte &FSB, FSafeByte &B) {
	return (FSB.GetValue()<=B.GetValue());
}

FORCEINLINE FSafeByte operator + (FSafeByte &FSB, FSafeByte &B) {
	return FSafeByte(FSB.GetValue()+B.GetValue());
}

FORCEINLINE FSafeByte operator - (FSafeByte &FSB, FSafeByte &B) {
	return FSafeByte(FSB.GetValue()-B.GetValue());
}

FORCEINLINE FSafeByte operator * (FSafeByte &FSB, FSafeByte &B) {
	return FSafeByte(FSB.GetValue()*B.GetValue());
}

FORCEINLINE FSafeByte operator / (FSafeByte &FSB, FSafeByte &B) {
	return FSafeByte(FSB.GetValue()/B.GetValue());
}

FORCEINLINE FSafeByte operator ~ (FSafeByte &FSB) {
	auto Local = FSB.GetValue();
	return FSafeByte(~Local);
}

FORCEINLINE FSafeByte operator % (FSafeByte &FSB, FSafeByte &B) {
	auto Local = FSB.GetValue(); auto Mod = B.GetValue();
	return FSafeByte((Local%Mod));
}

FORCEINLINE FSafeByte operator & (FSafeByte &FSB, FSafeByte &B) {
	auto Local = FSB.GetValue(); auto An = B.GetValue();
	return FSafeByte((Local&An));
}

FORCEINLINE FSafeByte operator | (FSafeByte &FSB, FSafeByte &B) {
	auto Local = FSB.GetValue(); auto Orr = B.GetValue();
	return FSafeByte((Local|Orr));
}

FORCEINLINE FSafeByte operator ^ (FSafeByte &FSB, FSafeByte &B) {
	auto Local = FSB.GetValue(); auto To = B.GetValue();
	return FSafeByte((Local^To));
}

FORCEINLINE FSafeByte operator >> (FSafeByte &FSB, FSafeByte &B) {
	auto Local = FSB.GetValue(); auto To = B.GetValue();
	return FSafeByte((Local>>To));
}

FORCEINLINE FSafeByte operator << (FSafeByte &FSB, FSafeByte &B) {
	auto Local = FSB.GetValue(); auto To = B.GetValue();
	return FSafeByte((Local<<To));
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeByte &FSB, const uint8 &B) {
	return (FSB.GetValue()==B);
}

FORCEINLINE bool operator != (FSafeByte &FSB, const uint8 &B) {
	return (FSB.GetValue()!=B);
}

FORCEINLINE bool operator > (FSafeByte &FSB, const uint8 &B) {
	return (FSB.GetValue()>B);
}

FORCEINLINE bool operator < (FSafeByte &FSB, const uint8 &B) {
	return (FSB.GetValue()<B);
}

FORCEINLINE bool operator >= (FSafeByte &FSB, const uint8 &B) {
	return (FSB.GetValue()>=B);
}

FORCEINLINE bool operator <= (FSafeByte &FSB, const uint8 &B) {
	return (FSB.GetValue()<=B);
}

FORCEINLINE FSafeByte operator + (FSafeByte &FSB, const uint8 &B) {
	return FSafeByte(FSB.GetValue()+B);
}

FORCEINLINE FSafeByte operator - (FSafeByte &FSB, const uint8 &B) {
	return FSafeByte(FSB.GetValue()-B);
}

FORCEINLINE FSafeByte operator * (FSafeByte &FSB, const uint8 &B) {
	return FSafeByte(FSB.GetValue()*B);
}

FORCEINLINE FSafeByte operator / (FSafeByte &FSB, const uint8 &B) {
	return FSafeByte(FSB.GetValue()/B);
}

FORCEINLINE FSafeByte operator % (FSafeByte &FSB, const uint8 &B) {
	auto Local = FSB.GetValue();
	return FSafeByte((Local%B));
}

FORCEINLINE FSafeByte operator & (FSafeByte &FSB, const uint8 &B) {
	auto Local = FSB.GetValue();
	return FSafeByte((Local&B));
}

FORCEINLINE FSafeByte operator | (FSafeByte &FSB, const uint8 &B) {
	auto Local = FSB.GetValue();
	return FSafeByte((Local|B));
}

FORCEINLINE FSafeByte operator ^ (FSafeByte &FSB, const uint8 &B) {
	auto Local = FSB.GetValue();
	return FSafeByte((Local^B));
}

FORCEINLINE FSafeByte operator >> (FSafeByte &FSB, const uint8 &B) {
	auto Local = FSB.GetValue();
	return FSafeByte((Local>>B));
}

FORCEINLINE FSafeByte operator << (FSafeByte &FSB, const uint8 &B) {
	auto Local = FSB.GetValue();
	return FSafeByte((Local<<B));
}

/* FSafe -> Native */

FORCEINLINE bool operator == (const uint8 &B, FSafeByte &FSB) {
	return (B==FSB.GetValue());
}

FORCEINLINE bool operator != (const uint8 &B, FSafeByte &FSB) {
	return (B!=FSB.GetValue());
}

FORCEINLINE bool operator > (const uint8 &B, FSafeByte &FSB) {
	return (B>FSB.GetValue());
}

FORCEINLINE bool operator < (const uint8 &B, FSafeByte &FSB) {
	return (B<FSB.GetValue());
}

FORCEINLINE bool operator >= (const uint8 &B, FSafeByte &FSB) {
	return (B>=FSB.GetValue());
}

FORCEINLINE bool operator <= (const uint8 &B, FSafeByte &FSB) {
	return (B<=FSB.GetValue());
}

FORCEINLINE uint8 operator + (uint8 &B, FSafeByte &FSB) {
	return (B+FSB.GetValue());
}

FORCEINLINE uint8 operator - (uint8 &B, FSafeByte &FSB) {
	return (B-FSB.GetValue());
}

FORCEINLINE uint8 operator * (uint8 &B, FSafeByte &FSB) {
	return (B*FSB.GetValue());
}

FORCEINLINE uint8 operator / (uint8 &B, FSafeByte &FSB) {
	return (B/FSB.GetValue());
}

FORCEINLINE uint8 operator % (uint8 &B, FSafeByte &FSB) {
	auto Mod = FSB.GetValue();
	return ((B%Mod));
}

FORCEINLINE uint8 operator & (uint8 &B, FSafeByte &FSB) {
	auto Local = FSB.GetValue();
	return ((B&Local));
}

FORCEINLINE uint8 operator | (uint8 &B, FSafeByte &FSB) {
	auto Local = FSB.GetValue();
	return ((B|Local));
}

FORCEINLINE uint8 operator ^ (uint8 &B, FSafeByte &FSB) {
	auto Local = FSB.GetValue();
	return ((B^Local));
}

FORCEINLINE uint8 operator >> (uint8 &B, FSafeByte &FSB) {
	auto Local = FSB.GetValue();
	return ((B>>Local));
}

FORCEINLINE uint8 operator << (uint8 &B, FSafeByte &FSB) {
	auto Local = FSB.GetValue();
	return ((B<<Local));
}

// FSInt

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeInt &FSI, FSafeInt &I) {
	return (FSI.GetValue() == I.GetValue());
}

FORCEINLINE bool operator != (FSafeInt &FSI, FSafeInt &I) {
	return (FSI.GetValue()!=I.GetValue());
}

FORCEINLINE bool operator > (FSafeInt &FSI, FSafeInt &I) {
	return (FSI.GetValue()>I.GetValue());
}

FORCEINLINE bool operator < (FSafeInt &FSI, FSafeInt &I) {
	return (FSI.GetValue()<I.GetValue());
}

FORCEINLINE bool operator >= (FSafeInt &FSI, FSafeInt &I) {
	return (FSI.GetValue()>=I.GetValue());
}

FORCEINLINE bool operator <= (FSafeInt &FSI, FSafeInt &I) {
	return (FSI.GetValue()<=I.GetValue());
}

FORCEINLINE FSafeInt operator + (FSafeInt &FSI, FSafeInt &I) {
	return FSafeInt(FSI.GetValue()+I.GetValue());
}

FORCEINLINE FSafeInt operator - (FSafeInt &FSI, FSafeInt &I) {
	return FSafeInt(FSI.GetValue()-I.GetValue());
}

FORCEINLINE FSafeInt operator * (FSafeInt &FSI, FSafeInt &I) {
	return FSafeInt(FSI.GetValue()*I.GetValue());
}

FORCEINLINE FSafeInt operator / (FSafeInt &FSI, FSafeInt &I) {
	return FSafeInt(FSI.GetValue()/I.GetValue());
}

FORCEINLINE FSafeInt operator ~ (FSafeInt &FSI) {
	auto Local = FSI.GetValue();
	return FSafeInt(~Local);
}

FORCEINLINE FSafeInt operator % (FSafeInt &FSI, FSafeInt &I) {
	auto Local = FSI.GetValue(); auto Mod = I.GetValue();
	return FSafeInt((Local%Mod));
}

FORCEINLINE FSafeInt operator & (FSafeInt &FSI, FSafeInt &I) {
	auto Local = FSI.GetValue(); auto An = I.GetValue();
	return FSafeInt((Local&An));
}

FORCEINLINE FSafeInt operator | (FSafeInt &FSI, FSafeInt &I) {
	auto Local = FSI.GetValue(); auto Orr = I.GetValue();
	return FSafeInt((Local|Orr));
}

FORCEINLINE FSafeInt operator ^ (FSafeInt &FSI, FSafeInt &I) {
	auto Local = FSI.GetValue(); auto To = I.GetValue();
	return FSafeInt((Local^To));
}

FORCEINLINE FSafeInt operator >> (FSafeInt &FSI, FSafeInt &I) {
	auto Local = FSI.GetValue(); auto To = I.GetValue();
	return FSafeInt((Local>>To));
}

FORCEINLINE FSafeInt operator << (FSafeInt &FSI, FSafeInt &I) {
	auto Local = FSI.GetValue(); auto To = I.GetValue();
	return FSafeInt((Local<<To));
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeInt &FSI, const int32 &I) {
	return (FSI.GetValue()==I);
}

FORCEINLINE bool operator != (FSafeInt &FSI, const int32 &I) {
	return (FSI.GetValue()!=I);
}

FORCEINLINE bool operator > (FSafeInt &FSI, const int32 &I) {
	return (FSI.GetValue()>I);
}

FORCEINLINE bool operator < (FSafeInt &FSI, const int32 &I) {
	return (FSI.GetValue()<I);
}

FORCEINLINE bool operator >= (FSafeInt &FSI, const int32 &I) {
	return (FSI.GetValue()>=I);
}

FORCEINLINE bool operator <= (FSafeInt &FSI, const int32 &I) {
	return (FSI.GetValue()<=I);
}

FORCEINLINE FSafeInt operator + (FSafeInt &FSI, const int32 &I) {
	return FSafeInt(FSI.GetValue()+I);
}

FORCEINLINE FSafeInt operator - (FSafeInt &FSI, const int32 &I) {
	return FSafeInt(FSI.GetValue()-I);
}

FORCEINLINE FSafeInt operator * (FSafeInt &FSI, const int32 &I) {
	return FSafeInt(FSI.GetValue()*I);
}

FORCEINLINE FSafeInt operator / (FSafeInt &FSI, const int32 &I) {
	return FSafeInt(FSI.GetValue()/I);
}

FORCEINLINE FSafeInt operator % (FSafeInt &FSI, const int32 &I) {
	auto Local = FSI.GetValue();
	return FSafeInt((Local%I));
}

FORCEINLINE FSafeInt operator & (FSafeInt &FSI, const int32 &I) {
	auto Local = FSI.GetValue();
	return FSafeInt((Local&I));
}

FORCEINLINE FSafeInt operator | (FSafeInt &FSI, const int32 &I) {
	auto Local = FSI.GetValue();
	return FSafeInt((Local|I));
}

FORCEINLINE FSafeInt operator ^ (FSafeInt &FSI, const int32 &I) {
	auto Local = FSI.GetValue();
	return FSafeInt((Local^I));
}

FORCEINLINE FSafeInt operator >> (FSafeInt &FSI, const int32 &I) {
	auto Local = FSI.GetValue();
	return FSafeInt((Local>>I));
}

FORCEINLINE FSafeInt operator << (FSafeInt &FSI, const int32 &I) {
	auto Local = FSI.GetValue();
	return FSafeInt((Local<<I));
}

/* FSafe -> Native */

FORCEINLINE bool operator == (const int32 &I, FSafeInt &FSI) {
	return (I==FSI.GetValue());
}

FORCEINLINE bool operator != (const int32 &I, FSafeInt &FSI) {
	return (I!=FSI.GetValue());
}

FORCEINLINE bool operator > (const int32 &I, FSafeInt &FSI) {
	return (I>FSI.GetValue());
}

FORCEINLINE bool operator < (const int32 &I, FSafeInt &FSI) {
	return (I<FSI.GetValue());
}

FORCEINLINE bool operator >= (const int32 &I, FSafeInt &FSI) {
	return (I>=FSI.GetValue());
}

FORCEINLINE bool operator <= (const int32 &I, FSafeInt &FSI) {
	return (I<=FSI.GetValue());
}

FORCEINLINE int32 operator + (int32 &I, FSafeInt &FSI) {
	return (I+FSI.GetValue());
}

FORCEINLINE int32 operator - (int32 &I, FSafeInt &FSI) {
	return (I-FSI.GetValue());
}

FORCEINLINE int32 operator * (int32 &I, FSafeInt &FSI) {
	return (I*FSI.GetValue());
}

FORCEINLINE int32 operator / (int32 &I, FSafeInt &FSI) {
	return (I/FSI.GetValue());
}

FORCEINLINE int32 operator % (int32 &I, FSafeInt &FSI) {
	auto Mod = FSI.GetValue();
	return ((I%Mod));
}

FORCEINLINE int32 operator & (int32 &I, FSafeInt &FSI) {
	auto Local = FSI.GetValue();
	return ((I&Local));
}

FORCEINLINE int32 operator | (int32 &I, FSafeInt &FSI) {
	auto Local = FSI.GetValue();
	return ((I|Local));
}

FORCEINLINE int32 operator ^ (int32 &I, FSafeInt &FSI) {
	auto Local = FSI.GetValue();
	return ((I^Local));
}

FORCEINLINE int32 operator >> (int32 &I, FSafeInt &FSI) {
	auto Local = FSI.GetValue();
	return ((I>>Local));
}

FORCEINLINE int32 operator << (int32 &I, FSafeInt &FSI) {
	auto Local = FSI.GetValue();
	return ((I<<Local));
}

// FSFloat

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeFloat &FSF, FSafeFloat &F) {
	return (FSF.GetValue()==F.GetValue());
}

FORCEINLINE bool operator != (FSafeFloat &FSF, FSafeFloat &F) {
	return (FSF.GetValue()!=F.GetValue());
}

FORCEINLINE bool operator > (FSafeFloat &FSF, FSafeFloat &F) {
	return (FSF.GetValue()>F.GetValue());
}

FORCEINLINE bool operator < (FSafeFloat &FSF, FSafeFloat &F) {
	return (FSF.GetValue()<F.GetValue());
}

FORCEINLINE bool operator >= (FSafeFloat &FSF, FSafeFloat &F) {
	return (FSF.GetValue()>=F.GetValue());
}

FORCEINLINE bool operator <= (FSafeFloat &FSF, FSafeFloat &F) {
	return (FSF.GetValue()<=F.GetValue());
}

FORCEINLINE FSafeFloat operator + (FSafeFloat &FSF, FSafeFloat &F) {
	return FSafeFloat(FSF.GetValue()+F.GetValue());
}

FORCEINLINE FSafeFloat operator - (FSafeFloat &FSF, FSafeFloat &F) {
	return FSafeFloat(FSF.GetValue()-F.GetValue());
}

FORCEINLINE FSafeFloat operator * (FSafeFloat &FSF, FSafeFloat &F) {
	return FSafeFloat(FSF.GetValue()*F.GetValue());
}

FORCEINLINE FSafeFloat operator / (FSafeFloat &FSF, FSafeFloat &F) {
	return FSafeFloat(FSF.GetValue()/F.GetValue());
}

FORCEINLINE FSafeFloat operator % (FSafeFloat &FSF, FSafeFloat &F) {
	auto Local = FSF.GetValue(); auto Mod = F.GetValue();
	return FSafeFloat(FGenericPlatformMath::Fmod(Local,Mod));
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeFloat &FSF, const float &F) {
	return (FSF.GetValue()==F);
}

FORCEINLINE bool operator != (FSafeFloat &FSF, const float &F) {
	return (FSF.GetValue()!=F);
}

FORCEINLINE bool operator > (FSafeFloat &FSF, const float &F) {
	return (FSF.GetValue()>F);
}

FORCEINLINE bool operator < (FSafeFloat &FSF, const float &F) {
	return (FSF.GetValue()<F);
}

FORCEINLINE bool operator >= (FSafeFloat &FSF, const float &F) {
	return (FSF.GetValue()>=F);
}

FORCEINLINE bool operator <= (FSafeFloat &FSF, const float &F) {
	return (FSF.GetValue()<=F);
}

FORCEINLINE FSafeFloat operator + (FSafeFloat &FSF, const float &F) {
	return FSafeFloat(FSF.GetValue()+F);
}

FORCEINLINE FSafeFloat operator - (FSafeFloat &FSF, const float &F) {
	return FSafeFloat(FSF.GetValue()-F);
}

FORCEINLINE FSafeFloat operator * (FSafeFloat &FSF, const float &F) {
	return FSafeFloat(FSF.GetValue()*F);
}

FORCEINLINE FSafeFloat operator / (FSafeFloat &FSF, const float &F) {
	return FSafeFloat(FSF.GetValue()/F);
}

FORCEINLINE FSafeFloat operator % (FSafeFloat &FSF, const float &F) {
	auto Local = FSF.GetValue();
	return FSafeFloat(FGenericPlatformMath::Fmod(Local,F));
}

/* FSafe -> Native */

FORCEINLINE bool operator == (const float &F, FSafeFloat &FSF) {
	return (F==FSF.GetValue());
}

FORCEINLINE bool operator != (const float &F, FSafeFloat &FSF) {
	return (F!=FSF.GetValue());
}

FORCEINLINE bool operator > (const float &F, FSafeFloat &FSF) {
	return (F>FSF.GetValue());
}

FORCEINLINE bool operator < (const float &F, FSafeFloat &FSF) {
	return (F<FSF.GetValue());
}

FORCEINLINE bool operator >= (const float &F, FSafeFloat &FSF) {
	return (F>=FSF.GetValue());
}

FORCEINLINE bool operator <= (const float &F, FSafeFloat &FSF) {
	return (F<=FSF.GetValue());
}

FORCEINLINE float operator + (float &F, FSafeFloat &FSF) {
	return (F+FSF.GetValue());
}

FORCEINLINE float operator - (float &F, FSafeFloat &FSF) {
	return (F-FSF.GetValue());
}

FORCEINLINE float operator * (float &F, FSafeFloat &FSF) {
	return (F*FSF.GetValue());
}

FORCEINLINE float operator / (float &F, FSafeFloat &FSF) {
	return (F/FSF.GetValue());
}

FORCEINLINE float operator % (float &F, FSafeFloat &FSF) {
	auto Mod = FSF.GetValue();
	return (FGenericPlatformMath::Fmod(F,Mod));
}

// FSName

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeName &FSN, FSafeName &N) {
	return (FSN.GetValue().IsEqual(N.GetValue(),ENameCase::CaseSensitive,true));
}

FORCEINLINE bool operator != (FSafeName &FSN, FSafeName &N) {
	return (!FSN.GetValue().IsEqual(N.GetValue(),ENameCase::CaseSensitive,true));
}

FORCEINLINE bool operator > (FSafeName &FSN, FSafeName &N) {
	return (N.GetValue().FastLess(FSN.GetValue()));
}

FORCEINLINE bool operator < (FSafeName &FSN, FSafeName &N) {
	return (FSN.GetValue().FastLess(N.GetValue()));
}

FORCEINLINE FSafeName operator + (FSafeName &FSN, FSafeName &N) {
	return FSafeName(*(FSN.GetValue().ToString().Append(N.GetValue().ToString())));
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeName &FSN, FName &N) {
	return (FSN.GetValue().IsEqual(N,ENameCase::CaseSensitive,true));
}

FORCEINLINE bool operator != (FSafeName &FSN, FName &N) {
	return (!FSN.GetValue().IsEqual(N,ENameCase::CaseSensitive,true));
}

FORCEINLINE bool operator > (FSafeName &FSN, FName &N) {
	return N.FastLess(FSN.GetValue());
}

FORCEINLINE bool operator < (FSafeName &FSN, FName &N) {
	return FSN.GetValue().FastLess(N);
}

FORCEINLINE FSafeName operator + (FSafeName &FSN, FName &N) {
	return FSafeName(*(FSN.GetValue().ToString().Append(N.ToString())));
}

/* FSafe -> Native */

FORCEINLINE bool operator == (FName &N, FSafeName &FSN) {
	return (N.IsEqual(FSN.GetValue(),ENameCase::CaseSensitive,true));
}

FORCEINLINE bool operator != (FName &N, FSafeName &FSN) {
	return (!N.IsEqual(FSN.GetValue(),ENameCase::CaseSensitive,true));
}

FORCEINLINE bool operator > (FName &N, FSafeName &FSN) {
	return FSN.GetValue().FastLess(N);
}

FORCEINLINE bool operator < (FName &N, FSafeName &FSN) {
	return N.FastLess(FSN.GetValue());
}

FORCEINLINE FName operator + (FName &N, FSafeName &FSN) {
	return FName(*(N.ToString().Append(FSN.GetValue().ToString())));
}

// FSText

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeText &FST, FSafeText &T) {
	return (FST.GetValue().EqualTo(T.GetValue()));
}

FORCEINLINE bool operator != (FSafeText &FST, FSafeText &T) {
	return (!FST.GetValue().EqualTo(T.GetValue()));
}

FORCEINLINE bool operator > (FSafeText &FST, FSafeText &T) {
	return (FST.GetValue().ToString()>T.GetValue().ToString());
}

FORCEINLINE bool operator < (FSafeText &FST, FSafeText &T) {
	return (FST.GetValue().ToString()<T.GetValue().ToString());
}

FORCEINLINE FSafeText operator + (FSafeText &FST, FSafeText &T) {
	return FSafeText(FText::Format(FST.GetValue(),T.GetValue()));
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeText &FST, FText &T) {
	return (FST.GetValue().EqualTo(T));
}

FORCEINLINE bool operator != (FSafeText &FST, FText &T) {
	return (!FST.GetValue().EqualTo(T));
}

FORCEINLINE bool operator > (FSafeText &FST, FText &T) {
	return (FST.GetValue().ToString()>T.ToString());
}

FORCEINLINE bool operator < (FSafeText &FST, FText &T) {
	return (FST.GetValue().ToString()<T.ToString());
}

FORCEINLINE FSafeText operator + (FSafeText &FST, FText &T) {
	return FSafeText(FText::Format(FST.GetValue(),T));
}

/* FSafe -> Native */

FORCEINLINE bool operator == (FText &T, FSafeText &FST) {
	return (T.EqualTo(FST.GetValue()));
}

FORCEINLINE bool operator != (FText &T, FSafeText &FST) {
	return (!T.EqualTo(FST.GetValue()));
}

FORCEINLINE bool operator > (FText &T, FSafeText &FST) {
	return (T.ToString()>FST.GetValue().ToString());
}

FORCEINLINE bool operator < (FText &T, FSafeText &FST) {
	return (T.ToString()<FST.GetValue().ToString());
}

FORCEINLINE FText operator + (FText &T, FSafeText &FST) {
	return FText::Format(T,FST.GetValue());
}

// FSString

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeString &FSS, FSafeString &S) {
	return (FSS.GetValue().Equals(S.GetValue(),ESearchCase::CaseSensitive));
}

FORCEINLINE bool operator != (FSafeString &FSS, FSafeString &S) {
	return (!FSS.GetValue().Equals(S.GetValue(),ESearchCase::CaseSensitive));
}

FORCEINLINE bool operator > (FSafeString &FSS, FSafeString &S) {
	return (FSS.GetValue()>S.GetValue());
}

FORCEINLINE bool operator < (FSafeString &FSS, FSafeString &S) {
	return (FSS.GetValue()<S.GetValue());
}

FORCEINLINE FSafeString operator + (FSafeString &FSS, FSafeString &S) {
	return FSafeString(*(FSS.GetValue().Append(S.GetValue()))); return *&FSS;
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeString &FSS, FString &S) {
	return (FSS.GetValue().Equals(S,ESearchCase::CaseSensitive));
}

FORCEINLINE bool operator != (FSafeString &FSS, FString &S) {
	return (!FSS.GetValue().Equals(S,ESearchCase::CaseSensitive));
}

FORCEINLINE bool operator > (FSafeString &FSS, FString &S) {
	return (FSS.GetValue()>S);
}

FORCEINLINE bool operator < (FSafeString &FSS, FString &S) {
	return (FSS.GetValue()<S);
}

FORCEINLINE FSafeString operator + (FSafeString &FSS, FString &S) {
	return FSafeString(*(FSS.GetValue().Append(S)));
}

/* FSafe -> Native */

FORCEINLINE bool operator == (FString &S, FSafeString &FSS) {
	return (S.Equals(FSS.GetValue(),ESearchCase::CaseSensitive));
}

FORCEINLINE bool operator != (FString &S, FSafeString &FSS) {
	return (!S.Equals(FSS.GetValue(),ESearchCase::CaseSensitive));
}

FORCEINLINE bool operator > (FString &S, FSafeString &FSS) {
	return (S>FSS.GetValue());
}

FORCEINLINE bool operator < (FString &S, FSafeString &FSS) {
	return (S<FSS.GetValue());
}

FORCEINLINE FString operator + (FString &S, FSafeString &FSS) {
	return FString(*(S.Append(FSS.GetValue())));
}

// FSVector2D

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeVector2D &FSV, FSafeVector2D &V) {
	return (FSV.GetValue()==V.GetValue());
}

FORCEINLINE bool operator != (FSafeVector2D &FSV, FSafeVector2D &V) {
	return (FSV.GetValue()!=V.GetValue());
}

FORCEINLINE bool operator > (FSafeVector2D &FSV, FSafeVector2D &V) {
	return (FSV.GetValue()>V.GetValue());
}

FORCEINLINE bool operator < (FSafeVector2D &FSV, FSafeVector2D &V) {
	return (FSV.GetValue()<V.GetValue());
}

FORCEINLINE bool operator >= (FSafeVector2D &FSV, FSafeVector2D &V) {
	return (FSV.GetValue()>=V.GetValue());
}

FORCEINLINE bool operator <= (FSafeVector2D &FSV, FSafeVector2D &V) {
	return (FSV.GetValue()<=V.GetValue());
}

FORCEINLINE FSafeVector2D operator + (FSafeVector2D &FSV, FSafeVector2D &V) {
	return FSafeVector2D(FSV.GetValue()+V.GetValue());
}

FORCEINLINE FSafeVector2D operator - (FSafeVector2D &FSV, FSafeVector2D &V) {
	return FSafeVector2D(FSV.GetValue()-V.GetValue());
}

FORCEINLINE FSafeVector2D operator * (FSafeVector2D &FSV, FSafeVector2D &V) {
	return FSafeVector2D(FSV.GetValue()*V.GetValue());
}

FORCEINLINE FSafeVector2D operator / (FSafeVector2D &FSV, FSafeVector2D &V) {
	return FSafeVector2D(FSV.GetValue()/V.GetValue());
}

FORCEINLINE FSafeVector2D operator % (FSafeVector2D &FSV, FSafeVector2D &V) {
	auto Local = FSV.GetValue(); auto Mod = V.GetValue();
	auto X = Local.X; auto Y = Local.Y; auto MX = Mod.X; auto MY = Mod.Y; 
	return FSafeVector2D(FVector2D(FGenericPlatformMath::Fmod(X,MX),FGenericPlatformMath::Fmod(Y,MY)));
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeVector2D &FSV, const FVector2D &V) {
	return (FSV.GetValue()==V);
}

FORCEINLINE bool operator != (FSafeVector2D &FSV, const FVector2D &V) {
	return (FSV.GetValue()!=V);
}

FORCEINLINE bool operator > (FSafeVector2D &FSV, const FVector2D &V) {
	return (FSV.GetValue()>V);
}

FORCEINLINE bool operator < (FSafeVector2D &FSV, const FVector2D &V) {
	return (FSV.GetValue()<V);
}

FORCEINLINE bool operator >= (FSafeVector2D &FSV, const FVector2D &V) {
	return (FSV.GetValue()>=V);
}

FORCEINLINE bool operator <= (FSafeVector2D &FSV, const FVector2D &V) {
	return (FSV.GetValue()<=V);
}

FORCEINLINE FSafeVector2D operator + (FSafeVector2D &FSV, const FVector2D &V) {
	return FSafeVector2D(FSV.GetValue()+V);
}

FORCEINLINE FSafeVector2D operator - (FSafeVector2D &FSV, const FVector2D &V) {
	return FSafeVector2D(FSV.GetValue()-V);
}

FORCEINLINE FSafeVector2D operator * (FSafeVector2D &FSV, const FVector2D &V) {
	return FSafeVector2D(FSV.GetValue()*V);
}

FORCEINLINE FSafeVector2D operator / (FSafeVector2D &FSV, const FVector2D &V) {
	return FSafeVector2D(FSV.GetValue()/V);
}

FORCEINLINE FSafeVector2D operator % (FSafeVector2D &FSV, const FVector2D &V) {
	auto Local = FSV.GetValue();
	auto X = Local.X; auto Y = Local.Y;
	auto MX = V.X; auto MY = V.Y; 
	return FSafeVector2D(FVector2D(FGenericPlatformMath::Fmod(X,MX),FGenericPlatformMath::Fmod(Y,MY)));
}

/* FSafe -> Native */

FORCEINLINE bool operator == (const FVector2D &V, FSafeVector2D &FSV) {
	return (V==FSV.GetValue());
}

FORCEINLINE bool operator != (const FVector2D &V, FSafeVector2D &FSV) {
	return (V!=FSV.GetValue());
}

FORCEINLINE bool operator > (const FVector2D &V, FSafeVector2D &FSV) {
	return (V>FSV.GetValue());
}

FORCEINLINE bool operator < (const FVector2D &V, FSafeVector2D &FSV) {
	return (V<FSV.GetValue());
}

FORCEINLINE bool operator >= (const FVector2D &V, FSafeVector2D &FSV) {
	return (V>=FSV.GetValue());
}

FORCEINLINE bool operator <= (const FVector2D &V, FSafeVector2D &FSV) {
	return (FSV.GetValue()<=V);
}

FORCEINLINE FVector2D operator + (const FVector2D &V, FSafeVector2D &FSV) {
	return (V+FSV.GetValue());
}

FORCEINLINE FVector2D operator - (const FVector2D &V, FSafeVector2D &FSV) {
	return (V-FSV.GetValue());
}

FORCEINLINE FVector2D operator * (const FVector2D &V, FSafeVector2D &FSV) {
	return (V*FSV.GetValue());
}

FORCEINLINE FVector2D operator / (const FVector2D &V, FSafeVector2D &FSV) {
	return (V/FSV.GetValue());
}

FORCEINLINE FVector2D operator % (const FVector2D &V, FSafeVector2D &FSV) {
	auto Local = FSV.GetValue();
	auto X = V.X; auto Y = V.Y; 
	auto MX = Local.X; auto MY = Local.Y;
	return FVector2D(FGenericPlatformMath::Fmod(X,MX),FGenericPlatformMath::Fmod(Y,MY));
}

// FSVector3D

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeVector3D &FSV, FSafeVector3D &V) {
	return (FSV.GetValue()==V.GetValue());
}

FORCEINLINE bool operator != (FSafeVector3D &FSV, FSafeVector3D &V) {
	return (FSV.GetValue()!=V.GetValue());
}

FORCEINLINE bool operator > (FSafeVector3D &FSV, FSafeVector3D &V) {
	return ((FSV.GetValue().X>V.GetValue().X)&&(FSV.GetValue().Y>V.GetValue().Y)&&(FSV.GetValue().Z>V.GetValue().Z));
}

FORCEINLINE bool operator < (FSafeVector3D &FSV, FSafeVector3D &V) {
	return ((FSV.GetValue().X<V.GetValue().X)&&(FSV.GetValue().Y<V.GetValue().Y)&&(FSV.GetValue().Z<V.GetValue().Z));
}

FORCEINLINE bool operator >= (FSafeVector3D &FSV, FSafeVector3D &V) {
	return ((FSV.GetValue().X>=V.GetValue().X)&&(FSV.GetValue().Y>=V.GetValue().Y)&&(FSV.GetValue().Z>=V.GetValue().Z));
}

FORCEINLINE bool operator <= (FSafeVector3D &FSV, FSafeVector3D &V) {
	return ((FSV.GetValue().X<=V.GetValue().X)&&(FSV.GetValue().Y<=V.GetValue().Y)&&(FSV.GetValue().Z<=V.GetValue().Z));
}

FORCEINLINE FSafeVector3D operator + (FSafeVector3D &FSV, FSafeVector3D &V) {
	return FSafeVector3D(FSV.GetValue()+V.GetValue());
}

FORCEINLINE FSafeVector3D operator - (FSafeVector3D &FSV, FSafeVector3D &V) {
	return FSafeVector3D(FSV.GetValue()-V.GetValue());
}

FORCEINLINE FSafeVector3D operator * (FSafeVector3D &FSV, FSafeVector3D &V) {
	return FSafeVector3D(FSV.GetValue()*V.GetValue());
}

FORCEINLINE FSafeVector3D operator / (FSafeVector3D &FSV, FSafeVector3D &V) {
	return FSafeVector3D(FSV.GetValue()/V.GetValue());
}

FORCEINLINE FSafeVector3D operator % (FSafeVector3D &FSV, FSafeVector3D &V) {
	auto Local = FSV.GetValue(); auto Mod = V.GetValue();
	auto X = Local.X; auto Y = Local.Y; auto Z = Local.Z;
	auto MX = Mod.X; auto MY = Mod.Y;  auto MZ = Mod.Z;
	return FSafeVector3D(FVector(FGenericPlatformMath::Fmod(X,MX),FGenericPlatformMath::Fmod(Y,MY),FGenericPlatformMath::Fmod(Z,MZ)));
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeVector3D &FSV, const FVector &V) {
	return (FSV.GetValue()==V);
}

FORCEINLINE bool operator != (FSafeVector3D &FSV, const FVector &V) {
	return (FSV.GetValue()!=V);
}

FORCEINLINE bool operator > (FSafeVector3D &FSV, const FVector &V) {
	return ((FSV.GetValue().X>V.X)&&(FSV.GetValue().Y>V.Y)&&(FSV.GetValue().Z>V.Z));
}

FORCEINLINE bool operator < (FSafeVector3D &FSV, const FVector &V) {
	return ((FSV.GetValue().X<V.X)&&(FSV.GetValue().Y<V.Y)&&(FSV.GetValue().Z<V.Z));
}

FORCEINLINE bool operator >= (FSafeVector3D &FSV, const FVector &V) {
	return ((FSV.GetValue().X>=V.X)&&(FSV.GetValue().Y>=V.Y)&&(FSV.GetValue().Z>=V.Z));
}

FORCEINLINE bool operator <= (FSafeVector3D &FSV, const FVector &V) {
	return ((FSV.GetValue().X<=V.X)&&(FSV.GetValue().Y<=V.Y)&&(FSV.GetValue().Z<=V.Z));
}

FORCEINLINE FSafeVector3D operator + (FSafeVector3D &FSV, const FVector &V) {
	return FSafeVector3D(FSV.GetValue()+V);
}

FORCEINLINE FSafeVector3D operator - (FSafeVector3D &FSV, const FVector &V) {
	return FSafeVector3D(FSV.GetValue()-V);
}

FORCEINLINE FSafeVector3D operator * (FSafeVector3D &FSV, const FVector &V) {
	return FSafeVector3D(FSV.GetValue()*V);
}

FORCEINLINE FSafeVector3D operator / (FSafeVector3D &FSV, const FVector &V) {
	return FSafeVector3D(FSV.GetValue()/V);
}

FORCEINLINE FSafeVector3D operator % (FSafeVector3D &FSV, const FVector &V) {
	auto Local = FSV.GetValue();
	auto X = Local.X; auto Y = Local.Y; auto Z = Local.Z;
	auto MX = V.X; auto MY = V.Y; auto MZ = V.Z;
	return FSafeVector3D(FVector(FGenericPlatformMath::Fmod(X,MX),FGenericPlatformMath::Fmod(Y,MY),FGenericPlatformMath::Fmod(Z,MZ)));
}

/* FSafe -> Native */

FORCEINLINE bool operator == (const FVector &V, FSafeVector3D &FSV) {
	return (V==FSV.GetValue());
}

FORCEINLINE bool operator != (const FVector &V, FSafeVector3D &FSV) {
	return (V!=FSV.GetValue());
}

FORCEINLINE bool operator > (const FVector &V, FSafeVector3D &FSV) {
	return ((V.X>FSV.GetValue().X)&&(V.Y>FSV.GetValue().Y)&&(V.Z>FSV.GetValue().Z));
}

FORCEINLINE bool operator < (const FVector &V, FSafeVector3D &FSV) {
	return ((V.X<FSV.GetValue().X)&&(V.Y<FSV.GetValue().Y)&&(V.Z<FSV.GetValue().Z));
}

FORCEINLINE bool operator >= (const FVector &V, FSafeVector3D &FSV) {
	return ((V.X>=FSV.GetValue().X)&&(V.Y>=FSV.GetValue().Y)&&(V.Z>=FSV.GetValue().Z));
}

FORCEINLINE bool operator <= (const FVector &V, FSafeVector3D &FSV) {
	return ((V.X<=FSV.GetValue().X)&&(V.Y<=FSV.GetValue().Y)&&(V.Z<=FSV.GetValue().Z));
}

FORCEINLINE FVector operator + (const FVector &V, FSafeVector3D &FSV) {
	return (V+FSV.GetValue());
}

FORCEINLINE FVector operator - (const FVector &V, FSafeVector3D &FSV) {
	return (V-FSV.GetValue());
}

FORCEINLINE FVector operator * (const FVector &V, FSafeVector3D &FSV) {
	return (V*FSV.GetValue());
}

FORCEINLINE FVector operator / (const FVector &V, FSafeVector3D &FSV) {
	return (V/FSV.GetValue());
}

FORCEINLINE FVector operator % (const FVector &V, FSafeVector3D &FSV) {
	auto Local = FSV.GetValue();
	auto X = V.X; auto Y = V.Y; auto Z = V.Z;
	auto MX = Local.X; auto MY = Local.Y; auto MZ = Local.Z;
	return FVector(FGenericPlatformMath::Fmod(X,MX),FGenericPlatformMath::Fmod(Y,MY),FGenericPlatformMath::Fmod(Z,MZ));
}

// FSVector4D

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeVector4D &FSV, FSafeVector4D &V) {
	return (FSV.GetValue()==V.GetValue());
}

FORCEINLINE bool operator != (FSafeVector4D &FSV, FSafeVector4D &V) {
	return (FSV.GetValue()!=V.GetValue());
}

FORCEINLINE bool operator > (FSafeVector4D &FSV, FSafeVector4D &V) {
	return ((FSV.GetValue().X>V.GetValue().X)&&(FSV.GetValue().Y>V.GetValue().Y)&&(FSV.GetValue().Z>V.GetValue().Z)&&(FSV.GetValue().W>V.GetValue().W));
}

FORCEINLINE bool operator < (FSafeVector4D &FSV, FSafeVector4D &V) {
	return ((FSV.GetValue().X<V.GetValue().X)&&(FSV.GetValue().Y<V.GetValue().Y)&&(FSV.GetValue().Z<V.GetValue().Z)&&(FSV.GetValue().W<V.GetValue().W));
}

FORCEINLINE bool operator >= (FSafeVector4D &FSV, FSafeVector4D &V) {
	return ((FSV.GetValue().X>=V.GetValue().X)&&(FSV.GetValue().Y>=V.GetValue().Y)&&(FSV.GetValue().Z>=V.GetValue().Z)&&(FSV.GetValue().W>=V.GetValue().W));
}

FORCEINLINE bool operator <= (FSafeVector4D &FSV, FSafeVector4D &V) {
	return ((FSV.GetValue().X<=V.GetValue().X)&&(FSV.GetValue().Y<=V.GetValue().Y)&&(FSV.GetValue().Z<=V.GetValue().Z)&&(FSV.GetValue().W<=V.GetValue().W));
}

FORCEINLINE FSafeVector4D operator + (FSafeVector4D &FSV, FSafeVector4D &V) {
	auto Local = (FSV.GetValue()+V.GetValue());
	return FSafeVector4D(Local.X,Local.Y,Local.Z,Local.W);
}

FORCEINLINE FSafeVector4D operator - (FSafeVector4D &FSV, FSafeVector4D &V) {
	auto Local = (FSV.GetValue()-V.GetValue());
	return FSafeVector4D(Local.X,Local.Y,Local.Z,Local.W);
}

FORCEINLINE FSafeVector4D operator * (FSafeVector4D &FSV, FSafeVector4D &V) {
	auto Local = (FSV.GetValue()*V.GetValue());
	return FSafeVector4D(Local.X,Local.Y,Local.Z,Local.W);
}

FORCEINLINE FSafeVector4D operator / (FSafeVector4D &FSV, FSafeVector4D &V) {
	auto Local = (FSV.GetValue()/V.GetValue());
	return FSafeVector4D(Local.X,Local.Y,Local.Z,Local.W);
}

FORCEINLINE FSafeVector4D operator % (FSafeVector4D &FSV, FSafeVector4D &V) {
	auto Local = FSV.GetValue(); auto Mod = V.GetValue();
	auto X = Local.X; auto Y = Local.Y; auto Z = Local.Z; auto W = Local.W;
	auto MX = Mod.X; auto MY = Mod.Y;  auto MZ = Mod.Z; auto MW = Mod.W;
	auto F4D = FVector4(FGenericPlatformMath::Fmod(X,MX),FGenericPlatformMath::Fmod(Y,MY),FGenericPlatformMath::Fmod(Z,MZ),FGenericPlatformMath::Fmod(W,MW));
	return FSafeVector4D(F4D.X,F4D.Y,F4D.Z,F4D.W);
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeVector4D &FSV, const FVector4 &V) {
	return (FSV.GetValue()==V);
}

FORCEINLINE bool operator != (FSafeVector4D &FSV, const FVector4 &V) {
	return (FSV.GetValue()!=V);
}

FORCEINLINE bool operator > (FSafeVector4D &FSV, const FVector4 &V) {
	return ((FSV.GetValue().X>V.X)&&(FSV.GetValue().Y>V.Y)&&(FSV.GetValue().Z>V.Z)&&(FSV.GetValue().W>V.W));
}

FORCEINLINE bool operator < (FSafeVector4D &FSV, const FVector4 &V) {
	return ((FSV.GetValue().X<V.X)&&(FSV.GetValue().Y<V.Y)&&(FSV.GetValue().Z<V.Z)&&(FSV.GetValue().W>V.W));
}

FORCEINLINE bool operator >= (FSafeVector4D &FSV, const FVector4 &V) {
	return ((FSV.GetValue().X>=V.X)&&(FSV.GetValue().Y>=V.Y)&&(FSV.GetValue().Z>=V.Z));
}

FORCEINLINE bool operator <= (FSafeVector4D &FSV, const FVector4 &V) {
	return ((FSV.GetValue().X<=V.X)&&(FSV.GetValue().Y<=V.Y)&&(FSV.GetValue().Z<=V.Z));
}

FORCEINLINE FSafeVector4D operator + (FSafeVector4D &FSV, const FVector4 &V) {
	auto Local = (FSV.GetValue()+V);
	return FSafeVector4D(Local.X,Local.Y,Local.Z,Local.W);
}

FORCEINLINE FSafeVector4D operator - (FSafeVector4D &FSV, const FVector4 &V) {
	auto Local = (FSV.GetValue()-V);
	return FSafeVector4D(Local.X,Local.Y,Local.Z,Local.W);
}

FORCEINLINE FSafeVector4D operator * (FSafeVector4D &FSV, const FVector4 &V) {
	auto Local = (FSV.GetValue()*V);
	return FSafeVector4D(Local.X,Local.Y,Local.Z,Local.W);
}

FORCEINLINE FSafeVector4D operator / (FSafeVector4D &FSV, const FVector4 &V) {
	auto Local = (FSV.GetValue()/V);
	return FSafeVector4D(Local.X,Local.Y,Local.Z,Local.W);
}

FORCEINLINE FSafeVector4D operator % (FSafeVector4D &FSV, const FVector4 &V) {
	auto Local = FSV.GetValue();
	auto MX = V.X; auto MY = V.Y;  auto MZ = V.Z; auto MW = V.W;
	auto X = Local.X; auto Y = Local.Y; auto Z = Local.Z; auto W = Local.W;
	auto F4D = FVector4(FGenericPlatformMath::Fmod(X,MX),FGenericPlatformMath::Fmod(Y,MY),FGenericPlatformMath::Fmod(Z,MZ),FGenericPlatformMath::Fmod(W,MW));
	return FSafeVector4D(F4D.X,F4D.Y,F4D.Z,F4D.W);
}

/* FSafe -> Native */

FORCEINLINE bool operator == (const FVector4 &V, FSafeVector4D &FSV) {
	return (V==FSV.GetValue());
}

FORCEINLINE bool operator != (const FVector4 &V, FSafeVector4D &FSV) {
	return (V!=FSV.GetValue());
}

FORCEINLINE bool operator > (const FVector4 &V, FSafeVector4D &FSV) {
	return ((V.X>FSV.GetValue().X)&&(V.Y>FSV.GetValue().Y)&&(V.Z>FSV.GetValue().Z)&&(V.W>FSV.GetValue().W));
}

FORCEINLINE bool operator < (const FVector4 &V, FSafeVector4D &FSV) {
	return ((V.X<FSV.GetValue().X)&&(V.Y<FSV.GetValue().Y)&&(V.Z<FSV.GetValue().Z)&&(V.W<FSV.GetValue().W));
}

FORCEINLINE bool operator >= (const FVector4 &V, FSafeVector4D &FSV) {
	return ((V.X>=FSV.GetValue().X)&&(V.Y>=FSV.GetValue().Y)&&(V.Z>=FSV.GetValue().Z)&&(V.W>=FSV.GetValue().W));
}

FORCEINLINE bool operator <= (const FVector4 &V, FSafeVector4D &FSV) {
	return ((V.X<=FSV.GetValue().X)&&(V.Y<=FSV.GetValue().Y)&&(V.Z<=FSV.GetValue().Z)&&(V.W<=FSV.GetValue().W));
}

FORCEINLINE FVector4 operator + (const FVector4 &V, FSafeVector4D &FSV) {
	return (V+FSV.GetValue());
}

FORCEINLINE FVector4 operator - (const FVector4 &V, FSafeVector4D &FSV) {
	return (V-FSV.GetValue());
}

FORCEINLINE FVector4 operator * (const FVector4 &V, FSafeVector4D &FSV) {
	return (V*FSV.GetValue());
}

FORCEINLINE FVector4 operator / (const FVector4 &V, FSafeVector4D &FSV) {
	return (V/FSV.GetValue());
}

FORCEINLINE FVector4 operator % (const FVector4 &V, FSafeVector4D &FSV) {
	auto Local = FSV.GetValue();
	auto X = V.X; auto Y = V.Y; auto Z = V.Z; auto W = V.W;
	auto MX = Local.X; auto MY = Local.Y; auto MZ = Local.Z; auto MW = Local.W;
	return FVector4(FGenericPlatformMath::Fmod(X,MX),FGenericPlatformMath::Fmod(Y,MY),FGenericPlatformMath::Fmod(Z,MZ),FGenericPlatformMath::Fmod(W,MW));
}

// FSColor

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeColor &FSC, FSafeColor &C) {
	return (FSC.GetValue()==C.GetValue());
}

FORCEINLINE bool operator != (FSafeColor &FSC, FSafeColor &C) {
	return (FSC.GetValue()!=C.GetValue());
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeColor &FSC, const FLinearColor &C) {
	return (FSC.GetValue()==C);
}

FORCEINLINE bool operator != (FSafeColor &FSC, const FLinearColor &C) {
	return (FSC.GetValue()!=C);
}

/* FSafe -> Native */

FORCEINLINE bool operator == (const FLinearColor &C, FSafeColor &FSC) {
	return (C==FSC.GetValue());
}

FORCEINLINE bool operator != (const FLinearColor &C, FSafeColor &FSC) {
	return (C!=FSC.GetValue());
}

// FSRotator

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeRotator &FSR, FSafeRotator &R) {
	return (FSR.GetValue()==R.GetValue());
}

FORCEINLINE bool operator != (FSafeRotator &FSR, FSafeRotator &R) {
	return (FSR.GetValue()!=R.GetValue());
}

FORCEINLINE bool operator > (FSafeRotator &FSR, FSafeRotator &R) {
	return ((FSR.GetValue().Pitch>R.GetValue().Pitch)&&(FSR.GetValue().Yaw>R.GetValue().Yaw)&&(FSR.GetValue().Roll>R.GetValue().Roll));
}

FORCEINLINE bool operator < (FSafeRotator &FSR, FSafeRotator &R) {
	return ((FSR.GetValue().Pitch<R.GetValue().Pitch)&&(FSR.GetValue().Yaw<R.GetValue().Yaw)&&(FSR.GetValue().Roll<R.GetValue().Roll));
}

FORCEINLINE bool operator >= (FSafeRotator &FSR, FSafeRotator &R) {
	return ((FSR.GetValue().Pitch>=R.GetValue().Pitch)&&(FSR.GetValue().Yaw>=R.GetValue().Yaw)&&(FSR.GetValue().Roll>=R.GetValue().Roll));
}

FORCEINLINE bool operator <= (FSafeRotator &FSR, FSafeRotator &R) {
	return ((FSR.GetValue().Pitch<=R.GetValue().Pitch)&&(FSR.GetValue().Yaw<=R.GetValue().Yaw)&&(FSR.GetValue().Roll<=R.GetValue().Roll));
}

FORCEINLINE FSafeRotator operator + (FSafeRotator &FSR, FSafeRotator &R) {
	return FSafeRotator(FSR.GetValue()+R.GetValue());
}

FORCEINLINE FSafeRotator operator - (FSafeRotator &FSR, FSafeRotator &R) {
	return FSafeRotator(FSR.GetValue()-R.GetValue());
}

FORCEINLINE FSafeRotator operator * (FSafeRotator &FSR, FSafeRotator &R) {
	auto A = FSR.GetValue(); auto B = R.GetValue();
	auto Rotator = FRotator(A.Pitch*B.Pitch,A.Yaw*B.Yaw,A.Roll*B.Roll);
	return FSafeRotator(Rotator);
}

FORCEINLINE FSafeRotator operator / (FSafeRotator &FSR, FSafeRotator &R) {
	auto A = FSR.GetValue(); auto B = R.GetValue();
	auto Rotator = FRotator(A.Pitch/B.Pitch,A.Yaw/B.Yaw,A.Roll/B.Roll);
	return FSafeRotator(Rotator);
}

FORCEINLINE FSafeRotator operator % (FSafeRotator &FSR, FSafeRotator &R) {
	auto Local = FSR.GetValue(); auto Mod = R.GetValue();
	auto X = Local.Pitch; auto Y = Local.Yaw; auto Z = Local.Roll;
	auto MX = Mod.Pitch; auto MY = Mod.Yaw;  auto MZ = Mod.Roll;
	return FSafeRotator(FRotator(FGenericPlatformMath::Fmod(X,MX),FGenericPlatformMath::Fmod(Y,MY),FGenericPlatformMath::Fmod(Z,MZ)));
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeRotator &FSR, const FRotator &R) {
	return (FSR.GetValue()==R);
}

FORCEINLINE bool operator != (FSafeRotator &FSR, const FRotator &R) {
	return (FSR.GetValue()!=R);
}

FORCEINLINE bool operator > (FSafeRotator &FSR, const FRotator &R) {
	return ((FSR.GetValue().Pitch>R.Pitch)&&(FSR.GetValue().Yaw>R.Yaw)&&(FSR.GetValue().Roll>R.Roll));
}

FORCEINLINE bool operator < (FSafeRotator &FSR, const FRotator &R) {
	return ((FSR.GetValue().Pitch<R.Pitch)&&(FSR.GetValue().Yaw<R.Yaw)&&(FSR.GetValue().Roll<R.Roll));
}

FORCEINLINE bool operator >= (FSafeRotator &FSR, const FRotator &R) {
	return ((FSR.GetValue().Pitch>=R.Pitch)&&(FSR.GetValue().Yaw>=R.Yaw)&&(FSR.GetValue().Roll>=R.Roll));
}

FORCEINLINE bool operator <= (FSafeRotator &FSR, const FRotator &R) {
	return ((FSR.GetValue().Pitch<=R.Pitch)&&(FSR.GetValue().Yaw<=R.Yaw)&&(FSR.GetValue().Roll<=R.Roll));
}

FORCEINLINE FSafeRotator operator + (FSafeRotator &FSR, const FRotator &R) {
	return FSafeRotator(FSR.GetValue()+R);
}

FORCEINLINE FSafeRotator operator - (FSafeRotator &FSR, const FRotator &R) {
	return FSafeRotator(FSR.GetValue()-R);
}

FORCEINLINE FSafeRotator operator * (FSafeRotator &FSR, const FRotator &R) {
	auto Local = FSR.GetValue();
	auto Rotator = FRotator(Local.Pitch*R.Pitch,Local.Yaw*R.Yaw,Local.Roll*R.Roll);
	return FSafeRotator(Rotator);
}

FORCEINLINE FSafeRotator operator / (FSafeRotator &FSR, const FRotator &R) {
	auto Local = FSR.GetValue();
	auto Rotator = FRotator(Local.Pitch/R.Pitch,Local.Yaw/R.Yaw,Local.Roll/R.Roll);
	return FSafeRotator(Rotator);
}

FORCEINLINE FSafeRotator operator % (FSafeRotator &FSR, const FRotator &R) {
	auto Local = FSR.GetValue();
	auto X = Local.Pitch; auto Y = Local.Yaw; auto Z = Local.Roll;
	auto MX = R.Pitch; auto MY = R.Yaw; auto MZ = R.Roll;
	return FSafeRotator(FRotator(FGenericPlatformMath::Fmod(X,MX),FGenericPlatformMath::Fmod(Y,MY),FGenericPlatformMath::Fmod(Z,MZ)));
}

/* FSafe -> Native */

FORCEINLINE bool operator == (const FRotator &R, FSafeRotator &FSR) {
	return (R==FSR.GetValue());
}

FORCEINLINE bool operator != (const FRotator &R, FSafeRotator &FSR) {
	return (R!=FSR.GetValue());
}

FORCEINLINE bool operator > (const FRotator &R, FSafeRotator &FSR) {
	return ((R.Pitch>FSR.GetValue().Pitch)&&(R.Yaw>FSR.GetValue().Yaw)&&(R.Roll>FSR.GetValue().Roll));
}

FORCEINLINE bool operator < (const FRotator &R, FSafeRotator &FSR) {
	return ((R.Pitch<FSR.GetValue().Pitch)&&(R.Yaw<FSR.GetValue().Yaw)&&(R.Roll<FSR.GetValue().Roll));
}

FORCEINLINE bool operator >= (const FRotator &R, FSafeRotator &FSR) {
	return ((R.Pitch>=FSR.GetValue().Pitch)&&(R.Yaw>=FSR.GetValue().Yaw)&&(R.Roll>=FSR.GetValue().Roll));
}

FORCEINLINE bool operator <= (const FRotator &R, FSafeRotator &FSR) {
	return ((R.Pitch<=FSR.GetValue().Pitch)&&(R.Yaw<=FSR.GetValue().Yaw)&&(R.Roll<=FSR.GetValue().Roll));
}

FORCEINLINE FRotator operator + (const FRotator &R, FSafeRotator &FSR) {
	return (R+FSR.GetValue());
}

FORCEINLINE FRotator operator - (const FRotator &R, FSafeRotator &FSR) {
	return (R-FSR.GetValue());
}

FORCEINLINE FRotator operator * (const FRotator &R, FSafeRotator &FSR) {
	auto Local = FSR.GetValue();
	return FRotator(R.Pitch*Local.Pitch,R.Yaw*Local.Yaw,R.Roll*Local.Roll);
}

FORCEINLINE FRotator operator / (const FRotator &R, FSafeRotator &FSR) {
	auto Local = FSR.GetValue();
	return FRotator(R.Pitch/Local.Pitch,R.Yaw/Local.Yaw,R.Roll/Local.Roll);
}

FORCEINLINE FRotator operator % (const FRotator &R, FSafeRotator &FSR) {
	auto Local = FSR.GetValue();
	auto X = R.Pitch; auto Y = R.Yaw; auto Z = R.Roll;
	auto MX = Local.Pitch; auto MY = Local.Yaw; auto MZ = Local.Roll;
	return FRotator(FGenericPlatformMath::Fmod(X,MX),FGenericPlatformMath::Fmod(Y,MY),FGenericPlatformMath::Fmod(Z,MZ));
}

// FSTransform

/* FSafe -> FSafe */

FORCEINLINE bool operator == (FSafeTransform &FST, FSafeTransform &T) {
	auto Local = FST.GetValue(); auto To = T.GetValue();
	return ((Local.GetLocation()==To.GetLocation())&&(Local.GetRotation()==To.GetRotation())&&(Local.GetScale3D()==To.GetScale3D()));
}

FORCEINLINE bool operator != (FSafeTransform &FST, FSafeTransform &T) {
	auto Local = FST.GetValue(); auto To = T.GetValue();
	return ((Local.GetLocation()!=To.GetLocation())&&(Local.GetRotation()!=To.GetRotation())&&(Local.GetScale3D()!=To.GetScale3D()));
}

/* Native -> FSafe */

FORCEINLINE bool operator == (FSafeTransform &FST, const FTransform &T) {
	auto Local = FST.GetValue();
	return ((Local.GetLocation()==T.GetLocation())&&(Local.GetRotation()==T.GetRotation())&&(Local.GetScale3D()==T.GetScale3D()));
}

FORCEINLINE bool operator != (FSafeTransform &FST, const FTransform &T) {
	auto Local = FST.GetValue();
	return ((Local.GetLocation()!=T.GetLocation())&&(Local.GetRotation()!=T.GetRotation())&&(Local.GetScale3D()!=T.GetScale3D()));
}

/* FSafe -> Native */

FORCEINLINE bool operator == (const FTransform &T, FSafeTransform &FST) {
	auto Local = FST.GetValue();
	return ((T.GetLocation()==Local.GetLocation())&&(T.GetRotation()==Local.GetRotation())&&(T.GetScale3D()==Local.GetScale3D()));
}

FORCEINLINE bool operator != (const FTransform &T, FSafeTransform &FST) {
	auto Local = FST.GetValue();
	return ((T.GetLocation()!=Local.GetLocation())&&(T.GetRotation()!=Local.GetRotation())&&(T.GetScale3D()!=Local.GetScale3D()));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Game Instance:: Runs anti-cheat, anti-debugging methods

/// Safe Game Instance; Secure-Client is a C++ Plugin designed to provide anti-cheat capability to your games.
/// Other custom Game Instance classes, when used, should have this class as a parent for effective use.
UCLASS(ClassGroup = Security, Category = "Security", Blueprintable, hideCategories = (Activation), meta = (DisplayName = "{S} Safe Game Instance", ShortTooltip = "{S} Safe Game Instance Class. Check documentation for more information."))
class SCUE4_API USafeGameInstance : public UGameInstance {
	GENERATED_BODY()
};

/// Moving SCUE4 logic from Game Instance to a Subsystem, for better compatibility:
UCLASS(ClassGroup = Security, Category = "Security", Blueprintable, hideCategories = (Activation))
class SCUE4_API USafeGameInstanceSubsystem : public UGameInstanceSubsystem {
	GENERATED_BODY()
protected:
	FProcHandle GuardProcess;
	const TCHAR* Editor = TEXT("EDITOR");
	const TCHAR* Guardx86 = TEXT("SCUE4x86.exe");
	const TCHAR* Guardx64 = TEXT("SCUE4x64.exe");
	const TCHAR* Game = FApp::GetProjectName();
	//
	FTimerHandle THInvokeGuard;
	FTimerHandle THScanner;
	uint32 GuardPID = 0;
public:
	virtual void Initialize(FSubsystemCollectionBase &Collection) override;
	virtual void Deinitialize() override;
public:
	/* Sets visibility of Game-Guard console window.
	Console is only visible in Editor Mode, on packaged games it's always hidden. */
	UPROPERTY(Category = "Security", EditAnywhere, meta = (AllowPrivateAccess = "true"))
	bool HideGameGuard = true;
	//
	/* To increase defenses against memory readers, uncheck this option when you're ready to
	ship final standalone game build. If disabled, option won't allow Debuggers attach to the game process. */
	UPROPERTY(Category = "Security", EditAnywhere, meta = (AllowPrivateAccess = "true"))
	bool AllowDebugging = true;
	//
	/** Interval, in seconds, for Internal Process Scanner to be automatically invoked. */
	UPROPERTY(Category = "Security", EditAnywhere, meta = (AllowPrivateAccess = "true", ClampMin = "10", ClampMax = "1000", UIMin = "10", UIMax = "1000"))
	uint32 ScannerInterval = 30.f;
	//
	/* Sets visibility of Game-Guard console window.
	Console is only visible in Editor Mode, on packaged games it's always hidden. */
	UFUNCTION(Category = "Security", BlueprintCallable, meta = (DisplayName = "{S}:: Hide Game-Guard Console", Keywords = "Security Guard"))
	void HideGameGuardConsole(bool Set);
public:
	void InvokeGuard() {
	#if PLATFORM_WINDOWS
		#if WITH_EDITOR
		GuardProcess = FPlatformProcess::CreateProc(*FPaths::Combine(*FPaths::EnginePluginsDir(),TEXT("Marketplace/SCUE4/Source/ThirdParty/x64"),Guardx64),Editor,false,HideGameGuard,HideGameGuard,&GuardPID,0,nullptr,nullptr);
		//GuardProcess = FPlatformProcess::CreateProc(*FPaths::Combine(*FPaths::ProjectPluginsDir(),TEXT("SCUE4/Source/ThirdParty/x64"),Guardx64),Editor,false,HideGameGuard,HideGameGuard,&GuardPID,0,nullptr,nullptr);
		#else
			#if !PLATFORM_64BITS
			//if (!FPaths::FileExists(FPaths::Combine(*FPaths::EnginePluginsDir(),TEXT("Marketplace/SCUE4/Source/ThirdParty/x86/"),Guardx86))) {FGenericPlatformMisc::RequestExit(false);}
			//GuardProcess = FPlatformProcess::CreateProc(*FPaths::Combine(*FPaths::EnginePluginsDir(),TEXT("Marketplace/SCUE4/Source/ThirdParty/x86/"),Guardx86),Game,false,true,true,&GuardPID,0,nullptr,nullptr);
			if (!FPaths::FileExists(FPaths::Combine(*FPaths::ProjectPluginsDir(),TEXT("SCUE4/Source/ThirdParty/x86/"),Guardx86))) {FGenericPlatformMisc::RequestExit(false);}
			GuardProcess = FPlatformProcess::CreateProc(*FPaths::Combine(*FPaths::ProjectPluginsDir(),TEXT("SCUE4/Source/ThirdParty/x86/"),Guardx86),Game,false,true,true,&GuardPID,0,nullptr,nullptr);
			#else
			//if (!FPaths::FileExists(FPaths::Combine(*FPaths::EnginePluginsDir(),TEXT("Marketplace/SCUE4/Source/ThirdParty/x64/"),Guardx64))) {FGenericPlatformMisc::RequestExit(false);}
			//GuardProcess = FPlatformProcess::CreateProc(*FPaths::Combine(*FPaths::EnginePluginsDir(),TEXT("Marketplace/SCUE4/Source/ThirdParty/x64/"),Guardx64),Game,false,true,true,&GuardPID,0,nullptr,nullptr);
			if (!FPaths::FileExists(FPaths::Combine(*FPaths::ProjectPluginsDir(),TEXT("SCUE4/Source/ThirdParty/x64/"),Guardx64))) {FGenericPlatformMisc::RequestExit(false);}
			GuardProcess = FPlatformProcess::CreateProc(*FPaths::Combine(*FPaths::ProjectPluginsDir(),TEXT("SCUE4/Source/ThirdParty/x64/"),Guardx64),Game,false,true,true,&GuardPID,0,nullptr,nullptr);
			#endif
		#endif
	#endif
	}
	//
	void GameGuard() {
	#if PLATFORM_WINDOWS && UE_BUILD_SHIPPING
		if (!GuardProcess.IsValid() || !FPlatformProcess::IsProcRunning(GuardProcess)) {InvokeGuard();}
		if (!AllowDebugging) {if (IsDebuggerPresent() || HasDebugger() || HasThreat()) {FGenericPlatformMisc::RequestExit(false);}}
	#endif
	}
	//
	bool IsDebuggerPresent() {
	#if PLATFORM_WINDOWS && UE_BUILD_SHIPPING
		HINSTANCE Kernel = LoadLibraryEx(TEXT("kernel32.dll"),NULL,0);
		FARPROC IDebuggerPresent = GetProcAddress(Kernel,"IsDebuggerPresent");
		if(IDebuggerPresent && IDebuggerPresent()) {FreeLibrary(Kernel); return true;}
		FreeLibrary(Kernel); return false;
	#else
		return false;
	#endif
	}
	//
	FORCEINLINE bool HasDebugger() {
	#if PLATFORM_WINDOWS
		#if UE_BUILD_SHIPPING && PLATFORM_32BITS
			__try {
				__asm __emit 0xF3
				__asm __emit 0x64
				__asm __emit 0xF1
			} __except(EXCEPTION_EXECUTE_HANDLER) {
				return false;
			} return true;
		#else
			return false;
		#endif
	#else
		return false;
	#endif
	}
	//
	FORCEINLINE bool HasThreat() {
	#if PLATFORM_WINDOWS
		#if !WITH_EDITOR
		if (OpenFileMapping(FILE_MAP_READ|FILE_MAP_WRITE,false,L"CEHYPERSCANSETTINGS")!=0) {return true;}
		auto HND = FindWindowA((LPCSTR)"WinDbgFrameClass",NULL); if (HND) {return true;}
		HND = FindWindowA((LPCSTR)"WinDbgFrameClass",NULL); if (HND) {return true;}
		HND = FindWindowA((LPCSTR)"OLLYDBG",NULL); if (HND) {return true;}
		HND = FindWindowA((LPCSTR)"Window",NULL); if (HND) {return true;}
		return false;
		#endif
		return false;
	#else
		return false;
	#endif
	}
	//
	void ScanProcesses() {
	#if PLATFORM_WINDOWS
		#if UE_BUILD_SHIPPING && !WITH_SERVER_CODE
		FSCUE4_Enumerate();
		#endif
	#endif
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/SCUE4/SCUE4.Build.cs`:

```cs
using UnrealBuildTool;
using System.IO;

public class SCUE4 : ModuleRules {
	public SCUE4(ReadOnlyTargetRules Target) : base(Target) {
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
		PrivatePCHHeaderFile = "Private/SCUE4PrivatePCH.h";
		bEnforceIWYU = true;
		//
		PublicDependencyModuleNames.AddRange(
			new string[] {
				"Core",
				"Engine",
				"SCUE4X",
				"Projects",
				"CoreUObject"
			}///
		);//
		//
		PublicDefinitions.Add("WITH_ANTI_CHEAT");
		PublicIncludePaths.Add(Path.Combine(ModuleDirectory,"Public"));
		PrivateIncludePaths.Add(Path.Combine(ModuleDirectory,"Private"));
	}///
}
```

`Plugins/SCUE4/Source/Settings/Private/SCUE4Commands.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//			Copyright 2016 (C) Bruno Xavier Leite
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "SCUE4EditorPrivatePCH.h"
#include "SCUE4EditorCommands.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define LOCTEXT_NAMESPACE "FSCUE4Editor"

void FSCUE4EditorCommands::RegisterCommands()
{
	UI_COMMAND(PluginAction, "Key Generator", "[Anti-Cheat] Keys Generator", EUserInterfaceActionType::Button, FInputGesture());
}

#undef LOCTEXT_NAMESPACE

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/Settings/Private/SCUE4Editor.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//			Copyright 2016 (C) Bruno Xavier Leite
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "SCUE4Editor.h"
#include "SCUE4EditorCommands.h"
#include "SCUE4EditorStyle.h"

#include "SCUE4.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define LOCTEXT_NAMESPACE "FSCUE4Editor"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static const FName SCUE4EditorTabName("SCUE4Editor");

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void FSCUE4Editor::StartupModule() {
	FSCUE4EditorStyle::Initialize();
	FSCUE4EditorStyle::ReloadTextures();
	FSCUE4EditorCommands::Register();
	//
	PluginCommands = MakeShareable(new FUICommandList);
	PluginCommands->MapAction(FSCUE4EditorCommands::Get().PluginAction,FExecuteAction::CreateRaw(this, &FSCUE4Editor::PluginButtonClicked),FCanExecuteAction());
	//
	FLevelEditorModule &LevelEditorModule = FModuleManager::LoadModuleChecked<FLevelEditorModule>("LevelEditor");
	//
	{
		TSharedPtr<FExtender> MenuExtender = MakeShareable(new FExtender());
		MenuExtender->AddMenuExtension("WindowLayout",EExtensionHook::After,PluginCommands,FMenuExtensionDelegate::CreateRaw(this,&FSCUE4Editor::AddMenuExtension));
		LevelEditorModule.GetMenuExtensibilityManager()->AddExtender(MenuExtender);
	}	
	{
		TSharedPtr<FExtender> ToolbarExtender = MakeShareable(new FExtender);
		ToolbarExtender->AddToolBarExtension("Settings",EExtensionHook::After,PluginCommands,FToolBarExtensionDelegate::CreateRaw(this,&FSCUE4Editor::AddToolbarExtension));
		LevelEditorModule.GetToolBarExtensibilityManager()->AddExtender(ToolbarExtender);
	}
	//
	{
		FPropertyEditorModule &PropertyEditorModule = FModuleManager::LoadModuleChecked<FPropertyEditorModule>("PropertyEditor");
		PropertyEditorModule.RegisterCustomPropertyTypeLayout("SafeBool",FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FSBool_CustomDetails::MakeInstance));
		PropertyEditorModule.RegisterCustomPropertyTypeLayout("SafeByte",FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FSByte_CustomDetails::MakeInstance));
		PropertyEditorModule.RegisterCustomPropertyTypeLayout("SafeInt",FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FSInt_CustomDetails::MakeInstance));
		PropertyEditorModule.RegisterCustomPropertyTypeLayout("SafeFloat",FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FSFloat_CustomDetails::MakeInstance));
		PropertyEditorModule.RegisterCustomPropertyTypeLayout("SafeName",FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FSName_CustomDetails::MakeInstance));
		PropertyEditorModule.RegisterCustomPropertyTypeLayout("SafeString",FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FSString_CustomDetails::MakeInstance));
		PropertyEditorModule.RegisterCustomPropertyTypeLayout("SafeText",FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FSText_CustomDetails::MakeInstance));
		PropertyEditorModule.RegisterCustomPropertyTypeLayout("SafeVector2D",FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FSV2D_CustomDetails::MakeInstance));
		PropertyEditorModule.RegisterCustomPropertyTypeLayout("SafeVector3D",FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FSV3D_CustomDetails::MakeInstance));
		PropertyEditorModule.RegisterCustomPropertyTypeLayout("SafeVector4D",FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FSV4D_CustomDetails::MakeInstance));
		PropertyEditorModule.RegisterCustomPropertyTypeLayout("SafeColor",FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FSColor_CustomDetails::MakeInstance));
		PropertyEditorModule.RegisterCustomPropertyTypeLayout("SafeRotator",FOnGetPropertyTypeCustomizationInstance::CreateStatic(&FSRotator_CustomDetails::MakeInstance));
	}
}

void FSCUE4Editor::ShutdownModule() {
	FSCUE4EditorStyle::Shutdown();
	FSCUE4EditorCommands::Unregister();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void FSCUE4Editor::AddMenuExtension(FMenuBuilder &Builder) {
	Builder.AddMenuEntry(FSCUE4EditorCommands::Get().PluginAction);
}

void FSCUE4Editor::AddToolbarExtension(FToolBarBuilder &Builder) {
	Builder.AddToolBarButton(FSCUE4EditorCommands::Get().PluginAction);
}

void FSCUE4Editor::PluginButtonClicked() {
	const auto &Settings = GetMutableDefault<USCUE4Settings>();
	//
	if (Settings && FPaths::FileExists(Settings->KeyGeneratorPath)) {
		FPlatformProcess::CreateProc(*Settings->KeyGeneratorPath,nullptr,true,false,false,nullptr,0,nullptr,nullptr,nullptr);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeBool

TSharedRef<IPropertyTypeCustomization> FSBool_CustomDetails::MakeInstance() {
	return MakeShareable(new FSBool_CustomDetails());
}

void FSBool_CustomDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {
	uint32 C; StructPropertyHandle->GetNumChildren(C); if (C<3) {return;}
	Keys = StructPropertyHandle->GetChildHandle(0).ToSharedRef();
	Real = StructPropertyHandle->GetChildHandle(1).ToSharedRef();
	Flip = StructPropertyHandle->GetChildHandle(2).ToSharedRef();
	if (!Keys->IsValidHandle()||!Real->IsValidHandle()||!Flip->IsValidHandle()) {return;}
	//
	//
	HeaderRow
	.NameContent()
	[
		SNew(SHorizontalBox)
		.ToolTipText(LOCTEXT("FSBoolTooltip","Safe Bool"))
		+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(0,0,5,0)
			[
				SNew(SImage)
				.Image(FSCUE4EditorStyle::Get().GetBrush("ClassIcon.SafeBool"))
			]
		+ SHorizontalBox::Slot()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
			.Font(IDetailLayoutBuilder::GetDetailFont())
			.Text(StructPropertyHandle->GetPropertyDisplayName())
		]
	]
	.ValueContent()
	.MinDesiredWidth(150)
	.MaxDesiredWidth(400)
	[
		SNew(SCheckBox)
		.IsChecked(this,&FSBool_CustomDetails::OnGetValue)
		.OnCheckStateChanged(this,&FSBool_CustomDetails::OnSetValue)
	];
}

void FSBool_CustomDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {}

void FSBool_CustomDetails::OnSetValue(ECheckBoxState Input) const {
	FString K; Keys->GetValue(K);
	//
	switch (Input) {
		case ECheckBoxState::Checked:
			if (K.Len()>0) {Real->SetValue(FEncode(K,TEXT("true")));} else {Real->SetValue(FEncode(TEXT("true")));}
			if (K.Len()>0) {Flip->SetValue(FEncode(K,TEXT("true")));} else {Flip->SetValue(FEncode(TEXT("true")));}
			break;
		case ECheckBoxState::Unchecked:
			if (K.Len()>0) {Real->SetValue(FEncode(K,TEXT("false")));} else {Real->SetValue(FEncode(TEXT("false")));}
			if (K.Len()>0) {Flip->SetValue(FEncode(K,TEXT("false")));} else {Flip->SetValue(FEncode(TEXT("false")));}
			break;
		default:
			Real->SetValue(FEncode(TEXT("false")));
			Flip->SetValue(FEncode(TEXT("false")));
	break;}
}

ECheckBoxState FSBool_CustomDetails::OnGetValue() const {
	FString K; Keys->GetValue(K);
	FString R; Real->GetValue(R);
	//
	if (K.Len()>0) {
		if (FCString::ToBool(*FDecode(K,R))) {return ECheckBoxState::Checked;} else {return ECheckBoxState::Unchecked;}}
	else {if (FCString::ToBool(*FDecode(R))) {return ECheckBoxState::Checked;} else {return ECheckBoxState::Unchecked;}}
	//
	return ECheckBoxState::Undetermined;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeByte

TSharedRef<IPropertyTypeCustomization> FSByte_CustomDetails::MakeInstance() {
	return MakeShareable(new FSByte_CustomDetails());
}

void FSByte_CustomDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {
	uint32 C; StructPropertyHandle->GetNumChildren(C); if (C<3) {return;}
	Keys = StructPropertyHandle->GetChildHandle(0).ToSharedRef();
	Real = StructPropertyHandle->GetChildHandle(1).ToSharedRef();
	Flip = StructPropertyHandle->GetChildHandle(2).ToSharedRef();
	if (!Keys->IsValidHandle()||!Real->IsValidHandle()||!Flip->IsValidHandle()) {return;}
	//
	//
	HeaderRow
	.NameContent()
	[
		SNew(SHorizontalBox)
		.ToolTipText(LOCTEXT("FSByteTooltip","Safe Byte"))
		+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(0,0,5,0)
			[
				SNew(SImage)
				.Image(FSCUE4EditorStyle::Get().GetBrush("ClassIcon.SafeByte"))
			]
		+ SHorizontalBox::Slot()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
			.Font(IDetailLayoutBuilder::GetDetailFont())
			.Text(StructPropertyHandle->GetPropertyDisplayName())
		]
	]
	.ValueContent()
	.MinDesiredWidth(150)
	.MaxDesiredWidth(400)
	[
		SNew(SNumericEntryBox<uint8>)
		.AllowSpin(true)
		.MinValue(TNumericLimits<uint8>::Lowest())
		.MaxValue(TNumericLimits<uint8>::Max())
		.MinSliderValue(0)
		.MaxSliderValue(MAX_int8)
		.Value(this,&FSByte_CustomDetails::OnGetValue)
		.OnValueChanged(this,&FSByte_CustomDetails::OnSetValue)
	];
}

void FSByte_CustomDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {}

void FSByte_CustomDetails::OnSetValue(uint8 Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {Real->SetValue(FEncode(K,FString::FromInt(Input)));} else {Real->SetValue(FEncode(FString::FromInt(Input)));}
	if (K.Len()>0) {Flip->SetValue(FEncode(K,FString::FromInt(Input)));} else {Flip->SetValue(FEncode(FString::FromInt(Input)));}
}

TOptional<uint8> FSByte_CustomDetails::OnGetValue() const {
	FString K; Keys->GetValue(K);
	FString R; Real->GetValue(R);
	//
	if (K.Len()>0) {return FCString::Atoi(*FDecode(K,R));} else {return FCString::Atoi(*FDecode(R));} return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeInt

TSharedRef<IPropertyTypeCustomization> FSInt_CustomDetails::MakeInstance() {
	return MakeShareable(new FSInt_CustomDetails());
}

void FSInt_CustomDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {
	uint32 C; StructPropertyHandle->GetNumChildren(C); if (C<3) {return;}
	Keys = StructPropertyHandle->GetChildHandle(0).ToSharedRef();
	Real = StructPropertyHandle->GetChildHandle(1).ToSharedRef();
	Flip = StructPropertyHandle->GetChildHandle(2).ToSharedRef();
	if (!Keys->IsValidHandle()||!Real->IsValidHandle()||!Flip->IsValidHandle()) {return;}
	//
	//
	HeaderRow
	.NameContent()
	[
		SNew(SHorizontalBox)
		.ToolTipText(LOCTEXT("FSIntTooltip","Safe Int32"))
		+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(0,0,5,0)
			[
				SNew(SImage)
				.Image(FSCUE4EditorStyle::Get().GetBrush("ClassIcon.SafeInt"))
			]
		+ SHorizontalBox::Slot()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
			.Font(IDetailLayoutBuilder::GetDetailFont())
			.Text(StructPropertyHandle->GetPropertyDisplayName())
		]
	]
	.ValueContent()
	.MinDesiredWidth(150)
	.MaxDesiredWidth(400)
	[
		SNew(SNumericEntryBox<int32>)
		.AllowSpin(true)
		.MinValue(TNumericLimits<int32>::Lowest())
		.MaxValue(TNumericLimits<int32>::Max())
		.MinSliderValue(0)
		.MaxSliderValue(1000)
		.Value(this,&FSInt_CustomDetails::OnGetValue)
		.OnValueChanged(this,&FSInt_CustomDetails::OnSetValue)
	];
}

void FSInt_CustomDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {}

void FSInt_CustomDetails::OnSetValue(int32 Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {Real->SetValue(FEncode(K,FString::FromInt(Input)));} else {Real->SetValue(FEncode(FString::FromInt(Input)));}
	if (K.Len()>0) {Flip->SetValue(FEncode(K,FString::FromInt(Input)));} else {Flip->SetValue(FEncode(FString::FromInt(Input)));}
}

TOptional<int32> FSInt_CustomDetails::OnGetValue() const {
	FString K; Keys->GetValue(K);
	FString R; Real->GetValue(R);
	FString F; Flip->GetValue(F);
	//
	if (R.Len()>0) { if (K.Len()>0) {return FCString::Atoi(*FDecode(K,R));} else {return FCString::Atoi(*FDecode(R));} }
	if (F.Len()>0) { if (K.Len()>0) {return FCString::Atoi(*FDecode(K,F));} else {return FCString::Atoi(*FDecode(F));} }
	//
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeFloat

TSharedRef<IPropertyTypeCustomization> FSFloat_CustomDetails::MakeInstance() {
	return MakeShareable(new FSFloat_CustomDetails());
}

void FSFloat_CustomDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {
	uint32 C; StructPropertyHandle->GetNumChildren(C); if (C<3) {return;}
	Keys = StructPropertyHandle->GetChildHandle(0).ToSharedRef();
	Real = StructPropertyHandle->GetChildHandle(1).ToSharedRef();
	Flip = StructPropertyHandle->GetChildHandle(2).ToSharedRef();
	if (!Keys->IsValidHandle()||!Real->IsValidHandle()||!Flip->IsValidHandle()) {return;}
	//
	//
	HeaderRow
	.NameContent()
	[
		SNew(SHorizontalBox)
		.ToolTipText(LOCTEXT("FSFloatTooltip","Safe Float"))
		+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(0,0,5,0)
			[
				SNew(SImage)
				.Image(FSCUE4EditorStyle::Get().GetBrush("ClassIcon.SafeFloat"))
			]
		+ SHorizontalBox::Slot()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
			.Font(IDetailLayoutBuilder::GetDetailFont())
			.Text(StructPropertyHandle->GetPropertyDisplayName())
		]
	]
	.ValueContent()
	.MinDesiredWidth(150)
	.MaxDesiredWidth(400)
	[
		SNew(SNumericEntryBox<float>)
		.AllowSpin(true)
		.MinValue(TNumericLimits<float>::Lowest())
		.MaxValue(TNumericLimits<float>::Max())
		.MinSliderValue(0)
		.MaxSliderValue(1000)
		.Value(this,&FSFloat_CustomDetails::OnGetValue)
		.OnValueChanged(this,&FSFloat_CustomDetails::OnSetValue)
	];
}

void FSFloat_CustomDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {}

void FSFloat_CustomDetails::OnSetValue(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {Real->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {Real->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {Flip->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {Flip->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

TOptional<float> FSFloat_CustomDetails::OnGetValue() const {
	FString K; Keys->GetValue(K);
	FString R; Real->GetValue(R);
	FString F; Flip->GetValue(F);
	//
	if (R.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,R));} else {return FCString::Atof(*FDecode(R));} }
	if (F.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,F));} else {return FCString::Atof(*FDecode(F));} }
	//
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeName

TSharedRef<IPropertyTypeCustomization> FSName_CustomDetails::MakeInstance() {
	return MakeShareable(new FSName_CustomDetails());
}

void FSName_CustomDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {
	uint32 C; StructPropertyHandle->GetNumChildren(C); if (C<3) {return;}
	Keys = StructPropertyHandle->GetChildHandle(0).ToSharedRef();
	Real = StructPropertyHandle->GetChildHandle(1).ToSharedRef();
	Flip = StructPropertyHandle->GetChildHandle(2).ToSharedRef();
	if (!Keys->IsValidHandle()||!Real->IsValidHandle()||!Flip->IsValidHandle()) {return;}
	//
	//
	HeaderRow
	.NameContent()
	[
		SNew(SHorizontalBox)
		.ToolTipText(LOCTEXT("FSNameTooltip","Safe Name"))
		+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(0,0,5,0)
			[
				SNew(SImage)
				.Image(FSCUE4EditorStyle::Get().GetBrush("ClassIcon.SafeName"))
			]
		+ SHorizontalBox::Slot()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
			.Font(IDetailLayoutBuilder::GetDetailFont())
			.Text(StructPropertyHandle->GetPropertyDisplayName())
		]
	]
	.ValueContent()
	.MinDesiredWidth(150)
	.MaxDesiredWidth(400)
	[
		SNew(SEditableTextBox)
		.Text(this,&FSName_CustomDetails::OnGetValue)
		.OnTextCommitted(this,&FSName_CustomDetails::OnSetValue)
	];
}

void FSName_CustomDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {}

void FSName_CustomDetails::OnSetValue(const FText &Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {Real->SetValue(FEncode(K,*&Input.ToString()));} else {Real->SetValue(FEncode(*&Input.ToString()));}
	if (K.Len()>0) {Flip->SetValue(FEncode(K,*&Input.ToString()));} else {Flip->SetValue(FEncode(*&Input.ToString()));}
}

FText FSName_CustomDetails::OnGetValue() const {
	FString K; Keys->GetValue(K);
	FString R; Real->GetValue(R);
	FString F; Real->GetValue(F);
	//
	if (R.Len()>0) { if (K.Len()>0) {return FText::FromString(*FDecode(K,R));} else {return FText::FromString(*FDecode(R));} }
	if (F.Len()>0) { if (K.Len()>0) {return FText::FromString(*FDecode(K,F));} else {return FText::FromString(*FDecode(F));} }
	//
	return FText::FText();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeString

TSharedRef<IPropertyTypeCustomization> FSString_CustomDetails::MakeInstance() {
	return MakeShareable(new FSString_CustomDetails());
}

void FSString_CustomDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {
	uint32 C; StructPropertyHandle->GetNumChildren(C); if (C<3) {return;}
	Keys = StructPropertyHandle->GetChildHandle(0).ToSharedRef();
	Real = StructPropertyHandle->GetChildHandle(1).ToSharedRef();
	Flip = StructPropertyHandle->GetChildHandle(2).ToSharedRef();
	if (!Keys->IsValidHandle()||!Real->IsValidHandle()||!Flip->IsValidHandle()) {return;}
	//
	//
	HeaderRow
	.NameContent()
	[
		SNew(SHorizontalBox)
		.ToolTipText(LOCTEXT("FSStringTooltip","Safe String"))
		+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(0,0,5,0)
			[
				SNew(SImage)
				.Image(FSCUE4EditorStyle::Get().GetBrush("ClassIcon.SafeString"))
			]
		+ SHorizontalBox::Slot()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
			.Font(IDetailLayoutBuilder::GetDetailFont())
			.Text(StructPropertyHandle->GetPropertyDisplayName())
		]
	]
	.ValueContent()
	.MinDesiredWidth(150)
	.MaxDesiredWidth(400)
	[
		SNew(SEditableTextBox)
		.Text(this,&FSString_CustomDetails::OnGetValue)
		.OnTextCommitted(this,&FSString_CustomDetails::OnSetValue)
	];
}

void FSString_CustomDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {}

void FSString_CustomDetails::OnSetValue(const FText &Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {Real->SetValue(FEncode(K,*&Input.ToString()));} else {Real->SetValue(FEncode(*&Input.ToString()));}
	if (K.Len()>0) {Flip->SetValue(FEncode(K,*&Input.ToString()));} else {Flip->SetValue(FEncode(*&Input.ToString()));}
}

FText FSString_CustomDetails::OnGetValue() const {
	FString K; Keys->GetValue(K);
	FString R; Real->GetValue(R);
	FString F; Real->GetValue(F);
	//
	if (R.Len()>0) { if (K.Len()>0) {return FText::FromString(*FDecode(K,R));} else {return FText::FromString(*FDecode(R));} }
	if (F.Len()>0) { if (K.Len()>0) {return FText::FromString(*FDecode(K,F));} else {return FText::FromString(*FDecode(F));} }
	//
	return FText::FText();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeText

TSharedRef<IPropertyTypeCustomization> FSText_CustomDetails::MakeInstance() {
	return MakeShareable(new FSText_CustomDetails());
}

void FSText_CustomDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {
	uint32 C; StructPropertyHandle->GetNumChildren(C); if (C<3) {return;}
	Keys = StructPropertyHandle->GetChildHandle(0).ToSharedRef();
	Real = StructPropertyHandle->GetChildHandle(1).ToSharedRef();
	Flip = StructPropertyHandle->GetChildHandle(2).ToSharedRef();
	if (!Keys->IsValidHandle()||!Real->IsValidHandle()||!Flip->IsValidHandle()) {return;}
	//
	//
	HeaderRow
	.NameContent()
	[
		SNew(SHorizontalBox)
		.ToolTipText(LOCTEXT("FSTextTooltip","Safe Text"))
		+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(0,0,5,0)
			[
				SNew(SImage)
				.Image(FSCUE4EditorStyle::Get().GetBrush("ClassIcon.SafeText"))
			]
		+ SHorizontalBox::Slot()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
			.Font(IDetailLayoutBuilder::GetDetailFont())
			.Text(StructPropertyHandle->GetPropertyDisplayName())
		]
	]
	.ValueContent()
	.MinDesiredWidth(150)
	.MaxDesiredWidth(400)
	[
		SNew(SEditableTextBox)
		.Text(this,&FSText_CustomDetails::OnGetValue)
		.OnTextCommitted(this,&FSText_CustomDetails::OnSetValue)
	];
}

void FSText_CustomDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {}

void FSText_CustomDetails::OnSetValue(const FText &Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {Real->SetValue(FEncode(K,*&Input.ToString()));} else {Real->SetValue(FEncode(*&Input.ToString()));}
	if (K.Len()>0) {Flip->SetValue(FEncode(K,*&Input.ToString()));} else {Flip->SetValue(FEncode(*&Input.ToString()));}
}

FText FSText_CustomDetails::OnGetValue() const {
	FString K; Keys->GetValue(K);
	FString R; Real->GetValue(R);
	FString F; Real->GetValue(F);
	//
	if (R.Len()>0) { if (K.Len()>0) {return FText::FromString(*FDecode(K,R));} else {return FText::FromString(*FDecode(R));} }
	if (F.Len()>0) { if (K.Len()>0) {return FText::FromString(*FDecode(K,F));} else {return FText::FromString(*FDecode(F));} }
	//
	return FText::FText();
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeVector2D

TSharedRef<IPropertyTypeCustomization> FSV2D_CustomDetails::MakeInstance() {
	return MakeShareable(new FSV2D_CustomDetails());
}

void FSV2D_CustomDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {
	uint32 C; StructPropertyHandle->GetNumChildren(C); if (C<5) {return;}
	Keys = StructPropertyHandle->GetChildHandle(0).ToSharedRef();
	RealX = StructPropertyHandle->GetChildHandle(1).ToSharedRef();
	RealY = StructPropertyHandle->GetChildHandle(2).ToSharedRef();
	FlipX = StructPropertyHandle->GetChildHandle(3).ToSharedRef();
	FlipY = StructPropertyHandle->GetChildHandle(4).ToSharedRef();
	//
	if (!Keys->IsValidHandle()) {return;}
	if (!RealX->IsValidHandle()||!RealY->IsValidHandle()) {return;}
	if (!FlipX->IsValidHandle()||!FlipY->IsValidHandle()) {return;}
	//
	//
	HeaderRow
	.NameContent()
	[
		SNew(SHorizontalBox)
		.ToolTipText(LOCTEXT("FSV2DTooltip","Safe Vector 2D"))
		+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(0,0,5,0)
			[
				SNew(SImage)
				.Image(FSCUE4EditorStyle::Get().GetBrush("ClassIcon.SafeVector2D"))
			]
		+ SHorizontalBox::Slot()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
			.Font(IDetailLayoutBuilder::GetDetailFont())
			.Text(StructPropertyHandle->GetPropertyDisplayName())
		]
	]
	.ValueContent()
	.MinDesiredWidth(150)
	.MaxDesiredWidth(600)
	[
		SNew(SVector2DBox)
		.ValueX(this,&FSV2D_CustomDetails::OnGetValueX)
		.ValueY(this,&FSV2D_CustomDetails::OnGetValueY)
		.OnSetValueX(this,&FSV2D_CustomDetails::OnSetValueX)
		.OnSetValueY(this,&FSV2D_CustomDetails::OnSetValueY)
		.OnValueChangeX(this,&FSV2D_CustomDetails::OnValueChangeX)
		.OnValueChangeY(this,&FSV2D_CustomDetails::OnValueChangeY)
	];
}

void FSV2D_CustomDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {}

void FSV2D_CustomDetails::OnSetValueX(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV2D_CustomDetails::OnSetValueY(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV2D_CustomDetails::OnValueChangeX(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV2D_CustomDetails::OnValueChangeY(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

TOptional<float> FSV2D_CustomDetails::OnGetValueX() const {
	FString K; Keys->GetValue(K);
	FString RX; RealX->GetValue(RX);
	FString FX; FlipX->GetValue(FX);
	//
	if (RX.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RX));} else {return FCString::Atof(*FDecode(RX));} }
	if (FX.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FX));} else {return FCString::Atof(*FDecode(FX));} }
	//
	return 0;
}

TOptional<float> FSV2D_CustomDetails::OnGetValueY() const {
	FString K; Keys->GetValue(K);
	FString RY; RealY->GetValue(RY);
	FString FY; FlipY->GetValue(FY);
	//
	if (RY.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RY));} else {return FCString::Atof(*FDecode(RY));} }
	if (FY.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FY));} else {return FCString::Atof(*FDecode(FY));} }
	//
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeVector3D

TSharedRef<IPropertyTypeCustomization> FSV3D_CustomDetails::MakeInstance() {
	return MakeShareable(new FSV3D_CustomDetails());
}

void FSV3D_CustomDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {
	uint32 C; StructPropertyHandle->GetNumChildren(C); if (C<7) {return;}
	Keys = StructPropertyHandle->GetChildHandle(0).ToSharedRef();
	RealX = StructPropertyHandle->GetChildHandle(1).ToSharedRef();
	RealY = StructPropertyHandle->GetChildHandle(2).ToSharedRef();
	RealZ = StructPropertyHandle->GetChildHandle(3).ToSharedRef();
	FlipX = StructPropertyHandle->GetChildHandle(4).ToSharedRef();
	FlipY = StructPropertyHandle->GetChildHandle(5).ToSharedRef();
	FlipZ = StructPropertyHandle->GetChildHandle(6).ToSharedRef();
	//
	if (!Keys->IsValidHandle()) {return;}
	if (!RealX->IsValidHandle()||!RealY->IsValidHandle()||!RealZ->IsValidHandle()) {return;}
	if (!FlipX->IsValidHandle()||!FlipY->IsValidHandle()||!FlipZ->IsValidHandle()) {return;}
	//
	//
	HeaderRow
	.NameContent()
	[
		SNew(SHorizontalBox)
		.ToolTipText(LOCTEXT("FSV3DTooltip","Safe Vector 3D"))
		+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(0,0,5,0)
			[
				SNew(SImage)
				.Image(FSCUE4EditorStyle::Get().GetBrush("ClassIcon.SafeVector3D"))
			]
		+ SHorizontalBox::Slot()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
			.Font(IDetailLayoutBuilder::GetDetailFont())
			.Text(StructPropertyHandle->GetPropertyDisplayName())
		]
	]
	.ValueContent()
	.MinDesiredWidth(150)
	.MaxDesiredWidth(600)
	[
		SNew(SVector3DBox)
		.ValueX(this,&FSV3D_CustomDetails::OnGetValueX)
		.ValueY(this,&FSV3D_CustomDetails::OnGetValueY)
		.ValueZ(this,&FSV3D_CustomDetails::OnGetValueZ)
		.OnSetValueX(this,&FSV3D_CustomDetails::OnSetValueX)
		.OnSetValueY(this,&FSV3D_CustomDetails::OnSetValueY)
		.OnSetValueZ(this,&FSV3D_CustomDetails::OnSetValueZ)
		.OnValueChangeX(this,&FSV3D_CustomDetails::OnValueChangeX)
		.OnValueChangeY(this,&FSV3D_CustomDetails::OnValueChangeY)
		.OnValueChangeZ(this,&FSV3D_CustomDetails::OnValueChangeZ)
	];
}

void FSV3D_CustomDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {}

void FSV3D_CustomDetails::OnSetValueX(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV3D_CustomDetails::OnSetValueY(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV3D_CustomDetails::OnSetValueZ(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealZ->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealZ->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipZ->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipZ->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV3D_CustomDetails::OnValueChangeX(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV3D_CustomDetails::OnValueChangeY(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV3D_CustomDetails::OnValueChangeZ(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealZ->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealZ->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipZ->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipZ->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

TOptional<float> FSV3D_CustomDetails::OnGetValueX() const {
	FString K; Keys->GetValue(K);
	FString RX; RealX->GetValue(RX);
	FString FX; FlipX->GetValue(FX);
	//
	if (RX.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RX));} else {return FCString::Atof(*FDecode(RX));} }
	if (FX.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FX));} else {return FCString::Atof(*FDecode(FX));} }
	//
	return 0;
}

TOptional<float> FSV3D_CustomDetails::OnGetValueY() const {
	FString K; Keys->GetValue(K);
	FString RY; RealY->GetValue(RY);
	FString FY; FlipY->GetValue(FY);
	//
	if (RY.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RY));} else {return FCString::Atof(*FDecode(RY));} }
	if (FY.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FY));} else {return FCString::Atof(*FDecode(FY));} }
	//
	return 0;
}

TOptional<float> FSV3D_CustomDetails::OnGetValueZ() const {
	FString K; Keys->GetValue(K);
	FString RZ; RealZ->GetValue(RZ);
	FString FZ; FlipZ->GetValue(FZ);
	//
	if (RZ.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RZ));} else {return FCString::Atof(*FDecode(RZ));} }
	if (FZ.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FZ));} else {return FCString::Atof(*FDecode(FZ));} }
	//
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeVector4D

TSharedRef<IPropertyTypeCustomization> FSV4D_CustomDetails::MakeInstance() {
	return MakeShareable(new FSV4D_CustomDetails());
}

void FSV4D_CustomDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {
	uint32 C; StructPropertyHandle->GetNumChildren(C); if (C<9) {return;}
	Keys = StructPropertyHandle->GetChildHandle(0).ToSharedRef();
	RealX = StructPropertyHandle->GetChildHandle(1).ToSharedRef();
	RealY = StructPropertyHandle->GetChildHandle(2).ToSharedRef();
	RealZ = StructPropertyHandle->GetChildHandle(3).ToSharedRef();
	RealW = StructPropertyHandle->GetChildHandle(4).ToSharedRef();
	FlipX = StructPropertyHandle->GetChildHandle(5).ToSharedRef();
	FlipY = StructPropertyHandle->GetChildHandle(6).ToSharedRef();
	FlipZ = StructPropertyHandle->GetChildHandle(7).ToSharedRef();
	FlipW = StructPropertyHandle->GetChildHandle(8).ToSharedRef();
	//
	if (!Keys->IsValidHandle()) {return;}
	if (!RealX->IsValidHandle()||!RealY->IsValidHandle()||!RealZ->IsValidHandle()||!RealW->IsValidHandle()) {return;}
	if (!FlipX->IsValidHandle()||!FlipY->IsValidHandle()||!FlipZ->IsValidHandle()||!FlipW->IsValidHandle()) {return;}
	//
	//
	HeaderRow
	.NameContent()
	[
		SNew(SHorizontalBox)
		.ToolTipText(LOCTEXT("FSV4DTooltip","Safe Vector 4D"))
		+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(0,0,5,0)
			[
				SNew(SImage)
				.Image(FSCUE4EditorStyle::Get().GetBrush("ClassIcon.SafeVector4D"))
			]
		+ SHorizontalBox::Slot()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
			.Font(IDetailLayoutBuilder::GetDetailFont())
			.Text(StructPropertyHandle->GetPropertyDisplayName())
		]
	]
	.ValueContent()
	.MinDesiredWidth(150)
	.MaxDesiredWidth(600)
	[
		SNew(SVector4DBox)
		.ValueX(this,&FSV4D_CustomDetails::OnGetValueX)
		.ValueY(this,&FSV4D_CustomDetails::OnGetValueY)
		.ValueZ(this,&FSV4D_CustomDetails::OnGetValueZ)
		.ValueW(this,&FSV4D_CustomDetails::OnGetValueW)
		.OnSetValueX(this,&FSV4D_CustomDetails::OnSetValueX)
		.OnSetValueY(this,&FSV4D_CustomDetails::OnSetValueY)
		.OnSetValueZ(this,&FSV4D_CustomDetails::OnSetValueZ)
		.OnSetValueW(this,&FSV4D_CustomDetails::OnSetValueW)
		.OnValueChangeX(this,&FSV4D_CustomDetails::OnValueChangeX)
		.OnValueChangeY(this,&FSV4D_CustomDetails::OnValueChangeY)
		.OnValueChangeZ(this,&FSV4D_CustomDetails::OnValueChangeZ)
		.OnValueChangeW(this,&FSV4D_CustomDetails::OnValueChangeW)
	];
}

void FSV4D_CustomDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {}

void FSV4D_CustomDetails::OnSetValueX(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV4D_CustomDetails::OnSetValueY(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV4D_CustomDetails::OnSetValueZ(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealZ->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealZ->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipZ->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipZ->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV4D_CustomDetails::OnSetValueW(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealW->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealW->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipW->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipW->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV4D_CustomDetails::OnValueChangeX(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV4D_CustomDetails::OnValueChangeY(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV4D_CustomDetails::OnValueChangeZ(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealZ->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealZ->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipZ->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipZ->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSV4D_CustomDetails::OnValueChangeW(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealW->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealW->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipW->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipW->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

TOptional<float> FSV4D_CustomDetails::OnGetValueX() const {
	FString K; Keys->GetValue(K);
	FString RX; RealX->GetValue(RX);
	FString FX; FlipX->GetValue(FX);
	//
	if (RX.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RX));} else {return FCString::Atof(*FDecode(RX));} }
	if (FX.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FX));} else {return FCString::Atof(*FDecode(FX));} }
	//
	return 0;
}

TOptional<float> FSV4D_CustomDetails::OnGetValueY() const {
	FString K; Keys->GetValue(K);
	FString RY; RealY->GetValue(RY);
	FString FY; FlipY->GetValue(FY);
	//
	if (RY.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RY));} else {return FCString::Atof(*FDecode(RY));} }
	if (FY.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FY));} else {return FCString::Atof(*FDecode(FY));} }
	//
	return 0;
}

TOptional<float> FSV4D_CustomDetails::OnGetValueZ() const {
	FString K; Keys->GetValue(K);
	FString RZ; RealZ->GetValue(RZ);
	FString FZ; FlipZ->GetValue(FZ);
	//
	if (RZ.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RZ));} else {return FCString::Atof(*FDecode(RZ));} }
	if (FZ.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FZ));} else {return FCString::Atof(*FDecode(FZ));} }
	//
	return 0;
}

TOptional<float> FSV4D_CustomDetails::OnGetValueW() const {
	FString K; Keys->GetValue(K);
	FString RW; RealW->GetValue(RW);
	FString FW; FlipW->GetValue(FW);
	//
	if (RW.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RW));} else {return FCString::Atof(*FDecode(RW));} }
	if (FW.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FW));} else {return FCString::Atof(*FDecode(FW));} }
	//
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeColor

TSharedRef<IPropertyTypeCustomization> FSColor_CustomDetails::MakeInstance() {
	return MakeShareable(new FSColor_CustomDetails());
}

void FSColor_CustomDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {
	uint32 C; StructPropertyHandle->GetNumChildren(C); if (C<9) {return;}
	Keys = StructPropertyHandle->GetChildHandle(0).ToSharedRef();
	RealR = StructPropertyHandle->GetChildHandle(1).ToSharedRef();
	RealG = StructPropertyHandle->GetChildHandle(2).ToSharedRef();
	RealB = StructPropertyHandle->GetChildHandle(3).ToSharedRef();
	RealA = StructPropertyHandle->GetChildHandle(4).ToSharedRef();
	FlipR = StructPropertyHandle->GetChildHandle(5).ToSharedRef();
	FlipG = StructPropertyHandle->GetChildHandle(6).ToSharedRef();
	FlipB = StructPropertyHandle->GetChildHandle(7).ToSharedRef();
	FlipA = StructPropertyHandle->GetChildHandle(8).ToSharedRef();
	//
	if (!Keys->IsValidHandle()) {return;}
	if (!RealR->IsValidHandle()||!RealG->IsValidHandle()||!RealB->IsValidHandle()||!RealA->IsValidHandle()) {return;}
	if (!FlipR->IsValidHandle()||!FlipG->IsValidHandle()||!FlipB->IsValidHandle()||!FlipA->IsValidHandle()) {return;}
	//
	//
	HeaderRow
	.NameContent()
	[
		SNew(SHorizontalBox)
		.ToolTipText(LOCTEXT("FSColorTooltip","Safe Color"))
		+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(0,0,5,0)
			[
				SNew(SImage)
				.Image(FSCUE4EditorStyle::Get().GetBrush("ClassIcon.SafeColor"))
			]
		+ SHorizontalBox::Slot()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
			.Font(IDetailLayoutBuilder::GetDetailFont())
			.Text(StructPropertyHandle->GetPropertyDisplayName())
		]
	]
	.ValueContent()
	.MinDesiredWidth(150)
	.MaxDesiredWidth(600)
	[
		SNew(SColorBox)
		.ValueR(this,&FSColor_CustomDetails::OnGetValueR)
		.ValueG(this,&FSColor_CustomDetails::OnGetValueG)
		.ValueB(this,&FSColor_CustomDetails::OnGetValueB)
		.ValueA(this,&FSColor_CustomDetails::OnGetValueA)
		.OnSetValueR(this,&FSColor_CustomDetails::OnSetValueR)
		.OnSetValueG(this,&FSColor_CustomDetails::OnSetValueG)
		.OnSetValueB(this,&FSColor_CustomDetails::OnSetValueB)
		.OnSetValueA(this,&FSColor_CustomDetails::OnSetValueA)
		.OnValueChangeR(this,&FSColor_CustomDetails::OnValueChangeR)
		.OnValueChangeG(this,&FSColor_CustomDetails::OnValueChangeG)
		.OnValueChangeB(this,&FSColor_CustomDetails::OnValueChangeB)
		.OnValueChangeA(this,&FSColor_CustomDetails::OnValueChangeA)
	];
}

void FSColor_CustomDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {}

void FSColor_CustomDetails::OnSetValueR(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealR->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealR->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipR->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipR->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSColor_CustomDetails::OnSetValueG(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealG->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealG->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipG->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipG->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSColor_CustomDetails::OnSetValueB(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealB->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealB->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipB->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipB->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSColor_CustomDetails::OnSetValueA(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealA->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealA->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipA->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipA->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSColor_CustomDetails::OnValueChangeR(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealR->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealR->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipR->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipR->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSColor_CustomDetails::OnValueChangeG(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealG->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealG->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipG->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipG->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSColor_CustomDetails::OnValueChangeB(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealB->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealB->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipB->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipB->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSColor_CustomDetails::OnValueChangeA(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealA->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealA->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipA->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipA->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

TOptional<float> FSColor_CustomDetails::OnGetValueR() const {
	FString K; Keys->GetValue(K);
	FString RR; RealR->GetValue(RR);
	FString FR; FlipR->GetValue(FR);
	//
	if (RR.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RR));} else {return FCString::Atof(*FDecode(RR));} }
	if (FR.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FR));} else {return FCString::Atof(*FDecode(FR));} }
	//
	return 0;
}

TOptional<float> FSColor_CustomDetails::OnGetValueG() const {
	FString K; Keys->GetValue(K);
	FString RG; RealG->GetValue(RG);
	FString FG; FlipG->GetValue(FG);
	//
	if (RG.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RG));} else {return FCString::Atof(*FDecode(RG));} }
	if (FG.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FG));} else {return FCString::Atof(*FDecode(FG));} }
	//
	return 0;
}

TOptional<float> FSColor_CustomDetails::OnGetValueB() const {
	FString K; Keys->GetValue(K);
	FString RB; RealB->GetValue(RB);
	FString FB; FlipB->GetValue(FB);
	//
	if (RB.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RB));} else {return FCString::Atof(*FDecode(RB));} }
	if (FB.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FB));} else {return FCString::Atof(*FDecode(FB));} }
	//
	return 0;
}

TOptional<float> FSColor_CustomDetails::OnGetValueA() const {
	FString K; Keys->GetValue(K);
	FString RA; RealA->GetValue(RA);
	FString FA; FlipA->GetValue(FA);
	//
	if (RA.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RA));} else {return FCString::Atof(*FDecode(RA));} }
	if (FA.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FA));} else {return FCString::Atof(*FDecode(FA));} }
	//
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeRotator

TSharedRef<IPropertyTypeCustomization> FSRotator_CustomDetails::MakeInstance() {
	return MakeShareable(new FSRotator_CustomDetails());
}

void FSRotator_CustomDetails::CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {
	uint32 C; StructPropertyHandle->GetNumChildren(C); if (C<7) {return;}
	Keys = StructPropertyHandle->GetChildHandle(0).ToSharedRef();
	RealX = StructPropertyHandle->GetChildHandle(1).ToSharedRef();
	RealY = StructPropertyHandle->GetChildHandle(2).ToSharedRef();
	RealZ = StructPropertyHandle->GetChildHandle(3).ToSharedRef();
	FlipX = StructPropertyHandle->GetChildHandle(4).ToSharedRef();
	FlipY = StructPropertyHandle->GetChildHandle(5).ToSharedRef();
	FlipZ = StructPropertyHandle->GetChildHandle(6).ToSharedRef();
	//
	if (!Keys->IsValidHandle()) {return;}
	if (!RealX->IsValidHandle()||!RealY->IsValidHandle()||!RealZ->IsValidHandle()) {return;}
	if (!FlipX->IsValidHandle()||!FlipY->IsValidHandle()||!FlipZ->IsValidHandle()) {return;}
	//
	//
	HeaderRow
	.NameContent()
	[
		SNew(SHorizontalBox)
		.ToolTipText(LOCTEXT("FSRotatorTooltip","Safe Rotator"))
		+ SHorizontalBox::Slot()
			.AutoWidth()
			.VAlign(VAlign_Center)
			.Padding(0,0,5,0)
			[
				SNew(SImage)
				.Image(FSCUE4EditorStyle::Get().GetBrush("ClassIcon.SafeRotator"))
			]
		+ SHorizontalBox::Slot()
		.VAlign(VAlign_Center)
		[
			SNew(STextBlock)
			.Font(IDetailLayoutBuilder::GetDetailFont())
			.Text(StructPropertyHandle->GetPropertyDisplayName())
		]
	]
	.ValueContent()
	.MinDesiredWidth(150)
	.MaxDesiredWidth(600)
	[
		SNew(SVector3DBox)
		.ValueX(this,&FSRotator_CustomDetails::OnGetValueX)
		.ValueY(this,&FSRotator_CustomDetails::OnGetValueY)
		.ValueZ(this,&FSRotator_CustomDetails::OnGetValueZ)
		.OnSetValueX(this,&FSRotator_CustomDetails::OnSetValueX)
		.OnSetValueY(this,&FSRotator_CustomDetails::OnSetValueY)
		.OnSetValueZ(this,&FSRotator_CustomDetails::OnSetValueZ)
		.OnValueChangeX(this,&FSRotator_CustomDetails::OnValueChangeX)
		.OnValueChangeY(this,&FSRotator_CustomDetails::OnValueChangeY)
		.OnValueChangeZ(this,&FSRotator_CustomDetails::OnValueChangeZ)
	];
}

void FSRotator_CustomDetails::CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) {}

void FSRotator_CustomDetails::OnSetValueX(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSRotator_CustomDetails::OnSetValueY(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSRotator_CustomDetails::OnSetValueZ(float Input, ETextCommit::Type CommitType) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealZ->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealZ->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipZ->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipZ->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSRotator_CustomDetails::OnValueChangeX(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipX->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipX->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSRotator_CustomDetails::OnValueChangeY(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipY->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipY->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

void FSRotator_CustomDetails::OnValueChangeZ(float Input) const {
	FString K; Keys->GetValue(K);
	//
	if (K.Len()>0) {RealZ->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {RealZ->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
	if (K.Len()>0) {FlipZ->SetValue(FEncode(K,FString::Printf(TEXT("%f"),Input)));} else {FlipZ->SetValue(FEncode(FString::Printf(TEXT("%f"),Input)));}
}

TOptional<float> FSRotator_CustomDetails::OnGetValueX() const {
	FString K; Keys->GetValue(K);
	FString RX; RealX->GetValue(RX);
	FString FX; FlipX->GetValue(FX);
	//
	if (RX.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RX));} else {return FCString::Atof(*FDecode(RX));} }
	if (FX.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FX));} else {return FCString::Atof(*FDecode(FX));} }
	//
	return 0;
}

TOptional<float> FSRotator_CustomDetails::OnGetValueY() const {
	FString K; Keys->GetValue(K);
	FString RY; RealY->GetValue(RY);
	FString FY; FlipY->GetValue(FY);
	//
	if (RY.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RY));} else {return FCString::Atof(*FDecode(RY));} }
	if (FY.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FY));} else {return FCString::Atof(*FDecode(FY));} }
	//
	return 0;
}

TOptional<float> FSRotator_CustomDetails::OnGetValueZ() const {
	FString K; Keys->GetValue(K);
	FString RZ; RealZ->GetValue(RZ);
	FString FZ; FlipZ->GetValue(FZ);
	//
	if (RZ.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,RZ));} else {return FCString::Atof(*FDecode(RZ));} }
	if (FZ.Len()>0) { if (K.Len()>0) {return FCString::Atof(*FDecode(K,FZ));} else {return FCString::Atof(*FDecode(FZ));} }
	//
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#undef LOCTEXT_NAMESPACE

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_MODULE(FSCUE4Editor,SCUE4Editor)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/Settings/Private/SCUE4EditorPrivatePCH.h`:

```h
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//			Copyright 2016 (C) Bruno Xavier Leite
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "CoreMinimal.h"
#include "UObject/Object.h"
#include "UObject/WeakObjectPtr.h"
#include "Runtime/Engine/Classes/Engine/Engine.h"

#include "PropertyEditorModule.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/Settings/Private/SCUE4EditorStyle.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//			Copyright 2016 (C) Bruno Xavier Leite
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "SCUE4EditorStyle.h"
#include "SCUE4EditorPrivatePCH.h"

#include "Interfaces/IPluginManager.h"
#include "Slate/SlateGameResources.h"
#include "Styling/SlateStyle.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define PLUGIN_BRUSH(RelativePath,...) FSlateImageBrush(Style->RootToContentDir(RelativePath,TEXT(".png")),__VA_ARGS__)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

TSharedPtr<FSlateStyleSet> FSCUE4EditorStyle::StyleInstance = NULL;

void FSCUE4EditorStyle::Initialize() {
	if (!StyleInstance.IsValid()) {
		StyleInstance = Create();
		FSlateStyleRegistry::RegisterSlateStyle(*StyleInstance);
	}
}

void FSCUE4EditorStyle::Shutdown() {
	FSlateStyleRegistry::UnRegisterSlateStyle(*StyleInstance);
	ensure(StyleInstance.IsUnique());
	StyleInstance.Reset();
}

const ISlateStyle& FSCUE4EditorStyle::Get() {
	return *StyleInstance;
}

FName FSCUE4EditorStyle::GetStyleSetName() {
	static FName StyleSetName(TEXT("SCUE4EditorStyle"));
	return StyleSetName;
}

void FSCUE4EditorStyle::ReloadTextures() {
	if (FSlateApplication::IsInitialized())	{
		FSlateApplication::Get().GetRenderer()->ReloadTextureResources();
	}
}

TSharedRef< FSlateStyleSet > FSCUE4EditorStyle::Create() {
	const FVector2D Icon16x16(16.0f,16.0f);
	const FVector2D Icon40x40(40.0f,40.0f);
	const FVector2D Icon128x128(128.0f,128.0f);
	//
	TSharedRef< FSlateStyleSet > Style = MakeShareable(new FSlateStyleSet("SCUE4EditorStyle"));
	Style->SetContentRoot(IPluginManager::Get().FindPlugin(TEXT("SCUE4"))->GetContentDir());
	//
	Style->Set("SCUE4Editor.PluginAction", new PLUGIN_BRUSH(TEXT("Icons/SCUE4_128x"),Icon40x40));
	Style->Set("ClassIcon.SafeInt", new PLUGIN_BRUSH(TEXT("Icons/Int_16x"),Icon16x16));
	Style->Set("ClassIcon.SafeBool", new PLUGIN_BRUSH(TEXT("Icons/Bool_16x"),Icon16x16));
	Style->Set("ClassIcon.SafeByte", new PLUGIN_BRUSH(TEXT("Icons/Byte_16x"),Icon16x16));
	Style->Set("ClassIcon.SafeFloat", new PLUGIN_BRUSH(TEXT("Icons/Float_16x"),Icon16x16));
	Style->Set("ClassIcon.SafeName", new PLUGIN_BRUSH(TEXT("Icons/Name_16x"),Icon16x16));
	Style->Set("ClassIcon.SafeText", new PLUGIN_BRUSH(TEXT("Icons/Text_16x"),Icon16x16));
	Style->Set("ClassIcon.SafeString", new PLUGIN_BRUSH(TEXT("Icons/String_16x"),Icon16x16));
	Style->Set("ClassIcon.SafeRotator", new PLUGIN_BRUSH(TEXT("Icons/Rotator_16x"),Icon16x16));
	Style->Set("ClassIcon.SafeColor", new PLUGIN_BRUSH(TEXT("Icons/Color_16x"),Icon16x16));
	Style->Set("ClassIcon.SafeVector2D", new PLUGIN_BRUSH(TEXT("Icons/Vector_16x"),Icon16x16));
	Style->Set("ClassIcon.SafeVector3D", new PLUGIN_BRUSH(TEXT("Icons/Vector_16x"),Icon16x16));
	Style->Set("ClassIcon.SafeVector4D", new PLUGIN_BRUSH(TEXT("Icons/Vector_16x"),Icon16x16));
	Style->Set("ClassIcon.SafeTransform", new PLUGIN_BRUSH(TEXT("Icons/Transform_16x"),Icon16x16));
	//
	return Style;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#undef PLUGIN_BRUSH

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/Settings/Public/SCUE4Editor.h`:

```h
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//			Copyright 2016 (C) Bruno Xavier Leite
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "Modules/ModuleManager.h"

#include "Widgets/Input/SNumericEntryBox.h"
#include "PropertyEditing.h"
#include "SlateBasics.h"
#include "SlateExtras.h"
#include "LevelEditor.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FToolBarBuilder;
class FMenuBuilder;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FSCUE4Editor : public IModuleInterface {
private:
	TSharedPtr<FUICommandList> PluginCommands;
	void AddToolbarExtension(FToolBarBuilder &Builder);
	void AddMenuExtension(FMenuBuilder &Builder);
public:
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
	//
	void PluginButtonClicked();
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeBool

class SCUE4EDITOR_API FSBool_CustomDetails : public IPropertyTypeCustomization {
private:
	TSharedPtr<IPropertyHandle> Keys;
	TSharedPtr<IPropertyHandle> Real;
	TSharedPtr<IPropertyHandle> Flip;
public:
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();
	//
	virtual void CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	//
	ECheckBoxState OnGetValue() const;
	void OnSetValue(ECheckBoxState Input) const;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeByte

class SCUE4EDITOR_API FSByte_CustomDetails : public IPropertyTypeCustomization {
private:
	TSharedPtr<IPropertyHandle> Keys;
	TSharedPtr<IPropertyHandle> Real;
	TSharedPtr<IPropertyHandle> Flip;
public:
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();
	//
	virtual void CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	//
	TOptional<uint8> OnGetValue() const;
	void OnSetValue(uint8 Input) const;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeInt

class SCUE4EDITOR_API FSInt_CustomDetails : public IPropertyTypeCustomization {
private:
	TSharedPtr<IPropertyHandle> Keys;
	TSharedPtr<IPropertyHandle> Real;
	TSharedPtr<IPropertyHandle> Flip;
public:
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();
	//
	virtual void CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	//
	TOptional<int32> OnGetValue() const;
	void OnSetValue(int32 Input) const;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeFloat

class SCUE4EDITOR_API FSFloat_CustomDetails : public IPropertyTypeCustomization {
private:
	TSharedPtr<IPropertyHandle> Keys;
	TSharedPtr<IPropertyHandle> Real;
	TSharedPtr<IPropertyHandle> Flip;
public:
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();
	//
	virtual void CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	//
	TOptional<float> OnGetValue() const;
	void OnSetValue(float Input) const;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeName

class SCUE4EDITOR_API FSName_CustomDetails : public IPropertyTypeCustomization {
private:
	TSharedPtr<IPropertyHandle> Keys;
	TSharedPtr<IPropertyHandle> Real;
	TSharedPtr<IPropertyHandle> Flip;
public:
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();
	//
	virtual void CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	//
	FText OnGetValue() const;
	void OnSetValue(const FText &Input, ETextCommit::Type CommitType) const;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeString

class SCUE4EDITOR_API FSString_CustomDetails : public IPropertyTypeCustomization {
private:
	TSharedPtr<IPropertyHandle> Keys;
	TSharedPtr<IPropertyHandle> Real;
	TSharedPtr<IPropertyHandle> Flip;
public:
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();
	//
	virtual void CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	//
	FText OnGetValue() const;
	void OnSetValue(const FText &Input, ETextCommit::Type CommitType) const;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeText

class SCUE4EDITOR_API FSText_CustomDetails : public IPropertyTypeCustomization {
private:
	TSharedPtr<IPropertyHandle> Keys;
	TSharedPtr<IPropertyHandle> Real;
	TSharedPtr<IPropertyHandle> Flip;
public:
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();
	//
	virtual void CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	//
	FText OnGetValue() const;
	void OnSetValue(const FText &Input, ETextCommit::Type CommitType) const;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeVector2D

class SCUE4EDITOR_API FSV2D_CustomDetails : public IPropertyTypeCustomization {
private:
	TSharedPtr<IPropertyHandle> Keys;
	TSharedPtr<IPropertyHandle> RealX;
	TSharedPtr<IPropertyHandle> RealY;
	TSharedPtr<IPropertyHandle> FlipX;
	TSharedPtr<IPropertyHandle> FlipY;
public:
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();
	//
	virtual void CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	//
	TOptional<float> OnGetValueX() const;
	TOptional<float> OnGetValueY() const;
	void OnValueChangeX(float Input) const;
	void OnValueChangeY(float Input) const;
	void OnSetValueX(float Input, ETextCommit::Type CommitType) const;
	void OnSetValueY(float Input, ETextCommit::Type CommitType) const;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeVector3D

class SCUE4EDITOR_API FSV3D_CustomDetails : public IPropertyTypeCustomization {
private:
	TSharedPtr<IPropertyHandle> Keys;
	TSharedPtr<IPropertyHandle> RealX;
	TSharedPtr<IPropertyHandle> RealY;
	TSharedPtr<IPropertyHandle> RealZ;
	TSharedPtr<IPropertyHandle> FlipX;
	TSharedPtr<IPropertyHandle> FlipY;
	TSharedPtr<IPropertyHandle> FlipZ;
public:
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();
	//
	virtual void CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	//
	TOptional<float> OnGetValueX() const;
	TOptional<float> OnGetValueY() const;
	TOptional<float> OnGetValueZ() const;
	void OnValueChangeX(float Input) const;
	void OnValueChangeY(float Input) const;
	void OnValueChangeZ(float Input) const;
	void OnSetValueX(float Input, ETextCommit::Type CommitType) const;
	void OnSetValueY(float Input, ETextCommit::Type CommitType) const;
	void OnSetValueZ(float Input, ETextCommit::Type CommitType) const;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeVector4D

class SCUE4EDITOR_API FSV4D_CustomDetails : public IPropertyTypeCustomization {
private:
	TSharedPtr<IPropertyHandle> Keys;
	TSharedPtr<IPropertyHandle> RealX;
	TSharedPtr<IPropertyHandle> RealY;
	TSharedPtr<IPropertyHandle> RealZ;
	TSharedPtr<IPropertyHandle> RealW;
	TSharedPtr<IPropertyHandle> FlipX;
	TSharedPtr<IPropertyHandle> FlipY;
	TSharedPtr<IPropertyHandle> FlipZ;
	TSharedPtr<IPropertyHandle> FlipW;
public:
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();
	//
	virtual void CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	//
	TOptional<float> OnGetValueX() const;
	TOptional<float> OnGetValueY() const;
	TOptional<float> OnGetValueZ() const;
	TOptional<float> OnGetValueW() const;
	void OnValueChangeX(float Input) const;
	void OnValueChangeY(float Input) const;
	void OnValueChangeZ(float Input) const;
	void OnValueChangeW(float Input) const;
	void OnSetValueX(float Input, ETextCommit::Type CommitType) const;
	void OnSetValueY(float Input, ETextCommit::Type CommitType) const;
	void OnSetValueZ(float Input, ETextCommit::Type CommitType) const;
	void OnSetValueW(float Input, ETextCommit::Type CommitType) const;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeColor

class SCUE4EDITOR_API FSColor_CustomDetails : public IPropertyTypeCustomization {
private:
	TSharedPtr<IPropertyHandle> Keys;
	TSharedPtr<IPropertyHandle> RealR;
	TSharedPtr<IPropertyHandle> RealG;
	TSharedPtr<IPropertyHandle> RealB;
	TSharedPtr<IPropertyHandle> RealA;
	TSharedPtr<IPropertyHandle> FlipR;
	TSharedPtr<IPropertyHandle> FlipG;
	TSharedPtr<IPropertyHandle> FlipB;
	TSharedPtr<IPropertyHandle> FlipA;
public:
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();
	//
	virtual void CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	//
	TOptional<float> OnGetValueR() const;
	TOptional<float> OnGetValueG() const;
	TOptional<float> OnGetValueB() const;
	TOptional<float> OnGetValueA() const;
	void OnValueChangeR(float Input) const;
	void OnValueChangeG(float Input) const;
	void OnValueChangeB(float Input) const;
	void OnValueChangeA(float Input) const;
	void OnSetValueR(float Input, ETextCommit::Type CommitType) const;
	void OnSetValueG(float Input, ETextCommit::Type CommitType) const;
	void OnSetValueB(float Input, ETextCommit::Type CommitType) const;
	void OnSetValueA(float Input, ETextCommit::Type CommitType) const;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// FSafeRotator

class SCUE4EDITOR_API FSRotator_CustomDetails : public IPropertyTypeCustomization {
private:
	TSharedPtr<IPropertyHandle> Keys;
	TSharedPtr<IPropertyHandle> RealX;
	TSharedPtr<IPropertyHandle> RealY;
	TSharedPtr<IPropertyHandle> RealZ;
	TSharedPtr<IPropertyHandle> FlipX;
	TSharedPtr<IPropertyHandle> FlipY;
	TSharedPtr<IPropertyHandle> FlipZ;
public:
	static TSharedRef<IPropertyTypeCustomization> MakeInstance();
	//
	virtual void CustomizeHeader(TSharedRef<class IPropertyHandle> StructPropertyHandle, class FDetailWidgetRow &HeaderRow, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	virtual void CustomizeChildren(TSharedRef<class IPropertyHandle> StructPropertyHandle, class IDetailChildrenBuilder &StructBuilder, IPropertyTypeCustomizationUtils &StructCustomizationUtils) override;
	//
	TOptional<float> OnGetValueX() const;
	TOptional<float> OnGetValueY() const;
	TOptional<float> OnGetValueZ() const;
	void OnValueChangeX(float Input) const;
	void OnValueChangeY(float Input) const;
	void OnValueChangeZ(float Input) const;
	void OnSetValueX(float Input, ETextCommit::Type CommitType) const;
	void OnSetValueY(float Input, ETextCommit::Type CommitType) const;
	void OnSetValueZ(float Input, ETextCommit::Type CommitType) const;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define LOCTEXT_NAMESPACE "FSCUE4Editor"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_DELEGATE_OneParam(FOnValueChanged,float);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class SVector2DBox : public SCompoundWidget {
private:
	TAttribute<TOptional<float>> ValueX;
	TAttribute<TOptional<float>> ValueY;
	TOptional<float> GetValueX() const {return ValueX.Get();}
	TOptional<float> GetValueY() const {return ValueY.Get();}
public:
	SLATE_BEGIN_ARGS(SVector2DBox) {}
		SLATE_ATTRIBUTE(TOptional<float>,ValueX)
		SLATE_ATTRIBUTE(TOptional<float>,ValueY)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueX)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueY)
		SLATE_EVENT(FOnValueChanged,OnValueChangeX)
		SLATE_EVENT(FOnValueChanged,OnValueChangeY)
	SLATE_END_ARGS()
	//
	void Construct(const FArguments &InArgs) {
		ValueX = InArgs._ValueX;
		ValueY = InArgs._ValueY;
		//
		this->ChildSlot
		[
			SNew(SVerticalBox)
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(0)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.AllowSpin(true)
					.LabelVAlign(VAlign_Center)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(100)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSV2DXAxisLabel","X"))
					]	
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSV2DXLabelToolTip","X value"))
					.Value(this,&SVector2DBox::GetValueX)
					.OnValueCommitted(InArgs._OnSetValueX)
					.OnValueChanged(InArgs._OnValueChangeX)
				]
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.AllowSpin(true)
					.LabelVAlign(VAlign_Center)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(100)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSV2DYAxisLabel","Y"))
					]
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSV2DYAxisLabelToolTip","Y value"))
					.Value(this,&SVector2DBox::GetValueY)
					.OnValueCommitted(InArgs._OnSetValueY)
					.OnValueChanged(InArgs._OnValueChangeY)
				]
			]
		];
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class SVector3DBox : public SCompoundWidget {
private:
	TAttribute<TOptional<float>> ValueX;
	TAttribute<TOptional<float>> ValueY;
	TAttribute<TOptional<float>> ValueZ;
	TOptional<float> GetValueX() const {return ValueX.Get();}
	TOptional<float> GetValueY() const {return ValueY.Get();}
	TOptional<float> GetValueZ() const {return ValueZ.Get();}
public:
	SLATE_BEGIN_ARGS(SVector3DBox) {}
		SLATE_ATTRIBUTE(TOptional<float>,ValueX)
		SLATE_ATTRIBUTE(TOptional<float>,ValueY)
		SLATE_ATTRIBUTE(TOptional<float>,ValueZ)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueX)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueY)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueZ)
		SLATE_EVENT(FOnValueChanged,OnValueChangeX)
		SLATE_EVENT(FOnValueChanged,OnValueChangeY)
		SLATE_EVENT(FOnValueChanged,OnValueChangeZ)
	SLATE_END_ARGS()
	//
	void Construct(const FArguments &InArgs) {
		ValueX = InArgs._ValueX;
		ValueY = InArgs._ValueY;
		ValueZ = InArgs._ValueZ;
		//
		this->ChildSlot
		[
			SNew(SVerticalBox)
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(0)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.LabelVAlign(VAlign_Center)
					.AllowSpin(true)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(50)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSV3DXAxisLabel","X"))
					]
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSV3DXLabelToolTip","X value"))
					.Value(this,&SVector3DBox::GetValueX)
					.OnValueCommitted(InArgs._OnSetValueX)
					.OnValueChanged(InArgs._OnValueChangeX)
				]
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.LabelVAlign(VAlign_Center)
					.AllowSpin(true)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(50)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSV3DYAxisLabel","Y"))
					]
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSV3DYAxisLabelToolTip","Y value"))
					.Value(this,&SVector3DBox::GetValueY)
					.OnValueCommitted(InArgs._OnSetValueY)
					.OnValueChanged(InArgs._OnValueChangeY)
				]
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.LabelVAlign(VAlign_Center)
					.AllowSpin(true)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(50)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSV3DZAxisLabel","Z"))
					]
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSV3DZAxisLabelToolTip","Z value"))
					.Value(this,&SVector3DBox::GetValueZ)
					.OnValueCommitted(InArgs._OnSetValueZ)
					.OnValueChanged(InArgs._OnValueChangeZ)
				]
			]
		];
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class SVector4DBox : public SCompoundWidget {
private:
	TAttribute<TOptional<float>> ValueX;
	TAttribute<TOptional<float>> ValueY;
	TAttribute<TOptional<float>> ValueZ;
	TAttribute<TOptional<float>> ValueW;
	TOptional<float> GetValueX() const {return ValueX.Get();}
	TOptional<float> GetValueY() const {return ValueY.Get();}
	TOptional<float> GetValueZ() const {return ValueZ.Get();}
	TOptional<float> GetValueW() const {return ValueW.Get();}
public:
	SLATE_BEGIN_ARGS(SVector4DBox) {}
		SLATE_ATTRIBUTE(TOptional<float>,ValueX)
		SLATE_ATTRIBUTE(TOptional<float>,ValueY)
		SLATE_ATTRIBUTE(TOptional<float>,ValueZ)
		SLATE_ATTRIBUTE(TOptional<float>,ValueW)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueX)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueY)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueZ)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueW)
		SLATE_EVENT(FOnValueChanged,OnValueChangeX)
		SLATE_EVENT(FOnValueChanged,OnValueChangeY)
		SLATE_EVENT(FOnValueChanged,OnValueChangeZ)
		SLATE_EVENT(FOnValueChanged,OnValueChangeW)
	SLATE_END_ARGS()
	//
	void Construct(const FArguments &InArgs) {
		ValueX = InArgs._ValueX;
		ValueY = InArgs._ValueY;
		ValueZ = InArgs._ValueZ;
		ValueW = InArgs._ValueW;
		//
		this->ChildSlot
		[
			SNew(SVerticalBox)
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(0)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.LabelVAlign(VAlign_Center)
					.AllowSpin(true)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(50)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSV4DXAxisLabel","X"))
					]
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSV4DXLabelToolTip","X value"))
					.Value(this,&SVector4DBox::GetValueX)
					.OnValueCommitted(InArgs._OnSetValueX)
					.OnValueChanged(InArgs._OnValueChangeX)
				]
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.LabelVAlign(VAlign_Center)
					.AllowSpin(true)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(50)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSV4DYAxisLabel","Y"))
					]
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSV4DYAxisLabelToolTip","Y value"))
					.Value(this,&SVector4DBox::GetValueY)
					.OnValueCommitted(InArgs._OnSetValueY)
					.OnValueChanged(InArgs._OnValueChangeY)
				]
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.LabelVAlign(VAlign_Center)
					.AllowSpin(true)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(50)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSV4DZAxisLabel","Z"))
					]
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSV4DZAxisLabelToolTip","Z value"))
					.Value(this,&SVector4DBox::GetValueZ)
					.OnValueCommitted(InArgs._OnSetValueZ)
					.OnValueChanged(InArgs._OnValueChangeZ)
				]
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.LabelVAlign(VAlign_Center)
					.AllowSpin(true)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(50)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSV4DWAxisLabel","W"))
					]
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSV4DWAxisLabelToolTip","W value"))
					.Value(this,&SVector4DBox::GetValueW)
					.OnValueCommitted(InArgs._OnSetValueW)
					.OnValueChanged(InArgs._OnValueChangeW)
				]
			]
		];
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class SColorBox : public SCompoundWidget {
private:
	TAttribute<TOptional<float>> ValueR;
	TAttribute<TOptional<float>> ValueG;
	TAttribute<TOptional<float>> ValueB;
	TAttribute<TOptional<float>> ValueA;
	TOptional<float> GetValueR() const {return ValueR.Get();}
	TOptional<float> GetValueG() const {return ValueG.Get();}
	TOptional<float> GetValueB() const {return ValueB.Get();}
	TOptional<float> GetValueA() const {return ValueA.Get();}
public:
	SLATE_BEGIN_ARGS(SColorBox) {}
		SLATE_ATTRIBUTE(TOptional<float>,ValueR)
		SLATE_ATTRIBUTE(TOptional<float>,ValueG)
		SLATE_ATTRIBUTE(TOptional<float>,ValueB)
		SLATE_ATTRIBUTE(TOptional<float>,ValueA)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueR)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueG)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueB)
		SLATE_EVENT(FOnFloatValueCommitted,OnSetValueA)
		SLATE_EVENT(FOnValueChanged,OnValueChangeR)
		SLATE_EVENT(FOnValueChanged,OnValueChangeG)
		SLATE_EVENT(FOnValueChanged,OnValueChangeB)
		SLATE_EVENT(FOnValueChanged,OnValueChangeA)
	SLATE_END_ARGS()
	//
	void Construct(const FArguments &InArgs) {
		ValueR = InArgs._ValueR;
		ValueG = InArgs._ValueG;
		ValueB = InArgs._ValueB;
		ValueA = InArgs._ValueA;
		//
		this->ChildSlot
		[
			SNew(SVerticalBox)
			+SVerticalBox::Slot()
			.AutoHeight()
			.Padding(0)
			[
				SNew(SHorizontalBox)
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.LabelVAlign(VAlign_Center)
					.AllowSpin(true)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(50)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSColorRLabel","R"))
					]
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSColorRLabelToolTip","Red value"))
					.Value(this,&SColorBox::GetValueR)
					.OnValueCommitted(InArgs._OnSetValueR)
					.OnValueChanged(InArgs._OnValueChangeR)
				]
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.LabelVAlign(VAlign_Center)
					.AllowSpin(true)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(50)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSColorGLabel","G"))
					]
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSColorGLabelToolTip","Green value"))
					.Value(this,&SColorBox::GetValueG)
					.OnValueCommitted(InArgs._OnSetValueG)
					.OnValueChanged(InArgs._OnValueChangeG)
				]
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.LabelVAlign(VAlign_Center)
					.AllowSpin(true)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(50)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSColorBLabel","B"))
					]
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSColorBLabelToolTip","Blue value"))
					.Value(this,&SColorBox::GetValueB)
					.OnValueCommitted(InArgs._OnSetValueB)
					.OnValueChanged(InArgs._OnValueChangeB)
				]
				+SHorizontalBox::Slot()
				.HAlign(HAlign_Fill)
				.AutoWidth()
				.FillWidth(1)
				.Padding(2)
				[
					SNew(SNumericEntryBox<float>)
					.LabelVAlign(VAlign_Center)
					.AllowSpin(true)
					.MinValue(TNumericLimits<float>::Lowest())
					.MaxValue(TNumericLimits<float>::Max())
					.MinDesiredValueWidth(50)
					.MinSliderValue(TNumericLimits<float>::Lowest())
					.MaxSliderValue(TNumericLimits<float>::Max())
					.Delta(0.1f)
					.Label()
					[
						SNew(STextBlock)
						.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
						.Text(LOCTEXT("FSColorALabel","A"))
					]
					.Font(FEditorStyle::GetFontStyle("Graph.VectorEditableTextBox"))
					.UndeterminedString(LOCTEXT("MultipleValues","Multiple Values"))
					.ToolTipText(LOCTEXT("FSColorALabelToolTip","Alpha value"))
					.Value(this,&SColorBox::GetValueA)
					.OnValueCommitted(InArgs._OnSetValueA)
					.OnValueChanged(InArgs._OnValueChangeA)
				]
			]
		];
	}
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#undef LOCTEXT_NAMESPACE

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/Settings/Public/SCUE4EditorCommands.h`:

```h
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//			Copyright 2016 (C) Bruno Xavier Leite
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once

#include "SlateBasics.h"
#include "SCUE4EditorStyle.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FSCUE4EditorCommands : public TCommands<FSCUE4EditorCommands>
{
public:

	FSCUE4EditorCommands()
		: TCommands<FSCUE4EditorCommands>(TEXT("SCUE4Editor"), NSLOCTEXT("Contexts", "SCUE4Editor", "SCUE4Editor Plugin"), NAME_None, FSCUE4EditorStyle::GetStyleSetName())
	{
	}

	// TCommands<> interface
	virtual void RegisterCommands() override;

public:
	TSharedPtr< FUICommandInfo > PluginAction;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/Settings/Public/SCUE4EditorStyle.h`:

```h
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//			Copyright 2016 (C) Bruno Xavier Leite
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once
#include "SlateBasics.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FSCUE4EditorStyle {
private:
	static TSharedPtr< class FSlateStyleSet > StyleInstance;
	static TSharedRef< class FSlateStyleSet > Create();
public:
	static void Initialize();
	static void Shutdown();
	static void ReloadTextures();
	static const ISlateStyle &Get();
	static FName GetStyleSetName();
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

`Plugins/SCUE4/Source/Settings/SCUE4Editor.Build.cs`:

```cs
using UnrealBuildTool;
using System.IO;

public class SCUE4Editor : ModuleRules {
	public SCUE4Editor(ReadOnlyTargetRules Target) : base(Target) {
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
		PrivatePCHHeaderFile = "Private/SCUE4EditorPrivatePCH.h";
		bEnforceIWYU = true;
		//
		PrivateDependencyModuleNames.AddRange(
			new string[] {
				"Core",
				"Slate",
				"SCUE4",
				"Engine",
				"Projects",
				"UnrealEd",
				"SlateCore",
				"InputCore",
				"EditorStyle",
				"LevelEditor",
				"CoreUObject",
				"PropertyEditor"
			}///
		);//
		//
		PrivateIncludePaths.Add(Path.Combine(ModuleDirectory,"Private"));
		PublicIncludePaths.Add(Path.Combine(ModuleDirectory,"Public"));
	}///
}
```

`Plugins/SCUE4/Source/ThirdParty/SCUE4X.Build.cs`:

```cs
using UnrealBuildTool;
using System.IO;

public class SCUE4X : ModuleRules {
    public SCUE4X(ReadOnlyTargetRules Target) : base(Target) {
        Type = ModuleType.External;
        //
        string DIRx86 = Path.Combine(ModuleDirectory,"x86");
        string DIRx64 = Path.Combine(ModuleDirectory,"x64");
        //
        if ((Target.Platform == UnrealTargetPlatform.Win32) || (Target.Platform == UnrealTargetPlatform.Win64)) {
            if (Target.Platform == UnrealTargetPlatform.Win32) { RuntimeDependencies.Add(Path.Combine(DIRx86,"SCUE4x86.exe")); } else
            if (Target.Platform == UnrealTargetPlatform.Win64) { RuntimeDependencies.Add(Path.Combine(DIRx64,"SCUE4x64.exe")); }
        }
    }
}
```

`README.md`:

```md
# {SCUE4}: Anti-Cheat Plugin for Unreal Engine 4

## Known Limitations:
* Build for UE4 Windows games only (32bit & 64bit); (but it won't break packaging for other platforms).
* Only default ASCII characters are supported for text/string encryption.


## Requirements:
* Both Key Generator and the External Scanner requires VS2015 runtime dependencies to run.
* External Scanner also requires .NET 4 runtime dependencies.


## How To Use:
* Close UE4, unzip the files provided within the 'Plugins' directory into your UE4 game project's folder. Executable libraries and code will be added to your project's Plugins folder;
Then right click your .uproject file and choose 'Generate Visual Studio project files'. Then open the .uproject file; around ~1.6GB of C++ code will be generated, so be patient.
You may have to convert your project to C++ project first, simply adding an empty C++ Class to your game.

* Open your game project in Unreal Editor, click Edit and go to 'Project Settings..'-> 'Maps & Modes'; In 'Game Instance Class' field, set 'SafeGameInstance' class as default.
If you have another custom Game Instance, use it instead, but after installing the Secure-Client plugin you have to re-parent your Game Instance to be a child of SafeGameInstance.
This will activate the anti-cheat system for your game. If you want the anti-cheat tool-set disabled, just replace the default Game Instance again.

* To observe Game-Guard's behaviour while developing in Unreal Editor, and to activate the anti-debugger that is disabled by default, you have to:
- Create or re-parent a GameInstance Blueprint from the 'SafeGameInstance' class and set it as default in Project Settings.
- Uncheck the 'Hide Game-Guard' and 'Allow Debugging' check-boxes from the Details panel.
- You most likely don't want to block debugging while developing your game, uncheck it only when packaging in Shipping Mode and ready to publish.


## FAQs:
° What is the performance impact in game when using SC Safe Types in Blueprint graphs?
- The Safe Types provided to encrypt Blueprint properties have a very insignificant impact in your game code;
- Each call to a Get/Set node has a function footprint ranging from 0.00ms to 0.01 milliseconds. In comparison: a single Tick Event call can sometimes eat up to 4.00ms.

° What about Garbage Collection, how these types deal with GC?
- The code generates no GC, UE4 will fire GC only when you destroy the Blueprint/Actor that was calling the Get/Set functions/nodes.

° Which Types are Safe Type supported?
- You can encrypt the usual types used for Blueprint properties, such as:

* Boolean
* Byte
* Integer
* Float
* Name
* String
* Text
* Vector
* Vector 2D
* Vector 4D
* Linear Color
* Rotator
* Transform

° Does Safe Types support SaveGame tag, to be recorded by the Auto-Save Plugin?
- Yes. Just enable SaveGame tag in advanced tab as usual and you easily get encrypted Save-Game data stored in your .sav files.

° Is networking, replication, supported for Safe Types?
- The idea is Yes, must be, but I'm still working on multiplayer code to make sure everything is bug-free when running in authoritative servers thus I'm not 100% sure on this one.

° Why I mark any Safe Type as 'editable', but values in Details panel are disabled and I can't change them?
- Because Safe Types are hidden and Unreal Engine's Editor doesn't know how to translate their encryption algorithm. Then what Details panel displays there is just a 'fake copy'
- of the real value which is possible to change or read only through the Get/Set node functions. If you could change values from Details panel, hackers could use the same route to
- trace the fake value and use it to change the real, encrypted one, without bothering with any encryption secrets.
- So to say, the only way you can change encrypted values is really through the Get/Set nodes which you can use in Blueprint graphs and/or its Construction Script to set default values.

° What if the Game-Guard external app gets cracked to never return any positives?
- Then your game itself through the SafeGameInstance class will take over and run an internal Game-Guard system; the class is built to force a crash in the game if a malicious app is running.
- This internal built-in code is compiled inside the game, packaged for Windows, and only runs slower than the external scanner, to not generate game-thread overhead.
You don't have to config anything for this, it's automatic; Just setup the required GameInstance class.


----- -----


[More Info]:

https://forums.unrealengine.com/t/plugin-anti-cheat-system/213948

--------------------------------------------------

**Copyright(C) Bruno Xavier B. Leite.**


#### LICENSE

THIS SYSTEM IS NOW PUBLISHED ON UNREAL ENGINE's MARKETPLACE
AND THE SAME THERMS FROM THEM APPLIES.

Please check Epic Games' therms here:
https://publish.unrealengine.com/faq


Unreal Marketplace page:
https://www.unrealengine.com/marketplace/scue4-anti-cheat-solution

```