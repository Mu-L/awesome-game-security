Project Path: arc_gmh5225_VanguardImportResolver_nxnhq1md

Source Tree:

```txt
arc_gmh5225_VanguardImportResolver_nxnhq1md
├── VanguardImportResolver
│   ├── Dependencies
│   │   ├── UdLib
│   │   │   └── UdLib.hpp
│   │   └── Unicorn
│   │       ├── list.h
│   │       ├── qemu.h
│   │       ├── uc_priv.h
│   │       ├── unicorn
│   │       │   ├── arm.h
│   │       │   ├── arm64.h
│   │       │   ├── m68k.h
│   │       │   ├── mips.h
│   │       │   ├── platform.h
│   │       │   ├── ppc.h
│   │       │   ├── riscv.h
│   │       │   ├── s390x.h
│   │       │   ├── sparc.h
│   │       │   ├── tricore.h
│   │       │   ├── unicorn.h
│   │       │   └── x86.h
│   │       └── unicorn.lib
│   ├── Source
│   │   └── Entry.cpp
│   ├── VanguardImportResolver.vcxproj
│   ├── VanguardImportResolver.vcxproj.filters
│   └── VanguardImportResolver.vcxproj.user
└── VanguardImportResolver.sln

```

`VanguardImportResolver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33110.190
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VanguardImportResolver", "VanguardImportResolver\VanguardImportResolver.vcxproj", "{0B76E008-10B8-446E-828F-1FC3FED503EB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0B76E008-10B8-446E-828F-1FC3FED503EB}.Debug|x64.ActiveCfg = Debug|x64
		{0B76E008-10B8-446E-828F-1FC3FED503EB}.Debug|x64.Build.0 = Debug|x64
		{0B76E008-10B8-446E-828F-1FC3FED503EB}.Debug|x86.ActiveCfg = Debug|Win32
		{0B76E008-10B8-446E-828F-1FC3FED503EB}.Debug|x86.Build.0 = Debug|Win32
		{0B76E008-10B8-446E-828F-1FC3FED503EB}.Release|x64.ActiveCfg = Release|x64
		{0B76E008-10B8-446E-828F-1FC3FED503EB}.Release|x64.Build.0 = Release|x64
		{0B76E008-10B8-446E-828F-1FC3FED503EB}.Release|x86.ActiveCfg = Release|Win32
		{0B76E008-10B8-446E-828F-1FC3FED503EB}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9B04CC1C-3877-4A54-A6C0-A50A4535C8BC}
	EndGlobalSection
EndGlobal

```

`VanguardImportResolver/Dependencies/UdLib/UdLib.hpp`:

```hpp
#pragma once
#include <optional>
#include <string>
#include <vector>
#include <array>
#include <algorithm>
#include <string_view>
#include <fstream>
#include <unordered_map>

#include <Windows.h>
#include <winternl.h>

#if defined(_MSC_VER)
#define UD_FORCEINLINE __forceinline
#pragma warning( push )
#pragma warning( disable : 4244 4083 )
#else
#define UD_FORCEINLINE __attribute__( ( always_inline ) )
#endif

#define ud_encode_c( str ) ud::rot::decode( ud::rot::rot_t<str>{ } ).data
#define ud_encode( str ) std::string_view( ud::rot::decode( ud::rot::rot_t<str>{ } ) )

#define ud_xorstr_c( str ) ud::xorstr::decrypt( ud::xorstr::xorstr_t< str, __COUNTER__ + 1 ^ 0x90 >{ } ).data
#define ud_xorstr( str ) std::string_view{ ud::xorstr::decrypt( ud::xorstr::xorstr_t< str, __COUNTER__ + 1 ^ 0x90 >{ } ) }

#define ud_stack_str( str ) ud::details::comp_string_t{ str }.data

#define ud_import( mod, func )	reinterpret_cast< decltype( &func ) >( ud::lazy_import::find_module_export< TEXT( mod ), #func >( ) )
#define ud_first_import( func ) reinterpret_cast< decltype( &func ) >( ud::lazy_import::find_first_export< #func >( ) )

// preprocessed settings due to MSVC (not clang or gcc) throwing errors even in `if constexpr` bodies
#define UD_USE_SEH false

namespace ud
{
    namespace details
    {
        struct LDR_DATA_TABLE_ENTRY32
        {
            LIST_ENTRY in_load_order_links;

            std::uint8_t pad[ 16 ];
            std::uintptr_t dll_base;
            std::uintptr_t entry_point;
            std::size_t size_of_image;

            UNICODE_STRING full_name;
            UNICODE_STRING base_name;
        };

        struct LDR_DATA_TABLE_ENTRY64
        {
            LIST_ENTRY in_load_order_links;
            LIST_ENTRY dummy_0;
            LIST_ENTRY dummy_1;

            std::uintptr_t dll_base;
            std::uintptr_t entry_point;
            union {
                unsigned long size_of_image;
                const char* _dummy;
            };

            UNICODE_STRING full_name;
            UNICODE_STRING base_name;
        };

#if defined( _M_X64 )
        using LDR_DATA_TABLE_ENTRY = LDR_DATA_TABLE_ENTRY64;
#else
        using LDR_DATA_TABLE_ENTRY = LDR_DATA_TABLE_ENTRY32;
#endif

        template < std::size_t sz >
        struct comp_string_t
        {
            std::size_t size = sz;
            char data[ sz ]{ };

            comp_string_t( ) = default;
            consteval explicit comp_string_t( const char( &str )[ sz ] )
            {
                std::copy_n( str, sz, data );
            }

            constexpr explicit operator std::string_view( ) const
            {
                return { data, size };
            }
        };

        template < std::size_t sz >
        struct wcomp_string_t
        {
            std::size_t size = sz;
            wchar_t data[ sz ]{ };

            wcomp_string_t( ) = default;
            consteval explicit wcomp_string_t( const wchar_t( &str )[ sz ] )
            {
                std::copy_n( str, sz, data );
            }

            constexpr explicit operator std::wstring_view( ) const
            {
                return { data, size };
            }
        };

        inline constexpr std::uint64_t multiplier = 0x5bd1e995;
        inline consteval std::uint64_t get_seed( )
        {
            constexpr auto time_str = __TIME__;
            constexpr auto time_len = sizeof( __TIME__ ) - 1;

            constexpr auto time_int = [ ]( const char* const str, const std::size_t len )
            {
                auto res = 0ull;
                for ( auto i = 0u; i < len; ++i )
                    if ( str[ i ] >= '0' && str[ i ] <= '9' )
                        res = res * 10 + str[ i ] - '0';

                return res;
            }(time_str, time_len);

            return time_int;
        }

        template < auto v >
        struct constant_t
        {
            enum : decltype(v)
            {
                value = v
            };
        };

        template < auto v >
        inline constexpr auto constant_v = constant_t< v >::value;

#undef max
#undef min

        template < std::uint32_t seq >
        consteval std::uint64_t recursive_random( )
        {
            constexpr auto seed = get_seed( );
            constexpr auto mask = std::numeric_limits< std::uint64_t >::max( );

            constexpr auto x = ((seq * multiplier) + seed) & mask;
            constexpr auto x_prime = (x >> 0x10) | (x << 0x10);

            return constant_v< x_prime >;
        }
    }

    namespace rot
    {
        template < details::comp_string_t str >
        struct rot_t
        {
            char rotted[ str.size ];

            [[nodiscard]] consteval const char* encoded( ) const
            {
                return rotted;
            }

            consteval rot_t( )
            {
                for ( auto i = 0u; i < str.size; ++i )
                {
                    const auto c = str.data[ i ];
                    const auto set = c >= 'A' && c <= 'Z' ? 'A' : c >= 'a' && c <= 'z' ? 'a' : c;

                    if ( set == 'a' || set == 'A' )
                        rotted[ i ] = (c - set - 13 + 26) % 26 + set;

                    else
                        rotted[ i ] = c;
                }
            }
        };

        template < details::comp_string_t str >
        UD_FORCEINLINE details::comp_string_t< str.size > decode( rot_t< str > encoded )
        {
            details::comp_string_t< str.size > result{ };

            for ( auto i = 0u; i < str.size; ++i )
            {
                const auto c = encoded.rotted[ i ];
                const auto set = c >= 'A' && c <= 'Z' ? 'A' : c >= 'a' && c <= 'z' ? 'a' : c;

                if ( set == 'a' || set == 'A' )
                    result.data[ i ] = (c - set - 13 + 26) % 26 + set;

                else
                    result.data[ i ] = c;
            }

            return result;
        }
    }

    namespace fnv
    {
        inline constexpr std::uint32_t fnv_1a( const char* const str, const std::size_t size )
        {
            constexpr auto prime = 16777619u;

            std::uint32_t hash = 2166136261;

            for ( auto i = 0u; i < size; ++i )
            {
                hash ^= str[ i ];
                hash *= prime;
            }

            return hash;
        }

        inline constexpr std::uint32_t fnv_1a( const wchar_t* const str, const std::size_t size )
        {
            constexpr auto prime = 16777619u;

            std::uint32_t hash = 2166136261;

            for ( auto i = 0u; i < size; ++i )
            {
                hash ^= static_cast< char >(str[ i ]);
                hash *= prime;
            }

            return hash;
        }

        inline constexpr std::uint32_t fnv_1a( const std::wstring_view str )
        {
            return fnv_1a( str.data( ), str.size( ) );
        }

        inline constexpr std::uint32_t fnv_1a( const std::string_view str )
        {
            return fnv_1a( str.data( ), str.size( ) );
        }

        template < details::comp_string_t str >
        consteval std::uint32_t fnv_1a( )
        {
            return fnv_1a( str.data, str.size );
        }

        template < details::wcomp_string_t str >
        consteval std::uint32_t fnv_1a( )
        {
            return fnv_1a( str.data, str.size );
        }
    }

    namespace xorstr
    {
        template < details::comp_string_t str, std::uint32_t key_multiplier >
        struct xorstr_t
        {
            char xored[ str.size ];

            [[nodiscard]] consteval std::uint64_t xor_key( ) const
            {
                return details::recursive_random< key_multiplier >( );
            }

            consteval xorstr_t( )
            {
                for ( auto i = 0u; i < str.size; ++i )
                    xored[ i ] = str.data[ i ] ^ xor_key( );
            }
        };

        template < details::comp_string_t str, std::uint32_t key_multiplier >
        UD_FORCEINLINE details::comp_string_t< str.size > decrypt( xorstr_t< str, key_multiplier > enc )
        {
            details::comp_string_t< str.size > result{ };

            for ( auto i = 0u; i < str.size; ++i )
            {
                const auto c = enc.xored[ i ];

                result.data[ i ] = c ^ enc.xor_key( );
            }

            return result;
        }
    }

    namespace lazy_import
    {
        UD_FORCEINLINE std::uintptr_t get_module_handle( const std::uint64_t hash )
        {
#if defined( _M_X64 )
            const auto peb = reinterpret_cast< const PEB* >(__readgsqword( 0x60 ));
#else
            const auto peb = reinterpret_cast< const PEB* >(__readfsdword( 0x30 ));
#endif

            const auto modules = reinterpret_cast< const LIST_ENTRY* >(peb->Ldr->InMemoryOrderModuleList.Flink);

            for ( auto i = modules->Flink; i != modules; i = i->Flink )
            {
                const auto entry = reinterpret_cast< const details::LDR_DATA_TABLE_ENTRY* >(i);

                const auto name = entry->base_name.Buffer;
                const auto len = entry->base_name.Length;

                if ( fnv::fnv_1a( static_cast< const wchar_t* >(name), len ) == hash )
                    return entry->dll_base;
            }

            return 0;
        }

        UD_FORCEINLINE void* find_primitive_export( const std::uint64_t dll_hash, const std::uint64_t function_hash )
        {
            const auto module = get_module_handle( dll_hash );

            if ( !module )
                return nullptr;

            const auto dos = reinterpret_cast< const IMAGE_DOS_HEADER* >(module);
            const auto nt = reinterpret_cast< const IMAGE_NT_HEADERS* >(module + dos->e_lfanew);

            const auto exports = reinterpret_cast< const IMAGE_EXPORT_DIRECTORY* >(module + nt->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ].VirtualAddress);

            const auto names = reinterpret_cast< const std::uint32_t* >(module + exports->AddressOfNames);
            const auto ordinals = reinterpret_cast< const std::uint16_t* >(module + exports->AddressOfNameOrdinals);
            const auto functions = reinterpret_cast< const std::uint32_t* >(module + exports->AddressOfFunctions);

            for ( auto i = 0u; i < exports->NumberOfNames; ++i )
            {
                const auto name = reinterpret_cast< const char* >(module + names[ i ]);
                std::size_t len = 0;

                for ( ; name[ len ]; ++len );

                if ( fnv::fnv_1a( name, len ) == function_hash )
                    return reinterpret_cast< void* >(module + functions[ ordinals[ i ] ]);
            }

            return nullptr;
        }

        template < details::wcomp_string_t dll_name, details::comp_string_t function_name >
        UD_FORCEINLINE void* find_module_export( )
        {
            return find_primitive_export( fnv::fnv_1a< dll_name >( ), fnv::fnv_1a< function_name >( ) );
        }

        template < details::comp_string_t function_name >
        UD_FORCEINLINE void* find_first_export( )
        {
            constexpr auto function_hash = fnv::fnv_1a< function_name >( );

#if defined( _M_X64 )
            const auto peb = reinterpret_cast< const PEB* >(__readgsqword( 0x60 ));
#else
            const auto peb = reinterpret_cast< const PEB* >(__readfsdword( 0x30 ));
#endif

            const auto modules = reinterpret_cast< const LIST_ENTRY* >(peb->Ldr->InMemoryOrderModuleList.Flink);


            for ( auto i = modules->Flink; i != modules; i = i->Flink )
            {
                const auto entry = reinterpret_cast< const details::LDR_DATA_TABLE_ENTRY* >(i);

                const auto name = entry->base_name.Buffer;
                std::size_t len = 0;

                if ( !name )
                    continue;

                for ( ; name[ len ]; ++len );

                if ( const auto exp = find_primitive_export( fnv::fnv_1a( name, len ), function_hash ) )
                    return exp;
            }

            return nullptr;
        }
    }

    template < typename ty = std::uintptr_t >
    std::optional< ty > find_pattern_primitive( const std::uintptr_t start, const std::uintptr_t end, const std::string_view pattern )
    {
        std::vector< std::pair< bool, std::uint8_t > > bytes;

        for ( auto it = pattern.begin( ); it != pattern.end( ); ++it )
        {
            if ( *it == ' ' )
                continue;

            else if ( *it == '?' )
            {
                if ( it + 1 < pattern.end( ) && *(it + 1) == '?' )
                {
                    bytes.push_back( { true, 0x00 } );
                    ++it;
                }

                else
                    bytes.push_back( { false, 0x00 } );
            }

            else
            {
                if ( it + 1 == pattern.end( ) )
                    break;

                const auto get_byte = [ ]( const std::string& x ) -> std::uint8_t
                {
                    return static_cast< std::uint8_t >(std::stoul( x, nullptr, 16 ));
                };

                bytes.emplace_back( false, get_byte( std::string( it - 1, (++it) + 1 ) ) );
            }
        }

        for ( auto i = reinterpret_cast< const std::uint8_t* >(start); i < reinterpret_cast< const std::uint8_t* >(end); )
        {
            auto found = true;
            for ( const auto& [is_wildcard, byte] : bytes )
            {
                ++i;

                if ( is_wildcard )
                    continue;

                if ( *i != byte )
                {
                    found = false;
                    break;
                }
            }

            if ( found )
                return ty( i - bytes.size( ) + 1 );
        }

        return std::nullopt;
    }

    template < typename ty = std::uintptr_t >
    std::vector< ty > find_patterns_primitive( const std::uintptr_t start, const std::uintptr_t end, const std::string_view pattern )
    {
        std::vector< ty > results;

        std::vector< std::pair< bool, std::uint8_t > > bytes;

        for ( auto it = pattern.begin( ); it != pattern.end( ); ++it )
        {
            if ( *it == ' ' )
                continue;

            else if ( *it == '?' )
            {
                if ( it + 1 < pattern.end( ) && *(it + 1) == '?' )
                {
                    bytes.push_back( { true, 0x00 } );
                    ++it;
                }

                else
                    bytes.push_back( { false, 0x00 } );
            }

            else
            {
                if ( it + 1 == pattern.end( ) )
                    break;

                const auto get_byte = [ ]( const std::string& x ) -> std::uint8_t
                {
                    return static_cast< std::uint8_t >(std::stoul( x, nullptr, 16 ));
                };

                bytes.emplace_back( false, get_byte( std::string( it - 1, (++it) + 1 ) ) );
            }
        }

        for ( auto i = reinterpret_cast< const std::uint8_t* >(start); i < reinterpret_cast< const std::uint8_t* >(end); )
        {
            auto found = true;
            for ( const auto& [is_wildcard, byte] : bytes )
            {
                ++i;

                if ( is_wildcard )
                    continue;

                if ( *i != byte )
                {
                    found = false;
                    break;
                }
            }

            if ( found )
                results.push_back( ty( i - bytes.size( ) + 1 ) );
        }

        return results;
    }

    struct segment_t
    {
        std::string_view name = "";
        std::uintptr_t start{ }, end{ };
        std::size_t size{ };

        template < typename ty = std::uintptr_t >
        std::optional< ty > find_pattern( const std::string_view pattern ) const
        {
            return find_pattern_primitive< ty >( start, end, pattern );
        }

        template < typename ty = std::uintptr_t >
        std::vector< ty > find_patterns( const std::string_view pattern ) const
        {
            return find_patterns_primitive< ty >( start, end, pattern );
        }

        explicit segment_t( const std::string_view segment_name )
        {
            init( GetModuleHandle( nullptr ), segment_name );
        }

        segment_t( const void* const module, const std::string_view segment_name )
        {
            init( module, segment_name );
        }

        segment_t( const void* const handle, const IMAGE_SECTION_HEADER* section )
        {
            init( handle, section );
        }

    private:
        void init( const void* const handle, const IMAGE_SECTION_HEADER* section )
        {
            name = std::string_view( reinterpret_cast< const char* >(section->Name), 8 );
            start = reinterpret_cast< std::uintptr_t >(handle) + section->VirtualAddress;
            end = start + section->Misc.VirtualSize;
            size = section->Misc.VirtualSize;
        }

        void init( const void* const handle, const std::string_view segment_name )
        {
            const auto dos = reinterpret_cast< const IMAGE_DOS_HEADER* >(handle);
            const auto nt = reinterpret_cast< const IMAGE_NT_HEADERS* >(reinterpret_cast< const std::uint8_t* >(handle) + dos->e_lfanew);

            const auto section = reinterpret_cast< const IMAGE_SECTION_HEADER* >(reinterpret_cast< const std::uint8_t* >(&nt->OptionalHeader) + nt->FileHeader.SizeOfOptionalHeader);

            for ( auto i = 0u; i < nt->FileHeader.NumberOfSections; ++i )
            {
                if ( std::string_view( reinterpret_cast< const char* >(section[ i ].Name), 8 ).find( segment_name ) != std::string_view::npos )
                {
                    start = reinterpret_cast< std::uintptr_t >(handle) + section[ i ].VirtualAddress;
                    end = start + section[ i ].Misc.VirtualSize;
                    size = section[ i ].Misc.VirtualSize;
                    name = segment_name;
                    return;
                }
            }
        }
    };

#pragma code_seg( push, ".text" )
    template < auto... bytes>
    struct shellcode_t
    {
        static constexpr std::size_t size = sizeof...(bytes);
        __declspec(allocate(".text")) static constexpr std::uint8_t data[ ]{ bytes... };
    };
#pragma code_seg( pop )

    template < typename ty, auto... bytes >
    constexpr ty make_shellcode( )
    {
        return reinterpret_cast< const ty >(&shellcode_t< bytes... >::data);
    }

    template < std::uint8_t... bytes >
    UD_FORCEINLINE constexpr void emit( )
    {
#if defined( __clang__ ) || defined( __GNUC__ )
        constexpr std::uint8_t data[ ]{ bytes... };

        for ( auto i = 0u; i < sizeof...(bytes); ++i )
            __asm volatile(".byte %c0\t\n" :: "i" (data[ i ]));
#endif
    }

    template < std::size_t size, std::uint32_t seed = __COUNTER__ + 0x69, std::size_t count = 0 >
    UD_FORCEINLINE constexpr void emit_random( )
    {
        if constexpr ( count < size )
        {
            constexpr auto random = details::recursive_random< seed >( );
            emit< static_cast< std::uint8_t >(random) >( );
            emit_random< size, static_cast< std::uint32_t >(random)* seed, count + 1 >( );
        }
    }

    inline bool is_valid_page( const void* const data, const std::uint32_t flags = PAGE_READWRITE )
    {
        MEMORY_BASIC_INFORMATION mbi{ };

        if ( !VirtualQuery( data, &mbi, sizeof( mbi ) ) )
            return false;

        return mbi.Protect & flags;
    }

    struct export_t
    {
        std::string_view name;
        std::uint16_t ordinal{ };
        std::uintptr_t address{ };
    };

    struct module_t
    {
        std::string name;
        std::uintptr_t start, end;
        std::size_t size;

        segment_t operator[ ]( const std::string_view segment_name ) const
        {
            return { reinterpret_cast< const void* >(start), segment_name };
        }

        std::vector< export_t > get_exports( ) const
        {
            const auto dos = reinterpret_cast< const IMAGE_DOS_HEADER* >(start);
            const auto nt = reinterpret_cast< const IMAGE_NT_HEADERS* >(start + dos->e_lfanew);

            const auto directory_header = nt->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];
            if ( !directory_header.VirtualAddress )
                return { };

            const auto export_dir = reinterpret_cast< const IMAGE_EXPORT_DIRECTORY* >(start + directory_header.VirtualAddress);
            const auto name_table = reinterpret_cast< const std::uint32_t* >(start + export_dir->AddressOfNames);
            const auto ord_table = reinterpret_cast< const std::uint16_t* >(start + export_dir->AddressOfNameOrdinals);
            const auto addr_table = reinterpret_cast< const std::uint32_t* >(start + export_dir->AddressOfFunctions);

            std::vector< export_t > exports( export_dir->NumberOfNames );

            for ( auto i = 0u; i < export_dir->NumberOfNames; ++i )
            {
                const auto name_str = reinterpret_cast< const char* >(start + name_table[ i ]);
                const auto ord = ord_table[ i ];
                const auto addr = start + addr_table[ ord ];

                exports[ i ] = { name_str, ord, addr };
            }

            return exports;
        }

        [[nodiscard]] std::vector< segment_t > get_segments( ) const
        {
            const auto dos = reinterpret_cast< const IMAGE_DOS_HEADER* >(start);
            const auto nt = reinterpret_cast< const IMAGE_NT_HEADERS* >(start + dos->e_lfanew);

            const auto section = reinterpret_cast< const IMAGE_SECTION_HEADER* >(reinterpret_cast< const std::uint8_t* >(&nt->OptionalHeader) + nt->FileHeader.SizeOfOptionalHeader);

            std::vector< segment_t > segments;
            segments.reserve( nt->FileHeader.NumberOfSections );

            for ( auto i = 0u; i < nt->FileHeader.NumberOfSections; ++i )
            {
                const segment_t seg( dos, &section[ i ] );
                segments.push_back( seg );
            }

            return segments;
        }

        [[nodiscard]] std::vector< export_t > get_imports( ) const
        {
            const auto dos = reinterpret_cast< const IMAGE_DOS_HEADER* >(start);
            const auto nt = reinterpret_cast< const IMAGE_NT_HEADERS* >(start + dos->e_lfanew);

            const auto directory_header = &nt->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ];
            if ( !directory_header->VirtualAddress )
                return { };

            const auto import_dir = reinterpret_cast< const IMAGE_IMPORT_DESCRIPTOR* >(start + directory_header->VirtualAddress);
            std::vector< export_t > imports;

            for ( auto i = 0u;; ++i )
            {
                if ( !import_dir[ i ].OriginalFirstThunk )
                    break;

                const auto directory = &import_dir[ i ];

                const auto name_table = reinterpret_cast< const std::uint32_t* >(start + directory->OriginalFirstThunk);
                const auto addr_table = reinterpret_cast< const std::uint32_t* >(start + directory->FirstThunk);

                for ( auto j = 0u;; ++j )
                {
                    if ( !addr_table[ j ] )
                        break;

                    if ( !name_table[ j ] )
                        continue;

                    std::string_view name_str;

                    constexpr auto name_alignment = 2;

                    const auto addr = &addr_table[ j ];
                    const auto name_ptr = reinterpret_cast< const char* >(start + name_table[ j ]) + name_alignment;

#if UD_USE_SEH
                    // using SEH here is not a very good solution
                    // however, it's faster than querying that page protection to see if it's readable
                    __try
                    {
                        name = name_ptr;
                    }
                    __except ( EXCEPTION_EXECUTE_HANDLER )
                    {
                        name = "";
                    }
#else
                    // runtime overhead of ~3us compared to SEH on single calls
                    // on bulk calls it can go up to ~300-500us
                    name_str = is_valid_page( name_ptr, PAGE_READONLY ) ? name_ptr : "";
#endif

                    // emplace_back doesn't allow for implicit conversion, so we have to do it manually
                    imports.push_back( { name_str, static_cast< std::uint16_t >(j), reinterpret_cast< std::uintptr_t >(addr) } );
                }
            }

            return imports;
        }

        template < typename ty = std::uintptr_t >
        ty get_address( const std::string_view name ) const
        {
            for ( const auto& export_ : get_exports( ) )
            {
                if ( export_.name.find( name ) != std::string_view::npos )
                    return ty( export_.address );
            }

            return 0;
        }

        template < typename ty = std::uintptr_t >
        std::optional< ty > find_pattern( const std::string_view pattern ) const
        {
            return find_pattern_primitive< ty >( start, end, pattern );
        }

        [[nodiscard]] std::vector< std::string_view > get_strings( const std::size_t minimum_size = 0 ) const
        {
            std::vector< std::string_view > result;

            const auto rdata = (*this)[ ".rdata" ];

            if ( !rdata.size )
                return { };

            const auto start = reinterpret_cast< const std::uint8_t* >(rdata.start);
            const auto end = reinterpret_cast< const std::uint8_t* >(rdata.end);

            for ( auto i = start; i < end; ++i )
            {
                if ( *i == 0 || *i > 127 )
                    continue;

                const auto str = reinterpret_cast< const char* >(i);
                const auto sz = std::strlen( str );

                if ( !sz || sz < minimum_size )
                    continue;

                result.emplace_back( str, sz );
                i += sz;
            }

            return result;
        }

        module_t( )
        {
            init( GetModuleHandle( nullptr ) );
        }

        explicit module_t( void* const handle )
        {
            init( handle );
        }

        explicit module_t( const std::string_view module_name )
        {
            init( GetModuleHandleA( module_name.data( ) ) );
        }

    private:
        void* module;

        void init( void* const handle )
        {
            module = handle;

            const auto dos = reinterpret_cast< const IMAGE_DOS_HEADER* >(handle);
            const auto nt = reinterpret_cast< const IMAGE_NT_HEADERS* >(reinterpret_cast< const std::uint8_t* >(handle) + dos->e_lfanew);

            start = reinterpret_cast< std::uintptr_t >(handle);
            end = start + nt->OptionalHeader.SizeOfImage;
            size = end - start;

            char buffer[ MAX_PATH ];
            const auto sz = GetModuleFileNameA( static_cast< HMODULE >(handle), buffer, MAX_PATH );

            name = sz ? std::string{ buffer, sz } : std::string{ };
        }
    };

    inline std::vector< module_t > get_modules( )
    {
        std::vector< module_t > result;

#if defined( _M_X64 )
        const auto peb = reinterpret_cast< const PEB* >(__readgsqword( 0x60 ));
#else
        const auto peb = reinterpret_cast< const PEB* >(__readfsdword( 0x30 ));
#endif

        const auto modules = reinterpret_cast< const LIST_ENTRY* >(peb->Ldr->InMemoryOrderModuleList.Flink);
        for ( auto i = modules->Flink; i != modules; i = i->Flink )
        {
            const auto entry = reinterpret_cast< const LDR_DATA_TABLE_ENTRY* >(i);

            if ( entry->Reserved2[ 0 ] || entry->DllBase )
                result.emplace_back( entry->Reserved2[ 0 ] ? entry->Reserved2[ 0 ] : entry->DllBase );
        }

        return result;
    }

    inline std::optional< module_t > get_module_at_address( const std::uintptr_t address )
    {
        for ( const auto& module : get_modules( ) )
        {
            if ( module.start <= address && address < module.end )
                return module;
        }

        return std::nullopt;
    }

    inline std::optional< export_t > get_export( const std::uintptr_t address )
    {
        for ( const auto& module : get_modules( ) )
        {
            if ( module.start <= address && address < module.end )
            {
                const auto exports = module.get_exports( );
                for ( const auto& export_ : exports )
                {
                    if ( export_.address == address )
                        return export_;
                }
            }
        }

        return std::nullopt;
    }

    template < typename rel_t, typename ty = std::uintptr_t >
    ty calculate_relative( const std::uintptr_t address, const std::uint8_t size, const std::uint8_t offset )
    {
        return ty( address + *reinterpret_cast< rel_t* >(address + offset) + size );
    }
}

template < std::size_t size >
UD_FORCEINLINE std::ostream& operator<<( std::ostream& os, const ud::details::comp_string_t< size >& str )
{
    return os << std::string_view{ str.data, str.size };
}

#if defined( _MSC_VER )
#pragma warning( pop )
#endif

```

`VanguardImportResolver/Dependencies/Unicorn/list.h`:

```h
#ifndef UC_LLIST_H
#define UC_LLIST_H

#include "unicorn/platform.h"

typedef void (*delete_fn)(void *data);

struct list_item {
    struct list_item *next;
    void *data;
};

struct list {
    struct list_item *head, *tail;
    delete_fn delete_fn;
};

// create a new list
struct list *list_new(void);

// removed linked list nodes but does not free their content
void list_clear(struct list *list);

// insert a new item at the begin of the list.
void *list_insert(struct list *list, void *data);

// append a new item at the end of the list.
void *list_append(struct list *list, void *data);

// returns true if entry was removed, false otherwise
bool list_remove(struct list *list, void *data);

// returns true if the data exists in the list
bool list_exists(struct list *list, void *data);

#endif

```

`VanguardImportResolver/Dependencies/Unicorn/qemu.h`:

```h
/* By Dang Hoang Vu <dang.hvu -at- gmail.com>, 2015 */
/* Modified for Unicorn Engine by Chen Huitao<chenhuitao@hfmrit.com>, 2020 */

#ifndef UC_QEMU_H
#define UC_QEMU_H

struct uc_struct;

#define OPC_BUF_SIZE 640

#include "sysemu/sysemu.h"
#include "sysemu/cpus.h"
#include "exec/cpu-common.h"
#include "exec/memory.h"

#include "qemu/thread.h"
#include "hw/core/cpu.h"

#include "vl.h"

// This struct is originally from qemu/include/exec/ramblock.h
// Temporarily moved here since there is circular inclusion.
struct RAMBlock {
    struct MemoryRegion *mr;
    uint8_t *host;
    ram_addr_t offset;
    ram_addr_t used_length;
    ram_addr_t max_length;
    uint32_t flags;
    /* RCU-enabled, writes protected by the ramlist lock */
    QLIST_ENTRY(RAMBlock) next;
    size_t page_size;
};

typedef struct {
    MemoryRegion *mr;
    void *buffer;
    hwaddr addr;
    hwaddr len;
} BounceBuffer;

// This struct is originally from qemu/include/exec/ramlist.h
typedef struct RAMList {
    RAMBlock *mru_block;
    QLIST_HEAD(, RAMBlock) blocks;
} RAMList;

#endif

```

`VanguardImportResolver/Dependencies/Unicorn/uc_priv.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015 */
/* Modified for Unicorn Engine by Chen Huitao<chenhuitao@hfmrit.com>, 2020 */

#ifndef UC_PRIV_H
#define UC_PRIV_H

#include "unicorn/platform.h"
#include <stdio.h>

#include "qemu.h"
#include "qemu/xxhash.h"
#include "unicorn/unicorn.h"
#include "list.h"

// The max recursive nested uc_emu_start levels
#define UC_MAX_NESTED_LEVEL (64)

// These are masks of supported modes for each cpu/arch.
// They should be updated when changes are made to the uc_mode enum typedef.
#define UC_MODE_ARM_MASK                                                       \
    (UC_MODE_ARM | UC_MODE_THUMB | UC_MODE_LITTLE_ENDIAN | UC_MODE_MCLASS |    \
     UC_MODE_ARM926 | UC_MODE_ARM946 | UC_MODE_ARM1176 | UC_MODE_BIG_ENDIAN |  \
     UC_MODE_ARMBE8)
#define UC_MODE_MIPS_MASK                                                      \
    (UC_MODE_MIPS32 | UC_MODE_MIPS64 | UC_MODE_LITTLE_ENDIAN |                 \
     UC_MODE_BIG_ENDIAN)
#define UC_MODE_X86_MASK                                                       \
    (UC_MODE_16 | UC_MODE_32 | UC_MODE_64 | UC_MODE_LITTLE_ENDIAN)
#define UC_MODE_PPC_MASK (UC_MODE_PPC32 | UC_MODE_PPC64 | UC_MODE_BIG_ENDIAN)
#define UC_MODE_SPARC_MASK                                                     \
    (UC_MODE_SPARC32 | UC_MODE_SPARC64 | UC_MODE_BIG_ENDIAN)
#define UC_MODE_M68K_MASK (UC_MODE_BIG_ENDIAN)
#define UC_MODE_RISCV_MASK                                                     \
    (UC_MODE_RISCV32 | UC_MODE_RISCV64 | UC_MODE_LITTLE_ENDIAN)
#define UC_MODE_S390X_MASK (UC_MODE_BIG_ENDIAN)
#define UC_MODE_TRICORE_MASK (UC_MODE_LITTLE_ENDIAN)

#define ARR_SIZE(a) (sizeof(a) / sizeof(a[0]))

#define READ_QWORD(x) ((uint64_t)x)
#define READ_DWORD(x) (x & 0xffffffff)
#define READ_WORD(x) (x & 0xffff)
#define READ_BYTE_H(x) ((x & 0xffff) >> 8)
#define READ_BYTE_L(x) (x & 0xff)
#define WRITE_DWORD(x, w) (x = (x & ~0xffffffffLL) | (w & 0xffffffff))
#define WRITE_WORD(x, w) (x = (x & ~0xffff) | (w & 0xffff))
#define WRITE_BYTE_H(x, b) (x = (x & ~0xff00) | ((b & 0xff) << 8))
#define WRITE_BYTE_L(x, b) (x = (x & ~0xff) | (b & 0xff))

struct TranslationBlock;

// Place the struct here since we need it in uc.c
typedef struct _mmio_cbs {
    uc_cb_mmio_read_t read;
    void *user_data_read;
    uc_cb_mmio_write_t write;
    void *user_data_write;
    MemoryRegionOps ops;
} mmio_cbs;

typedef uc_err (*query_t)(struct uc_struct *uc, uc_query_type type,
                          size_t *result);

// return 0 on success, -1 on failure
typedef int (*reg_read_t)(struct uc_struct *uc, unsigned int *regs, void **vals,
                          int count);
typedef int (*reg_write_t)(struct uc_struct *uc, unsigned int *regs,
                           void *const *vals, int count);

typedef int (*context_reg_read_t)(struct uc_context *ctx, unsigned int *regs,
                                  void **vals, int count);
typedef int (*context_reg_write_t)(struct uc_context *ctx, unsigned int *regs,
                                   void *const *vals, int count);
typedef struct {
    context_reg_read_t context_reg_read;
    context_reg_write_t context_reg_write;
} context_reg_rw_t;

typedef void (*reg_reset_t)(struct uc_struct *uc);

typedef bool (*uc_write_mem_t)(AddressSpace *as, hwaddr addr,
                               const uint8_t *buf, int len);

typedef bool (*uc_read_mem_t)(AddressSpace *as, hwaddr addr, uint8_t *buf,
                              int len);

typedef void (*uc_args_void_t)(void *);

typedef void (*uc_args_uc_t)(struct uc_struct *);
typedef void (*uc_args_int_uc_t)(struct uc_struct *);

typedef void (*uc_args_uc_long_t)(struct uc_struct *, unsigned long);

typedef void (*uc_args_uc_u64_t)(struct uc_struct *, uint64_t addr);

typedef uint64_t (*uc_get_pc_t)(struct uc_struct *);

typedef MemoryRegion *(*uc_args_uc_ram_size_t)(struct uc_struct *, hwaddr begin,
                                               size_t size, uint32_t perms);

typedef MemoryRegion *(*uc_args_uc_ram_size_ptr_t)(struct uc_struct *,
                                                   hwaddr begin, size_t size,
                                                   uint32_t perms, void *ptr);

typedef void (*uc_mem_unmap_t)(struct uc_struct *, MemoryRegion *mr);

typedef void (*uc_readonly_mem_t)(MemoryRegion *mr, bool readonly);

typedef int (*uc_cpus_init)(struct uc_struct *, const char *);

typedef MemoryRegion *(*uc_memory_map_io_t)(struct uc_struct *uc,
                                            ram_addr_t begin, size_t size,
                                            uc_cb_mmio_read_t read_cb,
                                            uc_cb_mmio_write_t write_cb,
                                            void *user_data_read,
                                            void *user_data_write);

// which interrupt should make emulation stop?
typedef bool (*uc_args_int_t)(struct uc_struct *uc, int intno);

// some architecture redirect virtual memory to physical memory like Mips
typedef uint64_t (*uc_mem_redirect_t)(uint64_t address);

// validate if Unicorn supports hooking a given instruction
typedef bool (*uc_insn_hook_validate)(uint32_t insn_enum);

typedef bool (*uc_opcode_hook_validate_t)(uint32_t op, uint32_t flags);

// init target page
typedef void (*uc_target_page_init)(struct uc_struct *);

// soft float init
typedef void (*uc_softfloat_initialize)(void);

// tcg flush softmmu tlb
typedef void (*uc_tcg_flush_tlb)(struct uc_struct *uc);

// Invalidate the TB at given address
typedef void (*uc_invalidate_tb_t)(struct uc_struct *uc, uint64_t start,
                                   size_t len);

// Request generating TB at given address
typedef uc_err (*uc_gen_tb_t)(struct uc_struct *uc, uint64_t pc, uc_tb *out_tb);

// tb flush
typedef uc_tcg_flush_tlb uc_tb_flush_t;

struct hook {
    int type;       // UC_HOOK_*
    int insn;       // instruction for HOOK_INSN
    int refs;       // reference count to free hook stored in multiple lists
    int op;         // opcode for HOOK_TCG_OPCODE
    int op_flags;   // opcode flags for HOOK_TCG_OPCODE
    bool to_delete; // set to true when the hook is deleted by the user. The
                    // destruction of the hook is delayed.
    uint64_t begin, end; // only trigger if PC or memory access is in this
                         // address (depends on hook type)
    void *callback;      // a uc_cb_* type
    void *user_data;
    GHashTable *hooked_regions; // The regions this hook instrumented on
};

// Add an inline hook to helper_table
typedef void (*uc_add_inline_hook_t)(struct uc_struct *uc, struct hook *hk,
                                     void **args, int args_len);

// Delete a hook from helper_table
typedef void (*uc_del_inline_hook_t)(struct uc_struct *uc, struct hook *hk);

// Return the size of a CPU context
typedef size_t (*uc_context_size_t)(struct uc_struct *uc);

// Generate a CPU context
typedef uc_err (*uc_context_save_t)(struct uc_struct *uc, uc_context *context);

// Restore a CPU context
typedef uc_err (*uc_context_restore_t)(struct uc_struct *uc,
                                       uc_context *context);

// hook list offsets
//
// The lowest 6 bits are used for hook type index while the others
// are used for hook flags.
//
// mirrors the order of uc_hook_type from include/unicorn/unicorn.h
typedef enum uc_hook_idx {
    UC_HOOK_INTR_IDX,
    UC_HOOK_INSN_IDX,
    UC_HOOK_CODE_IDX,
    UC_HOOK_BLOCK_IDX,
    UC_HOOK_MEM_READ_UNMAPPED_IDX,
    UC_HOOK_MEM_WRITE_UNMAPPED_IDX,
    UC_HOOK_MEM_FETCH_UNMAPPED_IDX,
    UC_HOOK_MEM_READ_PROT_IDX,
    UC_HOOK_MEM_WRITE_PROT_IDX,
    UC_HOOK_MEM_FETCH_PROT_IDX,
    UC_HOOK_MEM_READ_IDX,
    UC_HOOK_MEM_WRITE_IDX,
    UC_HOOK_MEM_FETCH_IDX,
    UC_HOOK_MEM_READ_AFTER_IDX,
    UC_HOOK_INSN_INVALID_IDX,
    UC_HOOK_EDGE_GENERATED_IDX,
    UC_HOOK_TCG_OPCODE_IDX,

    UC_HOOK_MAX,
} uc_hook_idx;

// Copy the essential information from TranslationBlock
#define UC_TB_COPY(uc_tb, tb)                                                  \
    do {                                                                       \
        (uc_tb)->pc = tb->pc;                                                  \
        (uc_tb)->icount = tb->icount;                                          \
        (uc_tb)->size = tb->size;                                              \
    } while (0)

// The lowest 6 bits are used for hook type index.
#define UC_HOOK_IDX_MASK ((1 << 6) - 1)

// hook flags
#define UC_HOOK_FLAG_NO_STOP                                                   \
    (1 << 6) // Don't stop emulation in this uc_tracecode.

// The rest of bits are reserved for hook flags.
#define UC_HOOK_FLAG_MASK (~(UC_HOOK_IDX_MASK))

#define HOOK_FOREACH_VAR_DECLARE struct list_item *cur

// for loop macro to loop over hook lists
#define HOOK_FOREACH(uc, hh, idx)                                              \
    for (cur = (uc)->hook[idx##_IDX].head;                                     \
         cur != NULL && ((hh) = (struct hook *)cur->data); cur = cur->next)

// if statement to check hook bounds
#define HOOK_BOUND_CHECK(hh, addr)                                             \
    ((((addr) >= (hh)->begin && (addr) <= (hh)->end) ||                        \
      (hh)->begin > (hh)->end) &&                                              \
     !((hh)->to_delete))

#define HOOK_EXISTS(uc, idx) ((uc)->hook[idx##_IDX].head != NULL)
#define HOOK_EXISTS_BOUNDED(uc, idx, addr)                                     \
    _hook_exists_bounded((uc)->hook[idx##_IDX].head, addr)

static inline bool _hook_exists_bounded(struct list_item *cur, uint64_t addr)
{
    while (cur != NULL) {
        if (HOOK_BOUND_CHECK((struct hook *)cur->data, addr))
            return true;
        cur = cur->next;
    }
    return false;
}

// relloc increment, KEEP THIS A POWER OF 2!
#define MEM_BLOCK_INCR 32

typedef struct TargetPageBits TargetPageBits;
typedef struct TCGContext TCGContext;

struct uc_struct {
    uc_arch arch;
    uc_mode mode;
    uc_err errnum; // qemu/cpu-exec.c
    AddressSpace address_space_memory;
    AddressSpace address_space_io;
    query_t query;
    reg_read_t reg_read;
    reg_write_t reg_write;
    reg_reset_t reg_reset;

    uc_write_mem_t write_mem;
    uc_read_mem_t read_mem;
    uc_args_void_t release;  // release resource when uc_close()
    uc_args_uc_u64_t set_pc; // set PC for tracecode
    uc_get_pc_t get_pc;
    uc_args_int_t
        stop_interrupt; // check if the interrupt should stop emulation
    uc_memory_map_io_t memory_map_io;

    uc_args_uc_t init_arch, cpu_exec_init_all;
    uc_args_int_uc_t vm_start;
    uc_args_uc_long_t tcg_exec_init;
    uc_args_uc_ram_size_t memory_map;
    uc_args_uc_ram_size_ptr_t memory_map_ptr;
    uc_mem_unmap_t memory_unmap;
    uc_readonly_mem_t readonly_mem;
    uc_mem_redirect_t mem_redirect;
    uc_cpus_init cpus_init;
    uc_target_page_init target_page;
    uc_softfloat_initialize softfloat_initialize;
    uc_tcg_flush_tlb tcg_flush_tlb;
    uc_invalidate_tb_t uc_invalidate_tb;
    uc_gen_tb_t uc_gen_tb;
    uc_tb_flush_t tb_flush;
    uc_add_inline_hook_t add_inline_hook;
    uc_del_inline_hook_t del_inline_hook;

    uc_context_size_t context_size;
    uc_context_save_t context_save;
    uc_context_restore_t context_restore;

    /*  only 1 cpu in unicorn,
        do not need current_cpu to handle current running cpu. */
    CPUState *cpu;

    uc_insn_hook_validate insn_hook_validate;
    uc_opcode_hook_validate_t opcode_hook_invalidate;

    MemoryRegion *system_memory;    // qemu/exec.c
    MemoryRegion *system_io;        // qemu/exec.c
    MemoryRegion io_mem_unassigned; // qemu/exec.c
    RAMList ram_list;               // qemu/exec.c
    /* qemu/exec.c */
    unsigned int alloc_hint;
    /* qemu/exec-vary.c */
    TargetPageBits *init_target_page;
    int target_bits; // User defined page bits by uc_ctl
    int cpu_model;
    BounceBuffer bounce;                // qemu/cpu-exec.c
    volatile sig_atomic_t exit_request; // qemu/cpu-exec.c
    /* qemu/accel/tcg/cpu-exec-common.c */
    /* always be true after call tcg_exec_init(). */
    bool tcg_allowed;
    /* This is a multi-level map on the virtual address space.
       The bottom level has pointers to PageDesc.  */
    void **l1_map; // qemu/accel/tcg/translate-all.c
    size_t l1_map_size;
    /* qemu/accel/tcg/translate-all.c */
    int v_l1_size;
    int v_l1_shift;
    int v_l2_levels;
    /* code generation context */
    TCGContext *tcg_ctx;
    /* memory.c */
    QTAILQ_HEAD(memory_listeners, MemoryListener) memory_listeners;
    QTAILQ_HEAD(, AddressSpace) address_spaces;
    GHashTable *flat_views;
    bool memory_region_update_pending;

    // linked lists containing hooks per type
    struct list hook[UC_HOOK_MAX];
    struct list hooks_to_del;
    int hooks_count[UC_HOOK_MAX];

    // hook to count number of instructions for uc_emu_start()
    uc_hook count_hook;

    size_t emu_counter; // current counter of uc_emu_start()
    size_t emu_count;   // save counter of uc_emu_start()

    int size_recur_mem; // size for mem access when in a recursive call

    bool init_tcg;       // already initialized local TCGv variables?
    bool stop_request;   // request to immediately stop emulation - for
                         // uc_emu_stop()
    bool quit_request;   // request to quit the current TB, but continue to
                         // emulate - for uc_mem_protect()
    bool emulation_done; // emulation is done by uc_emu_start()
    bool timed_out;      // emulation timed out, that can retrieve via
                         // uc_query(UC_QUERY_TIMEOUT)
    QemuThread timer;    // timer for emulation timeout
    uint64_t timeout;    // timeout for uc_emu_start()

    uint64_t invalid_addr; // invalid address to be accessed
    int invalid_error;     // invalid memory code: 1 = READ, 2 = WRITE, 3 = CODE

    int use_exits;
    uint64_t exits[UC_MAX_NESTED_LEVEL]; // When multiple exits is not enabled.
    GTree *ctl_exits; // addresses where emulation stops (@until param of
                      // uc_emu_start()) Also see UC_CTL_USE_EXITS for more
                      // details.

    int thumb; // thumb mode for ARM
    MemoryRegion **mapped_blocks;
    uint32_t mapped_block_count;
    uint32_t mapped_block_cache_index;
    void *qemu_thread_data; // to support cross compile to Windows
                            // (qemu-thread-win32.c)
    uint32_t target_page_size;
    uint32_t target_page_align;
    uint64_t qemu_host_page_size;
    uint64_t qemu_real_host_page_size;
    int qemu_icache_linesize;
    /* ARCH_REGS_STORAGE_SIZE */
    int cpu_context_size;
    uint64_t next_pc; // save next PC for some special cases
    bool hook_insert; // insert new hook at begin of the hook list (append by
                      // default)
    bool first_tb; // is this the first Translation-Block ever generated since
                   // uc_emu_start()?
    bool no_exit_request; // Disable check_exit_request temporarily. A
                          // workaround to treat the IT block as a whole block.
    bool init_done;       // Whether the initialization is done.

    sigjmp_buf jmp_bufs[UC_MAX_NESTED_LEVEL]; // To support nested uc_emu_start
    int nested_level;                         // Current nested_level

    struct TranslationBlock *last_tb; // The real last tb we executed.

    FlatView *empty_view; // Static function variable moved from flatviews_init
};

// Metadata stub for the variable-size cpu context used with uc_context_*()
struct uc_context {
    size_t context_size; // size of the real internal context structure
    uc_mode mode;        // the mode of this context
    uc_arch arch;        // the arch of this context
    char data[0];        // context
};

// check if this address is mapped in (via uc_mem_map())
MemoryRegion *memory_mapping(struct uc_struct *uc, uint64_t address);

// We have to support 32bit system so we can't hold uint64_t on void*
static inline void uc_add_exit(uc_engine *uc, uint64_t addr)
{
    uint64_t *new_exit = g_malloc(sizeof(uint64_t));
    *new_exit = addr;
    g_tree_insert(uc->ctl_exits, (gpointer)new_exit, (gpointer)1);
}

// This function has to exist since we would like to accept uint32_t or
// it's complex to achieve so.
static inline int uc_addr_is_exit(uc_engine *uc, uint64_t addr)
{
    if (uc->use_exits) {
        return g_tree_lookup(uc->ctl_exits, (gpointer)(&addr)) == (gpointer)1;
    } else {
        return uc->exits[uc->nested_level - 1] == addr;
    }
}

typedef struct HookedRegion {
    uint64_t start;
    uint64_t length;
} HookedRegion;

// hooked_regions related functions
static inline guint hooked_regions_hash(const void *p)
{
    HookedRegion *region = (HookedRegion *)p;

    return qemu_xxhash4(region->start, region->length);
}

static inline gboolean hooked_regions_equal(const void *lhs, const void *rhs)
{
    HookedRegion *l = (HookedRegion *)lhs;
    HookedRegion *r = (HookedRegion *)rhs;

    return l->start == r->start && l->length == r->length;
}

static inline void hooked_regions_add(struct hook *h, uint64_t start,
                                      uint64_t length)
{
    HookedRegion tmp;
    tmp.start = start;
    tmp.length = length;

    if (!g_hash_table_lookup(h->hooked_regions, (void *)&tmp)) {
        HookedRegion *r = malloc(sizeof(HookedRegion));
        r->start = start;
        r->length = length;
        g_hash_table_insert(h->hooked_regions, (void *)r, (void *)1);
    }
}

static inline void hooked_regions_check_single(struct list_item *cur,
                                               uint64_t start, uint64_t length)
{
    while (cur != NULL) {
        if (HOOK_BOUND_CHECK((struct hook *)cur->data, start)) {
            hooked_regions_add((struct hook *)cur->data, start, length);
        }
        cur = cur->next;
    }
}

static inline void hooked_regions_check(uc_engine *uc, uint64_t start,
                                        uint64_t length)
{
    // Only UC_HOOK_BLOCK and UC_HOOK_CODE might be wrongle cached!
    hooked_regions_check_single(uc->hook[UC_HOOK_CODE_IDX].head, start, length);
    hooked_regions_check_single(uc->hook[UC_HOOK_BLOCK_IDX].head, start,
                                length);
}

#ifdef UNICORN_TRACER
#define UC_TRACE_START(loc) trace_start(get_tracer(), loc)
#define UC_TRACE_END(loc, fmt, ...)                                            \
    trace_end(get_tracer(), loc, fmt, __VA_ARGS__)

typedef enum trace_loc {
    UC_TRACE_TB_EXEC = 0,
    UC_TRACE_TB_TRANS,
    UC_TRACER_MAX
} trace_loc;

typedef struct uc_tracer {
    int64_t starts[UC_TRACER_MAX];
} uc_tracer;

uc_tracer *get_tracer();

void trace_start(uc_tracer *tracer, trace_loc loc);

void trace_end(uc_tracer *tracer, trace_loc loc, const char *fmt, ...);

#else
#define UC_TRACE_START(loc)
#define UC_TRACE_END(loc, fmt, ...)
#endif

#endif
/* vim: set ts=4 noet:  */

```

`VanguardImportResolver/Dependencies/Unicorn/unicorn/arm.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_ARM_H
#define UNICORN_ARM_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> ARM CPU
typedef enum uc_cpu_arm {
    UC_CPU_ARM_926 = 0,
    UC_CPU_ARM_946,
    UC_CPU_ARM_1026,
    UC_CPU_ARM_1136_R2,
    UC_CPU_ARM_1136,
    UC_CPU_ARM_1176,
    UC_CPU_ARM_11MPCORE,
    UC_CPU_ARM_CORTEX_M0,
    UC_CPU_ARM_CORTEX_M3,
    UC_CPU_ARM_CORTEX_M4,
    UC_CPU_ARM_CORTEX_M7,
    UC_CPU_ARM_CORTEX_M33,
    UC_CPU_ARM_CORTEX_R5,
    UC_CPU_ARM_CORTEX_R5F,
    UC_CPU_ARM_CORTEX_A7,
    UC_CPU_ARM_CORTEX_A8,
    UC_CPU_ARM_CORTEX_A9,
    UC_CPU_ARM_CORTEX_A15,
    UC_CPU_ARM_TI925T,
    UC_CPU_ARM_SA1100,
    UC_CPU_ARM_SA1110,
    UC_CPU_ARM_PXA250,
    UC_CPU_ARM_PXA255,
    UC_CPU_ARM_PXA260,
    UC_CPU_ARM_PXA261,
    UC_CPU_ARM_PXA262,
    UC_CPU_ARM_PXA270,
    UC_CPU_ARM_PXA270A0,
    UC_CPU_ARM_PXA270A1,
    UC_CPU_ARM_PXA270B0,
    UC_CPU_ARM_PXA270B1,
    UC_CPU_ARM_PXA270C0,
    UC_CPU_ARM_PXA270C5,
    UC_CPU_ARM_MAX,

    UC_CPU_ARM_ENDING
} uc_cpu_arm;

// ARM coprocessor registers, use this with UC_ARM_REG_CP_REG to
// in call to uc_reg_write/read() to access the registers.
typedef struct uc_arm_cp_reg {
    uint32_t cp;   // The coprocessor identifier
    uint32_t is64; // Is it a 64 bit control register
    uint32_t sec;  // Security state
    uint32_t crn;  // Coprocessor register number
    uint32_t crm;  // Coprocessor register number
    uint32_t opc1; // Opcode1
    uint32_t opc2; // Opcode2
    uint64_t val;  // The value to read/write
} uc_arm_cp_reg;

//> ARM registers
typedef enum uc_arm_reg {
    UC_ARM_REG_INVALID = 0,
    UC_ARM_REG_APSR,
    UC_ARM_REG_APSR_NZCV,
    UC_ARM_REG_CPSR,
    UC_ARM_REG_FPEXC,
    UC_ARM_REG_FPINST,
    UC_ARM_REG_FPSCR,
    UC_ARM_REG_FPSCR_NZCV,
    UC_ARM_REG_FPSID,
    UC_ARM_REG_ITSTATE,
    UC_ARM_REG_LR,
    UC_ARM_REG_PC,
    UC_ARM_REG_SP,
    UC_ARM_REG_SPSR,
    UC_ARM_REG_D0,
    UC_ARM_REG_D1,
    UC_ARM_REG_D2,
    UC_ARM_REG_D3,
    UC_ARM_REG_D4,
    UC_ARM_REG_D5,
    UC_ARM_REG_D6,
    UC_ARM_REG_D7,
    UC_ARM_REG_D8,
    UC_ARM_REG_D9,
    UC_ARM_REG_D10,
    UC_ARM_REG_D11,
    UC_ARM_REG_D12,
    UC_ARM_REG_D13,
    UC_ARM_REG_D14,
    UC_ARM_REG_D15,
    UC_ARM_REG_D16,
    UC_ARM_REG_D17,
    UC_ARM_REG_D18,
    UC_ARM_REG_D19,
    UC_ARM_REG_D20,
    UC_ARM_REG_D21,
    UC_ARM_REG_D22,
    UC_ARM_REG_D23,
    UC_ARM_REG_D24,
    UC_ARM_REG_D25,
    UC_ARM_REG_D26,
    UC_ARM_REG_D27,
    UC_ARM_REG_D28,
    UC_ARM_REG_D29,
    UC_ARM_REG_D30,
    UC_ARM_REG_D31,
    UC_ARM_REG_FPINST2,
    UC_ARM_REG_MVFR0,
    UC_ARM_REG_MVFR1,
    UC_ARM_REG_MVFR2,
    UC_ARM_REG_Q0,
    UC_ARM_REG_Q1,
    UC_ARM_REG_Q2,
    UC_ARM_REG_Q3,
    UC_ARM_REG_Q4,
    UC_ARM_REG_Q5,
    UC_ARM_REG_Q6,
    UC_ARM_REG_Q7,
    UC_ARM_REG_Q8,
    UC_ARM_REG_Q9,
    UC_ARM_REG_Q10,
    UC_ARM_REG_Q11,
    UC_ARM_REG_Q12,
    UC_ARM_REG_Q13,
    UC_ARM_REG_Q14,
    UC_ARM_REG_Q15,
    UC_ARM_REG_R0,
    UC_ARM_REG_R1,
    UC_ARM_REG_R2,
    UC_ARM_REG_R3,
    UC_ARM_REG_R4,
    UC_ARM_REG_R5,
    UC_ARM_REG_R6,
    UC_ARM_REG_R7,
    UC_ARM_REG_R8,
    UC_ARM_REG_R9,
    UC_ARM_REG_R10,
    UC_ARM_REG_R11,
    UC_ARM_REG_R12,
    UC_ARM_REG_S0,
    UC_ARM_REG_S1,
    UC_ARM_REG_S2,
    UC_ARM_REG_S3,
    UC_ARM_REG_S4,
    UC_ARM_REG_S5,
    UC_ARM_REG_S6,
    UC_ARM_REG_S7,
    UC_ARM_REG_S8,
    UC_ARM_REG_S9,
    UC_ARM_REG_S10,
    UC_ARM_REG_S11,
    UC_ARM_REG_S12,
    UC_ARM_REG_S13,
    UC_ARM_REG_S14,
    UC_ARM_REG_S15,
    UC_ARM_REG_S16,
    UC_ARM_REG_S17,
    UC_ARM_REG_S18,
    UC_ARM_REG_S19,
    UC_ARM_REG_S20,
    UC_ARM_REG_S21,
    UC_ARM_REG_S22,
    UC_ARM_REG_S23,
    UC_ARM_REG_S24,
    UC_ARM_REG_S25,
    UC_ARM_REG_S26,
    UC_ARM_REG_S27,
    UC_ARM_REG_S28,
    UC_ARM_REG_S29,
    UC_ARM_REG_S30,
    UC_ARM_REG_S31,

    UC_ARM_REG_C1_C0_2,  // Depreciated, use UC_ARM_REG_CP_REG instead
    UC_ARM_REG_C13_C0_2, // Depreciated, use UC_ARM_REG_CP_REG instead
    UC_ARM_REG_C13_C0_3, // Depreciated, use UC_ARM_REG_CP_REG instead

    UC_ARM_REG_IPSR,
    UC_ARM_REG_MSP,
    UC_ARM_REG_PSP,
    UC_ARM_REG_CONTROL,
    UC_ARM_REG_IAPSR,
    UC_ARM_REG_EAPSR,
    UC_ARM_REG_XPSR,
    UC_ARM_REG_EPSR,
    UC_ARM_REG_IEPSR,
    UC_ARM_REG_PRIMASK,
    UC_ARM_REG_BASEPRI,
    UC_ARM_REG_BASEPRI_MAX,
    UC_ARM_REG_FAULTMASK,
    UC_ARM_REG_APSR_NZCVQ,
    UC_ARM_REG_APSR_G,
    UC_ARM_REG_APSR_NZCVQG,
    UC_ARM_REG_IAPSR_NZCVQ,
    UC_ARM_REG_IAPSR_G,
    UC_ARM_REG_IAPSR_NZCVQG,
    UC_ARM_REG_EAPSR_NZCVQ,
    UC_ARM_REG_EAPSR_G,
    UC_ARM_REG_EAPSR_NZCVQG,
    UC_ARM_REG_XPSR_NZCVQ,
    UC_ARM_REG_XPSR_G,
    UC_ARM_REG_XPSR_NZCVQG,
    UC_ARM_REG_CP_REG,
    UC_ARM_REG_ENDING, // <-- mark the end of the list or registers

    //> alias registers
    UC_ARM_REG_R13 = UC_ARM_REG_SP,
    UC_ARM_REG_R14 = UC_ARM_REG_LR,
    UC_ARM_REG_R15 = UC_ARM_REG_PC,

    UC_ARM_REG_SB = UC_ARM_REG_R9,
    UC_ARM_REG_SL = UC_ARM_REG_R10,
    UC_ARM_REG_FP = UC_ARM_REG_R11,
    UC_ARM_REG_IP = UC_ARM_REG_R12,
} uc_arm_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`VanguardImportResolver/Dependencies/Unicorn/unicorn/arm64.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_ARM64_H
#define UNICORN_ARM64_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> ARM64 CPU
typedef enum uc_cpu_arm64 {
    UC_CPU_ARM64_A57 = 0,
    UC_CPU_ARM64_A53,
    UC_CPU_ARM64_A72,
    UC_CPU_ARM64_MAX,

    UC_CPU_ARM64_ENDING
} uc_cpu_arm64;

// ARM64 coprocessor registers, use this with UC_ARM64_REG_CP_REG to
// in call to uc_reg_write/read() to access the registers.
typedef struct uc_arm64_cp_reg {
    uint32_t crn; // Coprocessor register number
    uint32_t crm; // Coprocessor register number
    uint32_t op0; // Opcode0
    uint32_t op1; // Opcode1
    uint32_t op2; // Opcode2
    uint64_t val; // The value to read/write
} uc_arm64_cp_reg;

//> ARM64 registers
typedef enum uc_arm64_reg {
    UC_ARM64_REG_INVALID = 0,

    UC_ARM64_REG_X29,
    UC_ARM64_REG_X30,
    UC_ARM64_REG_NZCV,
    UC_ARM64_REG_SP,
    UC_ARM64_REG_WSP,
    UC_ARM64_REG_WZR,
    UC_ARM64_REG_XZR,
    UC_ARM64_REG_B0,
    UC_ARM64_REG_B1,
    UC_ARM64_REG_B2,
    UC_ARM64_REG_B3,
    UC_ARM64_REG_B4,
    UC_ARM64_REG_B5,
    UC_ARM64_REG_B6,
    UC_ARM64_REG_B7,
    UC_ARM64_REG_B8,
    UC_ARM64_REG_B9,
    UC_ARM64_REG_B10,
    UC_ARM64_REG_B11,
    UC_ARM64_REG_B12,
    UC_ARM64_REG_B13,
    UC_ARM64_REG_B14,
    UC_ARM64_REG_B15,
    UC_ARM64_REG_B16,
    UC_ARM64_REG_B17,
    UC_ARM64_REG_B18,
    UC_ARM64_REG_B19,
    UC_ARM64_REG_B20,
    UC_ARM64_REG_B21,
    UC_ARM64_REG_B22,
    UC_ARM64_REG_B23,
    UC_ARM64_REG_B24,
    UC_ARM64_REG_B25,
    UC_ARM64_REG_B26,
    UC_ARM64_REG_B27,
    UC_ARM64_REG_B28,
    UC_ARM64_REG_B29,
    UC_ARM64_REG_B30,
    UC_ARM64_REG_B31,
    UC_ARM64_REG_D0,
    UC_ARM64_REG_D1,
    UC_ARM64_REG_D2,
    UC_ARM64_REG_D3,
    UC_ARM64_REG_D4,
    UC_ARM64_REG_D5,
    UC_ARM64_REG_D6,
    UC_ARM64_REG_D7,
    UC_ARM64_REG_D8,
    UC_ARM64_REG_D9,
    UC_ARM64_REG_D10,
    UC_ARM64_REG_D11,
    UC_ARM64_REG_D12,
    UC_ARM64_REG_D13,
    UC_ARM64_REG_D14,
    UC_ARM64_REG_D15,
    UC_ARM64_REG_D16,
    UC_ARM64_REG_D17,
    UC_ARM64_REG_D18,
    UC_ARM64_REG_D19,
    UC_ARM64_REG_D20,
    UC_ARM64_REG_D21,
    UC_ARM64_REG_D22,
    UC_ARM64_REG_D23,
    UC_ARM64_REG_D24,
    UC_ARM64_REG_D25,
    UC_ARM64_REG_D26,
    UC_ARM64_REG_D27,
    UC_ARM64_REG_D28,
    UC_ARM64_REG_D29,
    UC_ARM64_REG_D30,
    UC_ARM64_REG_D31,
    UC_ARM64_REG_H0,
    UC_ARM64_REG_H1,
    UC_ARM64_REG_H2,
    UC_ARM64_REG_H3,
    UC_ARM64_REG_H4,
    UC_ARM64_REG_H5,
    UC_ARM64_REG_H6,
    UC_ARM64_REG_H7,
    UC_ARM64_REG_H8,
    UC_ARM64_REG_H9,
    UC_ARM64_REG_H10,
    UC_ARM64_REG_H11,
    UC_ARM64_REG_H12,
    UC_ARM64_REG_H13,
    UC_ARM64_REG_H14,
    UC_ARM64_REG_H15,
    UC_ARM64_REG_H16,
    UC_ARM64_REG_H17,
    UC_ARM64_REG_H18,
    UC_ARM64_REG_H19,
    UC_ARM64_REG_H20,
    UC_ARM64_REG_H21,
    UC_ARM64_REG_H22,
    UC_ARM64_REG_H23,
    UC_ARM64_REG_H24,
    UC_ARM64_REG_H25,
    UC_ARM64_REG_H26,
    UC_ARM64_REG_H27,
    UC_ARM64_REG_H28,
    UC_ARM64_REG_H29,
    UC_ARM64_REG_H30,
    UC_ARM64_REG_H31,
    UC_ARM64_REG_Q0,
    UC_ARM64_REG_Q1,
    UC_ARM64_REG_Q2,
    UC_ARM64_REG_Q3,
    UC_ARM64_REG_Q4,
    UC_ARM64_REG_Q5,
    UC_ARM64_REG_Q6,
    UC_ARM64_REG_Q7,
    UC_ARM64_REG_Q8,
    UC_ARM64_REG_Q9,
    UC_ARM64_REG_Q10,
    UC_ARM64_REG_Q11,
    UC_ARM64_REG_Q12,
    UC_ARM64_REG_Q13,
    UC_ARM64_REG_Q14,
    UC_ARM64_REG_Q15,
    UC_ARM64_REG_Q16,
    UC_ARM64_REG_Q17,
    UC_ARM64_REG_Q18,
    UC_ARM64_REG_Q19,
    UC_ARM64_REG_Q20,
    UC_ARM64_REG_Q21,
    UC_ARM64_REG_Q22,
    UC_ARM64_REG_Q23,
    UC_ARM64_REG_Q24,
    UC_ARM64_REG_Q25,
    UC_ARM64_REG_Q26,
    UC_ARM64_REG_Q27,
    UC_ARM64_REG_Q28,
    UC_ARM64_REG_Q29,
    UC_ARM64_REG_Q30,
    UC_ARM64_REG_Q31,
    UC_ARM64_REG_S0,
    UC_ARM64_REG_S1,
    UC_ARM64_REG_S2,
    UC_ARM64_REG_S3,
    UC_ARM64_REG_S4,
    UC_ARM64_REG_S5,
    UC_ARM64_REG_S6,
    UC_ARM64_REG_S7,
    UC_ARM64_REG_S8,
    UC_ARM64_REG_S9,
    UC_ARM64_REG_S10,
    UC_ARM64_REG_S11,
    UC_ARM64_REG_S12,
    UC_ARM64_REG_S13,
    UC_ARM64_REG_S14,
    UC_ARM64_REG_S15,
    UC_ARM64_REG_S16,
    UC_ARM64_REG_S17,
    UC_ARM64_REG_S18,
    UC_ARM64_REG_S19,
    UC_ARM64_REG_S20,
    UC_ARM64_REG_S21,
    UC_ARM64_REG_S22,
    UC_ARM64_REG_S23,
    UC_ARM64_REG_S24,
    UC_ARM64_REG_S25,
    UC_ARM64_REG_S26,
    UC_ARM64_REG_S27,
    UC_ARM64_REG_S28,
    UC_ARM64_REG_S29,
    UC_ARM64_REG_S30,
    UC_ARM64_REG_S31,
    UC_ARM64_REG_W0,
    UC_ARM64_REG_W1,
    UC_ARM64_REG_W2,
    UC_ARM64_REG_W3,
    UC_ARM64_REG_W4,
    UC_ARM64_REG_W5,
    UC_ARM64_REG_W6,
    UC_ARM64_REG_W7,
    UC_ARM64_REG_W8,
    UC_ARM64_REG_W9,
    UC_ARM64_REG_W10,
    UC_ARM64_REG_W11,
    UC_ARM64_REG_W12,
    UC_ARM64_REG_W13,
    UC_ARM64_REG_W14,
    UC_ARM64_REG_W15,
    UC_ARM64_REG_W16,
    UC_ARM64_REG_W17,
    UC_ARM64_REG_W18,
    UC_ARM64_REG_W19,
    UC_ARM64_REG_W20,
    UC_ARM64_REG_W21,
    UC_ARM64_REG_W22,
    UC_ARM64_REG_W23,
    UC_ARM64_REG_W24,
    UC_ARM64_REG_W25,
    UC_ARM64_REG_W26,
    UC_ARM64_REG_W27,
    UC_ARM64_REG_W28,
    UC_ARM64_REG_W29,
    UC_ARM64_REG_W30,
    UC_ARM64_REG_X0,
    UC_ARM64_REG_X1,
    UC_ARM64_REG_X2,
    UC_ARM64_REG_X3,
    UC_ARM64_REG_X4,
    UC_ARM64_REG_X5,
    UC_ARM64_REG_X6,
    UC_ARM64_REG_X7,
    UC_ARM64_REG_X8,
    UC_ARM64_REG_X9,
    UC_ARM64_REG_X10,
    UC_ARM64_REG_X11,
    UC_ARM64_REG_X12,
    UC_ARM64_REG_X13,
    UC_ARM64_REG_X14,
    UC_ARM64_REG_X15,
    UC_ARM64_REG_X16,
    UC_ARM64_REG_X17,
    UC_ARM64_REG_X18,
    UC_ARM64_REG_X19,
    UC_ARM64_REG_X20,
    UC_ARM64_REG_X21,
    UC_ARM64_REG_X22,
    UC_ARM64_REG_X23,
    UC_ARM64_REG_X24,
    UC_ARM64_REG_X25,
    UC_ARM64_REG_X26,
    UC_ARM64_REG_X27,
    UC_ARM64_REG_X28,

    UC_ARM64_REG_V0,
    UC_ARM64_REG_V1,
    UC_ARM64_REG_V2,
    UC_ARM64_REG_V3,
    UC_ARM64_REG_V4,
    UC_ARM64_REG_V5,
    UC_ARM64_REG_V6,
    UC_ARM64_REG_V7,
    UC_ARM64_REG_V8,
    UC_ARM64_REG_V9,
    UC_ARM64_REG_V10,
    UC_ARM64_REG_V11,
    UC_ARM64_REG_V12,
    UC_ARM64_REG_V13,
    UC_ARM64_REG_V14,
    UC_ARM64_REG_V15,
    UC_ARM64_REG_V16,
    UC_ARM64_REG_V17,
    UC_ARM64_REG_V18,
    UC_ARM64_REG_V19,
    UC_ARM64_REG_V20,
    UC_ARM64_REG_V21,
    UC_ARM64_REG_V22,
    UC_ARM64_REG_V23,
    UC_ARM64_REG_V24,
    UC_ARM64_REG_V25,
    UC_ARM64_REG_V26,
    UC_ARM64_REG_V27,
    UC_ARM64_REG_V28,
    UC_ARM64_REG_V29,
    UC_ARM64_REG_V30,
    UC_ARM64_REG_V31,

    //> pseudo registers
    UC_ARM64_REG_PC, // program counter register

    UC_ARM64_REG_CPACR_EL1,

    //> thread registers, depreciated, use UC_ARM64_REG_CP_REG instead
    UC_ARM64_REG_TPIDR_EL0,
    UC_ARM64_REG_TPIDRRO_EL0,
    UC_ARM64_REG_TPIDR_EL1,

    UC_ARM64_REG_PSTATE,

    //> exception link registers, depreciated, use UC_ARM64_REG_CP_REG instead
    UC_ARM64_REG_ELR_EL0,
    UC_ARM64_REG_ELR_EL1,
    UC_ARM64_REG_ELR_EL2,
    UC_ARM64_REG_ELR_EL3,

    //> stack pointers registers, depreciated, use UC_ARM64_REG_CP_REG instead
    UC_ARM64_REG_SP_EL0,
    UC_ARM64_REG_SP_EL1,
    UC_ARM64_REG_SP_EL2,
    UC_ARM64_REG_SP_EL3,

    //> other CP15 registers, depreciated, use UC_ARM64_REG_CP_REG instead
    UC_ARM64_REG_TTBR0_EL1,
    UC_ARM64_REG_TTBR1_EL1,

    UC_ARM64_REG_ESR_EL0,
    UC_ARM64_REG_ESR_EL1,
    UC_ARM64_REG_ESR_EL2,
    UC_ARM64_REG_ESR_EL3,

    UC_ARM64_REG_FAR_EL0,
    UC_ARM64_REG_FAR_EL1,
    UC_ARM64_REG_FAR_EL2,
    UC_ARM64_REG_FAR_EL3,

    UC_ARM64_REG_PAR_EL1,

    UC_ARM64_REG_MAIR_EL1,

    UC_ARM64_REG_VBAR_EL0,
    UC_ARM64_REG_VBAR_EL1,
    UC_ARM64_REG_VBAR_EL2,
    UC_ARM64_REG_VBAR_EL3,

    UC_ARM64_REG_CP_REG,

    //> floating point control and status registers
    UC_ARM64_REG_FPCR,
    UC_ARM64_REG_FPSR,

    UC_ARM64_REG_ENDING, // <-- mark the end of the list of registers

    //> alias registers

    UC_ARM64_REG_IP0 = UC_ARM64_REG_X16,
    UC_ARM64_REG_IP1 = UC_ARM64_REG_X17,
    UC_ARM64_REG_FP = UC_ARM64_REG_X29,
    UC_ARM64_REG_LR = UC_ARM64_REG_X30,
} uc_arm64_reg;

// Callback function for tracing MRS/MSR/SYS/SYSL. If this callback returns
// true, the read/write to system registers would be skipped (even though it may
// cause exceptions!). Note one callback per instruction is allowed.
// @reg: The source/destination register.
// @cp_reg: The source/destincation system register.
// @user_data: The user data.
typedef uint32_t (*uc_cb_insn_sys_t)(uc_engine *uc, uc_arm64_reg reg,
                                     const uc_arm64_cp_reg *cp_reg,
                                     void *user_data);

//> ARM64 instructions
typedef enum uc_arm64_insn {
    UC_ARM64_INS_INVALID = 0,

    UC_ARM64_INS_MRS,
    UC_ARM64_INS_MSR,
    UC_ARM64_INS_SYS,
    UC_ARM64_INS_SYSL,

    UC_ARM64_INS_ENDING
} uc_arm64_insn;

#ifdef __cplusplus
}
#endif

#endif

```

`VanguardImportResolver/Dependencies/Unicorn/unicorn/m68k.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_M68K_H
#define UNICORN_M68K_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> M68K CPU
typedef enum uc_cpu_m68k {
    UC_CPU_M68K_M5206 = 0,
    UC_CPU_M68K_M68000,
    UC_CPU_M68K_M68020,
    UC_CPU_M68K_M68030,
    UC_CPU_M68K_M68040,
    UC_CPU_M68K_M68060,
    UC_CPU_M68K_M5208,
    UC_CPU_M68K_CFV4E,
    UC_CPU_M68K_ANY,

    UC_CPU_M68K_ENDING
} uc_cpu_m68k;

//> M68K registers
typedef enum uc_m68k_reg {
    UC_M68K_REG_INVALID = 0,

    UC_M68K_REG_A0,
    UC_M68K_REG_A1,
    UC_M68K_REG_A2,
    UC_M68K_REG_A3,
    UC_M68K_REG_A4,
    UC_M68K_REG_A5,
    UC_M68K_REG_A6,
    UC_M68K_REG_A7,

    UC_M68K_REG_D0,
    UC_M68K_REG_D1,
    UC_M68K_REG_D2,
    UC_M68K_REG_D3,
    UC_M68K_REG_D4,
    UC_M68K_REG_D5,
    UC_M68K_REG_D6,
    UC_M68K_REG_D7,

    UC_M68K_REG_SR,
    UC_M68K_REG_PC,

    UC_M68K_REG_ENDING, // <-- mark the end of the list of registers
} uc_m68k_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`VanguardImportResolver/Dependencies/Unicorn/unicorn/mips.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_MIPS_H
#define UNICORN_MIPS_H

#ifdef __cplusplus
extern "C" {
#endif

// GCC MIPS toolchain has a default macro called "mips" which breaks
// compilation
#undef mips

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> MIPS32 CPUS
typedef enum uc_cpu_mips32 {
    UC_CPU_MIPS32_4KC = 0,
    UC_CPU_MIPS32_4KM,
    UC_CPU_MIPS32_4KECR1,
    UC_CPU_MIPS32_4KEMR1,
    UC_CPU_MIPS32_4KEC,
    UC_CPU_MIPS32_4KEM,
    UC_CPU_MIPS32_24KC,
    UC_CPU_MIPS32_24KEC,
    UC_CPU_MIPS32_24KF,
    UC_CPU_MIPS32_34KF,
    UC_CPU_MIPS32_74KF,
    UC_CPU_MIPS32_M14K,
    UC_CPU_MIPS32_M14KC,
    UC_CPU_MIPS32_P5600,
    UC_CPU_MIPS32_MIPS32R6_GENERIC,
    UC_CPU_MIPS32_I7200,

    UC_CPU_MIPS32_ENDING
} uc_cpu_mips32;

//> MIPS64 CPUS
typedef enum uc_cpu_mips64 {
    UC_CPU_MIPS64_R4000 = 0,
    UC_CPU_MIPS64_VR5432,
    UC_CPU_MIPS64_5KC,
    UC_CPU_MIPS64_5KF,
    UC_CPU_MIPS64_20KC,
    UC_CPU_MIPS64_MIPS64R2_GENERIC,
    UC_CPU_MIPS64_5KEC,
    UC_CPU_MIPS64_5KEF,
    UC_CPU_MIPS64_I6400,
    UC_CPU_MIPS64_I6500,
    UC_CPU_MIPS64_LOONGSON_2E,
    UC_CPU_MIPS64_LOONGSON_2F,
    UC_CPU_MIPS64_MIPS64DSPR2,

    UC_CPU_MIPS64_ENDING
} uc_cpu_mips64;

//> MIPS registers
typedef enum UC_MIPS_REG {
    UC_MIPS_REG_INVALID = 0,
    //> General purpose registers
    UC_MIPS_REG_PC,

    UC_MIPS_REG_0,
    UC_MIPS_REG_1,
    UC_MIPS_REG_2,
    UC_MIPS_REG_3,
    UC_MIPS_REG_4,
    UC_MIPS_REG_5,
    UC_MIPS_REG_6,
    UC_MIPS_REG_7,
    UC_MIPS_REG_8,
    UC_MIPS_REG_9,
    UC_MIPS_REG_10,
    UC_MIPS_REG_11,
    UC_MIPS_REG_12,
    UC_MIPS_REG_13,
    UC_MIPS_REG_14,
    UC_MIPS_REG_15,
    UC_MIPS_REG_16,
    UC_MIPS_REG_17,
    UC_MIPS_REG_18,
    UC_MIPS_REG_19,
    UC_MIPS_REG_20,
    UC_MIPS_REG_21,
    UC_MIPS_REG_22,
    UC_MIPS_REG_23,
    UC_MIPS_REG_24,
    UC_MIPS_REG_25,
    UC_MIPS_REG_26,
    UC_MIPS_REG_27,
    UC_MIPS_REG_28,
    UC_MIPS_REG_29,
    UC_MIPS_REG_30,
    UC_MIPS_REG_31,

    //> DSP registers
    UC_MIPS_REG_DSPCCOND,
    UC_MIPS_REG_DSPCARRY,
    UC_MIPS_REG_DSPEFI,
    UC_MIPS_REG_DSPOUTFLAG,
    UC_MIPS_REG_DSPOUTFLAG16_19,
    UC_MIPS_REG_DSPOUTFLAG20,
    UC_MIPS_REG_DSPOUTFLAG21,
    UC_MIPS_REG_DSPOUTFLAG22,
    UC_MIPS_REG_DSPOUTFLAG23,
    UC_MIPS_REG_DSPPOS,
    UC_MIPS_REG_DSPSCOUNT,

    //> ACC registers
    UC_MIPS_REG_AC0,
    UC_MIPS_REG_AC1,
    UC_MIPS_REG_AC2,
    UC_MIPS_REG_AC3,

    //> COP registers
    UC_MIPS_REG_CC0,
    UC_MIPS_REG_CC1,
    UC_MIPS_REG_CC2,
    UC_MIPS_REG_CC3,
    UC_MIPS_REG_CC4,
    UC_MIPS_REG_CC5,
    UC_MIPS_REG_CC6,
    UC_MIPS_REG_CC7,

    //> FPU registers
    UC_MIPS_REG_F0,
    UC_MIPS_REG_F1,
    UC_MIPS_REG_F2,
    UC_MIPS_REG_F3,
    UC_MIPS_REG_F4,
    UC_MIPS_REG_F5,
    UC_MIPS_REG_F6,
    UC_MIPS_REG_F7,
    UC_MIPS_REG_F8,
    UC_MIPS_REG_F9,
    UC_MIPS_REG_F10,
    UC_MIPS_REG_F11,
    UC_MIPS_REG_F12,
    UC_MIPS_REG_F13,
    UC_MIPS_REG_F14,
    UC_MIPS_REG_F15,
    UC_MIPS_REG_F16,
    UC_MIPS_REG_F17,
    UC_MIPS_REG_F18,
    UC_MIPS_REG_F19,
    UC_MIPS_REG_F20,
    UC_MIPS_REG_F21,
    UC_MIPS_REG_F22,
    UC_MIPS_REG_F23,
    UC_MIPS_REG_F24,
    UC_MIPS_REG_F25,
    UC_MIPS_REG_F26,
    UC_MIPS_REG_F27,
    UC_MIPS_REG_F28,
    UC_MIPS_REG_F29,
    UC_MIPS_REG_F30,
    UC_MIPS_REG_F31,

    UC_MIPS_REG_FCC0,
    UC_MIPS_REG_FCC1,
    UC_MIPS_REG_FCC2,
    UC_MIPS_REG_FCC3,
    UC_MIPS_REG_FCC4,
    UC_MIPS_REG_FCC5,
    UC_MIPS_REG_FCC6,
    UC_MIPS_REG_FCC7,

    //> AFPR128
    UC_MIPS_REG_W0,
    UC_MIPS_REG_W1,
    UC_MIPS_REG_W2,
    UC_MIPS_REG_W3,
    UC_MIPS_REG_W4,
    UC_MIPS_REG_W5,
    UC_MIPS_REG_W6,
    UC_MIPS_REG_W7,
    UC_MIPS_REG_W8,
    UC_MIPS_REG_W9,
    UC_MIPS_REG_W10,
    UC_MIPS_REG_W11,
    UC_MIPS_REG_W12,
    UC_MIPS_REG_W13,
    UC_MIPS_REG_W14,
    UC_MIPS_REG_W15,
    UC_MIPS_REG_W16,
    UC_MIPS_REG_W17,
    UC_MIPS_REG_W18,
    UC_MIPS_REG_W19,
    UC_MIPS_REG_W20,
    UC_MIPS_REG_W21,
    UC_MIPS_REG_W22,
    UC_MIPS_REG_W23,
    UC_MIPS_REG_W24,
    UC_MIPS_REG_W25,
    UC_MIPS_REG_W26,
    UC_MIPS_REG_W27,
    UC_MIPS_REG_W28,
    UC_MIPS_REG_W29,
    UC_MIPS_REG_W30,
    UC_MIPS_REG_W31,

    UC_MIPS_REG_HI,
    UC_MIPS_REG_LO,

    UC_MIPS_REG_P0,
    UC_MIPS_REG_P1,
    UC_MIPS_REG_P2,

    UC_MIPS_REG_MPL0,
    UC_MIPS_REG_MPL1,
    UC_MIPS_REG_MPL2,

    UC_MIPS_REG_CP0_CONFIG3,
    UC_MIPS_REG_CP0_USERLOCAL,
    UC_MIPS_REG_CP0_STATUS,

    UC_MIPS_REG_ENDING, // <-- mark the end of the list or registers

    // alias registers
    UC_MIPS_REG_ZERO = UC_MIPS_REG_0,
    UC_MIPS_REG_AT = UC_MIPS_REG_1,
    UC_MIPS_REG_V0 = UC_MIPS_REG_2,
    UC_MIPS_REG_V1 = UC_MIPS_REG_3,
    UC_MIPS_REG_A0 = UC_MIPS_REG_4,
    UC_MIPS_REG_A1 = UC_MIPS_REG_5,
    UC_MIPS_REG_A2 = UC_MIPS_REG_6,
    UC_MIPS_REG_A3 = UC_MIPS_REG_7,
    UC_MIPS_REG_T0 = UC_MIPS_REG_8,
    UC_MIPS_REG_T1 = UC_MIPS_REG_9,
    UC_MIPS_REG_T2 = UC_MIPS_REG_10,
    UC_MIPS_REG_T3 = UC_MIPS_REG_11,
    UC_MIPS_REG_T4 = UC_MIPS_REG_12,
    UC_MIPS_REG_T5 = UC_MIPS_REG_13,
    UC_MIPS_REG_T6 = UC_MIPS_REG_14,
    UC_MIPS_REG_T7 = UC_MIPS_REG_15,
    UC_MIPS_REG_S0 = UC_MIPS_REG_16,
    UC_MIPS_REG_S1 = UC_MIPS_REG_17,
    UC_MIPS_REG_S2 = UC_MIPS_REG_18,
    UC_MIPS_REG_S3 = UC_MIPS_REG_19,
    UC_MIPS_REG_S4 = UC_MIPS_REG_20,
    UC_MIPS_REG_S5 = UC_MIPS_REG_21,
    UC_MIPS_REG_S6 = UC_MIPS_REG_22,
    UC_MIPS_REG_S7 = UC_MIPS_REG_23,
    UC_MIPS_REG_T8 = UC_MIPS_REG_24,
    UC_MIPS_REG_T9 = UC_MIPS_REG_25,
    UC_MIPS_REG_K0 = UC_MIPS_REG_26,
    UC_MIPS_REG_K1 = UC_MIPS_REG_27,
    UC_MIPS_REG_GP = UC_MIPS_REG_28,
    UC_MIPS_REG_SP = UC_MIPS_REG_29,
    UC_MIPS_REG_FP = UC_MIPS_REG_30,
    UC_MIPS_REG_S8 = UC_MIPS_REG_30,
    UC_MIPS_REG_RA = UC_MIPS_REG_31,

    UC_MIPS_REG_HI0 = UC_MIPS_REG_AC0,
    UC_MIPS_REG_HI1 = UC_MIPS_REG_AC1,
    UC_MIPS_REG_HI2 = UC_MIPS_REG_AC2,
    UC_MIPS_REG_HI3 = UC_MIPS_REG_AC3,

    UC_MIPS_REG_LO0 = UC_MIPS_REG_HI0,
    UC_MIPS_REG_LO1 = UC_MIPS_REG_HI1,
    UC_MIPS_REG_LO2 = UC_MIPS_REG_HI2,
    UC_MIPS_REG_LO3 = UC_MIPS_REG_HI3,
} UC_MIPS_REG;

#ifdef __cplusplus
}
#endif

#endif

```

`VanguardImportResolver/Dependencies/Unicorn/unicorn/platform.h`:

```h
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

/*
 This file is to support header files that are missing in MSVC and
 other non-standard compilers.
*/
#ifndef UNICORN_PLATFORM_H
#define UNICORN_PLATFORM_H

/*
These are the various MSVC versions as given by _MSC_VER:
MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015)
MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)
MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)
MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)
MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)
MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)
MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio 2003)
MSVC++ 7.0  _MSC_VER == 1300
MSVC++ 6.0  _MSC_VER == 1200
MSVC++ 5.0  _MSC_VER == 1100
*/
#define MSC_VER_VS2003 1310
#define MSC_VER_VS2005 1400
#define MSC_VER_VS2008 1500
#define MSC_VER_VS2010 1600
#define MSC_VER_VS2012 1700
#define MSC_VER_VS2013 1800
#define MSC_VER_VS2015 1900

// handle stdbool.h compatibility
#if !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) &&  \
    (defined(WIN32) || defined(WIN64) || defined(_WIN32) || defined(_WIN64))
// MSVC

// stdbool.h
#if (_MSC_VER < MSC_VER_VS2013) || defined(_KERNEL_MODE)
// this system does not have stdbool.h
#ifndef __cplusplus
typedef unsigned char bool;
#define false 0
#define true 1
#endif // __cplusplus

#else
// VisualStudio 2013+ -> C99 is supported
#include <stdbool.h>
#endif // (_MSC_VER < MSC_VER_VS2013) || defined(_KERNEL_MODE)

#else
// not MSVC -> C99 is supported
#include <stdbool.h>
#endif // !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__)
       // && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined
       // (_WIN64))

#if (defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2010)) || defined(_KERNEL_MODE)
// this system does not have stdint.h
typedef signed char int8_t;
typedef signed short int16_t;
typedef signed int int32_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef signed long long int64_t;
typedef unsigned long long uint64_t;

typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long uint_fast64_t;

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _INTPTR_T_DEFINED
#define _INTPTR_T_DEFINED
#ifdef _WIN64
typedef long long intptr_t;
#else  /* _WIN64 */
typedef _W64 int intptr_t;
#endif /* _WIN64 */
#endif /* _INTPTR_T_DEFINED */

#ifndef _UINTPTR_T_DEFINED
#define _UINTPTR_T_DEFINED
#ifdef _WIN64
typedef unsigned long long uintptr_t;
#else  /* _WIN64 */
typedef _W64 unsigned int uintptr_t;
#endif /* _WIN64 */
#endif /* _UINTPTR_T_DEFINED */

#define INT8_MIN (-127i8 - 1)
#define INT16_MIN (-32767i16 - 1)
#define INT32_MIN (-2147483647i32 - 1)
#define INT64_MIN (-9223372036854775807i64 - 1)
#define INT8_MAX 127i8
#define INT16_MAX 32767i16
#define INT32_MAX 2147483647i32
#define INT64_MAX 9223372036854775807i64
#define UINT8_MAX 0xffui8
#define UINT16_MAX 0xffffui16
#define UINT32_MAX 0xffffffffui32
#define UINT64_MAX 0xffffffffffffffffui64

#define INT_FAST8_MIN INT8_MIN
#define INT_FAST16_MIN INT32_MIN
#define INT_FAST32_MIN INT32_MIN
#define INT_FAST64_MIN INT64_MIN
#define INT_FAST8_MAX INT8_MAX
#define INT_FAST16_MAX INT32_MAX
#define INT_FAST32_MAX INT32_MAX
#define INT_FAST64_MAX INT64_MAX
#define UINT_FAST8_MAX UINT8_MAX
#define UINT_FAST16_MAX UINT32_MAX
#define UINT_FAST32_MAX UINT32_MAX
#define UINT_FAST64_MAX UINT64_MAX

#ifdef _WIN64
#define INTPTR_MIN INT64_MIN
#define INTPTR_MAX INT64_MAX
#define UINTPTR_MAX UINT64_MAX
#else /* _WIN64 */
#define INTPTR_MIN INT32_MIN
#define INTPTR_MAX INT32_MAX
#define UINTPTR_MAX UINT32_MAX
#endif /* _WIN64 */

#else // this system has stdint.h

#if defined(_MSC_VER) && (_MSC_VER == MSC_VER_VS2010)
#define _INTPTR 2
#endif

#include <stdint.h>
#endif // (defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2010)) ||
       // defined(_KERNEL_MODE)

// handle inttypes.h compatibility
#if (defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2013)) || defined(_KERNEL_MODE)
// this system does not have inttypes.h

#define __PRI_8_LENGTH_MODIFIER__ "hh"
#define __PRI_64_LENGTH_MODIFIER__ "ll"

#define PRId8 __PRI_8_LENGTH_MODIFIER__ "d"
#define PRIi8 __PRI_8_LENGTH_MODIFIER__ "i"
#define PRIo8 __PRI_8_LENGTH_MODIFIER__ "o"
#define PRIu8 __PRI_8_LENGTH_MODIFIER__ "u"
#define PRIx8 __PRI_8_LENGTH_MODIFIER__ "x"
#define PRIX8 __PRI_8_LENGTH_MODIFIER__ "X"

#define PRId16 "hd"
#define PRIi16 "hi"
#define PRIo16 "ho"
#define PRIu16 "hu"
#define PRIx16 "hx"
#define PRIX16 "hX"

#if defined(_MSC_VER) && (_MSC_VER <= MSC_VER_VS2012)
#define PRId32 "ld"
#define PRIi32 "li"
#define PRIo32 "lo"
#define PRIu32 "lu"
#define PRIx32 "lx"
#define PRIX32 "lX"
#else // OSX
#define PRId32 "d"
#define PRIi32 "i"
#define PRIo32 "o"
#define PRIu32 "u"
#define PRIx32 "x"
#define PRIX32 "X"
#endif // defined(_MSC_VER) && (_MSC_VER <= MSC_VER_VS2012)

#if defined(_MSC_VER) && (_MSC_VER <= MSC_VER_VS2012)
// redefine functions from inttypes.h used in cstool
#define strtoull _strtoui64
#endif

#define PRId64 __PRI_64_LENGTH_MODIFIER__ "d"
#define PRIi64 __PRI_64_LENGTH_MODIFIER__ "i"
#define PRIo64 __PRI_64_LENGTH_MODIFIER__ "o"
#define PRIu64 __PRI_64_LENGTH_MODIFIER__ "u"
#define PRIx64 __PRI_64_LENGTH_MODIFIER__ "x"
#define PRIX64 __PRI_64_LENGTH_MODIFIER__ "X"

#else
// this system has inttypes.h by default
#include <inttypes.h>
#endif // #if defined(_MSC_VER) && (_MSC_VER < MSC_VER_VS2013) ||
       // defined(_KERNEL_MODE)

// sys/time.h compatibility
#if defined(_MSC_VER)
#include <sys/types.h>
#include <sys/timeb.h>
#include <windows.h>

#else
#include <sys/time.h>
#endif

// unistd.h compatibility
#if defined(_MSC_VER)

static int usleep(uint32_t usec)
{
    HANDLE timer;
    LARGE_INTEGER due;

    timer = CreateWaitableTimer(NULL, TRUE, NULL);
    if (!timer)
        return -1;

    due.QuadPart = (-((int64_t)usec)) * 10LL;
    if (!SetWaitableTimer(timer, &due, 0, NULL, NULL, 0)) {
        CloseHandle(timer);
        return -1;
    }
    WaitForSingleObject(timer, INFINITE);
    CloseHandle(timer);

    return 0;
}

#else
#include <unistd.h>
#endif

// misc support
#if defined(_MSC_VER)
#ifdef _WIN64
typedef signed __int64 ssize_t;
#else
typedef _W64 signed int ssize_t;
#endif

#ifndef va_copy
#define va_copy(d, s) ((d) = (s))
#endif
#define strcasecmp _stricmp
#if (_MSC_VER < MSC_VER_VS2015)
#define snprintf _snprintf
#endif
#if (_MSC_VER <= MSC_VER_VS2013)
#define strtoll _strtoi64
#endif
#endif

#endif // UNICORN_PLATFORM_H

```

`VanguardImportResolver/Dependencies/Unicorn/unicorn/ppc.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_PPC_H
#define UNICORN_PPC_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> PPC CPU
typedef enum uc_cpu_ppc {
    UC_CPU_PPC32_401 = 0,
    UC_CPU_PPC32_401A1,
    UC_CPU_PPC32_401B2,
    UC_CPU_PPC32_401C2,
    UC_CPU_PPC32_401D2,
    UC_CPU_PPC32_401E2,
    UC_CPU_PPC32_401F2,
    UC_CPU_PPC32_401G2,
    UC_CPU_PPC32_IOP480,
    UC_CPU_PPC32_COBRA,
    UC_CPU_PPC32_403GA,
    UC_CPU_PPC32_403GB,
    UC_CPU_PPC32_403GC,
    UC_CPU_PPC32_403GCX,
    UC_CPU_PPC32_405D2,
    UC_CPU_PPC32_405D4,
    UC_CPU_PPC32_405CRA,
    UC_CPU_PPC32_405CRB,
    UC_CPU_PPC32_405CRC,
    UC_CPU_PPC32_405EP,
    UC_CPU_PPC32_405EZ,
    UC_CPU_PPC32_405GPA,
    UC_CPU_PPC32_405GPB,
    UC_CPU_PPC32_405GPC,
    UC_CPU_PPC32_405GPD,
    UC_CPU_PPC32_405GPR,
    UC_CPU_PPC32_405LP,
    UC_CPU_PPC32_NPE405H,
    UC_CPU_PPC32_NPE405H2,
    UC_CPU_PPC32_NPE405L,
    UC_CPU_PPC32_NPE4GS3,
    UC_CPU_PPC32_STB03,
    UC_CPU_PPC32_STB04,
    UC_CPU_PPC32_STB25,
    UC_CPU_PPC32_X2VP4,
    UC_CPU_PPC32_X2VP20,
    UC_CPU_PPC32_440_XILINX,
    UC_CPU_PPC32_440_XILINX_W_DFPU,
    UC_CPU_PPC32_440EPA,
    UC_CPU_PPC32_440EPB,
    UC_CPU_PPC32_440EPX,
    UC_CPU_PPC32_460EXB,
    UC_CPU_PPC32_G2,
    UC_CPU_PPC32_G2H4,
    UC_CPU_PPC32_G2GP,
    UC_CPU_PPC32_G2LS,
    UC_CPU_PPC32_G2HIP3,
    UC_CPU_PPC32_G2HIP4,
    UC_CPU_PPC32_MPC603,
    UC_CPU_PPC32_G2LE,
    UC_CPU_PPC32_G2LEGP,
    UC_CPU_PPC32_G2LELS,
    UC_CPU_PPC32_G2LEGP1,
    UC_CPU_PPC32_G2LEGP3,
    UC_CPU_PPC32_MPC5200_V10,
    UC_CPU_PPC32_MPC5200_V11,
    UC_CPU_PPC32_MPC5200_V12,
    UC_CPU_PPC32_MPC5200B_V20,
    UC_CPU_PPC32_MPC5200B_V21,
    UC_CPU_PPC32_E200Z5,
    UC_CPU_PPC32_E200Z6,
    UC_CPU_PPC32_E300C1,
    UC_CPU_PPC32_E300C2,
    UC_CPU_PPC32_E300C3,
    UC_CPU_PPC32_E300C4,
    UC_CPU_PPC32_MPC8343,
    UC_CPU_PPC32_MPC8343A,
    UC_CPU_PPC32_MPC8343E,
    UC_CPU_PPC32_MPC8343EA,
    UC_CPU_PPC32_MPC8347T,
    UC_CPU_PPC32_MPC8347P,
    UC_CPU_PPC32_MPC8347AT,
    UC_CPU_PPC32_MPC8347AP,
    UC_CPU_PPC32_MPC8347ET,
    UC_CPU_PPC32_MPC8347EP,
    UC_CPU_PPC32_MPC8347EAT,
    UC_CPU_PPC32_MPC8347EAP,
    UC_CPU_PPC32_MPC8349,
    UC_CPU_PPC32_MPC8349A,
    UC_CPU_PPC32_MPC8349E,
    UC_CPU_PPC32_MPC8349EA,
    UC_CPU_PPC32_MPC8377,
    UC_CPU_PPC32_MPC8377E,
    UC_CPU_PPC32_MPC8378,
    UC_CPU_PPC32_MPC8378E,
    UC_CPU_PPC32_MPC8379,
    UC_CPU_PPC32_MPC8379E,
    UC_CPU_PPC32_E500_V10,
    UC_CPU_PPC32_E500_V20,
    UC_CPU_PPC32_E500V2_V10,
    UC_CPU_PPC32_E500V2_V20,
    UC_CPU_PPC32_E500V2_V21,
    UC_CPU_PPC32_E500V2_V22,
    UC_CPU_PPC32_E500V2_V30,
    UC_CPU_PPC32_E500MC,
    UC_CPU_PPC32_MPC8533_V10,
    UC_CPU_PPC32_MPC8533_V11,
    UC_CPU_PPC32_MPC8533E_V10,
    UC_CPU_PPC32_MPC8533E_V11,
    UC_CPU_PPC32_MPC8540_V10,
    UC_CPU_PPC32_MPC8540_V20,
    UC_CPU_PPC32_MPC8540_V21,
    UC_CPU_PPC32_MPC8541_V10,
    UC_CPU_PPC32_MPC8541_V11,
    UC_CPU_PPC32_MPC8541E_V10,
    UC_CPU_PPC32_MPC8541E_V11,
    UC_CPU_PPC32_MPC8543_V10,
    UC_CPU_PPC32_MPC8543_V11,
    UC_CPU_PPC32_MPC8543_V20,
    UC_CPU_PPC32_MPC8543_V21,
    UC_CPU_PPC32_MPC8543E_V10,
    UC_CPU_PPC32_MPC8543E_V11,
    UC_CPU_PPC32_MPC8543E_V20,
    UC_CPU_PPC32_MPC8543E_V21,
    UC_CPU_PPC32_MPC8544_V10,
    UC_CPU_PPC32_MPC8544_V11,
    UC_CPU_PPC32_MPC8544E_V10,
    UC_CPU_PPC32_MPC8544E_V11,
    UC_CPU_PPC32_MPC8545_V20,
    UC_CPU_PPC32_MPC8545_V21,
    UC_CPU_PPC32_MPC8545E_V20,
    UC_CPU_PPC32_MPC8545E_V21,
    UC_CPU_PPC32_MPC8547E_V20,
    UC_CPU_PPC32_MPC8547E_V21,
    UC_CPU_PPC32_MPC8548_V10,
    UC_CPU_PPC32_MPC8548_V11,
    UC_CPU_PPC32_MPC8548_V20,
    UC_CPU_PPC32_MPC8548_V21,
    UC_CPU_PPC32_MPC8548E_V10,
    UC_CPU_PPC32_MPC8548E_V11,
    UC_CPU_PPC32_MPC8548E_V20,
    UC_CPU_PPC32_MPC8548E_V21,
    UC_CPU_PPC32_MPC8555_V10,
    UC_CPU_PPC32_MPC8555_V11,
    UC_CPU_PPC32_MPC8555E_V10,
    UC_CPU_PPC32_MPC8555E_V11,
    UC_CPU_PPC32_MPC8560_V10,
    UC_CPU_PPC32_MPC8560_V20,
    UC_CPU_PPC32_MPC8560_V21,
    UC_CPU_PPC32_MPC8567,
    UC_CPU_PPC32_MPC8567E,
    UC_CPU_PPC32_MPC8568,
    UC_CPU_PPC32_MPC8568E,
    UC_CPU_PPC32_MPC8572,
    UC_CPU_PPC32_MPC8572E,
    UC_CPU_PPC32_E600,
    UC_CPU_PPC32_MPC8610,
    UC_CPU_PPC32_MPC8641,
    UC_CPU_PPC32_MPC8641D,
    UC_CPU_PPC32_601_V0,
    UC_CPU_PPC32_601_V1,
    UC_CPU_PPC32_601_V2,
    UC_CPU_PPC32_602,
    UC_CPU_PPC32_603,
    UC_CPU_PPC32_603E_V1_1,
    UC_CPU_PPC32_603E_V1_2,
    UC_CPU_PPC32_603E_V1_3,
    UC_CPU_PPC32_603E_V1_4,
    UC_CPU_PPC32_603E_V2_2,
    UC_CPU_PPC32_603E_V3,
    UC_CPU_PPC32_603E_V4,
    UC_CPU_PPC32_603E_V4_1,
    UC_CPU_PPC32_603E7,
    UC_CPU_PPC32_603E7T,
    UC_CPU_PPC32_603E7V,
    UC_CPU_PPC32_603E7V1,
    UC_CPU_PPC32_603E7V2,
    UC_CPU_PPC32_603P,
    UC_CPU_PPC32_604,
    UC_CPU_PPC32_604E_V1_0,
    UC_CPU_PPC32_604E_V2_2,
    UC_CPU_PPC32_604E_V2_4,
    UC_CPU_PPC32_604R,
    UC_CPU_PPC32_740_V1_0,
    UC_CPU_PPC32_750_V1_0,
    UC_CPU_PPC32_740_V2_0,
    UC_CPU_PPC32_750_V2_0,
    UC_CPU_PPC32_740_V2_1,
    UC_CPU_PPC32_750_V2_1,
    UC_CPU_PPC32_740_V2_2,
    UC_CPU_PPC32_750_V2_2,
    UC_CPU_PPC32_740_V3_0,
    UC_CPU_PPC32_750_V3_0,
    UC_CPU_PPC32_740_V3_1,
    UC_CPU_PPC32_750_V3_1,
    UC_CPU_PPC32_740E,
    UC_CPU_PPC32_750E,
    UC_CPU_PPC32_740P,
    UC_CPU_PPC32_750P,
    UC_CPU_PPC32_750CL_V1_0,
    UC_CPU_PPC32_750CL_V2_0,
    UC_CPU_PPC32_750CX_V1_0,
    UC_CPU_PPC32_750CX_V2_0,
    UC_CPU_PPC32_750CX_V2_1,
    UC_CPU_PPC32_750CX_V2_2,
    UC_CPU_PPC32_750CXE_V2_1,
    UC_CPU_PPC32_750CXE_V2_2,
    UC_CPU_PPC32_750CXE_V2_3,
    UC_CPU_PPC32_750CXE_V2_4,
    UC_CPU_PPC32_750CXE_V2_4B,
    UC_CPU_PPC32_750CXE_V3_0,
    UC_CPU_PPC32_750CXE_V3_1,
    UC_CPU_PPC32_750CXE_V3_1B,
    UC_CPU_PPC32_750CXR,
    UC_CPU_PPC32_750FL,
    UC_CPU_PPC32_750FX_V1_0,
    UC_CPU_PPC32_750FX_V2_0,
    UC_CPU_PPC32_750FX_V2_1,
    UC_CPU_PPC32_750FX_V2_2,
    UC_CPU_PPC32_750FX_V2_3,
    UC_CPU_PPC32_750GL,
    UC_CPU_PPC32_750GX_V1_0,
    UC_CPU_PPC32_750GX_V1_1,
    UC_CPU_PPC32_750GX_V1_2,
    UC_CPU_PPC32_750L_V2_0,
    UC_CPU_PPC32_750L_V2_1,
    UC_CPU_PPC32_750L_V2_2,
    UC_CPU_PPC32_750L_V3_0,
    UC_CPU_PPC32_750L_V3_2,
    UC_CPU_PPC32_745_V1_0,
    UC_CPU_PPC32_755_V1_0,
    UC_CPU_PPC32_745_V1_1,
    UC_CPU_PPC32_755_V1_1,
    UC_CPU_PPC32_745_V2_0,
    UC_CPU_PPC32_755_V2_0,
    UC_CPU_PPC32_745_V2_1,
    UC_CPU_PPC32_755_V2_1,
    UC_CPU_PPC32_745_V2_2,
    UC_CPU_PPC32_755_V2_2,
    UC_CPU_PPC32_745_V2_3,
    UC_CPU_PPC32_755_V2_3,
    UC_CPU_PPC32_745_V2_4,
    UC_CPU_PPC32_755_V2_4,
    UC_CPU_PPC32_745_V2_5,
    UC_CPU_PPC32_755_V2_5,
    UC_CPU_PPC32_745_V2_6,
    UC_CPU_PPC32_755_V2_6,
    UC_CPU_PPC32_745_V2_7,
    UC_CPU_PPC32_755_V2_7,
    UC_CPU_PPC32_745_V2_8,
    UC_CPU_PPC32_755_V2_8,
    UC_CPU_PPC32_7400_V1_0,
    UC_CPU_PPC32_7400_V1_1,
    UC_CPU_PPC32_7400_V2_0,
    UC_CPU_PPC32_7400_V2_1,
    UC_CPU_PPC32_7400_V2_2,
    UC_CPU_PPC32_7400_V2_6,
    UC_CPU_PPC32_7400_V2_7,
    UC_CPU_PPC32_7400_V2_8,
    UC_CPU_PPC32_7400_V2_9,
    UC_CPU_PPC32_7410_V1_0,
    UC_CPU_PPC32_7410_V1_1,
    UC_CPU_PPC32_7410_V1_2,
    UC_CPU_PPC32_7410_V1_3,
    UC_CPU_PPC32_7410_V1_4,
    UC_CPU_PPC32_7448_V1_0,
    UC_CPU_PPC32_7448_V1_1,
    UC_CPU_PPC32_7448_V2_0,
    UC_CPU_PPC32_7448_V2_1,
    UC_CPU_PPC32_7450_V1_0,
    UC_CPU_PPC32_7450_V1_1,
    UC_CPU_PPC32_7450_V1_2,
    UC_CPU_PPC32_7450_V2_0,
    UC_CPU_PPC32_7450_V2_1,
    UC_CPU_PPC32_7441_V2_1,
    UC_CPU_PPC32_7441_V2_3,
    UC_CPU_PPC32_7451_V2_3,
    UC_CPU_PPC32_7441_V2_10,
    UC_CPU_PPC32_7451_V2_10,
    UC_CPU_PPC32_7445_V1_0,
    UC_CPU_PPC32_7455_V1_0,
    UC_CPU_PPC32_7445_V2_1,
    UC_CPU_PPC32_7455_V2_1,
    UC_CPU_PPC32_7445_V3_2,
    UC_CPU_PPC32_7455_V3_2,
    UC_CPU_PPC32_7445_V3_3,
    UC_CPU_PPC32_7455_V3_3,
    UC_CPU_PPC32_7445_V3_4,
    UC_CPU_PPC32_7455_V3_4,
    UC_CPU_PPC32_7447_V1_0,
    UC_CPU_PPC32_7457_V1_0,
    UC_CPU_PPC32_7447_V1_1,
    UC_CPU_PPC32_7457_V1_1,
    UC_CPU_PPC32_7457_V1_2,
    UC_CPU_PPC32_7447A_V1_0,
    UC_CPU_PPC32_7457A_V1_0,
    UC_CPU_PPC32_7447A_V1_1,
    UC_CPU_PPC32_7457A_V1_1,
    UC_CPU_PPC32_7447A_V1_2,
    UC_CPU_PPC32_7457A_V1_2,

    UC_CPU_PPC32_ENDING
} uc_cpu_ppc;

//> PPC64 CPU
typedef enum uc_cpu_ppc64 {
    UC_CPU_PPC64_E5500 = 0,
    UC_CPU_PPC64_E6500,
    UC_CPU_PPC64_970_V2_2,
    UC_CPU_PPC64_970FX_V1_0,
    UC_CPU_PPC64_970FX_V2_0,
    UC_CPU_PPC64_970FX_V2_1,
    UC_CPU_PPC64_970FX_V3_0,
    UC_CPU_PPC64_970FX_V3_1,
    UC_CPU_PPC64_970MP_V1_0,
    UC_CPU_PPC64_970MP_V1_1,
    UC_CPU_PPC64_POWER5_V2_1,
    UC_CPU_PPC64_POWER7_V2_3,
    UC_CPU_PPC64_POWER7_V2_1,
    UC_CPU_PPC64_POWER8E_V2_1,
    UC_CPU_PPC64_POWER8_V2_0,
    UC_CPU_PPC64_POWER8NVL_V1_0,
    UC_CPU_PPC64_POWER9_V1_0,
    UC_CPU_PPC64_POWER9_V2_0,
    UC_CPU_PPC64_POWER10_V1_0,

    UC_CPU_PPC64_ENDING
} uc_cpu_ppc64;

//> PPC registers
typedef enum uc_ppc_reg {
    UC_PPC_REG_INVALID = 0,
    //> General purpose registers
    UC_PPC_REG_PC,

    UC_PPC_REG_0,
    UC_PPC_REG_1,
    UC_PPC_REG_2,
    UC_PPC_REG_3,
    UC_PPC_REG_4,
    UC_PPC_REG_5,
    UC_PPC_REG_6,
    UC_PPC_REG_7,
    UC_PPC_REG_8,
    UC_PPC_REG_9,
    UC_PPC_REG_10,
    UC_PPC_REG_11,
    UC_PPC_REG_12,
    UC_PPC_REG_13,
    UC_PPC_REG_14,
    UC_PPC_REG_15,
    UC_PPC_REG_16,
    UC_PPC_REG_17,
    UC_PPC_REG_18,
    UC_PPC_REG_19,
    UC_PPC_REG_20,
    UC_PPC_REG_21,
    UC_PPC_REG_22,
    UC_PPC_REG_23,
    UC_PPC_REG_24,
    UC_PPC_REG_25,
    UC_PPC_REG_26,
    UC_PPC_REG_27,
    UC_PPC_REG_28,
    UC_PPC_REG_29,
    UC_PPC_REG_30,
    UC_PPC_REG_31,

    UC_PPC_REG_CR0,
    UC_PPC_REG_CR1,
    UC_PPC_REG_CR2,
    UC_PPC_REG_CR3,
    UC_PPC_REG_CR4,
    UC_PPC_REG_CR5,
    UC_PPC_REG_CR6,
    UC_PPC_REG_CR7,

    UC_PPC_REG_FPR0,
    UC_PPC_REG_FPR1,
    UC_PPC_REG_FPR2,
    UC_PPC_REG_FPR3,
    UC_PPC_REG_FPR4,
    UC_PPC_REG_FPR5,
    UC_PPC_REG_FPR6,
    UC_PPC_REG_FPR7,
    UC_PPC_REG_FPR8,
    UC_PPC_REG_FPR9,
    UC_PPC_REG_FPR10,
    UC_PPC_REG_FPR11,
    UC_PPC_REG_FPR12,
    UC_PPC_REG_FPR13,
    UC_PPC_REG_FPR14,
    UC_PPC_REG_FPR15,
    UC_PPC_REG_FPR16,
    UC_PPC_REG_FPR17,
    UC_PPC_REG_FPR18,
    UC_PPC_REG_FPR19,
    UC_PPC_REG_FPR20,
    UC_PPC_REG_FPR21,
    UC_PPC_REG_FPR22,
    UC_PPC_REG_FPR23,
    UC_PPC_REG_FPR24,
    UC_PPC_REG_FPR25,
    UC_PPC_REG_FPR26,
    UC_PPC_REG_FPR27,
    UC_PPC_REG_FPR28,
    UC_PPC_REG_FPR29,
    UC_PPC_REG_FPR30,
    UC_PPC_REG_FPR31,

    UC_PPC_REG_LR,
    UC_PPC_REG_XER,
    UC_PPC_REG_CTR,
    UC_PPC_REG_MSR,
    UC_PPC_REG_FPSCR,
    UC_PPC_REG_CR,

    UC_PPC_REG_ENDING, // <-- mark the end of the list or registers
} uc_ppc_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`VanguardImportResolver/Dependencies/Unicorn/unicorn/riscv.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2020 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
 */

#ifndef UNICORN_RISCV_H
#define UNICORN_RISCV_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> RISCV32 CPU
typedef enum uc_cpu_riscv32 {
    UC_CPU_RISCV32_ANY = 0,
    UC_CPU_RISCV32_BASE32,
    UC_CPU_RISCV32_SIFIVE_E31,
    UC_CPU_RISCV32_SIFIVE_U34,

    UC_CPU_RISCV32_ENDING
} uc_cpu_riscv32;

//> RISCV64 CPU
typedef enum uc_cpu_riscv64 {
    UC_CPU_RISCV64_ANY = 0,
    UC_CPU_RISCV64_BASE64,
    UC_CPU_RISCV64_SIFIVE_E51,
    UC_CPU_RISCV64_SIFIVE_U54,

    UC_CPU_RISCV64_ENDING
} uc_cpu_riscv64;

//> RISCV registers
typedef enum uc_riscv_reg {
    UC_RISCV_REG_INVALID = 0,
    //> General purpose registers
    UC_RISCV_REG_X0,
    UC_RISCV_REG_X1,
    UC_RISCV_REG_X2,
    UC_RISCV_REG_X3,
    UC_RISCV_REG_X4,
    UC_RISCV_REG_X5,
    UC_RISCV_REG_X6,
    UC_RISCV_REG_X7,
    UC_RISCV_REG_X8,
    UC_RISCV_REG_X9,
    UC_RISCV_REG_X10,
    UC_RISCV_REG_X11,
    UC_RISCV_REG_X12,
    UC_RISCV_REG_X13,
    UC_RISCV_REG_X14,
    UC_RISCV_REG_X15,
    UC_RISCV_REG_X16,
    UC_RISCV_REG_X17,
    UC_RISCV_REG_X18,
    UC_RISCV_REG_X19,
    UC_RISCV_REG_X20,
    UC_RISCV_REG_X21,
    UC_RISCV_REG_X22,
    UC_RISCV_REG_X23,
    UC_RISCV_REG_X24,
    UC_RISCV_REG_X25,
    UC_RISCV_REG_X26,
    UC_RISCV_REG_X27,
    UC_RISCV_REG_X28,
    UC_RISCV_REG_X29,
    UC_RISCV_REG_X30,
    UC_RISCV_REG_X31,

    //> RISCV CSR
    UC_RISCV_REG_USTATUS,
    UC_RISCV_REG_UIE,
    UC_RISCV_REG_UTVEC,
    UC_RISCV_REG_USCRATCH,
    UC_RISCV_REG_UEPC,
    UC_RISCV_REG_UCAUSE,
    UC_RISCV_REG_UTVAL,
    UC_RISCV_REG_UIP,
    UC_RISCV_REG_FFLAGS,
    UC_RISCV_REG_FRM,
    UC_RISCV_REG_FCSR,
    UC_RISCV_REG_CYCLE,
    UC_RISCV_REG_TIME,
    UC_RISCV_REG_INSTRET,
    UC_RISCV_REG_HPMCOUNTER3,
    UC_RISCV_REG_HPMCOUNTER4,
    UC_RISCV_REG_HPMCOUNTER5,
    UC_RISCV_REG_HPMCOUNTER6,
    UC_RISCV_REG_HPMCOUNTER7,
    UC_RISCV_REG_HPMCOUNTER8,
    UC_RISCV_REG_HPMCOUNTER9,
    UC_RISCV_REG_HPMCOUNTER10,
    UC_RISCV_REG_HPMCOUNTER11,
    UC_RISCV_REG_HPMCOUNTER12,
    UC_RISCV_REG_HPMCOUNTER13,
    UC_RISCV_REG_HPMCOUNTER14,
    UC_RISCV_REG_HPMCOUNTER15,
    UC_RISCV_REG_HPMCOUNTER16,
    UC_RISCV_REG_HPMCOUNTER17,
    UC_RISCV_REG_HPMCOUNTER18,
    UC_RISCV_REG_HPMCOUNTER19,
    UC_RISCV_REG_HPMCOUNTER20,
    UC_RISCV_REG_HPMCOUNTER21,
    UC_RISCV_REG_HPMCOUNTER22,
    UC_RISCV_REG_HPMCOUNTER23,
    UC_RISCV_REG_HPMCOUNTER24,
    UC_RISCV_REG_HPMCOUNTER25,
    UC_RISCV_REG_HPMCOUNTER26,
    UC_RISCV_REG_HPMCOUNTER27,
    UC_RISCV_REG_HPMCOUNTER28,
    UC_RISCV_REG_HPMCOUNTER29,
    UC_RISCV_REG_HPMCOUNTER30,
    UC_RISCV_REG_HPMCOUNTER31,
    UC_RISCV_REG_CYCLEH,
    UC_RISCV_REG_TIMEH,
    UC_RISCV_REG_INSTRETH,
    UC_RISCV_REG_HPMCOUNTER3H,
    UC_RISCV_REG_HPMCOUNTER4H,
    UC_RISCV_REG_HPMCOUNTER5H,
    UC_RISCV_REG_HPMCOUNTER6H,
    UC_RISCV_REG_HPMCOUNTER7H,
    UC_RISCV_REG_HPMCOUNTER8H,
    UC_RISCV_REG_HPMCOUNTER9H,
    UC_RISCV_REG_HPMCOUNTER10H,
    UC_RISCV_REG_HPMCOUNTER11H,
    UC_RISCV_REG_HPMCOUNTER12H,
    UC_RISCV_REG_HPMCOUNTER13H,
    UC_RISCV_REG_HPMCOUNTER14H,
    UC_RISCV_REG_HPMCOUNTER15H,
    UC_RISCV_REG_HPMCOUNTER16H,
    UC_RISCV_REG_HPMCOUNTER17H,
    UC_RISCV_REG_HPMCOUNTER18H,
    UC_RISCV_REG_HPMCOUNTER19H,
    UC_RISCV_REG_HPMCOUNTER20H,
    UC_RISCV_REG_HPMCOUNTER21H,
    UC_RISCV_REG_HPMCOUNTER22H,
    UC_RISCV_REG_HPMCOUNTER23H,
    UC_RISCV_REG_HPMCOUNTER24H,
    UC_RISCV_REG_HPMCOUNTER25H,
    UC_RISCV_REG_HPMCOUNTER26H,
    UC_RISCV_REG_HPMCOUNTER27H,
    UC_RISCV_REG_HPMCOUNTER28H,
    UC_RISCV_REG_HPMCOUNTER29H,
    UC_RISCV_REG_HPMCOUNTER30H,
    UC_RISCV_REG_HPMCOUNTER31H,
    UC_RISCV_REG_MCYCLE,
    UC_RISCV_REG_MINSTRET,
    UC_RISCV_REG_MCYCLEH,
    UC_RISCV_REG_MINSTRETH,
    UC_RISCV_REG_MVENDORID,
    UC_RISCV_REG_MARCHID,
    UC_RISCV_REG_MIMPID,
    UC_RISCV_REG_MHARTID,
    UC_RISCV_REG_MSTATUS,
    UC_RISCV_REG_MISA,
    UC_RISCV_REG_MEDELEG,
    UC_RISCV_REG_MIDELEG,
    UC_RISCV_REG_MIE,
    UC_RISCV_REG_MTVEC,
    UC_RISCV_REG_MCOUNTEREN,
    UC_RISCV_REG_MSTATUSH,
    UC_RISCV_REG_MUCOUNTEREN,
    UC_RISCV_REG_MSCOUNTEREN,
    UC_RISCV_REG_MHCOUNTEREN,
    UC_RISCV_REG_MSCRATCH,
    UC_RISCV_REG_MEPC,
    UC_RISCV_REG_MCAUSE,
    UC_RISCV_REG_MTVAL,
    UC_RISCV_REG_MIP,
    UC_RISCV_REG_MBADADDR,
    UC_RISCV_REG_SSTATUS,
    UC_RISCV_REG_SEDELEG,
    UC_RISCV_REG_SIDELEG,
    UC_RISCV_REG_SIE,
    UC_RISCV_REG_STVEC,
    UC_RISCV_REG_SCOUNTEREN,
    UC_RISCV_REG_SSCRATCH,
    UC_RISCV_REG_SEPC,
    UC_RISCV_REG_SCAUSE,
    UC_RISCV_REG_STVAL,
    UC_RISCV_REG_SIP,
    UC_RISCV_REG_SBADADDR,
    UC_RISCV_REG_SPTBR,
    UC_RISCV_REG_SATP,
    UC_RISCV_REG_HSTATUS,
    UC_RISCV_REG_HEDELEG,
    UC_RISCV_REG_HIDELEG,
    UC_RISCV_REG_HIE,
    UC_RISCV_REG_HCOUNTEREN,
    UC_RISCV_REG_HTVAL,
    UC_RISCV_REG_HIP,
    UC_RISCV_REG_HTINST,
    UC_RISCV_REG_HGATP,
    UC_RISCV_REG_HTIMEDELTA,
    UC_RISCV_REG_HTIMEDELTAH,

    //> Floating-point registers
    UC_RISCV_REG_F0,  // "ft0"
    UC_RISCV_REG_F1,  // "ft1"
    UC_RISCV_REG_F2,  // "ft2"
    UC_RISCV_REG_F3,  // "ft3"
    UC_RISCV_REG_F4,  // "ft4"
    UC_RISCV_REG_F5,  // "ft5"
    UC_RISCV_REG_F6,  // "ft6"
    UC_RISCV_REG_F7,  // "ft7"
    UC_RISCV_REG_F8,  // "fs0"
    UC_RISCV_REG_F9,  // "fs1"
    UC_RISCV_REG_F10, // "fa0"
    UC_RISCV_REG_F11, // "fa1"
    UC_RISCV_REG_F12, // "fa2"
    UC_RISCV_REG_F13, // "fa3"
    UC_RISCV_REG_F14, // "fa4"
    UC_RISCV_REG_F15, // "fa5"
    UC_RISCV_REG_F16, // "fa6"
    UC_RISCV_REG_F17, // "fa7"
    UC_RISCV_REG_F18, // "fs2"
    UC_RISCV_REG_F19, // "fs3"
    UC_RISCV_REG_F20, // "fs4"
    UC_RISCV_REG_F21, // "fs5"
    UC_RISCV_REG_F22, // "fs6"
    UC_RISCV_REG_F23, // "fs7"
    UC_RISCV_REG_F24, // "fs8"
    UC_RISCV_REG_F25, // "fs9"
    UC_RISCV_REG_F26, // "fs10"
    UC_RISCV_REG_F27, // "fs11"
    UC_RISCV_REG_F28, // "ft8"
    UC_RISCV_REG_F29, // "ft9"
    UC_RISCV_REG_F30, // "ft10"
    UC_RISCV_REG_F31, // "ft11"

    UC_RISCV_REG_PC, // PC register

    UC_RISCV_REG_ENDING, // <-- mark the end of the list or registers

    //> Alias registers
    UC_RISCV_REG_ZERO = UC_RISCV_REG_X0, // "zero"
    UC_RISCV_REG_RA = UC_RISCV_REG_X1,   // "ra"
    UC_RISCV_REG_SP = UC_RISCV_REG_X2,   // "sp"
    UC_RISCV_REG_GP = UC_RISCV_REG_X3,   // "gp"
    UC_RISCV_REG_TP = UC_RISCV_REG_X4,   // "tp"
    UC_RISCV_REG_T0 = UC_RISCV_REG_X5,   // "t0"
    UC_RISCV_REG_T1 = UC_RISCV_REG_X6,   // "t1"
    UC_RISCV_REG_T2 = UC_RISCV_REG_X7,   // "t2"
    UC_RISCV_REG_S0 = UC_RISCV_REG_X8,   // "s0"
    UC_RISCV_REG_FP = UC_RISCV_REG_X8,   // "fp"
    UC_RISCV_REG_S1 = UC_RISCV_REG_X9,   // "s1"
    UC_RISCV_REG_A0 = UC_RISCV_REG_X10,  // "a0"
    UC_RISCV_REG_A1 = UC_RISCV_REG_X11,  // "a1"
    UC_RISCV_REG_A2 = UC_RISCV_REG_X12,  // "a2"
    UC_RISCV_REG_A3 = UC_RISCV_REG_X13,  // "a3"
    UC_RISCV_REG_A4 = UC_RISCV_REG_X14,  // "a4"
    UC_RISCV_REG_A5 = UC_RISCV_REG_X15,  // "a5"
    UC_RISCV_REG_A6 = UC_RISCV_REG_X16,  // "a6"
    UC_RISCV_REG_A7 = UC_RISCV_REG_X17,  // "a7"
    UC_RISCV_REG_S2 = UC_RISCV_REG_X18,  // "s2"
    UC_RISCV_REG_S3 = UC_RISCV_REG_X19,  // "s3"
    UC_RISCV_REG_S4 = UC_RISCV_REG_X20,  // "s4"
    UC_RISCV_REG_S5 = UC_RISCV_REG_X21,  // "s5"
    UC_RISCV_REG_S6 = UC_RISCV_REG_X22,  // "s6"
    UC_RISCV_REG_S7 = UC_RISCV_REG_X23,  // "s7"
    UC_RISCV_REG_S8 = UC_RISCV_REG_X24,  // "s8"
    UC_RISCV_REG_S9 = UC_RISCV_REG_X25,  // "s9"
    UC_RISCV_REG_S10 = UC_RISCV_REG_X26, // "s10"
    UC_RISCV_REG_S11 = UC_RISCV_REG_X27, // "s11"
    UC_RISCV_REG_T3 = UC_RISCV_REG_X28,  // "t3"
    UC_RISCV_REG_T4 = UC_RISCV_REG_X29,  // "t4"
    UC_RISCV_REG_T5 = UC_RISCV_REG_X30,  // "t5"
    UC_RISCV_REG_T6 = UC_RISCV_REG_X31,  // "t6"

    UC_RISCV_REG_FT0 = UC_RISCV_REG_F0, // "ft0"
    UC_RISCV_REG_FT1 = UC_RISCV_REG_F1, // "ft1"
    UC_RISCV_REG_FT2 = UC_RISCV_REG_F2, // "ft2"
    UC_RISCV_REG_FT3 = UC_RISCV_REG_F3, // "ft3"
    UC_RISCV_REG_FT4 = UC_RISCV_REG_F4, // "ft4"
    UC_RISCV_REG_FT5 = UC_RISCV_REG_F5, // "ft5"
    UC_RISCV_REG_FT6 = UC_RISCV_REG_F6, // "ft6"
    UC_RISCV_REG_FT7 = UC_RISCV_REG_F7, // "ft7"
    UC_RISCV_REG_FS0 = UC_RISCV_REG_F8, // "fs0"
    UC_RISCV_REG_FS1 = UC_RISCV_REG_F9, // "fs1"

    UC_RISCV_REG_FA0 = UC_RISCV_REG_F10,  // "fa0"
    UC_RISCV_REG_FA1 = UC_RISCV_REG_F11,  // "fa1"
    UC_RISCV_REG_FA2 = UC_RISCV_REG_F12,  // "fa2"
    UC_RISCV_REG_FA3 = UC_RISCV_REG_F13,  // "fa3"
    UC_RISCV_REG_FA4 = UC_RISCV_REG_F14,  // "fa4"
    UC_RISCV_REG_FA5 = UC_RISCV_REG_F15,  // "fa5"
    UC_RISCV_REG_FA6 = UC_RISCV_REG_F16,  // "fa6"
    UC_RISCV_REG_FA7 = UC_RISCV_REG_F17,  // "fa7"
    UC_RISCV_REG_FS2 = UC_RISCV_REG_F18,  // "fs2"
    UC_RISCV_REG_FS3 = UC_RISCV_REG_F19,  // "fs3"
    UC_RISCV_REG_FS4 = UC_RISCV_REG_F20,  // "fs4"
    UC_RISCV_REG_FS5 = UC_RISCV_REG_F21,  // "fs5"
    UC_RISCV_REG_FS6 = UC_RISCV_REG_F22,  // "fs6"
    UC_RISCV_REG_FS7 = UC_RISCV_REG_F23,  // "fs7"
    UC_RISCV_REG_FS8 = UC_RISCV_REG_F24,  // "fs8"
    UC_RISCV_REG_FS9 = UC_RISCV_REG_F25,  // "fs9"
    UC_RISCV_REG_FS10 = UC_RISCV_REG_F26, // "fs10"
    UC_RISCV_REG_FS11 = UC_RISCV_REG_F27, // "fs11"
    UC_RISCV_REG_FT8 = UC_RISCV_REG_F28,  // "ft8"
    UC_RISCV_REG_FT9 = UC_RISCV_REG_F29,  // "ft9"
    UC_RISCV_REG_FT10 = UC_RISCV_REG_F30, // "ft10"
    UC_RISCV_REG_FT11 = UC_RISCV_REG_F31, // "ft11"
} uc_riscv_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`VanguardImportResolver/Dependencies/Unicorn/unicorn/s390x.h`:

```h
/* Unicorn Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2021 */

#ifndef UNICORN_S390X_H
#define UNICORN_S390X_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> S390X CPU
typedef enum uc_cpu_s390x {
    UC_CPU_S390X_Z900 = 0,
    UC_CPU_S390X_Z900_2,
    UC_CPU_S390X_Z900_3,
    UC_CPU_S390X_Z800,
    UC_CPU_S390X_Z990,
    UC_CPU_S390X_Z990_2,
    UC_CPU_S390X_Z990_3,
    UC_CPU_S390X_Z890,
    UC_CPU_S390X_Z990_4,
    UC_CPU_S390X_Z890_2,
    UC_CPU_S390X_Z990_5,
    UC_CPU_S390X_Z890_3,
    UC_CPU_S390X_Z9EC,
    UC_CPU_S390X_Z9EC_2,
    UC_CPU_S390X_Z9BC,
    UC_CPU_S390X_Z9EC_3,
    UC_CPU_S390X_Z9BC_2,
    UC_CPU_S390X_Z10EC,
    UC_CPU_S390X_Z10EC_2,
    UC_CPU_S390X_Z10BC,
    UC_CPU_S390X_Z10EC_3,
    UC_CPU_S390X_Z10BC_2,
    UC_CPU_S390X_Z196,
    UC_CPU_S390X_Z196_2,
    UC_CPU_S390X_Z114,
    UC_CPU_S390X_ZEC12,
    UC_CPU_S390X_ZEC12_2,
    UC_CPU_S390X_ZBC12,
    UC_CPU_S390X_Z13,
    UC_CPU_S390X_Z13_2,
    UC_CPU_S390X_Z13S,
    UC_CPU_S390X_Z14,
    UC_CPU_S390X_Z14_2,
    UC_CPU_S390X_Z14ZR1,
    UC_CPU_S390X_GEN15A,
    UC_CPU_S390X_GEN15B,
    UC_CPU_S390X_QEMU,
    UC_CPU_S390X_MAX,

    UC_CPU_S390X_ENDING
} uc_cpu_s390x;

//> S390X registers
typedef enum uc_s390x_reg {
    UC_S390X_REG_INVALID = 0,
    //> General purpose registers
    UC_S390X_REG_R0,
    UC_S390X_REG_R1,
    UC_S390X_REG_R2,
    UC_S390X_REG_R3,
    UC_S390X_REG_R4,
    UC_S390X_REG_R5,
    UC_S390X_REG_R6,
    UC_S390X_REG_R7,
    UC_S390X_REG_R8,
    UC_S390X_REG_R9,
    UC_S390X_REG_R10,
    UC_S390X_REG_R11,
    UC_S390X_REG_R12,
    UC_S390X_REG_R13,
    UC_S390X_REG_R14,
    UC_S390X_REG_R15,

    //> Floating point registers
    UC_S390X_REG_F0,
    UC_S390X_REG_F1,
    UC_S390X_REG_F2,
    UC_S390X_REG_F3,
    UC_S390X_REG_F4,
    UC_S390X_REG_F5,
    UC_S390X_REG_F6,
    UC_S390X_REG_F7,
    UC_S390X_REG_F8,
    UC_S390X_REG_F9,
    UC_S390X_REG_F10,
    UC_S390X_REG_F11,
    UC_S390X_REG_F12,
    UC_S390X_REG_F13,
    UC_S390X_REG_F14,
    UC_S390X_REG_F15,
    UC_S390X_REG_F16,
    UC_S390X_REG_F17,
    UC_S390X_REG_F18,
    UC_S390X_REG_F19,
    UC_S390X_REG_F20,
    UC_S390X_REG_F21,
    UC_S390X_REG_F22,
    UC_S390X_REG_F23,
    UC_S390X_REG_F24,
    UC_S390X_REG_F25,
    UC_S390X_REG_F26,
    UC_S390X_REG_F27,
    UC_S390X_REG_F28,
    UC_S390X_REG_F29,
    UC_S390X_REG_F30,
    UC_S390X_REG_F31,

    //> Access registers
    UC_S390X_REG_A0,
    UC_S390X_REG_A1,
    UC_S390X_REG_A2,
    UC_S390X_REG_A3,
    UC_S390X_REG_A4,
    UC_S390X_REG_A5,
    UC_S390X_REG_A6,
    UC_S390X_REG_A7,
    UC_S390X_REG_A8,
    UC_S390X_REG_A9,
    UC_S390X_REG_A10,
    UC_S390X_REG_A11,
    UC_S390X_REG_A12,
    UC_S390X_REG_A13,
    UC_S390X_REG_A14,
    UC_S390X_REG_A15,

    UC_S390X_REG_PC, // PC register
    UC_S390X_REG_PSWM,

    UC_S390X_REG_ENDING, // <-- mark the end of the list or registers

    //> Alias registers
} uc_s390x_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`VanguardImportResolver/Dependencies/Unicorn/unicorn/sparc.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_SPARC_H
#define UNICORN_SPARC_H

#ifdef __cplusplus
extern "C" {
#endif

// GCC SPARC toolchain has a default macro called "sparc" which breaks
// compilation
#undef sparc

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> SPARC32 CPU
typedef enum uc_cpu_sparc32 {
    UC_CPU_SPARC32_FUJITSU_MB86904 = 0,
    UC_CPU_SPARC32_FUJITSU_MB86907,
    UC_CPU_SPARC32_TI_MICROSPARC_I,
    UC_CPU_SPARC32_TI_MICROSPARC_II,
    UC_CPU_SPARC32_TI_MICROSPARC_IIEP,
    UC_CPU_SPARC32_TI_SUPERSPARC_40,
    UC_CPU_SPARC32_TI_SUPERSPARC_50,
    UC_CPU_SPARC32_TI_SUPERSPARC_51,
    UC_CPU_SPARC32_TI_SUPERSPARC_60,
    UC_CPU_SPARC32_TI_SUPERSPARC_61,
    UC_CPU_SPARC32_TI_SUPERSPARC_II,
    UC_CPU_SPARC32_LEON2,
    UC_CPU_SPARC32_LEON3,

    UC_CPU_SPARC32_ENDING
} uc_cpu_sparc32;

//> SPARC64 CPU
typedef enum uc_cpu_sparc64 {
    UC_CPU_SPARC64_FUJITSU = 0,
    UC_CPU_SPARC64_FUJITSU_III,
    UC_CPU_SPARC64_FUJITSU_IV,
    UC_CPU_SPARC64_FUJITSU_V,
    UC_CPU_SPARC64_TI_ULTRASPARC_I,
    UC_CPU_SPARC64_TI_ULTRASPARC_II,
    UC_CPU_SPARC64_TI_ULTRASPARC_III,
    UC_CPU_SPARC64_TI_ULTRASPARC_IIE,
    UC_CPU_SPARC64_SUN_ULTRASPARC_III,
    UC_CPU_SPARC64_SUN_ULTRASPARC_III_CU,
    UC_CPU_SPARC64_SUN_ULTRASPARC_IIII,
    UC_CPU_SPARC64_SUN_ULTRASPARC_IV,
    UC_CPU_SPARC64_SUN_ULTRASPARC_IV_PLUS,
    UC_CPU_SPARC64_SUN_ULTRASPARC_IIII_PLUS,
    UC_CPU_SPARC64_SUN_ULTRASPARC_T1,
    UC_CPU_SPARC64_SUN_ULTRASPARC_T2,
    UC_CPU_SPARC64_NEC_ULTRASPARC_I,

    UC_CPU_SPARC64_ENDING
} uc_cpu_sparc64;

//> SPARC registers
typedef enum uc_sparc_reg {
    UC_SPARC_REG_INVALID = 0,

    UC_SPARC_REG_F0,
    UC_SPARC_REG_F1,
    UC_SPARC_REG_F2,
    UC_SPARC_REG_F3,
    UC_SPARC_REG_F4,
    UC_SPARC_REG_F5,
    UC_SPARC_REG_F6,
    UC_SPARC_REG_F7,
    UC_SPARC_REG_F8,
    UC_SPARC_REG_F9,
    UC_SPARC_REG_F10,
    UC_SPARC_REG_F11,
    UC_SPARC_REG_F12,
    UC_SPARC_REG_F13,
    UC_SPARC_REG_F14,
    UC_SPARC_REG_F15,
    UC_SPARC_REG_F16,
    UC_SPARC_REG_F17,
    UC_SPARC_REG_F18,
    UC_SPARC_REG_F19,
    UC_SPARC_REG_F20,
    UC_SPARC_REG_F21,
    UC_SPARC_REG_F22,
    UC_SPARC_REG_F23,
    UC_SPARC_REG_F24,
    UC_SPARC_REG_F25,
    UC_SPARC_REG_F26,
    UC_SPARC_REG_F27,
    UC_SPARC_REG_F28,
    UC_SPARC_REG_F29,
    UC_SPARC_REG_F30,
    UC_SPARC_REG_F31,
    UC_SPARC_REG_F32,
    UC_SPARC_REG_F34,
    UC_SPARC_REG_F36,
    UC_SPARC_REG_F38,
    UC_SPARC_REG_F40,
    UC_SPARC_REG_F42,
    UC_SPARC_REG_F44,
    UC_SPARC_REG_F46,
    UC_SPARC_REG_F48,
    UC_SPARC_REG_F50,
    UC_SPARC_REG_F52,
    UC_SPARC_REG_F54,
    UC_SPARC_REG_F56,
    UC_SPARC_REG_F58,
    UC_SPARC_REG_F60,
    UC_SPARC_REG_F62,
    UC_SPARC_REG_FCC0, // Floating condition codes
    UC_SPARC_REG_FCC1,
    UC_SPARC_REG_FCC2,
    UC_SPARC_REG_FCC3,
    UC_SPARC_REG_G0,
    UC_SPARC_REG_G1,
    UC_SPARC_REG_G2,
    UC_SPARC_REG_G3,
    UC_SPARC_REG_G4,
    UC_SPARC_REG_G5,
    UC_SPARC_REG_G6,
    UC_SPARC_REG_G7,
    UC_SPARC_REG_I0,
    UC_SPARC_REG_I1,
    UC_SPARC_REG_I2,
    UC_SPARC_REG_I3,
    UC_SPARC_REG_I4,
    UC_SPARC_REG_I5,
    UC_SPARC_REG_FP,
    UC_SPARC_REG_I7,
    UC_SPARC_REG_ICC, // Integer condition codes
    UC_SPARC_REG_L0,
    UC_SPARC_REG_L1,
    UC_SPARC_REG_L2,
    UC_SPARC_REG_L3,
    UC_SPARC_REG_L4,
    UC_SPARC_REG_L5,
    UC_SPARC_REG_L6,
    UC_SPARC_REG_L7,
    UC_SPARC_REG_O0,
    UC_SPARC_REG_O1,
    UC_SPARC_REG_O2,
    UC_SPARC_REG_O3,
    UC_SPARC_REG_O4,
    UC_SPARC_REG_O5,
    UC_SPARC_REG_SP,
    UC_SPARC_REG_O7,
    UC_SPARC_REG_Y,

    // special register
    UC_SPARC_REG_XCC,

    // pseudo register
    UC_SPARC_REG_PC, // program counter register

    UC_SPARC_REG_ENDING, // <-- mark the end of the list of registers

    // extras
    UC_SPARC_REG_O6 = UC_SPARC_REG_SP,
    UC_SPARC_REG_I6 = UC_SPARC_REG_FP,
} uc_sparc_reg;

#ifdef __cplusplus
}
#endif

#endif

```

`VanguardImportResolver/Dependencies/Unicorn/unicorn/tricore.h`:

```h
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

/*
   Created for Unicorn Engine by Eric Poole <eric.poole@aptiv.com>, 2022
   Copyright 2022 Aptiv
*/

#ifndef UNICORN_TRICORE_H
#define UNICORN_TRICORE_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#endif

//> TRICORE CPU
typedef enum uc_cpu_tricore {
    UC_CPU_TRICORE_TC1796,
    UC_CPU_TRICORE_TC1797,
    UC_CPU_TRICORE_TC27X,

    UC_CPU_TRICORE_ENDING
} uc_cpu_tricore;

//> TRICORE registers
typedef enum uc_tricore_reg {
    UC_TRICORE_REG_INVALID = 0,

    // General purpose registers (GPR)
    // Address GPR
    UC_TRICORE_REG_A0,
    UC_TRICORE_REG_A1,
    UC_TRICORE_REG_A2,
    UC_TRICORE_REG_A3,
    UC_TRICORE_REG_A4,
    UC_TRICORE_REG_A5,
    UC_TRICORE_REG_A6,
    UC_TRICORE_REG_A7,
    UC_TRICORE_REG_A8,
    UC_TRICORE_REG_A9,
    UC_TRICORE_REG_A10,
    UC_TRICORE_REG_A11,
    UC_TRICORE_REG_A12,
    UC_TRICORE_REG_A13,
    UC_TRICORE_REG_A14,
    UC_TRICORE_REG_A15,
    // Data GPR
    UC_TRICORE_REG_D0,
    UC_TRICORE_REG_D1,
    UC_TRICORE_REG_D2,
    UC_TRICORE_REG_D3,
    UC_TRICORE_REG_D4,
    UC_TRICORE_REG_D5,
    UC_TRICORE_REG_D6,
    UC_TRICORE_REG_D7,
    UC_TRICORE_REG_D8,
    UC_TRICORE_REG_D9,
    UC_TRICORE_REG_D10,
    UC_TRICORE_REG_D11,
    UC_TRICORE_REG_D12,
    UC_TRICORE_REG_D13,
    UC_TRICORE_REG_D14,
    UC_TRICORE_REG_D15,

    /* CSFR Register */
    UC_TRICORE_REG_PCXI,

    UC_TRICORE_REG_PSW,

    /* PSW flag cache for faster execution */
    UC_TRICORE_REG_PSW_USB_C,
    UC_TRICORE_REG_PSW_USB_V,
    UC_TRICORE_REG_PSW_USB_SV,
    UC_TRICORE_REG_PSW_USB_AV,
    UC_TRICORE_REG_PSW_USB_SAV,

    UC_TRICORE_REG_PC,
    UC_TRICORE_REG_SYSCON,
    UC_TRICORE_REG_CPU_ID,
    UC_TRICORE_REG_BIV,
    UC_TRICORE_REG_BTV,
    UC_TRICORE_REG_ISP,
    UC_TRICORE_REG_ICR,
    UC_TRICORE_REG_FCX,
    UC_TRICORE_REG_LCX,
    UC_TRICORE_REG_COMPAT,

    UC_TRICORE_REG_DPR0_U,
    UC_TRICORE_REG_DPR1_U,
    UC_TRICORE_REG_DPR2_U,
    UC_TRICORE_REG_DPR3_U,
    UC_TRICORE_REG_DPR0_L,
    UC_TRICORE_REG_DPR1_L,
    UC_TRICORE_REG_DPR2_L,
    UC_TRICORE_REG_DPR3_L,

    UC_TRICORE_REG_CPR0_U,
    UC_TRICORE_REG_CPR1_U,
    UC_TRICORE_REG_CPR2_U,
    UC_TRICORE_REG_CPR3_U,
    UC_TRICORE_REG_CPR0_L,
    UC_TRICORE_REG_CPR1_L,
    UC_TRICORE_REG_CPR2_L,
    UC_TRICORE_REG_CPR3_L,

    UC_TRICORE_REG_DPM0,
    UC_TRICORE_REG_DPM1,
    UC_TRICORE_REG_DPM2,
    UC_TRICORE_REG_DPM3,

    UC_TRICORE_REG_CPM0,
    UC_TRICORE_REG_CPM1,
    UC_TRICORE_REG_CPM2,
    UC_TRICORE_REG_CPM3,

    /* Memory Management Registers */
    UC_TRICORE_REG_MMU_CON,
    UC_TRICORE_REG_MMU_ASI,
    UC_TRICORE_REG_MMU_TVA,
    UC_TRICORE_REG_MMU_TPA,
    UC_TRICORE_REG_MMU_TPX,
    UC_TRICORE_REG_MMU_TFA,

    // 1.3.1 Only
    UC_TRICORE_REG_BMACON,
    UC_TRICORE_REG_SMACON,
    UC_TRICORE_REG_DIEAR,
    UC_TRICORE_REG_DIETR,
    UC_TRICORE_REG_CCDIER,
    UC_TRICORE_REG_MIECON,
    UC_TRICORE_REG_PIEAR,
    UC_TRICORE_REG_PIETR,
    UC_TRICORE_REG_CCPIER,

    /* Debug Registers */
    UC_TRICORE_REG_DBGSR,
    UC_TRICORE_REG_EXEVT,
    UC_TRICORE_REG_CREVT,
    UC_TRICORE_REG_SWEVT,
    UC_TRICORE_REG_TR0EVT,
    UC_TRICORE_REG_TR1EVT,
    UC_TRICORE_REG_DMS,
    UC_TRICORE_REG_DCX,
    UC_TRICORE_REG_DBGTCR,
    UC_TRICORE_REG_CCTRL,
    UC_TRICORE_REG_CCNT,
    UC_TRICORE_REG_ICNT,
    UC_TRICORE_REG_M1CNT,
    UC_TRICORE_REG_M2CNT,
    UC_TRICORE_REG_M3CNT,

    UC_TRICORE_REG_ENDING, // <-- mark the end of the list of registers

    // alias registers
    UC_TRICORE_REG_GA0 = UC_TRICORE_REG_A0,
    UC_TRICORE_REG_GA1 = UC_TRICORE_REG_A1,
    UC_TRICORE_REG_GA8 = UC_TRICORE_REG_A8,
    UC_TRICORE_REG_GA9 = UC_TRICORE_REG_A9,
    UC_TRICORE_REG_SP = UC_TRICORE_REG_A10,
    UC_TRICORE_REG_LR = UC_TRICORE_REG_A11,
    UC_TRICORE_REG_IA = UC_TRICORE_REG_A15,
    UC_TRICORE_REG_ID = UC_TRICORE_REG_D15,
} uc_tricore_reg;

#ifdef __cplusplus
}
#endif

#endif
```

`VanguardImportResolver/Dependencies/Unicorn/unicorn/unicorn.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_ENGINE_H
#define UNICORN_ENGINE_H

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"
#include <stdarg.h>

#if defined(UNICORN_HAS_OSXKERNEL)
#include <libkern/libkern.h>
#else
#include <stdlib.h>
#include <stdio.h>
#endif

struct uc_struct;
typedef struct uc_struct uc_engine;

typedef size_t uc_hook;

#include "m68k.h"
#include "x86.h"
#include "arm.h"
#include "arm64.h"
#include "mips.h"
#include "sparc.h"
#include "ppc.h"
#include "riscv.h"
#include "s390x.h"
#include "tricore.h"

#ifdef __GNUC__
#define DEFAULT_VISIBILITY __attribute__((visibility("default")))
#else
#define DEFAULT_VISIBILITY
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4201)
#pragma warning(disable : 4100)
#ifdef UNICORN_SHARED
#define UNICORN_EXPORT __declspec(dllexport)
#else // defined(UNICORN_STATIC)
#define UNICORN_EXPORT
#endif
#else
#ifdef __GNUC__
#define UNICORN_EXPORT __attribute__((visibility("default")))
#else
#define UNICORN_EXPORT
#endif
#endif

#ifdef __GNUC__
#define UNICORN_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define UNICORN_DEPRECATED __declspec(deprecated)
#else
#pragma message(                                                               \
    "WARNING: You need to implement UNICORN_DEPRECATED for this compiler")
#define UNICORN_DEPRECATED
#endif

// Unicorn API version
#define UC_API_MAJOR 2
#define UC_API_MINOR 0
#define UC_API_PATCH 1
// Release candidate version, 255 means the official release.
#define UC_API_EXTRA 255

// Unicorn package version
#define UC_VERSION_MAJOR UC_API_MAJOR
#define UC_VERSION_MINOR UC_API_MINOR
#define UC_VERSION_PATCH UC_API_PATCH
#define UC_VERSION_EXTRA UC_API_EXTRA

/*
  Macro to create combined version which can be compared to
  result of uc_version() API.
*/
#define UC_MAKE_VERSION(major, minor) ((major << 8) + minor)

// Scales to calculate timeout on microsecond unit
// 1 second = 1000,000 microseconds
#define UC_SECOND_SCALE 1000000
// 1 milisecond = 1000 nanoseconds
#define UC_MILISECOND_SCALE 1000

// Architecture type
typedef enum uc_arch {
    UC_ARCH_ARM = 1, // ARM architecture (including Thumb, Thumb-2)
    UC_ARCH_ARM64,   // ARM-64, also called AArch64
    UC_ARCH_MIPS,    // Mips architecture
    UC_ARCH_X86,     // X86 architecture (including x86 & x86-64)
    UC_ARCH_PPC,     // PowerPC architecture
    UC_ARCH_SPARC,   // Sparc architecture
    UC_ARCH_M68K,    // M68K architecture
    UC_ARCH_RISCV,   // RISCV architecture
    UC_ARCH_S390X,   // S390X architecture
    UC_ARCH_TRICORE, // TriCore architecture
    UC_ARCH_MAX,
} uc_arch;

// Mode type
typedef enum uc_mode {
    UC_MODE_LITTLE_ENDIAN = 0,    // little-endian mode (default mode)
    UC_MODE_BIG_ENDIAN = 1 << 30, // big-endian mode

    // arm / arm64
    UC_MODE_ARM = 0,        // ARM mode
    UC_MODE_THUMB = 1 << 4, // THUMB mode (including Thumb-2)
    // Depreciated, use UC_ARM_CPU_* with uc_ctl instead.
    UC_MODE_MCLASS = 1 << 5,  // ARM's Cortex-M series.
    UC_MODE_V8 = 1 << 6,      // ARMv8 A32 encodings for ARM
    UC_MODE_ARMBE8 = 1 << 10, // Big-endian data and Little-endian code.
                              // Legacy support for UC1 only.

    // arm (32bit) cpu types
    // Depreciated, use UC_ARM_CPU_* with uc_ctl instead.
    UC_MODE_ARM926 = 1 << 7,  // ARM926 CPU type
    UC_MODE_ARM946 = 1 << 8,  // ARM946 CPU type
    UC_MODE_ARM1176 = 1 << 9, // ARM1176 CPU type

    // mips
    UC_MODE_MICRO = 1 << 4,    // MicroMips mode (currently unsupported)
    UC_MODE_MIPS3 = 1 << 5,    // Mips III ISA (currently unsupported)
    UC_MODE_MIPS32R6 = 1 << 6, // Mips32r6 ISA (currently unsupported)
    UC_MODE_MIPS32 = 1 << 2,   // Mips32 ISA
    UC_MODE_MIPS64 = 1 << 3,   // Mips64 ISA

    // x86 / x64
    UC_MODE_16 = 1 << 1, // 16-bit mode
    UC_MODE_32 = 1 << 2, // 32-bit mode
    UC_MODE_64 = 1 << 3, // 64-bit mode

    // ppc
    UC_MODE_PPC32 = 1 << 2, // 32-bit mode
    UC_MODE_PPC64 = 1 << 3, // 64-bit mode (currently unsupported)
    UC_MODE_QPX =
        1 << 4, // Quad Processing eXtensions mode (currently unsupported)

    // sparc
    UC_MODE_SPARC32 = 1 << 2, // 32-bit mode
    UC_MODE_SPARC64 = 1 << 3, // 64-bit mode
    UC_MODE_V9 = 1 << 4,      // SparcV9 mode (currently unsupported)

    // riscv
    UC_MODE_RISCV32 = 1 << 2, // 32-bit mode
    UC_MODE_RISCV64 = 1 << 3, // 64-bit mode

    // m68k
} uc_mode;

// All type of errors encountered by Unicorn API.
// These are values returned by uc_errno()
typedef enum uc_err {
    UC_ERR_OK = 0,         // No error: everything was fine
    UC_ERR_NOMEM,          // Out-Of-Memory error: uc_open(), uc_emulate()
    UC_ERR_ARCH,           // Unsupported architecture: uc_open()
    UC_ERR_HANDLE,         // Invalid handle
    UC_ERR_MODE,           // Invalid/unsupported mode: uc_open()
    UC_ERR_VERSION,        // Unsupported version (bindings)
    UC_ERR_READ_UNMAPPED,  // Quit emulation due to READ on unmapped memory:
                           // uc_emu_start()
    UC_ERR_WRITE_UNMAPPED, // Quit emulation due to WRITE on unmapped memory:
                           // uc_emu_start()
    UC_ERR_FETCH_UNMAPPED, // Quit emulation due to FETCH on unmapped memory:
                           // uc_emu_start()
    UC_ERR_HOOK,           // Invalid hook type: uc_hook_add()
    UC_ERR_INSN_INVALID,   // Quit emulation due to invalid instruction:
                           // uc_emu_start()
    UC_ERR_MAP,            // Invalid memory mapping: uc_mem_map()
    UC_ERR_WRITE_PROT,     // Quit emulation due to UC_MEM_WRITE_PROT violation:
                           // uc_emu_start()
    UC_ERR_READ_PROT,      // Quit emulation due to UC_MEM_READ_PROT violation:
                           // uc_emu_start()
    UC_ERR_FETCH_PROT,     // Quit emulation due to UC_MEM_FETCH_PROT violation:
                           // uc_emu_start()
    UC_ERR_ARG, // Inavalid argument provided to uc_xxx function (See specific
                // function API)
    UC_ERR_READ_UNALIGNED,  // Unaligned read
    UC_ERR_WRITE_UNALIGNED, // Unaligned write
    UC_ERR_FETCH_UNALIGNED, // Unaligned fetch
    UC_ERR_HOOK_EXIST,      // hook for this event already existed
    UC_ERR_RESOURCE,        // Insufficient resource: uc_emu_start()
    UC_ERR_EXCEPTION,       // Unhandled CPU exception
} uc_err;

/*
  Callback function for tracing code (UC_HOOK_CODE & UC_HOOK_BLOCK)

  @address: address where the code is being executed
  @size: size of machine instruction(s) being executed, or 0 when size is
  unknown
  @user_data: user data passed to tracing APIs.
*/
typedef void (*uc_cb_hookcode_t)(uc_engine *uc, uint64_t address, uint32_t size,
                                 void *user_data);

/*
  Callback function for tracing interrupts (for uc_hook_intr())

  @intno: interrupt number
  @user_data: user data passed to tracing APIs.
*/
typedef void (*uc_cb_hookintr_t)(uc_engine *uc, uint32_t intno,
                                 void *user_data);

/*
  Callback function for tracing invalid instructions

  @user_data: user data passed to tracing APIs.

  @return: return true to continue, or false to stop program (due to invalid
  instruction).
*/
typedef bool (*uc_cb_hookinsn_invalid_t)(uc_engine *uc, void *user_data);

/*
  Callback function for tracing IN instruction of X86

  @port: port number
  @size: data size (1/2/4) to be read from this port
  @user_data: user data passed to tracing APIs.
*/
typedef uint32_t (*uc_cb_insn_in_t)(uc_engine *uc, uint32_t port, int size,
                                    void *user_data);

/*
  Callback function for OUT instruction of X86

  @port: port number
  @size: data size (1/2/4) to be written to this port
  @value: data value to be written to this port
*/
typedef void (*uc_cb_insn_out_t)(uc_engine *uc, uint32_t port, int size,
                                 uint32_t value, void *user_data);

// Represent a TranslationBlock.
typedef struct uc_tb {
    uint64_t pc;
    uint16_t icount;
    uint16_t size;
} uc_tb;

/*
  Callback function for new edges between translation blocks.

  @cur_tb: Current TB which is to be generated.
  @prev_tb: The previous TB.
*/
typedef void (*uc_hook_edge_gen_t)(uc_engine *uc, uc_tb *cur_tb, uc_tb *prev_tb,
                                   void *user_data);

/*
  Callback function for tcg opcodes that fits in two arguments.

  @address: Current pc.
  @arg1: The first argument.
  @arg2: The second argument.
*/
typedef void (*uc_hook_tcg_op_2)(uc_engine *uc, uint64_t address, uint64_t arg1,
                                 uint64_t arg2, uint32_t size, void *user_data);

typedef uc_hook_tcg_op_2 uc_hook_tcg_sub_t;

/*
  Callback function for MMIO read

  @offset: offset to the base address of the IO memory.
  @size: data size to read
  @user_data: user data passed to uc_mmio_map()
*/
typedef uint64_t (*uc_cb_mmio_read_t)(uc_engine *uc, uint64_t offset,
                                      unsigned size, void *user_data);

/*
  Callback function for MMIO write

  @offset: offset to the base address of the IO memory.
  @size: data size to write
  @value: data value to be written
  @user_data: user data passed to uc_mmio_map()
*/
typedef void (*uc_cb_mmio_write_t)(uc_engine *uc, uint64_t offset,
                                   unsigned size, uint64_t value,
                                   void *user_data);

// All type of memory accesses for UC_HOOK_MEM_*
typedef enum uc_mem_type {
    UC_MEM_READ = 16,      // Memory is read from
    UC_MEM_WRITE,          // Memory is written to
    UC_MEM_FETCH,          // Memory is fetched
    UC_MEM_READ_UNMAPPED,  // Unmapped memory is read from
    UC_MEM_WRITE_UNMAPPED, // Unmapped memory is written to
    UC_MEM_FETCH_UNMAPPED, // Unmapped memory is fetched
    UC_MEM_WRITE_PROT,     // Write to write protected, but mapped, memory
    UC_MEM_READ_PROT,      // Read from read protected, but mapped, memory
    UC_MEM_FETCH_PROT,     // Fetch from non-executable, but mapped, memory
    UC_MEM_READ_AFTER,     // Memory is read from (successful access)
} uc_mem_type;

// These are all op codes we support to hook for UC_HOOK_TCG_OP_CODE.
// Be cautious since it may bring much more overhead than UC_HOOK_CODE without
// proper flags.
// TODO: Tracing UC_TCG_OP_CALL should be interesting.
typedef enum uc_tcg_op_code {
    UC_TCG_OP_SUB = 0, // Both sub_i32 and sub_i64
} uc_tcg_op_code;

// These are extra flags to be paired with uc_tcg_op_code which is helpful to
// instrument in some certain cases.
typedef enum uc_tcg_op_flag {
    // Only instrument opcode if it would set cc_dst, i.e. cmp instruction.
    UC_TCG_OP_FLAG_CMP = 1 << 0,
    // Only instrument opcode which is directly translated.
    // i.e. x86 sub/subc -> tcg sub_i32/64
    UC_TCG_OP_FLAG_DIRECT = 1 << 1
} uc_tcg_op_flag;

// All type of hooks for uc_hook_add() API.
typedef enum uc_hook_type {
    // Hook all interrupt/syscall events
    UC_HOOK_INTR = 1 << 0,
    // Hook a particular instruction - only a very small subset of instructions
    // supported here
    UC_HOOK_INSN = 1 << 1,
    // Hook a range of code
    UC_HOOK_CODE = 1 << 2,
    // Hook basic blocks
    UC_HOOK_BLOCK = 1 << 3,
    // Hook for memory read on unmapped memory
    UC_HOOK_MEM_READ_UNMAPPED = 1 << 4,
    // Hook for invalid memory write events
    UC_HOOK_MEM_WRITE_UNMAPPED = 1 << 5,
    // Hook for invalid memory fetch for execution events
    UC_HOOK_MEM_FETCH_UNMAPPED = 1 << 6,
    // Hook for memory read on read-protected memory
    UC_HOOK_MEM_READ_PROT = 1 << 7,
    // Hook for memory write on write-protected memory
    UC_HOOK_MEM_WRITE_PROT = 1 << 8,
    // Hook for memory fetch on non-executable memory
    UC_HOOK_MEM_FETCH_PROT = 1 << 9,
    // Hook memory read events.
    UC_HOOK_MEM_READ = 1 << 10,
    // Hook memory write events.
    UC_HOOK_MEM_WRITE = 1 << 11,
    // Hook memory fetch for execution events
    UC_HOOK_MEM_FETCH = 1 << 12,
    // Hook memory read events, but only successful access.
    // The callback will be triggered after successful read.
    UC_HOOK_MEM_READ_AFTER = 1 << 13,
    // Hook invalid instructions exceptions.
    UC_HOOK_INSN_INVALID = 1 << 14,
    // Hook on new edge generation. Could be useful in program analysis.
    //
    // NOTE: This is different from UC_HOOK_BLOCK in 2 ways:
    //       1. The hook is called before executing code.
    //       2. The hook is only called when generation is triggered.
    UC_HOOK_EDGE_GENERATED = 1 << 15,
    // Hook on specific tcg op code. The usage of this hook is similar to
    // UC_HOOK_INSN.
    UC_HOOK_TCG_OPCODE = 1 << 16,
} uc_hook_type;

// Hook type for all events of unmapped memory access
#define UC_HOOK_MEM_UNMAPPED                                                   \
    (UC_HOOK_MEM_READ_UNMAPPED + UC_HOOK_MEM_WRITE_UNMAPPED +                  \
     UC_HOOK_MEM_FETCH_UNMAPPED)
// Hook type for all events of illegal protected memory access
#define UC_HOOK_MEM_PROT                                                       \
    (UC_HOOK_MEM_READ_PROT + UC_HOOK_MEM_WRITE_PROT + UC_HOOK_MEM_FETCH_PROT)
// Hook type for all events of illegal read memory access
#define UC_HOOK_MEM_READ_INVALID                                               \
    (UC_HOOK_MEM_READ_PROT + UC_HOOK_MEM_READ_UNMAPPED)
// Hook type for all events of illegal write memory access
#define UC_HOOK_MEM_WRITE_INVALID                                              \
    (UC_HOOK_MEM_WRITE_PROT + UC_HOOK_MEM_WRITE_UNMAPPED)
// Hook type for all events of illegal fetch memory access
#define UC_HOOK_MEM_FETCH_INVALID                                              \
    (UC_HOOK_MEM_FETCH_PROT + UC_HOOK_MEM_FETCH_UNMAPPED)
// Hook type for all events of illegal memory access
#define UC_HOOK_MEM_INVALID (UC_HOOK_MEM_UNMAPPED + UC_HOOK_MEM_PROT)
// Hook type for all events of valid memory access
// NOTE: UC_HOOK_MEM_READ is triggered before UC_HOOK_MEM_READ_PROT and
// UC_HOOK_MEM_READ_UNMAPPED, so
//       this hook may technically trigger on some invalid reads.
#define UC_HOOK_MEM_VALID                                                      \
    (UC_HOOK_MEM_READ + UC_HOOK_MEM_WRITE + UC_HOOK_MEM_FETCH)

/*
  Callback function for hooking memory (READ, WRITE & FETCH)

  @type: this memory is being READ, or WRITE
  @address: address where the code is being executed
  @size: size of data being read or written
  @value: value of data being written to memory, or irrelevant if type = READ.
  @user_data: user data passed to tracing APIs
*/
typedef void (*uc_cb_hookmem_t)(uc_engine *uc, uc_mem_type type,
                                uint64_t address, int size, int64_t value,
                                void *user_data);

/*
  Callback function for handling invalid memory access events (UNMAPPED and
    PROT events)

  @type: this memory is being READ, or WRITE
  @address: address where the code is being executed
  @size: size of data being read or written
  @value: value of data being written to memory, or irrelevant if type = READ.
  @user_data: user data passed to tracing APIs

  @return: return true to continue, or false to stop program (due to invalid
  memory). NOTE: returning true to continue execution will only work if the
  accessed memory is made accessible with the correct permissions during the
  hook.

           In the event of a UC_MEM_READ_UNMAPPED or UC_MEM_WRITE_UNMAPPED
  callback, the memory should be uc_mem_map()-ed with the correct permissions,
  and the instruction will then read or write to the address as it was supposed
  to.

           In the event of a UC_MEM_FETCH_UNMAPPED callback, the memory can be
  mapped in as executable, in which case execution will resume from the fetched
  address. The instruction pointer may be written to in order to change where
  execution resumes, but the fetch must succeed if execution is to resume.
*/
typedef bool (*uc_cb_eventmem_t)(uc_engine *uc, uc_mem_type type,
                                 uint64_t address, int size, int64_t value,
                                 void *user_data);

/*
  Memory region mapped by uc_mem_map() and uc_mem_map_ptr()
  Retrieve the list of memory regions with uc_mem_regions()
*/
typedef struct uc_mem_region {
    uint64_t begin; // begin address of the region (inclusive)
    uint64_t end;   // end address of the region (inclusive)
    uint32_t perms; // memory permissions of the region
} uc_mem_region;

// All type of queries for uc_query() API.
typedef enum uc_query_type {
    // Dynamically query current hardware mode.
    UC_QUERY_MODE = 1,
    UC_QUERY_PAGE_SIZE, // query pagesize of engine
    UC_QUERY_ARCH, // query architecture of engine (for ARM to query Thumb mode)
    UC_QUERY_TIMEOUT, // query if emulation stops due to timeout (indicated if
                      // result = True)
} uc_query_type;

// The implementation of uc_ctl is like what Linux ioctl does but slightly
// different.
//
// A uc_control_type passed to uc_ctl is constructed as:
//
//    R/W       NR       Reserved     Type
//  [      ] [      ]  [         ] [       ]
//  31    30 29     26 25       16 15      0
//
//  @R/W: Whether the operation is a read or write access.
//  @NR: Number of arguments.
//  @Reserved: Should be zero, reserved for future extension.
//  @Type: Taken from uc_control_type enum.
//
// See the helper macros below.

// No input and output arguments.
#define UC_CTL_IO_NONE (0)
// Only input arguments for a write operation.
#define UC_CTL_IO_WRITE (1)
// Only output arguments for a read operation.
#define UC_CTL_IO_READ (2)
// The arguments include both input and output arugments.
#define UC_CTL_IO_READ_WRITE (UC_CTL_IO_WRITE | UC_CTL_IO_READ)

#define UC_CTL(type, nr, rw)                                                   \
    (uc_control_type)((type) | ((nr) << 26) | ((rw) << 30))
#define UC_CTL_NONE(type, nr) UC_CTL(type, nr, UC_CTL_IO_NONE)
#define UC_CTL_READ(type, nr) UC_CTL(type, nr, UC_CTL_IO_READ)
#define UC_CTL_WRITE(type, nr) UC_CTL(type, nr, UC_CTL_IO_WRITE)
#define UC_CTL_READ_WRITE(type, nr) UC_CTL(type, nr, UC_CTL_IO_READ_WRITE)

// All type of controls for uc_ctl API.
// The controls are organized in a tree level.
// If a control don't have `Set` or `Get` for @args, it means it's r/o or w/o.
typedef enum uc_control_type {
    // Current mode.
    // Read: @args = (int*)
    UC_CTL_UC_MODE = 0,
    // Curent page size.
    // Write: @args = (uint32_t)
    // Read: @args = (uint32_t*)
    UC_CTL_UC_PAGE_SIZE,
    // Current arch.
    // Read: @args = (int*)
    UC_CTL_UC_ARCH,
    // Current timeout.
    // Read: @args = (uint64_t*)
    UC_CTL_UC_TIMEOUT,
    // Enable multiple exits.
    // Without this control, reading/setting exits won't work.
    // This is for API backward compatibility.
    // Write: @args = (int)
    UC_CTL_UC_USE_EXITS,
    // The number of current exits.
    // Read: @args = (size_t*)
    UC_CTL_UC_EXITS_CNT,
    // Current exits.
    // Write: @args = (uint64_t* exits, size_t len)
    //        @len = UC_CTL_UC_EXITS_CNT
    // Read: @args = (uint64_t* exits, size_t len)
    //       @len = UC_CTL_UC_EXITS_CNT
    UC_CTL_UC_EXITS,

    // Set the cpu model of uc.
    // Note this option can only be set before any Unicorn
    // API is called except for uc_open.
    // Write: @args = (int)
    // Read:  @args = (int*)
    UC_CTL_CPU_MODEL,
    // Request a tb cache at a specific address
    // Read: @args = (uint64_t, uc_tb*)
    UC_CTL_TB_REQUEST_CACHE,
    // Invalidate a tb cache at a specific address
    // Write: @args = (uint64_t, uint64_t)
    UC_CTL_TB_REMOVE_CACHE,
    // Invalidate all translation blocks.
    // No arguments.
    UC_CTL_TB_FLUSH

} uc_control_type;

/*

Exits Mechanism

In some cases, users may have multiple exits and the @until parameter of
uc_emu_start is not sufficient to control the emulation. The exits mechanism is
designed to solve this problem. Note that using hooks is aslo feasible, but the
exits could be slightly more efficient and easy to implement.

By default, the exits mechanism is disabled to keep backward compatibility. That
is to say, calling uc_ctl_set/get_exits would return an error. Thus, to enable
the exits firstly, call:

  uc_ctl_exits_enable(uc)

After this call, the @until parameter of uc_emu_start would have no effect on
the emulation, so:

  uc_emu_start(uc, 0x1000, 0 ...)
  uc_emu_start(uc, 0x1000, 0x1000 ...)
  uc_emu_start(uc, 0x1000, -1 ...)

The three calls are totally equavelent since the @until is ignored.

To setup the exits, users may call:

  uc_ctl_set/get_exits(uc, exits, len)

For example, with an exits array [0x1000, 0x2000], uc_emu_start would stop at
either 0x1000 and 0x2000. With an exits array [], uc_emu_start won't stop unless
some hooks request a stop.

If users would like to restore the default behavior of @until parameter, users
may call:

  uc_ctl_exits_disable(uc)

After that, all exits setup previously would be cleared and @until parameter
would take effect again.

See sample_ctl.c for a detailed example.

*/
#define uc_ctl_get_mode(uc, mode)                                              \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_MODE, 1), (mode))
#define uc_ctl_get_page_size(uc, ptr)                                          \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_PAGE_SIZE, 1), (ptr))
#define uc_ctl_set_page_size(uc, page_size)                                    \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_UC_PAGE_SIZE, 1), (page_size))
#define uc_ctl_get_arch(uc, arch)                                              \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_ARCH, 1), (arch))
#define uc_ctl_get_timeout(uc, ptr)                                            \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_TIMEOUT, 1), (ptr))
#define uc_ctl_exits_enable(uc)                                                \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_UC_USE_EXITS, 1), 1)
#define uc_ctl_exits_disable(uc)                                               \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_UC_USE_EXITS, 1), 0)
#define uc_ctl_get_exits_cnt(uc, ptr)                                          \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_EXITS_CNT, 1), (ptr))
#define uc_ctl_get_exits(uc, buffer, len)                                      \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_UC_EXITS, 2), (buffer), (len))
#define uc_ctl_set_exits(uc, buffer, len)                                      \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_UC_EXITS, 2), (buffer), (len))
#define uc_ctl_get_cpu_model(uc, model)                                        \
    uc_ctl(uc, UC_CTL_READ(UC_CTL_CPU_MODEL, 1), (model))
#define uc_ctl_set_cpu_model(uc, model)                                        \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_CPU_MODEL, 1), (model))
#define uc_ctl_remove_cache(uc, address, end)                                  \
    uc_ctl(uc, UC_CTL_WRITE(UC_CTL_TB_REMOVE_CACHE, 2), (address), (end))
#define uc_ctl_request_cache(uc, address, tb)                                  \
    uc_ctl(uc, UC_CTL_READ_WRITE(UC_CTL_TB_REQUEST_CACHE, 2), (address), (tb))
#define uc_ctl_flush_tlb(uc) uc_ctl(uc, UC_CTL_WRITE(UC_CTL_TB_FLUSH, 0))
// Opaque storage for CPU context, used with uc_context_*()
struct uc_context;
typedef struct uc_context uc_context;

/*
 Return combined API version & major and minor version numbers.

 @major: major number of API version
 @minor: minor number of API version

 @return hexical number as (major << 8 | minor), which encodes both
     major & minor versions.
     NOTE: This returned value can be compared with version number made
     with macro UC_MAKE_VERSION

 For example, second API version would return 1 in @major, and 1 in @minor
 The return value would be 0x0101

 NOTE: if you only care about returned value, but not major and minor values,
 set both @major & @minor arguments to NULL.
*/
UNICORN_EXPORT
unsigned int uc_version(unsigned int *major, unsigned int *minor);

/*
 Determine if the given architecture is supported by this library.

 @arch: architecture type (UC_ARCH_*)

 @return True if this library supports the given arch.
*/
UNICORN_EXPORT
bool uc_arch_supported(uc_arch arch);

/*
 Create new instance of unicorn engine.

 @arch: architecture type (UC_ARCH_*)
 @mode: hardware mode. This is combined of UC_MODE_*
 @uc: pointer to uc_engine, which will be updated at return time

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_open(uc_arch arch, uc_mode mode, uc_engine **uc);

/*
 Close a Unicorn engine instance.
 NOTE: this must be called only when there is no longer any
 usage of @uc. This API releases some of @uc's cached memory, thus
 any use of the Unicorn API with @uc after it has been closed may
 crash your application. After this, @uc is invalid, and is no
 longer usable.

 @uc: pointer to a handle returned by uc_open()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_close(uc_engine *uc);

/*
 Query internal status of engine.

 @uc: handle returned by uc_open()
 @type: query type. See uc_query_type

 @result: save the internal status queried

 @return: error code of uc_err enum type (UC_ERR_*, see above)
*/
UNICORN_EXPORT
uc_err uc_query(uc_engine *uc, uc_query_type type, size_t *result);

/*
 Control internal states of engine.

 Also see uc_ctl_* macro helpers for easy use.

 @uc: handle returned by uc_open()
 @control: the control type.
 @args: See uc_control_type for details about variadic arguments.

 @return: error code of uc_err enum type (UC_ERR_*, see above)
*/
UNICORN_EXPORT
uc_err uc_ctl(uc_engine *uc, uc_control_type control, ...);

/*
 Report the last error number when some API function fails.
 Like glibc's errno, uc_errno might not retain its old value once accessed.

 @uc: handle returned by uc_open()

 @return: error code of uc_err enum type (UC_ERR_*, see above)
*/
UNICORN_EXPORT
uc_err uc_errno(uc_engine *uc);

/*
 Return a string describing given error code.

 @code: error code (see UC_ERR_* above)

 @return: returns a pointer to a string that describes the error code
   passed in the argument @code
 */
UNICORN_EXPORT
const char *uc_strerror(uc_err code);

/*
 Write to register.

 @uc: handle returned by uc_open()
 @regid:  register ID that is to be modified.
 @value:  pointer to the value that will set to register @regid

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_reg_write(uc_engine *uc, int regid, const void *value);

/*
 Read register value.

 @uc: handle returned by uc_open()
 @regid:  register ID that is to be retrieved.
 @value:  pointer to a variable storing the register value.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_reg_read(uc_engine *uc, int regid, void *value);

/*
 Write multiple register values.

 @uc: handle returned by uc_open()
 @rges:  array of register IDs to store
 @value: pointer to array of register values
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_reg_write_batch(uc_engine *uc, int *regs, void *const *vals,
                          int count);

/*
 Read multiple register values.

 @uc: handle returned by uc_open()
 @rges:  array of register IDs to retrieve
 @value: pointer to array of values to hold registers
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_reg_read_batch(uc_engine *uc, int *regs, void **vals, int count);

/*
 Write to a range of bytes in memory.

 @uc: handle returned by uc_open()
 @address: starting memory address of bytes to set.
 @bytes:   pointer to a variable containing data to be written to memory.
 @size:   size of memory to write to.

 NOTE: @bytes must be big enough to contain @size bytes.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_write(uc_engine *uc, uint64_t address, const void *bytes,
                    size_t size);

/*
 Read a range of bytes in memory.

 @uc: handle returned by uc_open()
 @address: starting memory address of bytes to get.
 @bytes:   pointer to a variable containing data copied from memory.
 @size:   size of memory to read.

 NOTE: @bytes must be big enough to contain @size bytes.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_read(uc_engine *uc, uint64_t address, void *bytes, size_t size);

/*
 Emulate machine code in a specific duration of time.

 @uc: handle returned by uc_open()
 @begin: address where emulation starts
 @until: address where emulation stops (i.e. when this address is hit)
 @timeout: duration to emulate the code (in microseconds). When this value is 0,
        we will emulate the code in infinite time, until the code is finished.
 @count: the number of instructions to be emulated. When this value is 0,
        we will emulate all the code available, until the code is finished.

 NOTE: The internal states of the engine is guranteed to be correct if and only
       if uc_emu_start returns without any errors or errors have been handled in
       the callbacks.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_emu_start(uc_engine *uc, uint64_t begin, uint64_t until,
                    uint64_t timeout, size_t count);

/*
 Stop emulation (which was started by uc_emu_start() API.
 This is typically called from callback functions registered via tracing APIs.

 @uc: handle returned by uc_open()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_emu_stop(uc_engine *uc);

/*
 Register callback for a hook event.
 The callback will be run when the hook event is hit.

 @uc: handle returned by uc_open()
 @hh: hook handle returned from this registration. To be used in uc_hook_del()
 API
 @type: hook type, refer to uc_hook_type enum
 @callback: callback to be run when instruction is hit
 @user_data: user-defined data. This will be passed to callback function in its
      last argument @user_data
 @begin: start address of the area where the callback is in effect (inclusive)
 @end: end address of the area where the callback is in effect (inclusive)
   NOTE 1: the callback is called only if related address is in range [@begin,
 @end] NOTE 2: if @begin > @end, callback is called whenever this hook type is
 triggered
 @...: variable arguments (depending on @type)
   NOTE: if @type = UC_HOOK_INSN, this is the instruction ID.
         currently, only x86 in, out, syscall, sysenter, cpuid are supported.
   NOTE: if @type = UC_HOOK_TCG_OPCODE, arguments are @opcode and @flags. See
 @uc_tcg_op_code and @uc_tcg_op_flag for details.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_hook_add(uc_engine *uc, uc_hook *hh, int type, void *callback,
                   void *user_data, uint64_t begin, uint64_t end, ...);

/*
 Unregister (remove) a hook callback.
 This API removes the hook callback registered by uc_hook_add().
 NOTE: this should be called only when you no longer want to trace.
 After this, @hh is invalid, and no longer usable.

 @uc: handle returned by uc_open()
 @hh: handle returned by uc_hook_add()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_hook_del(uc_engine *uc, uc_hook hh);

typedef enum uc_prot {
    UC_PROT_NONE = 0,
    UC_PROT_READ = 1,
    UC_PROT_WRITE = 2,
    UC_PROT_EXEC = 4,
    UC_PROT_ALL = 7,
} uc_prot;

/*
 Map memory in for emulation.
 This API adds a memory region that can be used by emulation.

 @uc: handle returned by uc_open()
 @address: starting address of the new memory region to be mapped in.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the new memory region to be mapped in.
    This size must be a multiple of 4KB, or this will return with UC_ERR_ARG
 error.
 @perms: Permissions for the newly mapped region.
    This must be some combination of UC_PROT_READ | UC_PROT_WRITE |
 UC_PROT_EXEC, or this will return with UC_ERR_ARG error.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_map(uc_engine *uc, uint64_t address, size_t size, uint32_t perms);

/*
 Map existing host memory in for emulation.
 This API adds a memory region that can be used by emulation.

 @uc: handle returned by uc_open()
 @address: starting address of the new memory region to be mapped in.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the new memory region to be mapped in.
    This size must be a multiple of 4KB, or this will return with UC_ERR_ARG
 error.
 @perms: Permissions for the newly mapped region.
    This must be some combination of UC_PROT_READ | UC_PROT_WRITE |
 UC_PROT_EXEC, or this will return with UC_ERR_ARG error.
 @ptr: pointer to host memory backing the newly mapped memory. This host memory
 is expected to be an equal or larger size than provided, and be mapped with at
    least PROT_READ | PROT_WRITE. If it is not, the resulting behavior is
 undefined.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_map_ptr(uc_engine *uc, uint64_t address, size_t size,
                      uint32_t perms, void *ptr);

/*
 Map MMIO in for emulation.
 This API adds a MMIO region that can be used by emulation.

 @uc: handle returned by uc_open()
 @address: starting address of the new MMIO region to be mapped in.
   This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the new MMIO region to be mapped in.
   This size must be multiple of 4KB, or this will return with UC_ERR_ARG error.
 @read_cb: function for handling reads from this MMIO region.
 @user_data_read: user-defined data. This will be passed to @read_cb function in
 its last argument @user_data
 @write_cb: function for handling writes to this MMIO region.
 @user_data_write: user-defined data. This will be passed to @write_cb function
 in its last argument @user_data
 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
 */
UNICORN_EXPORT
uc_err uc_mmio_map(uc_engine *uc, uint64_t address, size_t size,
                   uc_cb_mmio_read_t read_cb, void *user_data_read,
                   uc_cb_mmio_write_t write_cb, void *user_data_write);

/*
 Unmap a region of emulation memory.
 This API deletes a memory mapping from the emulation memory space.

 @uc: handle returned by uc_open()
 @address: starting address of the memory region to be unmapped.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the memory region to be modified.
    This size must be a multiple of 4KB, or this will return with UC_ERR_ARG
 error.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_unmap(uc_engine *uc, uint64_t address, size_t size);

/*
 Set memory permissions for emulation memory.
 This API changes permissions on an existing memory region.

 @uc: handle returned by uc_open()
 @address: starting address of the memory region to be modified.
    This address must be aligned to 4KB, or this will return with UC_ERR_ARG
 error.
 @size: size of the memory region to be modified.
    This size must be a multiple of 4KB, or this will return with UC_ERR_ARG
 error.
 @perms: New permissions for the mapped region.
    This must be some combination of UC_PROT_READ | UC_PROT_WRITE |
 UC_PROT_EXEC, or this will return with UC_ERR_ARG error.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_protect(uc_engine *uc, uint64_t address, size_t size,
                      uint32_t perms);

/*
 Retrieve all memory regions mapped by uc_mem_map() and uc_mem_map_ptr()
 This API allocates memory for @regions, and user must free this memory later
 by uc_free() to avoid leaking memory.
 NOTE: memory regions may be split by uc_mem_unmap()

 @uc: handle returned by uc_open()
 @regions: pointer to an array of uc_mem_region struct. This is allocated by
   Unicorn, and must be freed by user later with uc_free()
 @count: pointer to number of struct uc_mem_region contained in @regions

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_mem_regions(uc_engine *uc, uc_mem_region **regions, uint32_t *count);

/*
 Allocate a region that can be used with uc_context_{save,restore} to perform
 quick save/rollback of the CPU context, which includes registers and some
 internal metadata. Contexts may not be shared across engine instances with
 differing arches or modes.

 @uc: handle returned by uc_open()
 @context: pointer to a uc_context*. This will be updated with the pointer to
   the new context on successful return of this function.
   Later, this allocated memory must be freed with uc_context_free().

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_alloc(uc_engine *uc, uc_context **context);

/*
 Free the memory allocated by uc_mem_regions.
 WARNING: After Unicorn 1.0.1rc5, the memory allocated by uc_context_alloc
 should be freed by uc_context_free(). Calling uc_free() may still work, but
 the result is **undefined**.

 @mem: memory allocated by uc_mem_regions (returned in *regions).

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_free(void *mem);

/*
 Save a copy of the internal CPU context.
 This API should be used to efficiently make or update a saved copy of the
 internal CPU state.

 @uc: handle returned by uc_open()
 @context: handle returned by uc_context_alloc()

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_save(uc_engine *uc, uc_context *context);

/*
 Write value to a register of a context.

 @ctx: handle returned by uc_context_alloc()
 @regid:  register ID that is to be modified.
 @value:  pointer to the value that will set to register @regid

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_reg_write(uc_context *ctx, int regid, const void *value);

/*
 Read register value from a context.

 @ctx: handle returned by uc_context_alloc()
 @regid:  register ID that is to be retrieved.
 @value:  pointer to a variable storing the register value.

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_reg_read(uc_context *ctx, int regid, void *value);

/*
 Write multiple register values to registers of a context.

 @ctx: handle returned by uc_context_alloc()
 @regs:  array of register IDs to store
 @value: pointer to array of register values
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_reg_write_batch(uc_context *ctx, int *regs, void *const *vals,
                                  int count);

/*
 Read multiple register values from a context.

 @ctx: handle returned by uc_context_alloc()
 @regs:  array of register IDs to retrieve
 @value: pointer to array of values to hold registers
 @count: length of both *regs and *vals

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_reg_read_batch(uc_context *ctx, int *regs, void **vals,
                                 int count);

/*
 Restore the current CPU context from a saved copy.
 This API should be used to roll the CPU context back to a previous
 state saved by uc_context_save().

 @uc: handle returned by uc_open()
 @context: handle returned by uc_context_alloc that has been used with
 uc_context_save

 @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_restore(uc_engine *uc, uc_context *context);

/*
  Return the size needed to store the cpu context. Can be used to allocate a
  buffer to contain the cpu context and directly call uc_context_save.

  @uc: handle returned by uc_open()

  @return the size for needed to store the cpu context as as size_t.
*/
UNICORN_EXPORT
size_t uc_context_size(uc_engine *uc);

/*
  Free the context allocated by uc_context_alloc().

  @context: handle returned by uc_context_alloc()

  @return UC_ERR_OK on success, or other value on failure (refer to uc_err enum
   for detailed error).
*/
UNICORN_EXPORT
uc_err uc_context_free(uc_context *context);

#ifdef __cplusplus
}
#endif

#endif

```

`VanguardImportResolver/Dependencies/Unicorn/unicorn/x86.h`:

```h
/* Unicorn Emulator Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2015-2017 */
/* This file is released under LGPL2.
   See COPYING.LGPL2 in root directory for more details
*/

#ifndef UNICORN_X86_H
#define UNICORN_X86_H

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

//> X86 CPU
typedef enum uc_cpu_x86 {
    UC_CPU_X86_QEMU64 = 0,
    UC_CPU_X86_PHENOM,
    UC_CPU_X86_CORE2DUO,
    UC_CPU_X86_KVM64,
    UC_CPU_X86_QEMU32,
    UC_CPU_X86_KVM32,
    UC_CPU_X86_COREDUO,
    UC_CPU_X86_486,
    UC_CPU_X86_PENTIUM,
    UC_CPU_X86_PENTIUM2,
    UC_CPU_X86_PENTIUM3,
    UC_CPU_X86_ATHLON,
    UC_CPU_X86_N270,
    UC_CPU_X86_CONROE,
    UC_CPU_X86_PENRYN,
    UC_CPU_X86_NEHALEM,
    UC_CPU_X86_WESTMERE,
    UC_CPU_X86_SANDYBRIDGE,
    UC_CPU_X86_IVYBRIDGE,
    UC_CPU_X86_HASWELL,
    UC_CPU_X86_BROADWELL,
    UC_CPU_X86_SKYLAKE_CLIENT,
    UC_CPU_X86_SKYLAKE_SERVER,
    UC_CPU_X86_CASCADELAKE_SERVER,
    UC_CPU_X86_COOPERLAKE,
    UC_CPU_X86_ICELAKE_CLIENT,
    UC_CPU_X86_ICELAKE_SERVER,
    UC_CPU_X86_DENVERTON,
    UC_CPU_X86_SNOWRIDGE,
    UC_CPU_X86_KNIGHTSMILL,
    UC_CPU_X86_OPTERON_G1,
    UC_CPU_X86_OPTERON_G2,
    UC_CPU_X86_OPTERON_G3,
    UC_CPU_X86_OPTERON_G4,
    UC_CPU_X86_OPTERON_G5,
    UC_CPU_X86_EPYC,
    UC_CPU_X86_DHYANA,
    UC_CPU_X86_EPYC_ROME,

    UC_CPU_X86_ENDING
} uc_cpu_x86;

// Memory-Management Register for instructions IDTR, GDTR, LDTR, TR.
// Borrow from SegmentCache in qemu/target-i386/cpu.h
typedef struct uc_x86_mmr {
    uint16_t selector; /* not used by GDTR and IDTR */
    uint64_t base;     /* handle 32 or 64 bit CPUs */
    uint32_t limit;
    uint32_t flags; /* not used by GDTR and IDTR */
} uc_x86_mmr;

// Model-Specific Register structure, use this with UC_X86_REG_MSR (as the
// register ID) in call to uc_reg_write/uc_reg_read() to manipulate MSRs.
typedef struct uc_x86_msr {
    uint32_t rid;   // MSR id
    uint64_t value; // MSR value
} uc_x86_msr;

// Callback function for tracing SYSCALL/SYSENTER (for uc_hook_intr())
// @user_data: user data passed to tracing APIs.
typedef void (*uc_cb_insn_syscall_t)(struct uc_struct *uc, void *user_data);

// Callback function for tracing cpuid (for uc_hook_intr())
// @user_data: user data passed to tracing APIs.
//
// @return: true indicates the callback overwrites the cpuid instruction while
// false
//          indicates cpuid instruction will still be executed.
typedef int (*uc_cb_insn_cpuid_t)(struct uc_struct *uc, void *user_data);

//> X86 registers
typedef enum uc_x86_reg {
    UC_X86_REG_INVALID = 0,
    UC_X86_REG_AH,
    UC_X86_REG_AL,
    UC_X86_REG_AX,
    UC_X86_REG_BH,
    UC_X86_REG_BL,
    UC_X86_REG_BP,
    UC_X86_REG_BPL,
    UC_X86_REG_BX,
    UC_X86_REG_CH,
    UC_X86_REG_CL,
    UC_X86_REG_CS,
    UC_X86_REG_CX,
    UC_X86_REG_DH,
    UC_X86_REG_DI,
    UC_X86_REG_DIL,
    UC_X86_REG_DL,
    UC_X86_REG_DS,
    UC_X86_REG_DX,
    UC_X86_REG_EAX,
    UC_X86_REG_EBP,
    UC_X86_REG_EBX,
    UC_X86_REG_ECX,
    UC_X86_REG_EDI,
    UC_X86_REG_EDX,
    UC_X86_REG_EFLAGS,
    UC_X86_REG_EIP,
    UC_X86_REG_ES = UC_X86_REG_EIP + 2,
    UC_X86_REG_ESI,
    UC_X86_REG_ESP,
    UC_X86_REG_FPSW,
    UC_X86_REG_FS,
    UC_X86_REG_GS,
    UC_X86_REG_IP,
    UC_X86_REG_RAX,
    UC_X86_REG_RBP,
    UC_X86_REG_RBX,
    UC_X86_REG_RCX,
    UC_X86_REG_RDI,
    UC_X86_REG_RDX,
    UC_X86_REG_RIP,
    UC_X86_REG_RSI = UC_X86_REG_RIP + 2,
    UC_X86_REG_RSP,
    UC_X86_REG_SI,
    UC_X86_REG_SIL,
    UC_X86_REG_SP,
    UC_X86_REG_SPL,
    UC_X86_REG_SS,
    UC_X86_REG_CR0,
    UC_X86_REG_CR1,
    UC_X86_REG_CR2,
    UC_X86_REG_CR3,
    UC_X86_REG_CR4,
    UC_X86_REG_CR8 = UC_X86_REG_CR4 + 4,
    UC_X86_REG_DR0 = UC_X86_REG_CR8 + 8,
    UC_X86_REG_DR1,
    UC_X86_REG_DR2,
    UC_X86_REG_DR3,
    UC_X86_REG_DR4,
    UC_X86_REG_DR5,
    UC_X86_REG_DR6,
    UC_X86_REG_DR7,
    UC_X86_REG_FP0 = UC_X86_REG_DR7 + 9,
    UC_X86_REG_FP1,
    UC_X86_REG_FP2,
    UC_X86_REG_FP3,
    UC_X86_REG_FP4,
    UC_X86_REG_FP5,
    UC_X86_REG_FP6,
    UC_X86_REG_FP7,
    UC_X86_REG_K0,
    UC_X86_REG_K1,
    UC_X86_REG_K2,
    UC_X86_REG_K3,
    UC_X86_REG_K4,
    UC_X86_REG_K5,
    UC_X86_REG_K6,
    UC_X86_REG_K7,
    UC_X86_REG_MM0,
    UC_X86_REG_MM1,
    UC_X86_REG_MM2,
    UC_X86_REG_MM3,
    UC_X86_REG_MM4,
    UC_X86_REG_MM5,
    UC_X86_REG_MM6,
    UC_X86_REG_MM7,
    UC_X86_REG_R8,
    UC_X86_REG_R9,
    UC_X86_REG_R10,
    UC_X86_REG_R11,
    UC_X86_REG_R12,
    UC_X86_REG_R13,
    UC_X86_REG_R14,
    UC_X86_REG_R15,
    UC_X86_REG_ST0,
    UC_X86_REG_ST1,
    UC_X86_REG_ST2,
    UC_X86_REG_ST3,
    UC_X86_REG_ST4,
    UC_X86_REG_ST5,
    UC_X86_REG_ST6,
    UC_X86_REG_ST7,
    UC_X86_REG_XMM0,
    UC_X86_REG_XMM1,
    UC_X86_REG_XMM2,
    UC_X86_REG_XMM3,
    UC_X86_REG_XMM4,
    UC_X86_REG_XMM5,
    UC_X86_REG_XMM6,
    UC_X86_REG_XMM7,
    UC_X86_REG_XMM8,
    UC_X86_REG_XMM9,
    UC_X86_REG_XMM10,
    UC_X86_REG_XMM11,
    UC_X86_REG_XMM12,
    UC_X86_REG_XMM13,
    UC_X86_REG_XMM14,
    UC_X86_REG_XMM15,
    UC_X86_REG_XMM16,
    UC_X86_REG_XMM17,
    UC_X86_REG_XMM18,
    UC_X86_REG_XMM19,
    UC_X86_REG_XMM20,
    UC_X86_REG_XMM21,
    UC_X86_REG_XMM22,
    UC_X86_REG_XMM23,
    UC_X86_REG_XMM24,
    UC_X86_REG_XMM25,
    UC_X86_REG_XMM26,
    UC_X86_REG_XMM27,
    UC_X86_REG_XMM28,
    UC_X86_REG_XMM29,
    UC_X86_REG_XMM30,
    UC_X86_REG_XMM31,
    UC_X86_REG_YMM0,
    UC_X86_REG_YMM1,
    UC_X86_REG_YMM2,
    UC_X86_REG_YMM3,
    UC_X86_REG_YMM4,
    UC_X86_REG_YMM5,
    UC_X86_REG_YMM6,
    UC_X86_REG_YMM7,
    UC_X86_REG_YMM8,
    UC_X86_REG_YMM9,
    UC_X86_REG_YMM10,
    UC_X86_REG_YMM11,
    UC_X86_REG_YMM12,
    UC_X86_REG_YMM13,
    UC_X86_REG_YMM14,
    UC_X86_REG_YMM15,
    UC_X86_REG_YMM16,
    UC_X86_REG_YMM17,
    UC_X86_REG_YMM18,
    UC_X86_REG_YMM19,
    UC_X86_REG_YMM20,
    UC_X86_REG_YMM21,
    UC_X86_REG_YMM22,
    UC_X86_REG_YMM23,
    UC_X86_REG_YMM24,
    UC_X86_REG_YMM25,
    UC_X86_REG_YMM26,
    UC_X86_REG_YMM27,
    UC_X86_REG_YMM28,
    UC_X86_REG_YMM29,
    UC_X86_REG_YMM30,
    UC_X86_REG_YMM31,
    UC_X86_REG_ZMM0,
    UC_X86_REG_ZMM1,
    UC_X86_REG_ZMM2,
    UC_X86_REG_ZMM3,
    UC_X86_REG_ZMM4,
    UC_X86_REG_ZMM5,
    UC_X86_REG_ZMM6,
    UC_X86_REG_ZMM7,
    UC_X86_REG_ZMM8,
    UC_X86_REG_ZMM9,
    UC_X86_REG_ZMM10,
    UC_X86_REG_ZMM11,
    UC_X86_REG_ZMM12,
    UC_X86_REG_ZMM13,
    UC_X86_REG_ZMM14,
    UC_X86_REG_ZMM15,
    UC_X86_REG_ZMM16,
    UC_X86_REG_ZMM17,
    UC_X86_REG_ZMM18,
    UC_X86_REG_ZMM19,
    UC_X86_REG_ZMM20,
    UC_X86_REG_ZMM21,
    UC_X86_REG_ZMM22,
    UC_X86_REG_ZMM23,
    UC_X86_REG_ZMM24,
    UC_X86_REG_ZMM25,
    UC_X86_REG_ZMM26,
    UC_X86_REG_ZMM27,
    UC_X86_REG_ZMM28,
    UC_X86_REG_ZMM29,
    UC_X86_REG_ZMM30,
    UC_X86_REG_ZMM31,
    UC_X86_REG_R8B,
    UC_X86_REG_R9B,
    UC_X86_REG_R10B,
    UC_X86_REG_R11B,
    UC_X86_REG_R12B,
    UC_X86_REG_R13B,
    UC_X86_REG_R14B,
    UC_X86_REG_R15B,
    UC_X86_REG_R8D,
    UC_X86_REG_R9D,
    UC_X86_REG_R10D,
    UC_X86_REG_R11D,
    UC_X86_REG_R12D,
    UC_X86_REG_R13D,
    UC_X86_REG_R14D,
    UC_X86_REG_R15D,
    UC_X86_REG_R8W,
    UC_X86_REG_R9W,
    UC_X86_REG_R10W,
    UC_X86_REG_R11W,
    UC_X86_REG_R12W,
    UC_X86_REG_R13W,
    UC_X86_REG_R14W,
    UC_X86_REG_R15W,
    UC_X86_REG_IDTR,
    UC_X86_REG_GDTR,
    UC_X86_REG_LDTR,
    UC_X86_REG_TR,
    UC_X86_REG_FPCW,
    UC_X86_REG_FPTAG,
    UC_X86_REG_MSR, // Model-Specific Register
    UC_X86_REG_MXCSR,
    UC_X86_REG_FS_BASE, // Base regs for x86_64
    UC_X86_REG_GS_BASE,
    UC_X86_REG_FLAGS,
    UC_X86_REG_RFLAGS,
    UC_X86_REG_FIP,
    UC_X86_REG_FCS,
    UC_X86_REG_FDP,
    UC_X86_REG_FDS,
    UC_X86_REG_FOP,
    UC_X86_REG_ENDING // <-- mark the end of the list of registers
} uc_x86_reg;

//> X86 instructions
typedef enum uc_x86_insn {
    UC_X86_INS_INVALID = 0,

    UC_X86_INS_AAA,
    UC_X86_INS_AAD,
    UC_X86_INS_AAM,
    UC_X86_INS_AAS,
    UC_X86_INS_FABS,
    UC_X86_INS_ADC,
    UC_X86_INS_ADCX,
    UC_X86_INS_ADD,
    UC_X86_INS_ADDPD,
    UC_X86_INS_ADDPS,
    UC_X86_INS_ADDSD,
    UC_X86_INS_ADDSS,
    UC_X86_INS_ADDSUBPD,
    UC_X86_INS_ADDSUBPS,
    UC_X86_INS_FADD,
    UC_X86_INS_FIADD,
    UC_X86_INS_FADDP,
    UC_X86_INS_ADOX,
    UC_X86_INS_AESDECLAST,
    UC_X86_INS_AESDEC,
    UC_X86_INS_AESENCLAST,
    UC_X86_INS_AESENC,
    UC_X86_INS_AESIMC,
    UC_X86_INS_AESKEYGENASSIST,
    UC_X86_INS_AND,
    UC_X86_INS_ANDN,
    UC_X86_INS_ANDNPD,
    UC_X86_INS_ANDNPS,
    UC_X86_INS_ANDPD,
    UC_X86_INS_ANDPS,
    UC_X86_INS_ARPL,
    UC_X86_INS_BEXTR,
    UC_X86_INS_BLCFILL,
    UC_X86_INS_BLCI,
    UC_X86_INS_BLCIC,
    UC_X86_INS_BLCMSK,
    UC_X86_INS_BLCS,
    UC_X86_INS_BLENDPD,
    UC_X86_INS_BLENDPS,
    UC_X86_INS_BLENDVPD,
    UC_X86_INS_BLENDVPS,
    UC_X86_INS_BLSFILL,
    UC_X86_INS_BLSI,
    UC_X86_INS_BLSIC,
    UC_X86_INS_BLSMSK,
    UC_X86_INS_BLSR,
    UC_X86_INS_BOUND,
    UC_X86_INS_BSF,
    UC_X86_INS_BSR,
    UC_X86_INS_BSWAP,
    UC_X86_INS_BT,
    UC_X86_INS_BTC,
    UC_X86_INS_BTR,
    UC_X86_INS_BTS,
    UC_X86_INS_BZHI,
    UC_X86_INS_CALL,
    UC_X86_INS_CBW,
    UC_X86_INS_CDQ,
    UC_X86_INS_CDQE,
    UC_X86_INS_FCHS,
    UC_X86_INS_CLAC,
    UC_X86_INS_CLC,
    UC_X86_INS_CLD,
    UC_X86_INS_CLFLUSH,
    UC_X86_INS_CLFLUSHOPT,
    UC_X86_INS_CLGI,
    UC_X86_INS_CLI,
    UC_X86_INS_CLTS,
    UC_X86_INS_CLWB,
    UC_X86_INS_CMC,
    UC_X86_INS_CMOVA,
    UC_X86_INS_CMOVAE,
    UC_X86_INS_CMOVB,
    UC_X86_INS_CMOVBE,
    UC_X86_INS_FCMOVBE,
    UC_X86_INS_FCMOVB,
    UC_X86_INS_CMOVE,
    UC_X86_INS_FCMOVE,
    UC_X86_INS_CMOVG,
    UC_X86_INS_CMOVGE,
    UC_X86_INS_CMOVL,
    UC_X86_INS_CMOVLE,
    UC_X86_INS_FCMOVNBE,
    UC_X86_INS_FCMOVNB,
    UC_X86_INS_CMOVNE,
    UC_X86_INS_FCMOVNE,
    UC_X86_INS_CMOVNO,
    UC_X86_INS_CMOVNP,
    UC_X86_INS_FCMOVNU,
    UC_X86_INS_CMOVNS,
    UC_X86_INS_CMOVO,
    UC_X86_INS_CMOVP,
    UC_X86_INS_FCMOVU,
    UC_X86_INS_CMOVS,
    UC_X86_INS_CMP,
    UC_X86_INS_CMPPD,
    UC_X86_INS_CMPPS,
    UC_X86_INS_CMPSB,
    UC_X86_INS_CMPSD,
    UC_X86_INS_CMPSQ,
    UC_X86_INS_CMPSS,
    UC_X86_INS_CMPSW,
    UC_X86_INS_CMPXCHG16B,
    UC_X86_INS_CMPXCHG,
    UC_X86_INS_CMPXCHG8B,
    UC_X86_INS_COMISD,
    UC_X86_INS_COMISS,
    UC_X86_INS_FCOMP,
    UC_X86_INS_FCOMPI,
    UC_X86_INS_FCOMI,
    UC_X86_INS_FCOM,
    UC_X86_INS_FCOS,
    UC_X86_INS_CPUID,
    UC_X86_INS_CQO,
    UC_X86_INS_CRC32,
    UC_X86_INS_CVTDQ2PD,
    UC_X86_INS_CVTDQ2PS,
    UC_X86_INS_CVTPD2DQ,
    UC_X86_INS_CVTPD2PS,
    UC_X86_INS_CVTPS2DQ,
    UC_X86_INS_CVTPS2PD,
    UC_X86_INS_CVTSD2SI,
    UC_X86_INS_CVTSD2SS,
    UC_X86_INS_CVTSI2SD,
    UC_X86_INS_CVTSI2SS,
    UC_X86_INS_CVTSS2SD,
    UC_X86_INS_CVTSS2SI,
    UC_X86_INS_CVTTPD2DQ,
    UC_X86_INS_CVTTPS2DQ,
    UC_X86_INS_CVTTSD2SI,
    UC_X86_INS_CVTTSS2SI,
    UC_X86_INS_CWD,
    UC_X86_INS_CWDE,
    UC_X86_INS_DAA,
    UC_X86_INS_DAS,
    UC_X86_INS_DATA16,
    UC_X86_INS_DEC,
    UC_X86_INS_DIV,
    UC_X86_INS_DIVPD,
    UC_X86_INS_DIVPS,
    UC_X86_INS_FDIVR,
    UC_X86_INS_FIDIVR,
    UC_X86_INS_FDIVRP,
    UC_X86_INS_DIVSD,
    UC_X86_INS_DIVSS,
    UC_X86_INS_FDIV,
    UC_X86_INS_FIDIV,
    UC_X86_INS_FDIVP,
    UC_X86_INS_DPPD,
    UC_X86_INS_DPPS,
    UC_X86_INS_RET,
    UC_X86_INS_ENCLS,
    UC_X86_INS_ENCLU,
    UC_X86_INS_ENTER,
    UC_X86_INS_EXTRACTPS,
    UC_X86_INS_EXTRQ,
    UC_X86_INS_F2XM1,
    UC_X86_INS_LCALL,
    UC_X86_INS_LJMP,
    UC_X86_INS_FBLD,
    UC_X86_INS_FBSTP,
    UC_X86_INS_FCOMPP,
    UC_X86_INS_FDECSTP,
    UC_X86_INS_FEMMS,
    UC_X86_INS_FFREE,
    UC_X86_INS_FICOM,
    UC_X86_INS_FICOMP,
    UC_X86_INS_FINCSTP,
    UC_X86_INS_FLDCW,
    UC_X86_INS_FLDENV,
    UC_X86_INS_FLDL2E,
    UC_X86_INS_FLDL2T,
    UC_X86_INS_FLDLG2,
    UC_X86_INS_FLDLN2,
    UC_X86_INS_FLDPI,
    UC_X86_INS_FNCLEX,
    UC_X86_INS_FNINIT,
    UC_X86_INS_FNOP,
    UC_X86_INS_FNSTCW,
    UC_X86_INS_FNSTSW,
    UC_X86_INS_FPATAN,
    UC_X86_INS_FPREM,
    UC_X86_INS_FPREM1,
    UC_X86_INS_FPTAN,
    UC_X86_INS_FFREEP,
    UC_X86_INS_FRNDINT,
    UC_X86_INS_FRSTOR,
    UC_X86_INS_FNSAVE,
    UC_X86_INS_FSCALE,
    UC_X86_INS_FSETPM,
    UC_X86_INS_FSINCOS,
    UC_X86_INS_FNSTENV,
    UC_X86_INS_FXAM,
    UC_X86_INS_FXRSTOR,
    UC_X86_INS_FXRSTOR64,
    UC_X86_INS_FXSAVE,
    UC_X86_INS_FXSAVE64,
    UC_X86_INS_FXTRACT,
    UC_X86_INS_FYL2X,
    UC_X86_INS_FYL2XP1,
    UC_X86_INS_MOVAPD,
    UC_X86_INS_MOVAPS,
    UC_X86_INS_ORPD,
    UC_X86_INS_ORPS,
    UC_X86_INS_VMOVAPD,
    UC_X86_INS_VMOVAPS,
    UC_X86_INS_XORPD,
    UC_X86_INS_XORPS,
    UC_X86_INS_GETSEC,
    UC_X86_INS_HADDPD,
    UC_X86_INS_HADDPS,
    UC_X86_INS_HLT,
    UC_X86_INS_HSUBPD,
    UC_X86_INS_HSUBPS,
    UC_X86_INS_IDIV,
    UC_X86_INS_FILD,
    UC_X86_INS_IMUL,
    UC_X86_INS_IN,
    UC_X86_INS_INC,
    UC_X86_INS_INSB,
    UC_X86_INS_INSERTPS,
    UC_X86_INS_INSERTQ,
    UC_X86_INS_INSD,
    UC_X86_INS_INSW,
    UC_X86_INS_INT,
    UC_X86_INS_INT1,
    UC_X86_INS_INT3,
    UC_X86_INS_INTO,
    UC_X86_INS_INVD,
    UC_X86_INS_INVEPT,
    UC_X86_INS_INVLPG,
    UC_X86_INS_INVLPGA,
    UC_X86_INS_INVPCID,
    UC_X86_INS_INVVPID,
    UC_X86_INS_IRET,
    UC_X86_INS_IRETD,
    UC_X86_INS_IRETQ,
    UC_X86_INS_FISTTP,
    UC_X86_INS_FIST,
    UC_X86_INS_FISTP,
    UC_X86_INS_UCOMISD,
    UC_X86_INS_UCOMISS,
    UC_X86_INS_VCOMISD,
    UC_X86_INS_VCOMISS,
    UC_X86_INS_VCVTSD2SS,
    UC_X86_INS_VCVTSI2SD,
    UC_X86_INS_VCVTSI2SS,
    UC_X86_INS_VCVTSS2SD,
    UC_X86_INS_VCVTTSD2SI,
    UC_X86_INS_VCVTTSD2USI,
    UC_X86_INS_VCVTTSS2SI,
    UC_X86_INS_VCVTTSS2USI,
    UC_X86_INS_VCVTUSI2SD,
    UC_X86_INS_VCVTUSI2SS,
    UC_X86_INS_VUCOMISD,
    UC_X86_INS_VUCOMISS,
    UC_X86_INS_JAE,
    UC_X86_INS_JA,
    UC_X86_INS_JBE,
    UC_X86_INS_JB,
    UC_X86_INS_JCXZ,
    UC_X86_INS_JECXZ,
    UC_X86_INS_JE,
    UC_X86_INS_JGE,
    UC_X86_INS_JG,
    UC_X86_INS_JLE,
    UC_X86_INS_JL,
    UC_X86_INS_JMP,
    UC_X86_INS_JNE,
    UC_X86_INS_JNO,
    UC_X86_INS_JNP,
    UC_X86_INS_JNS,
    UC_X86_INS_JO,
    UC_X86_INS_JP,
    UC_X86_INS_JRCXZ,
    UC_X86_INS_JS,
    UC_X86_INS_KANDB,
    UC_X86_INS_KANDD,
    UC_X86_INS_KANDNB,
    UC_X86_INS_KANDND,
    UC_X86_INS_KANDNQ,
    UC_X86_INS_KANDNW,
    UC_X86_INS_KANDQ,
    UC_X86_INS_KANDW,
    UC_X86_INS_KMOVB,
    UC_X86_INS_KMOVD,
    UC_X86_INS_KMOVQ,
    UC_X86_INS_KMOVW,
    UC_X86_INS_KNOTB,
    UC_X86_INS_KNOTD,
    UC_X86_INS_KNOTQ,
    UC_X86_INS_KNOTW,
    UC_X86_INS_KORB,
    UC_X86_INS_KORD,
    UC_X86_INS_KORQ,
    UC_X86_INS_KORTESTB,
    UC_X86_INS_KORTESTD,
    UC_X86_INS_KORTESTQ,
    UC_X86_INS_KORTESTW,
    UC_X86_INS_KORW,
    UC_X86_INS_KSHIFTLB,
    UC_X86_INS_KSHIFTLD,
    UC_X86_INS_KSHIFTLQ,
    UC_X86_INS_KSHIFTLW,
    UC_X86_INS_KSHIFTRB,
    UC_X86_INS_KSHIFTRD,
    UC_X86_INS_KSHIFTRQ,
    UC_X86_INS_KSHIFTRW,
    UC_X86_INS_KUNPCKBW,
    UC_X86_INS_KXNORB,
    UC_X86_INS_KXNORD,
    UC_X86_INS_KXNORQ,
    UC_X86_INS_KXNORW,
    UC_X86_INS_KXORB,
    UC_X86_INS_KXORD,
    UC_X86_INS_KXORQ,
    UC_X86_INS_KXORW,
    UC_X86_INS_LAHF,
    UC_X86_INS_LAR,
    UC_X86_INS_LDDQU,
    UC_X86_INS_LDMXCSR,
    UC_X86_INS_LDS,
    UC_X86_INS_FLDZ,
    UC_X86_INS_FLD1,
    UC_X86_INS_FLD,
    UC_X86_INS_LEA,
    UC_X86_INS_LEAVE,
    UC_X86_INS_LES,
    UC_X86_INS_LFENCE,
    UC_X86_INS_LFS,
    UC_X86_INS_LGDT,
    UC_X86_INS_LGS,
    UC_X86_INS_LIDT,
    UC_X86_INS_LLDT,
    UC_X86_INS_LMSW,
    UC_X86_INS_OR,
    UC_X86_INS_SUB,
    UC_X86_INS_XOR,
    UC_X86_INS_LODSB,
    UC_X86_INS_LODSD,
    UC_X86_INS_LODSQ,
    UC_X86_INS_LODSW,
    UC_X86_INS_LOOP,
    UC_X86_INS_LOOPE,
    UC_X86_INS_LOOPNE,
    UC_X86_INS_RETF,
    UC_X86_INS_RETFQ,
    UC_X86_INS_LSL,
    UC_X86_INS_LSS,
    UC_X86_INS_LTR,
    UC_X86_INS_XADD,
    UC_X86_INS_LZCNT,
    UC_X86_INS_MASKMOVDQU,
    UC_X86_INS_MAXPD,
    UC_X86_INS_MAXPS,
    UC_X86_INS_MAXSD,
    UC_X86_INS_MAXSS,
    UC_X86_INS_MFENCE,
    UC_X86_INS_MINPD,
    UC_X86_INS_MINPS,
    UC_X86_INS_MINSD,
    UC_X86_INS_MINSS,
    UC_X86_INS_CVTPD2PI,
    UC_X86_INS_CVTPI2PD,
    UC_X86_INS_CVTPI2PS,
    UC_X86_INS_CVTPS2PI,
    UC_X86_INS_CVTTPD2PI,
    UC_X86_INS_CVTTPS2PI,
    UC_X86_INS_EMMS,
    UC_X86_INS_MASKMOVQ,
    UC_X86_INS_MOVD,
    UC_X86_INS_MOVDQ2Q,
    UC_X86_INS_MOVNTQ,
    UC_X86_INS_MOVQ2DQ,
    UC_X86_INS_MOVQ,
    UC_X86_INS_PABSB,
    UC_X86_INS_PABSD,
    UC_X86_INS_PABSW,
    UC_X86_INS_PACKSSDW,
    UC_X86_INS_PACKSSWB,
    UC_X86_INS_PACKUSWB,
    UC_X86_INS_PADDB,
    UC_X86_INS_PADDD,
    UC_X86_INS_PADDQ,
    UC_X86_INS_PADDSB,
    UC_X86_INS_PADDSW,
    UC_X86_INS_PADDUSB,
    UC_X86_INS_PADDUSW,
    UC_X86_INS_PADDW,
    UC_X86_INS_PALIGNR,
    UC_X86_INS_PANDN,
    UC_X86_INS_PAND,
    UC_X86_INS_PAVGB,
    UC_X86_INS_PAVGW,
    UC_X86_INS_PCMPEQB,
    UC_X86_INS_PCMPEQD,
    UC_X86_INS_PCMPEQW,
    UC_X86_INS_PCMPGTB,
    UC_X86_INS_PCMPGTD,
    UC_X86_INS_PCMPGTW,
    UC_X86_INS_PEXTRW,
    UC_X86_INS_PHADDSW,
    UC_X86_INS_PHADDW,
    UC_X86_INS_PHADDD,
    UC_X86_INS_PHSUBD,
    UC_X86_INS_PHSUBSW,
    UC_X86_INS_PHSUBW,
    UC_X86_INS_PINSRW,
    UC_X86_INS_PMADDUBSW,
    UC_X86_INS_PMADDWD,
    UC_X86_INS_PMAXSW,
    UC_X86_INS_PMAXUB,
    UC_X86_INS_PMINSW,
    UC_X86_INS_PMINUB,
    UC_X86_INS_PMOVMSKB,
    UC_X86_INS_PMULHRSW,
    UC_X86_INS_PMULHUW,
    UC_X86_INS_PMULHW,
    UC_X86_INS_PMULLW,
    UC_X86_INS_PMULUDQ,
    UC_X86_INS_POR,
    UC_X86_INS_PSADBW,
    UC_X86_INS_PSHUFB,
    UC_X86_INS_PSHUFW,
    UC_X86_INS_PSIGNB,
    UC_X86_INS_PSIGND,
    UC_X86_INS_PSIGNW,
    UC_X86_INS_PSLLD,
    UC_X86_INS_PSLLQ,
    UC_X86_INS_PSLLW,
    UC_X86_INS_PSRAD,
    UC_X86_INS_PSRAW,
    UC_X86_INS_PSRLD,
    UC_X86_INS_PSRLQ,
    UC_X86_INS_PSRLW,
    UC_X86_INS_PSUBB,
    UC_X86_INS_PSUBD,
    UC_X86_INS_PSUBQ,
    UC_X86_INS_PSUBSB,
    UC_X86_INS_PSUBSW,
    UC_X86_INS_PSUBUSB,
    UC_X86_INS_PSUBUSW,
    UC_X86_INS_PSUBW,
    UC_X86_INS_PUNPCKHBW,
    UC_X86_INS_PUNPCKHDQ,
    UC_X86_INS_PUNPCKHWD,
    UC_X86_INS_PUNPCKLBW,
    UC_X86_INS_PUNPCKLDQ,
    UC_X86_INS_PUNPCKLWD,
    UC_X86_INS_PXOR,
    UC_X86_INS_MONITOR,
    UC_X86_INS_MONTMUL,
    UC_X86_INS_MOV,
    UC_X86_INS_MOVABS,
    UC_X86_INS_MOVBE,
    UC_X86_INS_MOVDDUP,
    UC_X86_INS_MOVDQA,
    UC_X86_INS_MOVDQU,
    UC_X86_INS_MOVHLPS,
    UC_X86_INS_MOVHPD,
    UC_X86_INS_MOVHPS,
    UC_X86_INS_MOVLHPS,
    UC_X86_INS_MOVLPD,
    UC_X86_INS_MOVLPS,
    UC_X86_INS_MOVMSKPD,
    UC_X86_INS_MOVMSKPS,
    UC_X86_INS_MOVNTDQA,
    UC_X86_INS_MOVNTDQ,
    UC_X86_INS_MOVNTI,
    UC_X86_INS_MOVNTPD,
    UC_X86_INS_MOVNTPS,
    UC_X86_INS_MOVNTSD,
    UC_X86_INS_MOVNTSS,
    UC_X86_INS_MOVSB,
    UC_X86_INS_MOVSD,
    UC_X86_INS_MOVSHDUP,
    UC_X86_INS_MOVSLDUP,
    UC_X86_INS_MOVSQ,
    UC_X86_INS_MOVSS,
    UC_X86_INS_MOVSW,
    UC_X86_INS_MOVSX,
    UC_X86_INS_MOVSXD,
    UC_X86_INS_MOVUPD,
    UC_X86_INS_MOVUPS,
    UC_X86_INS_MOVZX,
    UC_X86_INS_MPSADBW,
    UC_X86_INS_MUL,
    UC_X86_INS_MULPD,
    UC_X86_INS_MULPS,
    UC_X86_INS_MULSD,
    UC_X86_INS_MULSS,
    UC_X86_INS_MULX,
    UC_X86_INS_FMUL,
    UC_X86_INS_FIMUL,
    UC_X86_INS_FMULP,
    UC_X86_INS_MWAIT,
    UC_X86_INS_NEG,
    UC_X86_INS_NOP,
    UC_X86_INS_NOT,
    UC_X86_INS_OUT,
    UC_X86_INS_OUTSB,
    UC_X86_INS_OUTSD,
    UC_X86_INS_OUTSW,
    UC_X86_INS_PACKUSDW,
    UC_X86_INS_PAUSE,
    UC_X86_INS_PAVGUSB,
    UC_X86_INS_PBLENDVB,
    UC_X86_INS_PBLENDW,
    UC_X86_INS_PCLMULQDQ,
    UC_X86_INS_PCMPEQQ,
    UC_X86_INS_PCMPESTRI,
    UC_X86_INS_PCMPESTRM,
    UC_X86_INS_PCMPGTQ,
    UC_X86_INS_PCMPISTRI,
    UC_X86_INS_PCMPISTRM,
    UC_X86_INS_PCOMMIT,
    UC_X86_INS_PDEP,
    UC_X86_INS_PEXT,
    UC_X86_INS_PEXTRB,
    UC_X86_INS_PEXTRD,
    UC_X86_INS_PEXTRQ,
    UC_X86_INS_PF2ID,
    UC_X86_INS_PF2IW,
    UC_X86_INS_PFACC,
    UC_X86_INS_PFADD,
    UC_X86_INS_PFCMPEQ,
    UC_X86_INS_PFCMPGE,
    UC_X86_INS_PFCMPGT,
    UC_X86_INS_PFMAX,
    UC_X86_INS_PFMIN,
    UC_X86_INS_PFMUL,
    UC_X86_INS_PFNACC,
    UC_X86_INS_PFPNACC,
    UC_X86_INS_PFRCPIT1,
    UC_X86_INS_PFRCPIT2,
    UC_X86_INS_PFRCP,
    UC_X86_INS_PFRSQIT1,
    UC_X86_INS_PFRSQRT,
    UC_X86_INS_PFSUBR,
    UC_X86_INS_PFSUB,
    UC_X86_INS_PHMINPOSUW,
    UC_X86_INS_PI2FD,
    UC_X86_INS_PI2FW,
    UC_X86_INS_PINSRB,
    UC_X86_INS_PINSRD,
    UC_X86_INS_PINSRQ,
    UC_X86_INS_PMAXSB,
    UC_X86_INS_PMAXSD,
    UC_X86_INS_PMAXUD,
    UC_X86_INS_PMAXUW,
    UC_X86_INS_PMINSB,
    UC_X86_INS_PMINSD,
    UC_X86_INS_PMINUD,
    UC_X86_INS_PMINUW,
    UC_X86_INS_PMOVSXBD,
    UC_X86_INS_PMOVSXBQ,
    UC_X86_INS_PMOVSXBW,
    UC_X86_INS_PMOVSXDQ,
    UC_X86_INS_PMOVSXWD,
    UC_X86_INS_PMOVSXWQ,
    UC_X86_INS_PMOVZXBD,
    UC_X86_INS_PMOVZXBQ,
    UC_X86_INS_PMOVZXBW,
    UC_X86_INS_PMOVZXDQ,
    UC_X86_INS_PMOVZXWD,
    UC_X86_INS_PMOVZXWQ,
    UC_X86_INS_PMULDQ,
    UC_X86_INS_PMULHRW,
    UC_X86_INS_PMULLD,
    UC_X86_INS_POP,
    UC_X86_INS_POPAW,
    UC_X86_INS_POPAL,
    UC_X86_INS_POPCNT,
    UC_X86_INS_POPF,
    UC_X86_INS_POPFD,
    UC_X86_INS_POPFQ,
    UC_X86_INS_PREFETCH,
    UC_X86_INS_PREFETCHNTA,
    UC_X86_INS_PREFETCHT0,
    UC_X86_INS_PREFETCHT1,
    UC_X86_INS_PREFETCHT2,
    UC_X86_INS_PREFETCHW,
    UC_X86_INS_PSHUFD,
    UC_X86_INS_PSHUFHW,
    UC_X86_INS_PSHUFLW,
    UC_X86_INS_PSLLDQ,
    UC_X86_INS_PSRLDQ,
    UC_X86_INS_PSWAPD,
    UC_X86_INS_PTEST,
    UC_X86_INS_PUNPCKHQDQ,
    UC_X86_INS_PUNPCKLQDQ,
    UC_X86_INS_PUSH,
    UC_X86_INS_PUSHAW,
    UC_X86_INS_PUSHAL,
    UC_X86_INS_PUSHF,
    UC_X86_INS_PUSHFD,
    UC_X86_INS_PUSHFQ,
    UC_X86_INS_RCL,
    UC_X86_INS_RCPPS,
    UC_X86_INS_RCPSS,
    UC_X86_INS_RCR,
    UC_X86_INS_RDFSBASE,
    UC_X86_INS_RDGSBASE,
    UC_X86_INS_RDMSR,
    UC_X86_INS_RDPMC,
    UC_X86_INS_RDRAND,
    UC_X86_INS_RDSEED,
    UC_X86_INS_RDTSC,
    UC_X86_INS_RDTSCP,
    UC_X86_INS_ROL,
    UC_X86_INS_ROR,
    UC_X86_INS_RORX,
    UC_X86_INS_ROUNDPD,
    UC_X86_INS_ROUNDPS,
    UC_X86_INS_ROUNDSD,
    UC_X86_INS_ROUNDSS,
    UC_X86_INS_RSM,
    UC_X86_INS_RSQRTPS,
    UC_X86_INS_RSQRTSS,
    UC_X86_INS_SAHF,
    UC_X86_INS_SAL,
    UC_X86_INS_SALC,
    UC_X86_INS_SAR,
    UC_X86_INS_SARX,
    UC_X86_INS_SBB,
    UC_X86_INS_SCASB,
    UC_X86_INS_SCASD,
    UC_X86_INS_SCASQ,
    UC_X86_INS_SCASW,
    UC_X86_INS_SETAE,
    UC_X86_INS_SETA,
    UC_X86_INS_SETBE,
    UC_X86_INS_SETB,
    UC_X86_INS_SETE,
    UC_X86_INS_SETGE,
    UC_X86_INS_SETG,
    UC_X86_INS_SETLE,
    UC_X86_INS_SETL,
    UC_X86_INS_SETNE,
    UC_X86_INS_SETNO,
    UC_X86_INS_SETNP,
    UC_X86_INS_SETNS,
    UC_X86_INS_SETO,
    UC_X86_INS_SETP,
    UC_X86_INS_SETS,
    UC_X86_INS_SFENCE,
    UC_X86_INS_SGDT,
    UC_X86_INS_SHA1MSG1,
    UC_X86_INS_SHA1MSG2,
    UC_X86_INS_SHA1NEXTE,
    UC_X86_INS_SHA1RNDS4,
    UC_X86_INS_SHA256MSG1,
    UC_X86_INS_SHA256MSG2,
    UC_X86_INS_SHA256RNDS2,
    UC_X86_INS_SHL,
    UC_X86_INS_SHLD,
    UC_X86_INS_SHLX,
    UC_X86_INS_SHR,
    UC_X86_INS_SHRD,
    UC_X86_INS_SHRX,
    UC_X86_INS_SHUFPD,
    UC_X86_INS_SHUFPS,
    UC_X86_INS_SIDT,
    UC_X86_INS_FSIN,
    UC_X86_INS_SKINIT,
    UC_X86_INS_SLDT,
    UC_X86_INS_SMSW,
    UC_X86_INS_SQRTPD,
    UC_X86_INS_SQRTPS,
    UC_X86_INS_SQRTSD,
    UC_X86_INS_SQRTSS,
    UC_X86_INS_FSQRT,
    UC_X86_INS_STAC,
    UC_X86_INS_STC,
    UC_X86_INS_STD,
    UC_X86_INS_STGI,
    UC_X86_INS_STI,
    UC_X86_INS_STMXCSR,
    UC_X86_INS_STOSB,
    UC_X86_INS_STOSD,
    UC_X86_INS_STOSQ,
    UC_X86_INS_STOSW,
    UC_X86_INS_STR,
    UC_X86_INS_FST,
    UC_X86_INS_FSTP,
    UC_X86_INS_FSTPNCE,
    UC_X86_INS_FXCH,
    UC_X86_INS_SUBPD,
    UC_X86_INS_SUBPS,
    UC_X86_INS_FSUBR,
    UC_X86_INS_FISUBR,
    UC_X86_INS_FSUBRP,
    UC_X86_INS_SUBSD,
    UC_X86_INS_SUBSS,
    UC_X86_INS_FSUB,
    UC_X86_INS_FISUB,
    UC_X86_INS_FSUBP,
    UC_X86_INS_SWAPGS,
    UC_X86_INS_SYSCALL,
    UC_X86_INS_SYSENTER,
    UC_X86_INS_SYSEXIT,
    UC_X86_INS_SYSRET,
    UC_X86_INS_T1MSKC,
    UC_X86_INS_TEST,
    UC_X86_INS_UD2,
    UC_X86_INS_FTST,
    UC_X86_INS_TZCNT,
    UC_X86_INS_TZMSK,
    UC_X86_INS_FUCOMPI,
    UC_X86_INS_FUCOMI,
    UC_X86_INS_FUCOMPP,
    UC_X86_INS_FUCOMP,
    UC_X86_INS_FUCOM,
    UC_X86_INS_UD2B,
    UC_X86_INS_UNPCKHPD,
    UC_X86_INS_UNPCKHPS,
    UC_X86_INS_UNPCKLPD,
    UC_X86_INS_UNPCKLPS,
    UC_X86_INS_VADDPD,
    UC_X86_INS_VADDPS,
    UC_X86_INS_VADDSD,
    UC_X86_INS_VADDSS,
    UC_X86_INS_VADDSUBPD,
    UC_X86_INS_VADDSUBPS,
    UC_X86_INS_VAESDECLAST,
    UC_X86_INS_VAESDEC,
    UC_X86_INS_VAESENCLAST,
    UC_X86_INS_VAESENC,
    UC_X86_INS_VAESIMC,
    UC_X86_INS_VAESKEYGENASSIST,
    UC_X86_INS_VALIGND,
    UC_X86_INS_VALIGNQ,
    UC_X86_INS_VANDNPD,
    UC_X86_INS_VANDNPS,
    UC_X86_INS_VANDPD,
    UC_X86_INS_VANDPS,
    UC_X86_INS_VBLENDMPD,
    UC_X86_INS_VBLENDMPS,
    UC_X86_INS_VBLENDPD,
    UC_X86_INS_VBLENDPS,
    UC_X86_INS_VBLENDVPD,
    UC_X86_INS_VBLENDVPS,
    UC_X86_INS_VBROADCASTF128,
    UC_X86_INS_VBROADCASTI32X4,
    UC_X86_INS_VBROADCASTI64X4,
    UC_X86_INS_VBROADCASTSD,
    UC_X86_INS_VBROADCASTSS,
    UC_X86_INS_VCMPPD,
    UC_X86_INS_VCMPPS,
    UC_X86_INS_VCMPSD,
    UC_X86_INS_VCMPSS,
    UC_X86_INS_VCOMPRESSPD,
    UC_X86_INS_VCOMPRESSPS,
    UC_X86_INS_VCVTDQ2PD,
    UC_X86_INS_VCVTDQ2PS,
    UC_X86_INS_VCVTPD2DQX,
    UC_X86_INS_VCVTPD2DQ,
    UC_X86_INS_VCVTPD2PSX,
    UC_X86_INS_VCVTPD2PS,
    UC_X86_INS_VCVTPD2UDQ,
    UC_X86_INS_VCVTPH2PS,
    UC_X86_INS_VCVTPS2DQ,
    UC_X86_INS_VCVTPS2PD,
    UC_X86_INS_VCVTPS2PH,
    UC_X86_INS_VCVTPS2UDQ,
    UC_X86_INS_VCVTSD2SI,
    UC_X86_INS_VCVTSD2USI,
    UC_X86_INS_VCVTSS2SI,
    UC_X86_INS_VCVTSS2USI,
    UC_X86_INS_VCVTTPD2DQX,
    UC_X86_INS_VCVTTPD2DQ,
    UC_X86_INS_VCVTTPD2UDQ,
    UC_X86_INS_VCVTTPS2DQ,
    UC_X86_INS_VCVTTPS2UDQ,
    UC_X86_INS_VCVTUDQ2PD,
    UC_X86_INS_VCVTUDQ2PS,
    UC_X86_INS_VDIVPD,
    UC_X86_INS_VDIVPS,
    UC_X86_INS_VDIVSD,
    UC_X86_INS_VDIVSS,
    UC_X86_INS_VDPPD,
    UC_X86_INS_VDPPS,
    UC_X86_INS_VERR,
    UC_X86_INS_VERW,
    UC_X86_INS_VEXP2PD,
    UC_X86_INS_VEXP2PS,
    UC_X86_INS_VEXPANDPD,
    UC_X86_INS_VEXPANDPS,
    UC_X86_INS_VEXTRACTF128,
    UC_X86_INS_VEXTRACTF32X4,
    UC_X86_INS_VEXTRACTF64X4,
    UC_X86_INS_VEXTRACTI128,
    UC_X86_INS_VEXTRACTI32X4,
    UC_X86_INS_VEXTRACTI64X4,
    UC_X86_INS_VEXTRACTPS,
    UC_X86_INS_VFMADD132PD,
    UC_X86_INS_VFMADD132PS,
    UC_X86_INS_VFMADDPD,
    UC_X86_INS_VFMADD213PD,
    UC_X86_INS_VFMADD231PD,
    UC_X86_INS_VFMADDPS,
    UC_X86_INS_VFMADD213PS,
    UC_X86_INS_VFMADD231PS,
    UC_X86_INS_VFMADDSD,
    UC_X86_INS_VFMADD213SD,
    UC_X86_INS_VFMADD132SD,
    UC_X86_INS_VFMADD231SD,
    UC_X86_INS_VFMADDSS,
    UC_X86_INS_VFMADD213SS,
    UC_X86_INS_VFMADD132SS,
    UC_X86_INS_VFMADD231SS,
    UC_X86_INS_VFMADDSUB132PD,
    UC_X86_INS_VFMADDSUB132PS,
    UC_X86_INS_VFMADDSUBPD,
    UC_X86_INS_VFMADDSUB213PD,
    UC_X86_INS_VFMADDSUB231PD,
    UC_X86_INS_VFMADDSUBPS,
    UC_X86_INS_VFMADDSUB213PS,
    UC_X86_INS_VFMADDSUB231PS,
    UC_X86_INS_VFMSUB132PD,
    UC_X86_INS_VFMSUB132PS,
    UC_X86_INS_VFMSUBADD132PD,
    UC_X86_INS_VFMSUBADD132PS,
    UC_X86_INS_VFMSUBADDPD,
    UC_X86_INS_VFMSUBADD213PD,
    UC_X86_INS_VFMSUBADD231PD,
    UC_X86_INS_VFMSUBADDPS,
    UC_X86_INS_VFMSUBADD213PS,
    UC_X86_INS_VFMSUBADD231PS,
    UC_X86_INS_VFMSUBPD,
    UC_X86_INS_VFMSUB213PD,
    UC_X86_INS_VFMSUB231PD,
    UC_X86_INS_VFMSUBPS,
    UC_X86_INS_VFMSUB213PS,
    UC_X86_INS_VFMSUB231PS,
    UC_X86_INS_VFMSUBSD,
    UC_X86_INS_VFMSUB213SD,
    UC_X86_INS_VFMSUB132SD,
    UC_X86_INS_VFMSUB231SD,
    UC_X86_INS_VFMSUBSS,
    UC_X86_INS_VFMSUB213SS,
    UC_X86_INS_VFMSUB132SS,
    UC_X86_INS_VFMSUB231SS,
    UC_X86_INS_VFNMADD132PD,
    UC_X86_INS_VFNMADD132PS,
    UC_X86_INS_VFNMADDPD,
    UC_X86_INS_VFNMADD213PD,
    UC_X86_INS_VFNMADD231PD,
    UC_X86_INS_VFNMADDPS,
    UC_X86_INS_VFNMADD213PS,
    UC_X86_INS_VFNMADD231PS,
    UC_X86_INS_VFNMADDSD,
    UC_X86_INS_VFNMADD213SD,
    UC_X86_INS_VFNMADD132SD,
    UC_X86_INS_VFNMADD231SD,
    UC_X86_INS_VFNMADDSS,
    UC_X86_INS_VFNMADD213SS,
    UC_X86_INS_VFNMADD132SS,
    UC_X86_INS_VFNMADD231SS,
    UC_X86_INS_VFNMSUB132PD,
    UC_X86_INS_VFNMSUB132PS,
    UC_X86_INS_VFNMSUBPD,
    UC_X86_INS_VFNMSUB213PD,
    UC_X86_INS_VFNMSUB231PD,
    UC_X86_INS_VFNMSUBPS,
    UC_X86_INS_VFNMSUB213PS,
    UC_X86_INS_VFNMSUB231PS,
    UC_X86_INS_VFNMSUBSD,
    UC_X86_INS_VFNMSUB213SD,
    UC_X86_INS_VFNMSUB132SD,
    UC_X86_INS_VFNMSUB231SD,
    UC_X86_INS_VFNMSUBSS,
    UC_X86_INS_VFNMSUB213SS,
    UC_X86_INS_VFNMSUB132SS,
    UC_X86_INS_VFNMSUB231SS,
    UC_X86_INS_VFRCZPD,
    UC_X86_INS_VFRCZPS,
    UC_X86_INS_VFRCZSD,
    UC_X86_INS_VFRCZSS,
    UC_X86_INS_VORPD,
    UC_X86_INS_VORPS,
    UC_X86_INS_VXORPD,
    UC_X86_INS_VXORPS,
    UC_X86_INS_VGATHERDPD,
    UC_X86_INS_VGATHERDPS,
    UC_X86_INS_VGATHERPF0DPD,
    UC_X86_INS_VGATHERPF0DPS,
    UC_X86_INS_VGATHERPF0QPD,
    UC_X86_INS_VGATHERPF0QPS,
    UC_X86_INS_VGATHERPF1DPD,
    UC_X86_INS_VGATHERPF1DPS,
    UC_X86_INS_VGATHERPF1QPD,
    UC_X86_INS_VGATHERPF1QPS,
    UC_X86_INS_VGATHERQPD,
    UC_X86_INS_VGATHERQPS,
    UC_X86_INS_VHADDPD,
    UC_X86_INS_VHADDPS,
    UC_X86_INS_VHSUBPD,
    UC_X86_INS_VHSUBPS,
    UC_X86_INS_VINSERTF128,
    UC_X86_INS_VINSERTF32X4,
    UC_X86_INS_VINSERTF32X8,
    UC_X86_INS_VINSERTF64X2,
    UC_X86_INS_VINSERTF64X4,
    UC_X86_INS_VINSERTI128,
    UC_X86_INS_VINSERTI32X4,
    UC_X86_INS_VINSERTI32X8,
    UC_X86_INS_VINSERTI64X2,
    UC_X86_INS_VINSERTI64X4,
    UC_X86_INS_VINSERTPS,
    UC_X86_INS_VLDDQU,
    UC_X86_INS_VLDMXCSR,
    UC_X86_INS_VMASKMOVDQU,
    UC_X86_INS_VMASKMOVPD,
    UC_X86_INS_VMASKMOVPS,
    UC_X86_INS_VMAXPD,
    UC_X86_INS_VMAXPS,
    UC_X86_INS_VMAXSD,
    UC_X86_INS_VMAXSS,
    UC_X86_INS_VMCALL,
    UC_X86_INS_VMCLEAR,
    UC_X86_INS_VMFUNC,
    UC_X86_INS_VMINPD,
    UC_X86_INS_VMINPS,
    UC_X86_INS_VMINSD,
    UC_X86_INS_VMINSS,
    UC_X86_INS_VMLAUNCH,
    UC_X86_INS_VMLOAD,
    UC_X86_INS_VMMCALL,
    UC_X86_INS_VMOVQ,
    UC_X86_INS_VMOVDDUP,
    UC_X86_INS_VMOVD,
    UC_X86_INS_VMOVDQA32,
    UC_X86_INS_VMOVDQA64,
    UC_X86_INS_VMOVDQA,
    UC_X86_INS_VMOVDQU16,
    UC_X86_INS_VMOVDQU32,
    UC_X86_INS_VMOVDQU64,
    UC_X86_INS_VMOVDQU8,
    UC_X86_INS_VMOVDQU,
    UC_X86_INS_VMOVHLPS,
    UC_X86_INS_VMOVHPD,
    UC_X86_INS_VMOVHPS,
    UC_X86_INS_VMOVLHPS,
    UC_X86_INS_VMOVLPD,
    UC_X86_INS_VMOVLPS,
    UC_X86_INS_VMOVMSKPD,
    UC_X86_INS_VMOVMSKPS,
    UC_X86_INS_VMOVNTDQA,
    UC_X86_INS_VMOVNTDQ,
    UC_X86_INS_VMOVNTPD,
    UC_X86_INS_VMOVNTPS,
    UC_X86_INS_VMOVSD,
    UC_X86_INS_VMOVSHDUP,
    UC_X86_INS_VMOVSLDUP,
    UC_X86_INS_VMOVSS,
    UC_X86_INS_VMOVUPD,
    UC_X86_INS_VMOVUPS,
    UC_X86_INS_VMPSADBW,
    UC_X86_INS_VMPTRLD,
    UC_X86_INS_VMPTRST,
    UC_X86_INS_VMREAD,
    UC_X86_INS_VMRESUME,
    UC_X86_INS_VMRUN,
    UC_X86_INS_VMSAVE,
    UC_X86_INS_VMULPD,
    UC_X86_INS_VMULPS,
    UC_X86_INS_VMULSD,
    UC_X86_INS_VMULSS,
    UC_X86_INS_VMWRITE,
    UC_X86_INS_VMXOFF,
    UC_X86_INS_VMXON,
    UC_X86_INS_VPABSB,
    UC_X86_INS_VPABSD,
    UC_X86_INS_VPABSQ,
    UC_X86_INS_VPABSW,
    UC_X86_INS_VPACKSSDW,
    UC_X86_INS_VPACKSSWB,
    UC_X86_INS_VPACKUSDW,
    UC_X86_INS_VPACKUSWB,
    UC_X86_INS_VPADDB,
    UC_X86_INS_VPADDD,
    UC_X86_INS_VPADDQ,
    UC_X86_INS_VPADDSB,
    UC_X86_INS_VPADDSW,
    UC_X86_INS_VPADDUSB,
    UC_X86_INS_VPADDUSW,
    UC_X86_INS_VPADDW,
    UC_X86_INS_VPALIGNR,
    UC_X86_INS_VPANDD,
    UC_X86_INS_VPANDND,
    UC_X86_INS_VPANDNQ,
    UC_X86_INS_VPANDN,
    UC_X86_INS_VPANDQ,
    UC_X86_INS_VPAND,
    UC_X86_INS_VPAVGB,
    UC_X86_INS_VPAVGW,
    UC_X86_INS_VPBLENDD,
    UC_X86_INS_VPBLENDMB,
    UC_X86_INS_VPBLENDMD,
    UC_X86_INS_VPBLENDMQ,
    UC_X86_INS_VPBLENDMW,
    UC_X86_INS_VPBLENDVB,
    UC_X86_INS_VPBLENDW,
    UC_X86_INS_VPBROADCASTB,
    UC_X86_INS_VPBROADCASTD,
    UC_X86_INS_VPBROADCASTMB2Q,
    UC_X86_INS_VPBROADCASTMW2D,
    UC_X86_INS_VPBROADCASTQ,
    UC_X86_INS_VPBROADCASTW,
    UC_X86_INS_VPCLMULQDQ,
    UC_X86_INS_VPCMOV,
    UC_X86_INS_VPCMPB,
    UC_X86_INS_VPCMPD,
    UC_X86_INS_VPCMPEQB,
    UC_X86_INS_VPCMPEQD,
    UC_X86_INS_VPCMPEQQ,
    UC_X86_INS_VPCMPEQW,
    UC_X86_INS_VPCMPESTRI,
    UC_X86_INS_VPCMPESTRM,
    UC_X86_INS_VPCMPGTB,
    UC_X86_INS_VPCMPGTD,
    UC_X86_INS_VPCMPGTQ,
    UC_X86_INS_VPCMPGTW,
    UC_X86_INS_VPCMPISTRI,
    UC_X86_INS_VPCMPISTRM,
    UC_X86_INS_VPCMPQ,
    UC_X86_INS_VPCMPUB,
    UC_X86_INS_VPCMPUD,
    UC_X86_INS_VPCMPUQ,
    UC_X86_INS_VPCMPUW,
    UC_X86_INS_VPCMPW,
    UC_X86_INS_VPCOMB,
    UC_X86_INS_VPCOMD,
    UC_X86_INS_VPCOMPRESSD,
    UC_X86_INS_VPCOMPRESSQ,
    UC_X86_INS_VPCOMQ,
    UC_X86_INS_VPCOMUB,
    UC_X86_INS_VPCOMUD,
    UC_X86_INS_VPCOMUQ,
    UC_X86_INS_VPCOMUW,
    UC_X86_INS_VPCOMW,
    UC_X86_INS_VPCONFLICTD,
    UC_X86_INS_VPCONFLICTQ,
    UC_X86_INS_VPERM2F128,
    UC_X86_INS_VPERM2I128,
    UC_X86_INS_VPERMD,
    UC_X86_INS_VPERMI2D,
    UC_X86_INS_VPERMI2PD,
    UC_X86_INS_VPERMI2PS,
    UC_X86_INS_VPERMI2Q,
    UC_X86_INS_VPERMIL2PD,
    UC_X86_INS_VPERMIL2PS,
    UC_X86_INS_VPERMILPD,
    UC_X86_INS_VPERMILPS,
    UC_X86_INS_VPERMPD,
    UC_X86_INS_VPERMPS,
    UC_X86_INS_VPERMQ,
    UC_X86_INS_VPERMT2D,
    UC_X86_INS_VPERMT2PD,
    UC_X86_INS_VPERMT2PS,
    UC_X86_INS_VPERMT2Q,
    UC_X86_INS_VPEXPANDD,
    UC_X86_INS_VPEXPANDQ,
    UC_X86_INS_VPEXTRB,
    UC_X86_INS_VPEXTRD,
    UC_X86_INS_VPEXTRQ,
    UC_X86_INS_VPEXTRW,
    UC_X86_INS_VPGATHERDD,
    UC_X86_INS_VPGATHERDQ,
    UC_X86_INS_VPGATHERQD,
    UC_X86_INS_VPGATHERQQ,
    UC_X86_INS_VPHADDBD,
    UC_X86_INS_VPHADDBQ,
    UC_X86_INS_VPHADDBW,
    UC_X86_INS_VPHADDDQ,
    UC_X86_INS_VPHADDD,
    UC_X86_INS_VPHADDSW,
    UC_X86_INS_VPHADDUBD,
    UC_X86_INS_VPHADDUBQ,
    UC_X86_INS_VPHADDUBW,
    UC_X86_INS_VPHADDUDQ,
    UC_X86_INS_VPHADDUWD,
    UC_X86_INS_VPHADDUWQ,
    UC_X86_INS_VPHADDWD,
    UC_X86_INS_VPHADDWQ,
    UC_X86_INS_VPHADDW,
    UC_X86_INS_VPHMINPOSUW,
    UC_X86_INS_VPHSUBBW,
    UC_X86_INS_VPHSUBDQ,
    UC_X86_INS_VPHSUBD,
    UC_X86_INS_VPHSUBSW,
    UC_X86_INS_VPHSUBWD,
    UC_X86_INS_VPHSUBW,
    UC_X86_INS_VPINSRB,
    UC_X86_INS_VPINSRD,
    UC_X86_INS_VPINSRQ,
    UC_X86_INS_VPINSRW,
    UC_X86_INS_VPLZCNTD,
    UC_X86_INS_VPLZCNTQ,
    UC_X86_INS_VPMACSDD,
    UC_X86_INS_VPMACSDQH,
    UC_X86_INS_VPMACSDQL,
    UC_X86_INS_VPMACSSDD,
    UC_X86_INS_VPMACSSDQH,
    UC_X86_INS_VPMACSSDQL,
    UC_X86_INS_VPMACSSWD,
    UC_X86_INS_VPMACSSWW,
    UC_X86_INS_VPMACSWD,
    UC_X86_INS_VPMACSWW,
    UC_X86_INS_VPMADCSSWD,
    UC_X86_INS_VPMADCSWD,
    UC_X86_INS_VPMADDUBSW,
    UC_X86_INS_VPMADDWD,
    UC_X86_INS_VPMASKMOVD,
    UC_X86_INS_VPMASKMOVQ,
    UC_X86_INS_VPMAXSB,
    UC_X86_INS_VPMAXSD,
    UC_X86_INS_VPMAXSQ,
    UC_X86_INS_VPMAXSW,
    UC_X86_INS_VPMAXUB,
    UC_X86_INS_VPMAXUD,
    UC_X86_INS_VPMAXUQ,
    UC_X86_INS_VPMAXUW,
    UC_X86_INS_VPMINSB,
    UC_X86_INS_VPMINSD,
    UC_X86_INS_VPMINSQ,
    UC_X86_INS_VPMINSW,
    UC_X86_INS_VPMINUB,
    UC_X86_INS_VPMINUD,
    UC_X86_INS_VPMINUQ,
    UC_X86_INS_VPMINUW,
    UC_X86_INS_VPMOVDB,
    UC_X86_INS_VPMOVDW,
    UC_X86_INS_VPMOVM2B,
    UC_X86_INS_VPMOVM2D,
    UC_X86_INS_VPMOVM2Q,
    UC_X86_INS_VPMOVM2W,
    UC_X86_INS_VPMOVMSKB,
    UC_X86_INS_VPMOVQB,
    UC_X86_INS_VPMOVQD,
    UC_X86_INS_VPMOVQW,
    UC_X86_INS_VPMOVSDB,
    UC_X86_INS_VPMOVSDW,
    UC_X86_INS_VPMOVSQB,
    UC_X86_INS_VPMOVSQD,
    UC_X86_INS_VPMOVSQW,
    UC_X86_INS_VPMOVSXBD,
    UC_X86_INS_VPMOVSXBQ,
    UC_X86_INS_VPMOVSXBW,
    UC_X86_INS_VPMOVSXDQ,
    UC_X86_INS_VPMOVSXWD,
    UC_X86_INS_VPMOVSXWQ,
    UC_X86_INS_VPMOVUSDB,
    UC_X86_INS_VPMOVUSDW,
    UC_X86_INS_VPMOVUSQB,
    UC_X86_INS_VPMOVUSQD,
    UC_X86_INS_VPMOVUSQW,
    UC_X86_INS_VPMOVZXBD,
    UC_X86_INS_VPMOVZXBQ,
    UC_X86_INS_VPMOVZXBW,
    UC_X86_INS_VPMOVZXDQ,
    UC_X86_INS_VPMOVZXWD,
    UC_X86_INS_VPMOVZXWQ,
    UC_X86_INS_VPMULDQ,
    UC_X86_INS_VPMULHRSW,
    UC_X86_INS_VPMULHUW,
    UC_X86_INS_VPMULHW,
    UC_X86_INS_VPMULLD,
    UC_X86_INS_VPMULLQ,
    UC_X86_INS_VPMULLW,
    UC_X86_INS_VPMULUDQ,
    UC_X86_INS_VPORD,
    UC_X86_INS_VPORQ,
    UC_X86_INS_VPOR,
    UC_X86_INS_VPPERM,
    UC_X86_INS_VPROTB,
    UC_X86_INS_VPROTD,
    UC_X86_INS_VPROTQ,
    UC_X86_INS_VPROTW,
    UC_X86_INS_VPSADBW,
    UC_X86_INS_VPSCATTERDD,
    UC_X86_INS_VPSCATTERDQ,
    UC_X86_INS_VPSCATTERQD,
    UC_X86_INS_VPSCATTERQQ,
    UC_X86_INS_VPSHAB,
    UC_X86_INS_VPSHAD,
    UC_X86_INS_VPSHAQ,
    UC_X86_INS_VPSHAW,
    UC_X86_INS_VPSHLB,
    UC_X86_INS_VPSHLD,
    UC_X86_INS_VPSHLQ,
    UC_X86_INS_VPSHLW,
    UC_X86_INS_VPSHUFB,
    UC_X86_INS_VPSHUFD,
    UC_X86_INS_VPSHUFHW,
    UC_X86_INS_VPSHUFLW,
    UC_X86_INS_VPSIGNB,
    UC_X86_INS_VPSIGND,
    UC_X86_INS_VPSIGNW,
    UC_X86_INS_VPSLLDQ,
    UC_X86_INS_VPSLLD,
    UC_X86_INS_VPSLLQ,
    UC_X86_INS_VPSLLVD,
    UC_X86_INS_VPSLLVQ,
    UC_X86_INS_VPSLLW,
    UC_X86_INS_VPSRAD,
    UC_X86_INS_VPSRAQ,
    UC_X86_INS_VPSRAVD,
    UC_X86_INS_VPSRAVQ,
    UC_X86_INS_VPSRAW,
    UC_X86_INS_VPSRLDQ,
    UC_X86_INS_VPSRLD,
    UC_X86_INS_VPSRLQ,
    UC_X86_INS_VPSRLVD,
    UC_X86_INS_VPSRLVQ,
    UC_X86_INS_VPSRLW,
    UC_X86_INS_VPSUBB,
    UC_X86_INS_VPSUBD,
    UC_X86_INS_VPSUBQ,
    UC_X86_INS_VPSUBSB,
    UC_X86_INS_VPSUBSW,
    UC_X86_INS_VPSUBUSB,
    UC_X86_INS_VPSUBUSW,
    UC_X86_INS_VPSUBW,
    UC_X86_INS_VPTESTMD,
    UC_X86_INS_VPTESTMQ,
    UC_X86_INS_VPTESTNMD,
    UC_X86_INS_VPTESTNMQ,
    UC_X86_INS_VPTEST,
    UC_X86_INS_VPUNPCKHBW,
    UC_X86_INS_VPUNPCKHDQ,
    UC_X86_INS_VPUNPCKHQDQ,
    UC_X86_INS_VPUNPCKHWD,
    UC_X86_INS_VPUNPCKLBW,
    UC_X86_INS_VPUNPCKLDQ,
    UC_X86_INS_VPUNPCKLQDQ,
    UC_X86_INS_VPUNPCKLWD,
    UC_X86_INS_VPXORD,
    UC_X86_INS_VPXORQ,
    UC_X86_INS_VPXOR,
    UC_X86_INS_VRCP14PD,
    UC_X86_INS_VRCP14PS,
    UC_X86_INS_VRCP14SD,
    UC_X86_INS_VRCP14SS,
    UC_X86_INS_VRCP28PD,
    UC_X86_INS_VRCP28PS,
    UC_X86_INS_VRCP28SD,
    UC_X86_INS_VRCP28SS,
    UC_X86_INS_VRCPPS,
    UC_X86_INS_VRCPSS,
    UC_X86_INS_VRNDSCALEPD,
    UC_X86_INS_VRNDSCALEPS,
    UC_X86_INS_VRNDSCALESD,
    UC_X86_INS_VRNDSCALESS,
    UC_X86_INS_VROUNDPD,
    UC_X86_INS_VROUNDPS,
    UC_X86_INS_VROUNDSD,
    UC_X86_INS_VROUNDSS,
    UC_X86_INS_VRSQRT14PD,
    UC_X86_INS_VRSQRT14PS,
    UC_X86_INS_VRSQRT14SD,
    UC_X86_INS_VRSQRT14SS,
    UC_X86_INS_VRSQRT28PD,
    UC_X86_INS_VRSQRT28PS,
    UC_X86_INS_VRSQRT28SD,
    UC_X86_INS_VRSQRT28SS,
    UC_X86_INS_VRSQRTPS,
    UC_X86_INS_VRSQRTSS,
    UC_X86_INS_VSCATTERDPD,
    UC_X86_INS_VSCATTERDPS,
    UC_X86_INS_VSCATTERPF0DPD,
    UC_X86_INS_VSCATTERPF0DPS,
    UC_X86_INS_VSCATTERPF0QPD,
    UC_X86_INS_VSCATTERPF0QPS,
    UC_X86_INS_VSCATTERPF1DPD,
    UC_X86_INS_VSCATTERPF1DPS,
    UC_X86_INS_VSCATTERPF1QPD,
    UC_X86_INS_VSCATTERPF1QPS,
    UC_X86_INS_VSCATTERQPD,
    UC_X86_INS_VSCATTERQPS,
    UC_X86_INS_VSHUFPD,
    UC_X86_INS_VSHUFPS,
    UC_X86_INS_VSQRTPD,
    UC_X86_INS_VSQRTPS,
    UC_X86_INS_VSQRTSD,
    UC_X86_INS_VSQRTSS,
    UC_X86_INS_VSTMXCSR,
    UC_X86_INS_VSUBPD,
    UC_X86_INS_VSUBPS,
    UC_X86_INS_VSUBSD,
    UC_X86_INS_VSUBSS,
    UC_X86_INS_VTESTPD,
    UC_X86_INS_VTESTPS,
    UC_X86_INS_VUNPCKHPD,
    UC_X86_INS_VUNPCKHPS,
    UC_X86_INS_VUNPCKLPD,
    UC_X86_INS_VUNPCKLPS,
    UC_X86_INS_VZEROALL,
    UC_X86_INS_VZEROUPPER,
    UC_X86_INS_WAIT,
    UC_X86_INS_WBINVD,
    UC_X86_INS_WRFSBASE,
    UC_X86_INS_WRGSBASE,
    UC_X86_INS_WRMSR,
    UC_X86_INS_XABORT,
    UC_X86_INS_XACQUIRE,
    UC_X86_INS_XBEGIN,
    UC_X86_INS_XCHG,
    UC_X86_INS_XCRYPTCBC,
    UC_X86_INS_XCRYPTCFB,
    UC_X86_INS_XCRYPTCTR,
    UC_X86_INS_XCRYPTECB,
    UC_X86_INS_XCRYPTOFB,
    UC_X86_INS_XEND,
    UC_X86_INS_XGETBV,
    UC_X86_INS_XLATB,
    UC_X86_INS_XRELEASE,
    UC_X86_INS_XRSTOR,
    UC_X86_INS_XRSTOR64,
    UC_X86_INS_XRSTORS,
    UC_X86_INS_XRSTORS64,
    UC_X86_INS_XSAVE,
    UC_X86_INS_XSAVE64,
    UC_X86_INS_XSAVEC,
    UC_X86_INS_XSAVEC64,
    UC_X86_INS_XSAVEOPT,
    UC_X86_INS_XSAVEOPT64,
    UC_X86_INS_XSAVES,
    UC_X86_INS_XSAVES64,
    UC_X86_INS_XSETBV,
    UC_X86_INS_XSHA1,
    UC_X86_INS_XSHA256,
    UC_X86_INS_XSTORE,
    UC_X86_INS_XTEST,
    UC_X86_INS_FDISI8087_NOP,
    UC_X86_INS_FENI8087_NOP,

    UC_X86_INS_ENDING, // mark the end of the list of insn
} uc_x86_insn;

#ifdef __cplusplus
}
#endif

#endif

```

`VanguardImportResolver/Source/Entry.cpp`:

```cpp
#include <iostream>
#include <UdLib/UdLib.hpp>
#include <Unicorn/unicorn/unicorn.h>

int main( )
{
    /* initialize unicorn engine */
    std::unique_ptr< uc_engine, decltype( &uc_close ) > Unicorn( ( []( ) {
        uc_engine* Engine;
        uc_open( UC_ARCH_X86, UC_MODE_64, &Engine );

        return Engine;
    } )( ), uc_close );

    /* load vanguard */
    const auto Vanguard = reinterpret_cast< std::uint8_t* >( LoadLibraryExA( "vgk.sys", nullptr, DONT_RESOLVE_DLL_REFERENCES ) );
    std::unique_ptr< std::remove_pointer_t< HANDLE >, decltype( &CloseHandle ) > ScopedVanguard( Vanguard, CloseHandle );

    /* reflect vanguard into unicorn's memory */
    uc_mem_map_ptr( Unicorn.get( ), 0x0, ud::module_t( Vanguard ).size, UC_PROT_ALL, Vanguard );

    /* initialize the stack */
    uc_mem_map( Unicorn.get( ), 0xFFFFFA0000000000, 0x2000, UC_PROT_ALL );
    const auto Rsp = 0xFFFFFA0000000000 + 0x1000;
    uc_reg_write( Unicorn.get( ), UC_X86_REG_RSP, &Rsp );
    
    /* initialize the first parameter */
    const auto BlankPointer = nullptr;
    uc_reg_write( Unicorn.get( ), UC_X86_REG_RCX, &BlankPointer );

    /* allocate and save the initial cpu context */
    uc_context* Context;
    uc_context_alloc( Unicorn.get( ), &Context );
    uc_context_save( Unicorn.get( ), Context );

    const auto DumpImport = [ & ]( const std::uintptr_t Address )
    {
        /* restore the cpu context to the initial context */
        uc_context_restore( Unicorn.get( ), Context );

        /* start the emulation */
        uc_emu_start( Unicorn.get( ), Address, 0, 0, 0 );

        /* check if the exception is triggered by our trap */
        std::uint64_t Rax;
        uc_reg_read( Unicorn.get( ), UC_X86_REG_RAX, &Rax );
        if ( Rax == *reinterpret_cast< std::uint64_t* >( Vanguard ) )
        {
            /* read the import name's address */
            std::uintptr_t Rdx;
            uc_reg_read( Unicorn.get( ), UC_X86_REG_RDX, &Rdx );

            /* read and log the import name */
            char Name[ 0x20 ];
            uc_mem_read( Unicorn.get( ), Rdx, Name, sizeof( Name ) );
            std::cout << "set_name(0x" << std::hex << Address << ", \"LI::" << Name << "\"); \n";
        }
    };

    /* scan for all jump proxies */
    for ( auto PossibleImportJump : ud::module_t( Vanguard )[ ".text" ].find_patterns( "48 33 C4 48 89 45 ?? 48 8B D9 33 C9 E9" ) )
    {
        /* locate the start of the function */
        auto PossibleImport = ud::find_pattern_primitive< std::uint8_t* >( PossibleImportJump - 50, PossibleImportJump, "48 8B C4" );
		if ( !PossibleImport )
			PossibleImport = ud::find_pattern_primitive< std::uint8_t* >( PossibleImportJump - 50, PossibleImportJump, "48 89 54" );

        /* attempt to emulate the possible import */
        if ( PossibleImport )
            DumpImport( *PossibleImport - Vanguard );
    }

    return 0;
}
```

`VanguardImportResolver/VanguardImportResolver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{0b76e008-10b8-446e-828f-1fc3fed503eb}</ProjectGuid>
    <RootNamespace>VanguardImportResolver</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>Dependencies/;Source/;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <Optimization>Full</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>Dependencies/Unicorn/unicorn.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Source\Entry.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Dependencies\UdLib\UdLib.hpp" />
    <ClInclude Include="Dependencies\Unicorn\list.h" />
    <ClInclude Include="Dependencies\Unicorn\qemu.h" />
    <ClInclude Include="Dependencies\Unicorn\uc_priv.h" />
    <ClInclude Include="Dependencies\Unicorn\unicorn\arm.h" />
    <ClInclude Include="Dependencies\Unicorn\unicorn\arm64.h" />
    <ClInclude Include="Dependencies\Unicorn\unicorn\m68k.h" />
    <ClInclude Include="Dependencies\Unicorn\unicorn\mips.h" />
    <ClInclude Include="Dependencies\Unicorn\unicorn\platform.h" />
    <ClInclude Include="Dependencies\Unicorn\unicorn\ppc.h" />
    <ClInclude Include="Dependencies\Unicorn\unicorn\riscv.h" />
    <ClInclude Include="Dependencies\Unicorn\unicorn\s390x.h" />
    <ClInclude Include="Dependencies\Unicorn\unicorn\sparc.h" />
    <ClInclude Include="Dependencies\Unicorn\unicorn\tricore.h" />
    <ClInclude Include="Dependencies\Unicorn\unicorn\unicorn.h" />
    <ClInclude Include="Dependencies\Unicorn\unicorn\x86.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`VanguardImportResolver/VanguardImportResolver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Source\Entry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Dependencies\Unicorn\list.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\qemu.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\uc_priv.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\unicorn\arm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\unicorn\arm64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\unicorn\m68k.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\unicorn\mips.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\unicorn\platform.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\unicorn\ppc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\unicorn\riscv.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\unicorn\s390x.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\unicorn\sparc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\unicorn\tricore.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\unicorn\unicorn.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\Unicorn\unicorn\x86.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Dependencies\UdLib\UdLib.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`VanguardImportResolver/VanguardImportResolver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```