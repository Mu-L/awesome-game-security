Project Path: arc_gmh5225_freedom_z3szex53

Source Tree:

```txt
arc_gmh5225_freedom_z3szex53
├── LICENSE
├── README.md
├── binnavi_db.py
├── bn_disasm.py
├── elf_loader.py
├── fREedom.py
├── loader.py
├── pe_loader.py
├── postgresql_tables.sql
└── x86_disasm.py

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.
```

`README.md`:

```md
fREedom is a primitive attempt to provide an IDA Pro independent means
of extracting disassembly information from executables for use with
binnavi (https://github.com/google/binnavi).

WARNING: This software is in its infancy

Background: binnavi is a graphical "binary navigator" useful for reverse
engineering software. binnavi does not contain its own disassembler, instead
relying upon the capabilities of the commercial disassembler, IDA Pro.
binnavi ships with an IDA plugin that extracts required information from an
existing IDA database into a set of binnavi compatible, Postgres tables. The
amount of work that IDA does on behalf of binnavi is not trivial. There is 
a reason there are no open source competitors to IDA. Eliminating binnavi's
dependency on IDA is not quite as trivial as slapping some glue code on top
of a disassembly framework like Capstone (http://www.capstone-engine.org/)
and calling it a day. This project takes some small steps in that direction.
it is thrown together, not well thought out, and it has a long way to go.

Basic use:  
* Use the provided postgres script to setup the initial postgres database.
* Configure your postgres instance appropriately (pg_hba.conf ...)
* `python fREedom.py --database=my_binnavi --user=someone --pass=itsasecret --dbhost=127.0.0.1 --binary=foo.exe`
* Launch binnavi to browse foo.exe

What's here:   
* binnavi's postgres script to build the required Postgres database
* Python scripts to extract from PE32, PE32+, and ELF binaries containing
x86 or x86_64 code. 

What's not here:  
* A Postgres tutorial (see http://www.postgresql.org/). Among other things,
you'll need psycopg2.
* A Capstone installation tutorial (see http://www.capstone-engine.org/)
* Support for anything other than PE32, PE32+, and ELF
* Support for anything other than x86 and x86_64

Limitations:  
* fREedom's disassembly engine is not as thorough as IDA's, lacking many of
the heuristics that IDA uses to identify code.
* There is currently no support for known data types and library function
signatures. binnavi's type system is complex and not well documented.
Substantial effort will be required to process development header files from
many platforms in order to incorporate this information into fREedom generated
disassemblies.
* Parsers (crude at best) are included for only PE32, PE32+, and ELF.
* Disassembly generators are included for only x86 and x86_64.
* My python skills are not good.

```

`binnavi_db.py`:

```py
#!/usr/bin/env python

'''
The database interface for a stand-alone binnavi compatible disassembler
'''

__author__ = "Chris Eagle"
__copyright__ = "Copyright 2015, Chris Eagle"
__credits__ = ["Chris Eagle"]
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Chris Eagle"
__email__ = "cseagle@gmail.com"
__status__ = "Use at your own risk"

import sys
import traceback
import struct
import hashlib
import psycopg2
import capstone
import bn_disasm

FUNCTION_TYPES = {'NORMAL':0, 'LIBRARY':1, 'IMPORTED':2, 'THUNK':3, 'INAVALID':4,}

class binnavi_db(object):

   def __init__(self, db, user, passwd, host='localhost'):
#      try:
         self.conn = psycopg2.connect("dbname='%s' user='%s' host='%s' password='%s'" % (db, user, host, passwd))
         self.create_empty_tables()
#      except Exception, e:
#         raise Exception("db connect fail: %s:%s" % (type(e), e.message))

   def export(self, module_data):
      return self.add_module(module_data)

   def add_functions(self, curs, id, module_data):
      for addr in module_data.call_targets:
         name = module_data.names[addr]
         named = not name.startswith('sub_')
         demangled = None   #demangle(name)
         ftype = FUNCTION_TYPES['NORMAL']  #NORMAL
         if addr in module_data.loader.imports_by_addr:
            ftype = FUNCTION_TYPES['IMPORT']
         elif addr in module_data.thunks:
            ftype = FUNCTION_TYPES['THUNK']
         #not working yet, but if a function has a stack frame, it will be named: "__SF%x" % addr
         stkframe = None
         if ("__SF%x" % addr) in module_data.types:
            stkframe = module_data.types["__SF%x" % addr].id
         curs.execute("insert into ex_%d_functions values (%%s, %%s, %%s, %%s, %%s, %%s, %%s, %%s);" % id,
                     (addr, name, demangled, named, ftype, module_data.loader.name, stkframe, None))

   def add_instructions(self, curs, id, module_data):
      for addr in module_data.visited:
         insn = module_data.insts[addr]
         curs.execute("insert into ex_%d_instructions values (%%s, %%s, %%s);" % id, (addr, insn.mnemonic, insn.bytes))

   #called from inside a with block already, so take a cursor from the caller
   #computes the basic block members from the give start address
   def add_basic_block_instructions(self, curs, id, module_data):
      for addr in module_data.visited:
         i = module_data.insts[addr]
         if hasattr(i, "bb"):
            for b in i.bb:
               curs.execute("insert into ex_%d_basic_block_instructions values (%%s, %%s, %%s);" % id, (b.bid, addr, b.seq))

   # also, build the cgf while we're at it
   def add_basic_blocks(self, curs, id, module_data):
      for addr,bb in module_data.basic_blocks.iteritems():
         for block in bb:
            curs.execute("insert into ex_%d_basic_blocks values (%%s, %%s, %%s);" % id, (block[0], block[1], addr))

   def drop_table(self, curs, table):
      curs.execute("drop table if exists %s cascade;" % table)

   def delete_raw_module(self, curs, id):
      self.drop_table(curs, "ex_%d_address_comments" % id)
      self.drop_table(curs, "ex_%d_address_references" % id)
      self.drop_table(curs, "ex_%d_expression_substitutions" % id)
      self.drop_table(curs, "ex_%d_operands" % id)
      self.drop_table(curs, "ex_%d_expression_tree_nodes" % id)
      self.drop_table(curs, "ex_%d_expression_trees" % id)
      self.drop_table(curs, "ex_%d_expression_nodes" % id)
      self.drop_table(curs, "ex_%d_control_flow_graphs" % id)
      self.drop_table(curs, "ex_%d_callgraph" % id)
      self.drop_table(curs, "ex_%d_basic_block_instructions" % id)
      self.drop_table(curs, "ex_%d_instructions" % id)
      self.drop_table(curs, "ex_%d_basic_blocks" % id)
      self.drop_table(curs, "ex_%d_functions" % id)
      self.drop_table(curs, "ex_%d_type_renderers" % id)
      self.drop_table(curs, "ex_%d_base_types" % id)
      self.drop_table(curs, "ex_%d_expression_type_instances" % id)
      self.drop_table(curs, "ex_%d_expression_types" % id)
      self.drop_table(curs, "ex_%d_types" % id)
      self.drop_table(curs, "ex_%d_type_instances" % id)
      self.drop_table(curs, "ex_%d_sections" % id)
      self.drop_table(curs, "ex_%d_type_substitution_paths" % id)

   def create_raw_module(self, curs, id):
      curs.execute('create table ex_%d_functions ("address" bigint not null, "name" text not null,"demangled_name" text null default null,"has_real_name" boolean not null,"type" int not null default 0 check( "type" in ( 0, 1, 2, 3, 4 )),"module_name" text null default null,"stack_frame" int null default null,"prototype" int null default null);' % id)
      curs.execute('create table ex_%d_basic_blocks ("id" int not null,"parent_function" bigint not null,"address" bigint not null);' % id)
      curs.execute('create table ex_%d_instructions ("address" bigint not null,"mnemonic" varchar( 32 ) not null,"data" bytea not null);' % id)
      curs.execute('create table ex_%d_basic_block_instructions ("basic_block_id" int not null,"instruction" bigint not null,"sequence" int not null);' % id)
      curs.execute('create table ex_%d_callgraph ("id" serial,"source" bigint not null,"source_basic_block_id" int not null,"source_address" bigint not null,"destination" bigint not null);' % id)
      curs.execute('create table ex_%d_control_flow_graphs ("id" serial,"parent_function" bigint not null,"source" int not null,"destination" int not null,"type" int not null default 0 check( "type" in ( 0, 1, 2, 3 )));' % id)
      curs.execute('create table ex_%d_expression_trees ("id" serial);' % id)
      curs.execute('create table ex_%d_expression_nodes ("id" serial,"type" int not null default 0 check( "type" >= 0 and "type" <= 7 ),"symbol" varchar( 256 ),"immediate" bigint,"position" int,"parent_id" int check( "id" > "parent_id" ));' % id)
      curs.execute('create table ex_%d_expression_tree_nodes ("expression_tree_id" int not null,"expression_node_id" int not null);' % id)
      curs.execute('create table ex_%d_operands ("address" bigint not null,"expression_tree_id" int not null,"position" int not null);' % id)
      curs.execute('create table ex_%d_expression_substitutions ("id" serial,"address" bigint not null,"position" int not null,"expression_node_id" int not null,"replacement" text not null);' % id)
      curs.execute('create table ex_%d_address_references ("address" bigint not null,"position" int null,"expression_node_id" int null,"destination" bigint not null,"type" int not null default 0 check( "type" >= 0 and "type" <= 8 ));' % id)
      curs.execute('create table ex_%d_address_comments ("address" bigint not null,"comment" text not null);' % id)
      curs.execute('drop type if exists ex_%d_type_category;' % id)
      curs.execute("create type ex_%d_type_category as enum ('atomic', 'pointer', 'array','struct', 'union', 'function_pointer');" % id)
      curs.execute('create table ex_%d_base_types ("id" integer not null,"name" text not null,"size" integer not null,"pointer" integer,"signed" bool,"category" ex_%d_type_category not null);' % (id, id))
      curs.execute('create table ex_%d_types ("id" serial not null,"name" text not null,"base_type" integer not null,"parent_id" integer,"offset" integer,"argument" integer,"number_of_elements" integer);' % id)
      curs.execute('drop type if exists ex_%d_type_renderers_renderer_type;' % id)
      curs.execute("create type ex_%d_type_renderers_renderer_type as enum ('integer','floating point', 'boolean', 'ascii', 'utf8', 'utf16');" % id)
      curs.execute('create table ex_%d_type_renderers ("type_id" int not null,"renderer" ex_%d_type_renderers_renderer_type not null);' % (id, id))
      curs.execute('drop type if exists ex_%d_section_permission_type;' % id)
      curs.execute("create type ex_%d_section_permission_type as enum ('READ', 'WRITE','EXECUTE', 'READ_WRITE', 'READ_EXECUTE', 'WRITE_EXECUTE','READ_WRITE_EXECUTE');" % id)
      curs.execute('create table ex_%d_sections ("id" serial not null,"name" text not null,"start_address" bigint not null,"end_address" bigint not null,"permission" ex_%d_section_permission_type not null,"data" bytea not null);' % (id, id))
      curs.execute('create table ex_%d_expression_types ("address" bigint not null,"position" integer not null,"expression_id" integer not null,"type" integer not null,"path" integer[] not null,"offset" integer);' % id)
      curs.execute('create table ex_%d_expression_type_instances ("address" bigint not null,"position" integer not null,"expression_node_id" integer not null,"type_instance_id" integer not null);' % id)
      curs.execute('create table ex_%d_type_instances ("id" integer not null,"name" text not null,"section_offset" bigint not null,"type_id" integer not null,"section_id" integer not null);' % id)
      curs.execute('create table ex_%d_type_substitution_paths ("id" integer not null,"child_id" integer,"type_id" integer not null);' % id)

   def vaccuum_raw_tables(self, id):
      try:
         with self.conn as conn:
            old_iso = conn.isolation_level
            conn.set_isolation_level(0)
            with conn.cursor() as curs:
               curs.execute('vacuum analyze "ex_%d_operands";' % id)
               curs.execute('vacuum analyze "ex_%d_functions";' % id)
               curs.execute('vacuum analyze "ex_%d_basic_blocks";' % id)
               curs.execute('vacuum analyze "ex_%d_instructions";' % id)
               curs.execute('vacuum analyze "ex_%d_basic_block_instructions";' % id)
               curs.execute('vacuum analyze "ex_%d_callgraph";' % id)
               curs.execute('vacuum analyze "ex_%d_control_flow_graphs";' % id)
               curs.execute('vacuum analyze "ex_%d_expression_trees";' % id)
               curs.execute('vacuum analyze "ex_%d_expression_nodes";' % id)
               curs.execute('vacuum analyze "ex_%d_expression_tree_nodes";' % id)
               curs.execute('vacuum analyze "ex_%d_expression_substitutions";' % id)
               curs.execute('vacuum analyze "ex_%d_address_references";' % id)
               curs.execute('vacuum analyze "ex_%d_address_comments";' % id)
               curs.execute('vacuum analyze "ex_%d_type_renderers";' % id)
               curs.execute('vacuum analyze "ex_%d_base_types";' % id)
               curs.execute('vacuum analyze "ex_%d_types";' % id)
               curs.execute('vacuum analyze "ex_%d_expression_types";' % id)
               curs.execute('vacuum analyze "ex_%d_sections";' % id)
            conn.set_isolation_level(old_iso)
      except psycopg2.Error, p:
         print "vaccuum_raw_tables: %s" % p.message
         raise p

   def create_raw_indicies(self, curs, id):
      curs.execute('create unique index ex_%d_functions_address_idx on ex_%d_functions( "address" );' % (id, id))
      curs.execute('create unique index ex_%d_basic_blocks_id_idx on ex_%d_basic_blocks( "id" );' % (id, id))
      curs.execute('create index ex_%d_basic_blocks_address_idx on ex_%d_basic_blocks( "address" );' % (id, id))
      curs.execute('create unique index ex_%d_instructions_address_idx on ex_%d_instructions( "address" );' % (id, id))
      curs.execute('create unique index ex_%d_expression_trees_id_idx on ex_%d_expression_trees( "id" );' % (id, id))
      curs.execute('create unique index ex_%d_expression_nodes_id_idx on ex_%d_expression_nodes( "id" );' % (id, id))

   def delete_cleanup(self, curs, id):
      curs.execute("delete from ex_%d_instructions as instructions using ex_%d_basic_block_instructions as basic_block_instructions where basic_block_instructions.instruction = instructions.address and basic_block_id is null;" % (id, id))
      curs.execute("delete from ex_%d_basic_block_instructions where basic_block_id is null;" % id)
      curs.execute("delete from ex_%d_address_references where address in ( select address from ex_%d_address_references except select address from ex_%d_instructions);" % (id, id, id))
      curs.execute("delete from ex_%d_address_comments where address in ( select address from ex_%d_address_comments except select address from ex_%d_instructions);" % (id, id, id))
      curs.execute("delete from ex_%d_expression_substitutions where address in ( select address from ex_%d_expression_substitutions except select address from ex_%d_instructions);" % (id, id, id))
      curs.execute("delete from ex_%d_operands where address in ( select address from ex_%d_operands except select address from ex_%d_instructions);" % (id, id, id))
      curs.execute("delete from ex_%d_expression_type_instances where address in ( select address from ex_%d_expression_type_instances except select address from ex_%d_operands);" % (id, id, id))

   def create_raw_keys(self, curs, id):
      curs.execute('alter table ex_%d_functions add primary key( "address" );' % id)
      curs.execute('alter table ex_%d_basic_blocks add primary key( "id" );' % id)
      curs.execute('alter table ex_%d_basic_blocks add constraint ex_%d_basic_blocks_parent_function_fkey foreign key ( "parent_function" ) references ex_%d_functions( "address" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_instructions add primary key( "address" );' % id)
      curs.execute('alter table ex_%d_basic_block_instructions add constraint ex_%d_basic_block_instructions_bb_fkey foreign key ( "basic_block_id" ) references ex_%d_basic_blocks( "id" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_basic_block_instructions add constraint ex_%d_basic_block_instructions_ins_fkey foreign key ( "instruction" ) references ex_%d_instructions( "address" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_callgraph add primary key( "id" );' % id)
      curs.execute('alter table ex_%d_callgraph add constraint ex_%d_callgraph_source_fkey foreign key ( "source" ) references ex_%d_functions( "address" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_callgraph add constraint ex_%d_callgraph_destination_fkey foreign key ( "destination" ) references ex_%d_functions( "address" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_callgraph add constraint ex_%d_callgraph_source_basic_block_id_fkey foreign key ( "source_basic_block_id" ) references ex_%d_basic_blocks( "id" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_callgraph add constraint ex_%d_callgraph_source_address_fkey foreign key ( "source_address" ) references ex_%d_instructions( "address" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_control_flow_graphs add primary key( "id" );' % id)
      curs.execute('alter table ex_%d_control_flow_graphs add constraint ex_%d_control_flow_graphs_parent_function_fkey foreign key ( "parent_function" ) references ex_%d_functions( "address" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_control_flow_graphs add constraint ex_%d_control_flow_graphs_source_fkey foreign key ( "source" ) references ex_%d_basic_blocks( "id" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_control_flow_graphs add constraint ex_%d_control_flow_graphs_destination_fkey foreign key ( "destination" ) references ex_%d_basic_blocks( "id" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_expression_trees add primary key( "id" );' % id)
      curs.execute('alter table ex_%d_expression_nodes add primary key( "id" );' % id)
      curs.execute('alter table ex_%d_expression_nodes add constraint ex_%d_expression_nodes_parent_id_fkey foreign key ( "parent_id" ) references ex_%d_expression_nodes( "id" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_expression_tree_nodes add constraint ex_%d_expression_tree_nodes_expression_tree_id_fkey foreign key ( "expression_tree_id" ) references ex_%d_expression_trees( "id" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_expression_tree_nodes add constraint ex_%d_expression_tree_nodes_expression_node_id_fkey foreign key ( "expression_node_id" ) references ex_%d_expression_nodes( "id" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_operands add primary key ( "address", "position" );' % id)
      curs.execute('alter table ex_%d_operands add constraint ex_%d_operands_expression_tree_id_fkey foreign key ( "expression_tree_id" ) references ex_%d_expression_trees( "id" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_operands add constraint ex_%d_operands_address_fkey foreign key ( "address" ) references ex_%d_instructions( "address" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_expression_substitutions add constraint ex_%d_expression_substitutions_address_position_fkey foreign key ( "address", "position" ) references ex_%d_operands( "address", "position" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_expression_substitutions add constraint ex_%d_expression_substitutions_expression_node_id_fkey foreign key ( "expression_node_id" ) references ex_%d_expression_nodes( "id" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_address_references add constraint ex_%d_address_references_address_position foreign key ( "address", "position" ) references ex_%d_operands( "address", "position" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_address_references add constraint ex_%d_address_references_expression_node_id_fkey foreign key ( "expression_node_id" ) references ex_%d_expression_nodes( "id" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_base_types add primary key ( "id" );' % id)
      curs.execute('alter table ex_%d_base_types add constraint ex_%d_base_types_pointer_fkey foreign key ( "pointer" ) references ex_%d_base_types( "id" ) on delete cascade on update cascade deferrable initially deferred;' % (id, id, id))
      curs.execute('alter table ex_%d_types add primary key ( "id");' % id)
      curs.execute('alter table ex_%d_types add constraint ex_%d_types_parent_id_fkey foreign key ( "parent_id" ) references ex_%d_base_types ( "id" ) on delete cascade on update cascade deferrable initially deferred;' % (id, id, id))
      curs.execute('alter table ex_%d_types add constraint ex_%d_types_base_type_fkey foreign key ( "base_type" ) references ex_%d_base_types ( "id" ) on delete cascade on update cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_expression_types add primary key ( "address", "position", "expression_id" );' % id)
      curs.execute('alter table ex_%d_expression_types add constraint ex_%d_expression_type_type_fkey foreign key ( "type" ) references ex_%d_base_types ( "id" ) on update no action on delete cascade deferrable initially deferred;' % (id, id, id))
      curs.execute('alter table ex_%d_sections add primary key ( "id" );' % id)
      curs.execute('alter table ex_%d_type_instances add primary key ( "id" );' % id)
      curs.execute('alter table ex_%d_type_instances add constraint ex_%d_type_instances_type_id_fkey foreign key ( "type_id" ) references ex_%d_base_types ( "id" ) match simple on update cascade on delete cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_type_instances add constraint ex_%d_type_instances_section_id_fkey foreign key ( "section_id" ) references ex_%d_sections ( "id" ) match simple on update cascade on delete cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_expression_type_instances add primary key ( "address", "position", "expression_node_id" );' % id)
      curs.execute('alter table ex_%d_expression_type_instances add constraint ex_%d_expression_type_instances_type_instance_id_fkey foreign key ( "type_instance_id" ) references ex_%d_type_instances ( "id" ) match simple on update cascade on delete cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_expression_type_instances add constraint ex_%d_expression_type_instances_address_position_fkey foreign key ( "address", "position" ) references ex_%d_operands ( "address", "position" ) match simple on update cascade on delete cascade;' % (id, id, id))
      curs.execute('alter table ex_%d_expression_type_instances add constraint ex_%d_expression_type_instances_expression_node_id_fkey foreign key ( "expression_node_id" ) references ex_%d_expression_nodes ( "id" ) match simple on update cascade on delete cascade;' % (id, id, id))

   def has_table(self, curs, table):
      result = False
      try:
         curs.execute("SELECT relname FROM pg_class WHERE relname = %s;", (table, ))
         result = curs.rowcount == 1
      except psycopg2.Error, p:
         print "has_table: %s" % p.message
         raise p
      return result

   def need_pg_init(self, curs):
      try:
         curs.execute('''SELECT count(*) FROM pg_class WHERE relname in ('bn_projects','bn_modules',
            'bn_address_spaces','bn_space_modules','bn_functions','bn_function_views','bn_instructions',
            'bn_operands','bn_expression_tree','bn_expression_tree_ids','bn_expression_tree_mapping',
            'bn_code_nodes','bn_codenode_instructions','bn_edges','bn_edge_paths','bn_function_nodes',
            'bn_group_nodes','bn_nodes','bn_project_settings','bn_module_settings','bn_traces','bn_trace_events',
            'bn_trace_event_values','bn_views','bn_module_views','bn_project_views','bn_view_settings',
            'bn_global_edge_comments','bn_global_node_comments','bn_project_debuggers','bn_debuggers',
            'bn_tags','bn_tagged_views','bn_tagged_nodes','bn_expression_substitutions','bn_comments',
            'bn_comments_audit','bn_types','bn_base_types','bn_users','bn_expression_types')''')
         res = curs.fetchone()[0]
         return res != 41
      except psycopg2.Error, p:
         print "need_pg_init: %s" % p.message
         raise p
      return True

   def create_modules_table(self):
      try:
         with self.conn as conn:
            with conn.cursor() as curs:
               query = ("CREATE TABLE modules ("
                        " id serial, "
                        " name text NOT NULL, "
                        " architecture varchar( 32 ) NOT NULL, "
                        " base_address bigint NOT NULL, "
                        " exporter varchar( 256 ) NOT NULL, "
                        " version int NOT NULL, "
                        " md5 char( 32 ) NOT NULL, "
                        " sha1 char( 40 ) NOT NULL, "
                        " comment TEXT, "
                        " import_time timestamp NOT NULL DEFAULT current_timestamp, "
                        " PRIMARY KEY (id));")
               curs.execute(query)
      except psycopg2.Error, p:
         print "create_modules_table: %s" % p.message
         raise p

   def delete_module(self, id):
      try:
         with self.conn as conn:
            with conn.cursor() as curs:
               curs.execute("delete from modules where id = %s;", (id, ))
               self.delete_raw_module(curs, id)
      except psycopg2.Error, p:
         print "delete_module: %s" % p.message
         raise p

   def insert_module(self, id, module_data):
      try:
         with self.conn as conn:
            with conn.cursor() as curs:
               curs.execute("insert into modules values(%s, %s, %s, %s, %s, %s, %s, %s, %s, now());",
                            (id, module_data.loader.name, module_data.loader.arch_name, module_data.loader.image_base, 'infiltrated', 0,
                             module_data.loader.md5, module_data.loader.sha1, module_data.comment))
      except psycopg2.Error, p:
         print "insert_module: %s" % p.message
         raise p

   def add_sections(self, curs, id, module_data):
      for s in module_data.loader.sections:
         raw = s.get_raw_bytes(module_data.loader)
         if raw is not None:
            curs.execute(("insert into ex_%d_sections"
                         "(name, start_address, end_address, permission, data)"
                         " values (%%s, %%s, %%s, %%s, %%s);" % id),
                         (s.name, s.start, s.end, bn_disasm.PERMISSIONS[s.perms], bytearray(raw)))

   def add_operands(self, curs, id, module_data):
      for addr in module_data.visited:
         op_exprs = module_data.operands[addr]
         opnum = 0
         '''
         if not hasattr(insn, "op_exprs"):
            print "Missing op_exprs for 0x%x" % insn.address
            continue
         if insn.op_exprs is None:
            print "op_exprs == None for 0x%x" % insn.address
            continue
         '''
         for expr in op_exprs:
            curs.execute(("insert into ex_%d_operands"
                         "(address, expression_tree_id, position)"
                         " values (%%s, %%s, %%s);" % id),
                         (addr, expr, opnum))
            opnum += 1

   def add_nodes(self, curs, id, module_data, nodes, parent):
      for key,value in nodes.iteritems():
         node = value[0]
         val = None
         if node.op_type == bn_disasm.IMMEDIATE_INT:
            val = node.value
            if node.value in module_data.names:
               key = module_data.names[node.value]
            else:
               key = None
         curs.execute(("insert into ex_%d_expression_nodes"
                      "(id, type, symbol, immediate, position, parent_id)"
                      " values (%%s, %%s, %%s, %%s, %%s, %%s);" % id),
                      (node.node_id, node.op_type % 10, key, val, node.pos, parent))
         for pos,op in value[1].iteritems():
            self.add_nodes(curs, id, module_data, op, node.node_id)

   def add_trees(self, curs, id, module_data):
      for expr in module_data.exprs.keys():
         curs.execute(("insert into ex_%d_expression_trees"
                      "(id)"
                      " values (%%s);" % id),
                      (expr, ))

   def add_tree_nodes(self, curs, id, module_data):
      for expr,nodes in module_data.exprs.iteritems():
         for n in nodes:
            curs.execute(("insert into ex_%d_expression_tree_nodes"
                         "(expression_tree_id, expression_node_id)"
                         " values (%%s, %%s);" % id),
                         (expr, n))

   def add_types(self, curs, id, module_data):
      for name,btype in module_data.types.iteritems():
         curs.execute(("insert into ex_%d_base_types"
                      "(id, name, size, pointer, signed, category)"
                      " values (%%s, %%s, %%s, %%s, %%s, %%s);" % id),
                      (btype.id, btype.name, btype.size, btype.pointer, btype.signed, bn_disasm.TYPE_CATEGORIES[btype.category]))

   def add_arefs(self, curs, id, module_data):
      for aref in module_data.arefs:
         curs.execute(("insert into ex_%d_address_references"
                      "(address, position, expression_node_id, destination, type)"
                      " values (%%s, %%s, %%s, %%s, %%s);" % id),
                      (aref.addr, aref.pos, aref.node_id, aref.dest, aref.rtype))

   def add_module(self, module_data):
      try:
         id = 0
         with self.conn as conn:
            with conn.cursor() as curs:
               curs.execute("select coalesce(max(id), 0) + 1 from modules;")
               id = curs.fetchone()[0]
         self.insert_module(id, module_data)

         with self.conn as conn:
            with conn.cursor() as curs:
               # ordering as binnavi's Ida plugin seems to
               #begin is here
               self.delete_raw_module(curs, id)
               self.create_raw_module(curs, id)
               #binnavi then adds sections here
               sys.stderr.write("add_sections\n")
               self.add_sections(curs, id, module_data)

               #next binnavi inserts into base_types table
               #    some basic types, then enumerates IDA's structs window, then adds types for all functions ('struct' ???)
               #   (1,'BYTE',8,181,true,'atomic'),
               #   (2,'WORD',16,181,true,'atomic'),
               #   (3,'DWORD',32,181,true,'atomic'),
               #   (4,'QWORD',64,null,true,'atomic'),
               #   (5,'void',32,181,false,'atomic'),
               #   (6,'void *',32,5,false,'atomic')
               sys.stderr.write("add_types\n")
               self.add_types(curs, id, module_data)
               #next binnavi inserts into types table
               #next into expression_types
               #          type_instances
               #          expression_type_instances
               #          address_comments

               sys.stderr.write("add_operands\n")
               self.add_operands(curs, id, module_data)
               sys.stderr.write("add_instructions\n")
               self.add_instructions(curs, id, module_data)
               #functions must have non-null stack_frame
               sys.stderr.write("add_functions\n")
               self.add_functions(curs, id, module_data)
               sys.stderr.write("add_basic_blocks\n")
               self.add_basic_blocks(curs, id, module_data)
               #          basic_block_instructions
               self.add_basic_block_instructions(curs, id, module_data)

               cfg_query = ("insert into ex_%d_control_flow_graphs"
                            "(parent_function, source, destination, type)"
                            " values (%%s, %%s, %%s, %%s);") % id
               for edge in module_data.cfg:
                  curs.execute(cfg_query, (edge.parent_func, edge.src_bb, edge.dest_bb, edge.edge_type))

               cg_query = ("insert into ex_%d_callgraph"
                           "(source, source_basic_block_id, source_address, destination)"
                           " values (%%s, %%s, %%s, %%s);") % id
               for edge in module_data.callgraph:
                  curs.execute(cg_query, (edge.src_func, edge.src_bb, edge.src_addr, edge.dest))

               sys.stderr.write("add_nodes\n")
               self.add_nodes(curs, id, module_data, module_data.nodes, None)
               #          expression_trees
               sys.stderr.write("add_trees\n")
               self.add_trees(curs, id, module_data)
               #          expression_tree_nodes
               sys.stderr.write("add_tree_nodes\n")
               self.add_tree_nodes(curs, id, module_data)

               #create indicies
               self.create_raw_indicies(curs, id)

               #          expression_substitutions
               #          address_references
               self.add_arefs(curs, id, module_data)

               #next a number of delete queries are executed
               self.delete_cleanup(curs, id)
               #now add indicies/foreign keys on all tables that need them
               self.create_raw_keys(curs, id)
               #commit is here

         self.vaccuum_raw_tables(id)

         return id
      except psycopg2.Error, p:
         traceback.print_exc()
         print "add_module: %s" % p.message
         raise p
      return -1

   def create_empty_tables(self):
      try:
         with self.conn as conn:
            with conn.cursor() as curs:
               if not self.has_table(curs, "modules"):
                  query = ("CREATE TABLE modules ("
                           " id serial, "
                           " name text NOT NULL, "
                           " architecture varchar( 32 ) NOT NULL, "
                           " base_address bigint NOT NULL, "
                           " exporter varchar( 256 ) NOT NULL, "
                           " version int NOT NULL, "
                           " md5 char( 32 ) NOT NULL, "
                           " sha1 char( 40 ) NOT NULL, "
                           " comment TEXT, "
                           " import_time timestamp NOT NULL DEFAULT current_timestamp, "
                           " PRIMARY KEY (id));")
                  curs.execute(query)

               if self.need_pg_init(curs):
                  with open('postgresql_tables.sql') as sql:
                     build_tables = sql.read()
                     curs.execute(build_tables)
                  curs.execute("INSERT INTO bn_users VALUES (DEFAULT, 'identity', null, null);")
      except psycopg2.Error, p:
         print "create_empty_tables: %s" % p.message

```

`bn_disasm.py`:

```py
#!/usr/bin/env python

'''
The disassembly engine for a stand-alone binnavi compatible disassembler
'''

__author__ = "Chris Eagle"
__copyright__ = "Copyright 2015, Chris Eagle"
__credits__ = ["Chris Eagle"]
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Chris Eagle"
__email__ = "cseagle@gmail.com"
__status__ = "Use at your own risk"

import os
import hashlib
import sys
import capstone
import loader

XR_FLOW = 1
XR_CALL = 2
XR_JUMP = 3
XR_JCC  = 4

CONDITION_TRUE = 0
CONDITION_FALSE = 1
UNCONDITIONAL = 2
SWITCH        = 3
CALL_DIRECT   = 4
CALL_INDIRECT = 5
CALL_VIRTUAL  = 6
DATA          = 7
DATA_STRING   = 8

AREF_TYPES = {
   0:'conditional_true',
   1:'conditional_false',  
   2:'unconditional',
   3:'switch',
   4:'call_direct',
   5:'call_indirect',
   6:'call_virtual',
   7:'data',
   8:'data_string'
}

PERMISSIONS = {
  1:'READ',
  2:'WRITE',
  4:'EXECUTE',
  3:'READ_WRITE',
  5:'READ_EXECUTE',
  6:'WRITE_EXECUTE',
  7:'READ_WRITE_EXECUTE'
}

NO_TYPE = 0
SYMBOL = 1           # String to be displayed.
IMMEDIATE_INT = 2
IMMEDIATE_FLOAT = 3
OPERATOR = 4         # '+', '*' etc.
REGISTER = 5
SIZE_PREFIX = 6     # 'B4, 'B8', etc.
DEREFERENCE = 7

ATOMIC  = 0
POINTER = 1
ARRAY   = 2
STRUCT  = 3
UNION   = 4
FUNCTION_POINTER = 5

TYPE_CATEGORIES = {
  0:'atomic',
  1:'pointer',
  2:'array',
  3:'struct',
  4:'union',
  5:'function_pointer',
}

#do the xrefs in the given list describe a conditional jump
def is_conditional(xrefs):
   if len(xrefs) != 2:
      return False
   return (xrefs[0][1] == XR_JCC or xrefs[1][1] == XR_JCC)

# return as (False target, True target)
def get_conditional_targets(xrefs):
   if len(xrefs) != 2:
      return None
   if xrefs[0][1] == XR_FLOW:
      return (xrefs[0][0], xrefs[1][0])
   return (xrefs[1][0], xrefs[0][0])

# return as (return target, call target)
def get_call_targets(xrefs):
   if len(xrefs) != 2:
      return None
   if xrefs[0][1] == XR_FLOW:
      return (xrefs[0][0], xrefs[1][0])
   return (xrefs[1][0], xrefs[0][0])

class OpNode(object):

   def __init__(self, op_type, value):
      self.op_type = op_type
      self.value = value
      self.node_id = 0
      self.pos = 0

class Operand(object):

   def __init__(self, addr, expr, pos):
      self.addr = addr
      self.expr = expr
      self.pos = pos

class AddressRef(object):
   
   def __init__(self, addr, pos, node_id, dest, rtype):
      self.addr = addr
      self.pos = pos
      self.node_id = node_id
      self.dest = dest
      self.rtype = rtype

class TypeInfo(object):

   def __init__(self, id, name, size, pointer, signed, category):
      self.id = id
      self.name = name
      self.size = size
      self.pointer = pointer
      self.signed = signed
      self.category = category

class BlockInfo(object):
   def __init__(self, bid, seq, func_addr):
      self.bid = bid
      self.seq = seq
      self.func = func_addr

#callgraph edge
class CG_Edge(object):
   def __init__(self, src_func, src_bb, src_addr, dest):
      self.src_func = src_func
      self.src_bb = src_bb
      self.src_addr = src_addr
      self.dest = dest

#control flow graph edge
class CFG_Edge(object):
   def __init__(self, parent_func, src_bb, dest_bb, edge_type):
      self.parent_func = parent_func
      self.src_bb = src_bb
      self.dest_bb = dest_bb
      self.edge_type = edge_type

class Disassembly(object):

   def __init__(self, loader):
      self.loader = loader

      self.comment = ''

      self.locs = []             # addr - to be visited
      self.visited = set()       # addr - instructions we have actually examined
      self.insts = {}            # addr:cs.CsInsn - cache of disassemled instructions
      self.names = {}            # addr:string
      self.jmp_targets = set()   # addr
      self.call_targets = set()  # addr
      self.xrefs_to = {}         # addr:list of (int,int)  (addr,type)
      self.xrefs_from = {}       # addr:list of (int,int)  (addr,type)
      self.thunks = set()        # addr

      self.bb_id = 0
      self.basic_block_starts = set()     # star address for basic blocks
      self.basic_blocks = {}     # addr:(int, set)  block_start:[(block_id, parent funcs)]

      self.callgraph = []        # CG_Edge
      self.cfg = []              # CFG_Edge

      self.nodes = {}            # {str:tuple}   tuple is node,{str:tuple}
      self.exprs = {}            # int:[]    int expression_id, list of nodes in expression
      self.expr_strings = {}     # string representations of expressions : expr_id
      self.node_id = 0
      self.expr_id = 0
      self.operands = {}         # addr:[int]   instruction address -> list of operand expressions
      self.arefs = []            # AddressRef
      self.type_id = 0
      self.types = {}            # name:TypeInfo
      self.func_sigs = []        # str - list of function header signatures for signature matching
      self.data_locs = {}        # {addr:size} - locations known to be data and their sizes
      
      #these should really come from disassembly process ??
      #rather than just priming the pump here
      self.add_type("char", 8, None, True, ATOMIC)
      self.add_type("short", 16, None, True, ATOMIC)
      self.add_type("int", 32, None, True, ATOMIC)
      self.add_type("BYTE", 8, None, True, ATOMIC)
      self.add_type("WORD", 16, None, True, ATOMIC)
      self.add_type("DWORD", 32, None, True, ATOMIC)
      self.add_type("QWORD", 32, None, True, ATOMIC)
      self.add_type("int8_t", 8, None, True, ATOMIC)
      self.add_type("int16_t", 16, None, True, ATOMIC)
      self.add_type("int32_t", 32, None, True, ATOMIC)
      self.add_type("int64_t", 64, None, True, ATOMIC)
      self.add_type("uint8_t", 8, None, False, ATOMIC)
      self.add_type("uint16_t", 16, None, False, ATOMIC)
      self.add_type("uint32_t", 32, None, False, ATOMIC)
      self.add_type("uint64_t", 64, None, False, ATOMIC)

      for addr in loader.imports_by_addr:
         self.data_locs[addr] = loader.sizeof_ptr

   #do the xrefs in the given list describe a function call that returns
   def is_returning_call(self, xrefs):
      if len(xrefs) != 2:
         return False
      if xrefs[1][1] == XR_CALL:
         tgt = xrefs[1][0]
      elif xrefs[0][1] == XR_CALL:
         tgt = xrefs[0][0]
      else:
         return False   # not a call
      if tgt in self.names and self.names[tgt] in self.loader.non_returning_funcs:
         return False
      return (xrefs[0][1] == XR_FLOW and xrefs[1][1] == XR_CALL) or \
             (xrefs[1][1] == XR_FLOW and xrefs[0][1] == XR_CALL)

   def add_type(self, name, size, pointer, signed, category):
      self.type_id += 1
      self.types[name] = TypeInfo(self.type_id, name, size, pointer, signed, category)

   def add_basic_block_start(self, addr):
      self.basic_block_starts.add(addr)

   #returns new basic block id
   def add_basic_block(self, addr, parent):
      if addr not in self.basic_block_starts:
         return
      self.bb_id += 1
      if addr not in self.basic_blocks:
         self.basic_blocks[addr] = []
      bb = (self.bb_id, parent)
      self.basic_blocks[addr].append(bb)
      return bb[0]

   def is_bb_start(self, addr):
      return addr in self.basic_block_starts

   def get_bb_id(self, func, addr):
      inst = self.insts[addr]
      if hasattr(inst, "bb"):
         for block in inst.bb:
            if func == block.func:
               return block.bid
         '''
         sys.stderr.write("Unable to get_bb_id for 0x%x in func 0x%x\n" % (addr, func))
         for block in inst.bb:
            sys.stderr.write("(%d, %d, 0x%x), " % (block.bid, block.seq, block.func))
         sys.stderr.write("\n")
         '''
      '''
      else:
         sys.stderr.write("0x%x has no bb attr\n" % addr)
         sys.stderr.write("Unable to get_bb_id for 0x%x in func 0x%x\n" % (addr, func))
      '''
      return -1

   def print_func_owners(self, addr):
      insn = self.insts[addr]
      if hasattr(insn, "bb"):
         for b in insn.bb:
            sys.stderr.write("0x%x, " % b.func)
         sys.stderr.write("\n")
            

   def build_cfg(self):
      for addr,bb in self.basic_blocks.iteritems():
         if addr in self.call_targets:
            continue
         if addr in self.xrefs_to:
            #look at the instructions that refer to this basic block start address
            for xr in self.xrefs_to[addr]:
               src = xr[0]
               #add an edge for each block that the referring instruction belongs to
               for block in bb:
                  src_bb = self.get_bb_id(block[1], src)
                  if src_bb == -1:
                     # this seems to happen when we don't have a complete understanding
                     # of whether a function call fails to return or not
                     # which leads to the incorrect conclusion that the instruction
                     # following the call is reachable
                     '''
                     sys.stderr.write("0x%x refers to 0x%x but failed to find bid for 0x%x\n" % (src, addr, src))
                     sys.stderr.write("0x%x belongs to: " % src)
                     self.print_func_owners(src)
                     sys.stderr.write("0x%x belongs to: " % addr)
                     self.print_func_owners(addr)
                     '''
                     continue
                  xr_type = CONDITION_FALSE
                  if xr[1] == XR_FLOW:
                     if len(self.xrefs_from[src]) == 1:
                        xr_type = UNCONDITIONAL
                     else:
                        xr_type = CONDITION_FALSE
                  elif xr[1] == XR_JCC:
                     xr_type = CONDITION_TRUE
                  elif xr[1] == XR_JUMP:
                     xr_type = UNCONDITIONAL
                  else:  #should not get here
                     continue
                  edge = CFG_Edge(block[1], src_bb, block[0], xr_type)
                  self.cfg.append(edge)

   def build_callgraph(self):
      for func in self.call_targets:
         if func in self.xrefs_to:
            for xr in self.xrefs_to[func]:
               src = xr[0]
               inst = self.insts[src]
               if hasattr(inst, "bb"):
                  for block in inst.bb:
                     edge = CG_Edge(block.func, block.bid, src, func)
                     self.callgraph.append(edge)

   #need to traverse to figure out the parent functions for 
   #all basic blocks. Note we have more work to do than we should
   #this is a result of the binnavi database schema failing to actually
   #set the ex_N_basic_blocks primary key to (id, parent_function) as they 
   #claim to in
   #binnavi/src/main/java/com/google/security/zynamics/binnavi/manual/html/dbformat.htm
   #instead they only use id so we need a unique id when a block is part of more than
   #one function
   def extract_basic_block_data(self, func, addr, func_insts):
      bb = -1
      while True:
         if addr in func_insts:
            break
         func_insts.add(addr)
         if self.is_bb_start(addr):
            if addr == 0:
               print "tried to add basic block at 0 for func 0x%x" % func
            else:
               bb = self.add_basic_block(addr, func)
         if addr in self.xrefs_from:
            flows_to = -1
            xrefs = self.xrefs_from[addr]
            for xr in xrefs:
               if xr[1] == XR_FLOW:
                  flows_to = xr[0]
               elif xr[1] == XR_CALL:
                  continue
               elif xr[1] == XR_JCC:
                  self.extract_basic_block_data(func, xr[0], func_insts)
               elif xr[0] in self.thunks:  # must be XR_JUMP
                  continue
               elif xr[0] in self.call_targets:  # must be XR_JUMP to a function
                  # this might/probably needs a callgraph edge
                  continue
               elif xr[0] in self.loader.imports_by_addr:  # must be XR_JUMP
                  continue
               else:  # XR_JUMP, perhaps switch jump ???
                  self.extract_basic_block_data(func, xr[0], func_insts)
            if flows_to != -1:
               addr = flows_to
            else: #no normal flow from here
               break
         else: #no xrefs from here
            break

   #assumes we have all basic blocks identified, we make a second pass here
   #in case we need to associate a bansic block with more than one function
   #this is a result of the binnavi database schema failing to actually
   #set the ex_N_basic_blocks primary key to (id, parent_function) as they 
   #claim to in
   #binnavi/src/main/java/com/google/security/zynamics/binnavi/manual/html/dbformat.htm
   #instead they only use id so we need a unique id when a block is part of more than
   #one function
   def set_basic_block_instructions(self):
      for addr,bb in self.basic_blocks.iteritems():
         seq = 0
         while True:
            if addr not in self.insts:
               #may have reference to invalid isntruction
               break
            inst = self.insts[addr]
            inst.bb = [BlockInfo(b[0], seq, b[1]) for b in bb] #block may belong to more than one function
            seq += 1
            if addr in self.xrefs_from:
               xrefs = self.xrefs_from[addr]
               if self.is_returning_call(xrefs):
                  addr = get_call_targets(xrefs)[0]
               elif len(xrefs) > 1:
                  break
               else: # len(xrefs) == 1
                  addr = xrefs[0][0]
            else: # no xrefs from so at end of block
               break
            if addr in self.basic_blocks: #hit start of different basic block
               break

   #tree is a list of OpNode
   def insert_tree(self, root, tree, depth, pos):
      n = tree[depth]
      n.pos = pos
      depth += 1
      arity = 0
      if (n.op_type % 10) == OPERATOR:
         #operator types are encoded as #4 where # is the arity of the operator
         arity = n.op_type // 10
      if n.op_type == SIZE_PREFIX or n.op_type == DEREFERENCE:
         #also descend on a SIZE_PREFIX
         arity = 1
      
      if n.value not in root:
         #new node at this level
         self.node_id += 1
         n.node_id = self.node_id
         root[n.value] = (n, {})
      else:
         n.node_id = root[n.value][0].node_id      
      self.exprs[self.expr_id].append(root[n.value][0].node_id)
      op_root = root[n.value][1]
      for i in range(arity):
         if i not in op_root:
            op_root[i] = {}
         root = op_root[i]    #different subtrees for different operand position
         #parse the operands for the operator
         depth = self.insert_tree(root, tree, depth, i)
      return depth

   def tree_to_str(self, tree):
      s = ''
      for o in tree:
         s += '(%s)' % str(o.value)
      return s

   def add_expr_tree(self, tree):
      if len(tree) == 0:
         return 0
      s = self.tree_to_str(tree)
      if s in self.expr_strings:
         #we have seen this expression before
         expr_id = self.expr_strings[s]
         idx = 0
         for i in self.exprs[expr_id]:
            tree[idx].node_id = i
            idx += 1
         return expr_id
      # will be making a new expression
      self.expr_id += 1
      self.exprs[self.expr_id] = []
      self.insert_tree(self.nodes, tree, 0, 0)
      self.expr_strings[s] = self.expr_id
      return self.expr_id

   def print_disassembly(self):
      keylist = [a for a in self.visited]    # self.insts.keys()
      keylist.sort()
      last = None
      for a in keylist:
         i = self.insts[a]
         if a in self.names:
            print "%s:" % self.names[a]
         ref = ''
         if i.address not in self.xrefs_to:
            ref = "\t\t**** NOT REFERENCED ****"
         operand = self.get_op_name(i.address, i.op_str)
         print "\t0x%08x:\t%s%s%s" % (i.address, i.mnemonic.ljust(8), operand, ref)
         '''
         if i.address in self.xrefs_from:
            xr = self.xrefs_from[i.address]
            sys.stdout.write('\t')
            for x in xr:
               sys.stdout.write("0x%x(%d), " % (x[0], x[1]))           
            sys.stdout.write('\n')
         '''
         last = i

   def scan_gaps(self, header):
      keylist = [a for a in self.visited]   # self.insts.keys()
      keylist.sort()
      last = None
      count = 0
      for a in keylist:
         i = self.insts[a]
         if last is not None and (last.address + last.size) != a:
            gap_start = last.address + last.size
            gap = self.loader.get_bytes(gap_start, a - gap_start)
            if gap is None:
               print "That's odd, gap is None"
               continue
            idx = 0
            while True:
               loc = gap.find(header, idx)
               if loc != -1 and (loc + gap_start) not in self.visited:
                  self.locs.append(loc + gap_start)
                  #print "Adding gap function 0x%x" % (loc + gap_start)
                  count += 1
                  idx = loc + 1
               else:
                  break
         last = i
      #print "Gap analysis added %d new locations" % count

   #Scan the data sections for possible references back to code
   #such as vtables, switch jumps, and other function pointers
   def scan_data(self):
      pass

   #Scan unanalyzed gaps in the code section for possible references
   #to code such as switch jumps
   def scan_gap_data(self):
      pass

   #subclasses should implement this as it's very platform specific
   def process_operands(self, inst):
      raise Exception("Please implement process_operands")

   #subclasses should implement this
   def process_jump(self, inst):
      raise Exception("Please implement process_jump")

   #subclasses should implement this
   def process_call(self, inst):
      raise Exception("Please implement process_jump")

   #subclasses should implement this
   def get_op_name(self, addr, default_val):
      raise Exception("Please implement get_op_name")

   def add_xref(self, frm, to, xr_type=XR_FLOW):
      raise Exception("Please implement add_xref")

   def nextinst(self, addr):
      #take enough to get at least 1 instruction in majority case
      if addr in self.insts:
         # previously decoded this with capstone
         return self.insts[addr]
      # grab a block of bytes following the current address
      mc = self.loader.get_bytes(addr, 256)
      if mc is None or len(mc) == 0:
         return None
      for i in self.dis.disasm(mc, addr):
         self.insts[i.address] = i
      if addr in self.insts:
         return self.insts[addr]
      return None

   def is_possible_code(self, addr):
      if addr in self.data_locs:
         return False
      for s in self.loader.sections:
         if (s.perms & loader.PROT_EXEC) and s.contains(addr):
            return True
      return False

   def generate_disassembly(self):
      while len(self.locs) > 0:
         addr = self.locs.pop(0)
         if not self.is_possible_code(addr):
            continue
         dead_end = False
         while True:
            i = self.nextinst(addr)
            if i is None:
               # but we should have gotten an instruction so this is odd
               # remove all xrefs to this address
               if addr in self.xrefs_to:
                  srcs = self.xrefs_to[addr]
                  for s in srcs:
                     if s[0] in self.xrefs_from:
                        dests = self.xrefs_from[s[0]]
                        for tgt in dests:
                           if tgt[0] == addr:
                              dests.remove(tgt)
                              break
                        if len(dests) == 0:
                           self.xrefs_from.pop(s[0])
                  self.xrefs_to.pop(addr, None)
               break
            if i.address in self.visited:
               #already been here, won't learn anything new
               break
            self.visited.add(i.address)
            self.insts[i.address] = i
            self.process_operands(i)
            
            dead_end = False
            if i.group(capstone.CS_GRP_JUMP):
               dead_end = self.process_jump(i)
            elif i.group(capstone.CS_GRP_CALL):
               dead_end = self.process_call(i)
            elif i.group(capstone.CS_GRP_RET):
               dead_end = True
            elif i.group(capstone.CS_GRP_IRET):
               dead_end = True
            if not dead_end:
               next_addr = i.address + i.size
               self.add_xref(i.address, next_addr)
            else:
               #dead end return to instruction list
               break

   def generate_data(self):
      self.generate_disassembly()
   
      print "After first pass, have %d insts" % len(self.visited)
   
      main = self.loader.find_main(self.insts, self.xrefs_to, self.xrefs_from)
      if main is not None and main not in self.visited:
         print "Found main at 0x%x" % main
         self.locs.append(main)
         self.call_targets.add(main)
         self.add_basic_block_start(main)
         if "main" not in self.names:
            self.names[main] = "main"
         elif "_main" not in self.names:
            self.names[main] = "_main"
         else:
            self.names[main] = "sub_%x" % main
      self.generate_disassembly()   

      print "After 'find_main' pass, have %d insts" % len(self.visited)
   
      #pick up pointers in the rdata section
#      self.scan_data()
#      self.generate_disassembly()
   
#      for sig in self.func_sigs:
         #try to find more code by looking for standard prologue
#         self.scan_gaps(sig)
#         self.generate_disassembly()
   
      #pick up pointers in the text section
#      self.scan_gap_data()
#      self.generate_disassembly()

      for f in self.call_targets:
         self.extract_basic_block_data(f, f, set())
      self.set_basic_block_instructions()
      self.build_cfg()
      self.build_callgraph()
      for addr,bb in self.basic_blocks.iteritems():
         if len(bb) == 0:
            print "no parent found for basic block at 0x%x" % addr
      for addr in self.visited:
         i = self.insts[addr]
         if not hasattr(i, "bb"):
            print "Instruction 0x%x has no bb" % addr

```

`elf_loader.py`:

```py
#!/usr/bin/env python

'''
Crude ELF loader, conforming to the Loader interface, for a stand-alone binnavi compatible disassembler
'''

__author__ = "Chris Eagle"
__copyright__ = "Copyright 2015, Chris Eagle"
__credits__ = ["Chris Eagle"]
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Chris Eagle"
__email__ = "cseagle@gmail.com"
__status__ = "Use at your own risk"

import sys
import struct
import hashlib
import binascii
import capstone
from loader import *

XR_FLOW = 1
XR_CALL = 2
XR_JUMP = 3
XR_JCC  = 4

EI_CLASS    = 4        # File class byte index
ELFCLASSNONE = 0    # Invalid class
ELFCLASS32  = 1     # 32-bit objects
ELFCLASS64  = 2     # 64-bit objects
ELFCLASSNUM = 3

EI_DATA     = 5     # Data encoding byte index
ELFDATANONE = 0     # Invalid data encoding
ELFDATA2LSB = 1     # 2's complement, little endian
ELFDATA2MSB = 2     # 2's complement, big endian
ELFDATANUM  = 3

EI_VERSION  = 6     # File version byte index
      # Value must be EV_CURRENT

EI_OSABI = 7     # OS ABI identification
ELFOSABI_NONE    = 0  # UNIX System V ABI
ELFOSABI_SYSV    = 0  # Alias.
ELFOSABI_HPUX    = 1  # HP-UX
ELFOSABI_NETBSD  = 2  # NetBSD.
ELFOSABI_GNU     = 3  # Object uses GNU ELF extensions.
ELFOSABI_LINUX   = ELFOSABI_GNU # Compatibility alias.
ELFOSABI_SOLARIS = 6  # Sun Solaris.
ELFOSABI_AIX     = 7  # IBM AIX.
ELFOSABI_IRIX    = 8  # SGI Irix.
ELFOSABI_FREEBSD = 9  # FreeBSD.
ELFOSABI_TRU64   = 10 # Compaq TRU64 UNIX.
ELFOSABI_MODESTO = 11 # Novell Modesto.
ELFOSABI_OPENBSD = 12 # OpenBSD.
ELFOSABI_ARM_AEABI = 64 # ARM EABI
ELFOSABI_ARM     = 97 # ARM
ELFOSABI_STANDALONE = 255   # Standalone (embedded) application

EI_ABIVERSION = 8     # ABI version

EI_PAD    = 9     # Byte index of padding bytes

# Legal values for e_type (object file type).

ET_NONE   = 0     # No file type
ET_REL    = 1     # Relocatable file
ET_EXEC   = 2     # Executable file
ET_DYN    = 3     # Shared object file
ET_CORE   = 4     # Core file
ET_NUM    = 5     # Number of defined types
ET_LOOS   = 0xfe00      # OS-specific range start
ET_HIOS   = 0xfeff      # OS-specific range end
ET_LOPROC = 0xff00      # Processor-specific range start
ET_HIPROC = 0xffff      # Processor-specific range end


EM_NONE    =  0    # No machine
EM_SPARC   =  2    # SUN SPARC
EM_386     =  3    # Intel 80386
EM_68K     =  4    # Motorola m68k family
EM_MIPS    =  8    # MIPS R3000 big-endian
EM_MIPS_RS3_LE = 10 # MIPS R3000 little-endian

EM_PPC     =  20    # PowerPC
EM_PPC64   =  21    # PowerPC 64-bit

EM_ARM     =  40    # ARM
EM_SPARCV9 =  43    # SPARC v9 64-bit

EM_X86_64  =  62    # AMD x86-64 architecture

EM_AARCH64 =  183   # ARM AARCH64

# Legal values for p_type (segment type).

PT_NULL     = 0     # Program header table entry unused
PT_LOAD     = 1     # Loadable program segment
PT_DYNAMIC  = 2     # Dynamic linking information
PT_INTERP   = 3     # Program interpreter
PT_NOTE     = 4     # Auxiliary information
PT_SHLIB    = 5     # Reserved
PT_PHDR     = 6     # Entry for header table itself
PT_TLS      = 7     # Thread-local storage segment
PT_NUM      = 8     # Number of defined types
PT_LOOS     = 0x60000000  # Start of OS-specific
PT_GNU_EH_FRAME   = 0x6474e550  # GCC .eh_frame_hdr segment
PT_GNU_STACK   = 0x6474e551  # Indicates stack executability
PT_GNU_RELRO   = 0x6474e552  # Read-only after relocation
PT_LOSUNW   = 0x6ffffffa
PT_SUNWBSS  = 0x6ffffffa  # Sun Specific segment
PT_SUNWSTACK = 0x6ffffffb  # Stack segment
PT_HISUNW   = 0x6fffffff
PT_HIOS     = 0x6fffffff  # End of OS-specific
PT_LOPROC   = 0x70000000  # Start of processor-specific
PT_HIPROC   = 0x7fffffff  # End of processor-specific

# Legal values for e_version (version).

EV_NONE     = 0     # Invalid ELF version
EV_CURRENT  = 1     # Current version
EV_NUM      = 2

# Legal values for p_flags (segment flags).

PF_X        = (1 << 0) # Segment is executable
PF_W        = (1 << 1) # Segment is writable
PF_R        = (1 << 2) # Segment is readable
PF_MASKOS   = 0x0ff00000  # OS-specific
PF_MASKPROC = 0xf0000000  # Processor-specific

# Legal values for sh_type (section type).

SHT_NULL  = 0     # Section header table entry unused
SHT_PROGBITS   = 1      # Program data
SHT_SYMTAB  = 2      # Symbol table
SHT_STRTAB  = 3      # String table
SHT_RELA = 4      # Relocation entries with addends
SHT_HASH = 5      # Symbol hash table
SHT_DYNAMIC = 6      # Dynamic linking information
SHT_NOTE = 7      # Notes
SHT_NOBITS  = 8      # Program space with no data (bss)
SHT_REL     = 9      # Relocation entries, no addends
SHT_SHLIB   = 10     # Reserved
SHT_DYNSYM  = 11     # Dynamic linker symbol table
SHT_INIT_ARRAY = 14     # Array of constructors
SHT_FINI_ARRAY = 15     # Array of destructors
SHT_PREINIT_ARRAY = 16    # Array of pre-constructors
SHT_GROUP   = 17     # Section group
SHT_SYMTAB_SHNDX = 18    # Extended section indeces
SHT_NUM     = 19     # Number of defined types.
SHT_LOOS = 0x60000000   # Start OS-specific.
SHT_GNU_ATTRIBUTES = 0x6ffffff5 # Object attributes.
SHT_GNU_HASH   = 0x6ffffff6   # GNU-style hash table.
SHT_GNU_LIBLIST   = 0x6ffffff7   # Prelink library list
SHT_CHECKSUM   = 0x6ffffff8   # Checksum for DSO content.
SHT_LOSUNW   = 0x6ffffffa   # Sun-specific low bound.
SHT_SUNW_move   = 0x6ffffffa
SHT_SUNW_COMDAT  = 0x6ffffffb
SHT_SUNW_syminfo = 0x6ffffffc
SHT_GNU_verdef  = 0x6ffffffd   # Version definition section.
SHT_GNU_verneed   = 0x6ffffffe   # Version needs section.
SHT_GNU_versym  = 0x6fffffff   # Version symbol table.
SHT_HISUNW   = 0x6fffffff   # Sun-specific high bound.
SHT_HIOS  = 0x6fffffff   # End OS-specific type
SHT_LOPROC  = 0x70000000   # Start of processor-specific
SHT_HIPROC  = 0x7fffffff   # End of processor-specific
SHT_LOUSER  = 0x80000000   # Start of application-specific
SHT_HIUSER  = 0x8fffffff   # End of application-specific

# Legal values for sh_flags (section flags).

SHF_WRITE        = (1 << 0)  # Writable
SHF_ALLOC        = (1 << 1)  # Occupies memory during execution
SHF_EXECINSTR    = (1 << 2)  # Executable
SHF_MERGE        = (1 << 4)  # Might be merged
SHF_STRINGS      = (1 << 5)  # Contains nul-terminated strings
SHF_INFO_LINK    = (1 << 6)  # `sh_info' contains SHT index
SHF_LINK_ORDER   = (1 << 7)  # Preserve order after combining
SHF_OS_NONCONFORMING = (1 << 8) # Non-standard OS specific handling required
SHF_GROUP       = (1 << 9)  # Section is member of a group.
SHF_TLS         = (1 << 10) # Section hold thread-local data.
SHF_MASKOS      = 0x0ff00000   # OS-specific.
SHF_MASKPROC    = 0xf0000000   # Processor-specific
SHF_ORDERED     = (1 << 30) # Special ordering requirement (Solaris).
SHF_EXCLUDE     = (1 << 31) # Section is excluded unless referenced or allocated (Solaris).

# Legal values for ST_TYPE subfield of st_info (symbol type).

STT_NOTYPE   = 0     # Symbol type is unspecified
STT_OBJECT   = 1     # Symbol is a data object
STT_FUNC     = 2     # Symbol is a code object
STT_SECTION  = 3     # Symbol associated with a section
STT_FILE     = 4     # Symbol's name is file name
STT_COMMON   = 5     # Symbol is a common data object
STT_TLS      = 6     # Symbol is thread-local data object
STT_NUM      = 7     # Number of defined types.
STT_LOOS     = 10    # Start of OS-specific
STT_GNU_IFUNC = 10    # Symbol is indirect code object
STT_HIOS     = 12    # End of OS-specific
STT_LOPROC   = 13    # Start of processor-specific
STT_HIPROC   = 15    # End of processor-specific

# Legal values for d_tag (dynamic entry type).

DT_NULL      = 0     # Marks end of dynamic section
DT_NEEDED    = 1     # Name of needed library
DT_PLTRELSZ  = 2     # Size in bytes of PLT relocs
DT_PLTGOT    = 3     # Processor defined value
DT_HASH      = 4     # Address of symbol hash table
DT_STRTAB    = 5     # Address of string table
DT_SYMTAB    = 6     # Address of symbol table
DT_RELA      = 7     # Address of Rela relocs
DT_RELASZ    = 8     # Total size of Rela relocs
DT_RELAENT   = 9     # Size of one Rela reloc
DT_STRSZ     = 10    # Size of string table
DT_SYMENT    = 11    # Size of one symbol table entry
DT_INIT      = 12    # Address of init function
DT_FINI      = 13    # Address of termination function
DT_SONAME    = 14    # Name of shared object
DT_RPATH     = 15    # Library search path (deprecated)
DT_SYMBOLIC  = 16    # Start symbol search here
DT_REL       = 17    # Address of Rel relocs
DT_RELSZ     = 18    # Total size of Rel relocs
DT_RELENT    = 19    # Size of one Rel reloc
DT_PLTREL    = 20    # Type of reloc in PLT
DT_DEBUG     = 21    # For debugging; unspecified
DT_TEXTREL   = 22    # Reloc might modify .text
DT_JMPREL    = 23    # Address of PLT relocs
DT_BIND_NOW  = 24    # Process relocations of object
DT_INIT_ARRAY = 25    # Array with addresses of init fct
DT_FINI_ARRAY = 26    # Array with addresses of fini fct
DT_INIT_ARRAYSZ   = 27    # Size in bytes of DT_INIT_ARRAY
DT_FINI_ARRAYSZ   = 28    # Size in bytes of DT_FINI_ARRAY
DT_RUNPATH   = 29    # Library search path
DT_FLAGS     = 30    # Flags for the object being loaded
DT_ENCODING  = 32    # Start of encoded range
DT_PREINIT_ARRAY = 32      # Array with addresses of preinit fct
DT_PREINIT_ARRAYSZ = 33    # size in bytes of DT_PREINIT_ARRAY
DT_NUM       = 34    # Number used
DT_LOOS      = 0x6000000d  # Start of OS-specific
DT_HIOS      = 0x6ffff000  # End of OS-specific
DT_LOPROC    = 0x70000000  # Start of processor-specific
DT_HIPROC    = 0x7fffffff  # End of processor-specific
#DT_PROCNUM  = DT_MIPS_NUM # Most used by any processor

# DT_* entries which fall between DT_VALRNGHI & DT_VALRNGLO use the
#   Dyn.d_un.d_val field of the Elf*_Dyn structure.  This follows Sun's
#   approach.
DT_VALRNGLO  = 0x6ffffd00
DT_GNU_PRELINKED  = 0x6ffffdf5 # Prelinking timestamp
DT_GNU_CONFLICTSZ = 0x6ffffdf6   # Size of conflict section
DT_GNU_LIBLISTSZ  = 0x6ffffdf7 # Size of library list
DT_CHECKSUM  = 0x6ffffdf8
DT_PLTPADSZ  = 0x6ffffdf9
DT_MOVEENT   = 0x6ffffdfa
DT_MOVESZ    = 0x6ffffdfb
DT_FEATURE_1 = 0x6ffffdfc  # Feature selection (DTF_*).
DT_POSFLAG_1 = 0x6ffffdfd  # Flags for DT_* entries, effecting the following DT_* entry.
DT_SYMINSZ   = 0x6ffffdfe  # Size of syminfo table (in bytes)
DT_SYMINENT  = 0x6ffffdff  # Entry size of syminfo
DT_VALRNGHI  = 0x6ffffdff
#DT_VALTAGIDX(tag)  (DT_VALRNGHI - (tag))   # Reverse order!
DT_VALNUM    = 12

# DT_* entries which fall between DT_ADDRRNGHI & DT_ADDRRNGLO use the
#   Dyn.d_un.d_ptr field of the Elf*_Dyn structure.

#   If any adjustment is made to the ELF object after it has been
#   built these entries will need to be adjusted.
DT_ADDRRNGLO = 0x6ffffe00
DT_GNU_HASH  = 0x6ffffef5  # GNU-style hash table.
DT_TLSDESC_PLT  = 0x6ffffef6
DT_TLSDESC_GOT  = 0x6ffffef7
DT_GNU_CONFLICT = 0x6ffffef8  # Start of conflict section
DT_GNU_LIBLIST  = 0x6ffffef9  # Library list
DT_CONFIG    = 0x6ffffefa  # Configuration information.
DT_DEPAUDIT  = 0x6ffffefb  # Dependency auditing.
DT_AUDIT     = 0x6ffffefc  # Object auditing.
DT_PLTPAD    = 0x6ffffefd  # PLT padding.
DT_MOVETAB   = 0x6ffffefe  # Move table.
DT_SYMINFO   = 0x6ffffeff  # Syminfo table.
DT_ADDRRNGHI = 0x6ffffeff
#DT_ADDRTAGIDX(tag) (DT_ADDRRNGHI - (tag))  # Reverse order!
DT_ADDRNUM   = 11

# The versioning entry types.  The next are defined as part of the GNU extension.
DT_VERSYM    = 0x6ffffff0

DT_RELACOUNT = 0x6ffffff9
DT_RELCOUNT  = 0x6ffffffa

# These were chosen by Sun.
DT_FLAGS_1   = 0x6ffffffb  # State flags, see DF_1_* below.
DT_VERDEF    = 0x6ffffffc  # Address of version definition table
DT_VERDEFNUM = 0x6ffffffd  # Number of version definitions
DT_VERNEED   = 0x6ffffffe  # Address of table with needed versions
DT_VERNEEDNUM  = 0x6fffffff  # Number of needed versions
#DT_VERSIONTAGIDX(tag) (DT_VERNEEDNUM - (tag)) # Reverse order!
DT_VERSIONTAGNUM = 16

# Sun added these machine-independent extensions in the "processor-specific" range.  Be compatible.
DT_AUXILIARY    = 0x7ffffffd      # Shared object to load before self
DT_FILTER       = 0x7fffffff      # Shared object to get values from
#DT_EXTRATAGIDX(tag)   ((Elf32_Word)-((Elf32_Sword) (tag) <<1>>1)-1)
DT_EXTRANUM     = 3

class InvalidHeader(Exception):
   def __init__(self, msg):
      Exception.__init__(self, msg)

class ElfSectionHeader(object):
   # do our best to handle both Elf32_Shdr and Elf64_Shdr
   def __init__(self, elf, offset):
      try:
         self.elf = elf
         self.raw = elf.raw[offset:offset+elf.e_shentsize]
         if elf.sizeof_ptr == 8:
            fields = struct.unpack(elf.endian + "IIQQQQIIQQ", self.raw)
         else:
            fields = struct.unpack(elf.endian + "IIIIIIIIII", self.raw)
         self.sh_name = fields[0]
         self.sh_type = fields[1]
         self.sh_flags = fields[2]
         self.sh_addr = fields[3]
         self.sh_offset = fields[4]
         self.sh_size = fields[5]
         self.sh_link = fields[6]
         self.sh_info = fields[7]
         self.sh_addralign = fields[8]
         self.sh_entsize = fields[9]

         self.perms = PROT_READ

         if self.sh_type == SHT_NOBITS:
            size = 0
         else:
            size = self.sh_size

         if self.sh_flags & SHF_WRITE:
            self.perms |= PROT_WRITE
         if self.sh_flags & SHF_EXECINSTR:
            self.perms |= PROT_EXEC
            
         self.content = elf.raw

      except:
         raise InvalidHeader("Invalid section header")

   def __del__(self):
      del self.raw

   def get_string(self, offset):
      #if this isn't a STRTAB section we should probably throw an exception
      res = ''
      while offset < self.sh_size:
         ch = self.content[self.sh_offset + offset]
         if ch == '\x00':
            break
         res += ch
         offset += 1
      return res

   def get_symbol(self, offset):
      #if this isn't a SYMTAB section we should probably throw an exception
      strtab = self.elf.shdrs[self.sh_link]
      sym_start = self.sh_offset + offset
      st_name = struct.unpack(self.elf.endian + "I", self.content[sym_start:sym_start + 4])[0]
      if self.elf.sizeof_ptr == 4:
         idx = 2
         fields = struct.unpack(self.elf.endian + "IIBBH", self.content[sym_start + 4:sym_start + 16])
      else:
         idx = 0
         fields = struct.unpack(self.elf.endian + "BBHQQ", self.content[sym_start + 4:sym_start + 24])
      st_info = fields[idx]
      st_other = fields[idx + 1]
      st_shndx = fields[idx + 2]
      st_value = fields[(idx + 3) % 5]
      st_size = fields[(idx + 4) % 5]
      name = strtab.get_string(st_name)
      #print "Symbol name: %s" % name
      return ElfSymbol(name, st_value, st_size, st_info, st_other, st_shndx)

class ElfProgramHeader(object):
   # do our best to handle both Elf32_Phdr and Elf64_Phdr
   def __init__(self, elf, offset):
      try:
         self.raw = elf.raw[offset:offset+elf.e_phentsize]
         i = elf.sizeof_ptr >> 2
         if elf.sizeof_ptr == 8:
            fields = struct.unpack(elf.endian + "IIQQQQQQ", self.raw)
            self.p_flags = fields[1]
         else:
            fields = struct.unpack(elf.endian + "IIIIIIII", self.raw)
            self.p_flags = fields[6]

         self.p_type = fields[0]
         self.p_offset = fields[i]
         self.p_vaddr = fields[i + 1]
         self.p_paddr = fields[i + 2]
         self.p_filesz = fields[i + 3]
         self.p_memsz = fields[i + 4]
         self.p_align = fields[7]

         self.perms = 0
         if self.p_flags & PF_R:
            self.perms |= PROT_READ
         if self.p_flags & PF_W:
            self.perms |= PROT_WRITE
         if self.p_flags & PF_X:
            self.perms |= PROT_EXEC

         if self.p_type == PT_DYNAMIC:
            self.dyns = {}
            dyn_size = 2 * elf.sizeof_ptr
            num_dyns = self.p_filesz // dyn_size
            for i in range(num_dyns):
               d_tag = elf.get_pointer(self.p_vaddr + i * dyn_size)
               d_un = elf.get_pointer(self.p_vaddr + i * dyn_size + elf.sizeof_ptr)
               if d_tag == DT_NEEDED:
                  if d_tag not in self.dyns:
                     self.dyns[d_tag] = []
                  self.dyns[d_tag].append(d_un)
               elif d_tag == DT_NULL:
                  break
               elif d_tag == DT_STRTAB:
                  if elf.symbol_strtab != 0:
                     #print "Existing strtab: 0x%x" % elf.symbol_strtab
                     #print "DT_STRTAB: 0x%x" % d_un
                     pass
                  elf.symbol_strtab = d_un
               else:
                  if d_tag in self.dyns:
                     print "Unexpected duplicate of d_tag %d" % d_tag
                  self.dyns[d_tag] = d_un
      except:
         raise InvalidHeader("Invalid program header")

   def __del__(self):
      del self.raw

class ElfSymbol(object):

   def __init__(self, name, value, size, info, other, shndx):
      self.name = name
      self.value = value
      self.size = size
      self.info = info
      self.other = other
      self.shndx = shndx
      self.bind = (info >> 4) & 0xf
      self.type = info & 0xf

   def __del__(self):
      del self.name

class ElfBase(Loader):

   def __init__(self, elf_file):
      Loader.__init__(self, elf_file)

      self.pe_offset = 0
      self.shdrs = []
      self.phdrs = []
      self.symbols = []

      #need algorithm to propogate this attribute to callers when possible
      self.non_returning_funcs.append("abort")
      self.non_returning_funcs.append("err")
      self.non_returning_funcs.append("errx")
      self.non_returning_funcs.append("exit")
      self.non_returning_funcs.append("_exit")
      self.non_returning_funcs.append("__assert_fail")
      self.non_returning_funcs.append("pthread_exit")
      self.non_returning_funcs.append("verr")
      self.non_returning_funcs.append("verrx")

   def __del__(self):
      del self.shdrs[:]
      del self.shdrs
      del self.phdrs[:]
      del self.phdrs
      del self.symbols[:]
      del self.symbols
      Loader.__del__(self)

   # Perform common ELF validation tasks
   def is_valid(self):
      if self.raw[0:4] != '\x7fELF':
         return False

      if ord(self.raw[EI_VERSION]) != EV_CURRENT:
         return False

      if ord(self.raw[EI_CLASS]) != ELFCLASS32 and ord(self.raw[EI_CLASS]) != ELFCLASS64:
         return False

      if ord(self.raw[EI_DATA]) != ELFDATA2MSB and ord(self.raw[EI_DATA]) != ELFDATA2LSB:
         return False

      if ord(self.raw[EI_DATA]) == ELFDATA2MSB:
         self.set_endianness(BIG_ENDIAN)

      self.e_type = self.get_word(16)

      if self.e_type < ET_REL or self.e_type > ET_CORE:
         return False

      self.e_machine = self.get_word(18)

      if self.e_machine == EM_386:
         self.arch = capstone.CS_ARCH_X86
         self.mode = capstone.CS_MODE_32
         self.arch_name = 'x86-32'
      elif self.e_machine == EM_X86_64:
         self.arch = capstone.CS_ARCH_X86
         self.mode = capstone.CS_MODE_64
         self.arch_name = 'x86-64'
      elif self.e_machine == EM_ARM:
         self.arch = capstone.CS_ARCH_ARM
         self.mode = capstone.CS_MODE_ARM
         self.arch_name = 'ARM'
      elif self.e_machine == EM_AARCH64:
         self.arch = capstone.CS_ARCH_ARM64
         self.mode = capstone.CS_MODE_ARM
         self.arch_name = 'AARCH64'
      elif self.e_machine == EM_PPC:
         self.arch = capstone.CS_ARCH_PPC
         self.mode = capstone.CS_MODE_32
         self.arch_name = 'PPC'
      elif self.e_machine == EM_PPC64:
         self.arch = capstone.CS_ARCH_PPC
         self.mode = capstone.CS_MODE_64
         self.arch_name = 'PPC-64'
      elif self.e_machine == EM_SPARC:
         self.arch = capstone.CS_ARCH_SPARC
         self.mode = capstone.CS_MODE_32
         self.arch_name = 'SPARC'
      elif self.e_machine == EM_MIPS:
         self.arch = capstone.CS_ARCH_MIPS
         if self.sizeof_ptr == 4:
            self.mode = capstone.CS_MODE_MIPS32
            self.arch_name = 'MIPS32'
         elif self.sizeof_ptr == 8:
            self.mode = capstone.CS_MODE_MIPS64
            self.arch_name = 'MIPS64'
      else:
         # anything else, we don't recognize
         # could move this check into the caller
         # to allow it to determine whether it has an appropriate
         # disassembler
         return False

      if self.endian == BIG_ENDIAN:
         self.mode |= capstone.CS_MODE_BIG_ENDIAN

      self.e_version = self.get_dword(20)
      self.e_entry = self.get_pointer(24)
      self.e_phoff = self.get_pointer(24 + self.sizeof_ptr)
      self.e_shoff = self.get_pointer(24 + self.sizeof_ptr * 2)
      self.e_flags = self.get_dword(24 + self.sizeof_ptr * 3)
      fields_offset = 28 + self.sizeof_ptr * 3
      fields = []
      for i in range(6):
         # could do all this with struct.unpack, would need to ensure
         # we honor endian-ness in the format string that is used
         fields.append(self.get_word(fields_offset + i * 2))
      self.e_ehsize = fields[0]
      self.e_phentsize = fields[1]
      self.e_phnum = fields[2]
      self.e_shentsize = fields[3]
      self.e_shnum = fields[4]
      self.e_shstrndx = fields[5]

      self.symbol_strtab = 0

      # some sanity checks

      # check e_ehsize
      if self.e_ehsize != (40 + 3 * self.sizeof_ptr):
         return False

      if self.e_shstrndx >= self.e_shnum:
         return False

      # check e_shentsize
      if self.e_shentsize != (16 + 6 * self.sizeof_ptr):
         return False

      # check e_phentsize
      if self.e_phentsize != (8 + 6 * self.sizeof_ptr):
         return False

      # Check that there is room for the phdr table
      if self.e_phoff > (len(self.raw) - self.e_phentsize * self.e_phnum):
         return False

      # Check that there is room for the shdr table
      if self.e_shoff > (len(self.raw) - self.e_shentsize * self.e_shnum):
         return False

      # many other checks we could perform
      return True

   def resolve_sym(self, symidx, addr):
      if symidx < len(self.symbols):
         sym = self.symbols[symidx]
         #print "Resolving symbol: %s" % sym.name
         self.add_symbol(addr, sym.name)
         if sym.type == STT_FUNC:
            self.add_import(addr, sym.name)

   def parse_rel(self, addr, size):
      if self.sizeof_ptr == 4:
         mask = 0xff
         shift = 8
      else:
         mask = 0xffffffff
         shift = 32
      relsz = 2 * self.sizeof_ptr
      num_rels = size // relsz
      for i in range(num_rels):
         r_offset = self.get_pointer(addr + i * relsz)
         r_info = self.get_pointer(addr + i * relsz + self.sizeof_ptr)
         r_sym = r_info >> shift
         r_type = r_info & mask
         #print "REL r_offset 0x%x" % r_offset
         self.resolve_sym(r_sym, r_offset)

   def parse_rela(self, addr, size):
      if self.sizeof_ptr == 4:
         mask = 0xff
         shift = 8
      else:
         mask = 0xffffffff
         shift = 32
      relsz = 3 * self.sizeof_ptr
      num_rels = size // relsz
      for i in range(num_rels):
         r_offset = self.get_pointer(addr + i * relsz)
         r_info = self.get_pointer(addr + i * relsz + self.sizeof_ptr)
         r_addend = self.get_pointer(addr + i * relsz + 2 * self.sizeof_ptr)
         r_sym = r_info >> shift
         r_type = r_info & mask
         #print "RELA r_offset 0x%x" % r_offset
         self.resolve_sym(r_sym, r_offset)

   def parse_imports(self):
      if self.dyn_hdr is None:
         return
      jmprel = None
      pltgot = None
      if DT_JMPREL in self.dyn_hdr.dyns:
         jmprel = self.dyn_hdr.dyns[DT_JMPREL]
         pltrelsz = self.dyn_hdr.dyns[DT_PLTRELSZ]
         pltrel = self.dyn_hdr.dyns[DT_PLTREL]
      if DT_PLTGOT in self.dyn_hdr.dyns:
         pltgot = self.dyn_hdr.dyns[DT_PLTGOT]

      if jmprel is not None:
         if pltrel == DT_REL:
            self.parse_rel(jmprel, pltrelsz)
         elif pltrel == DT_RELA:
            self.parse_rela(jmprel, pltrelsz)
         else:
            print "UNEXPECTED PLTREL value: %d" % pltrel

   def parse_symbols(self):
      symsz = 8 + 2 * self.sizeof_ptr
      for s in self.shdrs:
         if s.sh_type == SHT_SYMTAB or s.sh_type == SHT_DYNSYM:
            num_syms = s.sh_size // symsz
            #print "Section %s has %d symbols" % (s.name, num_syms)
            for i in range(num_syms):
               sym = s.get_symbol(i * symsz)
               self.symbols.append(sym)
               #if sym.type == STT_FUNC:
                  #print "Function symbol %s at address 0x%x" % (name, st_value)

   def parse_exports(self):
      self.add_export(self.start, "_start")
      # add DT_INIT == init_proc and DT_FINI == term_proc
      if self.dyn_hdr is not None:
         if DT_INIT in self.dyn_hdr.dyns:
            self.add_export(self.dyn_hdr.dyns[DT_INIT], ".init_proc")
         if DT_FINI in self.dyn_hdr.dyns:
            self.add_export(self.dyn_hdr.dyns[DT_FINI], ".term_proc")
      for sym in self.symbols:
         if sym.type == STT_FUNC and sym.value != 0:
            self.add_export(sym.value, sym.name)
      #for addr,name in self.exports_by_addr.iteritems():
         #print "EXPORT: 0x%x - %s" % (addr, name)

   def load_phdrs(self):
      self.dyn_hdr = None
      for i in range(self.e_phnum):
         phdr = ElfProgramHeader(self, self.e_phoff + self.e_phentsize * i)
         self.phdrs.append(phdr)
         if phdr.p_type == PT_DYNAMIC:
            self.dyn_hdr = phdr
         if phdr.p_type == PT_LOAD:
            va = phdr.p_vaddr
            if self.image_base is None or va < self.image_base:
               self.image_base = va
            mr = self.raw[phdr.p_offset:phdr.p_offset+phdr.p_filesz].ljust(phdr.p_memsz, '\x00')
            self.add_mapped(va, va + phdr.p_memsz, phdr.perms, mr)

   def load_shdrs(self):
      self.sections_by_name.clear()

      for i in range(self.e_shnum):
         shdr = ElfSectionHeader(self, self.e_shoff + self.e_shentsize * i)
         self.shdrs.append(shdr)
         if shdr.sh_type == SHT_STRTAB and i != self.e_shstrndx and self.symbol_strtab != 0:
            self.symbol_strtab = shdr.sh_addr

      # now that we have sections, go back and pull section names
      # out of the sh names table
      strtab = self.shdrs[self.e_shstrndx]
      for s in self.shdrs:
         # defer setting the name until we are sure we know about the shstrtab
         s.name = strtab.get_string(s.sh_name)

         va = s.sh_addr
         # match perms against phdrs? sh_flags ??

         if (s.sh_flags & SHF_ALLOC) == 0:
            print 'Skipping section %s' % s.name
            continue
         self.add_section(s.name, va, va + s.sh_size, s.perms, s.sh_size)

   def load(self):
      if self.is_valid():
         del self.mapped[:]
         del self.sections[:]
         self.phdrs = []
         self.shdrs = []

         self.osabi = ord(self.raw[EI_OSABI])
         self.image_base = None   # set in load_phdrs
         self.start = self.e_entry

         self.load_phdrs()
         self.load_shdrs()

         # deal with dynamic section imports
         # deal with .got .plt
         # deal with exports
         # deal with symbol table
         # deal with dwarf and other debug info

         self.parse_symbols()
         self.parse_imports()
         self.parse_exports()
         return True
      return False

   def find_main(self, insts, to, frm):
      if self.arch != capstone.CS_ARCH_X86:
         return None
      addr = self.start
      if self.osabi != ELFOSABI_LINUX:
         #find main by scanning Linux start stup
         while addr in frm:
            inst = insts[addr]
            if inst.group(capstone.CS_GRP_JUMP):
               break
            xrefs = frm[addr]
            if inst.group(capstone.CS_GRP_CALL):
               for x in xrefs:
                  if x[1] == XR_CALL:
                     #call to libc_start_main
                     last = to[addr][0][0]
                     inst = insts[last]
                     main = inst.operands[-1].value.imm
                     return main
               break
            elif len(xrefs) == 1:
               if xrefs[0][1] == XR_FLOW:
                  addr = xrefs[0][0]
               else:
                  break
            else:
               break
      return None

class Elf32(ElfBase):

   def __init__(self, elf_file):
      ElfBase.__init__(self, elf_file)

   # override to perform file type validation checks such
   # as checking magic numbers, etc
   def is_valid(self):
#      try:
         if ord(self.raw[EI_CLASS]) != ELFCLASS32:
            return False
         self.set_pointer_size(4)
         if not ElfBase.is_valid(self):
            return False
         # now do Elf32 specific checks
         # following e_ident we have: self.endian + "HHIIIIIHHHHHH"
#      except Exception as e:
         #any exception means it's not a PE32
#         raise e
         return True

class Elf64(ElfBase):

   def __init__(self, elf_file):
      ElfBase.__init__(self, elf_file)

   # override to perform file type validation checks such
   # as checking magic numbers, etc
   def is_valid(self):
      try:
         if ord(self.raw[EI_CLASS]) != ELFCLASS64:
            return False
         self.set_pointer_size(8)
         if not ElfBase.is_valid(self):
            return False
         #now do Elf64 specific checks
         # following e_ident we have: self.endian + "HHIQQQIHHHHHH
      except Exception as e:
         #any exception means it's not a PE32
         raise e
#         return False
      return True

```

`fREedom.py`:

```py
#!/usr/bin/env python

'''
Stand-alone binnavi compatible disassembler based on capstone
'''

__author__ = "Chris Eagle"
__copyright__ = "Copyright 2015, Chris Eagle"
__credits__ = ["Chris Eagle"]
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Chris Eagle"
__email__ = "cseagle@gmail.com"
__status__ = "Use at your own risk"

import sys
import argparse
import capstone
import x86_disasm
import pe_loader
import elf_loader
import binnavi_db

class UnsupportedArch(Exception):
   def __init__(self, msg):
      Exception.__init__(self, msg)

class UnsupportedFormat(Exception):
   def __init__(self, msg):
      Exception.__init__(self,msg)

def main(args):

   # cycle through available loaders, if one matches
   # pass it into the disassembler
   ldr = pe_loader.Pe32(args.binary)
   if not ldr.load():
      del ldr
      ldr = pe_loader.Pe64(args.binary)
      if not ldr.load():
         del ldr
         ldr = elf_loader.Elf32(args.binary)
         if not ldr.load():
            del ldr
            ldr = elf_loader.Elf64(args.binary)
            if not ldr.load():
               del ldr
               raise UnsupportedFormat("Unsupported file format for %s" % args.binary)

   if ldr.arch == capstone.CS_ARCH_X86:
      dis = x86_disasm.x86_disasm(ldr)   
   else:
      raise UnsupportedArch("Unsupported processor architecture for %s" % args.binary)
   
   dis.generate_data()

   print "found %d instructions" % len(dis.visited)
   print "found %d basic blocks" % len(dis.basic_blocks)
   print "found %d functions" % len(dis.call_targets)

   '''
   print "Functions identified at:"
   dis.call_targets.sort()
   for c in dis.call_targets:
      print "   0x%x" % c
   '''

   #dis.print_disassembly()

   db = binnavi_db.binnavi_db(args.database, args.user, args.passwd, args.dbhost)
   db.export(dis)

# add argument parsing for database commection parameters
if __name__ == "__main__":
   parser = argparse.ArgumentParser(description='Export to binnavi.')
   parser.add_argument('--database', help='name of database to export to')
   parser.add_argument('--user', help='database user name')
   parser.add_argument('--pass', dest='passwd', help='database user password')
   parser.add_argument('--dbhost', help='database host name')
   parser.add_argument('--binary', type=str, required=False, help='binary file to export')
   parser.add_argument('--delete', action='store_true', required=False,
                       help='flag to initiate module deletion')
   parser.add_argument('--modules', type=int, nargs='+', required=False,
                      help='module numbers to delete')

   args = parser.parse_args()

   if args.delete:
      db = binnavi_db.binnavi_db(args.database, args.user, args.passwd, args.dbhost)
      for m in args.modules:
         db.delete_module(m)
   else:
      main(args)

```

`loader.py`:

```py
#!/usr/bin/env python

'''
Base class for loaders (file parsers) for a stand-alone binnavi compatible disassembler
'''

__author__ = "Chris Eagle"
__copyright__ = "Copyright 2015, Chris Eagle"
__credits__ = ["Chris Eagle"]
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Chris Eagle"
__email__ = "cseagle@gmail.com"
__status__ = "Use at your own risk"

import sys
import struct
import hashlib
import os

LITTLE_ENDIAN = '<'
BIG_ENDIAN    = '>'

PROT_READ =  1
PROT_WRITE = 2
PROT_EXEC =  4
PROT_ALL  = PROT_READ | PROT_WRITE | PROT_EXEC

class MappedRegion(object):
   def __init__(self, start, end, perms, raw):
      self.start = start
      self.end = end
      self.perms = perms
      self.raw = raw

   def contains(self, addr, blen = 1):
      _end = addr + blen
      return addr >= self.start and addr < self.end and _end <= self.end
      
   def get_bytes(self, addr, blen = 1):
      if self.contains(addr, blen):
         offset = addr - self.start
         return self.raw[offset:offset+blen]
      return None

class Section(object):
   def __init__(self, name, start, end, perms, filesz):
      self.name = name
      self.start = start
      self.end = end
      self.perms = perms
      self.filesz = filesz
      
      print "Created section %s, 0x%x:0x%x, raw length 0x%x, perms %d" % (self.name, self.start, self.end, filesz, self.perms)

   def contains(self, addr):
      return addr >= self.start and addr < self.end

   def get_raw_bytes(self, ldr):
      raw = ldr.get_bytes(self.start, self.filesz)
      if raw is None:
         sys.stderr.write("Failed to get raw content for section %s at address 0x%x for size 0x%s\n" % (self.name, self.start, self.filesz))
      return ldr.get_bytes(self.start, self.filesz)

class Loader(object):

   def __init__(self, fname):
      self.exe = fname
      f = open(fname, 'rb')
      self.raw = f.read()
      self.md5 = hashlib.md5(self.raw).hexdigest()
      self.sha1 = hashlib.sha1(self.raw).hexdigest()
      f.close()

      self.name = os.path.basename(fname)

      self.image_base = 0
      self.start = 0

      self.sections = []           # Section
      self.sections_by_name = {}   # str:Section
      self.imports_by_name = {}    # str:int
      self.imports_by_addr = {}    # int:str
      self.exports_by_addr = {}    # int:str

      self.symbols_by_addr = {}    # int:str
      self.symbols_by_name = {}    # str:int
      self.mapped = []             # MappedRegion

      self.non_returning_funcs = []

      self.add_mapped(0, len(self.raw), PROT_ALL, self.raw)

      self.set_endianness(LITTLE_ENDIAN)
      self.sizeof_ptr = 4
      self.arch = None
      self.mode = None
      self.cached_section = None
      self.cached_region = None

   def __del__(self):
      del self.mapped[:]
      del self.sections[:]
      del self.sections
      del self.raw
      del self.name
      self.sections_by_name.clear()
      self.imports_by_name.clear()
      self.imports_by_addr.clear()
      self.exports_by_addr.clear()
      self.symbols_by_name.clear()
      self.symbols_by_addr.clear()

   def set_endianness(self, which_endian):
      self.endian = which_endian

   def set_pointer_size(self, sizeof_ptr):
      self.sizeof_ptr = sizeof_ptr

   # override to create a mapped process binary image where
   # raw does not match the memory layout of the running
   # process.
   def load(self):
      # probably want to start with:
      # del sections[:]
      # sections_by_name.clear()
      pass

   def get_mapped(self, addr):
      if self.cached_region is not None and self.cached_region.contains(addr):
         return self.cached_region
      for m in self.mapped:
         if m.contains(addr):
            self.cached_region = m
            return m
      return None

   #regions should not overlap!
   def add_mapped(self, start, end, perms, raw):
      self.mapped.append(MappedRegion(start, end, perms, raw))

   def del_mapped(self, start):
      rem = None
      for m in self.mapped:
         if m.start == addr:
            if self.cached_region == m:
               self.cached_region = None
            rem = m
            break
      if rem is not None:
         self.mapped.remove(rem)
         del rem

   # override to perform file type validation checks such
   # as checking magic numbers, etc
   def is_valid(self):
      return True

   def get_bytes(self, addr, len):
      m = self.get_mapped(addr)
      if m is not None:
         return m.get_bytes(addr, len)
      return None

   def get_byte(self, addr):
      return self.get_bytes(addr, 1)

   def get_word(self, addr):
      return struct.unpack(self.endian + "H", self.get_bytes(addr, 2))[0]

   def get_dword(self, addr):
      try:
	 return struct.unpack(self.endian + "I", self.get_bytes(addr, 4))[0]
      except Exception, e:
         print "Unable to read dword from address 0x%x" % addr
         raise e

   def get_qword(self, addr):
      return struct.unpack(self.endian + "Q", self.get_bytes(addr, 8))[0]

   def get_pointer(self, addr):
      if self.sizeof_ptr == 4:
         return self.get_dword(addr)
      elif self.sizeof_ptr == 8:
         return self.get_qword(addr)

   def get_string(self, addr):
      res = ''
      while True:
         ch = self.get_byte(addr)
         if ch == '\x00':
            break
         addr += 1
         res += ch
      return res

   # get containing section for given address
   def get_section(self, addr):
      if self.cached_section is not None and self.cached_section.contains(addr):
         return self.cached_section
      for s in self.sections:
         if s.contains(addr):
            self.cached_section = s
            return s
      return None

   def add_section(self, name, start, end, perms, filesz):
      sect = Section(name, start, end, perms, filesz)
      self.sections.append(sect)
      self.sections_by_name[name] = sect

   def add_import(self, addr, name):
      self.imports_by_addr[addr] = name
      self.imports_by_name[name] = addr

   def add_symbol(self, addr, name):
      self.symbols_by_addr[addr] = name
      self.symbols_by_name[name] = addr

   def add_export(self, addr, name):
      self.exports_by_addr[addr] = name
      
   #override in subclasses if you have an algorithm
   #for finding main given the address of start
   #and all currently known instructions
   def find_main(self, insts, to, frm):
      return None


```

`pe_loader.py`:

```py
#!/usr/bin/env python

'''
Crude PE32 / PE32+ loader, conforming to the Loader interface, for a stand-alone binnavi compatible disassembler
'''

__author__ = "Chris Eagle"
__copyright__ = "Copyright 2015, Chris Eagle"
__credits__ = ["Chris Eagle"]
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Chris Eagle"
__email__ = "cseagle@gmail.com"
__status__ = "Use at your own risk"

import sys
import struct
import hashlib
import binascii
import capstone
from loader import *

IMAGE_FILE_MACHINE_I386 = 0x14c
IMAGE_FILE_MACHINE_ARM = 0x1c0
IMAGE_FILE_MACHINE_THUMB = 0x1c2
IMAGE_FILE_MACHINE_ARMV7 = 0x1c4
IMAGE_FILE_MACHINE_AMD64 = 0x8664

OK_PE_MACHINES = [IMAGE_FILE_MACHINE_I386, IMAGE_FILE_MACHINE_ARM,
                  IMAGE_FILE_MACHINE_THUMB, IMAGE_FILE_MACHINE_ARMV7,
                  IMAGE_FILE_MACHINE_AMD64]

IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10b
IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x20b

IMAGE_DOS_SIGNATURE = 0x5A4D
IMAGE_NT_SIGNATURE = 0x00004550

IMAGE_SCN_MEM_EXECUTE = 0x20000000
IMAGE_SCN_MEM_READ = 0x40000000
IMAGE_SCN_MEM_WRITE = 0x80000000

DATA_DIRECTORY_EXPORT = 0
DATA_DIRECTORY_IMPORT = 1

class InvalidHeader(Exception):
   def __init__(self, msg):
      Exception.__init__(self, msg)

class FileHeader(object):

   def __init__(self, raw, offset):
      self.raw = raw[offset:offset+20]
      fields = struct.unpack("<HHIIIHH", self.raw)
      self.Machine = fields[0]
      self.NumberOfSections = fields[1]
      self.TimeDateStamp = fields[2]
      self.PointerToSymbolTable = fields[3]
      self.NumberOfSynbols = fields[4]
      self.SizeOfOptionalHeader = fields[5]
      self.Characteristics = fields[6]

   def __del__(self):
      del self.raw

   def sizeof(self):
      return len(self.raw)

class ImportDirectory(object):

   # enough loading has taken place by the time that we get here
   # that we need to start dealing with RVA
   def __init__(self, pe, va):
      self.raw = pe.get_bytes(va, 20)
      fields = struct.unpack("<IIIII", self.raw)
      self.ilt = fields[0]
      self.time_date = fields[1]
      self.forwarder = fields[2]
      self.name_rva = fields[3]
      self.iat = fields[4]
      self.pe = pe

   def __del__(self):
      del self.raw

   def parse(self):
      self.dll = self.pe.get_string(self.name_rva + self.pe.image_base)
      if self.ilt != 0:
         iat = self.ilt
      else:
         iat = self.iat
      mask = 0x80 << (self.pe.sizeof_ptr * 8 - 8)
      while True:
         addr = iat + self.pe.image_base
         iat += self.pe.sizeof_ptr
         ie = self.pe.get_pointer(addr)
         if ie == 0:
            break
         if ie & mask:
            # it's an ordinal
            func = "%s_%d" % (self.dll.replace('.', '_'), ie & 0xffff)
         else:
            # it's a name rva
            func = self.pe.get_string(ie + 2 + self.pe.image_base)
         self.pe.add_import(addr, func)

   def is_null_dir(self):
      return self.raw == ('\x00'*20)

class ExportDirectory(object):

   # enough loading has taken place by the time that we get here
   # that we need to start dealing with RVA
   def __init__(self, pe, va, size):
      self.raw = pe.get_bytes(va, 40)
      self.rva = va - pe.image_base
      self.end_rva = self.rva + size
      fields = struct.unpack("<7I", self.raw[12:])
      self.NameRva = fields[0]
      self.OrdinalBase = fields[1]
      self.NumberOfFunctions = fields[2]
      self.NumberOfNames = fields[3]
      self.AddressOfFunctions = fields[4]
      self.AddressOfNames = fields[5]
      self.AddressOfNameOrdinals = fields[6]
      self.pe = pe

   def __del__(self):
      del self.raw

   def parse(self):
      self.dll = self.pe.get_string(self.NameRva + self.pe.image_base)
      aof = self.AddressOfFunctions + self.pe.image_base
      aon = self.AddressOfNames + self.pe.image_base
      aono = self.AddressOfNameOrdinals + self.pe.image_base
      fcount = 0
      for f in range(self.NumberOfNames):
         name_rva = self.pe.get_dword(aon)
         aon += 4
         name = self.pe.get_string(name_rva + self.pe.image_base)
         func_idx = self.pe.get_word(aono + f * 2)
         func_rva = self.pe.get_dword(aof + func_idx * 4)
         if func_rva >= self.rva and func_rva < self.end_rva:
            #this is a forwarded entry
            fcount += 1
            continue
         else:
            self.pe.add_export(func_rva + self.pe.image_base, name)

      for f in range(self.NumberOfNames, self.NumberOfFunctions):
         name = "%s_%d" % (self.dll.replace('.', '_'), f)
         func_idx = self.pe.get_word(aono + f * 2)
         func_rva = self.pe.get_dword(aof + func_idx * 4)
         self.pe.add_export(func_rva + self.pe.image_base, name)

class OptionalHeaderBase(object):

   def __init__(self, raw, offset):
      try:
         self.common = raw[offset:offset+24]
         fields = struct.unpack("<HBBIIIII", self.common)
         self.Magic = fields[0]
         self.SizeOfCode = fields[3]
         self.SizeOfInitializedData = fields[4]
         self.SizeOfUninitializedData = fields[5]
         self.AddressOfEntryPoint = fields[6]
         self.BaseOfCode = fields[7]
         if self.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC:
            bod = raw[offset+24:offset+28]
            self.common += bod
            self.BaseOfData = struct.unpack("<I", bod)[0]
         self.DataDirectories = None
         self.ImageBase = 0
      except Exception as e:
         print e.message
         raise InvalidHeader("Invalid PE header")

   def __del__(self):
      del self.common

   # return va (not rva),size
   def get_directory(self, n):
      rva,size = struct.unpack("<II", self.DataDirectories[n * 8:8 + n * 8])
      if size == 0:
         return None, None
      return self.ImageBase + rva, size

class OptionalHeader32(OptionalHeaderBase):

   def __init__(self, raw, offset):
      OptionalHeaderBase.__init__(self, raw, offset)
      try:
         self.fields = raw[offset+28:offset+96]
         tmp = struct.unpack("<III", self.fields[0:12])
         self.ImageBase = tmp[0]
         self.SectionAlignment = tmp[1]
         self.FileAlignment = tmp[2]

         self.NumberOfRvaAndSizes = struct.unpack("<I", self.fields[-4:])[0]

         self.DataDirectories = raw[offset+96:offset+96+self.NumberOfRvaAndSizes*8]
      except Exception as e:
         print e.message
         raise InvalidHeader("Invalid PE32 header")

   def __del__(self):
      del self.fields
      del self.DataDirectories
      OptionalHeaderBase.__del__(self)

class OptionalHeader64(OptionalHeaderBase):

   def __init__(self, raw, offset):
      OptionalHeaderBase.__init__(self, raw, offset)
      try:
         self.fields = raw[offset+24:offset+112]

         tmp = struct.unpack("<QII", self.fields[0:16])
         self.ImageBase = tmp[0]
         self.SectionAlignment = tmp[1]
         self.FileAlignment = tmp[2]

         self.NumberOfRvaAndSizes = struct.unpack("<I", self.fields[-4:])[0]

         self.DataDirectories = raw[offset+112:offset+112+self.NumberOfRvaAndSizes*8]
      except Exception as e:
         raise InvalidHeader("Invalid PE64 header")

   def __del__(self):
      del self.fields
      del self.DataDirectories
      OptionalHeaderBase.__del__(self)

class SectionHeader(object):

   def __init__(self, raw, offset):
#      try:
         self.raw = raw[offset:offset+40]
         fields = struct.unpack("<8sIIIIIIHHI", self.raw)
         self.Name = fields[0].rstrip('\x00')
         self.VirtualSize = fields[1]
         self.VirtualAddress = fields[2]
         self.SizeOfRawData = fields[3]
         self.PointerToRawData = fields[4]
         self.PointerToRelocations = fields[5]
         self.PointerToLinenumbers = fields[6]
         self.NumberOfRelocations = fields[7]
         self.NumberOfLinenumbers = fields[8]
         self.Characteristics = fields[9]
         self.perms = 0
         if self.Characteristics & IMAGE_SCN_MEM_READ:
            self.perms |= PROT_READ
         if self.Characteristics & IMAGE_SCN_MEM_WRITE:
            self.perms |= PROT_WRITE
         if self.Characteristics & IMAGE_SCN_MEM_EXECUTE:
            self.perms |= PROT_EXEC
#      except:
#         raise InvalidHeader("Invalid section header")

   def __del__(self):
      del self.raw

class PeBase(Loader):

   def __init__(self, pe_file):
      Loader.__init__(self, pe_file)

      self.pe_offset = 0
      self.section_headers = []
      
      self.non_returning_funcs.append("ExitProcess")
      self.non_returning_funcs.append("ExitThread")
      self.non_returning_funcs.append("_ExitProcess")
      self.non_returning_funcs.append("_ExitThread")

   def __del__(self):
      del self.section_headers[:]
      del self.section_headers
      Loader.__del__(self)

   # Perform common PE validation tasks
   def is_valid(self):
      if self.raw[0:2] != 'MZ':
         return False
      # image sections are still in .raw mode at this point
      self.pe_offset = self.get_dword(0x3c)
      if self.get_dword(self.pe_offset) != IMAGE_NT_SIGNATURE:
         return False
      self.FileHeader = FileHeader(self.raw, self.pe_offset + 4)

      if self.FileHeader.Machine == IMAGE_FILE_MACHINE_I386:
         self.arch = capstone.CS_ARCH_X86
         self.mode = capstone.CS_MODE_32
         self.arch_name = 'x86-32'
      elif self.FileHeader.Machine == IMAGE_FILE_MACHINE_ARM or self.FileHeader.Machine == IMAGE_FILE_MACHINE_THUMB:
         self.arch = capstone.CS_ARCH_ARM
         self.mode = capstone.CS_MODE_ARM
         self.arch_name = 'ARM-32'
      elif self.FileHeader.Machine == IMAGE_FILE_MACHINE_ARMV7:
         self.arch = capstone.CS_ARCH_ARM
         self.mode = capstone.CS_MODE_THUMB
         self.arch_name = 'ARM-THUMB'
      elif self.FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64:
         self.arch = capstone.CS_ARCH_X86
         self.mode = capstone.CS_MODE_64
         self.arch_name = 'x86-64'
      else:
         # anything else, we don't recognize
         # could move this check into the caller
         # to allow it to determine whether it has an appropriate 
         # disassembler
         return False

      oh_magic = self.get_word(self.pe_offset + 24)
      if oh_magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC and oh_magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC:
         return False
      #many other checks we could perform
      return True

   def load_sections(self):
      del self.mapped[:]
      del self.sections[:]
      self.sections_by_name.clear()
      for i in range(self.FileHeader.NumberOfSections):
         self.section_headers.append(SectionHeader(self.raw, self.pe_offset + 24 + self.FileHeader.SizeOfOptionalHeader + i * 40))
      for s in self.section_headers:
         va = self.OptionalHeader.ImageBase + s.VirtualAddress
         mr = self.raw[s.PointerToRawData:s.PointerToRawData+s.SizeOfRawData].ljust(s.VirtualSize, '\x00')
         self.add_mapped(va, va + max(s.VirtualSize, s.SizeOfRawData), s.perms, mr)
         self.add_section(s.Name, va, va + s.VirtualSize, s.perms, s.SizeOfRawData)

   def parse_imports(self):
      va,size = self.OptionalHeader.get_directory(DATA_DIRECTORY_IMPORT)
      if size is not None:
         while True:
            id = ImportDirectory(self, va)
            if id.is_null_dir():
               break
            id.parse()
            va += 20

   def parse_symbols(self):
      pass

   def parse_exports(self):
      self.add_export(self.start, "_start")
      va,size = self.OptionalHeader.get_directory(DATA_DIRECTORY_EXPORT)
      if size is not None:
         exp = ExportDirectory(self, va, size)
         exp.parse()

   def load(self):
      if self.is_valid():
         self.image_base = self.OptionalHeader.ImageBase
         self.start = self.OptionalHeader.AddressOfEntryPoint + self.image_base
         self.load_sections()
         self.parse_imports()
         self.parse_exports()
         return True
      return False

class Pe32(PeBase):

   def __init__(self, pe_file):
      PeBase.__init__(self, pe_file)

   # override to perform file type validation checks such
   # as checking magic numbers, etc
   def is_valid(self):
      try:
         if not PeBase.is_valid(self):
            return False
         #now do PE32 specific checks
         self.OptionalHeader = OptionalHeader32(self.raw, self.pe_offset + 24)
         if self.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC:
            return False
         self.set_pointer_size(4)
      except Exception as e:
         #any exception means it's not a PE32
         raise e
#         return False
      return True

class Pe64(PeBase):

   def __init__(self, pe_file):
      PeBase.__init__(self, pe_file)

   # override to perform file type validation checks such
   # as checking magic numbers, etc
   def is_valid(self):
      try:
         if not PeBase.is_valid(self):
            return False
         #now do PE64 specific checks
         self.OptionalHeader = OptionalHeader64(self.raw, self.pe_offset + 24)
         if self.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC:
            return False
         self.set_pointer_size(8)
      except Exception as e:
         #any exception means it's not a PE32
         raise e
#         return False
      return True

```

`postgresql_tables.sql`:

```sql
-- Setup a binnavi compatible database

SET check_function_bodies = false;
SET default_tablespace = '';
SET default_with_oids = false;

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;
-- COMMENT ON EXTENSION plpgsql
--   IS 'PL/pgSQL procedural language';

--
-- Types section
--

--
-- address_reference_type
--

DROP TYPE IF EXISTS address_reference_type CASCADE;
CREATE TYPE address_reference_type AS ENUM (
    'conditional_true',
    'conditional_false',
    'unconditional',
    'switch',
    'call_direct',
    'call_indirect',
    'call_virtual',
    'data',
    'data_string'
);
COMMENT ON TYPE address_reference_type
  IS 'The address_reference_type defines all possible address reference types.';

--
-- architecture_type
--

DROP TYPE IF EXISTS architecture_type CASCADE;
CREATE TYPE architecture_type AS ENUM (
    'x86-32',
    'x86-64',
    'ARM-32',
    'PowerPC-32',
    'PowerPC-64',
    'MIPS-32',
    'MIPS-64',
    'GENERIC-32',
    'GENERIC-64',
    'REIL',
    'RREIL'
);
COMMENT ON TYPE architecture_type
  IS 'The architecture_type defines all architectures known to BinNavi.
  Unknown architectures used the generic type.';

--
-- edge_type
--

DROP TYPE IF EXISTS edge_type CASCADE;
CREATE TYPE edge_type AS ENUM (
    'jump_conditional_true',
    'jump_conditional_false',
    'jump_unconditional',
    'jump_switch',
    'jump_conditional_true_loop',
    'jump_conditional_false_loop',
    'jump_unconditional_loop',
    'enter_inlined_function',
    'leave_inlined_function',
    'inter_module',
    'inter_addressspace_edge',
    'textnode_edge',
    'dummy'
);
COMMENT ON TYPE edge_type
  IS 'The edge_type defines all possible types of an edge.
  This type is used in BinNavi to enable specific functions for an edge.';

--
-- function_type
--

DROP TYPE IF EXISTS function_type CASCADE;
CREATE TYPE function_type AS ENUM (
    'normal',
    'library',
    'import',
    'thunk',
    'adjustor_thunk',
    'invalid'
);
COMMENT ON TYPE function_type
  IS 'The function_type defines all possible function types.
  This type is used in BinNavi to enable specific functions for a function.';

--
-- node_type
--

DROP TYPE IF EXISTS node_type CASCADE;
CREATE TYPE node_type AS ENUM (
    'code',
    'function',
    'group',
    'text'
);
COMMENT ON TYPE node_type
  IS 'The node_type defines all possible node type.
  The type is used in BinNavi to enable specific functions for a node.';

--
-- permission type
--

DROP TYPE IF EXISTS permission_type CASCADE;
CREATE TYPE permission_type AS ENUM (
  'READ',
  'WRITE',
  'EXECUTE',
  'READ_WRITE',
  'READ_EXECUTE',
  'READ_WRITE_EXECUTE',
  'WRITE_EXECUTE'
);
COMMENT ON TYPE permission_type
  IS 'The permission_type is used to describe the permission a section has.
  This information can either come from the exporter or from the debugger.';

--
-- tag_type
--

DROP TYPE IF EXISTS tag_type CASCADE;
CREATE TYPE tag_type AS ENUM (
    'view_tag',
    'node_tag'
);
COMMENT ON TYPE tag_type
  IS 'The tag_type defines to which taggable instance the tags belongs.
  A tag can either be a view tag or a node tag.';

--
-- view_type
--

DROP TYPE IF EXISTS view_type CASCADE;
CREATE TYPE view_type AS ENUM (
    'native',
    'non-native'
);
COMMENT ON TYPE view_type
  IS 'The view_type defines where a view comes from.
  Native views come from the export / disassembler.
  Non-native views have been generated in BinNavi.
  Native views are immutable.';

--
-- type_cagetory
--

DROP TYPE IF EXISTS type_category CASCADE;
CREATE TYPE type_category AS ENUM (
  'atomic',
  'array',
  'pointer',
  'struct',
  'union',
  'function_pointer'
);
COMMENT ON TYPE type_category
  IS 'The type_category enum specifies the category of a given base type as defined in a C type system.';

--
-- Begin trigger section.
--

--
-- bn_sections_trigger()
--

CREATE OR REPLACE FUNCTION bn_sections_trigger()
  RETURNS trigger AS
$$
BEGIN
  IF ( TG_OP = 'INSERT' ) THEN
    PERFORM pg_notify('section_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.id );
    RETURN NEW;
  ELSIF ( TG_OP = 'UPDATE' ) THEN
    PERFORM pg_notify('section_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.id );
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('section_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.module_id || ' ' || OLD.id );
    RETURN OLD;
  END IF;
END;
$$ LANGUAGE plpgsql VOLATILE
  COST 100;
COMMENT ON FUNCTION bn_sections_trigger()
  IS 'The bn_sections_trigger is called for all altering operations on the bn_sections table and will perform a pg_notify with the altered information.
  This information will be used in BinNavi to provide synchronisation between multiple instances of BinNavi';

--
-- bn_types_trigger()
--

CREATE OR REPLACE FUNCTION bn_types_trigger()
  RETURNS trigger AS
$$
BEGIN
  IF ( TG_OP = 'INSERT' ) THEN
    PERFORM pg_notify('types_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.id );
    RETURN NEW;
  ELSIF ( TG_OP = 'UPDATE' ) THEN
    PERFORM pg_notify('types_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.id );
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('types_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.module_id || ' ' || OLD.id );
    RETURN OLD;
  END IF;
END;
$$
  LANGUAGE plpgsql VOLATILE COST 100;
COMMENT ON FUNCTION bn_types_trigger() IS 'The bn_types_trigger is called for all altering operations on the bn_types table and will perform a pg_notify with the altered information.
  This information will be used in BinNavi to provide synchronisation between multiple instances of BinNavi';

--
-- bn_base_types_trigger()
--

CREATE OR REPLACE FUNCTION bn_base_types_trigger()
  RETURNS trigger AS
$$
BEGIN
  IF ( TG_OP = 'INSERT' ) THEN
    PERFORM pg_notify('types_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.id );
    RETURN NEW;
  ELSIF ( TG_OP = 'UPDATE' ) THEN
    PERFORM pg_notify('types_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.id );
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('types_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.module_id || ' ' || OLD.id );
    RETURN OLD;
  END IF;
END;
$$
  LANGUAGE plpgsql VOLATILE COST 100;
COMMENT ON FUNCTION bn_base_types_trigger() IS 'The bn_base_types_trigger is called for all altering operations on the bn_base_types table and will perform a pg_notify with the altered information.
  This information will be used in BinNavi to provide synchronisation between multiple instances of BinNavi';

--
-- bn_type_instances_trigger()
--

CREATE OR REPLACE FUNCTION bn_type_instances_trigger()
  RETURNS trigger AS
$BODY$
BEGIN
  IF ( TG_OP = 'INSERT' ) THEN
    PERFORM pg_notify('type_instances_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.id );
    RETURN NEW;
  ELSIF ( TG_OP = 'UPDATE' ) THEN
    PERFORM pg_notify('type_instances_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.id );
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('type_instances_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.module_id || ' ' || OLD.id );
    RETURN OLD;
  END IF;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE COST 100;
COMMENT ON FUNCTION bn_type_instances_trigger() IS 'The bn_expression_type_instances_trigger is called for all altering operations on the bn_expression_type_instances table and will perform a pg_notify with the altered information.
  This information will be used in BinNavi to provide synchronisation between multiple instances of BinNavi.';

--
-- bn_type_instances_comment_trigger()
--

CREATE OR REPLACE FUNCTION bn_type_instances_comment_trigger()
  RETURNS trigger AS
$$
DECLARE
  comment text;
BEGIN
  IF ( TG_OP = 'UPDATE') THEN
    IF ( NEW.comment_id is null) THEN
      comment = 'null';
    ELSE
      comment = CAST(NEW.comment_id AS TEXT);
    END IF;
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.id || ' ' || comment );
    RETURN NEW;
  END IF;
END;
$$
  LANGUAGE plpgsql VOLATILE COST 100;
COMMENT ON FUNCTION bn_type_instances_comment_trigger() IS 'The bn_type_instances_comment_trigger is called for UPDATE operations on the bn_type_instances table an will perform a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of comments associated to type instances between multiple instances of BinNavi.';

--
-- bn_expression_types_trigger()
--

CREATE OR REPLACE FUNCTION bn_expression_types_trigger()
  RETURNS trigger AS
$$
BEGIN
  IF ( TG_OP = 'INSERT' ) THEN
    PERFORM pg_notify('types_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.address || ' ' || NEW."position" || ' ' || NEW.expression_id);
    RETURN NEW;
  ELSIF ( TG_OP = 'UPDATE' ) THEN
    PERFORM pg_notify('types_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.address || ' ' || NEW."position" || ' ' || NEW.expression_id);
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('types_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.module_id || ' ' || OLD.address || ' ' || OLD."position" || ' ' || OLD.expression_id);
    RETURN OLD;
  END IF;
END;
$$
  LANGUAGE plpgsql VOLATILE COST 100;
COMMENT ON FUNCTION bn_expression_types_trigger() IS 'The bn_expression_types_trigger is called for all altering operations on the bn_expression_types table and will perform a pg_notify with the altered information.
  This information will be used in BinNavi to provide synchronization between multiple instances of BinNavi';

--
-- bn_ecpression_type_instances_trigger()
--

CREATE OR REPLACE FUNCTION bn_expression_type_instances_trigger()
  RETURNS trigger AS
$BODY$
BEGIN
  IF ( TG_OP = 'INSERT' ) THEN
    PERFORM pg_notify('type_instances_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.address || ' ' || NEW."position" || ' ' || NEW.expression_id || ' ' || NEW.type_instance_id);
    RETURN NEW;
  ELSIF ( TG_OP = 'UPDATE' ) THEN
    PERFORM pg_notify('type_instances_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.address || ' ' || NEW."position" || ' ' || NEW.expression_id || ' ' || NEW.type_instance_id);
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('type_instances_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.module_id || ' ' || OLD.address || ' ' || OLD."position" || ' ' || OLD.expression_id || ' ' || OLD.type_instance_id);
    RETURN OLD;
  END IF;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE COST 100;
COMMENT ON FUNCTION bn_expression_type_instances_trigger() IS 'The bn_expression_type_instances_trigger is called for all operations on the bn_expression_type_instances table an will perform a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronization of type instances associated to type instances between multiple instances of BinNavi.';

--
-- bn_functions_trigger()
--

CREATE OR REPLACE FUNCTION bn_functions_trigger()
  RETURNS trigger AS
$$
BEGIN
  IF ( TG_OP = 'INSERT' ) THEN
    PERFORM pg_notify('function_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.address );
    RETURN NEW;
  ELSIF ( TG_OP = 'UPDATE' ) THEN
    PERFORM pg_notify('function_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.address );
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('function_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.module_id || ' ' || OLD.address );
    RETURN OLD;
  END IF;
END;
$$
  LANGUAGE plpgsql VOLATILE
  COST 100;
COMMENT ON FUNCTION bn_functions_trigger()
  IS 'The bn_functions_trigger is called for all altering operations on the bn_functions table and will perform a pg_notify with the altered information.
  This information will be used in BinNavi to provide synchronisation between multiple instances of BinNavi';

--
-- bn_module_views_trigger()
--

CREATE OR REPLACE FUNCTION bn_module_views_trigger()
  RETURNS trigger AS
$$
BEGIN
  IF ( TG_OP = 'INSERT' ) THEN
    PERFORM pg_notify('view_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.view_id || ' ' || NEW.module_id );
    RETURN NEW;
  ELSIF ( TG_OP = 'UPDATE' ) THEN
    PERFORM pg_notify('view_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.view_id || ' ' || NEW.module_id );
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('view_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.view_id || ' ' || OLD.module_id );
    RETURN OLD;
  END IF;
END;
$$
  LANGUAGE plpgsql VOLATILE
  COST 100;
COMMENT ON FUNCTION bn_module_views_trigger()
  IS 'The bn_module_views_trigger is called for all altering operations on the bn_module_views table and will perform a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of module views between multiple instances of BinNavi.';

--
-- bn_project_views_trigger()
--

CREATE OR REPLACE FUNCTION bn_project_views_trigger()
  RETURNS trigger AS
$$
BEGIN
  IF ( TG_OP = 'INSERT' ) THEN
    PERFORM pg_notify('view_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.view_id || ' ' || NEW.project_id );
    RETURN NEW;
  ELSIF ( TG_OP = 'UPDATE' ) THEN
    PERFORM pg_notify('view_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.view_id || ' ' || NEW.project_id );
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('view_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.view_id || ' ' || OLD.project_id );
    RETURN OLD;
  END IF;
END;
$$
  LANGUAGE plpgsql VOLATILE
  COST 100;
COMMENT ON FUNCTION bn_project_views_trigger()
  IS 'The bn_project_views_trigger is called for all altering operations on the bn_project_views table and will perform a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of project views between multiple instances of BinNavi.';

--
-- bn_views_trigger()
--

CREATE OR REPLACE FUNCTION bn_views_trigger()
  RETURNS trigger AS
$$
 BEGIN
  IF ( TG_OP = 'UPDATE' ) THEN
    PERFORM pg_notify('view_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.id );
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('view_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.id );
    RETURN OLD;
  END IF;
 END;
 $$
  LANGUAGE plpgsql VOLATILE
  COST 100;
COMMENT ON FUNCTION bn_views_trigger()
  IS 'The bn_views_trigger is called for UPDATE and DELETE operations on the bn_views table and will perform a pg_notify with the altered information.
  This infromation is used in BinNavi to provide synchronisation of views between multiple instances of BinNavi.';

--
-- bn_comments_trigger()
--

CREATE OR REPLACE FUNCTION bn_comments_trigger()
  RETURNS trigger
  LANGUAGE plpgsql
  AS
$$
DECLARE
  comment text;
  parentid text;
BEGIN
  IF ( TG_OP = 'UPDATE') THEN
    IF ( NEW.comment_text IS NULL) THEN
      comment = 'null';
    ELSE
      comment = CAST(NEW.comment_text AS TEXT);
    END IF;
    IF( NEW.parent_id IS NULL) THEN
      parentid = 'null';
    ELSE
      parentid = CAST(NEW.parent_id AS TEXT);
    END IF;
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.id || ' ' || parentid || ' ' || NEW.user_id || ' ' || comment );
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    IF ( OLD.comment_text IS NULL) THEN
      comment = 'null';
    ELSE
      comment = CAST(OLD.comment_text AS TEXT);
    END IF;
    IF( OLD.parent_id IS NULL) THEN
      parentid = 'null';
    ELSE
      parentid = CAST(OLD.parent_id AS TEXT);
    END IF;
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.id || ' ' || parentid || ' ' || OLD.user_id || ' ' || comment );
    RETURN OLD;
  END IF;
END;
$$;
COMMENT ON FUNCTION bn_comments_trigger()
  IS 'The bn_comments_trigger is called for UPDATE and DELETE operations on the bn_comments table and will perform a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of comments between multiple instances of BinNavi.';

--
-- bn_code_node_comment_trigger()
--

CREATE OR REPLACE FUNCTION bn_code_node_comment_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  comment text;
BEGIN
  IF ( TG_OP = 'UPDATE') THEN
    IF ( NEW.comment_id is null) THEN
      comment = 'null';
    ELSE
      comment = CAST(NEW.comment_id AS TEXT);
    END IF;
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.node_id || ' ' || NEW.parent_function || ' ' || comment );
    RETURN NEW;
  END IF;
END;
$$;
COMMENT ON FUNCTION bn_code_node_comment_trigger()
  IS 'The bn_bn_code_node_comment_trigger is called for UPDATE operations on the bn_code_nodes table an will perform a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of local comments associated to code nodes between multiple instances of BinNavi.';

--
-- bn_codenode_instructions_comment_trigger()
--

CREATE OR REPLACE FUNCTION bn_codenode_instructions_comment_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  comment text;
BEGIN
  IF ( TG_OP = 'UPDATE') THEN
    IF ( NEW.comment_id is null) THEN
      comment = 'null';
    ELSE
      comment = CAST(NEW.comment_id AS TEXT);
    END IF;
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.node_id || ' ' || NEW.position || ' ' || NEW.address || ' ' || comment );
    RETURN NEW;
  END IF;
END;
$$;
COMMENT ON FUNCTION bn_codenode_instructions_comment_trigger()
  IS 'The bn_codenode_instructions_comment_trigger is called for UPDATE operations on the bn_codenode_instructions table and will perform a pg_notify with the altered information
  This information is used in BinNavi to provide synchronisation of local comments associated to instructions between multiple instances of BinNavi.';

--
-- bn_comments_audit_logger()
--

CREATE OR REPLACE FUNCTION bn_comments_audit_logger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  BEGIN
    --
    -- Create a row in bn_comments_audit to reflect the operation performed on bn_comments,
    --
    IF (TG_OP = 'DELETE') THEN
      INSERT INTO bn_comments_audit SELECT 'D', now(), OLD.id, OLD.parent_id, OLD.user_id, OLD.comment_text;
      RETURN OLD;
    ELSIF (TG_OP = 'UPDATE') THEN
      INSERT INTO bn_comments_audit SELECT 'U', now(), NEW.id, NEW.parent_id, NEW.user_id, NEW.comment_text;
      RETURN NEW;
    ELSIF (TG_OP = 'INSERT') THEN
      INSERT INTO bn_comments_audit SELECT 'I', now(), NEW.id, NEW.parent_id, NEW.user_id, NEW.comment_text;
      RETURN NEW;
    END IF;
    RETURN NULL;
  END;
$$;
COMMENT ON FUNCTION bn_comments_audit_logger()
  IS 'The bn_comments_audit_logger is called for all operations performed on the bn_comments table and saves the operation with the altered information in the table
  bn_comments_audit. This information can be used to track changes to comments which have been performed to a database over time.';

--
-- bn_edges_comment_trigger()
--

CREATE OR REPLACE FUNCTION bn_edges_comment_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  DECLARE
  comment text;
  BEGIN
  IF ( TG_OP = 'UPDATE') THEN
    IF ( NEW.comment_id is null) THEN
      comment = 'null';
    ELSE
      comment = CAST(NEW.comment_id AS TEXT);
    END IF;
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.id || ' ' || comment );
    RETURN NEW;
  END IF;
  END;
  $$;
COMMENT ON FUNCTION bn_edges_comment_trigger()
  IS 'The bn_edges_comment_trigger is called for UPDATE operations on the bn_edges table and will perfrom a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of local comments associated to edges between multiple instances of BinNavi.';

--
-- bn_function_nodes_comment_trigger()
--

CREATE OR REPLACE FUNCTION bn_function_nodes_comment_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
  DECLARE
  comment text;
  BEGIN
  IF ( TG_OP = 'UPDATE') THEN
    IF ( NEW.comment_id is null) THEN
      comment = 'null';
    ELSE
      comment = CAST(NEW.comment_id AS TEXT);
    END IF;
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.node_id || ' ' || NEW.function || ' ' || comment );
    RETURN NEW;
  END IF;
  END;
  $$;
COMMENT ON FUNCTION bn_function_nodes_comment_trigger()
  IS 'The bn_function_nodes_comment_trigger is called for UPDATE operations on the bn_function_nodes table and will perfrom a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of comments associated to function nodes between multiple instances of BinNavi.';

--
-- bn_functions_comment_trigger()
--

CREATE OR REPLACE FUNCTION bn_functions_comment_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
 DECLARE
  comment text;
 BEGIN
  IF ( TG_OP = 'UPDATE') THEN
    IF ( NEW.comment_id is null) THEN
      comment = 'null';
    ELSE
      comment = CAST(NEW.comment_id AS TEXT);
    END IF;
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.address || ' ' || comment );
    RETURN NEW;
  END IF;
 END;
 $$;
COMMENT ON FUNCTION bn_functions_comment_trigger()
  IS 'The bn_functions_comment_trigger is called for UPDATE operations on the bn_function table and will perfrom a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of comments associated to functions between multiple instances of BinNavi.';

--
-- bn_global_edge_comments_trigger()
--

CREATE OR REPLACE FUNCTION bn_global_edge_comments_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  IF ( TG_OP = 'INSERT' OR TG_OP = 'UPDATE' ) THEN
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.src_module_id || ' ' || NEW.dst_module_id || ' ' || NEW.src_address || ' ' || NEW.dst_address || ' ' || NEW.comment_id );
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.src_module_id || ' ' || OLD.dst_module_id || ' ' || OLD.src_address || ' ' || OLD.dst_address);
    RETURN OLD;
  END IF;
END;
$$;
COMMENT ON FUNCTION bn_global_edge_comments_trigger()
  IS 'The bn_global_edge_comments_trigger is called for all operations on the bn_global_edge_comments table and will perfrom a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of global comments associated to edges between multiple instances of BinNavi.';

--
-- bn_global_node_comments_trigger()
--

CREATE OR REPLACE FUNCTION bn_global_node_comments_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  IF ( TG_OP = 'INSERT' OR TG_OP = 'UPDATE' ) THEN
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.address || ' ' || NEW.comment_id );
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.module_id || ' ' || OLD.address);
    RETURN OLD;
  END IF;
END;
$$;
COMMENT ON FUNCTION bn_global_node_comments_trigger()
  IS 'The bn_global_node_comments_trigger is called for all operations on the bn_global_node_comments table and will perfrom a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of global comments associated to nodes between multiple instances of BinNavi.';

--
-- bn_group_nodes_comment_trigger()
--

CREATE OR REPLACE FUNCTION bn_group_nodes_comment_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  comment text;
BEGIN
  IF ( TG_OP = 'INSERT' OR TG_OP = 'UPDATE' ) THEN
    IF ( NEW.comment_id is null) THEN
      comment = 'null';
    ELSE
      comment = CAST(NEW.comment_id AS TEXT);
    END IF;
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.node_id || ' ' || comment );
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.node_id);
    RETURN OLD;
  END IF;
END;
$$;
COMMENT ON FUNCTION bn_group_nodes_comment_trigger()
  IS 'The bn_group_nodes_comment_trigger is called for all operations on the bn_group_nodes table and will perfrom a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of comments associated to group nodes between multiple instances of BinNavi.';

--
-- bn_instructions_comment_trigger()
--

CREATE OR REPLACE FUNCTION bn_instructions_comment_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  comment text;
BEGIN
  IF ( TG_OP = 'UPDATE') THEN
    IF ( NEW.comment_id is null) THEN
      comment = 'null';
    ELSE
      comment = CAST(NEW.comment_id AS TEXT);
    END IF;
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.module_id || ' ' || NEW.address || ' ' || comment );
    RETURN NEW;
  END IF;
END;
$$;
COMMENT ON FUNCTION bn_instructions_comment_trigger()
  IS 'The bn_instructions_comment_trigger is called for UPDATE operations on the bn_instructions table and will perfrom a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of global comments associated to instructions between multiple instances of BinNavi.';

--
-- bn_text_nodes_comment_trigger()
--

CREATE OR REPLACE FUNCTION bn_text_nodes_comment_trigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  comment text;
BEGIN
  IF ( TG_OP = 'INSERT' OR TG_OP = 'UPDATE' ) THEN
    IF ( NEW.comment_id is null) THEN
      comment = 'null';
    ELSE
      comment = CAST(NEW.comment_id AS TEXT);
    END IF;
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || NEW.node_id || ' ' || comment );
    RETURN NEW;
  ELSIF ( TG_OP = 'DELETE' ) THEN
    PERFORM pg_notify('comment_changes', TG_TABLE_NAME || ' ' || TG_OP || ' ' || OLD.node_id);
    RETURN OLD;
  END IF;
END;
$$;
COMMENT ON FUNCTION bn_text_nodes_comment_trigger()
  IS 'The bn_text_nodes_comment_trigger is called for all operations on the bn_text_nodes table and will perfrom a pg_notify with the altered information.
  This information is used in BinNavi to provide synchronisation of comments associated to text nodes between multiple instances of BinNavi.';

--
-- Table section
--

--
-- bn_debuggers
--

CREATE SEQUENCE bn_debuggers_id_seq;
COMMENT ON SEQUENCE bn_debuggers_id_seq
    IS 'This sequence is used by the table bn_debuggers id field.';

CREATE TABLE bn_debuggers (
    id integer NOT NULL PRIMARY KEY DEFAULT nextval('bn_debuggers_id_seq'::regclass),
    name text NOT NULL,
    host text NOT NULL,
    port integer NOT NULL
);

COMMENT ON TABLE bn_debuggers IS 'This table contains all information to connect to a debug client.';
COMMENT ON COLUMN bn_debuggers.id IS 'Id of the debug client.';
COMMENT ON COLUMN bn_debuggers.name IS 'Name of the debug client.';
COMMENT ON COLUMN bn_debuggers.host IS 'Host name of the debug client.';
COMMENT ON COLUMN bn_debuggers.port IS 'Port number of the debug client.';

ALTER SEQUENCE bn_debuggers_id_seq OWNED BY bn_debuggers.id;

--
-- bn_modules
--

CREATE SEQUENCE bn_modules_id_seq;
COMMENT ON SEQUENCE bn_modules_id_seq
    IS 'This sequence is used in the table bn_modules id field.';

CREATE TABLE bn_modules (
    id integer NOT NULL PRIMARY KEY DEFAULT nextval('bn_modules_id_seq'::regclass),
    raw_module_id integer, --REFERENCES modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    name text NOT NULL,
    description text NOT NULL,
    md5 character(32) NOT NULL,
    sha1 character(40) NOT NULL,
    debugger_id integer REFERENCES bn_debuggers(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    image_base bigint DEFAULT 0 NOT NULL,
    file_base bigint DEFAULT 0 NOT NULL,
    import_time timestamp without time zone DEFAULT now() NOT NULL,
    modification_date timestamp without time zone DEFAULT now() NOT NULL,
    data bytea,
    stared boolean DEFAULT false NOT NULL,
    initialization_state integer DEFAULT 0 NOT NULL
);

COMMENT ON TABLE bn_modules IS 'This table holds the information about a BinNavi module.';
COMMENT ON COLUMN bn_modules.id IS 'The id of the module.';
COMMENT ON COLUMN bn_modules.raw_module_id IS 'The id of the corresponding raw module.';
COMMENT ON COLUMN bn_modules.name IS 'The name of the module.';
COMMENT ON COLUMN bn_modules.description IS 'The description of the module.';
COMMENT ON COLUMN bn_modules.md5 IS 'The md5 hash of the binary which corresponds to this module.';
COMMENT ON COLUMN bn_modules.sha1 IS 'The sha1 has of the binary which corresponds to this module.';
COMMENT ON COLUMN bn_modules.debugger_id IS 'The id of the debugger currently active for this module.';
COMMENT ON COLUMN bn_modules.image_base IS 'The image base of the executable represented by the module.';
COMMENT ON COLUMN bn_modules.file_base IS 'The file base of the executable represented by the module.';
COMMENT ON COLUMN bn_modules.import_time IS 'The time of import.';
COMMENT ON COLUMN bn_modules.modification_date IS 'The time when the database was last updated.';
COMMENT ON COLUMN bn_modules.data IS 'The data of binary represented by the module.';
COMMENT ON COLUMN bn_modules.stared IS 'Flags if the module has been stared.';
COMMENT ON COLUMN bn_modules.initialization_state IS 'Indicates the initialization state of the module';

ALTER SEQUENCE bn_modules_id_seq OWNED BY bn_modules.id;

CREATE INDEX bn_modules_raw_module_id_idx
    ON bn_modules USING btree (raw_module_id);

--
-- bn_address_references
--

CREATE TABLE bn_address_references (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    address bigint NOT NULL,
    "position" integer NOT NULL,
    expression_id integer NOT NULL,
    type address_reference_type NOT NULL,
    target bigint NOT NULL,
	CONSTRAINT bn_address_references_pkey PRIMARY KEY (module_id, address, "position", expression_id, type, target)
);

COMMENT ON TABLE bn_address_references IS 'This table stores all address references.';
COMMENT ON COLUMN bn_address_references.module_id IS 'The module id the address reference is associated to.';
COMMENT ON COLUMN bn_address_references.address IS 'The address where the reference is associated to.';
COMMENT ON COLUMN bn_address_references."position" IS 'The position of the operand tree to which the address reference is associated to.';
COMMENT ON COLUMN bn_address_references.expression_id IS 'The id of the expression in the operand tree the address reference is associated to.';
COMMENT ON COLUMN bn_address_references.type IS 'The type of the address reference see the address_reference_type type for details.';
COMMENT ON COLUMN bn_address_references.target IS 'The target where address reference points to.';

CREATE INDEX bn_address_references_module_id_address_position_expression_id_
  ON bn_address_references USING btree (module_id, address, "position", expression_id);

CREATE INDEX bn_address_references_module_id_idx
  ON bn_address_references USING btree (module_id);

CREATE INDEX bn_address_references_target_idx
  ON bn_address_references USING btree (target);

CREATE INDEX bn_address_references_type_idx
  ON bn_address_references USING btree (type);

--
-- bn_projects
--

CREATE SEQUENCE bn_projects_id_seq;
COMMENT ON SEQUENCE bn_projects_id_seq
    IS 'This sequence is used by the table bn_projects id field.';

CREATE TABLE bn_projects (
    id integer NOT NULL PRIMARY KEY DEFAULT nextval('bn_projects_id_seq'::regclass),
    name text NOT NULL,
    description text NOT NULL,
    creation_date timestamp without time zone DEFAULT now() NOT NULL,
    modification_date timestamp without time zone DEFAULT now() NOT NULL,
    stared boolean DEFAULT false NOT NULL
);

COMMENT ON TABLE bn_projects IS 'This table stores all information about a project.';
COMMENT ON COLUMN bn_projects.id IS 'The id of the project. Backed by bn_projects_id_seq';
COMMENT ON COLUMN bn_projects.name IS 'The name of the project.';
COMMENT ON COLUMN bn_projects.description IS 'The description of the project.';
COMMENT ON COLUMN bn_projects.creation_date IS 'The creation date of the project.';
COMMENT ON COLUMN bn_projects.modification_date IS 'The modification date of the project.';
COMMENT ON COLUMN bn_projects.stared IS 'Flag which indicates if the project is stared.';

ALTER SEQUENCE bn_projects_id_seq OWNED BY bn_projects.id;

--
-- bn_address_spaces
--

CREATE SEQUENCE bn_address_spaces_id_seq;
COMMENT ON SEQUENCE bn_address_spaces_id_seq
    IS 'This sequence is used by the table bn_address_spaces id field.';

CREATE TABLE bn_address_spaces (
    id integer NOT NULL PRIMARY KEY DEFAULT nextval('bn_address_spaces_id_seq'::regclass),
    project_id integer NOT NULL REFERENCES bn_projects(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    debugger_id integer REFERENCES bn_debuggers(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    name text NOT NULL,
    description text NOT NULL,
    creation_date timestamp without time zone DEFAULT now() NOT NULL,
    modification_date timestamp without time zone DEFAULT now() NOT NULL
);

COMMENT ON TABLE bn_address_spaces IS 'This table stores the information about address spaces associated to a project.';
COMMENT ON COLUMN bn_address_spaces.id IS 'The id of the address space which is backed by the sequence bn_address_spaces_id_seq';
COMMENT ON COLUMN bn_address_spaces.project_id IS 'The id of the project the address space is associated to.';
COMMENT ON COLUMN bn_address_spaces.debugger_id IS 'The id of the current debugger of the address space.';
COMMENT ON COLUMN bn_address_spaces.name IS 'The name of the address space.';
COMMENT ON COLUMN bn_address_spaces.description IS 'The description of the address space.';
COMMENT ON COLUMN bn_address_spaces.creation_date IS 'The creation date of the address space.';
COMMENT ON COLUMN bn_address_spaces.modification_date IS 'The modification date of the address space.';

ALTER SEQUENCE bn_address_spaces_id_seq OWNED BY bn_address_spaces.id;

--
-- bn_base_types
--

CREATE SEQUENCE bn_base_types_id_seq;
COMMENT ON SEQUENCE bn_base_types_id_seq
    IS 'This sequence is used by the table bn_base_types id field.';

CREATE TABLE bn_base_types (
    module_id integer NOT NULL,
    id integer NOT NULL,
    name text NOT NULL,
    size integer NOT NULL,
    pointer integer,
    signed boolean,
    category type_category NOT NULL,
    CONSTRAINT bn_base_types_pkey PRIMARY KEY (module_id, id),
    CONSTRAINT bn_base_types_pointer_fkey
        FOREIGN KEY (module_id, pointer)
        REFERENCES bn_base_types(module_id, id)
        ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_base_types IS 'This table stores all base types for the type system used in BinNavi.';
COMMENT ON COLUMN bn_base_types.module_id IS 'The module id the base type is associated to.';
COMMENT ON COLUMN bn_base_types.id IS 'The id of the base type.';
COMMENT ON COLUMN bn_base_types.name IS 'The name of the base type.';
COMMENT ON COLUMN bn_base_types.size IS 'The size of the base type in bits.';
COMMENT ON COLUMN bn_base_types.pointer IS 'A flag that indicates if the base type is a pointer or not.';
COMMENT ON COLUMN bn_base_types.signed IS 'A flag that indicates if the base type id signed or not.';
COMMENT ON COLUMN bn_base_types.category IS 'An enum that describes the category of this base type.';

ALTER SEQUENCE bn_base_types_id_seq OWNED BY bn_base_types.id;

CREATE TRIGGER bn_base_types_trigger
  AFTER INSERT OR UPDATE OR DELETE
  ON bn_base_types
  FOR EACH ROW EXECUTE
    PROCEDURE bn_base_types_trigger();
--
-- bn_nodes
--

CREATE SEQUENCE bn_nodes_id_seq;
COMMENT ON SEQUENCE bn_nodes_id_seq
    IS 'This sequence is used by the table bn_nodes id field.';

CREATE TABLE bn_nodes (
    id integer NOT NULL PRIMARY KEY DEFAULT nextval('bn_nodes_id_seq'::regclass),
    view_id integer NOT NULL,
    parent_id integer,
    type node_type NOT NULL,
    x double precision NOT NULL,
    y double precision NOT NULL,
    width double precision NOT NULL,
    height double precision NOT NULL,
    color integer NOT NULL,
    bordercolor integer DEFAULT 0 NOT NULL,
    selected boolean NOT NULL,
    visible boolean NOT NULL
);

COMMENT ON TABLE bn_nodes IS 'This table holds the information representing a base node.';
COMMENT ON COLUMN bn_nodes.id IS 'The id of the node.';
COMMENT ON COLUMN bn_nodes.view_id IS 'The id of the view the node belongs to.';
COMMENT ON COLUMN bn_nodes.parent_id IS 'The potential parent node of this node in z-axis';
COMMENT ON COLUMN bn_nodes.type IS 'The type of the node see node_type.';
COMMENT ON COLUMN bn_nodes.x IS 'The x coordinate of the node.';
COMMENT ON COLUMN bn_nodes.y IS 'The y coordinate of the node.';
COMMENT ON COLUMN bn_nodes.width IS 'The width of the node.';
COMMENT ON COLUMN bn_nodes.height IS 'The height of the node.';
COMMENT ON COLUMN bn_nodes.color IS 'The color of the node.';
COMMENT ON COLUMN bn_nodes.bordercolor IS 'The border color of the node.';
COMMENT ON COLUMN bn_nodes.selected IS 'Flags if the node is selected.';
COMMENT ON COLUMN bn_nodes.visible IS 'Flags if the node is visible.';

ALTER SEQUENCE bn_nodes_id_seq OWNED BY bn_nodes.id;

CREATE INDEX bn_nodes_type
  ON bn_nodes USING btree (type);

CREATE INDEX bn_nodes_view_id
  ON bn_nodes USING btree (view_id);

CREATE INDEX bn_nodes_view_id_type_idx
  ON bn_nodes USING btree (view_id, type);

--
-- bn_users
--

CREATE SEQUENCE bn_users_user_id_seq;
COMMENT ON SEQUENCE bn_users_user_id_seq
  IS 'This sequence is used by the table bn_users id field.';

CREATE TABLE bn_users (
    user_id integer NOT NULL PRIMARY KEY DEFAULT nextval('bn_users_user_id_seq'::regclass),
    user_name text,
    user_image bytea,
    user_image_filename text
);

COMMENT ON TABLE bn_users IS 'This table holds all information about users in BinNavi';
COMMENT ON COLUMN bn_users.user_id IS 'The id of the user.';
COMMENT ON COLUMN bn_users.user_name IS 'The name of the user.';
COMMENT ON COLUMN bn_users.user_image IS 'Currently unused.';
COMMENT ON COLUMN bn_users.user_image_filename IS 'Currently unused.';

ALTER SEQUENCE bn_users_user_id_seq OWNED BY bn_users.user_id;

--
-- bn_comments
--

CREATE SEQUENCE bn_comments_id_seq;
COMMENT ON SEQUENCE bn_comments_id_seq
  IS 'This sequence is used by the table bn_comments id field.';

CREATE TABLE bn_comments (
    id integer NOT NULL PRIMARY KEY,
    parent_id integer REFERENCES bn_comments(id) ON DELETE SET NULL DEFERRABLE INITIALLY DEFERRED,
    user_id integer NOT NULL REFERENCES bn_users(user_id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    comment_text text NOT NULL
);

COMMENT ON TABLE bn_comments IS 'This table stores all information about comments';
COMMENT ON COLUMN bn_comments.id IS 'The id of the comment used in all other tables as reference to this table.';
COMMENT ON COLUMN bn_comments.parent_id IS 'This column contains the id of the comment which is the parent of this comment.nThe idea here is that the latest generated comment will be refered to by the comment_id in the tables having a comment such that we will traverse the comments upwards to generate the complete comment stream ';
COMMENT ON COLUMN bn_comments.user_id IS 'The owner of the comment which is the only person to be able to delete or edit this comment.nThis value does not provide any security it is just there to reduce concurrent modification problems.';
COMMENT ON COLUMN bn_comments.comment_text IS 'The actual comment.';

ALTER SEQUENCE bn_comments_id_seq OWNED BY bn_comments.id;

CREATE INDEX bn_comments_parent_id_idx
  ON bn_comments USING btree (parent_id);

CREATE INDEX bn_comments_user_id_idx
  ON bn_comments USING btree (user_id);

CREATE TRIGGER bn_comments_audit_trigger
  AFTER INSERT OR DELETE OR UPDATE ON bn_comments
  FOR EACH ROW
    EXECUTE PROCEDURE bn_comments_audit_logger();

CREATE TRIGGER bn_comments_trigger
  AFTER UPDATE OR DELETE
  ON bn_comments
  FOR EACH ROW
    EXECUTE PROCEDURE bn_comments_trigger();

--
-- bn_code_nodes
--

CREATE TABLE bn_code_nodes (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    node_id integer NOT NULL PRIMARY KEY REFERENCES bn_nodes(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    parent_function bigint,
    comment_id integer REFERENCES bn_comments(id) ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_code_nodes IS 'This table stores all information about code nodes.';
COMMENT ON COLUMN bn_code_nodes.module_id IS 'The module id the code node belongs to.';
COMMENT ON COLUMN bn_code_nodes.node_id IS 'The node id the code node is associated with.';
COMMENT ON COLUMN bn_code_nodes.parent_function IS 'The parent function of the code node.';
COMMENT ON COLUMN bn_code_nodes.comment_id IS 'The id of the comment associacted with the code node.';


CREATE INDEX bn_code_nodes_module_id_idx
    ON bn_code_nodes USING btree (module_id);

CREATE INDEX bn_code_nodes_comment_id_idx
    ON bn_code_nodes USING btree (comment_id);

CREATE TRIGGER bn_code_node_comment_trigger
    AFTER UPDATE OF comment_id ON bn_code_nodes
    FOR EACH ROW EXECUTE
        PROCEDURE bn_code_node_comment_trigger();

--
-- bn_codenode_instructions
--

CREATE TABLE bn_codenode_instructions (
    module_id integer NOT NULL,
    node_id integer NOT NULL REFERENCES bn_nodes(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    "position" integer NOT NULL,
    address bigint NOT NULL,
    comment_id integer REFERENCES bn_comments(id) ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT bn_codenode_instructions_pkey PRIMARY KEY (node_id, "position")
);

COMMENT ON TABLE bn_codenode_instructions IS 'This table stores the association between instructions and code nodes.';
COMMENT ON COLUMN bn_codenode_instructions.module_id IS 'The module id the association between instruction and code node belongs to.';
COMMENT ON COLUMN bn_codenode_instructions.node_id IS 'The node id to which the instruction is associated.';
COMMENT ON COLUMN bn_codenode_instructions.position IS 'The position within the node the instruction has.';
COMMENT ON COLUMN bn_codenode_instructions.address IS 'The address of the code node.';
COMMENT ON COLUMN bn_codenode_instructions.comment_id IS 'The id of the comment associated with the instruction in the code node.';

CREATE INDEX bn_codenode_instructions_address_idx
  ON bn_codenode_instructions USING btree (address);

CREATE INDEX bn_codenode_instructions_module_id_address_idx
  ON bn_codenode_instructions USING btree (module_id, address);

CREATE INDEX bn_codenode_instructions_comment_id_idx
  ON bn_codenode_instructions USING btree (comment_id);

CREATE TRIGGER bn_codenode_instructions_comment_trigger
  AFTER UPDATE OF comment_id ON bn_codenode_instructions
  FOR EACH ROW EXECUTE
    PROCEDURE bn_codenode_instructions_comment_trigger();

--
-- bn_comments_audit
--

CREATE TABLE bn_comments_audit (
    operation bpchar NOT NULL,
    time_stamp timestamp with time zone DEFAULT ('now'::text)::date NOT NULL,
    id integer NOT NULL,
    parent_id integer,
    user_id integer NOT NULL,
    comment_text text NOT NULL,
    CONSTRAINT bn_comments_audit_pkey PRIMARY KEY (operation, time_stamp, id)
);

COMMENT ON TABLE bn_comments_audit IS 'This table contains all operations that have been performed on the table bn_comments.nIts purpose is that for all operations done by multiple clients on the table bn_comments there will be a log of thier activity which can help debug issues if something goes wrong.';
COMMENT ON COLUMN bn_comments_audit.operation IS 'The operation that has been performed where: U is update, I is insert and D is delete.';
COMMENT ON COLUMN bn_comments_audit.time_stamp IS 'The time stamp of the operation such that it is possible to find out when a speciffic event has occured.';
COMMENT ON COLUMN bn_comments_audit.id IS 'see bn_comments.id for description.';
COMMENT ON COLUMN bn_comments_audit.parent_id IS 'see bn_comments.parent_id for description.';
COMMENT ON COLUMN bn_comments_audit.user_id IS 'see bn_comments.user_id for description.';
COMMENT ON COLUMN bn_comments_audit.comment_text IS 'see bn_comments.comment_text for description.';

--
-- bn_data_parts
--

CREATE TABLE bn_data_parts (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    part_id integer NOT NULL,
    data bytea,
	PRIMARY KEY (module_id, part_id)
);

COMMENT ON TABLE bn_data_parts IS 'This table is used to store the original binary data of the module in the database.';
COMMENT ON COLUMN bn_data_parts.module_id IS 'Module id of a data part.';
COMMENT ON COLUMN bn_data_parts.part_id IS 'Id of a data part.';
COMMENT ON COLUMN bn_data_parts.data IS 'The actual data of a data part.';

--
-- bn_edges
--
CREATE SEQUENCE bn_edges_id_seq;
COMMENT ON SEQUENCE bn_edges_id_seq
    IS 'This sequence is used by the table bn_edges id field.';

CREATE TABLE bn_edges (
    id integer NOT NULL PRIMARY KEY DEFAULT nextval('bn_edges_id_seq'::regclass),
    source_node_id integer NOT NULL REFERENCES bn_nodes(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    target_node_id integer NOT NULL REFERENCES bn_nodes(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    x1 double precision NOT NULL,
    y1 double precision NOT NULL,
    x2 double precision NOT NULL,
    y2 double precision NOT NULL,
    type edge_type NOT NULL,
    color integer NOT NULL,
    visible boolean NOT NULL,
    selected boolean NOT NULL,
    comment_id integer REFERENCES bn_comments(id) ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_edges IS 'This table stores information about edges.';
COMMENT ON COLUMN bn_edges.id IS 'The id of the edge Globally unique in a single database.';
COMMENT ON COLUMN bn_edges.source_node_id IS 'The id of the node where the edge originates from.';
COMMENT ON COLUMN bn_edges.target_node_id IS 'The id of the node where the edge destined to.';
COMMENT ON COLUMN bn_edges.x1 IS 'The x1 coordinate of the edge.';
COMMENT ON COLUMN bn_edges.y1 IS 'The y1 coordinate of the edge.';
COMMENT ON COLUMN bn_edges.x2 IS 'The x2 coordinate of the edge.';
COMMENT ON COLUMN bn_edges.y2 IS 'The y2 coordinate of the edge.';
COMMENT ON COLUMN bn_edges.type IS 'The type of the edge see edge_type for all possible cases.';
COMMENT ON COLUMN bn_edges.color IS 'The color of the edge.';
COMMENT ON COLUMN bn_edges.visible IS 'Flags if the edge is currently visible or not.';
COMMENT On COLUMN bn_edges.selected IS 'Flags if the edge is currently selected or not.';
COMMENT ON COLUMN bn_edges.comment_id IS 'The id of the last comment in the comment list associated to the edge.';

ALTER SEQUENCE bn_edges_id_seq OWNED BY bn_edges.id;

CREATE INDEX bn_edges_source_node_id_idx
    ON bn_edges USING btree (source_node_id);

CREATE INDEX bn_edges_target_node_id_idx
    ON bn_edges USING btree (target_node_id);

CREATE INDEX bn_edges_comment_id_idx
    ON bn_edges USING btree (comment_id);

CREATE TRIGGER bn_edges_comment_trigger
    AFTER UPDATE OF comment_id ON bn_edges
    FOR EACH ROW
        EXECUTE PROCEDURE bn_edges_comment_trigger();

--
-- bn_edge_paths
--

CREATE TABLE bn_edge_paths (
    edge_id integer NOT NULL REFERENCES bn_edges(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    "position" integer NOT NULL,
    x double precision NOT NULL,
    y double precision NOT NULL,
	CONSTRAINT bn_edge_paths_pkey PRIMARY KEY (edge_id, "position")
);

COMMENT ON TABLE bn_edge_paths IS 'This table stores the layout information of edges.';
COMMENT ON COLUMN bn_edge_paths.edge_id IS 'The id of the edge which the path information belongs to.';
COMMENT ON COLUMN bn_edge_paths."position" IS 'The position of the edge path.';
COMMENT ON COLUMN bn_edge_paths.x IS 'The x coordinate of the edge path';
COMMENT ON COLUMN bn_edge_paths.y IS 'The y coordinate of the edge path';

--
-- bn_expression_substitutions
--

CREATE TABLE bn_expression_substitutions (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    address bigint NOT NULL,
    "position" integer NOT NULL,
    expression_id integer NOT NULL,
    replacement text NOT NULL,
	CONSTRAINT bn_expression_substitutions_pkey PRIMARY KEY (module_id, address, "position", expression_id)
);

COMMENT ON TABLE bn_expression_substitutions IS 'This table defines the expression substitutions.';
COMMENT ON COLUMN bn_expression_substitutions.module_id IS 'The id of the module to which this expression substitution belongs.';
COMMENT ON COLUMN bn_expression_substitutions.address IS 'The address of the expression substitution.';
COMMENT ON COLUMN bn_expression_substitutions."position" IS 'The position of the expression substitution in regards to the operands.';
COMMENT ON COLUMN bn_expression_substitutions.expression_id IS 'The id of the expression to be substituted.';
COMMENT ON COLUMN bn_expression_substitutions.replacement IS 'The text replacement for this expression substitution.';

CREATE INDEX bn_expression_substitutions_module_id_idx
  ON bn_expression_substitutions USING btree (module_id);

--
-- bn_expression_tree
--

CREATE TABLE bn_expression_tree (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    id integer NOT NULL,
    type integer NOT NULL,
    symbol character varying(256),
    immediate bigint,
    "position" integer NOT NULL,
    parent_id integer,
	CONSTRAINT bn_expression_tree_pkey PRIMARY KEY (module_id, id)
);

COMMENT ON TABLE bn_expression_tree IS 'This table defines the in BinNavi used expression trees';
COMMENT ON COLUMN bn_expression_tree.module_id IS 'The id of the module tio which the expression tree belongs.';
COMMENT ON COLUMN bn_expression_tree.id IS 'The id of the expression tree.';
COMMENT ON COLUMN bn_expression_tree.type IS 'The type of the expression tree.';
COMMENT ON COLUMN bn_expression_tree.symbol IS 'If the type is a symbol the string is saved here.';
COMMENT ON COLUMN bn_expression_tree.immediate IS 'If the type is an immediate the immediate is saved here.';
COMMENT ON COLUMN bn_expression_tree."position" IS 'The position of the expression tree.';
COMMENT ON COLUMN bn_expression_tree.parent_id IS 'If the tree has a parent tree id it is saved here.';

--
-- bn_expression_tree_ids
--

CREATE TABLE bn_expression_tree_ids (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    id integer NOT NULL,
	CONSTRAINT bn_expression_tree_ids_pkey PRIMARY KEY (module_id, id)
);

COMMENT ON TABLE bn_expression_tree_ids IS 'This table links expression tree ids to module ids.';
COMMENT ON COLUMN bn_expression_tree_ids.module_id IS 'Module id.';
COMMENT ON COLUMN bn_expression_tree_ids.id IS 'Expression tree id.';

CREATE INDEX bn_expression_tree_ids_module_id_idx
  ON bn_expression_tree_ids USING btree (module_id);

--
-- bn_expression_tree_mapping
--

CREATE TABLE bn_expression_tree_mapping (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    tree_id integer NOT NULL,
    tree_node_id integer NOT NULL,
	CONSTRAINT bn_expression_tree_mapping_pkey PRIMARY KEY (module_id, tree_id, tree_node_id)
);

COMMENT ON TABLE bn_expression_tree_mapping IS 'This table maps a tree id of an expression tree to a tree node id of an expression tree.';
COMMENT ON COLUMN bn_expression_tree_mapping.module_id IS 'The module id of the mapping.';
COMMENT ON COLUMN bn_expression_tree_mapping.tree_id IS 'The tree id of the mapping.';
COMMENT ON COLUMN bn_expression_tree_mapping.tree_node_id IS 'The tree node id of the mapping.';

CREATE INDEX bn_expression_tree_mapping_module_id_idx
  ON bn_expression_tree_mapping USING btree (module_id);

--
-- bn_types
--

CREATE SEQUENCE bn_types_id_seq;
COMMENT ON SEQUENCE bn_types_id_seq
    IS 'This sequence is used by the table bn_types id field.';

CREATE TABLE bn_types (
    module_id integer NOT NULL,
    id integer NOT NULL DEFAULT nextval('bn_types_id_seq'::regclass),
    name text NOT NULL,
    base_type integer NOT NULL,
    parent_id integer,
    "offset" integer,
    argument integer,
    number_of_elements integer,
    CONSTRAINT bn_types_pkey PRIMARY KEY (module_id, id),
    CONSTRAINT bn_types_base_type_fkey
        FOREIGN KEY (module_id, base_type)
        REFERENCES bn_base_types(module_id, id)
        ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    CONSTRAINT bn_types_parent_id_fkey
        FOREIGN KEY (module_id, parent_id)
        REFERENCES bn_base_types(module_id, id)
        ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_types IS 'This table holds the information about concrete types.';
COMMENT ON COLUMN bn_types.module_id IS 'The id of the module the type is associated to.';
COMMENT ON COLUMN bn_types.id IS 'The id of the type.';
COMMENT ON COLUMN bn_types.name IS 'The name of the type.';
COMMENT ON COLUMN bn_types.base_type IS 'The base type of this type.';
COMMENT ON COLUMN bn_types.parent_id IS 'The potential parent type of this type.';
COMMENT ON COLUMN bn_types."offset" IS 'Used for struct types and object types to define the offset of the member within the compound type.';
COMMENT ON COLUMN bn_types.argument IS 'Used for function pointer types to indicate which argument this type is.';
COMMENT ON COLUMN bn_types.number_of_elements IS 'Used for array types to indicate the number of elements in an array';

ALTER SEQUENCE bn_types_id_seq OWNED BY bn_types.id;

CREATE TRIGGER bn_types_trigger
  AFTER INSERT OR UPDATE OR DELETE
  ON bn_types
  FOR EACH ROW EXECUTE
    PROCEDURE bn_types_trigger();

--
-- bn_expression_types
--

CREATE TABLE bn_expression_types (
    module_id integer NOT NULL,
    address bigint NOT NULL,
    "position" integer NOT NULL,
    expression_id integer NOT NULL,
    base_type_id integer NOT NULL,
    path integer[],
    "offset" integer,
    PRIMARY KEY (module_id, address, "position", expression_id),
    CONSTRAINT bn_expression_types_module_id_member_id_fkey
        FOREIGN KEY (module_id, base_type_id)
        REFERENCES bn_base_types(module_id, id)
        ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_expression_types IS 'This table stores the type from the type system for a specific operand.';
COMMENT ON COLUMN bn_expression_types.module_id IS 'The module id the type is associated with.';
COMMENT ON COLUMN bn_expression_types.address IS 'The address where the type association is located.';
COMMENT ON COLUMN bn_expression_types."position" IS 'The position or the operand tree in the instruction where the type is associated to.';
COMMENT ON COLUMN bn_expression_types.expression_id IS 'The expression tree id the type is associated to.';
COMMENT ON COLUMN bn_expression_types.base_type_id IS 'The bn_base_types type which is associated here.';
COMMENT ON COLUMN bn_expression_types.path IS 'The path of the type substitution. Each integer here is an element from bn_types.';
COMMENT ON COLUMN bn_expression_types."offset" IS 'The offset of the type substitution.';

CREATE TRIGGER bn_expression_types_trigger
  AFTER INSERT OR UPDATE OR DELETE
  ON bn_expression_types
  FOR EACH ROW EXECUTE
    PROCEDURE bn_expression_types_trigger();

--
-- bn_sections
--

CREATE SEQUENCE bn_sections_id_seq;
COMMENT ON SEQUENCE bn_sections_id_seq
    IS 'This sequence is used by the table bn_sections id field.';

CREATE TABLE bn_sections (
    module_id integer NOT NULL REFERENCES bn_modules (id) ON UPDATE NO ACTION ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    id integer NOT NULL DEFAULT nextval('bn_sections_id_seq'::regclass),
    name text NOT NULL,
    comment_id integer REFERENCES bn_comments (id) ON UPDATE NO ACTION ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED,
    start_address bigint NOT NULL,
    end_address bigint NOT NULL,
    permission permission_type,
    data bytea,
    CONSTRAINT bn_sections_pkey PRIMARY KEY(module_id, id)
);

ALTER SEQUENCE bn_sections_id_seq OWNED BY bn_sections.id;

COMMENT ON TABLE bn_sections IS 'This table stores the information about sections known to BinNavi.';
COMMENT ON COLUMN bn_sections.module_id IS 'The module id the section belongs to.';
COMMENT ON COLUMN bn_sections.id IS 'The id of the section.';
COMMENT ON COLUMN bn_sections.name IS 'The name of the section.';
COMMENT ON COLUMN bn_sections.comment_id IS 'The id of the comment associated with this section.';
COMMENT ON COLUMN bn_sections.start_address IS 'The start address of the section.';
COMMENT ON COLUMN bn_sections.end_address IS 'The end address of the section.';
COMMENT ON COLUMN bn_sections.permission IS 'The permissions of the section see bn_permission_type for more information';
COMMENT ON COLUMN bn_sections.data IS 'The actual data of the section.';

CREATE INDEX bn_sections_comment_id_idx
  ON bn_sections
  USING btree
  (comment_id );

CREATE TRIGGER bn_sections_trigger
  AFTER INSERT OR DELETE OR UPDATE ON bn_sections
  FOR EACH ROW EXECUTE
    PROCEDURE bn_sections_trigger();

--
-- bn_type_instances
--


CREATE SEQUENCE bn_type_instances_id_seq START 0 MINVALUE 0;
COMMENT ON SEQUENCE bn_type_instances_id_seq
    IS 'This sequence is used by the table bn_type_instances id field.';

CREATE TABLE bn_type_instances (
    module_id integer NOT NULL REFERENCES bn_modules (id) ON UPDATE NO ACTION ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    id integer NOT NULL DEFAULT nextval('bn_type_instances_id_seq'::regclass),
    name text,
    comment_id integer REFERENCES bn_comments (id) ON UPDATE NO ACTION ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED,
    type_id integer NOT NULL,
    section_id integer NOT NULL,
    section_offset bigint NOT NULL,
    CONSTRAINT bn_type_instances_pkey PRIMARY KEY (module_id, id),
	CONSTRAINT bn_type_instances_module_id_type_id_fkey FOREIGN KEY (module_id, type_id)
        REFERENCES bn_base_types (module_id, id) MATCH SIMPLE
        ON UPDATE NO ACTION ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    CONSTRAINT bn_type_instances_module_id_section_id_fkey FOREIGN KEY (module_id, section_id)
        REFERENCES bn_sections (module_id, id) MATCH SIMPLE
        ON UPDATE NO ACTION ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED
);

ALTER SEQUENCE bn_type_instances_id_seq OWNED BY bn_type_instances.id;

COMMENT ON TABLE bn_type_instances IS 'This table stores the information about type instances known to BinNavi.';
COMMENT ON COLUMN bn_type_instances.module_id IS 'The module id the type instance belongs to.';
COMMENT ON COLUMN bn_type_instances.id IS 'The id of the type instance.';
COMMENT ON COLUMN bn_type_instances.name IS 'The name of the type instance.';
COMMENT ON COLUMN bn_type_instances.comment_id IS 'The id of the comment associated with this type instance.';
COMMENT ON COLUMN bn_type_instances.type_id IS 'The type id of the type that backs the type instance.';
COMMENT ON COLUMN bn_type_instances.section_id IS 'The id of the section where in combination with address types value can be found.';
COMMENT ON COLUMN bn_type_instances.section_offset IS 'The offset of the type instance in the section.';

CREATE INDEX bn_type_instances_comment_id_idx
  ON bn_type_instances
  USING btree
  (comment_id );

CREATE TRIGGER bn_type_instances_trigger
  AFTER INSERT OR DELETE OR UPDATE ON bn_type_instances
  FOR EACH ROW EXECUTE
    PROCEDURE bn_type_instances_trigger();

CREATE TRIGGER bn_type_instances_comment_trigger
  AFTER UPDATE OF comment_id
  ON bn_type_instances
  FOR EACH ROW EXECUTE
    PROCEDURE bn_type_instances_comment_trigger();



--
-- bn_expression_type_instances
--

CREATE TABLE bn_expression_type_instances (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    address bigint NOT NULL,
    position integer NOT NULL,
    expression_id integer NOT NULL,
    type_instance_id integer NOT NULL,
    PRIMARY KEY(module_id, address, position, expression_id),
    CONSTRAINT bn_expression_type_instances_module_id_type_id_fkey FOREIGN KEY (module_id, type_instance_id)
        REFERENCES bn_type_instances (module_id, id) MATCH SIMPLE
        ON UPDATE NO ACTION ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED
);
COMMENT ON TABLE bn_expression_type_instances IS 'This table stores the information about data cross references. It provides the link between a type instance and an operand tree expression in the graph.';
COMMENT ON COLUMN bn_expression_type_instances.module_id IS 'The module id of the module this data xref belongs to.';
COMMENT ON COLUMN bn_expression_type_instances.address IS 'The address of the instruction to which the type instance substitution belongs.';
COMMENT ON COLUMN bn_expression_type_instances.position IS 'The position of the operand within the instruction the type instance substitution belongs to.';
COMMENT ON COLUMN bn_expression_type_instances.expression_id IS 'The expression tree id in the operand the type instance belongs to.';
COMMENT ON COLUMN bn_expression_type_instances.type_instance_id IS 'The type instance to which this substitution points.';

CREATE TRIGGER bn_expression_type_instances_trigger
  AFTER INSERT OR DELETE OR UPDATE ON bn_expression_type_instances
  FOR EACH ROW EXECUTE
    PROCEDURE bn_expression_type_instances_trigger();

--
-- bn_function_nodes
--

CREATE TABLE bn_function_nodes (
    module_id integer NOT NULL,
    node_id integer NOT NULL PRIMARY KEY REFERENCES bn_nodes(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    function bigint NOT NULL,
    comment_id integer REFERENCES bn_comments(id) ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_function_nodes IS 'This table holds the information about function nodes in a module.';
COMMENT ON COLUMN bn_function_nodes.module_id IS 'The module id of the function node.';
COMMENT ON COLUMN bn_function_nodes.node_id IS 'The node id the function node is associated to.';
COMMENT ON COLUMN bn_function_nodes.function IS 'The function address the function node is associated to.';
COMMENT ON COLUMN bn_function_nodes.comment_id IS 'The id of the comment associated to the function node.';

CREATE INDEX bn_function_nodes_function_idx
  ON bn_function_nodes USING btree (function);

CREATE INDEX bn_function_nodes_module_id_function_idx
  ON bn_function_nodes USING btree (module_id, function);

CREATE INDEX bn_function_nodes_module_id_idx
  ON bn_function_nodes USING btree (module_id);

CREATE INDEX bn_function_nodes_comment_id_idx
  ON bn_function_nodes USING btree (comment_id);

CREATE TRIGGER bn_function_nodes_comment_trigger
  AFTER UPDATE OF comment_id ON bn_function_nodes
  FOR EACH ROW
    EXECUTE PROCEDURE bn_function_nodes_comment_trigger();

--
-- bn_views
--
CREATE SEQUENCE bn_views_id_seq;
COMMENT ON SEQUENCE bn_views_id_seq
    IS 'This sequence is used by the table bn_views id field.';

CREATE TABLE bn_views (
    id integer NOT NULL PRIMARY KEY DEFAULT nextval('bn_views_id_seq'::regclass),
    type view_type NOT NULL,
    name text NOT NULL,
    description text,
    creation_date timestamp without time zone DEFAULT now() NOT NULL,
    modification_date timestamp without time zone DEFAULT now() NOT NULL,
    stared boolean DEFAULT false NOT NULL,
    user_id integer REFERENCES bn_users(user_id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_views IS 'This table holds the information about views.';
COMMENT ON COLUMN bn_views.id IS 'The id of the view.';
COMMENT ON COLUMN bn_views.type IS 'The type of the view see view_type.';
COMMENT ON COLUMN bn_views.name IS 'The name of the view.';
COMMENT ON COLUMN bn_views.description IS 'The description of the view.';
COMMENT ON COLUMN bn_views.creation_date IS 'The date when the view was originally created.';
COMMENT ON COLUMN bn_views.modification_date IS 'The date when the view was last modified.';
COMMENT ON COLUMN bn_views.stared IS 'Flags if the view is stared.';
COMMENT ON COLUMN bn_views.user_id IS 'Defines the owner of the view.';

ALTER SEQUENCE bn_views_id_seq OWNED BY bn_views.id;

CREATE INDEX bn_views_user_id_idx
  ON bn_views USING btree (user_id);

CREATE INDEX bn_views_type_idx
  ON bn_views USING btree (type);

CREATE TRIGGER bn_views_trigger
  AFTER DELETE OR UPDATE ON bn_views
  FOR EACH ROW EXECUTE
    PROCEDURE bn_views_trigger();

--
-- bn_function_views
--

CREATE TABLE bn_function_views (
    module_id integer NOT NULL,
    view_id integer NOT NULL PRIMARY KEY REFERENCES bn_views(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    function bigint NOT NULL
);

COMMENT ON TABLE bn_function_views IS 'This table holds the information about function views.';
COMMENT ON COLUMN bn_function_views.module_id IS 'The module id the function view is associated to.';
COMMENT ON COLUMN bn_function_views.view_id IS 'The view id the function view is associated to.';
COMMENT ON COLUMN bn_function_views.function IS 'The address of the function the function view is associated to.';

CREATE INDEX bn_function_views_module_id_function_idx
  ON bn_function_views USING btree (module_id, function);

CREATE INDEX bn_function_views_module_id_idx
  ON bn_function_views USING btree (module_id);

--
-- bn_functions
--

CREATE TABLE bn_functions (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    address bigint NOT NULL,
    name text,
    original_name text NOT NULL,
    type function_type NOT NULL,
    description text,
    parent_module_name text,
    parent_module_id integer,
    parent_module_function integer,
    stack_frame integer,
    prototype integer,
    comment_id integer REFERENCES bn_comments(id) ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT bn_functions_pkey PRIMARY KEY (module_id, address)
);

COMMENT ON TABLE bn_functions IS 'This table holds the information about functions and thier relations.';
COMMENT ON COLUMN bn_functions.module_id IS 'The id of the module the function belongs to.';
COMMENT ON COLUMN bn_functions.address IS 'The address of the function.';
COMMENT ON COLUMN bn_functions.name IS 'The current name of the function.';
COMMENT ON COLUMN bn_functions.original_name IS 'The original name of the function.';
COMMENT ON COLUMN bn_functions.type IS 'The type of the function see the function_type type for more information.';
COMMENT ON COLUMN bn_functions.description IS 'The description of the function.';
COMMENT ON COLUMN bn_functions.parent_module_name IS 'If the function is forwarded the module name of the function where this function is forwarded to.';
COMMENT ON COLUMN bn_functions.parent_module_id IS 'If the function is forwarded the module id of the function where this function is forwarded to.';
COMMENT ON COLUMN bn_functions.parent_module_function IS 'If the function is forwarded the address of the function where this function is forwarded to.';
COMMENT ON COLUMN bn_functions.stack_frame IS 'The bn_base_types id of the stack frame that is associated with the function.';
COMMENT ON COLUMN bn_functions.prototype IS 'The bn_base_types id of the prototype that is associated with the functions.';
COMMENT ON COLUMN bn_functions.comment_id IS 'The id of the comment associated with the function.';

CREATE INDEX bn_functions_address_idx
  ON bn_functions USING btree (address);

CREATE INDEX bn_functions_module_id_address_idx
  ON bn_functions USING btree (module_id, address);

CREATE INDEX bn_functions_module_id_address_type_idx
  ON bn_functions USING btree (module_id, address, type);

CREATE INDEX bn_functions_module_id_idx
  ON bn_functions USING btree (module_id);

CREATE INDEX bn_functions_parent_module_id_parent_module_function_idx
  ON bn_functions USING btree (parent_module_id, parent_module_function);

CREATE INDEX bn_functions_comment_id_idx
  ON bn_functions USING btree (comment_id);

CREATE TRIGGER bn_functions_comment_trigger
  AFTER UPDATE OF comment_id ON bn_functions
  FOR EACH ROW
    EXECUTE PROCEDURE bn_functions_comment_trigger();

--
-- bn_global_edge_comments
--

CREATE TABLE bn_global_edge_comments (
    src_module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    dst_module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    src_address bigint NOT NULL,
    dst_address bigint NOT NULL,
    comment_id integer REFERENCES bn_comments(id) ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT bn_global_edge_comments_pkey PRIMARY KEY (src_module_id, dst_module_id, src_address, dst_address)
);

COMMENT ON TABLE bn_global_edge_comments IS 'This table holds all global edge comments.';
COMMENT ON COLUMN bn_global_edge_comments.src_module_id IS 'The module id of the module where the edge originates from.';
COMMENT ON COLUMN bn_global_edge_comments.dst_module_id IS 'The module if of the module where the edge destined to.';
COMMENT ON COLUMN bn_global_edge_comments.src_address IS 'The address of the source node of the edge.';
COMMENT ON COLUMN bn_global_edge_comments.dst_address IS 'The address of the destination node of the edge.';
COMMENT ON COLUMN bn_global_edge_comments.comment_id IS 'The id of the global comment';

CREATE INDEX bn_global_edge_comments_src_module_id_idx
  ON bn_global_edge_comments USING btree (src_module_id);

CREATE INDEX bn_global_edge_comments_dst_module_id_idx
  ON bn_global_edge_comments USING btree (dst_module_id);

CREATE INDEX bn_global_edge_comments_comment_id_idx
  ON bn_global_edge_comments USING btree (comment_id);

CREATE TRIGGER bn_global_edge_comments_trigger
  AFTER INSERT OR DELETE OR UPDATE ON bn_global_edge_comments
  FOR EACH ROW
    EXECUTE PROCEDURE bn_global_edge_comments_trigger();

--
-- bn_global_node_comments
--

CREATE TABLE bn_global_node_comments (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    address bigint NOT NULL,
    comment_id integer REFERENCES bn_comments(id) ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT bn_global_node_comments_pkey PRIMARY KEY (module_id, address)
);

COMMENT ON TABLE bn_global_node_comments IS 'This table holds all global node comments.';
COMMENT ON COLUMN bn_global_node_comments.module_id IS 'The module id of the node.';
COMMENT ON COLUMN bn_global_node_comments.address IS 'The address of the node.';
COMMENT ON COLUMN bn_global_node_comments.comment_id IS 'The id of the global node comment.';

CREATE INDEX bn_global_node_comments_comment_id_idx
  ON bn_global_node_comments USING btree (comment_id);

CREATE TRIGGER bn_global_node_comments_trigger
  AFTER INSERT OR DELETE OR UPDATE ON bn_global_node_comments
  FOR EACH ROW
    EXECUTE PROCEDURE bn_global_node_comments_trigger();

--
-- bn_group_nodes
--

CREATE TABLE bn_group_nodes (
    node_id integer NOT NULL PRIMARY KEY REFERENCES bn_nodes(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    collapsed boolean NOT NULL,
    comment_id integer REFERENCES bn_comments(id) ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_group_nodes IS 'This table holds the information about group nodes.';
COMMENT ON COLUMN bn_group_nodes.node_id IS 'The node id of the group node.';
COMMENT ON COLUMN bn_group_nodes.collapsed IS 'Flag that indicates if the node is collapsed.';
COMMENT ON COLUMN bn_group_nodes.comment_id IS 'The id of the comment associated to the group node.';

CREATE INDEX bn_group_nodes_comments_id_idx
  ON bn_group_nodes USING btree (comment_id);

CREATE TRIGGER bn_group_nodes_comment_trigger
  AFTER INSERT OR DELETE OR UPDATE ON bn_group_nodes
  FOR EACH ROW
    EXECUTE PROCEDURE bn_group_nodes_comment_trigger();

--
-- bn_instructions
--

CREATE TABLE bn_instructions (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    address bigint NOT NULL,
    mnemonic character varying(32) NOT NULL,
    data bytea NOT NULL,
    native boolean NOT NULL,
    architecture architecture_type NOT NULL,
    comment_id integer REFERENCES bn_comments(id) ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT bn_instructions_pkey PRIMARY KEY (module_id, address)
);

COMMENT ON TABLE bn_instructions IS 'This table holds the information about instruction.';
COMMENT ON COLUMN bn_instructions.module_id IS 'The module of the instruction.';
COMMENT ON COLUMN bn_instructions.address IS 'The address of the instruction.';
COMMENT ON COLUMN bn_instructions.mnemonic IS 'The mnemonic of the instruction.';
COMMENT ON COLUMN bn_instructions.data IS 'The raw bytes of the instruction from the binary.';
COMMENT ON COLUMN bn_instructions.native IS 'Flag that indicates if the instruction has been build within BinNavi or came from external sources.';
COMMENT ON COLUMN bn_instructions.architecture IS 'The architecture of the instruction for more information about known architecture types see srchitecture_type type.';
COMMENT ON COLUMN bn_instructions.comment_id IS 'The id of the comment associated to the instruction.';

CREATE INDEX bn_instructions_comment_id_idx
  ON bn_instructions USING btree (comment_id);

CREATE TRIGGER bn_instructions_comment_trigger
  AFTER UPDATE OF comment_id ON bn_instructions
  FOR EACH ROW
    EXECUTE PROCEDURE bn_instructions_comment_trigger();

--
-- bn_module_settings
--

CREATE TABLE bn_module_settings (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    name character varying(255) NOT NULL,
    value text NOT NULL,
	CONSTRAINT bn_module_settings_pkey PRIMARY KEY (module_id, name)
);

COMMENT ON TABLE bn_module_settings IS 'This table stores various settings for modules.';
COMMENT ON COLUMN bn_module_settings.module_id IS 'The module id of the setting.';
COMMENT ON COLUMN bn_module_settings.name IS 'The name of the setting.';
COMMENT ON COLUMN bn_module_settings.value IS 'The value of the setting.';



--
-- bn_traces
--

CREATE SEQUENCE bn_traces_id_seq;
COMMENT ON SEQUENCE bn_traces_id_seq
    IS 'This sequence is used by the table bn_traces id field.';

CREATE TABLE bn_traces (
    id integer NOT NULL PRIMARY KEY DEFAULT nextval('bn_traces_id_seq'::regclass),
    view_id integer NOT NULL,
    name text NOT NULL,
    description text NOT NULL
);

COMMENT ON TABLE bn_traces IS 'This table holds the information about traces.';
COMMENT ON COLUMN bn_traces.id IS 'The id of the trace.';
COMMENT ON COLUMN bn_traces.view_id IS 'The view id to which the trace is associated.';
COMMENT ON COLUMN bn_traces.name IS 'The name of the trace.';
COMMENT ON COLUMN bn_traces.description IS 'The description of the trace.';

ALTER SEQUENCE bn_traces_id_seq OWNED BY bn_traces.id;

CREATE INDEX bn_traces_view_id_idx
    ON bn_traces USING btree (view_id);

--
-- bn_trace_events
--

CREATE TABLE bn_trace_events (
    module_id integer REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    trace_id integer NOT NULL REFERENCES bn_traces(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    "position" integer NOT NULL,
    tid integer NOT NULL,
    address bigint NOT NULL,
    type integer,
    CONSTRAINT bn_trace_events_pkey PRIMARY KEY (trace_id, "position")
);

COMMENT ON TABLE bn_trace_events IS 'This table holds the information about a single trace event.';
COMMENT ON COLUMN bn_trace_events.module_id IS 'The id of the module the trace is associated to.';
COMMENT ON COLUMN bn_trace_events.trace_id IS 'The id of the trace.';
COMMENT ON COLUMN bn_trace_events."position" IS 'The position of the trace event within the trace.';
COMMENT ON COLUMN bn_trace_events.tid IS 'The thread id of the trace event.';
COMMENT ON COLUMN bn_trace_events.address IS 'The address of the trace event.';
COMMENT ON COLUMN bn_trace_events.type IS 'The type of the trace event.';

CREATE INDEX bn_trace_events_module_id_idx
    ON bn_trace_events USING btree (module_id);

--
-- bn_module_traces
--

CREATE TABLE bn_module_traces (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    trace_id integer NOT NULL REFERENCES bn_traces(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT bn_module_traces_pkey PRIMARY KEY (module_id, trace_id)
);

COMMENT ON TABLE bn_module_traces IS 'This table stores the association between modules and traces.';
COMMENT ON COLUMN bn_module_traces.module_id IS 'The module id a trace belongs to.';
COMMENT ON COLUMN bn_module_traces.trace_id IS 'The id of the trace.';

--
-- bn_module_views
--

CREATE TABLE bn_module_views (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    view_id integer NOT NULL PRIMARY KEY REFERENCES bn_views(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_module_views IS 'This table stores the association between modules and views.';
COMMENT ON COLUMN bn_module_views.module_id IS 'The module id a view belongs to.';
COMMENT ON COLUMN bn_module_views.view_id IS 'The id of the view.';

CREATE INDEX bn_module_views_module_id_view_id_idx
    ON bn_module_views USING btree (module_id, view_id);

CREATE INDEX bn_module_views_module_id_idx
    ON bn_module_views USING btree (module_id);

CREATE TRIGGER bn_module_views_trigger
    AFTER INSERT OR UPDATE OR DELETE
    ON bn_module_views
    FOR EACH ROW
        EXECUTE PROCEDURE bn_module_views_trigger();

--
-- bn_nodes_spacemodules
--

CREATE TABLE bn_nodes_spacemodules (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    node integer NOT NULL PRIMARY KEY REFERENCES bn_nodes(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    address_space integer REFERENCES bn_address_spaces(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_nodes_spacemodules IS 'This table holds the information about a nodes module association when in a project.';
COMMENT ON COLUMN bn_nodes_spacemodules.module_id IS 'The module id the node is associated to.';
COMMENT ON COLUMN bn_nodes_spacemodules.node IS 'The id of the node.';
COMMENT ON COLUMN bn_nodes_spacemodules.address_space IS 'The id of the address space.';

CREATE INDEX bn_nodes_spacemodules_address_space_idx
  ON bn_nodes_spacemodules USING btree (address_space);

--
-- bn_operands
--

CREATE TABLE bn_operands (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    address bigint NOT NULL,
    expression_tree_id integer NOT NULL,
    "position" integer NOT NULL,
	CONSTRAINT bn_operands_pkey PRIMARY KEY (module_id, address, "position")
);

COMMENT ON TABLE bn_operands IS 'This table stores the information about operands.';
COMMENT ON COLUMN bn_operands.module_id IS 'The module id the operand belongs to.';
COMMENT ON COLUMN bn_operands.address IS 'The address where the operand can be found.';
COMMENT ON COLUMN bn_operands.expression_tree_id IS 'The expression tree id of the operand.';
COMMENT ON COLUMN bn_operands."position" IS 'The position of the operand.';

CREATE INDEX bn_operands_module_id_idx
  ON bn_operands USING btree (module_id);

--
-- bn_project_debuggers
--

CREATE TABLE bn_project_debuggers (
    project_id integer NOT NULL REFERENCES bn_projects(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    debugger_id integer NOT NULL REFERENCES bn_debuggers(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_project_debuggers IS 'This table stores the information about debuggers associated to projects.';
COMMENT ON COLUMN bn_project_debuggers.project_id IS 'The id of a project.';
COMMENT ON COLUMN bn_project_debuggers.debugger_id IS 'The id of a debugger.';

CREATE INDEX bn_project_debuggers_debugger_id_idx
  ON bn_project_debuggers USING btree (debugger_id);

--
-- bn_project_settings
--

CREATE TABLE bn_project_settings (
    project_id integer NOT NULL REFERENCES bn_projects(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    name character varying(255) NOT NULL,
    value text NOT NULL,
	CONSTRAINT bn_project_settings_pkey PRIMARY KEY (project_id, name)
);

COMMENT ON TABLE bn_project_settings IS 'This table stores all settings of a project.';
COMMENT ON COLUMN bn_project_settings.project_id IS 'The id of the project the setting belongs to.';
COMMENT ON COLUMN bn_project_settings.name IS 'The name of the setting.';
COMMENT ON COLUMN bn_project_settings.value IS 'The value of the setting.';

--
-- bn_project_traces
--

CREATE TABLE bn_project_traces (
    project_id integer NOT NULL REFERENCES bn_projects(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    trace_id integer NOT NULL REFERENCES bn_traces(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT bn_project_traces_pkey PRIMARY KEY (project_id, trace_id)
);

COMMENT ON TABLE bn_project_traces IS 'This table stores the association between a project and a trace.';
COMMENT ON COLUMN bn_project_traces.project_id IS 'The id of the project';
COMMENT ON COLUMN bn_project_traces.trace_id IS 'The id of the trace.';

CREATE INDEX bn_project_traces_trace_id_idx
  ON bn_project_traces USING btree (trace_id);

--
-- bn_project_views
--

CREATE TABLE bn_project_views (
    project_id integer NOT NULL REFERENCES bn_projects(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    view_id integer NOT NULL PRIMARY KEY REFERENCES bn_views(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_project_views IS 'This table stores the association of a view to a project.';
COMMENT ON COLUMN bn_project_views.project_id IS 'The id of the project.';
COMMENT ON COLUMN bn_project_views.view_id IS 'The id of the view.';

CREATE INDEX bn_project_views_project_id_idx
    ON bn_project_views USING btree (project_id);

CREATE TRIGGER bn_project_views_trigger
    AFTER INSERT OR UPDATE OR DELETE
    ON bn_project_views
    FOR EACH ROW
    EXECUTE PROCEDURE bn_project_views_trigger();

--
-- bn_space_modules
--

CREATE TABLE bn_space_modules (
    module_id integer NOT NULL REFERENCES bn_modules(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    address_space_id integer NOT NULL REFERENCES bn_address_spaces(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    image_base bigint NOT NULL,
	CONSTRAINT bn_space_modules_pkey PRIMARY KEY (address_space_id, module_id)
);

COMMENT ON TABLE bn_space_modules IS 'This table stores the association between modules and address spaces.';
COMMENT ON COLUMN bn_space_modules.module_id IS 'The id of the module.';
COMMENT ON COLUMN bn_space_modules.address_space_id IS 'The id of the address space.';
COMMENT ON COLUMN bn_space_modules.image_base IS 'The image base of the module in the context of the address space.';

--
-- bn_tags
--

CREATE SEQUENCE bn_tags_id_seq;
COMMENT ON SEQUENCE bn_tags_id_seq
    IS 'This sequence is used by the table bn_tags id field.';

CREATE TABLE bn_tags (
    id integer NOT NULL PRIMARY KEY DEFAULT nextval('bn_tags_id_seq'::regclass),
    parent_id integer REFERENCES bn_tags(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    name text NOT NULL,
    description text NOT NULL,
    type tag_type NOT NULL
);

COMMENT ON TABLE bn_tags IS 'This table stores all information about tags';
COMMENT ON COLUMN bn_tags.id IS 'The id of the tag.';
COMMENT ON COLUMN bn_tags.parent_id IS 'The id of a potential parent tag.';
COMMENT ON COLUMN bn_tags.name IS 'The name of the tag.';
COMMENT ON COLUMN bn_tags.description IS 'The description of the tag.';
COMMENT ON COLUMN bn_tags.type IS 'The type of the tag.';

ALTER SEQUENCE bn_tags_id_seq OWNED BY bn_tags.id;

CREATE INDEX bn_tags_parent_id_idx
    ON bn_tags USING btree (parent_id);

--
-- bn_tagged_nodes
--

CREATE TABLE bn_tagged_nodes (
    node_id integer NOT NULL REFERENCES bn_nodes(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    tag_id integer NOT NULL REFERENCES bn_tags(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT bn_tagged_nodes_pkey PRIMARY KEY (node_id, tag_id)
);

COMMENT ON TABLE bn_tagged_nodes IS 'This table stores the association between tags and nodes.';
COMMENT ON COLUMN bn_tagged_nodes.node_id IS 'The node id of a tagged node.';
COMMENT ON COLUMN bn_tagged_nodes.tag_id IS 'The id of a tag.';

--
-- bn_tagged_views
--

CREATE TABLE bn_tagged_views (
    view_id integer NOT NULL REFERENCES bn_views(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    tag_id integer NOT NULL REFERENCES bn_tags(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT bn_tagged_views_pkey PRIMARY KEY (view_id, tag_id)
);

COMMENT ON TABLE bn_tagged_views IS 'This table stores the association between tags and views.';
COMMENT ON COLUMN bn_tagged_views.view_id IS 'The view id of a tagged view.';
COMMENT ON COLUMN bn_tagged_views.tag_id IS 'The id of a tag.';

CREATE INDEX bn_tagged_views_tag_id_idx
    ON bn_tagged_views USING btree (tag_id);

--
-- bn_text_nodes
--

CREATE TABLE bn_text_nodes (
    node_id integer NOT NULL PRIMARY KEY REFERENCES bn_nodes(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    comment_id integer REFERENCES bn_comments(id) ON DELETE NO ACTION DEFERRABLE INITIALLY DEFERRED
);

COMMENT ON TABLE bn_text_nodes IS 'This table stores the information about text nodes.';
COMMENT ON COLUMN bn_text_nodes.node_id IS 'The node id of the text node.';
COMMENT ON COLUMN bn_text_nodes.comment_id IS 'The id of the comment associated to the text node.';

CREATE INDEX bn_text_nodes_comment_id_idx
  ON bn_text_nodes USING btree (comment_id);

CREATE TRIGGER bn_text_nodes_comment_trigger
  AFTER INSERT OR DELETE OR UPDATE ON bn_text_nodes
  FOR EACH ROW
    EXECUTE PROCEDURE bn_text_nodes_comment_trigger();

--
-- bn_trace_event_values
--

CREATE TABLE bn_trace_event_values (
    trace_id integer NOT NULL REFERENCES bn_traces(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    "position" integer NOT NULL,
    register_name character varying(50) NOT NULL,
    register_value bigint NOT NULL,
    memory_value bytea NOT NULL,
	CONSTRAINT bn_trace_event_values_pkey PRIMARY KEY (trace_id, "position", register_name)
);

COMMENT ON TABLE bn_trace_event_values IS 'This table holds the information about register contents for a trace event.';
COMMENT ON COLUMN bn_trace_event_values.trace_id IS 'The id of the trace the event values are associated to.';
COMMENT ON COLUMN bn_trace_event_values."position" IS 'The position of the values within the trace.';
COMMENT ON COLUMN bn_trace_event_values.register_name IS 'The name of the register for which we have the values.';
COMMENT ON COLUMN bn_trace_event_values.register_value IS 'The values of the register.';
COMMENT ON COLUMN bn_trace_event_values.memory_value IS 'The value of the memory pointed to by the register when there was valid memory available.';

CREATE INDEX bn_trace_event_values_trace_id_idx
  ON bn_trace_event_values USING btree (trace_id);

--
-- bn_view_settings
--

CREATE TABLE bn_view_settings (
    view_id integer NOT NULL REFERENCES bn_views(id) ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED,
    name character varying(255) NOT NULL,
    value text NOT NULL,
	CONSTRAINT bn_view_settings_pkey PRIMARY KEY (view_id, name)
);

COMMENT ON TABLE bn_view_settings IS 'This table holds configuration settings for a particular view.';
COMMENT ON COLUMN bn_view_settings.view_id IS 'The view id associated to this setting.';
COMMENT ON COLUMN bn_view_settings.name IS 'The name of the setting.';
COMMENT ON COLUMN bn_view_settings.value IS 'The value of the setting.';


--
-- Function section.
--

--
-- import(IN rawmoduleid integer, IN moduleid integer, IN userid integer)
--

CREATE OR REPLACE FUNCTION import(IN rawmoduleid integer, IN moduleid integer, IN userid integer)
  RETURNS void AS
$$
DECLARE
    arch text;
    viewid int;
  BEGIN

  --
  -- Disable all trigger procedures during the import.
  --

  SET session_replication_role = replica;

  SELECT architecture INTO arch FROM modules WHERE id = rawmoduleid;

  --
  -- import expression tree ids.
  --

  EXECUTE 'INSERT INTO bn_expression_tree_ids
           SELECT '|| moduleid ||', id
           FROM ex_'|| rawmoduleid ||'_expression_trees';

  --
  -- import expression trees.
  --

  EXECUTE 'INSERT INTO bn_expression_tree
          (module_id, id, type, symbol, immediate, position, parent_id)
          SELECT '|| moduleid ||', id, type, symbol, immediate, position, parent_id
          FROM ex_'|| rawmoduleid ||'_expression_nodes';

  --
  -- Connect expression trees.
  --

  EXECUTE 'INSERT INTO bn_expression_tree_mapping
          (SELECT '|| moduleid ||', expression_tree_id, expression_node_id
          FROM ex_'|| rawmoduleid ||'_expression_tree_nodes)';

  --
  -- import instructions.
  --

  EXECUTE 'WITH comments_to_id(id, address, comment) AS (
            SELECT nextval(''bn_comments_id_seq''::regclass), address, comment
            FROM ex_'|| rawmoduleid ||'_address_comments
          ), comments_table AS (
            INSERT INTO bn_comments
              (id, parent_id, user_id, comment_text)
              SELECT id, null, '|| userid ||', comment
                FROM comments_to_id
           )
           INSERT INTO bn_instructions
             (module_id, address, mnemonic, data, native, architecture, comment_id)
             SELECT '|| moduleid ||', isn.address, mnemonic, data, true, '|| quote_literal(arch) ||', com.id
             FROM ex_'|| rawmoduleid ||'_instructions AS isn
               LEFT JOIN comments_to_id AS com ON com.address = isn.address';

  --
  -- import operands.
  --

  EXECUTE 'INSERT INTO bn_operands SELECT '|| moduleid ||', address, expression_tree_id, position
          FROM ex_'|| rawmoduleid ||'_operands';

  --
  -- import expression substitutions.
  --

  EXECUTE 'INSERT INTO bn_expression_substitutions
           (module_id, address, position, expression_id, replacement)
           SELECT '|| moduleid ||', address, position, expression_node_id, replacement
           FROM ex_'|| rawmoduleid ||'_expression_substitutions';

  --
  -- Import address references.
  --

  EXECUTE 'INSERT INTO bn_address_references
           (module_id, address, position, expression_id, type, target)
           SELECT '|| moduleid ||', address, position, expression_node_id,
           (ENUM_RANGE(NULL::address_reference_type))[type + 1], destination
           FROM ex_'|| rawmoduleid ||'_address_references
             WHERE position IS NOT NULL AND expression_node_id IS NOT NULL';

  --
  -- Import functions.
  --

  EXECUTE 'INSERT INTO bn_functions
           (module_id, address, name, original_name, type, description,
           parent_module_name, parent_module_id, parent_module_function, comment_id, stack_frame, prototype)
           SELECT '|| moduleid ||', address, demangled_name, name, (ENUM_RANGE(NULL::function_type))[type + 1],
           null, module_name, null, null, null, stack_frame, prototype
           FROM ex_'|| rawmoduleid ||'_functions';

  --
  -- import base types.
  --

  EXECUTE 'INSERT INTO bn_base_types
           SELECT '|| moduleid ||', id, name, size, pointer, signed, category::text::type_category
           FROM ex_'|| rawmoduleid ||'_base_types';
  EXECUTE 'SELECT setval(''bn_base_types_id_seq'', MAX(id)) FROM bn_base_types';

  --
  -- import types.
  --

  EXECUTE 'INSERT INTO bn_types
           SELECT '|| moduleid ||', raw_types.id, raw_types.name, raw_types.base_type, raw_types.parent_id,
           raw_types.offset, raw_types.argument, raw_types.number_of_elements
           FROM ex_'|| rawmoduleid ||'_types AS raw_types';
  EXECUTE 'SELECT setval(''bn_types_id_seq'', MAX(id)) FROM bn_types';

  --
  -- import expression types.
  --

  EXECUTE 'INSERT INTO bn_expression_types
           SELECT '|| moduleid ||', et.address, et.position, et.expression_id, et.type, et.path, et.offset
           FROM ex_'|| rawmoduleid ||'_expression_types AS et';

  --
  -- import sections
  --

  EXECUTE 'INSERT INTO bn_sections (module_id, id, name, comment_id, start_address, end_address, permission, data)
           SELECT '|| moduleid ||', id, name, NULL, start_address, end_address, permission::text::permission_type, data
		   FROM ex_'|| rawmoduleid ||'_sections';
  EXECUTE 'SELECT setval(''bn_sections_id_seq'', MAX(id)) FROM bn_sections';

  --
  -- import type instances
  --

  EXECUTE 'INSERT INTO bn_type_instances (module_id, id, name, type_id, section_id, section_offset)
           SELECT '|| moduleid ||', id, name, type_id, section_id, section_offset
           FROM ex_'|| rawmoduleid ||'_type_instances';
  EXECUTE 'SELECT setval(''bn_type_instances_id_seq'', MAX(id)) FROM bn_type_instances';

  --
  -- import expression type instances
  --

  EXECUTE 'INSERT INTO bn_expression_type_instances
           SELECT '|| moduleid ||', address, position, expression_node_id, type_instance_id
           FROM ex_'|| rawmoduleid ||'_expression_type_instances';

  PERFORM create_native_flowgraph_views(moduleid);
  PERFORM create_native_code_nodes(rawmoduleid, moduleid);
  PERFORM connect_instructions_to_code_nodes(rawmoduleid, moduleid);
  PERFORM create_native_flowgraph_edges(rawmoduleid,moduleid);
  PERFORM colorize_module_nodes(moduleid);
  SELECT * INTO viewid FROM create_native_call_graph_view(moduleid);
  PERFORM create_native_callgraph_nodes(viewid, moduleid);
  PERFORM create_native_callgraph_edges(rawmoduleid, moduleid);

  UPDATE bn_modules SET initialization_state = 2147483647 WHERE id = moduleid;

  --
  -- Enable all trigger procedures after the import.
  --

  SET session_replication_role = DEFAULT;

  ANALYZE bn_nodes;
  ANALYZE bn_code_nodes;
  ANALYZE bn_function_nodes;
  ANALYZE bn_edges;
  ANALYZE bn_functions;
  ANALYZE bn_function_views;
  ANALYZE bn_views;
  ANALYZE bn_address_references;
  ANALYZE bn_expression_substitutions;
  ANALYZE bn_instructions;
  ANALYZE bn_codenode_instructions;

  END;
$$
  LANGUAGE plpgsql VOLATILE
  COST 100;
COMMENT ON FUNCTION import(IN rawmoduleid integer, IN moduleid integer, IN userid integer)
  IS 'This function performs all necessary conversions to transform a raw module from the exporter tables into a BinNavi type module.';

--
-- load_code_nodes(IN viewid integer)
--

CREATE OR REPLACE FUNCTION load_code_nodes(
  IN viewid integer)
  RETURNS TABLE (
    module_id integer,
    instruction_address bigint,
    operand_position integer,
    view_id integer,
    node_id integer,
    parent_function bigint,
    local_code_node_comment integer,
    global_code_node_comment integer,
    local_instruction_comment integer,
    global_instruction_comment integer,
    instruction_data bytea,
    x  double precision,
    y  double precision,
    width  double precision,
    height  double precision,
    color integer,
    bordercolor integer,
    selected boolean,
    visible boolean,
    mnemonic text,
    architecture architecture_type,
    expression_tree_id integer,
    expression_tree_type integer,
    symbol text,
    immediate bigint,
    expression_tree_parent_id integer,
    replacement text,
    target bigint,
    expression_types_type integer,
    expression_types_offset integer,
    expression_types_position integer,
    expression_types_path integer[],
    address_references_type address_reference_type,
    function_address bigint,
    type_instance_id integer)
    LANGUAGE SQL AS
$$

SELECT bi.module_id AS module_id,
       bi.address AS instruction_address,
       bo.position AS operand_position,
       bv.id AS view_id,
       bn.id AS node_id,
       parent_function,
       bcn.comment_id AS local_code_node_comment,
       bgnc.comment_id AS global_code_node_comment,
       bci.comment_id AS local_instruction_comment,
       bi.comment_id AS global_instruction_comment,
       bi.data AS instruction_data,
       x,
       y,
       width,
       height,
       color,
       bordercolor,
       selected,
       visible,
       mnemonic,
       architecture,
       bet.id AS expression_tree_id,
       bet.type AS expression_tree_type,
       symbol,
       immediate,
       bet.parent_id AS expression_tree_parent_id,
       replacement,
       target,
       bety.base_type_id AS expression_types_type,
       bety.offset AS expression_types_offset,
       bety.position AS expression_types_position,
       bety.path AS expression_types_path,
       bar.type AS address_references_type,
       bf.address AS function_address,
       beti.type_instance_id AS type_instance_id

FROM bn_views as bv
JOIN bn_nodes as bn
  ON bn.view_id = bv.id
 AND bn.type = 'code'::node_type

LEFT JOIN bn_code_nodes AS bcn
       ON bcn.node_id = bn.id

LEFT JOIN bn_codenode_instructions AS bci
       ON bci.module_id = bcn.module_id
      AND bci.node_id = bcn.node_id

LEFT JOIN bn_global_node_comments AS bgnc
       ON bgnc.module_id = bci.module_id
      AND bgnc.address = bci.address

LEFT JOIN bn_instructions AS bi
       ON bi.module_id = bci.module_id
      AND bi.address = bci.address

LEFT JOIN bn_operands AS bo
       ON bo.module_id = bi.module_id
      AND bo.address = bi.address

LEFT JOIN bn_expression_tree_mapping AS betm
       ON betm.module_id = bo.module_id
      AND betm.tree_id = bo.expression_tree_id

LEFT JOIN bn_expression_tree AS bet
       ON bet.module_id = betm.module_id
      and bet.id = betm.tree_node_id

LEFT JOIN bn_address_references AS bar
       ON bar.module_id = betm.module_id
      AND bar.address = bi.address
      AND bar.position = bo.position
      AND bar.expression_id = bet.id

LEFT JOIN bn_expression_substitutions AS bes
       ON bes.module_id = bet.module_id
      AND bes.address = bi.address
      AND bes.position = bo.position
      AND bes.expression_id = bet.id

LEFT JOIN bn_expression_types AS bety
       ON bety.module_id = bet.module_id
      AND bety.address = bi.address
      AND bety.expression_id = bet.id

LEFT JOIN bn_functions AS bf
       ON bf.module_id = bet.module_id
      AND bf.address = bet.immediate

LEFT JOIN bn_expression_type_instances AS beti
       ON beti.module_id = bet.module_id
      AND beti.address = bi.address
      AND beti.position = bo.position
      AND beti.expression_id = bet.id

WHERE bv.id = $1

ORDER BY bn.id, bci.position, bo.position, bet.position, bet.id;

$$;
COMMENT ON FUNCTION load_code_nodes(
  IN viewid integer)
  IS 'Loads the code nodes for a view.';

--
-- load_function_information(IN moduleid integer, IN address bigint)
--

CREATE OR REPLACE FUNCTION load_function_information(IN moduleid integer, IN address bigint)
  RETURNS TABLE(
    view_id integer,
    address bigint,
    name text,
    original_name text,
    description text,
    bbcount bigint,
    edgecount bigint,
    incount bigint,
    outcount bigint,
    global_comment integer,
    type function_type,
    parent_module_name text,
    parent_module_id integer,
    parent_module_function integer,
    stack_frame integer,
    prototype integer)
  LANGUAGE SQL AS
$$

WITH function_block_count AS (
  SELECT function, count(nt.id) AS bbcount FROM bn_views AS vt
    LEFT JOIN bn_function_views AS fvt ON vt.id = fvt.view_id
    LEFT JOIN bn_nodes AS nt ON nt.view_id = vt.id
    WHERE fvt.module_id = $1 AND function = $2
    GROUP BY fvt.function
), function_edge_count AS (
  SELECT function, count(et.id) AS edgecount FROM bn_views AS vt
    LEFT JOIN bn_function_views AS fvt ON vt.id = fvt.view_id
    LEFT JOIN bn_nodes AS nt ON nt.view_id = vt.id
    LEFT JOIN bn_edges AS et ON source_node_id = nt.id
    WHERE fvt.module_id = $1 AND function = $2
    GROUP BY function
), function_in_count AS (
  SELECT function, COUNT(source_node_id) AS incount FROM bn_views AS vt
    JOIN bn_nodes AS nt ON nt.view_id = vt.id
    JOIN bn_function_nodes AS fnt ON nt.id = fnt.node_id
    LEFT JOIN bn_edges ON target_node_id = fnt.node_id
    WHERE vt.type = 'native' AND module_id = $1 AND function = $2
    GROUP BY function
), function_out_count AS (
  SELECT function, COUNT(target_node_id) AS outcount FROM bn_views AS vt
    JOIN bn_nodes AS nt ON nt.view_id = vt.id
    JOIN bn_function_nodes AS fnt ON nt.id = fnt.node_id
    LEFT JOIN bn_edges ON source_node_id = fnt.node_id
    WHERE vt.type = 'native' AND module_id = $1 AND function = $2
    GROUP BY function
)
SELECT view_id, ft.address, name, original_name, description,
bc.bbcount, ec.edgecount, ic.incount, oc.outcount,
 comment_id AS global_comment, type, parent_module_name,
 parent_module_id, parent_module_function, stack_frame FROM bn_functions AS ft
 JOIN bn_function_views AS fviews ON fviews.module_id = ft.module_id
  AND function = ft.address
 JOIN function_block_count AS bc ON bc.function = ft.address
 JOIN function_edge_count AS ec ON ec.function = ft.address
 JOIN function_in_count AS ic ON ic.function = ft.address
 JOIN function_out_count AS oc ON oc.function = ft.address
 WHERE ft.module_id = $1 AND ft.address = $2

$$;
COMMENT ON FUNCTION load_function_information(IN moduleid integer, IN address bigint)
  IS 'This function provides the information about a single view / function information stored in the database.';

--
-- load_function_information(IN moduleid integer)
--

CREATE OR REPLACE FUNCTION load_function_information(IN moduleid integer)
  RETURNS TABLE(
    view_id integer,
    address bigint,
    name text,
    original_name text,
    description text,
    bbcount bigint,
    edgecount bigint,
    incount bigint,
    outcount bigint,
    global_comment integer,
    type function_type,
    parent_module_name text,
    parent_module_id integer,
    parent_module_function integer,
    stack_frame integer,
    prototype integer) AS
$$

WITH function_block_count AS (
  SELECT function, count(nt.id) AS bbcount FROM bn_views AS vt
    LEFT JOIN bn_function_views AS fvt ON vt.id = fvt.view_id
    LEFT JOIN bn_nodes AS nt ON nt.view_id = vt.id
    WHERE fvt.module_id = $1
    GROUP BY fvt.function
), function_edge_count AS (
  SELECT function, count(et.id) AS edgecount FROM bn_views AS vt
    LEFT JOIN bn_function_views AS fvt ON vt.id = fvt.view_id
    LEFT JOIN bn_nodes AS nt ON nt.view_id = vt.id
    LEFT JOIN bn_edges AS et ON source_node_id = nt.id
    WHERE fvt.module_id = $1
    GROUP BY function
), function_in_count AS (
  SELECT function, COUNT(source_node_id) AS incount FROM bn_views AS vt
    JOIN bn_nodes AS nt ON nt.view_id = vt.id
    JOIN bn_function_nodes AS fnt ON nt.id = fnt.node_id
    LEFT JOIN bn_edges ON target_node_id = fnt.node_id
    WHERE vt.type = 'native' AND module_id = $1
    GROUP BY function
), function_out_count AS (
  SELECT function, COUNT(target_node_id) AS outcount FROM bn_views AS vt
    JOIN bn_nodes AS nt ON nt.view_id = vt.id
    JOIN bn_function_nodes AS fnt ON nt.id = fnt.node_id
    LEFT JOIN bn_edges ON source_node_id = fnt.node_id
    WHERE vt.type = 'native' and module_id = $1
    GROUP BY function
)
SELECT view_id, ft.address, name, original_name, description,
bc.bbcount, ec.edgecount, ic.incount, oc.outcount,
 comment_id AS global_comment, type, parent_module_name,
 parent_module_id, parent_module_function, stack_frame, prototype FROM bn_functions AS ft
 JOIN bn_function_views AS fviews ON fviews.module_id = ft.module_id
  AND function = ft.address
 JOIN function_block_count AS bc ON bc.function = ft.address
 JOIN function_edge_count AS ec ON ec.function = ft.address
 JOIN function_in_count AS ic ON ic.function = ft.address
 JOIN function_out_count AS oc ON oc.function = ft.address
 WHERE ft.module_id = $1
 ORDER BY ft.address

$$
  LANGUAGE SQL;
COMMENT ON FUNCTION load_function_information(IN moduleid integer)
  IS 'This function provides the information about all view / function information stored in the database under a specific module id.';

--
-- load_project_flowgraph(IN projectid integer, IN viewid integer)
--

CREATE OR REPLACE FUNCTION load_project_flowgraph(IN projectid integer, IN viewid integer)
  RETURNS TABLE(
    view_id integer,
    name text,
    description text,
    type view_type,
    creation_date timestamp without time zone,
    modification_date timestamp without time zone,
    stared boolean,
    bbcount bigint,
    edgecount bigint,
    type_count bigint,
    node_type node_type) AS
$$

  SELECT vt.id AS view_id, name, description, vt.type AS type, creation_date, modification_date, stared,
    COUNT(DISTINCT(nt.id)) AS bbcount, COUNT(et.id) AS edgecount, COUNT(DISTINCT(nt.type)) AS type_count,
    nt.type AS node_type
    FROM bn_views AS vt
    JOIN bn_project_views AS pvt ON vt.id = pvt.view_id
    LEFT JOIN bn_nodes AS nt ON vt.id = nt.view_id
    LEFT JOIN bn_edges AS et ON nt.id = et.source_node_id
      WHERE vt.type = 'non-native'
        AND vt.id = $2
        AND pvt.project_id = $1
        AND nt.type in ('code', 'function')
      GROUP BY vt.id, nt.type
      HAVING COUNT(DISTINCT(nt.type)) = 1 AND nt.type = 'code'
      ORDER BY vt.id
$$
  LANGUAGE SQL;
COMMENT ON FUNCTION load_project_flowgraph(IN projectid integer, IN viewid integer)
  IS 'This function loads project view specific configuration information from the database.';

--
-- load_module_call_graph(IN moduleid integer, IN viewtype view_type)
--

CREATE OR REPLACE FUNCTION load_module_call_graph(IN moduleid integer, IN viewtype view_type)
  RETURNS TABLE(
    view_id integer,
    name text,
    description text,
    type view_type,
    creation_date timestamp without time zone,
    modification_date timestamp without time zone,
    stared boolean,
    bbcount bigint,
    edgecount bigint,
    type_count bigint,
    node_type node_type) AS
$$
SELECT vt.id AS view_id, name, description, vt.type AS type, creation_date, modification_date, stared,
  COUNT(DISTINCT(nt.id)) AS bbcount,
  COUNT(et.id) AS edgecount,
  COUNT(DISTINCT(nt.type)) AS type_count,
  nt.type AS node_type
FROM bn_views AS vt
JOIN bn_module_views AS mvt ON vt.id = mvt.view_id
LEFT JOIN bn_nodes AS nt ON vt.id = nt.view_id
LEFT JOIN bn_edges AS et ON nt.id = et.source_node_id
  WHERE vt.type = $2 AND mvt.module_id = $1
GROUP BY vt.id, nt.type
HAVING COUNT(DISTINCT(nt.type)) = 1
  AND nt.type = 'function'
ORDER BY vt.id;
$$
  LANGUAGE SQL;
COMMENT ON FUNCTION load_module_call_graph(IN moduleid integer, IN viewtype view_type)
  IS 'This function loads module call graph information. But not the call graph itself.';

--
-- load_project_call_graph(IN projectid int)
--

CREATE OR REPLACE FUNCTION load_project_call_graph(IN projectid int)
RETURNS TABLE(
    view_id int,
    name text,
    description text,
    type view_type,
    creation_date timestamp,
    modification_date timestamp,
    stared boolean,
    bbcount bigint,
    edgecount bigint,
    type_count bigint,
    node_type node_type) AS
$$
SELECT vt.id AS view_id, name, description,  vt.type AS type, creation_date, modification_date, stared,
  count(DISTINCT(nt.id)) AS bbcount,
  count(et.id) AS edgecount,
  count(DISTINCT(nt.type)) AS type_count, nt.type AS node_type
FROM bn_views AS vt
JOIN bn_project_views AS pvt ON vt.id = pvt.view_id
LEFT JOIN bn_nodes AS nt ON vt.id = nt.view_id
LEFT JOIN bn_edges AS et ON nt.id = et.source_node_id
  WHERE pvt.project_id = $1
GROUP BY vt.id, nt.type
HAVING COUNT(DISTINCT(nt.type)) = 1
  AND nt.type = 'function'
ORDER BY vt.id;

$$ LANGUAGE SQL;
COMMENT ON FUNCTION load_project_call_graph(IN projectid int)
  IS 'This function loads project call graph information. But not the call graph itself.';

--
-- get_derived_views(IN viewid integer)
--

CREATE OR REPLACE FUNCTION get_derived_views(IN viewid integer)
RETURNS integer AS $$

SELECT vt.id FROM bn_codenode_instructions AS cit
  JOIN (
    SELECT cit.address FROM bn_views AS vt
      JOIN bn_nodes AS nt ON vt.id = nt.view_id
      JOIN bn_codenode_instructions AS cit ON nt.id = cit.node_id
    WHERE vt.id = $1
  ) AS a ON cit.address = a.address
  JOIN bn_nodes AS nt ON cit.node_id = nt.id
  JOIN bn_views AS vt ON vt.id = nt.view_id
  WHERE vt.type = 'non-native' GROUP by vt.id;

$$ LANGUAGE SQL;
COMMENT ON FUNCTION get_derived_views(IN viewid integer)
  IS 'This function retrieves the views from the database which have been derived from the given view.';

--
-- create_native_call_graph_view(IN moduleid int)
--

CREATE OR REPLACE FUNCTION create_native_call_graph_view(IN moduleid integer)
RETURNS int AS $$

WITH callgraphid AS (
  INSERT INTO bn_views
    (type, name, description, creation_date, modification_date)
    VALUES('native', 'Native Callgraph', null, NOW(), NOW())
    RETURNING id
)
INSERT INTO bn_module_views (view_id, module_id)
  SELECT id, $1 FROM callgraphid
  RETURNING view_id;

$$ LANGUAGE SQL;
COMMENT ON FUNCTION create_native_call_graph_view(IN moduleid integer)
  IS 'This function creates the native call graph information and updates the tables accordingly.';

--
-- create_native_flowgraph_views(IN moduleid integer)
--

CREATE OR REPLACE FUNCTION create_native_flowgraph_views(IN moduleid integer)
  RETURNS void AS
$$

WITH allinfo AS (
  SELECT nextval('bn_views_id_seq') AS id, address, COALESCE(name, original_name) AS name
  FROM bn_functions WHERE module_id = $1
), views AS (
  INSERT INTO bn_views(id, type, name, description)
  SELECT id, 'native', name, null FROM allinfo
), function_views AS (
  INSERT INTO bn_function_views
  SELECT $1, id, address FROM allinfo
)
INSERT INTO bn_module_views (view_id, module_id)
  SELECT id, $1 FROM allinfo

$$ LANGUAGE SQL;
COMMENT ON FUNCTION create_native_flowgraph_views(IN moduleid integer)
  IS 'This function creates the native flowgraph information in the database during a conversion and updates the related tables accordingly.';

--
-- create_native_flowgraph_edges(IN rawmoduleid integer, IN moduleid integer)
--

CREATE OR REPLACE FUNCTION create_native_flowgraph_edges(IN rawmoduleid integer, IN moduleid integer)
  RETURNS void AS
$$
  DECLARE
    minnodeid int;
  BEGIN
    SELECT MIN(node_id) INTO minnodeid
      FROM bn_code_nodes
     WHERE module_id = moduleid;

  EXECUTE 'INSERT INTO bn_edges
  (source_node_id, target_node_id, x1, y1, x2, y2, type, color, visible, selected, comment_id)
  SELECT fg.source + '|| minnodeid ||' - 1 AS source,
         fg.destination + '|| minnodeid ||' - 1 AS target, 0, 0, 0, 0,
  (ENUM_RANGE(NULL::edge_type))[fg.type + 1], 0, true, false, null
  FROM ex_'|| rawmoduleid ||'_control_flow_graphs AS fg';

  END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION create_native_flowgraph_edges(IN rawmoduleid integer, IN moduleid integer)
  IS 'This function creates the edges in the native flowgraphs during a rawmodule to module converstion.';

--
-- colorize_module_nodes(IN moduleid integer)
--

CREATE OR REPLACE FUNCTION colorize_module_nodes(IN moduleid integer) RETURNS void
  LANGUAGE sql
  AS $$
  WITH entry_nodes AS (
    SELECT bn_nodes.id AS nodes_id FROM bn_nodes
      JOIN bn_module_views ON bn_nodes.view_id = bn_module_views.view_id
      AND bn_module_views.module_id = $1
      LEFT JOIN bn_edges ON bn_nodes.id = bn_edges.target_node_id
      WHERE target_node_id IS NULL
      AND bn_nodes.type = 'code'
    ), exit_nodes AS (
    SELECT bn_nodes.id AS nodes_id FROM bn_nodes
      JOIN bn_module_views ON bn_nodes.view_id = bn_module_views.view_id
      AND bn_module_views.module_id = $1
      LEFT JOIN bn_edges ON bn_nodes.id = bn_edges.source_node_id
      WHERE source_node_id IS NULL
      AND bn_nodes.type = 'code'
    ), single_nodes AS (
    SELECT nodes_id FROM entry_nodes INTERSECT SELECT nodes_id from exit_nodes
    ), update_entry_nodes AS (
    UPDATE bn_nodes SET bordercolor = -16736256 WHERE bn_nodes.id IN
      (SELECT * FROM entry_nodes)
    ), update_exit_nodes AS (
    UPDATE bn_nodes SET bordercolor = -6291456 WHERE bn_nodes.id IN
      (SELECT * FROM exit_nodes)
    )
  UPDATE bn_nodes SET bordercolor = -6250496 WHERE bn_nodes.id IN
    (SELECT * FROM single_nodes);
$$;
COMMENT ON FUNCTION colorize_module_nodes(IN moduleid integer)
  IS 'This function creates the initial colors for nodes of a module that is getting converted.';

--
-- load_module_flowgraph_information(IN moduleid integer, IN viewid integer)
--

CREATE OR REPLACE FUNCTION load_module_flowgraph_information(IN moduleid integer, IN viewid integer)
  RETURNS TABLE(view_id integer, name text, description text, type view_type, creation_date timestamp without time zone, modification_date timestamp without time zone, stared boolean, bbcount bigint, edgecount bigint, type_count bigint, node_type node_type) AS
$$

  SELECT vt.id AS view_id, name, description, vt.type AS type, creation_date, modification_date, stared,
    COUNT(DISTINCT(nt.id)) AS bbcount, COUNT(et.id) AS edgecount, COUNT(DISTINCT(nt.type)) AS type_count,
    nt.type AS node_type
    FROM bn_views AS vt
    JOIN bn_module_views AS mvt ON vt.id = mvt.view_id
    LEFT JOIN bn_nodes AS nt ON vt.id = nt.view_id
    LEFT JOIN bn_edges AS et ON nt.id = et.source_node_id
      WHERE vt.id = $2
        AND mvt.module_id = $1
        AND (nt.type IN ('code', 'function') OR nt.type IS NULL)
      GROUP BY vt.id, nt.type

$$ LANGUAGE SQL;
COMMENT ON FUNCTION load_module_flowgraph_information(IN moduleid integer, IN viewid integer)
  IS 'This function loads aggregated information about a specific view / function from the database.';

--
-- load_module_node_tags(IN moduleid integer)
--

CREATE OR REPLACE FUNCTION load_module_node_tags(IN moduleid integer)
  RETURNS TABLE (view_id int, tag_id int) AS $$

  SELECT nt.view_id, tnt.tag_id FROM bn_tagged_nodes AS tnt
        JOIN bn_nodes AS nt ON node_id = nt.id
        JOIN bn_module_views AS mvt ON mvt.view_id = nt.view_id
      WHERE mvt.module_id = $1
      GROUP BY nt.view_id, tnt.tag_id
      ORDER BY nt.view_id;

$$ LANGUAGE SQL;
COMMENT ON FUNCTION load_module_node_tags(IN moduleid integer)
  IS 'Loads the node tags for the module given as argument.';

--
-- load_project_node_tags(IN projectid integer)
--

CREATE OR REPLACE FUNCTION load_project_node_tags(IN projectid integer)
  RETURNS TABLE (view_id int, tag_id int) AS $$

  SELECT nt.view_id, tnt.tag_id FROM bn_tagged_nodes AS tnt
        JOIN bn_nodes AS nt ON node_id = nt.id
        JOIN bn_project_views AS pvt ON pvt.view_id = nt.view_id
      WHERE pvt.project_id = $1
      GROUP BY nt.view_id, tnt.tag_id
      ORDER BY nt.view_id;

$$ LANGUAGE SQL;
COMMENT ON FUNCTION load_project_node_tags(IN moduleid integer)
  IS 'Loads the node tags for the project given as argument.';

--
-- load_module_mixed_graph(IN moduleid integer)
--

CREATE OR REPLACE FUNCTION load_module_mixed_graph(IN moduleid integer)
  RETURNS TABLE(view_id int, name text, description text, type view_type, creation_date timestamp,
  modification_date timestamp, stared boolean, bbcount bigint, edgecount bigint, type_count bigint) AS $$

  SELECT vt.id AS view_id, name, description, vt.type AS type, creation_date, modification_date, stared,
    COUNT(DISTINCT(nt.id)) AS bbcount, COUNT(et.id) AS edgecount, COUNT(DISTINCT(nt.type)) AS type_count
    FROM bn_views AS vt
    JOIN bn_module_views AS mvt ON vt.id = mvt.view_id
    LEFT JOIN bn_nodes AS nt ON vt.id = nt.view_id
    LEFT JOIN bn_edges AS et ON nt.id = et.source_node_id
      WHERE vt.type = 'non-native' AND mvt.module_id = $1
      GROUP BY vt.id
      HAVING COUNT(DISTINCT(nt.type)) = 2

$$ LANGUAGE SQL;
COMMENT ON FUNCTION load_module_mixed_graph(IN moduleid integer)
  IS 'This function loads all mixed graph information for the specified module from the database.';

--
-- load_project_mixed_graph(IN projectid integer)
--

CREATE OR REPLACE FUNCTION load_project_mixed_graph(IN projectid integer)
  RETURNS TABLE(view_id int, name text, description text, type view_type, creation_date timestamp,
  modification_date timestamp, stared boolean, bbcount bigint, edgecount bigint, type_count bigint) AS $$

  SELECT vt.id AS view_id, name, description, vt.type AS type, creation_date, modification_date, stared,
    COUNT(DISTINCT(nt.id)) AS bbcount, COUNT(et.id) AS edgecount, COUNT(DISTINCT(nt.type)) AS type_count
    FROM bn_views AS vt
    JOIN bn_project_views AS mvt ON vt.id = pvt.view_id
    LEFT JOIN bn_nodes AS nt ON vt.id = nt.view_id
    LEFT JOIN bn_edges AS et ON nt.id = et.source_node_id
      WHERE vt.type = 'non-native' AND pvt.project_id = $1
      GROUP BY vt.id
      HAVING COUNT(DISTINCT(nt.type)) in (0,2)

$$ LANGUAGE SQL;
COMMENT ON FUNCTION load_project_mixed_graph(IN projectid integer)
  IS 'This function loads all mixed graph information for the specified project from the database.';

--
-- load_module_flow_graphs(IN moduleid integer, IN viewtype view_type)
--

CREATE OR REPLACE FUNCTION load_module_flow_graphs(IN moduleid integer, IN viewtype view_type)
  RETURNS TABLE(view_id integer, name text, description text, type view_type, creation_date timestamp without time zone,
  modification_date timestamp without time zone, stared boolean, bbcount bigint, edgecount bigint, type_count bigint,
  node_type node_type) AS
$$

  SELECT vt.id AS view_id, name, description, vt.type AS type, creation_date, modification_date, stared,
    COUNT(DISTINCT(nt.id)) AS bbcount, COUNT(et.id) AS edgecount, COUNT(DISTINCT(nt.type)) AS type_count,
    MAX(nt.type) AS node_type
	FROM bn_views AS vt
	JOIN bn_module_views AS mvt ON vt.id = mvt.view_id
	LEFT JOIN bn_nodes AS nt ON vt.id = nt.view_id
	LEFT JOIN bn_edges AS et ON nt.id = et.source_node_id
      WHERE vt.type = $2
      AND mvt.module_id = $1
    GROUP BY vt.id
      HAVING COUNT(DISTINCT(nt.type)) <= 1
      AND MAX(nt.type) = 'code' OR MAX(nt.type) is null

$$ LANGUAGE SQL;
COMMENT ON FUNCTION load_module_flow_graphs(IN moduleid integer, IN viewtype view_type)
  IS 'This function loads flow graph type graphs for a module.';

--
-- load_module_call_graphs(IN moduleid integer, IN viewtype view_type)
--

CREATE OR REPLACE FUNCTION load_module_call_graphs(IN moduleid integer, IN viewtype view_type)
  RETURNS TABLE(view_id integer, name text, description text, type view_type, creation_date timestamp without time zone,
  modification_date timestamp without time zone, stared boolean, bbcount bigint, edgecount bigint, type_count bigint,
  node_type node_type) AS
$$

  SELECT vt.id AS view_id, name, description, vt.type AS type, creation_date, modification_date, stared,
    COUNT(DISTINCT(nt.id)) AS bbcount, COUNT(et.id) AS edgecount, COUNT(DISTINCT(nt.type)) AS type_count,
    MAX(nt.type) AS node_type
FROM bn_views AS vt
JOIN bn_module_views AS mvt ON vt.id = mvt.view_id
LEFT JOIN bn_nodes AS nt ON vt.id = nt.view_id
LEFT JOIN bn_edges AS et ON nt.id = et.source_node_id
  WHERE vt.type = $2
    AND mvt.module_id = $1
  GROUP BY vt.id
    HAVING COUNT(DISTINCT(nt.type)) = 1
    AND MAX(nt.type) = 'function'

$$ LANGUAGE sql;
COMMENT ON FUNCTION load_module_call_graphs(IN moduleid integer, IN viewtype view_type)
  IS 'This function loads call graph type graphs for a module.';

--
-- load_project_flow_graphs(IN moduleid integer, IN viewtype view_type)
--

CREATE OR REPLACE FUNCTION load_project_flow_graphs(IN projectid integer, IN viewtype view_type)
  RETURNS TABLE(view_id integer, name text, description text, type view_type, creation_date timestamp without time zone,
  modification_date timestamp without time zone, stared boolean, bbcount bigint, edgecount bigint, type_count bigint,
  node_type node_type) AS
$$

  SELECT vt.id AS view_id, name, description, vt.type AS type, creation_date, modification_date, stared,
    COUNT(DISTINCT(nt.id)) AS bbcount, COUNT(et.id) AS edgecount, COUNT(DISTINCT(nt.type)) AS type_count,
    MAX(nt.type) AS node_type
	FROM bn_views AS vt
	JOIN bn_project_views AS pvt ON vt.id = pvt.view_id
	LEFT JOIN bn_nodes AS nt ON vt.id = nt.view_id
	LEFT JOIN bn_edges AS et ON nt.id = et.source_node_id
      WHERE vt.type = $2
      AND pvt.project_id = $1
    GROUP BY vt.id
      HAVING COUNT(DISTINCT(nt.type)) <= 1
      AND MAX(nt.type) = 'code' OR MAX(nt.type) is null

$$ LANGUAGE SQL;
COMMENT ON FUNCTION load_project_flow_graphs(IN projectid integer, IN viewtype view_type)
  IS 'This function loads flow graph type graphs for a project.';

--
-- load_project_call_graphs(IN moduleid integer, IN viewtype view_type)
--

CREATE OR REPLACE FUNCTION load_project_call_graphs(IN projectid integer, IN viewtype view_type)
  RETURNS TABLE(view_id integer, name text, description text, type view_type, creation_date timestamp without time zone,
  modification_date timestamp without time zone, stared boolean, bbcount bigint, edgecount bigint, type_count bigint,
  node_type node_type) AS
$$

  SELECT vt.id AS view_id, name, description, vt.type AS type, creation_date, modification_date, stared,
    COUNT(DISTINCT(nt.id)) AS bbcount, COUNT(et.id) AS edgecount, COUNT(DISTINCT(nt.type)) AS type_count,
    MAX(nt.type) AS node_type
FROM bn_views AS vt
JOIN bn_project_views AS pvt ON vt.id = pvt.view_id
LEFT JOIN bn_nodes AS nt ON vt.id = nt.view_id
LEFT JOIN bn_edges AS et ON nt.id = et.source_node_id
  WHERE vt.type = $2
    AND pvt.project_id = $1
  GROUP BY vt.id
    HAVING COUNT(DISTINCT(nt.type)) = 1
    AND MAX(nt.type) = 'function'

$$ LANGUAGE sql;
COMMENT ON FUNCTION load_project_call_graphs(IN projectid integer, IN viewtype view_type)
  IS 'This function loads call graph type graphs for a project.';


--
-- connect_instructions_to_code_nodes(IN rawmoduleid integer, IN moduleid integer)
--

CREATE OR REPLACE FUNCTION connect_instructions_to_code_nodes(IN rawmoduleid integer, IN moduleid integer)
  RETURNS void AS
$$
DECLARE
    minnodeid int;
  BEGIN
    SELECT MIN(node_id) INTO minnodeid
      FROM bn_code_nodes
     WHERE module_id = moduleid;

  EXECUTE 'INSERT INTO bn_codenode_instructions
             (module_id, node_id, position, address, comment_id)
             SELECT '|| moduleid ||', basic_block_id + '|| minnodeid ||' - 1 AS nodeId,
               bbi.sequence, bbi.instruction, null
             FROM ex_'|| rawmoduleid ||'_basic_block_instructions AS bbi';

  END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION connect_instructions_to_code_nodes(IN rawmoduleid integer, IN moduleid integer)
  IS 'This function connects the instruction to code nodes in the conversion from a raw module to a BinNavi module.';

--
-- create_native_callgraph_edges(IN rawmoduleid integer, IN moduleid integer)
--

CREATE OR REPLACE FUNCTION create_native_callgraph_edges(IN rawmoduleid integer, IN moduleid integer)
  RETURNS void AS
$$
  BEGIN
    EXECUTE 'DROP INDEX IF EXISTS ex_'|| rawmoduleid ||'_callgraph_source_idx';
    EXECUTE 'DROP INDEX IF EXISTS ex_'|| rawmoduleid ||'_callgraph_destination_idx';
    EXECUTE 'CREATE INDEX ex_'|| rawmoduleid ||'_callgraph_source_idx
             ON ex_'|| rawmoduleid ||'_callgraph USING btree(source)';
    EXECUTE 'CREATE INDEX ex_'|| rawmoduleid ||'_callgraph_destination_idx
             ON ex_'|| rawmoduleid ||'_callgraph USING btree(destination)';

    EXECUTE 'INSERT INTO bn_edges
      (source_node_id, target_node_id, x1, y1, x2, y2, type, color, selected, visible, comment_id)
      SELECT source_function.node_id, destination_function.node_id, 0, 0, 0, 0, ''jump_unconditional'', 0, false, true, null
        FROM ex_'|| rawmoduleid ||'_callgraph AS callgraph
      INNER JOIN bn_function_nodes AS source_function ON source_function.module_id = '|| moduleid ||'
        AND source_function.function = callgraph.source
      INNER JOIN bn_function_nodes as destination_function ON destination_function.module_id = '|| moduleid ||'
        AND destination_function.function = callgraph.destination';

  END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION create_native_callgraph_edges(IN rawmoduleid integer, IN moduleid integer)
  IS 'This function creates the edges for the native call graph of a module.';

--
-- create_native_code_nodes(IN rawmoduleid integer, IN moduleid integer)
--

CREATE OR REPLACE FUNCTION create_native_code_nodes(IN rawmoduleid integer, IN moduleid integer)
 RETURNS void AS
$$
  DECLARE
    minnodeid int;
  BEGIN
    EXECUTE 'DROP INDEX IF EXISTS ex_'|| rawmoduleid ||'_basic_blocks_parent_function_idx';
    EXECUTE 'CREATE INDEX ex_'|| rawmoduleid ||'_basic_blocks_parent_function_idx
             ON ex_'|| rawmoduleid ||'_basic_blocks USING btree(parent_function)';

    EXECUTE 'INSERT INTO bn_nodes
            (view_id, parent_id, type, x, y, width, height, color, selected, visible)
            SELECT view_id, null, ''code'', 0, 0, 0, 0, 0, false, true
              FROM ex_'|| rawmoduleid ||'_basic_blocks as basic_blocks
            INNER JOIN bn_functions AS functions ON functions.module_id = '|| moduleid ||'
              AND functions.address = basic_blocks.parent_function
              AND functions.type != ''import''
            INNER JOIN bn_function_views AS fvt ON fvt.module_id = '|| moduleid ||'
              AND fvt.function = basic_blocks.parent_function
              ORDER BY id
            RETURNING id' INTO minnodeid;

     INSERT INTO bn_code_nodes SELECT moduleid, nt.id, function, null
     FROM bn_function_views AS fvt
       INNER JOIN bn_nodes AS nt ON nt.view_id = fvt.view_id AND nt.type = 'code'
         AND nt.id >= minnodeid WHERE fvt.module_id = moduleid;

  END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION create_native_code_nodes(IN rawmoduleid integer, IN moduleid integer)
  IS 'This function creates the code nodes for all native flow graphs in a raw module to BinNavi module conversion.';

--
-- create_native_callgraph_nodes(IN viewid integer, IN moduleid integer)
--

CREATE OR REPLACE FUNCTION create_native_callgraph_nodes(IN viewid integer, IN moduleid integer)
  RETURNS void AS
$$
WITH allinfo AS (
  SELECT nextval('bn_nodes_id_seq'::regclass) as id ,$1 as view_id, address, $2 as module_id
    FROM bn_functions WHERE module_id = $2
), ni AS (
  INSERT INTO bn_nodes
    (id, view_id, parent_id, type, x, y, width, height, color, selected, visible)
    SELECT id, view_id, null, 'function', 0, 0, 0, 0, 0, false, true FROM allinfo
)
INSERT INTO bn_function_nodes
  (node_id, module_id, function, comment_id)
  SELECT id, module_id, address, null FROM allinfo
$$ LANGUAGE SQL;
COMMENT ON FUNCTION create_native_callgraph_nodes(IN viewid integer, IN moduleid integer)
  IS 'This function creates the function nodes for the native call graph in a raw module to BinNavi module conversion.';

--
-- create_module(IN rawmoduleid integer)
--

CREATE OR REPLACE FUNCTION create_module(IN rawmoduleid integer)
  RETURNS int AS
$$
INSERT INTO bn_modules
  (name, raw_module_id, md5, sha1, description, file_base, image_base, import_time)
  (SELECT name, id, md5, sha1, comment, base_address, base_address, NOW()
  FROM modules WHERE id = $1) RETURNING id
$$ LANGUAGE SQL;
COMMENT ON FUNCTION create_module(IN rawmoduleid integer)
  IS 'This function creates the entry in the BinNavi modules table in a raw module to BinNavi module conversion.';

--
-- set_section_name(IN moduleid integer, IN sectionid integer, IN newname text)
--

CREATE OR REPLACE FUNCTION set_section_name(IN moduleid integer, IN sectionid integer, IN newname text)
    RETURNS void AS $$

    UPDATE bn_sections
       SET name = $3
     WHERE module_id = $1
       AND id = $2

$$ LANGUAGE SQL;
COMMENT ON FUNCTION set_section_name(IN moduleid integer, IN sectionid integer, IN newname text)
  IS 'This function creates a new entry in the section table of BinNavi and returns the id of the entry.';

--
-- get_sections(IN moduleid integer)
--

CREATE OR REPLACE FUNCTION get_sections(IN moduleid integer)
    RETURNS TABLE (module_id integer, id integer, name text, comment_id integer, start_address bigint,
                   end_address bigint, permission permission_type, data bytea) AS $$

    SELECT *
      FROM bn_sections
     WHERE module_id = $1;

$$ LANGUAGE SQL;
COMMENT ON FUNCTION get_sections(IN moduleid integer)
  IS 'This function returns all sections associated with the given module id.';

--
-- create_section(IN moduleid integer, name text, comment_id integer, start_address bigint, end_address bigint, permission permission_type, data bytea)
--

CREATE OR REPLACE FUNCTION create_section(IN moduleid integer, name text, comment_id integer, start_address bigint, end_address bigint, permission permission_type, data bytea)
    RETURNS integer AS $$

    INSERT INTO bn_sections (module_id, name, comment_id, start_address, end_address, permission, data)
         VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING id;

$$ LANGUAGE SQL;
COMMENT ON FUNCTION create_section(IN moduleid integer, name text, comment_id integer, start_address bigint,
                   end_address bigint, permission permission_type, data bytea)
  IS 'This function creates a new section and returns its id';

--
-- delete_section(IN moduleid integer, IN sectionid integer)
--

CREATE OR REPLACE FUNCTION delete_section(IN moduleid integer, IN sectionid integer)
	RETURNS void AS $$

	DELETE
	 FROM bn_sections
	 WHERE module_id = $1
	 AND id = $2;

$$ LANGUAGE SQL;
COMMENT ON FUNCTION delete_section(IN moduleid integer, IN sectionid integer)
  IS 'This function deletes a section.';

--
-- delete_expression_type_instance(IN moduleid integer, IN address bigint, IN "position" integer, IN expressionid integer)
--

CREATE OR REPLACE FUNCTION delete_expression_type_instance(IN moduleid integer, IN address bigint, IN "position" integer, IN expressionid integer)
    RETURNS void AS $$

    DELETE
     FROM bn_expression_type_instances
     WHERE module_id = $1
       AND address = $2
       AND "position" = $3
       AND expression_id = $4;

$$ LANGUAGE SQL;
COMMENT ON FUNCTION delete_expression_type_instance(IN moduleid integer, IN address bigint, IN "position" integer, IN expressionid integer)
  IS 'This function deletes a expression type instance (cross reference).';

--
-- delete_type_instance(IN moduleid integer, IN typeinstanceid integer)
--

CREATE OR REPLACE FUNCTION delete_type_instance(IN moduleid integer, IN typeinstanceid integer)
	RETURNS void AS $$

	DELETE
     FROM bn_type_instances
     WHERE module_id = $1
     AND id = $2;

$$ LANGUAGE SQL;
COMMENT ON FUNCTION delete_type_instance(IN moduleid integer, IN typeinstanceid integer)
  IS 'This function delete a type instance.';

--
-- load_expression_type_instances(IN moduleid integer)
--

CREATE OR REPLACE FUNCTION load_expression_type_instances(
    IN moduleid integer)
	RETURNS TABLE(
        view_id integer,
        module_id integer,
        address bigint,
        "position" integer,
        expression_id integer,
        type_instance_id integer)
        LANGUAGE SQL AS
$$

SELECT bv.id AS view_id, beti.module_id, beti.address, beti.position, beti.expression_id, beti.type_instance_id
  FROM bn_views AS bv
  JOIN bn_nodes AS bn
	ON bn.view_id = bv.id
   AND bn.type = 'code'::node_type
  LEFT JOIN bn_code_nodes AS bcn
         ON bcn.node_id = bn.id
  LEFT JOIN bn_codenode_instructions AS bcni
         ON bcni.module_id = bcn.module_id
        AND bcni.node_id = bcn.node_id
  LEFT JOIN bn_instructions AS bi
         ON bi.module_id = bcni.module_id
        AND bi.address = bcni.address
  JOIN bn_expression_type_instances AS beti
    ON beti.module_id = bi.module_id
   AND beti.address = bi.address
 WHERE bcn.module_id = $1

$$;
COMMENT ON FUNCTION load_expression_type_instances(
    IN moduleid integer)
    IS 'The function retrieves all expression type instances for a given module.';

--
-- load_expression_type_instance(IN moduleid integer, IN typeinstanceid integer, IN address bigint, IN "position" integer, IN expressionid integer)
--

CREATE OR REPLACE FUNCTION load_expression_type_instance(
    IN moduleid integer,
	IN typeinstanceid integer,
	IN address bigint,
	IN "position" integer,
	IN expressionid integer)
	RETURNS TABLE (
	    view_id integer,
		module_id integer,
		address bigint,
		"position" integer,
		expression_id integer,
		type_instance_id integer)
	LANGUAGE SQL AS
$$

SELECT bv.id AS view_id, beti.module_id, beti.address, beti.position, beti.expression_id, beti.type_instance_id
  FROM bn_views AS bv
  JOIN bn_nodes AS bn
	ON bn.view_id = bv.id
   AND bn.type = 'code'::node_type
  LEFT JOIN bn_code_nodes AS bcn
         ON bcn.node_id = bn.id
  LEFT JOIN bn_codenode_instructions AS bcni
         ON bcni.module_id = bcn.module_id
        AND bcni.node_id = bcn.node_id
  LEFT JOIN bn_instructions AS bi
         ON bi.module_id = bcni.module_id
        AND bi.address = bcni.address
  JOIN bn_expression_type_instances AS beti
    ON beti.module_id = bi.module_id
   AND beti.address = bi.address
 WHERE bcn.module_id = $1
   AND beti.type_instance_id = $2
   AND beti.address = $3
   AND beti.position = $4
   AND beti.expression_id = $5

$$;

COMMENT ON FUNCTION load_expression_type_instance(
    IN moduleid integer,
    IN typeinstanceid integer,
    IN address bigint,
    IN "position" integer,
    IN expressionid integer)
    IS 'Loads a single cross reference from the database.';

--
-- create_type_instance(moduleid integer, instancename text, commentid integer, typeid integer, sectionid integer, instanceaddress bigint)
--

CREATE OR REPLACE FUNCTION create_type_instance(
  moduleid integer,
  instancename text,
  commentid integer,
  typeid integer,
  sectionid integer,
  instanceaddress bigint)
  RETURNS integer
  LANGUAGE SQL AS
$$

    INSERT INTO bn_type_instances (module_id, name, comment_id, type_id, section_id, section_offset)
        VALUES ($1, $2, $3, $4, $5, $6) RETURNING id;

$$;
COMMENT ON FUNCTION create_type_instance(integer, text, integer, integer, integer, bigint)
  IS 'This function creates a new type instance and returns the generated id of it.';

--
-- load_type_instances(IN moduleid integer)
--

CREATE OR REPLACE FUNCTION load_type_instances(
    IN moduleid integer)
    RETURNS TABLE (
	  module_id integer,
	  id integer,
	  name text,
	  comment_id integer,
	  type_id integer,
	  section_id integer,
	  section_offset bigint)
	  LANGUAGE SQL AS
$$
    SELECT * FROM bn_type_instances
     WHERE module_id = $1;

$$;
COMMENT ON FUNCTION load_type_instances(
  IN moduleid integer)
  IS 'This function retrives all type instaces for a given module id.';

--
-- load_type_instance(IN moduleid integer, IN typeinstanceid integer)
--

CREATE OR REPLACE FUNCTION load_type_instance(
    IN moduleid integer,
    IN typeinstanceid integer)
    RETURNS TABLE (
	  module_id integer,
	  id integer,
	  name text,
	  comment_id integer,
	  type_id integer,
	  section_id integer,
	  section_offset bigint)
	  LANGUAGE SQL AS
$$
    SELECT * FROM bn_type_instances
     WHERE module_id = $1
	   AND id = $2;
$$;
COMMENT ON FUNCTION load_type_instance(
  IN moduleid integer,
  IN typeinstanceid integer)
  IS 'This function loads a single type instaces.';

--
-- create_expression_type_instance(moduleid integer, operandaddress bigint, operandposition integer, expressionid integer, typeinstanceid integer)
--

CREATE OR REPLACE FUNCTION create_expression_type_instance(
  moduleid integer,
  operandaddress bigint,
  operandposition integer,
  expressionid integer,
  typeinstanceid integer)
  RETURNS void AS
$$

    INSERT INTO bn_expression_type_instances (module_id, address, position, expression_id, type_instance_id)
        VALUES ($1, $2, $3, $4, $5);

$$ LANGUAGE SQL;
COMMENT ON FUNCTION create_expression_type_instance(integer, bigint, integer, integer, integer)
  IS 'This function creates a new expression type instance which connects a type instance in a section to an operand in the graph view.';

--
-- set_type_instance_name(moduleid integer, typeinstanceid integer, newname text)
--

CREATE OR REPLACE FUNCTION set_type_instance_name(moduleid integer, typeinstanceid integer, newname text)
  RETURNS void AS
$$

    UPDATE bn_type_instances
       SET name = $3
     WHERE module_id = $1
       AND id = $2;

$$ LANGUAGE SQL;
COMMENT ON FUNCTION set_type_instance_name(integer, integer, text)
  IS 'This functions sets the name of a type instance.';


--
-- append_comment(IN parent_id integer, IN user_id integer, IN comment_text text)
--

CREATE OR REPLACE FUNCTION append_comment(IN parent_id integer, IN user_id integer, IN comment_text text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    comment_id integer;
    child integer;
  BEGIN
    --
    -- Find out if the node in question has a child
    -- node.
    --
    SELECT two.id INTO child FROM bn_comments AS one
      JOIN bn_comments AS two
        ON (one.id = two.parent_id)
    WHERE one.id = $1;

    --
    -- If we find a child node we must exit as append
    -- only works on a node which has no child.
    --
    IF FOUND THEN
      RAISE EXCEPTION 'can not append comment to node % as it has a child comment', $1;
    END IF;

    --
    -- If we did not find a child node we perform the append
    -- operation and return the newly generated
    --
    INSERT INTO bn_comments(id, parent_id, user_id, comment_text)
      VALUES (nextval('bn_comments_id_seq'::regclass), $1, $2, $3)
      RETURNING id INTO STRICT comment_id;

    RETURN comment_id;

  END;
 $$;
COMMENT ON FUNCTION append_comment(IN parent_id integer, IN user_id integer, IN comment_text text)
  IS 'This function appends a comment to a comment owned by the user given as argument.
  It returns the generated id of the comment.
  This function is used by all other append comment functions.';

--
-- append_group_node_comment(IN nodeId integer, IN userId integer, IN comment text)
--

CREATE OR REPLACE FUNCTION append_group_node_comment(IN nodeId integer, IN userId integer, IN comment text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    commentid integer;
    parentid integer;
  BEGIN
    --
    -- Check if the group node already has a comment
    -- associated with it.
    --
    SELECT comment_id INTO parentid
      FROM bn_group_nodes
     WHERE node_id = nodeId;

    --
    -- Create a comment using the append comment function.
    --
    SELECT append_comment(parentid, userId, comment)
      INTO commentid;

    --
    -- Update the group nodes with the newly generated comment.
    --
    UPDATE bn_group_nodes
      SET comment_id = commentid
    WHERE node_id = nodeId;

    RETURN commentid;
  END;
$$;
COMMENT ON FUNCTION append_group_node_comment(IN nodeId integer, IN userId integer, IN comment text)
  IS 'This function appends a comment to a group node. It returns the generated id of the comment.';

--
-- append_text_node_comment(IN nodeId integer, IN userId integer, IN comment text)
--

CREATE OR REPLACE FUNCTION append_text_node_comment(IN nodeId integer, IN userId integer, IN comment text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    commentid integer;
    parentid integer;
  BEGIN
    --
    -- Check if the text node already has a comment
    -- associated with it.
    --
    SELECT comment_id INTO parentid
      FROM bn_text_nodes
     WHERE node_id = nodeId;

    --
    -- Create a comment using the append comment function.
    --
    SELECT append_comment(parentid, userId, comment)
      INTO commentid;

    --
    -- Update the group nodes with the newly generated comment.
    --
    UPDATE bn_text_nodes
      SET comment_id = commentid
    WHERE node_id = nodeId;

    RETURN commentid;
  END;
$$;
COMMENT ON FUNCTION append_text_node_comment(IN nodeId integer, IN userId integer, IN comment text)
  IS 'This function appends a comment to a text node. It returns the generated id of the comment.';

--
-- append_function_comment(IN moduleid integer, IN functionaddress bigint, IN user_id integer, IN comment_text text)
--

CREATE OR REPLACE FUNCTION append_function_comment(IN moduleid integer, IN functionaddress bigint, IN user_id integer, IN comment_text text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    commentid integer;
    parentid integer;
  BEGIN
    --
    -- Check if the function already has a comment
    -- associated with it.
    --
    SELECT comment_id INTO parentid
      FROM bn_functions
     WHERE module_id = moduleid
       AND address = functionaddress;

    --
    -- Create a comment using the append comment function.
    --
    SELECT append_comment(parentid, user_id, comment_text)
      INTO commentid;

    --
    -- Update the function nodes table with the newly generated comment.
    --
    UPDATE bn_functions
      SET comment_id = commentid
    WHERE module_id = moduleid
      AND address = functionaddress;

    RETURN commentid;
  END;
$$;
COMMENT ON FUNCTION append_function_comment(IN moduleid integer, IN functionaddress bigint, IN user_id integer, IN comment_text text)
  IS 'This function appends a comment to a function. It returns the generated id of the comment.';

--
-- append_function_node_comment(IN moduleid integer, IN nodeid integer, IN user_id integer, IN comment_text text)
--

CREATE OR REPLACE FUNCTION append_function_node_comment(IN moduleid integer, IN nodeid integer, IN user_id integer, IN comment_text text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    commentid integer;
    parentid integer;
  BEGIN
    --
    -- Check if the function already has a comment
    -- associated with it.
    --
    SELECT comment_id INTO parentid
      FROM bn_function_nodes
     WHERE node_id = nodeid
      AND module_id = moduleid;

    --
    -- Create a comment using the append comment function.
    --
    SELECT append_comment(parentid, user_id, comment_text)
      INTO commentid;

    --
    -- Update the function nodes table with the newly generated comment.
    --
    UPDATE bn_function_nodes
      SET comment_id = commentid
    WHERE node_id = nodeid
      AND module_id = moduleid;

    RETURN commentid;
  END;
$$;
COMMENT ON FUNCTION append_function_node_comment(IN moduleid integer, IN nodeid integer, IN user_id integer, IN comment_text text)
  IS 'This function appends a comment to a function node. It returns the generated id of the comment.';

--
-- append_global_code_node_comment(IN moduleid integer, IN node_id integer, IN node_address bigint, IN user_id integer, IN comment_text text)
--

CREATE OR REPLACE FUNCTION append_global_code_node_comment(IN moduleid integer, IN node_id integer, IN node_address bigint, IN user_id integer, IN comment_text text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    commentid integer;
    parentid integer;
  BEGIN
    --
    -- Check if the code node already has a global comment
    -- associated with it.
    --
    SELECT comment_id INTO parentid
      FROM bn_global_node_comments
     WHERE module_id = moduleid
       AND address = node_address;

    --
    -- Create a comment using the append comment function.
    --
    SELECT append_comment(parentid, user_id, comment_text)
      INTO commentid;

    --
    -- We use the information from the parent id to decide
    -- if we need to update or if we need to insert.
    --
    IF (parentid IS NOT NULL) THEN
      UPDATE bn_global_node_comments
         SET comment_id = commentid
       WHERE module_id = moduleid
         AND address = node_address
         AND comment_id = parentid;
    ELSE
      INSERT INTO bn_global_node_comments
        VALUES(moduleid, node_address, commentid);
    END IF;
    RETURN commentid;
  END;
$$;
COMMENT ON FUNCTION append_global_code_node_comment(IN moduleid integer, IN node_id integer, IN node_address bigint, IN user_id integer, IN comment_text text)
  IS 'This function appends a global code node comment. It returns the generated id of the comment.';

--
-- append_global_edge_comment(IN srcmoduleid integer, IN dstmoduleid integer, IN srcnodeaddress bigint, IN dstnodeaddress bigint, IN user_id integer, IN comment_text text)
--

CREATE OR REPLACE FUNCTION append_global_edge_comment(IN srcmoduleid integer, IN dstmoduleid integer, IN srcnodeaddress bigint, IN dstnodeaddress bigint, IN user_id integer, IN comment_text text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    commentid integer;
    parentid integer;
  BEGIN
    --
    -- Check if the edge already has a global comment
    -- associated with it.
    --
    SELECT comment_id INTO parentid
      FROM bn_global_edge_comments
     WHERE src_module_id = srcmoduleid
       AND dst_module_id = dstmoduleid
       AND src_address = srcnodeaddress
       AND dst_address = dstnodeaddress;

    --
    -- Create a comment using the append comment function.
    --
    SELECT append_comment(parentid, user_id, comment_text)
      INTO commentid;

     --
    -- We use the information from the parent id to decide
    -- if we need to update or if we need to insert.
    --
    IF (parentid IS NOT NULL) THEN
      UPDATE bn_global_edge_comments
         SET comment_id = commentid
       WHERE src_module_id = srcmoduleid
         AND dst_module_id = dstmoduleid
         AND src_address = srcnodeaddress
         AND dst_address = dstnodeaddress
         AND comment_id = parentid;
    ELSE
      INSERT INTO bn_global_edge_comments
        VALUES(srcmoduleid, dstmoduleid, srcnodeaddress, dstnodeaddress, commentid);
    END IF;
    RETURN commentid;
  END;
$$;
COMMENT ON FUNCTION append_global_edge_comment(IN srcmoduleid integer, IN dstmoduleid integer, IN srcnodeaddress bigint, IN dstnodeaddress bigint, IN user_id integer, IN comment_text text)
  IS 'This function appends a global edge comment. It returns the generated id of the comment.';

--
-- append_global_instruction_comment(IN moduleid integer, IN instruction_address bigint, IN user_id integer, IN comment_text text)
--

CREATE OR REPLACE FUNCTION append_global_instruction_comment(IN moduleid integer, IN instruction_address bigint, IN user_id integer, IN comment_text text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    commentid integer;
    parentid integer;
  BEGIN
    --
    -- Check if the instruction already has a global comment
    -- associated with it.
    --
    SELECT comment_id INTO parentid
      FROM bn_instructions
     WHERE module_id = moduleid
       AND address = instruction_address;
    --
    -- Create a comment using the append comment function.
    --
    SELECT append_comment(parentid, user_id, comment_text)
      INTO commentid;

    --
    -- Update the record of the instruction to point to the
    -- new comment.
    --
    UPDATE bn_instructions
       SET comment_id = commentid
     WHERE module_id = moduleid
       AND address = instruction_address;

    RETURN commentid;
  END;
$$;
COMMENT ON FUNCTION append_global_instruction_comment(IN moduleid integer, IN instruction_address bigint, IN user_id integer, IN comment_text text)
  IS 'This function appends a global instruction comment. It returns the generated id of the comment.';

--
-- append_local_code_node_comment(IN moduleid integer, IN nodeid integer, IN user_id integer, IN comment_text text)
--

CREATE OR REPLACE FUNCTION append_local_code_node_comment(IN moduleid integer, IN nodeid integer, IN user_id integer, IN comment_text text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    commentid integer;
    parentid integer;
  BEGIN
    --
    -- Find out if our current code node already
    -- had a local comment and save its comment_id.
    --
    SELECT comment_id INTO parentid
      FROM bn_code_nodes
     WHERE module_id = moduleid
       AND node_id = nodeid;

    --
    -- Create a comment using the append comment function
    -- with the optional current_node_comment_id as the new paremt.
    --
    SELECT append_comment(parentid, user_id, comment_text)
      INTO commentid;

    --
    -- Update the code node with the newly generated comment.
    --
    UPDATE bn_code_nodes
       SET comment_id = commentid
     WHERE module_id = moduleid
       AND node_id = nodeid;

    RETURN commentid;
  END;
$$;
COMMENT ON FUNCTION append_local_code_node_comment(IN moduleid integer, IN nodeid integer, IN user_id integer, IN comment_text text)
  IS 'This function appends a local comment to a code node. It returns the generated id of the comment.';

--
-- append_local_edge_comment(IN edge_id integer, IN user_id integer, IN comment_text text)
--

CREATE OR REPLACE FUNCTION append_local_edge_comment(IN edge_id integer, IN user_id integer, IN comment_text text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    commentid integer;
    parentid integer;
  BEGIN
    --
    -- Find out if our current code node already
    -- had a local comment and save its comment_id.
    --
    SELECT comment_id INTO parentid
      FROM bn_edges
     WHERE id = edge_id;

    --
    -- Create a comment using the append comment function.
    --
    SELECT append_comment(parentid, user_id, comment_text)
      INTO commentid;

    --
    -- Update the edge with the newly generated comment.
    --
    UPDATE bn_edges
      SET comment_id = commentid
    WHERE id = edge_id;

    RETURN commentid;
  END;
$$;
COMMENT ON FUNCTION append_local_edge_comment(IN edge_id integer, IN user_id integer, IN comment_text text)
  IS 'This function appends a local edge comment to an edge. It returns the generated id of the comment.';

--
-- append_local_instruction_comment(IN moduleid integer, IN nodeid integer, IN instruction_address bigint, IN user_id integer, IN comment_text text)
--

CREATE OR REPLACE FUNCTION append_local_instruction_comment(IN moduleid integer, IN nodeid integer, IN instruction_address bigint, IN user_id integer, IN comment_text text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    commentid integer;
    parentid integer;
  BEGIN
    --
    -- Find out if our current code node already
    -- had a local comment and save its comment_id.
    --
    SELECT comment_id INTO parentid
      FROM bn_codenode_instructions
     WHERE module_id = moduleid
       AND node_id = nodeid
       AND address = instruction_address;
    --
    -- Create a comment using the append comment function.
    --
    SELECT append_comment(parentid, user_id, comment_text)
      INTO commentid;

    --
    -- Update the record of the instruction to point to the
    -- new comment.
    --
    UPDATE bn_codenode_instructions
       SET comment_id = commentid
     WHERE module_id = moduleid
       AND node_id = nodeid
       AND address = instruction_address;

    RETURN commentid;
  END;
$$;
COMMENT ON FUNCTION append_local_instruction_comment(IN moduleid integer, IN nodeid integer, IN instruction_address bigint, IN user_id integer, IN comment_text text)
  IS 'This function appends a local instruction comment to an instruction in a code node. It returns the generated id of the comment.';

--
-- append_section_comment(moduleid integer, sectionid integer, user_id integer, comment_text text)
--

CREATE OR REPLACE FUNCTION append_section_comment(moduleid integer, sectionid integer, user_id integer, comment_text text)
  RETURNS integer AS
$$
  DECLARE
    commentid integer;
    parentid integer;
  BEGIN
    --
    -- Check if the section already has a comment
    -- associated with it.
    --
    SELECT comment_id INTO parentid
      FROM bn_sections
     WHERE module_id = moduleid
       AND id = sectionid;

    --
    -- Create a comment using the append comment function.
    --
    SELECT append_comment(parentid, user_id, comment_text)
      INTO commentid;

    --
    -- Update the sections table with the newly generated comment.
    --
    UPDATE bn_sections
       SET comment_id = commentid
     WHERE module_id = moduleid
       AND id = sectionid;

    RETURN commentid;
  END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION append_section_comment(integer, integer, integer, text)
   IS 'This function appends a comment to a section. It returns the generated id of the comment.';

--
-- append_type_instance_comment(moduleid integer, typeinstanceid integer, user_id integer, comment_text text)
--

CREATE OR REPLACE FUNCTION append_type_instance_comment(moduleid integer, typeinstanceid integer, user_id integer, comment_text text)
  RETURNS integer AS
$$
  DECLARE
    commentid integer;
    parentid integer;
  BEGIN
    --
    -- Check if the type instance already has a comment
    -- associated with it.
    --
    SELECT comment_id INTO parentid
      FROM bn_type_instances
     WHERE module_id = moduleid
       AND id = typeinstanceid;

    --
    -- Create a comment using the append comment function.
    --
    SELECT append_comment(parentid, user_id, comment_text)
      INTO commentid;

    --
    -- Update the type instances table with the newly generated comment.
    --
    UPDATE bn_type_instances
       SET comment_id = commentid
     WHERE module_id = moduleid
       AND id = typeinstanceid;

    RETURN commentid;
  END;
$$ LANGUAGE plpgsql;
COMMENT ON FUNCTION append_type_instance_comment(integer, integer, integer, text)
   IS 'This function appends a comment to a type instance. It returns the generated id of the comment.';

--
-- delete_group_node_comment(IN nodeId integer, IN commentid integer, IN userid integer)
--

CREATE OR REPLACE FUNCTION delete_group_node_comment(IN nodeId integer, IN commentid integer, IN userid integer)
  RETURNS integer
  LANGUAGE plpgsql
  AS $$
  DECLARE
    parentid integer;
  BEGIN
    --
    -- Delete the comment according to the specified user and
    -- comment ids.
    --
    SELECT delete_comment_by_id(commentId, userId)
      INTO parentid;

    --
    -- Update the group nodes table with the newly generated comment.
    --
    UPDATE bn_group_nodes
      SET comment_id = parentid
    WHERE node_id = nodeId
      AND comment_id = commentid;

    RETURN commentid;

  END;
$$;
COMMENT ON FUNCTION delete_group_node_comment(IN nodeId integer, IN commentid integer, IN userid integer)
  IS 'This function deletes a comment from a group node. It returns the id of the deleted comment.';

--
-- delete_text_node_comment(IN nodeId integer, IN commentid integer, IN userid integer)
--

CREATE OR REPLACE FUNCTION delete_text_node_comment(IN nodeId integer, IN commentid integer, IN userid integer)
  RETURNS integer
  LANGUAGE plpgsql
  AS $$
  DECLARE
    parentid integer;
  BEGIN
    --
    -- Delete the comment according to the specified user and
    -- comment ids.
    --
    SELECT delete_comment_by_id(commentId, userId)
      INTO parentid;

    --
    -- Update the text nodes table with the newly generated comment.
    --
    UPDATE bn_text_nodes
      SET comment_id = parentid
    WHERE node_id = nodeId
      AND comment_id = commentid;

    RETURN commentid;

  END;
$$;
COMMENT ON FUNCTION delete_text_node_comment(IN nodeId integer, IN commentid integer, IN userid integer)
  IS 'This function deletes a comment from a text node. It returns the id of the deleted comment.';

--
-- delete_comment_by_id(IN commentid integer, IN userid integer)
--

CREATE OR REPLACE FUNCTION delete_comment_by_id(IN commentid integer, IN userid integer)
  RETURNS integer
  LANGUAGE plpgsql
  AS $$
    DECLARE
	  parentid integer;
    BEGIN
   WITH parent_comment AS (
   SELECT one.id AS id, one.parent_id AS parent FROM bn_comments AS one
    JOIN bn_comments AS two
      ON one.parent_id = two.id
   WHERE one.id = commentid
   ),
   child_comment AS (
   SELECT one.id AS id, two.id AS child FROM bn_comments AS one
    JOIN bn_comments AS two
      ON one.id = two.parent_id
   WHERE one.id = commentid
   ),

   update AS (UPDATE bn_comments SET parent_id =
	(
	SELECT parent FROM parent_comment
	  LEFT JOIN child_comment
	    ON child_comment.id = parent_comment.id
	) WHERE id =
	(
	SELECT child FROM parent_comment
	  LEFT JOIN child_comment
	    ON child_comment.id = parent_comment.id
	)
	AND user_id = userid
	)

    DELETE FROM bn_comments
    WHERE bn_comments.id = commentid
      AND bn_comments.user_id = userid
    RETURNING bn_comments.parent_id INTO STRICT parentid;

    RETURN parentid;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
      RAISE EXCEPTION 'the comment with id % does not exist or is not owned by the user with id %', commentId, userId;

END;
 $$;
COMMENT ON FUNCTION delete_comment_by_id(IN commentid integer, IN userid integer)
 IS 'This function deletes a comment by id. It is used by all other comment delete functions as core functionality.
 It does verify if the user id given as argument is the actual owner of the comment which is requested to be deleted and will fail otherwise.';

--
-- delete_function_comment(IN moduleid integer, IN functionaddress bigint, IN commentid integer, IN userid integer)
--

CREATE OR REPLACE FUNCTION delete_function_comment(IN moduleid integer, IN functionaddress bigint, IN commentid integer, IN userid integer)
  RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    parentid integer;
  BEGIN
    --
    -- Delete the comment according to the specified user and
    -- comment ids.
    --
    SELECT delete_comment_by_id(commentId, userId)
      INTO parentid;

    --
    -- Update the function nodes table with the newly generated comment.
    --
    UPDATE bn_functions
      SET comment_id = parentid
    WHERE module_id = moduleid
      AND address = functionaddress
      AND comment_id = commentId;

    RETURN commentId;
  END;
$$;
COMMENT ON FUNCTION delete_function_comment(IN moduleid integer, IN functionaddress bigint, IN commentid integer, IN userid integer)
  IS 'This function deletes a comment associated to a function. It does return the id of the deleted comment.';

--
-- delete_function_node_comment(IN moduleid integer, IN nodeid integer, IN commentid integer, IN userid integer)
--

CREATE OR REPLACE FUNCTION delete_function_node_comment(IN moduleid integer, IN nodeid integer, IN commentid integer, IN userid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    parentid integer;
  BEGIN
    --
    -- Delete the comment according to the specified user and
    -- comment ids.
    --
    SELECT delete_comment_by_id(commentId, userId)
      INTO parentid;

    --
    -- Update the function nodes table with the newly generated comment.
    --
    UPDATE bn_function_nodes
      SET comment_id = parentid
    WHERE node_id = nodeid
      AND module_id = moduleid
      AND comment_id = commentId;

    RETURN commentId;
  END;
$$;
COMMENT ON FUNCTION delete_function_node_comment(IN moduleid integer, IN nodeid integer, IN commentid integer, IN userid integer)
  IS 'This function deletes a comment associated to a function node. It returns the id of the deleted comment.';

--
-- delete_global_code_node_comment(IN moduleid integer, IN node_id integer, IN node_address bigint, IN commentid integer, IN userid integer)
--

CREATE OR REPLACE FUNCTION delete_global_code_node_comment(IN moduleid integer, IN node_id integer, IN node_address bigint, IN commentid integer, IN userid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    parentid integer;
  BEGIN
    --
    -- Delete the comment according to the specified user and
    -- comment ids.
    --
    SELECT delete_comment_by_id(commentId, userId)
      INTO parentid;

    --
    -- Update the global comments according to the changes.
    --
    IF parentid IS NULL THEN
      DELETE FROM bn_global_node_comments
        WHERE module_id = moduleid
          AND address = node_address
          AND comment_id = commentId;
    ELSE
	UPDATE bn_global_node_comments
	   SET comment_id = parentid
	 WHERE module_id = moduleId
	   AND address = node_address
	   AND comment_id = commentId;
    END IF;

    RETURN commentId;
  END;
$$;
COMMENT ON FUNCTION delete_global_code_node_comment(IN moduleid integer, IN node_id integer, IN node_address bigint, IN commentid integer, IN userid integer)
  IS 'This function deletes a global comment assocatiated with a code node. It returns the id of the deleted comment.';

--
-- delete_global_edge_comment(IN srcmoduleid integer, IN dstmoduleid integer, IN srcnodeaddress bigint, IN dstnodeaddress bigint, IN commentid integer, IN userid integer)
--

CREATE OR REPLACE FUNCTION delete_global_edge_comment(IN srcmoduleid integer, IN dstmoduleid integer, IN srcnodeaddress bigint, IN dstnodeaddress bigint, IN commentid integer, IN userid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    parentid integer;
  BEGIN
    --
    -- Delete the comment according to the specified user and
    -- comment ids.
    --
    SELECT delete_comment_by_id(commentId, userId)
      INTO parentid;

    --
    -- Update the global comments according to the changes.
    --
    IF parentid IS NULL THEN
      DELETE FROM bn_global_edge_comments
        WHERE src_module_id = srcmoduleid
          AND dst_module_id = dstmoduleid
          AND src_address = srcnodeaddress
          AND dst_address = dstnodeaddress
          AND comment_id = commentId;
    ELSE
      UPDATE bn_global_edge_comments
         SET comment_id = parentid
       WHERE dst_module_id = dstmoduleid
         AND src_address = srcnodeaddress
         AND dst_address = dstnodeaddress
         AND comment_id = commentId;
    END IF;

    RETURN commentId;
  END;
$$;
COMMENT ON FUNCTION delete_global_edge_comment(IN srcmoduleid integer, IN dstmoduleid integer, IN srcnodeaddress bigint, IN dstnodeaddress bigint, IN commentid integer, IN userid integer)
  IS 'This function deletes a global comment associated with an edge. It does return the id of the deleted comment.';

--
-- delete_global_instruction_comment(IN moduleid integer, IN instruction_address bigint, IN commentid integer, IN userid integer)
--

CREATE OR REPLACE FUNCTION delete_global_instruction_comment(IN moduleid integer, IN instruction_address bigint, IN commentid integer, IN userid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    parentid integer;
  BEGIN
    --
    -- Delete the comment according to the specified user and
    -- comment ids.
    --
    SELECT delete_comment_by_id(commentId, userId)
      INTO parentid;

    --
    -- Update the record of the instruction to point to the
    -- new comment.
    --
    UPDATE bn_instructions
      SET comment_id = parentid
      WHERE module_id = moduleid
        AND address = instruction_address
        AND comment_id = commentId;

    RETURN commentId;
  END;
$$;
COMMENT ON FUNCTION delete_global_instruction_comment(IN moduleid integer, IN instruction_address bigint, IN commentid integer, IN userid integer)
  IS 'This function deletes a global comment associated with an instruction. It returns the id of the deleted comment.';

--
-- delete_local_code_node_comment(IN moduleid integer, IN nodeid integer, IN commentid integer, IN userid integer)
--

CREATE OR REPLACE FUNCTION delete_local_code_node_comment(IN moduleid integer, IN nodeid integer, IN commentid integer, IN userid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    parentid integer;
  BEGIN
    --
    -- Delete the comment according to the specified user and
    -- comment ids.
    --
    SELECT delete_comment_by_id(commentId, userId)
      INTO parentid;

    --
    -- Update the code node with the newly generated comment.
    --
    UPDATE bn_code_nodes
       SET comment_id = parentid
     WHERE module_id = moduleid
       AND node_id = nodeid
       AND comment_id = commentId;

    RETURN commentId;
  END;
$$;
COMMENT ON FUNCTION delete_local_code_node_comment(IN moduleid integer, IN nodeid integer, IN commentid integer, IN userid integer)
  IS 'This funciton deletes a local comment associated with a code node. It returns the id of the deleted comment.';

--
-- delete_local_edge_comment(IN edge_id integer, IN commentid integer, IN userid integer)
--

CREATE OR REPLACE FUNCTION delete_local_edge_comment(IN edge_id integer, IN commentid integer, IN userid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    parentid integer;
  BEGIN
    --
    -- Delete the comment according to the specified user and
    -- comment ids.
    --
    SELECT delete_comment_by_id(commentId, userId)
      INTO parentid;

    --
    -- Update the edge with the newly generated comment.
    --
    UPDATE bn_edges
      SET comment_id = parentid
    WHERE id = edge_id
      AND comment_id = commentId;

    RETURN commentId;
  END;
$$;
COMMENT ON FUNCTION delete_local_edge_comment(IN edge_id integer, IN commentid integer, IN userid integer)
  IS 'This function deletes a local comment associated with an edge. It returns the id of the deleted comment.';

--
-- delete_local_instruction_comment(IN moduleid integer, IN nodeid integer, IN instruction_address bigint, IN commentid integer, IN userid integer)
--

CREATE OR REPLACE FUNCTION delete_local_instruction_comment(IN moduleid integer, IN nodeid integer, IN instruction_address bigint, IN commentid integer, IN userid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  DECLARE
    parentid integer;
  BEGIN
    --
    -- Delete the comment according to the specified user and
    -- comment ids.
    --
    SELECT delete_comment_by_id(commentId, userId)
      INTO parentid;

    --
    -- Update the record of the instruction to point to the
    -- new comment.
    --
    UPDATE bn_codenode_instructions
      SET comment_id = parentid
      WHERE module_id = moduleid
        AND node_id = nodeid
        AND address = instruction_address
        AND comment_id = commentId;

    RETURN commentId;
  END;
$$;
COMMENT ON FUNCTION delete_local_instruction_comment(IN moduleid integer, IN nodeid integer, IN instruction_address bigint, IN commentid integer, IN userid integer)
  IS 'This function deletes a local comment associated with an instruction in a code node. It returns the id of the deleted comment.';

--
-- delete_section_comment(moduleid integer, sectionid integer, commentid integer, userid integer)
--

CREATE OR REPLACE FUNCTION delete_section_comment(moduleid integer, sectionid integer, commentid integer, userid integer)
  RETURNS integer AS
$$
  DECLARE
    parentid integer;
  BEGIN
    --
    -- Delete the comment according to the specified user and
    -- comment ids.
    --
    SELECT delete_comment_by_id(commentId, userId)
      INTO parentid;

    --
    -- Update the function nodes table with the newly generated comment.
    --
    UPDATE bn_sections
      SET comment_id = parentid
    WHERE module_id = moduleid
      AND id = sectionid
      AND comment_id = commentId;

    RETURN commentId;
  END;
$$
  LANGUAGE plpgsql;
COMMENT ON FUNCTION delete_section_comment(integer, integer, integer, integer)
   IS 'This function deletes a comment associated to a section. It does return the id of the deleted comment.';

--
-- delete_type_instance_comment(moduleid integer, typeinstanceid integer, commentid integer, userid integer)
--

CREATE OR REPLACE FUNCTION delete_type_instance_comment(moduleid integer, typeinstanceid integer, commentid integer, userid integer)
  RETURNS integer AS
$$
  DECLARE
    parentid integer;
  BEGIN
    --
    -- Delete the comment according to the specified user and
    -- comment ids.
    --
    SELECT delete_comment_by_id(commentId, userId)
      INTO parentid;

    --
    -- Update the function nodes table with the newly generated comment.
    --
    UPDATE bn_type_instances
      SET comment_id = parentid
    WHERE module_id = moduleid
      AND id = typeinstanceid
      AND comment_id = commentId;

    RETURN commentId;
  END;
$$
  LANGUAGE plpgsql;
  COMMENT ON FUNCTION delete_type_instance_comment(integer, integer, integer, integer)
   IS 'This function deletes a comment associated to a type instance. It does return the id of the deleted comment.';

--
-- edit_comment(IN comment_id integer, IN userid integer, IN commenttext text)
--

CREATE OR REPLACE FUNCTION edit_comment(IN comment_id integer, IN userid integer, IN commenttext text) RETURNS void
    LANGUAGE plpgsql
    AS $$
  DECLARE
    result integer;
  BEGIN
    --
    -- Find out if there is a comment record which is owned
    -- by the user id given as argument.
    --
    SELECT c.id INTO STRICT result FROM bn_comments AS c
      WHERE c.id = comment_id
        AND c.user_id = userid;

    --
    -- If the record exists proceed with the update.
    --
    IF FOUND THEN
      UPDATE bn_comments
        SET comment_text = commenttext
        WHERE id = comment_id
          AND user_id = userid;
    END IF;

    --
    -- If either the comment is not owned by the supplied user id
    -- or if there are actually more comments which come up for the same
    -- key we bail out and inform the caller.
    --
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'Error: there is no comment record in the database which satisfies id = % user = %.', comment_id, userid;
      WHEN TOO_MANY_ROWS THEN
        RAISE EXCEPTION 'Error: there is more then one comment which satisfies id = % user = %.', comment_id, userid;
  END;
$$;
COMMENT ON FUNCTION edit_comment(IN comment_id integer, IN userid integer, IN commenttext text)
  IS 'This function edits a comment based on the id and the comment text provided.
  It checks if the user given is the owner of the comment and will fail if this is not the case.
  This function is used for all edit functions.';

--
-- get_all_comment_ancestors(IN comment_id integer)
--

CREATE OR REPLACE FUNCTION get_all_comment_ancestors(IN comment_id integer)
  RETURNS TABLE(level integer, id integer, parent_id integer, user_id integer, comment text)
  LANGUAGE sql
  AS $$
  WITH RECURSIVE
        q AS
        (
        SELECT  h.*, 1 AS level
        FROM    bn_comments h
        WHERE   id = $1
        UNION ALL
        SELECT  hp.*, level + 1
        FROM    q
        JOIN    bn_comments hp
        ON      hp.id = q.parent_id
        )
SELECT  level, id, parent_id, user_id, comment_text
FROM    q
ORDER BY level DESC
 $$;
COMMENT ON FUNCTION get_all_comment_ancestors(IN comment_id integer)
  IS 'This function gets all ancestors of a comment for the provided comment id.';

--
-- get_all_comment_ancestors_multiple(IN commentids integer[])
--

CREATE OR REPLACE FUNCTION get_all_comment_ancestors_multiple(IN commentids integer[])
  RETURNS TABLE(commentid integer, level integer, id integer, parent_id integer, user_id integer, comment text)
  LANGUAGE plpgsql
  AS $$
  DECLARE
    commentId integer;
  BEGIN
    FOREACH commentId IN ARRAY $1
    LOOP
      RETURN QUERY(
        SELECT commentId, * FROM get_all_comment_ancestors(commentId)
      );
    END LOOP;
  END;
$$;
COMMENT ON FUNCTION get_all_comment_ancestors_multiple(IN commentids integer[])
  IS 'This function gets all ancestors of all comment ids provided as argument.
  It can be used as to batch load comments and reduce the number of querries needed to do so.';

--
-- load_view_edges(IN viewid integer)
--

CREATE OR REPLACE FUNCTION load_view_edges(IN viewid integer)
  RETURNS TABLE(id integer, source_node_id integer, target_node_id integer, comment_id integer, x1 double precision, y1 double precision, x2 double precision, y2 double precision, type edge_type, color integer, visible boolean, selected boolean, x double precision, y double precision)
  LANGUAGE sql AS
$$
  SELECT edges.id, source_node_id, target_node_id,
  comment_id, x1, y1, x2, y2,
  edges.type, edges.color, edges.visible, edges.selected, ep.x, ep.y
  FROM bn_edges AS edges
    JOIN bn_nodes AS bt ON edges.target_node_id = bt.id
    JOIN bn_nodes AS bs ON edges.source_node_id = bs.id
    LEFT JOIN bn_edge_paths AS ep ON ep.edge_id = edges.id
  WHERE bt.view_id = $1
    AND bs.view_id = $1;
$$;
COMMENT ON FUNCTION load_view_edges(IN viewid integer)
  IS 'This function loads the edges of a view.';

--
-- create_type_substitution(IN moduleid integer, IN address bigint, IN position integer, IN expressionid integer, IN basetypeid integer, IN path integer[], IN offset integer)
--

CREATE OR REPLACE FUNCTION create_type_substitution(
  IN moduleid integer,
  IN address bigint,
  IN "position" integer,
  IN expressionid integer,
  IN basetypeid integer,
  IN path integer[],
  IN "offset" integer)
  RETURNS void
  LANGUAGE sql AS
$$
INSERT INTO bn_expression_types (module_id, address, position, expression_id, base_type_id, path, offset)
  VALUES($1, $2, $3, $4, $5, $6, $7);
$$;
COMMENT ON FUNCTION create_type_substitution(
  IN moduleid integer,
  IN address bigint,
  IN "position" integer,
  IN expressionid integer,
  IN basetypeid integer,
  IN path integer[],
  IN "offset" integer)
  IS 'This function creates a single type substitution';

--
-- delete_type_substitution(IN moduleid integer, IN address bigint, IN position integer, IN expressionid)
--

CREATE OR REPLACE FUNCTION delete_type_substitution(
  IN moduleid integer,
  IN address bigint,
  IN "position" integer,
  IN expressionid integer)
  RETURNS void
  LANGUAGE sql AS
$$
DELETE FROM bn_expression_types AS et
  WHERE et.module_id = $1
    AND et.address = $2
	AND et.position = $3
	AND et.expression_id = $4;
$$;
COMMENT ON FUNCTION delete_type_substitution(
  IN moduleid integer,
  IN address bigint,
  IN "position" integer,
  IN expressionid integer)
  IS 'This function deletes a single type substitution';

--
-- load_types(IN moduleid integer)
--

CREATE OR REPLACE FUNCTION load_types(
  IN moduleid integer)
  RETURNS TABLE(
    id integer,
    name text,
    size integer,
    pointer integer,
    signed boolean,
    category type_category)
  LANGUAGE SQL AS
$$

SELECT id, name, size, pointer, signed, category
  FROM bn_base_types
 WHERE module_id = $1;

$$;
COMMENT ON FUNCTION load_types(
  IN moduleid integer)
  IS 'Loads all base types for a given module id.';

--
-- load_type(IN moduleid integer, IN typeid integer)
--

CREATE OR REPLACE FUNCTION load_type(
  IN moduleid integer,
  IN typeid integer)
  RETURNS TABLE(
    id integer,
    name text,
    size integer,
    pointer integer,
    signed boolean,
    category type_category)
  LANGUAGE SQL AS
$$

SELECT id, name, size, pointer, signed, category
  FROM bn_base_types
 WHERE module_id = $1
   AND id = $2;

$$;
COMMENT ON FUNCTION load_type(
  IN moduleid integer,
  IN typeid integer)
  IS 'Loads a single base type.';

--
-- load_type_member(IN moduleid integer, IN typeid integer)
--

CREATE OR REPLACE FUNCTION load_type_member(
  IN moduleid integer,
  IN typeid integer)
  RETURNS TABLE (
    id integer,
    name text,
	base_type integer,
	parent_id integer,
	"offset" integer,
	argument integer,
	number_of_elements integer)
  LANGUAGE SQL AS
$$

SELECT id, name, base_type, parent_id, "offset", argument, number_of_elements
  FROM bn_types
 WHERE module_id = $1
   AND id = $2;

$$;
COMMENT ON FUNCTION load_type_member(
  IN moduleid integer,
  IN typeid integer)
  IS 'Loads a single type member from the database.';


--
-- load_type_members(IN moduleid integer)
--

CREATE OR REPLACE FUNCTION load_type_members(
  IN moduleid integer)
  RETURNS TABLE (
    id integer,
    name text,
	base_type integer,
	parent_id integer,
	"offset" integer,
	argument integer,
	number_of_elements integer)
  LANGUAGE SQL AS
$$

SELECT id, name, base_type, parent_id, "offset", argument, number_of_elements
  FROM bn_types
 WHERE module_id = $1;

$$;
COMMENT ON FUNCTION load_type_members(
  IN moduleid integer)
  IS 'Loads all type members for the given module.';

--
-- load_type_substitutions(IN moduleid integer)
--

CREATE OR REPLACE FUNCTION load_type_substitutions(
  IN moduleid integer)
  RETURNS TABLE (
    address bigint,
	"position" integer,
    expression_id integer,
	base_type_id integer,
	path integer[],
	"offset" integer)
  LANGUAGE SQL AS

$$

SELECT address, "position", expression_id, base_type_id, path, "offset"
  FROM bn_expression_types
 WHERE module_id = $1;

$$;
COMMENT ON FUNCTION load_type_substitutions(
  IN moduleid integer)
  IS 'Loads all type susbtitutions for a single module from the database.';

--
-- load_type_substitution(IN moduleid integer, IN address bigint, IN "position" integer, IN expression_id integer)
--

CREATE OR REPLACE FUNCTION load_type_substitution(
  IN moduleid integer,
  IN address bigint,
  IN "position" integer,
  IN expression_id integer)
  RETURNS TABLE (
    address bigint,
	"position" integer,
    expression_id integer,
	base_type_id integer,
	path integer[],
	"offset" integer)
  LANGUAGE SQL AS

$$

SELECT address, "position", expression_id, base_type_id, path, "offset"
  FROM bn_expression_types
 WHERE module_id = $1
   AND address = $2
   AND "position" = $3
   AND expression_id = $4;

$$;
COMMENT ON FUNCTION load_type_substitution(
  IN moduleid integer,
  IN address bigint,
  IN "position" integer,
  IN expression_id integer)
  IS 'Loads a aingle type susbtitutions.';

--
-- delete_type
--

CREATE OR REPLACE FUNCTION delete_type(
  IN module_id integer,
  IN type_id integer)
  RETURNS void
  LANGUAGE SQL AS
$$
DELETE FROM bn_types AS t
  WHERE t.module_id = $1
    AND t.id = $2;
$$;
COMMENT ON FUNCTION delete_type(IN moduleid integer, IN typeid integer)
  IS 'This function deletes a single type from bn_types also known as a member type if leaves a hole in the compound type at the member offset as large as the members size.';

--
-- update_member_offsets(IN module_id integer, IN moved_members integer[], IN delta integer, IN implicitly_moved_members integer[], IN implicit_delta integer)
--

CREATE OR REPLACE FUNCTION update_member_offsets(IN module_id integer, IN updated_members integer[], IN delta integer, IN implicitly_updated_members integer[], IN implicit_delta integer)
  RETURNS void LANGUAGE sql AS
$$
WITH moved AS (
  UPDATE bn_types
  SET "offset" = "offset" + $3
  WHERE module_id = $1
    AND id = any($2)
)
UPDATE bn_types
SET "offset" = "offset" + $5
WHERE module_id = $1
  AND id = any($4);
$$;
COMMENT ON FUNCTION update_member_offsets(IN module_id integer, IN updated_members integer[], IN delta integer, IN implicitly_updated_members integer[], IN implicit_delta integer)
  IS 'This function adjusts the offsets of the updated_members by delta and the offsets of implicitly_updated_members by implicit_dela, respectively.';

--
-- locate_type
--

CREATE OR REPLACE FUNCTION locate_type(IN moduleid integer, IN parentid integer, IN currentoffset integer)
  RETURNS integer LANGUAGE plpgsql AS
$$
SELECT bt.id FROM bn_types AS bt
  JOIN bn_base_types AS bbt
    ON bt.base_type = bbt.id
   AND bt.module_id = bbt.module_id
 WHERE bt.module_id = moduleid
   AND bt.parent_id = parentid
   AND bt.offset <= currentoffset
   AND bt.offset + bbt.size >= currentoffset
$$;
COMMENT ON FUNCTION locate_type(IN moduleid integer, IN parentid integer, IN currentoffset integer)
  IS 'Locates the bn_type id of a type at a given offset.';

--
-- move_type
--

CREATE OR REPLACE FUNCTION move_type(IN moduleid integer, IN old_parent_id integer, IN new_parent_id integer, IN type_id integer, IN newoffset integer)
  RETURNS void LANGUAGE plpgsql AS
$$
DECLARE
  oldoffset integer;
BEGIN
  --
  -- Determine if the parent ids are the same
  --
  IF old_parent_id = new_parent_id THEN
        --
	-- same struct move
	--
    SELECT offset FROM bn_types
	  WHERE module_id = moduleid
	    AND id = type_id
	   INTO oldoffset;

	IF newoffset > oldoffset THEN
	  --
      -- we have moved the member up.
      --

	ELSE
	  --
	  -- we have moved the member down.
	  --

	END IF;
  ELSE
    --
	-- different struct move
	--

  END IF;
END;
$$;

--
-- delete_type_member_compact_struct
--
CREATE OR REPLACE FUNCTION delete_type_compact(IN module_id integer, IN type_id integer)
  --RETURNS bn_types LANGUAGE plpgsql AS
  RETURNS integer LANGUAGE plpgsql AS
$$
DECLARE
  deleted bn_types;
  deletedsize integer;
BEGIN
  --
  -- Delete the type first.
  --
  SELECT delete_type(module_id, type_id)
    INTO deleted;

  --
  -- Find the size of the type.
  --
  SELECT size FROM bn_base_types bt
    WHERE bt.module_id = module_id
	  AND bt.id = deleted.base_type
	 INTO deletedsize;

  --
  -- Then update the offsets.
  --
  PERFORM update_type_offsets(module_id, deleted.parent_id, deletedsize, deleted.offset);
END;
$$;
COMMENT ON FUNCTION delete_type_compact(IN module_id integer, IN type_id integer)
  IS 'This function deletes a single type from bn_types and compacts the other elements in the compound type to leave no hole where the element has been.';

```

`x86_disasm.py`:

```py
#!/usr/bin/env python

'''
An x86/X64 disassembly module for a stand-alone binnavi compatible disassembler
'''

__author__ = "Chris Eagle"
__copyright__ = "Copyright 2015, Chris Eagle"
__credits__ = ["Chris Eagle"]
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Chris Eagle"
__email__ = "cseagle@gmail.com"
__status__ = "Use at your own risk"

import sys
import struct
import hashlib
import os
import binascii
import psycopg2
import capstone
import capstone.x86_const
import pe_loader
import elf_loader
import binnavi_db
from bn_disasm import *

'''
TODO
   resolve switch table jumps
   find virtual functions
   locate unfound instruction bytes
   identify thunk functions and what they thunk to
   figure out how expression_substitutions work
   figure out when 'symbol' field in expression_nodes is used
   get address_references working
   build stack_frames
'''

def signed_byte(b):
   if b & 0x80:
      return -(256 - b)
   return b

def signed_dword(d):
   val = unsigned_dword(d)
   if val & 0x80000000:
      return -(0x100000000 - val)
   return val

def unsigned_dword(d):
   val = 0
   shift = 0
   for b in d:
      val = val + (b << shift)
      shift += 8
   return val

def tostr(inst):
   res = ''
   for b in inst.bytes:
      res += chr(b)
   return binascii.hexlify(res)

class x86_disasm(Disassembly):

   def __init__(self, loader):
      Disassembly.__init__(self, loader)

      self.dis = capstone.Cs(loader.arch, loader.mode)
      self.dis.detail = True

      for addr,name in self.loader.exports_by_addr.iteritems():
         self.names[addr] = name
         if self.is_possible_code(addr):
            self.locs.append(addr)
            self.call_targets.add(addr)
            if addr != 0:
               #treat address zero differently, don't add xrefs to it
               self.add_basic_block_start(addr)

      if loader.mode == capstone.CS_MODE_32 and loader.arch == capstone.CS_ARCH_X86:
         self.func_sigs.append("\x8b\xff\x55\x8b\xec")
         self.func_sigs.append("\x55\x8b\xec")

   def get_dword(self, addr):
      return self.loader.get_dword(addr)

   def get_qword(self, addr):
      return self.loader.get_qword(addr)

   def get_pointer(self, addr):
      return self.loader.get_pointer(addr)

   def scan_data(self):
      for s in self.loader.sections:
         if s.name == ".rdata":
            ptr_mask = ~(self.loader.sizeof_ptr - 1)
            for addr in range(s.start, s.end & ptr_mask, self.loader.sizeof_ptr):
               val = self.get_pointer(addr)
               if val is None:
                  break
               if self.is_possible_code(val) and val not in self.visited:
                  self.locs.append(val)

   def get_op_name(self, addr, default):
      if addr in self.xrefs_from:
         refs = self.xrefs_from[addr]
         for r in refs:
            if r[1] != XR_FLOW:   # this is a jump or call
               if r[0] in self.loader.imports_by_addr:
                  return self.loader.imports_by_addr[r[0]]
               return self.names[r[0]]
      return default

   def resolve_thunk(self, addr):
      if addr in self.loader.imports_by_addr:
         return self.loader.imports_by_addr[addr]
      return ''

   def add_xref(self, frm, to, xr_type=XR_FLOW):
      if frm not in self.xrefs_from:
         self.xrefs_from[frm] = []
      self.xrefs_from[frm].append((to, xr_type))
      from_list = self.xrefs_from[frm]
      if len(from_list) >= 2 and not self.is_returning_call(from_list):
         # add all destinations to basic_blocks
         for xr in from_list:
            if xr[0] != 0:
               #treat address zero differently, don't add xrefs to it
               self.add_basic_block_start(xr[0])
      
      if to not in self.xrefs_to:
         self.xrefs_to[to] = []
      self.xrefs_to[to].append((frm, xr_type))
      to_list = self.xrefs_to[to]
      if to not in self.names:
         if xr_type == XR_CALL:
            self.names[to] = 'sub_%x' % to
         elif xr_type >= XR_JUMP:  # JUMP or JCC
            self.names[to] = 'loc_%x' % to
         self.add_loc(to)
      elif xr_type == XR_CALL and self.names[to] == ('loc_%x' % to):
         #update loc_ label to sub_ label now that a call was found 
         self.names[to] = 'sub_%x' % to
      if to not in self.basic_blocks:
         if xr_type == XR_CALL or len(to_list) > 1:
            if to != 0:
               #treat address zero differently, don't add xrefs to it
               self.add_basic_block_start(to)

   #add an address we need to explore
   def add_loc(self, addr):
      if addr in self.visited:
         return
      self.locs.append(addr)

   def is_conditional(self, i):
      op = i.bytes[0]
      if (op >= 0x70 and op <= 0x7f) or (op >= 0xe0 and op <= 0xe3):
         return True
      elif op == 0x0f:
         op2 = i.bytes[1]
         if op2 >= 0x80 and op2 <= 0x8f:
            return True
      return False

   def process_jump(self, i):
      opcode = i.bytes[0]
      offset = signed_byte(i.bytes[1])
      short_tgt = i.address + i.size + offset
      if opcode == 0xeb:   # jmp disp8
         self.add_xref(i.address, short_tgt, XR_JUMP)
         self.jmp_targets.add(short_tgt)
         return True
      if opcode == 0xe9:   # jmp disp32
         offset = signed_dword(i.bytes[1:5])
         tgt = i.address + i.size + offset
         self.add_xref(i.address, tgt, XR_JUMP)
         self.jmp_targets.add(tgt)
         return True
      if (opcode >= 0x70 and opcode <= 0x7f) or opcode == 0xe3: # jcc jecx disp8
         self.add_xref(i.address, short_tgt, XR_JCC)
         self.jmp_targets.add(short_tgt)
         return False
      elif opcode == 0x0f:  # jcc disp32
         op2 = i.bytes[1]
         if op2 >= 0x80 and op2 <= 0x8f:
            offset = signed_dword(i.bytes[2:6])
            tgt = i.address + i.size + offset
            self.add_xref(i.address, tgt, XR_JCC)
            self.jmp_targets.add(tgt)
            return False
#         else:
#            sys.stderr.write("Classified jump (0x0f), not categorized at address 0x%x: %s\n" % (i.address, tostr(i)))
      elif opcode == 0xff:
         modrm = i.modrm   # i.bytes[1]
         if modrm == 0x25: #near jump [disp]
            slot = unsigned_dword(i.bytes[2:6])
            if i.address in self.loader.imports_by_addr: #this is a thunk  DO BETTER HERE
               self.thunks.add(i.address)
               self.names[i.address] = self.loader.imports_by_addr[i.address]
#         else:
#            sys.stderr.write("Classified jump (0xff), not categorized at address 0x%x: %s\n" % (i.address, tostr(i)))
         return True
#      else:
#         sys.stderr.write("Classified jump, not categorized at address 0x%x: %s\n" % (i.address, tostr(i)))
      return True

   def process_call(self, i):
      opcode = i.bytes[0]
      if opcode == 0xe8:   # call disp32
         offset = signed_dword(i.bytes[1:5])
         tgt = i.address + i.size + offset
         self.call_targets.add(tgt)
         self.add_xref(i.address, tgt, XR_CALL)
         #add a minimal stack frame for this function, it will have at least a
         #return address
         #self.add_type("__SF%x" % tgt, self.loader.sizeof_ptr, None, False, STRUCT)
         return tgt in self.names and self.names[tgt] in self.loader.non_returning_funcs
      elif opcode == 0xff:
         modrm = i.modrm   # i.bytes[1]
         if modrm == 0x15: #near call [disp]
            slot = unsigned_dword(i.bytes[2:6])
            #sometimes this will be an imported function other times not
            #only xref that is really taking place here is a data reference
            #self.add_xref(i.address, slot, XR_CALL)
#         else:
#            sys.stderr.write("Classified call (0xff), not categorized at address 0x%x: %s\n" % (i.address, tostr(i)))
#      else:
#         sys.stderr.write("Classified call, not categorized at address 0x%x: %s\n" % (i.address, tostr(i)))
      #assume all calls return
      return False

   def add_address_ref(self, inst, opnum, node_id, aref_addr, false_id):
      is_jump = inst.group(capstone.CS_GRP_JUMP)
      is_call = inst.group(capstone.CS_GRP_CALL)
      if inst.operands[opnum].type == capstone.x86_const.X86_OP_IMM:
         if is_jump:
            if self.is_conditional(inst):
               self.arefs.append(AddressRef(inst.address, opnum, node_id, aref_addr, CONDITION_TRUE))
               self.arefs.append(AddressRef(inst.address, opnum, false_id, inst.address + inst.size, CONDITION_FALSE))
            else:
               self.arefs.append(AddressRef(inst.address, opnum, node_id, aref_addr, UNCONDITIONAL))
         elif is_call:
            self.arefs.append(AddressRef(inst.address, opnum, node_id, aref_addr, CALL_DIRECT))
         else:
            #raw data, aref_addr is an offset
            pass
      elif inst.operands[opnum].type == capstone.x86_const.X86_OP_MEM:
         if is_jump:
            dest = self.get_pointer(aref_addr)
            #try to determine whether this is a switch table
            if dest is not None and self.is_possible_code(dest):
               self.arefs.append(AddressRef(inst.address, opnum, node_id, dest, UNCONDITIONAL))
         elif is_call:
            dest = self.get_pointer(aref_addr)
            #try to determine whether this is a switch table
            if dest is not None and self.is_possible_code(dest):
               self.arefs.append(AddressRef(inst.address, opnum, node_id, dest, CALL_INDIRECT))
         else:
            #raw data, aref_addr is a pointer
            #could check content at aref_addr to see if its a string
            self.arefs.append(AddressRef(inst.address, opnum, node_id, aref_addr, DATA))

   #THIS IS HIGHLY ARCHITECTURE DEPENDENT
   def process_operands(self, inst):
      opnum = 0
      #annotate the CsInsn with the operands we build here
      op_exprs = []
      for op in inst.operands:
         add_aref = False
         aref_addr = 0
         aref_op = 0
         aref_type = -1
         op_size = 'b%d' % op.size
         tree = []
         tree.append(OpNode(SIZE_PREFIX, op_size))
         if op.type == capstone.x86_const.X86_OP_REG:
            reg = inst.reg_name(op.reg)
            #operand expr is: op_size reg
            tree.append(OpNode(REGISTER, reg))
         elif op.type == capstone.x86_const.X86_OP_IMM:
            imm = op.imm
            #operand expr is: op_size imm
            tree.append(OpNode(IMMEDIATE_INT, imm))
            s = self.loader.get_section(imm)
            if s is not None:
               #immediate refers to a memory address
               #let's add an AddressRef
               add_aref = True
               aref_op = 1
               aref_addr = imm
         elif op.type == capstone.x86_const.X86_OP_MEM:
            if op.mem.segment == capstone.x86_const.X86_REG_INVALID:
               op_seg = None
            else:
               op_seg = '%s:' % inst.reg_name(op.mem.segment)
               tree.append(OpNode(OPERATOR + 10, op_seg))  # 10 = unary operator

            op_disp = op.mem.disp
            tree.append(OpNode(DEREFERENCE, '['))
            s = self.loader.get_section(op_disp)
            if s is not None:
               #immediate refers to a memory address
               #let's add an AddressRef
               add_aref = True
               aref_addr = op_disp

            if op.mem.base != capstone.x86_const.X86_REG_INVALID:   #has a base reg
               op_base = inst.reg_name(op.mem.base)
               if op.mem.index != capstone.x86_const.X86_REG_INVALID:   #has an index reg
                  op_scale = op.mem.scale
                  op_index = inst.reg_name(op.mem.index)
                  tree.append(OpNode(OPERATOR + 20, '+'))  # 20 = unary operator
                  tree.append(OpNode(REGISTER, op_base))
                  if op_scale == 1:
                     if op_disp == 0:
                        #operand expr is: op_size op_seg [ + op_base op_index
                        tree.append(OpNode(REGISTER, op_index))
                     else:
                        #operand expr is: op_size op_seg [ + op_base + op_index op_disp
                        tree.append(OpNode(OPERATOR + 20, '+'))  # 20 = unary operator
                        tree.append(OpNode(REGISTER, op_index))
                        aref_op = len(tree)
                        tree.append(OpNode(IMMEDIATE_INT, op_disp))
                  else:
                     if op_disp == 0:
                        #operand expr is: op_size op_seg [ + op_base * op_index op_scale
                        tree.append(OpNode(OPERATOR + 20, '*'))  # 20 = unary operator
                        tree.append(OpNode(REGISTER, op_index))
                        tree.append(OpNode(IMMEDIATE_INT, op_scale))
                     else:
                        #operand expr is: op_size op_seg [ + op_base + * op_index op_scale op_disp
                        tree.append(OpNode(OPERATOR + 20, '+'))  # 20 = unary operator
                        tree.append(OpNode(OPERATOR + 20, '*'))  # 20 = unary operator
                        tree.append(OpNode(REGISTER, op_index))
                        tree.append(OpNode(IMMEDIATE_INT, op_scale))
                        aref_op = len(tree)
                        tree.append(OpNode(IMMEDIATE_INT, op_disp))
               else:
                  if op_disp == 0:
                     #operand expr is: op_size op_seg [ op_base
                     tree.append(OpNode(REGISTER, op_base))
                  else:
                     #operand expr is: op_size op_seg [ + op_base op_disp
                     tree.append(OpNode(OPERATOR + 20, '+'))  # 20 = unary operator
                     tree.append(OpNode(REGISTER, op_base))
                     aref_op = len(tree)
                     tree.append(OpNode(IMMEDIATE_INT, op_disp))
            elif op.mem.index != capstone.x86_const.X86_REG_INVALID:   #has an index reg
               op_scale = op.mem.scale
               op_index = inst.reg_name(op.mem.index)
               if op_scale == 1:
                  if op_disp == 0:
                     #operand expr is: op_size op_seg [ op_index
                     tree.append(OpNode(REGISTER, op_index))
                  else:
                     #operand expr is: op_size op_seg [ + op_index op_disp
                     tree.append(OpNode(OPERATOR + 20, '+'))  # 20 = unary operator
                     tree.append(OpNode(REGISTER, op_index))
                     aref_op = len(tree)
                     tree.append(OpNode(IMMEDIATE_INT, op_disp))
               else:
                  if op_disp == 0:
                     #operand expr is: op_size op_seg [ * op_index op_scale
                     tree.append(OpNode(OPERATOR + 20, '*'))  # 20 = unary operator
                     tree.append(OpNode(REGISTER, op_index))
                     tree.append(OpNode(IMMEDIATE_INT, op_scale))
                  else:
                     #operand expr is: op_size op_seg [ + * op_index op_scale op_disp
                     tree.append(OpNode(OPERATOR + 20, '+'))  # 20 = unary operator
                     tree.append(OpNode(OPERATOR + 20, '*'))  # 20 = unary operator
                     tree.append(OpNode(REGISTER, op_index))
                     tree.append(OpNode(IMMEDIATE_INT, op_scale))
                     aref_op = len(tree)
                     tree.append(OpNode(IMMEDIATE_INT, op_disp))
            else:  #must be [disp] only, mem with no registers
               #operand expr is: op_size op_seg [ op_disp
               aref_op = len(tree)
               tree.append(OpNode(IMMEDIATE_INT, op_disp))
         elif op.type == capstone.x86_const.X86_OP_FP:
            sys.stderr.write("found an FP operand at 0x%x, op %d\n" % (inst.address, opnum))
         else:
            sys.stderr.write("Unknown operand at 0x%x, op %d\n" % (inst.address, opnum))
         # store operand expression tree for inst.addr, opnum
         if len(tree) > 0:
            expr = self.add_expr_tree(tree)
            if expr != 0:
               op_exprs.append(expr)
               if add_aref:
                  self.add_address_ref(inst, opnum, tree[aref_op].node_id, aref_addr, tree[0].node_id)
         opnum += 1
      self.operands[inst.address] = op_exprs

   def scan_gap_data(self):
      ptr_sz = self.loader.sizeof_ptr

      keylist = [a for a in self.visited]
      keylist.sort()
      last = None
      count = 0
      for a in keylist:
         i = self.insts[a]
         if last is not None and (last.address + last.size) != a:
            gap_start = last.address + last.size
            #round up to ptr aligned address
            gap_start = (gap_start + ptr_sz - 1) & ~(ptr_sz - 1)
            if gap_start >= a:
               continue
            for addr in range(gap_start, a, ptr_sz):
               val = self.get_pointer(addr)
               if val is None:
                  break
               if self.is_possible_code(val) and val not in self.visited:
                  self.locs.append(val)
                  #print "Adding text ptr 0x%x" % val
                  count += 1
         last = i
      #print "Gap data analysis added %d new locations" % count


def main(exe_file):
   ldr = pe_loader.Pe32(exe_file)
   if not ldr.load():
      del ldr
      ldr = pe_loader.Pe64(exe_file)
      if not ldr.load():
         del ldr
         ldr = elf_loader.Elf32(exe_file)
         if not ldr.load():
            del ldr
            ldr = elf_loader.Elf64(exe_file)
            if not ldr.load():
               del ldr
               print "Failed to recognize input file type"
               return

   dis = x86_disasm(ldr)
   print "starting with %d initial locations" % len(dis.locs)
   dis.generate_data()

   print "found %d instructions" % len(dis.visited)

   '''
   print "Functions identified at:"
   dis.call_targets.sort()
   for c in dis.call_targets:
      print "   0x%x" % c
   '''

   dis.print_disassembly()

if __name__ == "__main__":
   main(sys.argv[1])

```