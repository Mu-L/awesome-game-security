Project Path: arc_gmh5225_COD-boiii_n7nn08xv

Source Tree:

```txt
arc_gmh5225_COD-boiii_n7nn08xv
├── LICENSE
├── README.md
├── deps
│   ├── asmjit
│   ├── discord-rpc
│   ├── extra
│   │   └── udis86
│   │       └── libudis86
│   │           ├── itab.c
│   │           └── itab.h
│   ├── libtomcrypt
│   ├── libtommath
│   ├── minhook
│   ├── premake
│   │   ├── asmjit.lua
│   │   ├── discord-rpc.lua
│   │   ├── libtomcrypt.lua
│   │   ├── libtommath.lua
│   │   ├── minhook.lua
│   │   ├── minizip.lua
│   │   ├── rapidjson.lua
│   │   ├── stb.lua
│   │   ├── udis86.lua
│   │   └── zlib.lua
│   ├── rapidjson
│   ├── stb
│   ├── udis86
│   └── zlib
├── generate.bat
├── premake5.lua
├── src
│   ├── client
│   │   ├── component
│   │   │   ├── arxan.cpp
│   │   │   ├── auth.cpp
│   │   │   ├── auth.hpp
│   │   │   ├── bots.cpp
│   │   │   ├── branding.cpp
│   │   │   ├── chat.cpp
│   │   │   ├── client_command.cpp
│   │   │   ├── client_command.hpp
│   │   │   ├── colors.cpp
│   │   │   ├── command.cpp
│   │   │   ├── command.hpp
│   │   │   ├── console.cpp
│   │   │   ├── console_command.cpp
│   │   │   ├── console_command.hpp
│   │   │   ├── dedi_patches.cpp
│   │   │   ├── dedicated.cpp
│   │   │   ├── dedicated.hpp
│   │   │   ├── demonware.cpp
│   │   │   ├── discord.cpp
│   │   │   ├── exception.cpp
│   │   │   ├── game_log.cpp
│   │   │   ├── getinfo.cpp
│   │   │   ├── icon.cpp
│   │   │   ├── intro.cpp
│   │   │   ├── loot.cpp
│   │   │   ├── network.cpp
│   │   │   ├── network.hpp
│   │   │   ├── party.cpp
│   │   │   ├── party.hpp
│   │   │   ├── scheduler.cpp
│   │   │   ├── scheduler.hpp
│   │   │   ├── server_list.cpp
│   │   │   ├── server_list.hpp
│   │   │   ├── splash.cpp
│   │   │   ├── splash.hpp
│   │   │   ├── steam_proxy.cpp
│   │   │   ├── steam_proxy.hpp
│   │   │   ├── updater.cpp
│   │   │   └── updater.hpp
│   │   ├── game
│   │   │   ├── demonware
│   │   │   │   ├── bit_buffer.cpp
│   │   │   │   ├── bit_buffer.hpp
│   │   │   │   ├── byte_buffer.cpp
│   │   │   │   ├── byte_buffer.hpp
│   │   │   │   ├── data_types.hpp
│   │   │   │   ├── keys.cpp
│   │   │   │   ├── keys.hpp
│   │   │   │   ├── reply.cpp
│   │   │   │   ├── reply.hpp
│   │   │   │   ├── server_registry.hpp
│   │   │   │   ├── servers
│   │   │   │   │   ├── auth3_server.cpp
│   │   │   │   │   ├── auth3_server.hpp
│   │   │   │   │   ├── base_server.cpp
│   │   │   │   │   ├── base_server.hpp
│   │   │   │   │   ├── lobby_server.cpp
│   │   │   │   │   ├── lobby_server.hpp
│   │   │   │   │   ├── service_server.hpp
│   │   │   │   │   ├── stun_server.cpp
│   │   │   │   │   ├── stun_server.hpp
│   │   │   │   │   ├── tcp_server.cpp
│   │   │   │   │   ├── tcp_server.hpp
│   │   │   │   │   ├── udp_server.cpp
│   │   │   │   │   ├── udp_server.hpp
│   │   │   │   │   ├── umbrella_server.cpp
│   │   │   │   │   └── umbrella_server.hpp
│   │   │   │   ├── service.hpp
│   │   │   │   ├── services
│   │   │   │   │   ├── bdAnticheat.cpp
│   │   │   │   │   ├── bdAnticheat.hpp
│   │   │   │   │   ├── bdBandwidthTest.cpp
│   │   │   │   │   ├── bdBandwidthTest.hpp
│   │   │   │   │   ├── bdContentStreaming.cpp
│   │   │   │   │   ├── bdContentStreaming.hpp
│   │   │   │   │   ├── bdCounter.cpp
│   │   │   │   │   ├── bdCounter.hpp
│   │   │   │   │   ├── bdDDL.cpp
│   │   │   │   │   ├── bdDDL.hpp
│   │   │   │   │   ├── bdDML.cpp
│   │   │   │   │   ├── bdDML.hpp
│   │   │   │   │   ├── bdEventLog.cpp
│   │   │   │   │   ├── bdEventLog.hpp
│   │   │   │   │   ├── bdFacebook.cpp
│   │   │   │   │   ├── bdFacebook.hpp
│   │   │   │   │   ├── bdGroup.cpp
│   │   │   │   │   ├── bdGroup.hpp
│   │   │   │   │   ├── bdLeague.cpp
│   │   │   │   │   ├── bdLeague.hpp
│   │   │   │   │   ├── bdLeague2.cpp
│   │   │   │   │   ├── bdLeague2.hpp
│   │   │   │   │   ├── bdMarketingComms.cpp
│   │   │   │   │   ├── bdMarketingComms.hpp
│   │   │   │   │   ├── bdMarketplace.cpp
│   │   │   │   │   ├── bdMarketplace.hpp
│   │   │   │   │   ├── bdMatchMaking.cpp
│   │   │   │   │   ├── bdMatchMaking.hpp
│   │   │   │   │   ├── bdPresence.cpp
│   │   │   │   │   ├── bdPresence.hpp
│   │   │   │   │   ├── bdProfiles.cpp
│   │   │   │   │   ├── bdProfiles.hpp
│   │   │   │   │   ├── bdPublisherVariables.cpp
│   │   │   │   │   ├── bdPublisherVariables.hpp
│   │   │   │   │   ├── bdReward.cpp
│   │   │   │   │   ├── bdReward.hpp
│   │   │   │   │   ├── bdRichPresence.cpp
│   │   │   │   │   ├── bdRichPresence.hpp
│   │   │   │   │   ├── bdStats.cpp
│   │   │   │   │   ├── bdStats.hpp
│   │   │   │   │   ├── bdStats2.cpp
│   │   │   │   │   ├── bdStats2.hpp
│   │   │   │   │   ├── bdStats3.cpp
│   │   │   │   │   ├── bdStats3.hpp
│   │   │   │   │   ├── bdStorage.cpp
│   │   │   │   │   ├── bdStorage.hpp
│   │   │   │   │   ├── bdTeams.cpp
│   │   │   │   │   ├── bdTeams.hpp
│   │   │   │   │   ├── bdTitleUtilities.cpp
│   │   │   │   │   ├── bdTitleUtilities.hpp
│   │   │   │   │   ├── bdUNK63.cpp
│   │   │   │   │   ├── bdUNK63.hpp
│   │   │   │   │   ├── bdUserGroups.cpp
│   │   │   │   │   └── bdUserGroups.hpp
│   │   │   │   └── services.hpp
│   │   │   ├── game.cpp
│   │   │   ├── game.hpp
│   │   │   ├── structs.hpp
│   │   │   ├── symbols.cpp
│   │   │   └── symbols.hpp
│   │   ├── launcher
│   │   │   ├── html
│   │   │   │   ├── dispatch.hpp
│   │   │   │   ├── doc_host_ui_handler.hpp
│   │   │   │   ├── html_argument.cpp
│   │   │   │   ├── html_argument.hpp
│   │   │   │   ├── html_frame.cpp
│   │   │   │   ├── html_frame.hpp
│   │   │   │   ├── html_window.cpp
│   │   │   │   ├── html_window.hpp
│   │   │   │   ├── internet_security_manager.hpp
│   │   │   │   ├── ole_client_site.hpp
│   │   │   │   ├── ole_in_place_frame.hpp
│   │   │   │   ├── ole_in_place_site.hpp
│   │   │   │   └── service_provider.hpp
│   │   │   ├── launcher.cpp
│   │   │   ├── launcher.hpp
│   │   │   ├── window.cpp
│   │   │   └── window.hpp
│   │   ├── loader
│   │   │   ├── component_interface.hpp
│   │   │   ├── component_loader.cpp
│   │   │   ├── component_loader.hpp
│   │   │   ├── loader.cpp
│   │   │   ├── loader.hpp
│   │   │   ├── tls.cpp
│   │   │   └── tls.hpp
│   │   ├── main.cpp
│   │   ├── resource.hpp
│   │   ├── resource.rc
│   │   ├── resources
│   │   │   ├── dw
│   │   │   │   ├── core_ffotd_tu32_593.ff
│   │   │   │   ├── experiments_tu32.gz
│   │   │   │   ├── featured_cards-english_tu32.gz
│   │   │   │   ├── keys.txt
│   │   │   │   ├── playlists_tu32.gz
│   │   │   │   └── qosconfig4.csv
│   │   │   ├── icon.ico
│   │   │   ├── logo.jpg
│   │   │   ├── main.html
│   │   │   └── splash.jpg
│   │   ├── std_include.cpp
│   │   ├── std_include.hpp
│   │   └── steam
│   │       ├── interface.cpp
│   │       ├── interface.hpp
│   │       ├── interfaces
│   │       │   ├── apps.cpp
│   │       │   ├── apps.hpp
│   │       │   ├── client.cpp
│   │       │   ├── client.hpp
│   │       │   ├── controller.cpp
│   │       │   ├── controller.hpp
│   │       │   ├── friends.cpp
│   │       │   ├── friends.hpp
│   │       │   ├── game_server.cpp
│   │       │   ├── game_server.hpp
│   │       │   ├── game_server_stats.cpp
│   │       │   ├── game_server_stats.hpp
│   │       │   ├── http.cpp
│   │       │   ├── http.hpp
│   │       │   ├── matchmaking.cpp
│   │       │   ├── matchmaking.hpp
│   │       │   ├── matchmaking_servers.cpp
│   │       │   ├── matchmaking_servers.hpp
│   │       │   ├── networking.cpp
│   │       │   ├── networking.hpp
│   │       │   ├── remote_storage.cpp
│   │       │   ├── remote_storage.hpp
│   │       │   ├── screenshots.cpp
│   │       │   ├── screenshots.hpp
│   │       │   ├── ugc.cpp
│   │       │   ├── ugc.hpp
│   │       │   ├── unified_messages.cpp
│   │       │   ├── unified_messages.hpp
│   │       │   ├── user.cpp
│   │       │   ├── user.hpp
│   │       │   ├── user_stats.cpp
│   │       │   ├── user_stats.hpp
│   │       │   ├── utils.cpp
│   │       │   └── utils.hpp
│   │       ├── steam.cpp
│   │       └── steam.hpp
│   ├── common
│   │   ├── exception
│   │   │   ├── minidump.cpp
│   │   │   └── minidump.hpp
│   │   └── utils
│   │       ├── binary_resource.cpp
│   │       ├── binary_resource.hpp
│   │       ├── com.cpp
│   │       ├── com.hpp
│   │       ├── compression.cpp
│   │       ├── compression.hpp
│   │       ├── concurrency.hpp
│   │       ├── cryptography.cpp
│   │       ├── cryptography.hpp
│   │       ├── finally.hpp
│   │       ├── flags.cpp
│   │       ├── flags.hpp
│   │       ├── hardware_breakpoint.cpp
│   │       ├── hardware_breakpoint.hpp
│   │       ├── hook.cpp
│   │       ├── hook.hpp
│   │       ├── http.cpp
│   │       ├── http.hpp
│   │       ├── image.cpp
│   │       ├── image.hpp
│   │       ├── info_string.cpp
│   │       ├── info_string.hpp
│   │       ├── io.cpp
│   │       ├── io.hpp
│   │       ├── memory.cpp
│   │       ├── memory.hpp
│   │       ├── nt.cpp
│   │       ├── nt.hpp
│   │       ├── progress_ui.cpp
│   │       ├── progress_ui.hpp
│   │       ├── signature.cpp
│   │       ├── signature.hpp
│   │       ├── smbios.cpp
│   │       ├── smbios.hpp
│   │       ├── string.cpp
│   │       ├── string.hpp
│   │       ├── thread.cpp
│   │       └── thread.hpp
│   └── tlsdll
│       ├── dllmain.cpp
│       ├── resource.rc
│       └── tlssup.cpp
└── tools
    └── premake5.exe

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
![license](https://img.shields.io/github/license/momo5502/boiii.svg)
[![build](https://github.com/momo5502/boiii/workflows/Build/badge.svg)](https://github.com/momo5502/boiii/actions)
[![paypal](https://img.shields.io/badge/PayPal-support-blue.svg?logo=paypal)](https://paypal.me/momo5502)


# BOIII ☄️

Reverse engineering and analysis of Call of Duty: Black Ops 3. Very experimental.

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQeSXYzQITJrcjiifN1nqX1fsVE7VwLZ3vl2g&usqp=CAU">

## Roadmap

- [x] Steam API Emulation
- [x] Steam Integrity Bypass
- [x] Offline Multiplayer/Zombies/Campaign Support
- [x] RE Tool Detection Bypass (only the ones I use: IDA Pro, HxD, Wireshark)
- [x] Disable Hardware Breakpoint Detection
- [x] Disable Integrity Checks
- [x] Demonware Emulation
- [ ] Disable Anti-Debugging Mechanisms (probably never gonna happen cause who needs that if you have printf debugging)
- [x] Process wrapper
- [x] P2P multiplayer
- [ ] Dedicated Servers

## Disclaimer

This software has been created purely for the purposes of
academic research. It is not intended to be used to harm
others. Project maintainers are not responsible or
liable for misuse of the software. Use responsibly.


```

`deps/extra/udis86/libudis86/itab.c`:

```c
/* itab.c -- generated by udis86:scripts/ud_itab.py, do no edit */
#include "decode.h"

#define GROUP(n) (0x8000 | (n))
#define INVALID  0


const uint16_t ud_itab__0[] = {
  /*  0 */          15,          16,          17,          18,
  /*  4 */          19,          20,    GROUP(1),    GROUP(2),
  /*  8 */         964,         965,         966,         967,
  /*  c */         968,         969,    GROUP(3),    GROUP(4),
  /* 10 */           5,           6,           7,           8,
  /* 14 */           9,          10,  GROUP(284),  GROUP(285),
  /* 18 */        1336,        1337,        1338,        1339,
  /* 1c */        1340,        1341,  GROUP(286),  GROUP(287),
  /* 20 */          49,          50,          51,          52,
  /* 24 */          53,          54,     INVALID,  GROUP(288),
  /* 28 */        1407,        1408,        1409,        1410,
  /* 2c */        1411,        1412,     INVALID,  GROUP(289),
  /* 30 */        1487,        1488,        1489,        1490,
  /* 34 */        1491,        1492,     INVALID,  GROUP(290),
  /* 38 */         100,         101,         102,         103,
  /* 3c */         104,         105,     INVALID,  GROUP(291),
  /* 40 */         699,         700,         701,         702,
  /* 44 */         703,         704,         705,         706,
  /* 48 */         175,         176,         177,         178,
  /* 4c */         179,         180,         181,         182,
  /* 50 */        1246,        1247,        1248,        1249,
  /* 54 */        1250,        1251,        1252,        1253,
  /* 58 */        1101,        1102,        1103,        1104,
  /* 5c */        1105,        1106,        1107,        1108,
  /* 60 */  GROUP(292),  GROUP(295),  GROUP(298),  GROUP(299),
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */        1254,         697,        1256,         698,
  /* 6c */         709,  GROUP(300),         982,  GROUP(301),
  /* 70 */         726,         728,         730,         732,
  /* 74 */         734,         736,         738,         740,
  /* 78 */         742,         744,         746,         748,
  /* 7c */         750,         752,         754,         756,
  /* 80 */  GROUP(302),  GROUP(303),  GROUP(304),  GROUP(313),
  /* 84 */        1433,        1434,        1475,        1476,
  /* 88 */         828,         829,         830,         831,
  /* 8c */         832,         770,         833,  GROUP(314),
  /* 90 */        1477,        1478,        1479,        1480,
  /* 94 */        1481,        1482,        1483,        1484,
  /* 98 */  GROUP(315),  GROUP(316),  GROUP(317),        1470,
  /* 9c */  GROUP(318),  GROUP(322),        1310,         766,
  /* a0 */         834,         835,         836,         837,
  /* a4 */         922,  GROUP(326),         114,  GROUP(327),
  /* a8 */        1435,        1436,        1402,  GROUP(328),
  /* ac */         790,  GROUP(329),        1346,  GROUP(330),
  /* b0 */         838,         839,         840,         841,
  /* b4 */         842,         843,         844,         845,
  /* b8 */         846,         847,         848,         849,
  /* bc */         850,         851,         852,         853,
  /* c0 */  GROUP(331),  GROUP(332),        1301,        1302,
  /* c4 */  GROUP(333),  GROUP(403),  GROUP(405),  GROUP(406),
  /* c8 */         200,         776,        1303,        1304,
  /* cc */         713,         714,  GROUP(407),  GROUP(408),
  /* d0 */  GROUP(409),  GROUP(410),  GROUP(411),  GROUP(412),
  /* d4 */  GROUP(413),  GROUP(414),  GROUP(415),        1486,
  /* d8 */  GROUP(416),  GROUP(419),  GROUP(422),  GROUP(425),
  /* dc */  GROUP(428),  GROUP(431),  GROUP(434),  GROUP(437),
  /* e0 */         794,         795,         796,  GROUP(440),
  /* e4 */         690,         691,         978,         979,
  /* e8 */          72,         763,  GROUP(441),         765,
  /* ec */         692,         693,         980,         981,
  /* f0 */         789,         712,        1299,        1300,
  /* f4 */         687,          83,  GROUP(442),  GROUP(443),
  /* f8 */          77,        1395,          81,        1398,
  /* fc */          78,        1396,  GROUP(444),  GROUP(445),
};

static const uint16_t ud_itab__1[] = {
  /*  0 */        1240,     INVALID,
};

static const uint16_t ud_itab__2[] = {
  /*  0 */        1096,     INVALID,
};

static const uint16_t ud_itab__3[] = {
  /*  0 */        1241,     INVALID,
};

static const uint16_t ud_itab__4[] = {
  /*  0 */    GROUP(5),    GROUP(6),         767,         797,
  /*  4 */     INVALID,        1426,          82,        1431,
  /*  8 */         716,        1471,     INVALID,        1444,
  /*  c */     INVALID,   GROUP(27),         430,   GROUP(28),
  /* 10 */   GROUP(29),   GROUP(30),   GROUP(31),   GROUP(34),
  /* 14 */   GROUP(35),   GROUP(36),   GROUP(37),   GROUP(40),
  /* 18 */   GROUP(41),         955,         956,         957,
  /* 1c */         958,         959,         960,         961,
  /* 20 */         854,         855,         856,         857,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */   GROUP(42),   GROUP(43),   GROUP(44),   GROUP(45),
  /* 2c */   GROUP(46),   GROUP(47),   GROUP(48),   GROUP(49),
  /* 30 */        1472,        1297,        1295,        1296,
  /* 34 */   GROUP(50),   GROUP(52),     INVALID,        1514,
  /* 38 */   GROUP(54),     INVALID,  GROUP(116),     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */          84,          85,          86,          87,
  /* 44 */          88,          89,          90,          91,
  /* 48 */          92,          93,          94,          95,
  /* 4c */          96,          97,          98,          99,
  /* 50 */  GROUP(143),  GROUP(144),  GROUP(145),  GROUP(146),
  /* 54 */  GROUP(147),  GROUP(148),  GROUP(149),  GROUP(150),
  /* 58 */  GROUP(151),  GROUP(152),  GROUP(153),  GROUP(154),
  /* 5c */  GROUP(155),  GROUP(156),  GROUP(157),  GROUP(158),
  /* 60 */  GROUP(159),  GROUP(160),  GROUP(161),  GROUP(162),
  /* 64 */  GROUP(163),  GROUP(164),  GROUP(165),  GROUP(166),
  /* 68 */  GROUP(167),  GROUP(168),  GROUP(169),  GROUP(170),
  /* 6c */  GROUP(171),  GROUP(172),  GROUP(173),  GROUP(176),
  /* 70 */  GROUP(177),  GROUP(178),  GROUP(182),  GROUP(186),
  /* 74 */  GROUP(191),  GROUP(192),  GROUP(193),         199,
  /* 78 */  GROUP(194),  GROUP(195),     INVALID,     INVALID,
  /* 7c */  GROUP(196),  GROUP(197),  GROUP(198),  GROUP(201),
  /* 80 */         727,         729,         731,         733,
  /* 84 */         735,         737,         739,         741,
  /* 88 */         743,         745,         747,         749,
  /* 8c */         751,         753,         755,         757,
  /* 90 */        1350,        1351,        1352,        1353,
  /* 94 */        1354,        1355,        1356,        1357,
  /* 98 */        1358,        1359,        1360,        1361,
  /* 9c */        1362,        1363,        1364,        1365,
  /* a0 */        1245,        1100,         131,        1670,
  /* a4 */        1375,        1376,  GROUP(202),  GROUP(207),
  /* a8 */        1244,        1099,        1305,        1675,
  /* ac */        1377,        1378,  GROUP(215),         694,
  /* b0 */         122,         123,         775,        1673,
  /* b4 */         772,         773,         940,         941,
  /* b8 */  GROUP(221),     INVALID,  GROUP(222),        1671,
  /* bc */        1659,        1660,         930,         931,
  /* c0 */        1473,        1474,  GROUP(223),         904,
  /* c4 */  GROUP(224),  GROUP(225),  GROUP(226),  GROUP(227),
  /* c8 */        1661,        1662,        1663,        1664,
  /* cc */        1665,        1666,        1667,        1668,
  /* d0 */  GROUP(236),  GROUP(237),  GROUP(238),  GROUP(239),
  /* d4 */  GROUP(240),  GROUP(241),  GROUP(242),  GROUP(243),
  /* d8 */  GROUP(244),  GROUP(245),  GROUP(246),  GROUP(247),
  /* dc */  GROUP(248),  GROUP(249),  GROUP(250),  GROUP(251),
  /* e0 */  GROUP(252),  GROUP(253),  GROUP(254),  GROUP(255),
  /* e4 */  GROUP(256),  GROUP(257),  GROUP(258),  GROUP(259),
  /* e8 */  GROUP(260),  GROUP(261),  GROUP(262),  GROUP(263),
  /* ec */  GROUP(264),  GROUP(265),  GROUP(266),  GROUP(267),
  /* f0 */  GROUP(268),  GROUP(269),  GROUP(270),  GROUP(271),
  /* f4 */  GROUP(272),  GROUP(273),  GROUP(274),  GROUP(275),
  /* f8 */  GROUP(277),  GROUP(278),  GROUP(279),  GROUP(280),
  /* fc */  GROUP(281),  GROUP(282),  GROUP(283),     INVALID,
};

static const uint16_t ud_itab__5[] = {
  /*  0 */        1384,        1406,         786,         798,
  /*  4 */        1453,        1454,     INVALID,     INVALID,
};

static const uint16_t ud_itab__6[] = {
  /*  0 */    GROUP(7),    GROUP(8),
};

static const uint16_t ud_itab__7[] = {
  /*  0 */        1374,        1383,         785,         774,
  /*  4 */        1385,     INVALID,         787,         719,
};

static const uint16_t ud_itab__8[] = {
  /*  0 */    GROUP(9),   GROUP(14),   GROUP(15),   GROUP(16),
  /*  4 */        1386,     INVALID,         788,   GROUP(25),
};

static const uint16_t ud_itab__9[] = {
  /*  0 */     INVALID,   GROUP(10),   GROUP(11),   GROUP(12),
  /*  4 */   GROUP(13),     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__10[] = {
  /*  0 */     INVALID,        1455,     INVALID,
};

static const uint16_t ud_itab__11[] = {
  /*  0 */     INVALID,        1461,     INVALID,
};

static const uint16_t ud_itab__12[] = {
  /*  0 */     INVALID,        1462,     INVALID,
};

static const uint16_t ud_itab__13[] = {
  /*  0 */     INVALID,        1463,     INVALID,
};

static const uint16_t ud_itab__14[] = {
  /*  0 */         824,         952,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__15[] = {
  /*  0 */        1485,        1508,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__16[] = {
  /*  0 */   GROUP(17),   GROUP(18),   GROUP(19),   GROUP(20),
  /*  4 */   GROUP(21),   GROUP(22),   GROUP(23),   GROUP(24),
};

static const uint16_t ud_itab__17[] = {
  /*  0 */        1466,     INVALID,     INVALID,
};

static const uint16_t ud_itab__18[] = {
  /*  0 */        1467,     INVALID,     INVALID,
};

static const uint16_t ud_itab__19[] = {
  /*  0 */        1468,     INVALID,     INVALID,
};

static const uint16_t ud_itab__20[] = {
  /*  0 */        1469,     INVALID,     INVALID,
};

static const uint16_t ud_itab__21[] = {
  /*  0 */        1397,     INVALID,     INVALID,
};

static const uint16_t ud_itab__22[] = {
  /*  0 */          80,     INVALID,     INVALID,
};

static const uint16_t ud_itab__23[] = {
  /*  0 */        1399,     INVALID,     INVALID,
};

static const uint16_t ud_itab__24[] = {
  /*  0 */         720,     INVALID,     INVALID,
};

static const uint16_t ud_itab__25[] = {
  /*  0 */        1425,   GROUP(26),     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__26[] = {
  /*  0 */        1298,     INVALID,     INVALID,
};

static const uint16_t ud_itab__27[] = {
  /*  0 */        1119,        1120,        1121,        1122,
  /*  4 */        1123,        1124,        1125,        1126,
};

static const uint16_t ud_itab__28[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  c */        1216,        1217,     INVALID,     INVALID,
  /* 10 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 14 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */        1218,        1219,     INVALID,     INVALID,
  /* 20 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 2c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 5c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 60 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,        1220,     INVALID,
  /* 8c */     INVALID,     INVALID,        1221,     INVALID,
  /* 90 */        1222,     INVALID,     INVALID,     INVALID,
  /* 94 */        1223,     INVALID,        1224,        1225,
  /* 98 */     INVALID,     INVALID,        1226,     INVALID,
  /* 9c */     INVALID,     INVALID,        1227,     INVALID,
  /* a0 */        1228,     INVALID,     INVALID,     INVALID,
  /* a4 */        1229,     INVALID,        1230,        1231,
  /* a8 */     INVALID,     INVALID,        1232,     INVALID,
  /* ac */     INVALID,     INVALID,        1233,     INVALID,
  /* b0 */        1234,     INVALID,     INVALID,     INVALID,
  /* b4 */        1235,     INVALID,        1236,        1237,
  /* b8 */     INVALID,     INVALID,     INVALID,        1238,
  /* bc */     INVALID,     INVALID,     INVALID,        1239,
  /* c0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* dc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__29[] = {
  /*  0 */         936,         925,         928,         932,
};

static const uint16_t ud_itab__30[] = {
  /*  0 */         938,         926,         929,         934,
};

static const uint16_t ud_itab__31[] = {
  /*  0 */   GROUP(32),   GROUP(33),
};

static const uint16_t ud_itab__32[] = {
  /*  0 */         892,        1563,        1571,         888,
};

static const uint16_t ud_itab__33[] = {
  /*  0 */         896,        1561,        1569,     INVALID,
};

static const uint16_t ud_itab__34[] = {
  /*  0 */         894,     INVALID,     INVALID,         890,
};

static const uint16_t ud_itab__35[] = {
  /*  0 */        1449,     INVALID,     INVALID,        1451,
};

static const uint16_t ud_itab__36[] = {
  /*  0 */        1447,     INVALID,     INVALID,        1445,
};

static const uint16_t ud_itab__37[] = {
  /*  0 */   GROUP(38),   GROUP(39),
};

static const uint16_t ud_itab__38[] = {
  /*  0 */         882,     INVALID,        1567,         878,
};

static const uint16_t ud_itab__39[] = {
  /*  0 */         886,     INVALID,        1565,     INVALID,
};

static const uint16_t ud_itab__40[] = {
  /*  0 */         884,     INVALID,     INVALID,         880,
};

static const uint16_t ud_itab__41[] = {
  /*  0 */        1127,        1128,        1129,        1130,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__42[] = {
  /*  0 */         862,     INVALID,     INVALID,         858,
};

static const uint16_t ud_itab__43[] = {
  /*  0 */         864,     INVALID,     INVALID,         860,
};

static const uint16_t ud_itab__44[] = {
  /*  0 */         141,         152,         154,         142,
};

static const uint16_t ud_itab__45[] = {
  /*  0 */         907,     INVALID,     INVALID,         905,
};

static const uint16_t ud_itab__46[] = {
  /*  0 */         165,         166,         168,         162,
};

static const uint16_t ud_itab__47[] = {
  /*  0 */         147,         148,         158,         138,
};

static const uint16_t ud_itab__48[] = {
  /*  0 */        1442,     INVALID,     INVALID,        1440,
};

static const uint16_t ud_itab__49[] = {
  /*  0 */         129,     INVALID,     INVALID,         127,
};

static const uint16_t ud_itab__50[] = {
  /*  0 */        1427,   GROUP(51),
};

static const uint16_t ud_itab__51[] = {
  /*  0 */     INVALID,        1428,     INVALID,
};

static const uint16_t ud_itab__52[] = {
  /*  0 */        1429,   GROUP(53),
};

static const uint16_t ud_itab__53[] = {
  /*  0 */     INVALID,        1430,     INVALID,
};

static const uint16_t ud_itab__54[] = {
  /*  0 */   GROUP(67),   GROUP(68),   GROUP(63),   GROUP(64),
  /*  4 */   GROUP(65),   GROUP(66),   GROUP(86),   GROUP(90),
  /*  8 */   GROUP(69),   GROUP(70),   GROUP(71),   GROUP(72),
  /*  c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 10 */   GROUP(73),     INVALID,     INVALID,     INVALID,
  /* 14 */   GROUP(75),   GROUP(76),     INVALID,   GROUP(77),
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */   GROUP(78),   GROUP(79),   GROUP(80),     INVALID,
  /* 20 */   GROUP(81),   GROUP(82),   GROUP(83),   GROUP(84),
  /* 24 */   GROUP(85),  GROUP(108),     INVALID,     INVALID,
  /* 28 */   GROUP(87),   GROUP(88),   GROUP(89),   GROUP(74),
  /* 2c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 30 */   GROUP(91),   GROUP(92),   GROUP(93),   GROUP(94),
  /* 34 */   GROUP(95),   GROUP(96),     INVALID,   GROUP(97),
  /* 38 */   GROUP(98),   GROUP(99),  GROUP(100),  GROUP(101),
  /* 3c */  GROUP(102),  GROUP(103),  GROUP(104),  GROUP(105),
  /* 40 */  GROUP(106),  GROUP(107),     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 5c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 60 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 80 */   GROUP(55),   GROUP(59),     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,  GROUP(109),
  /* dc */  GROUP(110),  GROUP(111),  GROUP(112),  GROUP(113),
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */  GROUP(114),  GROUP(115),     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__55[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,   GROUP(56),
};

static const uint16_t ud_itab__56[] = {
  /*  0 */   GROUP(57),   GROUP(58),
};

static const uint16_t ud_itab__57[] = {
  /*  0 */     INVALID,         717,     INVALID,
};

static const uint16_t ud_itab__58[] = {
  /*  0 */     INVALID,         718,     INVALID,
};

static const uint16_t ud_itab__59[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,   GROUP(60),
};

static const uint16_t ud_itab__60[] = {
  /*  0 */   GROUP(61),   GROUP(62),
};

static const uint16_t ud_itab__61[] = {
  /*  0 */     INVALID,         721,     INVALID,
};

static const uint16_t ud_itab__62[] = {
  /*  0 */     INVALID,         722,     INVALID,
};

static const uint16_t ud_itab__63[] = {
  /*  0 */        1588,     INVALID,     INVALID,        1589,
};

static const uint16_t ud_itab__64[] = {
  /*  0 */        1591,     INVALID,     INVALID,        1592,
};

static const uint16_t ud_itab__65[] = {
  /*  0 */        1594,     INVALID,     INVALID,        1595,
};

static const uint16_t ud_itab__66[] = {
  /*  0 */        1597,     INVALID,     INVALID,        1598,
};

static const uint16_t ud_itab__67[] = {
  /*  0 */        1582,     INVALID,     INVALID,        1583,
};

static const uint16_t ud_itab__68[] = {
  /*  0 */        1585,     INVALID,     INVALID,        1586,
};

static const uint16_t ud_itab__69[] = {
  /*  0 */        1606,     INVALID,     INVALID,        1607,
};

static const uint16_t ud_itab__70[] = {
  /*  0 */        1612,     INVALID,     INVALID,        1613,
};

static const uint16_t ud_itab__71[] = {
  /*  0 */        1609,     INVALID,     INVALID,        1610,
};

static const uint16_t ud_itab__72[] = {
  /*  0 */        1615,     INVALID,     INVALID,        1616,
};

static const uint16_t ud_itab__73[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1621,
};

static const uint16_t ud_itab__74[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1683,
};

static const uint16_t ud_itab__75[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1657,
};

static const uint16_t ud_itab__76[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1656,
};

static const uint16_t ud_itab__77[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1711,
};

static const uint16_t ud_itab__78[] = {
  /*  0 */        1573,     INVALID,     INVALID,        1574,
};

static const uint16_t ud_itab__79[] = {
  /*  0 */        1576,     INVALID,     INVALID,        1577,
};

static const uint16_t ud_itab__80[] = {
  /*  0 */        1579,     INVALID,     INVALID,        1580,
};

static const uint16_t ud_itab__81[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1685,
};

static const uint16_t ud_itab__82[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1687,
};

static const uint16_t ud_itab__83[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1689,
};

static const uint16_t ud_itab__84[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1691,
};

static const uint16_t ud_itab__85[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1693,
};

static const uint16_t ud_itab__86[] = {
  /*  0 */        1600,     INVALID,     INVALID,        1601,
};

static const uint16_t ud_itab__87[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1622,
};

static const uint16_t ud_itab__88[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1708,
};

static const uint16_t ud_itab__89[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1681,
};

static const uint16_t ud_itab__90[] = {
  /*  0 */        1603,     INVALID,     INVALID,        1604,
};

static const uint16_t ud_itab__91[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1696,
};

static const uint16_t ud_itab__92[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1698,
};

static const uint16_t ud_itab__93[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1700,
};

static const uint16_t ud_itab__94[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1702,
};

static const uint16_t ud_itab__95[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1704,
};

static const uint16_t ud_itab__96[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1706,
};

static const uint16_t ud_itab__97[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1717,
};

static const uint16_t ud_itab__98[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1624,
};

static const uint16_t ud_itab__99[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1626,
};

static const uint16_t ud_itab__100[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1628,
};

static const uint16_t ud_itab__101[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1630,
};

static const uint16_t ud_itab__102[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1632,
};

static const uint16_t ud_itab__103[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1634,
};

static const uint16_t ud_itab__104[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1638,
};

static const uint16_t ud_itab__105[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1636,
};

static const uint16_t ud_itab__106[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1640,
};

static const uint16_t ud_itab__107[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1642,
};

static const uint16_t ud_itab__108[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1695,
};

static const uint16_t ud_itab__109[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,          45,
};

static const uint16_t ud_itab__110[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,          41,
};

static const uint16_t ud_itab__111[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,          43,
};

static const uint16_t ud_itab__112[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,          37,
};

static const uint16_t ud_itab__113[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,          39,
};

static const uint16_t ud_itab__114[] = {
  /*  0 */        1723,        1725,     INVALID,     INVALID,
};

static const uint16_t ud_itab__115[] = {
  /*  0 */        1724,        1726,     INVALID,     INVALID,
};

static const uint16_t ud_itab__116[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  8 */  GROUP(117),  GROUP(118),  GROUP(119),  GROUP(120),
  /*  c */  GROUP(121),  GROUP(122),  GROUP(123),  GROUP(124),
  /* 10 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 14 */  GROUP(125),  GROUP(126),  GROUP(127),  GROUP(129),
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */  GROUP(130),  GROUP(131),  GROUP(132),     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 2c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */  GROUP(134),  GROUP(135),  GROUP(136),     INVALID,
  /* 44 */  GROUP(137),     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 5c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 60 */  GROUP(139),  GROUP(140),  GROUP(141),  GROUP(142),
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* dc */     INVALID,     INVALID,     INVALID,  GROUP(138),
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__117[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1644,
};

static const uint16_t ud_itab__118[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1646,
};

static const uint16_t ud_itab__119[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1648,
};

static const uint16_t ud_itab__120[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1650,
};

static const uint16_t ud_itab__121[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1654,
};

static const uint16_t ud_itab__122[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1652,
};

static const uint16_t ud_itab__123[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1677,
};

static const uint16_t ud_itab__124[] = {
  /*  0 */        1618,     INVALID,     INVALID,        1619,
};

static const uint16_t ud_itab__125[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1045,
};

static const uint16_t ud_itab__126[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1056,
};

static const uint16_t ud_itab__127[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,  GROUP(128),
};

static const uint16_t ud_itab__128[] = {
  /*  0 */        1047,        1049,        1051,
};

static const uint16_t ud_itab__129[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,         201,
};

static const uint16_t ud_itab__130[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1058,
};

static const uint16_t ud_itab__131[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1557,
};

static const uint16_t ud_itab__132[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,  GROUP(133),
};

static const uint16_t ud_itab__133[] = {
  /*  0 */        1062,        1063,        1064,
};

static const uint16_t ud_itab__134[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,         197,
};

static const uint16_t ud_itab__135[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,         195,
};

static const uint16_t ud_itab__136[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1679,
};

static const uint16_t ud_itab__137[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1512,
};

static const uint16_t ud_itab__138[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,          47,
};

static const uint16_t ud_itab__139[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1715,
};

static const uint16_t ud_itab__140[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1713,
};

static const uint16_t ud_itab__141[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1721,
};

static const uint16_t ud_itab__142[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1719,
};

static const uint16_t ud_itab__143[] = {
  /*  0 */         900,     INVALID,     INVALID,         898,
};

static const uint16_t ud_itab__144[] = {
  /*  0 */        1387,        1391,        1393,        1389,
};

static const uint16_t ud_itab__145[] = {
  /*  0 */        1306,     INVALID,        1308,     INVALID,
};

static const uint16_t ud_itab__146[] = {
  /*  0 */        1291,     INVALID,        1293,     INVALID,
};

static const uint16_t ud_itab__147[] = {
  /*  0 */          61,     INVALID,     INVALID,          59,
};

static const uint16_t ud_itab__148[] = {
  /*  0 */          65,     INVALID,     INVALID,          63,
};

static const uint16_t ud_itab__149[] = {
  /*  0 */         976,     INVALID,     INVALID,         974,
};

static const uint16_t ud_itab__150[] = {
  /*  0 */        1499,     INVALID,     INVALID,        1497,
};

static const uint16_t ud_itab__151[] = {
  /*  0 */          27,          29,          31,          25,
};

static const uint16_t ud_itab__152[] = {
  /*  0 */         946,         948,         950,         944,
};

static const uint16_t ud_itab__153[] = {
  /*  0 */         145,         150,         156,         139,
};

static const uint16_t ud_itab__154[] = {
  /*  0 */         134,     INVALID,         163,         143,
};

static const uint16_t ud_itab__155[] = {
  /*  0 */        1419,        1421,        1423,        1417,
};

static const uint16_t ud_itab__156[] = {
  /*  0 */         818,         820,         822,         816,
};

static const uint16_t ud_itab__157[] = {
  /*  0 */         189,         191,         193,         187,
};

static const uint16_t ud_itab__158[] = {
  /*  0 */         802,         804,         806,         800,
};

static const uint16_t ud_itab__159[] = {
  /*  0 */        1209,     INVALID,     INVALID,        1207,
};

static const uint16_t ud_itab__160[] = {
  /*  0 */        1212,     INVALID,     INVALID,        1210,
};

static const uint16_t ud_itab__161[] = {
  /*  0 */        1215,     INVALID,     INVALID,        1213,
};

static const uint16_t ud_itab__162[] = {
  /*  0 */         987,     INVALID,     INVALID,         985,
};

static const uint16_t ud_itab__163[] = {
  /*  0 */        1038,     INVALID,     INVALID,        1036,
};

static const uint16_t ud_itab__164[] = {
  /*  0 */        1041,     INVALID,     INVALID,        1039,
};

static const uint16_t ud_itab__165[] = {
  /*  0 */        1044,     INVALID,     INVALID,        1042,
};

static const uint16_t ud_itab__166[] = {
  /*  0 */         993,     INVALID,     INVALID,         991,
};

static const uint16_t ud_itab__167[] = {
  /*  0 */        1200,     INVALID,     INVALID,        1198,
};

static const uint16_t ud_itab__168[] = {
  /*  0 */        1203,     INVALID,     INVALID,        1201,
};

static const uint16_t ud_itab__169[] = {
  /*  0 */        1206,     INVALID,     INVALID,        1204,
};

static const uint16_t ud_itab__170[] = {
  /*  0 */         990,     INVALID,     INVALID,         988,
};

static const uint16_t ud_itab__171[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1547,
};

static const uint16_t ud_itab__172[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1545,
};

static const uint16_t ud_itab__173[] = {
  /*  0 */  GROUP(174),     INVALID,     INVALID,  GROUP(175),
};

static const uint16_t ud_itab__174[] = {
  /*  0 */         866,         867,         910,
};

static const uint16_t ud_itab__175[] = {
  /*  0 */         868,         870,         911,
};

static const uint16_t ud_itab__176[] = {
  /*  0 */         920,     INVALID,        1522,        1517,
};

static const uint16_t ud_itab__177[] = {
  /*  0 */        1134,        1537,        1535,        1539,
};

static const uint16_t ud_itab__178[] = {
  /*  0 */     INVALID,     INVALID,  GROUP(179),     INVALID,
  /*  4 */  GROUP(180),     INVALID,  GROUP(181),     INVALID,
};

static const uint16_t ud_itab__179[] = {
  /*  0 */        1159,     INVALID,     INVALID,        1163,
};

static const uint16_t ud_itab__180[] = {
  /*  0 */        1152,     INVALID,     INVALID,        1150,
};

static const uint16_t ud_itab__181[] = {
  /*  0 */        1138,     INVALID,     INVALID,        1137,
};

static const uint16_t ud_itab__182[] = {
  /*  0 */     INVALID,     INVALID,  GROUP(183),     INVALID,
  /*  4 */  GROUP(184),     INVALID,  GROUP(185),     INVALID,
};

static const uint16_t ud_itab__183[] = {
  /*  0 */        1165,     INVALID,     INVALID,        1169,
};

static const uint16_t ud_itab__184[] = {
  /*  0 */        1153,     INVALID,     INVALID,        1157,
};

static const uint16_t ud_itab__185[] = {
  /*  0 */        1142,     INVALID,     INVALID,        1141,
};

static const uint16_t ud_itab__186[] = {
  /*  0 */     INVALID,     INVALID,  GROUP(187),  GROUP(188),
  /*  4 */     INVALID,     INVALID,  GROUP(189),  GROUP(190),
};

static const uint16_t ud_itab__187[] = {
  /*  0 */        1171,     INVALID,     INVALID,        1175,
};

static const uint16_t ud_itab__188[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1543,
};

static const uint16_t ud_itab__189[] = {
  /*  0 */        1146,     INVALID,     INVALID,        1145,
};

static const uint16_t ud_itab__190[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1541,
};

static const uint16_t ud_itab__191[] = {
  /*  0 */        1027,     INVALID,     INVALID,        1028,
};

static const uint16_t ud_itab__192[] = {
  /*  0 */        1030,     INVALID,     INVALID,        1031,
};

static const uint16_t ud_itab__193[] = {
  /*  0 */        1033,     INVALID,     INVALID,        1034,
};

static const uint16_t ud_itab__194[] = {
  /*  0 */     INVALID,        1464,     INVALID,
};

static const uint16_t ud_itab__195[] = {
  /*  0 */     INVALID,        1465,     INVALID,
};

static const uint16_t ud_itab__196[] = {
  /*  0 */     INVALID,        1551,     INVALID,        1549,
};

static const uint16_t ud_itab__197[] = {
  /*  0 */     INVALID,        1555,     INVALID,        1553,
};

static const uint16_t ud_itab__198[] = {
  /*  0 */  GROUP(199),     INVALID,         916,  GROUP(200),
};

static const uint16_t ud_itab__199[] = {
  /*  0 */         872,         873,         913,
};

static const uint16_t ud_itab__200[] = {
  /*  0 */         874,         876,         914,
};

static const uint16_t ud_itab__201[] = {
  /*  0 */         921,     INVALID,        1524,        1515,
};

static const uint16_t ud_itab__202[] = {
  /*  0 */     INVALID,  GROUP(203),
};

static const uint16_t ud_itab__203[] = {
  /*  0 */  GROUP(204),  GROUP(205),  GROUP(206),     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__204[] = {
  /*  0 */         825,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__205[] = {
  /*  0 */        1509,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__206[] = {
  /*  0 */        1510,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__207[] = {
  /*  0 */     INVALID,  GROUP(208),
};

static const uint16_t ud_itab__208[] = {
  /*  0 */  GROUP(209),  GROUP(210),  GROUP(211),  GROUP(212),
  /*  4 */  GROUP(213),  GROUP(214),     INVALID,     INVALID,
};

static const uint16_t ud_itab__209[] = {
  /*  0 */        1511,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__210[] = {
  /*  0 */        1501,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__211[] = {
  /*  0 */        1502,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__212[] = {
  /*  0 */        1503,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__213[] = {
  /*  0 */        1504,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__214[] = {
  /*  0 */        1505,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__215[] = {
  /*  0 */  GROUP(216),  GROUP(217),
};

static const uint16_t ud_itab__216[] = {
  /*  0 */         683,         682,         768,        1400,
  /*  4 */        1507,        1506,     INVALID,          79,
};

static const uint16_t ud_itab__217[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,  GROUP(218),  GROUP(219),  GROUP(220),
};

static const uint16_t ud_itab__218[] = {
  /*  0 */         777,         778,         779,         780,
  /*  4 */         781,         782,         783,         784,
};

static const uint16_t ud_itab__219[] = {
  /*  0 */         808,         809,         810,         811,
  /*  4 */         812,         813,         814,         815,
};

static const uint16_t ud_itab__220[] = {
  /*  0 */        1366,        1367,        1368,        1369,
  /*  4 */        1370,        1371,        1372,        1373,
};

static const uint16_t ud_itab__221[] = {
  /*  0 */     INVALID,     INVALID,        1710,     INVALID,
};

static const uint16_t ud_itab__222[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */        1669,        1676,        1674,        1672,
};

static const uint16_t ud_itab__223[] = {
  /*  0 */         112,         117,         120,         110,
};

static const uint16_t ud_itab__224[] = {
  /*  0 */        1059,     INVALID,     INVALID,        1060,
};

static const uint16_t ud_itab__225[] = {
  /*  0 */        1055,     INVALID,     INVALID,        1053,
};

static const uint16_t ud_itab__226[] = {
  /*  0 */        1381,     INVALID,     INVALID,        1379,
};

static const uint16_t ud_itab__227[] = {
  /*  0 */  GROUP(228),  GROUP(235),
};

static const uint16_t ud_itab__228[] = {
  /*  0 */     INVALID,  GROUP(229),     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,  GROUP(230),  GROUP(234),
};

static const uint16_t ud_itab__229[] = {
  /*  0 */         124,         125,         126,
};

static const uint16_t ud_itab__230[] = {
  /*  0 */  GROUP(231),     INVALID,  GROUP(232),  GROUP(233),
};

static const uint16_t ud_itab__231[] = {
  /*  0 */     INVALID,        1459,     INVALID,
};

static const uint16_t ud_itab__232[] = {
  /*  0 */     INVALID,        1458,     INVALID,
};

static const uint16_t ud_itab__233[] = {
  /*  0 */     INVALID,        1457,     INVALID,
};

static const uint16_t ud_itab__234[] = {
  /*  0 */     INVALID,        1460,     INVALID,
};

static const uint16_t ud_itab__235[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,        1456,     INVALID,
};

static const uint16_t ud_itab__236[] = {
  /*  0 */     INVALID,          35,     INVALID,          33,
};

static const uint16_t ud_itab__237[] = {
  /*  0 */        1160,     INVALID,     INVALID,        1161,
};

static const uint16_t ud_itab__238[] = {
  /*  0 */        1166,     INVALID,     INVALID,        1167,
};

static const uint16_t ud_itab__239[] = {
  /*  0 */        1172,     INVALID,     INVALID,        1173,
};

static const uint16_t ud_itab__240[] = {
  /*  0 */        1527,     INVALID,     INVALID,        1528,
};

static const uint16_t ud_itab__241[] = {
  /*  0 */        1093,     INVALID,     INVALID,        1094,
};

static const uint16_t ud_itab__242[] = {
  /*  0 */     INVALID,        1521,        1526,         918,
};

static const uint16_t ud_itab__243[] = {
  /*  0 */        1086,     INVALID,     INVALID,        1084,
};

static const uint16_t ud_itab__244[] = {
  /*  0 */        1192,     INVALID,     INVALID,        1193,
};

static const uint16_t ud_itab__245[] = {
  /*  0 */        1195,     INVALID,     INVALID,        1196,
};

static const uint16_t ud_itab__246[] = {
  /*  0 */        1083,     INVALID,     INVALID,        1081,
};

static const uint16_t ud_itab__247[] = {
  /*  0 */        1017,     INVALID,     INVALID,        1015,
};

static const uint16_t ud_itab__248[] = {
  /*  0 */        1009,     INVALID,     INVALID,        1010,
};

static const uint16_t ud_itab__249[] = {
  /*  0 */        1012,     INVALID,     INVALID,        1013,
};

static const uint16_t ud_itab__250[] = {
  /*  0 */        1075,     INVALID,     INVALID,        1076,
};

static const uint16_t ud_itab__251[] = {
  /*  0 */        1020,     INVALID,     INVALID,        1018,
};

static const uint16_t ud_itab__252[] = {
  /*  0 */        1023,     INVALID,     INVALID,        1021,
};

static const uint16_t ud_itab__253[] = {
  /*  0 */        1147,     INVALID,     INVALID,        1148,
};

static const uint16_t ud_itab__254[] = {
  /*  0 */        1156,     INVALID,     INVALID,        1154,
};

static const uint16_t ud_itab__255[] = {
  /*  0 */        1026,     INVALID,     INVALID,        1024,
};

static const uint16_t ud_itab__256[] = {
  /*  0 */        1087,     INVALID,     INVALID,        1088,
};

static const uint16_t ud_itab__257[] = {
  /*  0 */        1092,     INVALID,     INVALID,        1090,
};

static const uint16_t ud_itab__258[] = {
  /*  0 */     INVALID,         136,         132,         160,
};

static const uint16_t ud_itab__259[] = {
  /*  0 */         909,     INVALID,     INVALID,         902,
};

static const uint16_t ud_itab__260[] = {
  /*  0 */        1186,     INVALID,     INVALID,        1187,
};

static const uint16_t ud_itab__261[] = {
  /*  0 */        1189,     INVALID,     INVALID,        1190,
};

static const uint16_t ud_itab__262[] = {
  /*  0 */        1080,     INVALID,     INVALID,        1078,
};

static const uint16_t ud_itab__263[] = {
  /*  0 */        1118,     INVALID,     INVALID,        1116,
};

static const uint16_t ud_itab__264[] = {
  /*  0 */        1003,     INVALID,     INVALID,        1004,
};

static const uint16_t ud_itab__265[] = {
  /*  0 */        1006,     INVALID,     INVALID,        1007,
};

static const uint16_t ud_itab__266[] = {
  /*  0 */        1074,     INVALID,     INVALID,        1072,
};

static const uint16_t ud_itab__267[] = {
  /*  0 */        1266,     INVALID,     INVALID,        1264,
};

static const uint16_t ud_itab__268[] = {
  /*  0 */     INVALID,        1559,     INVALID,     INVALID,
};

static const uint16_t ud_itab__269[] = {
  /*  0 */        1136,     INVALID,     INVALID,        1135,
};

static const uint16_t ud_itab__270[] = {
  /*  0 */        1140,     INVALID,     INVALID,        1139,
};

static const uint16_t ud_itab__271[] = {
  /*  0 */        1144,     INVALID,     INVALID,        1143,
};

static const uint16_t ud_itab__272[] = {
  /*  0 */        1533,     INVALID,     INVALID,        1534,
};

static const uint16_t ud_itab__273[] = {
  /*  0 */        1069,     INVALID,     INVALID,        1070,
};

static const uint16_t ud_itab__274[] = {
  /*  0 */        1133,     INVALID,     INVALID,        1131,
};

static const uint16_t ud_itab__275[] = {
  /*  0 */     INVALID,  GROUP(276),
};

static const uint16_t ud_itab__276[] = {
  /*  0 */         799,     INVALID,     INVALID,        1519,
};

static const uint16_t ud_itab__277[] = {
  /*  0 */        1179,     INVALID,     INVALID,        1177,
};

static const uint16_t ud_itab__278[] = {
  /*  0 */        1182,     INVALID,     INVALID,        1180,
};

static const uint16_t ud_itab__279[] = {
  /*  0 */        1183,     INVALID,     INVALID,        1184,
};

static const uint16_t ud_itab__280[] = {
  /*  0 */        1532,     INVALID,     INVALID,        1530,
};

static const uint16_t ud_itab__281[] = {
  /*  0 */         996,     INVALID,     INVALID,         994,
};

static const uint16_t ud_itab__282[] = {
  /*  0 */         997,     INVALID,     INVALID,         998,
};

static const uint16_t ud_itab__283[] = {
  /*  0 */        1000,     INVALID,     INVALID,        1001,
};

static const uint16_t ud_itab__284[] = {
  /*  0 */        1242,     INVALID,
};

static const uint16_t ud_itab__285[] = {
  /*  0 */        1097,     INVALID,
};

static const uint16_t ud_itab__286[] = {
  /*  0 */        1243,     INVALID,
};

static const uint16_t ud_itab__287[] = {
  /*  0 */        1098,     INVALID,
};

static const uint16_t ud_itab__288[] = {
  /*  0 */         173,     INVALID,
};

static const uint16_t ud_itab__289[] = {
  /*  0 */         174,     INVALID,
};

static const uint16_t ud_itab__290[] = {
  /*  0 */           1,     INVALID,
};

static const uint16_t ud_itab__291[] = {
  /*  0 */           4,     INVALID,
};

static const uint16_t ud_itab__292[] = {
  /*  0 */  GROUP(293),  GROUP(294),     INVALID,
};

static const uint16_t ud_itab__293[] = {
  /*  0 */        1257,     INVALID,
};

static const uint16_t ud_itab__294[] = {
  /*  0 */        1258,     INVALID,
};

static const uint16_t ud_itab__295[] = {
  /*  0 */  GROUP(296),  GROUP(297),     INVALID,
};

static const uint16_t ud_itab__296[] = {
  /*  0 */        1110,     INVALID,
};

static const uint16_t ud_itab__297[] = {
  /*  0 */        1111,     INVALID,
};

static const uint16_t ud_itab__298[] = {
  /*  0 */        1658,     INVALID,
};

static const uint16_t ud_itab__299[] = {
  /*  0 */          67,          68,
};

static const uint16_t ud_itab__300[] = {
  /*  0 */         710,         711,     INVALID,
};

static const uint16_t ud_itab__301[] = {
  /*  0 */         983,         984,     INVALID,
};

static const uint16_t ud_itab__302[] = {
  /*  0 */          21,         970,          11,        1342,
  /*  4 */          55,        1413,        1493,         106,
};

static const uint16_t ud_itab__303[] = {
  /*  0 */          23,         971,          13,        1343,
  /*  4 */          57,        1414,        1494,         108,
};

static const uint16_t ud_itab__304[] = {
  /*  0 */  GROUP(305),  GROUP(306),  GROUP(307),  GROUP(308),
  /*  4 */  GROUP(309),  GROUP(310),  GROUP(311),  GROUP(312),
};

static const uint16_t ud_itab__305[] = {
  /*  0 */          22,     INVALID,
};

static const uint16_t ud_itab__306[] = {
  /*  0 */         972,     INVALID,
};

static const uint16_t ud_itab__307[] = {
  /*  0 */          12,     INVALID,
};

static const uint16_t ud_itab__308[] = {
  /*  0 */        1344,     INVALID,
};

static const uint16_t ud_itab__309[] = {
  /*  0 */          56,     INVALID,
};

static const uint16_t ud_itab__310[] = {
  /*  0 */        1415,     INVALID,
};

static const uint16_t ud_itab__311[] = {
  /*  0 */        1495,     INVALID,
};

static const uint16_t ud_itab__312[] = {
  /*  0 */         107,     INVALID,
};

static const uint16_t ud_itab__313[] = {
  /*  0 */          24,         973,          14,        1345,
  /*  4 */          58,        1416,        1496,         109,
};

static const uint16_t ud_itab__314[] = {
  /*  0 */        1109,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__315[] = {
  /*  0 */          74,          75,          76,
};

static const uint16_t ud_itab__316[] = {
  /*  0 */         170,         171,         172,
};

static const uint16_t ud_itab__317[] = {
  /*  0 */          73,     INVALID,
};

static const uint16_t ud_itab__318[] = {
  /*  0 */  GROUP(319),  GROUP(320),  GROUP(321),
};

static const uint16_t ud_itab__319[] = {
  /*  0 */        1259,        1260,
};

static const uint16_t ud_itab__320[] = {
  /*  0 */        1261,        1262,
};

static const uint16_t ud_itab__321[] = {
  /*  0 */     INVALID,        1263,
};

static const uint16_t ud_itab__322[] = {
  /*  0 */  GROUP(323),  GROUP(324),  GROUP(325),
};

static const uint16_t ud_itab__323[] = {
  /*  0 */        1112,     INVALID,
};

static const uint16_t ud_itab__324[] = {
  /*  0 */        1113,        1114,
};

static const uint16_t ud_itab__325[] = {
  /*  0 */     INVALID,        1115,
};

static const uint16_t ud_itab__326[] = {
  /*  0 */         923,         924,         927,
};

static const uint16_t ud_itab__327[] = {
  /*  0 */         115,         116,         119,
};

static const uint16_t ud_itab__328[] = {
  /*  0 */        1403,        1404,        1405,
};

static const uint16_t ud_itab__329[] = {
  /*  0 */         791,         792,         793,
};

static const uint16_t ud_itab__330[] = {
  /*  0 */        1347,        1348,        1349,
};

static const uint16_t ud_itab__331[] = {
  /*  0 */        1279,        1286,        1267,        1275,
  /*  4 */        1327,        1334,        1318,        1313,
};

static const uint16_t ud_itab__332[] = {
  /*  0 */        1284,        1287,        1268,        1274,
  /*  4 */        1323,        1330,        1319,        1315,
};

static const uint16_t ud_itab__333[] = {
  /*  0 */  GROUP(334),  GROUP(335),     INVALID,     INVALID,
  /*  4 */     INVALID,  GROUP(341),  GROUP(357),  GROUP(369),
  /*  8 */     INVALID,  GROUP(394),     INVALID,     INVALID,
  /*  c */     INVALID,  GROUP(399),     INVALID,     INVALID,
};

static const uint16_t ud_itab__334[] = {
  /*  0 */         771,     INVALID,
};

static const uint16_t ud_itab__335[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 10 */         937,         939,  GROUP(336),         895,
  /* 14 */        1450,        1448,  GROUP(337),         885,
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */         863,         865,     INVALID,         908,
  /* 2c */     INVALID,     INVALID,        1443,         130,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */         901,        1388,        1307,        1292,
  /* 54 */          62,          66,         977,        1500,
  /* 58 */          28,         947,         146,         135,
  /* 5c */        1420,         819,         190,         803,
  /* 60 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,  GROUP(340),
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,  GROUP(338),     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,         113,     INVALID,
  /* c4 */     INVALID,     INVALID,        1382,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* dc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__336[] = {
  /*  0 */         893,         897,
};

static const uint16_t ud_itab__337[] = {
  /*  0 */         883,         887,
};

static const uint16_t ud_itab__338[] = {
  /*  0 */  GROUP(339),     INVALID,
};

static const uint16_t ud_itab__339[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,        1401,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__340[] = {
  /*  0 */        1742,        1743,
};

static const uint16_t ud_itab__341[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 10 */         933,         935,  GROUP(342),         891,
  /* 14 */        1452,        1446,  GROUP(343),         881,
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */         859,         861,     INVALID,         906,
  /* 2c */     INVALID,     INVALID,        1441,         128,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */         899,        1390,     INVALID,     INVALID,
  /* 54 */          60,          64,         975,        1498,
  /* 58 */          26,         945,         140,         144,
  /* 5c */        1418,         817,         188,         801,
  /* 60 */        1208,        1211,        1214,         986,
  /* 64 */        1037,        1040,        1043,         992,
  /* 68 */        1199,        1202,        1205,         989,
  /* 6c */        1548,        1546,  GROUP(344),        1518,
  /* 70 */        1540,  GROUP(345),  GROUP(347),  GROUP(349),
  /* 74 */        1029,        1032,        1035,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */        1550,        1554,  GROUP(351),        1516,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,         111,     INVALID,
  /* c4 */        1061,        1054,        1380,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */          34,        1162,        1168,        1174,
  /* d4 */        1529,        1095,         919,  GROUP(352),
  /* d8 */        1194,        1197,        1082,        1016,
  /* dc */        1011,        1014,        1077,        1019,
  /* e0 */        1022,        1149,        1155,        1025,
  /* e4 */        1089,        1091,         161,         903,
  /* e8 */        1188,        1191,        1079,        1117,
  /* ec */        1005,        1008,        1073,        1265,
  /* f0 */     INVALID,  GROUP(353),  GROUP(354),  GROUP(355),
  /* f4 */     INVALID,        1071,        1132,  GROUP(356),
  /* f8 */        1178,        1181,        1185,        1531,
  /* fc */         995,         999,        1002,     INVALID,
};

static const uint16_t ud_itab__342[] = {
  /*  0 */         889,     INVALID,
};

static const uint16_t ud_itab__343[] = {
  /*  0 */         879,     INVALID,
};

static const uint16_t ud_itab__344[] = {
  /*  0 */         869,         871,         912,
};

static const uint16_t ud_itab__345[] = {
  /*  0 */     INVALID,     INVALID,        1164,     INVALID,
  /*  4 */        1151,     INVALID,  GROUP(346),     INVALID,
};

static const uint16_t ud_itab__346[] = {
  /*  0 */        1756,     INVALID,
};

static const uint16_t ud_itab__347[] = {
  /*  0 */     INVALID,     INVALID,        1170,     INVALID,
  /*  4 */        1158,     INVALID,  GROUP(348),     INVALID,
};

static const uint16_t ud_itab__348[] = {
  /*  0 */        1758,     INVALID,
};

static const uint16_t ud_itab__349[] = {
  /*  0 */     INVALID,     INVALID,        1176,        1544,
  /*  4 */     INVALID,     INVALID,  GROUP(350),        1542,
};

static const uint16_t ud_itab__350[] = {
  /*  0 */        1760,     INVALID,
};

static const uint16_t ud_itab__351[] = {
  /*  0 */         875,         877,         915,
};

static const uint16_t ud_itab__352[] = {
  /*  0 */        1085,     INVALID,
};

static const uint16_t ud_itab__353[] = {
  /*  0 */        1755,     INVALID,
};

static const uint16_t ud_itab__354[] = {
  /*  0 */        1757,     INVALID,
};

static const uint16_t ud_itab__355[] = {
  /*  0 */        1759,     INVALID,
};

static const uint16_t ud_itab__356[] = {
  /*  0 */     INVALID,        1520,
};

static const uint16_t ud_itab__357[] = {
  /*  0 */        1584,        1587,        1590,        1593,
  /*  4 */        1596,        1599,        1602,        1605,
  /*  8 */        1608,        1614,        1611,        1617,
  /*  c */  GROUP(358),  GROUP(359),  GROUP(360),  GROUP(361),
  /* 10 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 14 */     INVALID,     INVALID,     INVALID,        1712,
  /* 18 */  GROUP(362),  GROUP(363),     INVALID,     INVALID,
  /* 1c */        1575,        1578,        1581,     INVALID,
  /* 20 */        1686,        1688,        1690,        1692,
  /* 24 */        1694,     INVALID,     INVALID,     INVALID,
  /* 28 */        1623,        1709,        1682,        1684,
  /* 2c */  GROUP(365),  GROUP(366),  GROUP(367),  GROUP(368),
  /* 30 */        1697,        1699,        1701,        1703,
  /* 34 */        1705,        1707,     INVALID,        1718,
  /* 38 */        1625,        1627,        1629,        1631,
  /* 3c */        1633,        1635,        1639,        1637,
  /* 40 */        1641,        1643,     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 5c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 60 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,          46,
  /* dc */          42,          44,          38,          40,
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__358[] = {
  /*  0 */        1737,     INVALID,
};

static const uint16_t ud_itab__359[] = {
  /*  0 */        1735,     INVALID,
};

static const uint16_t ud_itab__360[] = {
  /*  0 */        1740,     INVALID,
};

static const uint16_t ud_itab__361[] = {
  /*  0 */        1741,     INVALID,
};

static const uint16_t ud_itab__362[] = {
  /*  0 */        1727,     INVALID,
};

static const uint16_t ud_itab__363[] = {
  /*  0 */  GROUP(364),     INVALID,
};

static const uint16_t ud_itab__364[] = {
  /*  0 */     INVALID,        1728,
};

static const uint16_t ud_itab__365[] = {
  /*  0 */        1731,     INVALID,
};

static const uint16_t ud_itab__366[] = {
  /*  0 */        1733,     INVALID,
};

static const uint16_t ud_itab__367[] = {
  /*  0 */        1732,     INVALID,
};

static const uint16_t ud_itab__368[] = {
  /*  0 */        1734,     INVALID,
};

static const uint16_t ud_itab__369[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */  GROUP(370),  GROUP(371),  GROUP(372),     INVALID,
  /*  8 */        1645,        1647,        1649,        1651,
  /*  c */        1655,        1653,        1678,        1620,
  /* 10 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 14 */  GROUP(374),        1057,  GROUP(375),         202,
  /* 18 */  GROUP(379),  GROUP(381),     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */  GROUP(383),        1558,  GROUP(385),     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 2c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */         198,         196,        1680,     INVALID,
  /* 44 */        1513,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,  GROUP(391),  GROUP(392),
  /* 4c */  GROUP(393),     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 5c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 60 */        1716,        1714,        1722,        1720,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* dc */     INVALID,     INVALID,     INVALID,          48,
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__370[] = {
  /*  0 */        1738,     INVALID,
};

static const uint16_t ud_itab__371[] = {
  /*  0 */        1736,     INVALID,
};

static const uint16_t ud_itab__372[] = {
  /*  0 */  GROUP(373),     INVALID,
};

static const uint16_t ud_itab__373[] = {
  /*  0 */     INVALID,        1739,
};

static const uint16_t ud_itab__374[] = {
  /*  0 */        1046,     INVALID,
};

static const uint16_t ud_itab__375[] = {
  /*  0 */  GROUP(376),  GROUP(377),  GROUP(378),
};

static const uint16_t ud_itab__376[] = {
  /*  0 */        1048,     INVALID,
};

static const uint16_t ud_itab__377[] = {
  /*  0 */        1050,     INVALID,
};

static const uint16_t ud_itab__378[] = {
  /*  0 */     INVALID,        1052,
};

static const uint16_t ud_itab__379[] = {
  /*  0 */  GROUP(380),     INVALID,
};

static const uint16_t ud_itab__380[] = {
  /*  0 */     INVALID,        1730,
};

static const uint16_t ud_itab__381[] = {
  /*  0 */  GROUP(382),     INVALID,
};

static const uint16_t ud_itab__382[] = {
  /*  0 */     INVALID,        1729,
};

static const uint16_t ud_itab__383[] = {
  /*  0 */  GROUP(384),     INVALID,
};

static const uint16_t ud_itab__384[] = {
  /*  0 */        1065,     INVALID,
};

static const uint16_t ud_itab__385[] = {
  /*  0 */  GROUP(386),  GROUP(388),
};

static const uint16_t ud_itab__386[] = {
  /*  0 */  GROUP(387),     INVALID,
};

static const uint16_t ud_itab__387[] = {
  /*  0 */        1066,     INVALID,
};

static const uint16_t ud_itab__388[] = {
  /*  0 */  GROUP(389),  GROUP(390),
};

static const uint16_t ud_itab__389[] = {
  /*  0 */        1067,     INVALID,
};

static const uint16_t ud_itab__390[] = {
  /*  0 */        1068,     INVALID,
};

static const uint16_t ud_itab__391[] = {
  /*  0 */        1745,     INVALID,
};

static const uint16_t ud_itab__392[] = {
  /*  0 */        1744,     INVALID,
};

static const uint16_t ud_itab__393[] = {
  /*  0 */        1754,     INVALID,
};

static const uint16_t ud_itab__394[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 10 */  GROUP(395),  GROUP(396),  GROUP(397),     INVALID,
  /* 14 */     INVALID,     INVALID,  GROUP(398),     INVALID,
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */     INVALID,     INVALID,         155,     INVALID,
  /* 2c */         169,         159,     INVALID,     INVALID,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,        1394,        1309,        1294,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */          32,         951,         157,         164,
  /* 5c */        1424,         823,         194,         807,
  /* 60 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,        1523,
  /* 70 */        1536,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */     INVALID,     INVALID,         917,        1525,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,         121,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* dc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,         133,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__395[] = {
  /*  0 */        1751,        1750,
};

static const uint16_t ud_itab__396[] = {
  /*  0 */        1753,        1752,
};

static const uint16_t ud_itab__397[] = {
  /*  0 */        1572,        1570,
};

static const uint16_t ud_itab__398[] = {
  /*  0 */        1568,        1566,
};

static const uint16_t ud_itab__399[] = {
  /*  0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /*  c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 10 */  GROUP(402),  GROUP(400),  GROUP(401),     INVALID,
  /* 14 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 18 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */     INVALID,     INVALID,         153,     INVALID,
  /* 2c */         167,         149,     INVALID,     INVALID,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 40 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 44 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 48 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 4c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 50 */     INVALID,        1392,     INVALID,     INVALID,
  /* 54 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 58 */          30,         949,         151,     INVALID,
  /* 5c */        1422,         821,         192,         805,
  /* 60 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 64 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 68 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 6c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 70 */        1538,     INVALID,     INVALID,     INVALID,
  /* 74 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 78 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 7c */        1552,        1556,     INVALID,     INVALID,
  /* 80 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 84 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 88 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 8c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 90 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 94 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 98 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 9c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* a8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ac */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* b8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* bc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c0 */     INVALID,     INVALID,         118,     INVALID,
  /* c4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* c8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* cc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d0 */          36,     INVALID,     INVALID,     INVALID,
  /* d4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* d8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* dc */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e0 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* e4 */     INVALID,     INVALID,         137,     INVALID,
  /* e8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* ec */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f0 */        1560,     INVALID,     INVALID,     INVALID,
  /* f4 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* f8 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* fc */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__400[] = {
  /*  0 */        1749,        1748,
};

static const uint16_t ud_itab__401[] = {
  /*  0 */        1564,        1562,
};

static const uint16_t ud_itab__402[] = {
  /*  0 */        1747,        1746,
};

static const uint16_t ud_itab__403[] = {
  /*  0 */  GROUP(404),  GROUP(335),     INVALID,     INVALID,
  /*  4 */     INVALID,  GROUP(341),  GROUP(357),  GROUP(369),
  /*  8 */     INVALID,  GROUP(394),     INVALID,     INVALID,
  /*  c */     INVALID,  GROUP(399),     INVALID,     INVALID,
};

static const uint16_t ud_itab__404[] = {
  /*  0 */         769,     INVALID,
};

static const uint16_t ud_itab__405[] = {
  /*  0 */         826,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__406[] = {
  /*  0 */         827,     INVALID,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__407[] = {
  /*  0 */         715,     INVALID,
};

static const uint16_t ud_itab__408[] = {
  /*  0 */         723,         724,         725,
};

static const uint16_t ud_itab__409[] = {
  /*  0 */        1280,        1285,        1269,        1273,
  /*  4 */        1326,        1333,        1320,        1314,
};

static const uint16_t ud_itab__410[] = {
  /*  0 */        1281,        1288,        1272,        1276,
  /*  4 */        1325,        1332,        1329,        1312,
};

static const uint16_t ud_itab__411[] = {
  /*  0 */        1282,        1289,        1270,        1277,
  /*  4 */        1324,        1331,        1321,        1316,
};

static const uint16_t ud_itab__412[] = {
  /*  0 */        1283,        1290,        1271,        1278,
  /*  4 */        1328,        1335,        1322,        1317,
};

static const uint16_t ud_itab__413[] = {
  /*  0 */           3,     INVALID,
};

static const uint16_t ud_itab__414[] = {
  /*  0 */           2,     INVALID,
};

static const uint16_t ud_itab__415[] = {
  /*  0 */        1311,     INVALID,
};

static const uint16_t ud_itab__416[] = {
  /*  0 */  GROUP(417),  GROUP(418),
};

static const uint16_t ud_itab__417[] = {
  /*  0 */         206,         503,         307,         357,
  /*  4 */         587,         630,         387,         413,
};

static const uint16_t ud_itab__418[] = {
  /*  0 */         215,         216,         217,         218,
  /*  4 */         219,         220,         221,         222,
  /*  8 */         504,         505,         506,         507,
  /*  c */         508,         509,         510,         511,
  /* 10 */         309,         310,         311,         312,
  /* 14 */         313,         314,         315,         316,
  /* 18 */         359,         360,         361,         362,
  /* 1c */         363,         364,         365,         366,
  /* 20 */         589,         590,         591,         592,
  /* 24 */         593,         594,         595,         596,
  /* 28 */         614,         615,         616,         617,
  /* 2c */         618,         619,         620,         621,
  /* 30 */         388,         389,         390,         391,
  /* 34 */         392,         393,         394,         395,
  /* 38 */         414,         415,         416,         417,
  /* 3c */         418,         419,         420,         421,
};

static const uint16_t ud_itab__419[] = {
  /*  0 */  GROUP(420),  GROUP(421),
};

static const uint16_t ud_itab__420[] = {
  /*  0 */         476,     INVALID,         573,         540,
  /*  4 */         493,         492,         584,         583,
};

static const uint16_t ud_itab__421[] = {
  /*  0 */         477,         478,         479,         480,
  /*  4 */         481,         482,         483,         484,
  /*  8 */         658,         659,         660,         661,
  /*  c */         662,         663,         664,         665,
  /* 10 */         522,     INVALID,     INVALID,     INVALID,
  /* 14 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 18 */         549,         550,         551,         552,
  /* 1c */         553,         554,         555,         556,
  /* 20 */         233,         204,     INVALID,     INVALID,
  /* 24 */         639,         657,     INVALID,     INVALID,
  /* 28 */         485,         486,         487,         488,
  /* 2c */         489,         490,         491,     INVALID,
  /* 30 */         203,         685,         529,         526,
  /* 34 */         684,         528,         377,         454,
  /* 38 */         527,         686,         537,         536,
  /* 3c */         530,         534,         535,         376,
};

static const uint16_t ud_itab__422[] = {
  /*  0 */  GROUP(423),  GROUP(424),
};

static const uint16_t ud_itab__423[] = {
  /*  0 */         456,         520,         448,         450,
  /*  4 */         462,         464,         460,         458,
};

static const uint16_t ud_itab__424[] = {
  /*  0 */         235,         236,         237,         238,
  /*  4 */         239,         240,         241,         242,
  /*  8 */         243,         244,         245,         246,
  /*  c */         247,         248,         249,         250,
  /* 10 */         251,         252,         253,         254,
  /* 14 */         255,         256,         257,         258,
  /* 18 */         259,         260,         261,         262,
  /* 1c */         263,         264,         265,         266,
  /* 20 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */     INVALID,         656,     INVALID,     INVALID,
  /* 2c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__425[] = {
  /*  0 */  GROUP(426),  GROUP(427),
};

static const uint16_t ud_itab__426[] = {
  /*  0 */         453,         471,         467,         470,
  /*  4 */     INVALID,         474,     INVALID,         538,
};

static const uint16_t ud_itab__427[] = {
  /*  0 */         267,         268,         269,         270,
  /*  4 */         271,         272,         273,         274,
  /*  8 */         275,         276,         277,         278,
  /*  c */         279,         280,         281,         282,
  /* 10 */         283,         284,         285,         286,
  /* 14 */         287,         288,         289,         290,
  /* 18 */         291,         292,         293,         294,
  /* 1c */         295,         296,         297,         298,
  /* 20 */         524,         523,         234,         455,
  /* 24 */         525,         532,     INVALID,     INVALID,
  /* 28 */         299,         300,         301,         302,
  /* 2c */         303,         304,         305,         306,
  /* 30 */         333,         334,         335,         336,
  /* 34 */         337,         338,         339,         340,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__428[] = {
  /*  0 */  GROUP(429),  GROUP(430),
};

static const uint16_t ud_itab__429[] = {
  /*  0 */         205,         494,         308,         358,
  /*  4 */         588,         613,         378,         404,
};

static const uint16_t ud_itab__430[] = {
  /*  0 */         207,         208,         209,         210,
  /*  4 */         211,         212,         213,         214,
  /*  8 */         495,         496,         497,         498,
  /*  c */         499,         500,         501,         502,
  /* 10 */         317,         318,         319,         320,
  /* 14 */         321,         322,         323,         324,
  /* 18 */         325,         326,         327,         328,
  /* 1c */         329,         330,         331,         332,
  /* 20 */         622,         623,         624,         625,
  /* 24 */         626,         627,         628,         629,
  /* 28 */         597,         598,         599,         600,
  /* 2c */         601,         602,         603,         604,
  /* 30 */         405,         406,         407,         408,
  /* 34 */         409,         410,         411,         412,
  /* 38 */         379,         380,         381,         382,
  /* 3c */         383,         384,         385,         386,
};

static const uint16_t ud_itab__431[] = {
  /*  0 */  GROUP(432),  GROUP(433),
};

static const uint16_t ud_itab__432[] = {
  /*  0 */         475,         472,         574,         539,
  /*  4 */         531,     INVALID,         533,         585,
};

static const uint16_t ud_itab__433[] = {
  /*  0 */         431,         432,         433,         434,
  /*  4 */         435,         436,         437,         438,
  /*  8 */         666,         667,         668,         669,
  /*  c */         670,         671,         672,         673,
  /* 10 */         575,         576,         577,         578,
  /* 14 */         579,         580,         581,         582,
  /* 18 */         541,         542,         543,         544,
  /* 1c */         545,         546,         547,         548,
  /* 20 */         640,         641,         642,         643,
  /* 24 */         644,         645,         646,         647,
  /* 28 */         648,         649,         650,         651,
  /* 2c */         652,         653,         654,         655,
  /* 30 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 34 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__434[] = {
  /*  0 */  GROUP(435),  GROUP(436),
};

static const uint16_t ud_itab__435[] = {
  /*  0 */         457,         521,         447,         449,
  /*  4 */         463,         465,         461,         459,
};

static const uint16_t ud_itab__436[] = {
  /*  0 */         223,         224,         225,         226,
  /*  4 */         227,         228,         229,         230,
  /*  8 */         512,         513,         514,         515,
  /*  c */         516,         517,         518,         519,
  /* 10 */         367,         368,         369,         370,
  /* 14 */         371,         372,         373,         374,
  /* 18 */     INVALID,         375,     INVALID,     INVALID,
  /* 1c */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 20 */         631,         632,         633,         634,
  /* 24 */         635,         636,         637,         638,
  /* 28 */         605,         606,         607,         608,
  /* 2c */         609,         610,         611,         612,
  /* 30 */         422,         423,         424,         425,
  /* 34 */         426,         427,         428,         429,
  /* 38 */         396,         397,         398,         399,
  /* 3c */         400,         401,         402,         403,
};

static const uint16_t ud_itab__437[] = {
  /*  0 */  GROUP(438),  GROUP(439),
};

static const uint16_t ud_itab__438[] = {
  /*  0 */         451,         473,         466,         468,
  /*  4 */         231,         452,         232,         469,
};

static const uint16_t ud_itab__439[] = {
  /*  0 */         439,         440,         441,         442,
  /*  4 */         443,         444,         445,         446,
  /*  8 */         674,         675,         676,         677,
  /*  c */         678,         679,         680,         681,
  /* 10 */         557,         558,         559,         560,
  /* 14 */         561,         562,         563,         564,
  /* 18 */         565,         566,         567,         568,
  /* 1c */         569,         570,         571,         572,
  /* 20 */         586,     INVALID,     INVALID,     INVALID,
  /* 24 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 28 */         341,         342,         343,         344,
  /* 2c */         345,         346,         347,         348,
  /* 30 */         349,         350,         351,         352,
  /* 34 */         353,         354,         355,         356,
  /* 38 */     INVALID,     INVALID,     INVALID,     INVALID,
  /* 3c */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__440[] = {
  /*  0 */         758,         759,         760,
};

static const uint16_t ud_itab__441[] = {
  /*  0 */         764,     INVALID,
};

static const uint16_t ud_itab__442[] = {
  /*  0 */        1432,        1437,         962,         953,
  /*  4 */         942,         695,         186,         689,
};

static const uint16_t ud_itab__443[] = {
  /*  0 */        1438,        1439,         963,         954,
  /*  4 */         943,         696,         185,         688,
};

static const uint16_t ud_itab__444[] = {
  /*  0 */         708,         183,     INVALID,     INVALID,
  /*  4 */     INVALID,     INVALID,     INVALID,     INVALID,
};

static const uint16_t ud_itab__445[] = {
  /*  0 */         707,         184,  GROUP(446),          71,
  /*  4 */         761,         762,        1255,     INVALID,
};

static const uint16_t ud_itab__446[] = {
  /*  0 */          69,          70,
};


struct ud_lookup_table_list_entry ud_lookup_table_list[] = {
    /* 000 */ { ud_itab__0, UD_TAB__OPC_TABLE, "opctbl" },
    /* 001 */ { ud_itab__1, UD_TAB__OPC_MODE, "/m" },
    /* 002 */ { ud_itab__2, UD_TAB__OPC_MODE, "/m" },
    /* 003 */ { ud_itab__3, UD_TAB__OPC_MODE, "/m" },
    /* 004 */ { ud_itab__4, UD_TAB__OPC_TABLE, "opctbl" },
    /* 005 */ { ud_itab__5, UD_TAB__OPC_REG, "/reg" },
    /* 006 */ { ud_itab__6, UD_TAB__OPC_MOD, "/mod" },
    /* 007 */ { ud_itab__7, UD_TAB__OPC_REG, "/reg" },
    /* 008 */ { ud_itab__8, UD_TAB__OPC_REG, "/reg" },
    /* 009 */ { ud_itab__9, UD_TAB__OPC_RM, "/rm" },
    /* 010 */ { ud_itab__10, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 011 */ { ud_itab__11, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 012 */ { ud_itab__12, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 013 */ { ud_itab__13, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 014 */ { ud_itab__14, UD_TAB__OPC_RM, "/rm" },
    /* 015 */ { ud_itab__15, UD_TAB__OPC_RM, "/rm" },
    /* 016 */ { ud_itab__16, UD_TAB__OPC_RM, "/rm" },
    /* 017 */ { ud_itab__17, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 018 */ { ud_itab__18, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 019 */ { ud_itab__19, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 020 */ { ud_itab__20, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 021 */ { ud_itab__21, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 022 */ { ud_itab__22, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 023 */ { ud_itab__23, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 024 */ { ud_itab__24, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 025 */ { ud_itab__25, UD_TAB__OPC_RM, "/rm" },
    /* 026 */ { ud_itab__26, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 027 */ { ud_itab__27, UD_TAB__OPC_REG, "/reg" },
    /* 028 */ { ud_itab__28, UD_TAB__OPC_3DNOW, "/3dnow" },
    /* 029 */ { ud_itab__29, UD_TAB__OPC_SSE, "/sse" },
    /* 030 */ { ud_itab__30, UD_TAB__OPC_SSE, "/sse" },
    /* 031 */ { ud_itab__31, UD_TAB__OPC_MOD, "/mod" },
    /* 032 */ { ud_itab__32, UD_TAB__OPC_SSE, "/sse" },
    /* 033 */ { ud_itab__33, UD_TAB__OPC_SSE, "/sse" },
    /* 034 */ { ud_itab__34, UD_TAB__OPC_SSE, "/sse" },
    /* 035 */ { ud_itab__35, UD_TAB__OPC_SSE, "/sse" },
    /* 036 */ { ud_itab__36, UD_TAB__OPC_SSE, "/sse" },
    /* 037 */ { ud_itab__37, UD_TAB__OPC_MOD, "/mod" },
    /* 038 */ { ud_itab__38, UD_TAB__OPC_SSE, "/sse" },
    /* 039 */ { ud_itab__39, UD_TAB__OPC_SSE, "/sse" },
    /* 040 */ { ud_itab__40, UD_TAB__OPC_SSE, "/sse" },
    /* 041 */ { ud_itab__41, UD_TAB__OPC_REG, "/reg" },
    /* 042 */ { ud_itab__42, UD_TAB__OPC_SSE, "/sse" },
    /* 043 */ { ud_itab__43, UD_TAB__OPC_SSE, "/sse" },
    /* 044 */ { ud_itab__44, UD_TAB__OPC_SSE, "/sse" },
    /* 045 */ { ud_itab__45, UD_TAB__OPC_SSE, "/sse" },
    /* 046 */ { ud_itab__46, UD_TAB__OPC_SSE, "/sse" },
    /* 047 */ { ud_itab__47, UD_TAB__OPC_SSE, "/sse" },
    /* 048 */ { ud_itab__48, UD_TAB__OPC_SSE, "/sse" },
    /* 049 */ { ud_itab__49, UD_TAB__OPC_SSE, "/sse" },
    /* 050 */ { ud_itab__50, UD_TAB__OPC_MODE, "/m" },
    /* 051 */ { ud_itab__51, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 052 */ { ud_itab__52, UD_TAB__OPC_MODE, "/m" },
    /* 053 */ { ud_itab__53, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 054 */ { ud_itab__54, UD_TAB__OPC_TABLE, "opctbl" },
    /* 055 */ { ud_itab__55, UD_TAB__OPC_SSE, "/sse" },
    /* 056 */ { ud_itab__56, UD_TAB__OPC_MODE, "/m" },
    /* 057 */ { ud_itab__57, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 058 */ { ud_itab__58, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 059 */ { ud_itab__59, UD_TAB__OPC_SSE, "/sse" },
    /* 060 */ { ud_itab__60, UD_TAB__OPC_MODE, "/m" },
    /* 061 */ { ud_itab__61, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 062 */ { ud_itab__62, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 063 */ { ud_itab__63, UD_TAB__OPC_SSE, "/sse" },
    /* 064 */ { ud_itab__64, UD_TAB__OPC_SSE, "/sse" },
    /* 065 */ { ud_itab__65, UD_TAB__OPC_SSE, "/sse" },
    /* 066 */ { ud_itab__66, UD_TAB__OPC_SSE, "/sse" },
    /* 067 */ { ud_itab__67, UD_TAB__OPC_SSE, "/sse" },
    /* 068 */ { ud_itab__68, UD_TAB__OPC_SSE, "/sse" },
    /* 069 */ { ud_itab__69, UD_TAB__OPC_SSE, "/sse" },
    /* 070 */ { ud_itab__70, UD_TAB__OPC_SSE, "/sse" },
    /* 071 */ { ud_itab__71, UD_TAB__OPC_SSE, "/sse" },
    /* 072 */ { ud_itab__72, UD_TAB__OPC_SSE, "/sse" },
    /* 073 */ { ud_itab__73, UD_TAB__OPC_SSE, "/sse" },
    /* 074 */ { ud_itab__74, UD_TAB__OPC_SSE, "/sse" },
    /* 075 */ { ud_itab__75, UD_TAB__OPC_SSE, "/sse" },
    /* 076 */ { ud_itab__76, UD_TAB__OPC_SSE, "/sse" },
    /* 077 */ { ud_itab__77, UD_TAB__OPC_SSE, "/sse" },
    /* 078 */ { ud_itab__78, UD_TAB__OPC_SSE, "/sse" },
    /* 079 */ { ud_itab__79, UD_TAB__OPC_SSE, "/sse" },
    /* 080 */ { ud_itab__80, UD_TAB__OPC_SSE, "/sse" },
    /* 081 */ { ud_itab__81, UD_TAB__OPC_SSE, "/sse" },
    /* 082 */ { ud_itab__82, UD_TAB__OPC_SSE, "/sse" },
    /* 083 */ { ud_itab__83, UD_TAB__OPC_SSE, "/sse" },
    /* 084 */ { ud_itab__84, UD_TAB__OPC_SSE, "/sse" },
    /* 085 */ { ud_itab__85, UD_TAB__OPC_SSE, "/sse" },
    /* 086 */ { ud_itab__86, UD_TAB__OPC_SSE, "/sse" },
    /* 087 */ { ud_itab__87, UD_TAB__OPC_SSE, "/sse" },
    /* 088 */ { ud_itab__88, UD_TAB__OPC_SSE, "/sse" },
    /* 089 */ { ud_itab__89, UD_TAB__OPC_SSE, "/sse" },
    /* 090 */ { ud_itab__90, UD_TAB__OPC_SSE, "/sse" },
    /* 091 */ { ud_itab__91, UD_TAB__OPC_SSE, "/sse" },
    /* 092 */ { ud_itab__92, UD_TAB__OPC_SSE, "/sse" },
    /* 093 */ { ud_itab__93, UD_TAB__OPC_SSE, "/sse" },
    /* 094 */ { ud_itab__94, UD_TAB__OPC_SSE, "/sse" },
    /* 095 */ { ud_itab__95, UD_TAB__OPC_SSE, "/sse" },
    /* 096 */ { ud_itab__96, UD_TAB__OPC_SSE, "/sse" },
    /* 097 */ { ud_itab__97, UD_TAB__OPC_SSE, "/sse" },
    /* 098 */ { ud_itab__98, UD_TAB__OPC_SSE, "/sse" },
    /* 099 */ { ud_itab__99, UD_TAB__OPC_SSE, "/sse" },
    /* 100 */ { ud_itab__100, UD_TAB__OPC_SSE, "/sse" },
    /* 101 */ { ud_itab__101, UD_TAB__OPC_SSE, "/sse" },
    /* 102 */ { ud_itab__102, UD_TAB__OPC_SSE, "/sse" },
    /* 103 */ { ud_itab__103, UD_TAB__OPC_SSE, "/sse" },
    /* 104 */ { ud_itab__104, UD_TAB__OPC_SSE, "/sse" },
    /* 105 */ { ud_itab__105, UD_TAB__OPC_SSE, "/sse" },
    /* 106 */ { ud_itab__106, UD_TAB__OPC_SSE, "/sse" },
    /* 107 */ { ud_itab__107, UD_TAB__OPC_SSE, "/sse" },
    /* 108 */ { ud_itab__108, UD_TAB__OPC_SSE, "/sse" },
    /* 109 */ { ud_itab__109, UD_TAB__OPC_SSE, "/sse" },
    /* 110 */ { ud_itab__110, UD_TAB__OPC_SSE, "/sse" },
    /* 111 */ { ud_itab__111, UD_TAB__OPC_SSE, "/sse" },
    /* 112 */ { ud_itab__112, UD_TAB__OPC_SSE, "/sse" },
    /* 113 */ { ud_itab__113, UD_TAB__OPC_SSE, "/sse" },
    /* 114 */ { ud_itab__114, UD_TAB__OPC_SSE, "/sse" },
    /* 115 */ { ud_itab__115, UD_TAB__OPC_SSE, "/sse" },
    /* 116 */ { ud_itab__116, UD_TAB__OPC_TABLE, "opctbl" },
    /* 117 */ { ud_itab__117, UD_TAB__OPC_SSE, "/sse" },
    /* 118 */ { ud_itab__118, UD_TAB__OPC_SSE, "/sse" },
    /* 119 */ { ud_itab__119, UD_TAB__OPC_SSE, "/sse" },
    /* 120 */ { ud_itab__120, UD_TAB__OPC_SSE, "/sse" },
    /* 121 */ { ud_itab__121, UD_TAB__OPC_SSE, "/sse" },
    /* 122 */ { ud_itab__122, UD_TAB__OPC_SSE, "/sse" },
    /* 123 */ { ud_itab__123, UD_TAB__OPC_SSE, "/sse" },
    /* 124 */ { ud_itab__124, UD_TAB__OPC_SSE, "/sse" },
    /* 125 */ { ud_itab__125, UD_TAB__OPC_SSE, "/sse" },
    /* 126 */ { ud_itab__126, UD_TAB__OPC_SSE, "/sse" },
    /* 127 */ { ud_itab__127, UD_TAB__OPC_SSE, "/sse" },
    /* 128 */ { ud_itab__128, UD_TAB__OPC_OSIZE, "/o" },
    /* 129 */ { ud_itab__129, UD_TAB__OPC_SSE, "/sse" },
    /* 130 */ { ud_itab__130, UD_TAB__OPC_SSE, "/sse" },
    /* 131 */ { ud_itab__131, UD_TAB__OPC_SSE, "/sse" },
    /* 132 */ { ud_itab__132, UD_TAB__OPC_SSE, "/sse" },
    /* 133 */ { ud_itab__133, UD_TAB__OPC_OSIZE, "/o" },
    /* 134 */ { ud_itab__134, UD_TAB__OPC_SSE, "/sse" },
    /* 135 */ { ud_itab__135, UD_TAB__OPC_SSE, "/sse" },
    /* 136 */ { ud_itab__136, UD_TAB__OPC_SSE, "/sse" },
    /* 137 */ { ud_itab__137, UD_TAB__OPC_SSE, "/sse" },
    /* 138 */ { ud_itab__138, UD_TAB__OPC_SSE, "/sse" },
    /* 139 */ { ud_itab__139, UD_TAB__OPC_SSE, "/sse" },
    /* 140 */ { ud_itab__140, UD_TAB__OPC_SSE, "/sse" },
    /* 141 */ { ud_itab__141, UD_TAB__OPC_SSE, "/sse" },
    /* 142 */ { ud_itab__142, UD_TAB__OPC_SSE, "/sse" },
    /* 143 */ { ud_itab__143, UD_TAB__OPC_SSE, "/sse" },
    /* 144 */ { ud_itab__144, UD_TAB__OPC_SSE, "/sse" },
    /* 145 */ { ud_itab__145, UD_TAB__OPC_SSE, "/sse" },
    /* 146 */ { ud_itab__146, UD_TAB__OPC_SSE, "/sse" },
    /* 147 */ { ud_itab__147, UD_TAB__OPC_SSE, "/sse" },
    /* 148 */ { ud_itab__148, UD_TAB__OPC_SSE, "/sse" },
    /* 149 */ { ud_itab__149, UD_TAB__OPC_SSE, "/sse" },
    /* 150 */ { ud_itab__150, UD_TAB__OPC_SSE, "/sse" },
    /* 151 */ { ud_itab__151, UD_TAB__OPC_SSE, "/sse" },
    /* 152 */ { ud_itab__152, UD_TAB__OPC_SSE, "/sse" },
    /* 153 */ { ud_itab__153, UD_TAB__OPC_SSE, "/sse" },
    /* 154 */ { ud_itab__154, UD_TAB__OPC_SSE, "/sse" },
    /* 155 */ { ud_itab__155, UD_TAB__OPC_SSE, "/sse" },
    /* 156 */ { ud_itab__156, UD_TAB__OPC_SSE, "/sse" },
    /* 157 */ { ud_itab__157, UD_TAB__OPC_SSE, "/sse" },
    /* 158 */ { ud_itab__158, UD_TAB__OPC_SSE, "/sse" },
    /* 159 */ { ud_itab__159, UD_TAB__OPC_SSE, "/sse" },
    /* 160 */ { ud_itab__160, UD_TAB__OPC_SSE, "/sse" },
    /* 161 */ { ud_itab__161, UD_TAB__OPC_SSE, "/sse" },
    /* 162 */ { ud_itab__162, UD_TAB__OPC_SSE, "/sse" },
    /* 163 */ { ud_itab__163, UD_TAB__OPC_SSE, "/sse" },
    /* 164 */ { ud_itab__164, UD_TAB__OPC_SSE, "/sse" },
    /* 165 */ { ud_itab__165, UD_TAB__OPC_SSE, "/sse" },
    /* 166 */ { ud_itab__166, UD_TAB__OPC_SSE, "/sse" },
    /* 167 */ { ud_itab__167, UD_TAB__OPC_SSE, "/sse" },
    /* 168 */ { ud_itab__168, UD_TAB__OPC_SSE, "/sse" },
    /* 169 */ { ud_itab__169, UD_TAB__OPC_SSE, "/sse" },
    /* 170 */ { ud_itab__170, UD_TAB__OPC_SSE, "/sse" },
    /* 171 */ { ud_itab__171, UD_TAB__OPC_SSE, "/sse" },
    /* 172 */ { ud_itab__172, UD_TAB__OPC_SSE, "/sse" },
    /* 173 */ { ud_itab__173, UD_TAB__OPC_SSE, "/sse" },
    /* 174 */ { ud_itab__174, UD_TAB__OPC_OSIZE, "/o" },
    /* 175 */ { ud_itab__175, UD_TAB__OPC_OSIZE, "/o" },
    /* 176 */ { ud_itab__176, UD_TAB__OPC_SSE, "/sse" },
    /* 177 */ { ud_itab__177, UD_TAB__OPC_SSE, "/sse" },
    /* 178 */ { ud_itab__178, UD_TAB__OPC_REG, "/reg" },
    /* 179 */ { ud_itab__179, UD_TAB__OPC_SSE, "/sse" },
    /* 180 */ { ud_itab__180, UD_TAB__OPC_SSE, "/sse" },
    /* 181 */ { ud_itab__181, UD_TAB__OPC_SSE, "/sse" },
    /* 182 */ { ud_itab__182, UD_TAB__OPC_REG, "/reg" },
    /* 183 */ { ud_itab__183, UD_TAB__OPC_SSE, "/sse" },
    /* 184 */ { ud_itab__184, UD_TAB__OPC_SSE, "/sse" },
    /* 185 */ { ud_itab__185, UD_TAB__OPC_SSE, "/sse" },
    /* 186 */ { ud_itab__186, UD_TAB__OPC_REG, "/reg" },
    /* 187 */ { ud_itab__187, UD_TAB__OPC_SSE, "/sse" },
    /* 188 */ { ud_itab__188, UD_TAB__OPC_SSE, "/sse" },
    /* 189 */ { ud_itab__189, UD_TAB__OPC_SSE, "/sse" },
    /* 190 */ { ud_itab__190, UD_TAB__OPC_SSE, "/sse" },
    /* 191 */ { ud_itab__191, UD_TAB__OPC_SSE, "/sse" },
    /* 192 */ { ud_itab__192, UD_TAB__OPC_SSE, "/sse" },
    /* 193 */ { ud_itab__193, UD_TAB__OPC_SSE, "/sse" },
    /* 194 */ { ud_itab__194, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 195 */ { ud_itab__195, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 196 */ { ud_itab__196, UD_TAB__OPC_SSE, "/sse" },
    /* 197 */ { ud_itab__197, UD_TAB__OPC_SSE, "/sse" },
    /* 198 */ { ud_itab__198, UD_TAB__OPC_SSE, "/sse" },
    /* 199 */ { ud_itab__199, UD_TAB__OPC_OSIZE, "/o" },
    /* 200 */ { ud_itab__200, UD_TAB__OPC_OSIZE, "/o" },
    /* 201 */ { ud_itab__201, UD_TAB__OPC_SSE, "/sse" },
    /* 202 */ { ud_itab__202, UD_TAB__OPC_MOD, "/mod" },
    /* 203 */ { ud_itab__203, UD_TAB__OPC_REG, "/reg" },
    /* 204 */ { ud_itab__204, UD_TAB__OPC_RM, "/rm" },
    /* 205 */ { ud_itab__205, UD_TAB__OPC_RM, "/rm" },
    /* 206 */ { ud_itab__206, UD_TAB__OPC_RM, "/rm" },
    /* 207 */ { ud_itab__207, UD_TAB__OPC_MOD, "/mod" },
    /* 208 */ { ud_itab__208, UD_TAB__OPC_REG, "/reg" },
    /* 209 */ { ud_itab__209, UD_TAB__OPC_RM, "/rm" },
    /* 210 */ { ud_itab__210, UD_TAB__OPC_RM, "/rm" },
    /* 211 */ { ud_itab__211, UD_TAB__OPC_RM, "/rm" },
    /* 212 */ { ud_itab__212, UD_TAB__OPC_RM, "/rm" },
    /* 213 */ { ud_itab__213, UD_TAB__OPC_RM, "/rm" },
    /* 214 */ { ud_itab__214, UD_TAB__OPC_RM, "/rm" },
    /* 215 */ { ud_itab__215, UD_TAB__OPC_MOD, "/mod" },
    /* 216 */ { ud_itab__216, UD_TAB__OPC_REG, "/reg" },
    /* 217 */ { ud_itab__217, UD_TAB__OPC_REG, "/reg" },
    /* 218 */ { ud_itab__218, UD_TAB__OPC_RM, "/rm" },
    /* 219 */ { ud_itab__219, UD_TAB__OPC_RM, "/rm" },
    /* 220 */ { ud_itab__220, UD_TAB__OPC_RM, "/rm" },
    /* 221 */ { ud_itab__221, UD_TAB__OPC_SSE, "/sse" },
    /* 222 */ { ud_itab__222, UD_TAB__OPC_REG, "/reg" },
    /* 223 */ { ud_itab__223, UD_TAB__OPC_SSE, "/sse" },
    /* 224 */ { ud_itab__224, UD_TAB__OPC_SSE, "/sse" },
    /* 225 */ { ud_itab__225, UD_TAB__OPC_SSE, "/sse" },
    /* 226 */ { ud_itab__226, UD_TAB__OPC_SSE, "/sse" },
    /* 227 */ { ud_itab__227, UD_TAB__OPC_MOD, "/mod" },
    /* 228 */ { ud_itab__228, UD_TAB__OPC_REG, "/reg" },
    /* 229 */ { ud_itab__229, UD_TAB__OPC_OSIZE, "/o" },
    /* 230 */ { ud_itab__230, UD_TAB__OPC_SSE, "/sse" },
    /* 231 */ { ud_itab__231, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 232 */ { ud_itab__232, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 233 */ { ud_itab__233, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 234 */ { ud_itab__234, UD_TAB__OPC_VENDOR, "/vendor" },
    /* 235 */ { ud_itab__235, UD_TAB__OPC_REG, "/reg" },
    /* 236 */ { ud_itab__236, UD_TAB__OPC_SSE, "/sse" },
    /* 237 */ { ud_itab__237, UD_TAB__OPC_SSE, "/sse" },
    /* 238 */ { ud_itab__238, UD_TAB__OPC_SSE, "/sse" },
    /* 239 */ { ud_itab__239, UD_TAB__OPC_SSE, "/sse" },
    /* 240 */ { ud_itab__240, UD_TAB__OPC_SSE, "/sse" },
    /* 241 */ { ud_itab__241, UD_TAB__OPC_SSE, "/sse" },
    /* 242 */ { ud_itab__242, UD_TAB__OPC_SSE, "/sse" },
    /* 243 */ { ud_itab__243, UD_TAB__OPC_SSE, "/sse" },
    /* 244 */ { ud_itab__244, UD_TAB__OPC_SSE, "/sse" },
    /* 245 */ { ud_itab__245, UD_TAB__OPC_SSE, "/sse" },
    /* 246 */ { ud_itab__246, UD_TAB__OPC_SSE, "/sse" },
    /* 247 */ { ud_itab__247, UD_TAB__OPC_SSE, "/sse" },
    /* 248 */ { ud_itab__248, UD_TAB__OPC_SSE, "/sse" },
    /* 249 */ { ud_itab__249, UD_TAB__OPC_SSE, "/sse" },
    /* 250 */ { ud_itab__250, UD_TAB__OPC_SSE, "/sse" },
    /* 251 */ { ud_itab__251, UD_TAB__OPC_SSE, "/sse" },
    /* 252 */ { ud_itab__252, UD_TAB__OPC_SSE, "/sse" },
    /* 253 */ { ud_itab__253, UD_TAB__OPC_SSE, "/sse" },
    /* 254 */ { ud_itab__254, UD_TAB__OPC_SSE, "/sse" },
    /* 255 */ { ud_itab__255, UD_TAB__OPC_SSE, "/sse" },
    /* 256 */ { ud_itab__256, UD_TAB__OPC_SSE, "/sse" },
    /* 257 */ { ud_itab__257, UD_TAB__OPC_SSE, "/sse" },
    /* 258 */ { ud_itab__258, UD_TAB__OPC_SSE, "/sse" },
    /* 259 */ { ud_itab__259, UD_TAB__OPC_SSE, "/sse" },
    /* 260 */ { ud_itab__260, UD_TAB__OPC_SSE, "/sse" },
    /* 261 */ { ud_itab__261, UD_TAB__OPC_SSE, "/sse" },
    /* 262 */ { ud_itab__262, UD_TAB__OPC_SSE, "/sse" },
    /* 263 */ { ud_itab__263, UD_TAB__OPC_SSE, "/sse" },
    /* 264 */ { ud_itab__264, UD_TAB__OPC_SSE, "/sse" },
    /* 265 */ { ud_itab__265, UD_TAB__OPC_SSE, "/sse" },
    /* 266 */ { ud_itab__266, UD_TAB__OPC_SSE, "/sse" },
    /* 267 */ { ud_itab__267, UD_TAB__OPC_SSE, "/sse" },
    /* 268 */ { ud_itab__268, UD_TAB__OPC_SSE, "/sse" },
    /* 269 */ { ud_itab__269, UD_TAB__OPC_SSE, "/sse" },
    /* 270 */ { ud_itab__270, UD_TAB__OPC_SSE, "/sse" },
    /* 271 */ { ud_itab__271, UD_TAB__OPC_SSE, "/sse" },
    /* 272 */ { ud_itab__272, UD_TAB__OPC_SSE, "/sse" },
    /* 273 */ { ud_itab__273, UD_TAB__OPC_SSE, "/sse" },
    /* 274 */ { ud_itab__274, UD_TAB__OPC_SSE, "/sse" },
    /* 275 */ { ud_itab__275, UD_TAB__OPC_MOD, "/mod" },
    /* 276 */ { ud_itab__276, UD_TAB__OPC_SSE, "/sse" },
    /* 277 */ { ud_itab__277, UD_TAB__OPC_SSE, "/sse" },
    /* 278 */ { ud_itab__278, UD_TAB__OPC_SSE, "/sse" },
    /* 279 */ { ud_itab__279, UD_TAB__OPC_SSE, "/sse" },
    /* 280 */ { ud_itab__280, UD_TAB__OPC_SSE, "/sse" },
    /* 281 */ { ud_itab__281, UD_TAB__OPC_SSE, "/sse" },
    /* 282 */ { ud_itab__282, UD_TAB__OPC_SSE, "/sse" },
    /* 283 */ { ud_itab__283, UD_TAB__OPC_SSE, "/sse" },
    /* 284 */ { ud_itab__284, UD_TAB__OPC_MODE, "/m" },
    /* 285 */ { ud_itab__285, UD_TAB__OPC_MODE, "/m" },
    /* 286 */ { ud_itab__286, UD_TAB__OPC_MODE, "/m" },
    /* 287 */ { ud_itab__287, UD_TAB__OPC_MODE, "/m" },
    /* 288 */ { ud_itab__288, UD_TAB__OPC_MODE, "/m" },
    /* 289 */ { ud_itab__289, UD_TAB__OPC_MODE, "/m" },
    /* 290 */ { ud_itab__290, UD_TAB__OPC_MODE, "/m" },
    /* 291 */ { ud_itab__291, UD_TAB__OPC_MODE, "/m" },
    /* 292 */ { ud_itab__292, UD_TAB__OPC_OSIZE, "/o" },
    /* 293 */ { ud_itab__293, UD_TAB__OPC_MODE, "/m" },
    /* 294 */ { ud_itab__294, UD_TAB__OPC_MODE, "/m" },
    /* 295 */ { ud_itab__295, UD_TAB__OPC_OSIZE, "/o" },
    /* 296 */ { ud_itab__296, UD_TAB__OPC_MODE, "/m" },
    /* 297 */ { ud_itab__297, UD_TAB__OPC_MODE, "/m" },
    /* 298 */ { ud_itab__298, UD_TAB__OPC_MODE, "/m" },
    /* 299 */ { ud_itab__299, UD_TAB__OPC_MODE, "/m" },
    /* 300 */ { ud_itab__300, UD_TAB__OPC_OSIZE, "/o" },
    /* 301 */ { ud_itab__301, UD_TAB__OPC_OSIZE, "/o" },
    /* 302 */ { ud_itab__302, UD_TAB__OPC_REG, "/reg" },
    /* 303 */ { ud_itab__303, UD_TAB__OPC_REG, "/reg" },
    /* 304 */ { ud_itab__304, UD_TAB__OPC_REG, "/reg" },
    /* 305 */ { ud_itab__305, UD_TAB__OPC_MODE, "/m" },
    /* 306 */ { ud_itab__306, UD_TAB__OPC_MODE, "/m" },
    /* 307 */ { ud_itab__307, UD_TAB__OPC_MODE, "/m" },
    /* 308 */ { ud_itab__308, UD_TAB__OPC_MODE, "/m" },
    /* 309 */ { ud_itab__309, UD_TAB__OPC_MODE, "/m" },
    /* 310 */ { ud_itab__310, UD_TAB__OPC_MODE, "/m" },
    /* 311 */ { ud_itab__311, UD_TAB__OPC_MODE, "/m" },
    /* 312 */ { ud_itab__312, UD_TAB__OPC_MODE, "/m" },
    /* 313 */ { ud_itab__313, UD_TAB__OPC_REG, "/reg" },
    /* 314 */ { ud_itab__314, UD_TAB__OPC_REG, "/reg" },
    /* 315 */ { ud_itab__315, UD_TAB__OPC_OSIZE, "/o" },
    /* 316 */ { ud_itab__316, UD_TAB__OPC_OSIZE, "/o" },
    /* 317 */ { ud_itab__317, UD_TAB__OPC_MODE, "/m" },
    /* 318 */ { ud_itab__318, UD_TAB__OPC_OSIZE, "/o" },
    /* 319 */ { ud_itab__319, UD_TAB__OPC_MODE, "/m" },
    /* 320 */ { ud_itab__320, UD_TAB__OPC_MODE, "/m" },
    /* 321 */ { ud_itab__321, UD_TAB__OPC_MODE, "/m" },
    /* 322 */ { ud_itab__322, UD_TAB__OPC_OSIZE, "/o" },
    /* 323 */ { ud_itab__323, UD_TAB__OPC_MODE, "/m" },
    /* 324 */ { ud_itab__324, UD_TAB__OPC_MODE, "/m" },
    /* 325 */ { ud_itab__325, UD_TAB__OPC_MODE, "/m" },
    /* 326 */ { ud_itab__326, UD_TAB__OPC_OSIZE, "/o" },
    /* 327 */ { ud_itab__327, UD_TAB__OPC_OSIZE, "/o" },
    /* 328 */ { ud_itab__328, UD_TAB__OPC_OSIZE, "/o" },
    /* 329 */ { ud_itab__329, UD_TAB__OPC_OSIZE, "/o" },
    /* 330 */ { ud_itab__330, UD_TAB__OPC_OSIZE, "/o" },
    /* 331 */ { ud_itab__331, UD_TAB__OPC_REG, "/reg" },
    /* 332 */ { ud_itab__332, UD_TAB__OPC_REG, "/reg" },
    /* 333 */ { ud_itab__333, UD_TAB__OPC_VEX, "/vex" },
    /* 334 */ { ud_itab__334, UD_TAB__OPC_MODE, "/m" },
    /* 335 */ { ud_itab__335, UD_TAB__OPC_TABLE, "opctbl" },
    /* 336 */ { ud_itab__336, UD_TAB__OPC_MOD, "/mod" },
    /* 337 */ { ud_itab__337, UD_TAB__OPC_MOD, "/mod" },
    /* 338 */ { ud_itab__338, UD_TAB__OPC_MOD, "/mod" },
    /* 339 */ { ud_itab__339, UD_TAB__OPC_REG, "/reg" },
    /* 340 */ { ud_itab__340, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 341 */ { ud_itab__341, UD_TAB__OPC_TABLE, "opctbl" },
    /* 342 */ { ud_itab__342, UD_TAB__OPC_MOD, "/mod" },
    /* 343 */ { ud_itab__343, UD_TAB__OPC_MOD, "/mod" },
    /* 344 */ { ud_itab__344, UD_TAB__OPC_OSIZE, "/o" },
    /* 345 */ { ud_itab__345, UD_TAB__OPC_REG, "/reg" },
    /* 346 */ { ud_itab__346, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 347 */ { ud_itab__347, UD_TAB__OPC_REG, "/reg" },
    /* 348 */ { ud_itab__348, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 349 */ { ud_itab__349, UD_TAB__OPC_REG, "/reg" },
    /* 350 */ { ud_itab__350, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 351 */ { ud_itab__351, UD_TAB__OPC_OSIZE, "/o" },
    /* 352 */ { ud_itab__352, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 353 */ { ud_itab__353, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 354 */ { ud_itab__354, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 355 */ { ud_itab__355, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 356 */ { ud_itab__356, UD_TAB__OPC_MOD, "/mod" },
    /* 357 */ { ud_itab__357, UD_TAB__OPC_TABLE, "opctbl" },
    /* 358 */ { ud_itab__358, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 359 */ { ud_itab__359, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 360 */ { ud_itab__360, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 361 */ { ud_itab__361, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 362 */ { ud_itab__362, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 363 */ { ud_itab__363, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 364 */ { ud_itab__364, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 365 */ { ud_itab__365, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 366 */ { ud_itab__366, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 367 */ { ud_itab__367, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 368 */ { ud_itab__368, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 369 */ { ud_itab__369, UD_TAB__OPC_TABLE, "opctbl" },
    /* 370 */ { ud_itab__370, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 371 */ { ud_itab__371, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 372 */ { ud_itab__372, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 373 */ { ud_itab__373, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 374 */ { ud_itab__374, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 375 */ { ud_itab__375, UD_TAB__OPC_OSIZE, "/o" },
    /* 376 */ { ud_itab__376, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 377 */ { ud_itab__377, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 378 */ { ud_itab__378, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 379 */ { ud_itab__379, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 380 */ { ud_itab__380, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 381 */ { ud_itab__381, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 382 */ { ud_itab__382, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 383 */ { ud_itab__383, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 384 */ { ud_itab__384, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 385 */ { ud_itab__385, UD_TAB__OPC_MODE, "/m" },
    /* 386 */ { ud_itab__386, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 387 */ { ud_itab__387, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 388 */ { ud_itab__388, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 389 */ { ud_itab__389, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 390 */ { ud_itab__390, UD_TAB__OPC_VEX_L, "/vexl" },
    /* 391 */ { ud_itab__391, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 392 */ { ud_itab__392, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 393 */ { ud_itab__393, UD_TAB__OPC_VEX_W, "/vexw" },
    /* 394 */ { ud_itab__394, UD_TAB__OPC_TABLE, "opctbl" },
    /* 395 */ { ud_itab__395, UD_TAB__OPC_MOD, "/mod" },
    /* 396 */ { ud_itab__396, UD_TAB__OPC_MOD, "/mod" },
    /* 397 */ { ud_itab__397, UD_TAB__OPC_MOD, "/mod" },
    /* 398 */ { ud_itab__398, UD_TAB__OPC_MOD, "/mod" },
    /* 399 */ { ud_itab__399, UD_TAB__OPC_TABLE, "opctbl" },
    /* 400 */ { ud_itab__400, UD_TAB__OPC_MOD, "/mod" },
    /* 401 */ { ud_itab__401, UD_TAB__OPC_MOD, "/mod" },
    /* 402 */ { ud_itab__402, UD_TAB__OPC_MOD, "/mod" },
    /* 403 */ { ud_itab__403, UD_TAB__OPC_VEX, "/vex" },
    /* 404 */ { ud_itab__404, UD_TAB__OPC_MODE, "/m" },
    /* 405 */ { ud_itab__405, UD_TAB__OPC_REG, "/reg" },
    /* 406 */ { ud_itab__406, UD_TAB__OPC_REG, "/reg" },
    /* 407 */ { ud_itab__407, UD_TAB__OPC_MODE, "/m" },
    /* 408 */ { ud_itab__408, UD_TAB__OPC_OSIZE, "/o" },
    /* 409 */ { ud_itab__409, UD_TAB__OPC_REG, "/reg" },
    /* 410 */ { ud_itab__410, UD_TAB__OPC_REG, "/reg" },
    /* 411 */ { ud_itab__411, UD_TAB__OPC_REG, "/reg" },
    /* 412 */ { ud_itab__412, UD_TAB__OPC_REG, "/reg" },
    /* 413 */ { ud_itab__413, UD_TAB__OPC_MODE, "/m" },
    /* 414 */ { ud_itab__414, UD_TAB__OPC_MODE, "/m" },
    /* 415 */ { ud_itab__415, UD_TAB__OPC_MODE, "/m" },
    /* 416 */ { ud_itab__416, UD_TAB__OPC_MOD, "/mod" },
    /* 417 */ { ud_itab__417, UD_TAB__OPC_REG, "/reg" },
    /* 418 */ { ud_itab__418, UD_TAB__OPC_X87, "/x87" },
    /* 419 */ { ud_itab__419, UD_TAB__OPC_MOD, "/mod" },
    /* 420 */ { ud_itab__420, UD_TAB__OPC_REG, "/reg" },
    /* 421 */ { ud_itab__421, UD_TAB__OPC_X87, "/x87" },
    /* 422 */ { ud_itab__422, UD_TAB__OPC_MOD, "/mod" },
    /* 423 */ { ud_itab__423, UD_TAB__OPC_REG, "/reg" },
    /* 424 */ { ud_itab__424, UD_TAB__OPC_X87, "/x87" },
    /* 425 */ { ud_itab__425, UD_TAB__OPC_MOD, "/mod" },
    /* 426 */ { ud_itab__426, UD_TAB__OPC_REG, "/reg" },
    /* 427 */ { ud_itab__427, UD_TAB__OPC_X87, "/x87" },
    /* 428 */ { ud_itab__428, UD_TAB__OPC_MOD, "/mod" },
    /* 429 */ { ud_itab__429, UD_TAB__OPC_REG, "/reg" },
    /* 430 */ { ud_itab__430, UD_TAB__OPC_X87, "/x87" },
    /* 431 */ { ud_itab__431, UD_TAB__OPC_MOD, "/mod" },
    /* 432 */ { ud_itab__432, UD_TAB__OPC_REG, "/reg" },
    /* 433 */ { ud_itab__433, UD_TAB__OPC_X87, "/x87" },
    /* 434 */ { ud_itab__434, UD_TAB__OPC_MOD, "/mod" },
    /* 435 */ { ud_itab__435, UD_TAB__OPC_REG, "/reg" },
    /* 436 */ { ud_itab__436, UD_TAB__OPC_X87, "/x87" },
    /* 437 */ { ud_itab__437, UD_TAB__OPC_MOD, "/mod" },
    /* 438 */ { ud_itab__438, UD_TAB__OPC_REG, "/reg" },
    /* 439 */ { ud_itab__439, UD_TAB__OPC_X87, "/x87" },
    /* 440 */ { ud_itab__440, UD_TAB__OPC_ASIZE, "/a" },
    /* 441 */ { ud_itab__441, UD_TAB__OPC_MODE, "/m" },
    /* 442 */ { ud_itab__442, UD_TAB__OPC_REG, "/reg" },
    /* 443 */ { ud_itab__443, UD_TAB__OPC_REG, "/reg" },
    /* 444 */ { ud_itab__444, UD_TAB__OPC_REG, "/reg" },
    /* 445 */ { ud_itab__445, UD_TAB__OPC_REG, "/reg" },
    /* 446 */ { ud_itab__446, UD_TAB__OPC_MODE, "/m" },
};

/* itab entry operand definitions (for readability) */
#define O_AL      { OP_AL,       SZ_B     }
#define O_AX      { OP_AX,       SZ_W     }
#define O_Av      { OP_A,        SZ_V     }
#define O_C       { OP_C,        SZ_NA    }
#define O_CL      { OP_CL,       SZ_B     }
#define O_CS      { OP_CS,       SZ_NA    }
#define O_CX      { OP_CX,       SZ_W     }
#define O_D       { OP_D,        SZ_NA    }
#define O_DL      { OP_DL,       SZ_B     }
#define O_DS      { OP_DS,       SZ_NA    }
#define O_DX      { OP_DX,       SZ_W     }
#define O_E       { OP_E,        SZ_NA    }
#define O_ES      { OP_ES,       SZ_NA    }
#define O_Eb      { OP_E,        SZ_B     }
#define O_Ed      { OP_E,        SZ_D     }
#define O_Eq      { OP_E,        SZ_Q     }
#define O_Ev      { OP_E,        SZ_V     }
#define O_Ew      { OP_E,        SZ_W     }
#define O_Ey      { OP_E,        SZ_Y     }
#define O_Ez      { OP_E,        SZ_Z     }
#define O_FS      { OP_FS,       SZ_NA    }
#define O_Fv      { OP_F,        SZ_V     }
#define O_G       { OP_G,        SZ_NA    }
#define O_GS      { OP_GS,       SZ_NA    }
#define O_Gb      { OP_G,        SZ_B     }
#define O_Gd      { OP_G,        SZ_D     }
#define O_Gq      { OP_G,        SZ_Q     }
#define O_Gv      { OP_G,        SZ_V     }
#define O_Gw      { OP_G,        SZ_W     }
#define O_Gy      { OP_G,        SZ_Y     }
#define O_Gz      { OP_G,        SZ_Z     }
#define O_H       { OP_H,        SZ_X     }
#define O_Hqq     { OP_H,        SZ_QQ    }
#define O_Hx      { OP_H,        SZ_X     }
#define O_I1      { OP_I1,       SZ_NA    }
#define O_I3      { OP_I3,       SZ_NA    }
#define O_Ib      { OP_I,        SZ_B     }
#define O_Iv      { OP_I,        SZ_V     }
#define O_Iw      { OP_I,        SZ_W     }
#define O_Iz      { OP_I,        SZ_Z     }
#define O_Jb      { OP_J,        SZ_B     }
#define O_Jv      { OP_J,        SZ_V     }
#define O_Jz      { OP_J,        SZ_Z     }
#define O_L       { OP_L,        SZ_O     }
#define O_Lx      { OP_L,        SZ_X     }
#define O_M       { OP_M,        SZ_NA    }
#define O_Mb      { OP_M,        SZ_B     }
#define O_MbRd    { OP_MR,       SZ_BD    }
#define O_MbRv    { OP_MR,       SZ_BV    }
#define O_Md      { OP_M,        SZ_D     }
#define O_MdRy    { OP_MR,       SZ_DY    }
#define O_MdU     { OP_MU,       SZ_DO    }
#define O_Mdq     { OP_M,        SZ_DQ    }
#define O_Mo      { OP_M,        SZ_O     }
#define O_Mq      { OP_M,        SZ_Q     }
#define O_MqU     { OP_MU,       SZ_QO    }
#define O_Ms      { OP_M,        SZ_W     }
#define O_Mt      { OP_M,        SZ_T     }
#define O_Mv      { OP_M,        SZ_V     }
#define O_Mw      { OP_M,        SZ_W     }
#define O_MwRd    { OP_MR,       SZ_WD    }
#define O_MwRv    { OP_MR,       SZ_WV    }
#define O_MwRy    { OP_MR,       SZ_WY    }
#define O_MwU     { OP_MU,       SZ_WO    }
#define O_N       { OP_N,        SZ_Q     }
#define O_NONE    { OP_NONE,     SZ_NA    }
#define O_Ob      { OP_O,        SZ_B     }
#define O_Ov      { OP_O,        SZ_V     }
#define O_Ow      { OP_O,        SZ_W     }
#define O_P       { OP_P,        SZ_Q     }
#define O_Q       { OP_Q,        SZ_Q     }
#define O_R       { OP_R,        SZ_RDQ   }
#define O_R0b     { OP_R0,       SZ_B     }
#define O_R0v     { OP_R0,       SZ_V     }
#define O_R0w     { OP_R0,       SZ_W     }
#define O_R0y     { OP_R0,       SZ_Y     }
#define O_R0z     { OP_R0,       SZ_Z     }
#define O_R1b     { OP_R1,       SZ_B     }
#define O_R1v     { OP_R1,       SZ_V     }
#define O_R1w     { OP_R1,       SZ_W     }
#define O_R1y     { OP_R1,       SZ_Y     }
#define O_R1z     { OP_R1,       SZ_Z     }
#define O_R2b     { OP_R2,       SZ_B     }
#define O_R2v     { OP_R2,       SZ_V     }
#define O_R2w     { OP_R2,       SZ_W     }
#define O_R2y     { OP_R2,       SZ_Y     }
#define O_R2z     { OP_R2,       SZ_Z     }
#define O_R3b     { OP_R3,       SZ_B     }
#define O_R3v     { OP_R3,       SZ_V     }
#define O_R3w     { OP_R3,       SZ_W     }
#define O_R3y     { OP_R3,       SZ_Y     }
#define O_R3z     { OP_R3,       SZ_Z     }
#define O_R4b     { OP_R4,       SZ_B     }
#define O_R4v     { OP_R4,       SZ_V     }
#define O_R4w     { OP_R4,       SZ_W     }
#define O_R4y     { OP_R4,       SZ_Y     }
#define O_R4z     { OP_R4,       SZ_Z     }
#define O_R5b     { OP_R5,       SZ_B     }
#define O_R5v     { OP_R5,       SZ_V     }
#define O_R5w     { OP_R5,       SZ_W     }
#define O_R5y     { OP_R5,       SZ_Y     }
#define O_R5z     { OP_R5,       SZ_Z     }
#define O_R6b     { OP_R6,       SZ_B     }
#define O_R6v     { OP_R6,       SZ_V     }
#define O_R6w     { OP_R6,       SZ_W     }
#define O_R6y     { OP_R6,       SZ_Y     }
#define O_R6z     { OP_R6,       SZ_Z     }
#define O_R7b     { OP_R7,       SZ_B     }
#define O_R7v     { OP_R7,       SZ_V     }
#define O_R7w     { OP_R7,       SZ_W     }
#define O_R7y     { OP_R7,       SZ_Y     }
#define O_R7z     { OP_R7,       SZ_Z     }
#define O_S       { OP_S,        SZ_W     }
#define O_SS      { OP_SS,       SZ_NA    }
#define O_ST0     { OP_ST0,      SZ_NA    }
#define O_ST1     { OP_ST1,      SZ_NA    }
#define O_ST2     { OP_ST2,      SZ_NA    }
#define O_ST3     { OP_ST3,      SZ_NA    }
#define O_ST4     { OP_ST4,      SZ_NA    }
#define O_ST5     { OP_ST5,      SZ_NA    }
#define O_ST6     { OP_ST6,      SZ_NA    }
#define O_ST7     { OP_ST7,      SZ_NA    }
#define O_U       { OP_U,        SZ_O     }
#define O_Ux      { OP_U,        SZ_X     }
#define O_V       { OP_V,        SZ_DQ    }
#define O_Vdq     { OP_V,        SZ_DQ    }
#define O_Vqq     { OP_V,        SZ_QQ    }
#define O_Vsd     { OP_V,        SZ_Q     }
#define O_Vx      { OP_V,        SZ_X     }
#define O_W       { OP_W,        SZ_DQ    }
#define O_Wdq     { OP_W,        SZ_DQ    }
#define O_Wqq     { OP_W,        SZ_QQ    }
#define O_Wsd     { OP_W,        SZ_Q     }
#define O_Wx      { OP_W,        SZ_X     }
#define O_eAX     { OP_eAX,      SZ_Z     }
#define O_eCX     { OP_eCX,      SZ_Z     }
#define O_eDX     { OP_eDX,      SZ_Z     }
#define O_rAX     { OP_rAX,      SZ_V     }
#define O_rCX     { OP_rCX,      SZ_V     }
#define O_rDX     { OP_rDX,      SZ_V     }
#define O_sIb     { OP_sI,       SZ_B     }
#define O_sIv     { OP_sI,       SZ_V     }
#define O_sIz     { OP_sI,       SZ_Z     }

struct ud_itab_entry ud_itab[] = {
  /* 0000 */ { UD_Iinvalid, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0001 */ { UD_Iaaa, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0002 */ { UD_Iaad, O_Ib, O_NONE, O_NONE, O_NONE, P_none },
  /* 0003 */ { UD_Iaam, O_Ib, O_NONE, O_NONE, O_NONE, P_none },
  /* 0004 */ { UD_Iaas, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0005 */ { UD_Iadc, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0006 */ { UD_Iadc, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0007 */ { UD_Iadc, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0008 */ { UD_Iadc, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0009 */ { UD_Iadc, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 0010 */ { UD_Iadc, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0011 */ { UD_Iadc, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0012 */ { UD_Iadc, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0013 */ { UD_Iadc, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0014 */ { UD_Iadc, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0015 */ { UD_Iadd, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0016 */ { UD_Iadd, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0017 */ { UD_Iadd, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0018 */ { UD_Iadd, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0019 */ { UD_Iadd, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 0020 */ { UD_Iadd, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0021 */ { UD_Iadd, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0022 */ { UD_Iadd, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0023 */ { UD_Iadd, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0024 */ { UD_Iadd, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0025 */ { UD_Iaddpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0026 */ { UD_Ivaddpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0027 */ { UD_Iaddps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0028 */ { UD_Ivaddps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0029 */ { UD_Iaddsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0030 */ { UD_Ivaddsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0031 */ { UD_Iaddss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0032 */ { UD_Ivaddss, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0033 */ { UD_Iaddsubpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0034 */ { UD_Ivaddsubpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0035 */ { UD_Iaddsubps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0036 */ { UD_Ivaddsubps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0037 */ { UD_Iaesdec, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0038 */ { UD_Ivaesdec, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0039 */ { UD_Iaesdeclast, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0040 */ { UD_Ivaesdeclast, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0041 */ { UD_Iaesenc, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0042 */ { UD_Ivaesenc, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0043 */ { UD_Iaesenclast, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0044 */ { UD_Ivaesenclast, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0045 */ { UD_Iaesimc, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0046 */ { UD_Ivaesimc, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0047 */ { UD_Iaeskeygenassist, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0048 */ { UD_Ivaeskeygenassist, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0049 */ { UD_Iand, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0050 */ { UD_Iand, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0051 */ { UD_Iand, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0052 */ { UD_Iand, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0053 */ { UD_Iand, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 0054 */ { UD_Iand, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0055 */ { UD_Iand, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0056 */ { UD_Iand, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0057 */ { UD_Iand, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0058 */ { UD_Iand, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0059 */ { UD_Iandpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0060 */ { UD_Ivandpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0061 */ { UD_Iandps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0062 */ { UD_Ivandps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0063 */ { UD_Iandnpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0064 */ { UD_Ivandnpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0065 */ { UD_Iandnps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0066 */ { UD_Ivandnps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0067 */ { UD_Iarpl, O_Ew, O_Gw, O_NONE, O_NONE, P_aso },
  /* 0068 */ { UD_Imovsxd, O_Gq, O_Ed, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexx|P_rexr|P_rexb },
  /* 0069 */ { UD_Icall, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0070 */ { UD_Icall, O_Eq, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 0071 */ { UD_Icall, O_Fv, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0072 */ { UD_Icall, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0073 */ { UD_Icall, O_Av, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0074 */ { UD_Icbw, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0075 */ { UD_Icwde, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0076 */ { UD_Icdqe, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0077 */ { UD_Iclc, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0078 */ { UD_Icld, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0079 */ { UD_Iclflush, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0080 */ { UD_Iclgi, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0081 */ { UD_Icli, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0082 */ { UD_Iclts, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0083 */ { UD_Icmc, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0084 */ { UD_Icmovo, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0085 */ { UD_Icmovno, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0086 */ { UD_Icmovb, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0087 */ { UD_Icmovae, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0088 */ { UD_Icmovz, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0089 */ { UD_Icmovnz, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0090 */ { UD_Icmovbe, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0091 */ { UD_Icmova, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0092 */ { UD_Icmovs, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0093 */ { UD_Icmovns, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0094 */ { UD_Icmovp, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0095 */ { UD_Icmovnp, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0096 */ { UD_Icmovl, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0097 */ { UD_Icmovge, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0098 */ { UD_Icmovle, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0099 */ { UD_Icmovg, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0100 */ { UD_Icmp, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0101 */ { UD_Icmp, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0102 */ { UD_Icmp, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0103 */ { UD_Icmp, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0104 */ { UD_Icmp, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 0105 */ { UD_Icmp, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0106 */ { UD_Icmp, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0107 */ { UD_Icmp, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0108 */ { UD_Icmp, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0109 */ { UD_Icmp, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0110 */ { UD_Icmppd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0111 */ { UD_Ivcmppd, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0112 */ { UD_Icmpps, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0113 */ { UD_Ivcmpps, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0114 */ { UD_Icmpsb, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_seg },
  /* 0115 */ { UD_Icmpsw, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw|P_seg },
  /* 0116 */ { UD_Icmpsd, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw|P_seg },
  /* 0117 */ { UD_Icmpsd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0118 */ { UD_Ivcmpsd, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0119 */ { UD_Icmpsq, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw|P_seg },
  /* 0120 */ { UD_Icmpss, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0121 */ { UD_Ivcmpss, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0122 */ { UD_Icmpxchg, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0123 */ { UD_Icmpxchg, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0124 */ { UD_Icmpxchg8b, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0125 */ { UD_Icmpxchg8b, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0126 */ { UD_Icmpxchg16b, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0127 */ { UD_Icomisd, O_Vsd, O_Wsd, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0128 */ { UD_Ivcomisd, O_Vsd, O_Wsd, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0129 */ { UD_Icomiss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0130 */ { UD_Ivcomiss, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0131 */ { UD_Icpuid, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0132 */ { UD_Icvtdq2pd, O_V, O_Wdq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0133 */ { UD_Ivcvtdq2pd, O_Vx, O_Wdq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0134 */ { UD_Icvtdq2ps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0135 */ { UD_Ivcvtdq2ps, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0136 */ { UD_Icvtpd2dq, O_Vdq, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0137 */ { UD_Ivcvtpd2dq, O_Vdq, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0138 */ { UD_Icvtpd2pi, O_P, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0139 */ { UD_Icvtpd2ps, O_Vdq, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0140 */ { UD_Ivcvtpd2ps, O_Vdq, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0141 */ { UD_Icvtpi2ps, O_V, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0142 */ { UD_Icvtpi2pd, O_V, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0143 */ { UD_Icvtps2dq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0144 */ { UD_Ivcvtps2dq, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0145 */ { UD_Icvtps2pd, O_V, O_Wdq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0146 */ { UD_Ivcvtps2pd, O_Vx, O_Wdq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0147 */ { UD_Icvtps2pi, O_P, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0148 */ { UD_Icvtsd2si, O_Gy, O_MqU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0149 */ { UD_Ivcvtsd2si, O_Gy, O_MqU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0150 */ { UD_Icvtsd2ss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0151 */ { UD_Ivcvtsd2ss, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0152 */ { UD_Icvtsi2sd, O_V, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0153 */ { UD_Ivcvtsi2sd, O_Vx, O_Hx, O_Ey, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0154 */ { UD_Icvtsi2ss, O_V, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0155 */ { UD_Ivcvtsi2ss, O_Vx, O_Hx, O_Ey, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0156 */ { UD_Icvtss2sd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0157 */ { UD_Ivcvtss2sd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0158 */ { UD_Icvtss2si, O_Gy, O_MdU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0159 */ { UD_Ivcvtss2si, O_Gy, O_MdU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0160 */ { UD_Icvttpd2dq, O_Vdq, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0161 */ { UD_Ivcvttpd2dq, O_Vdq, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0162 */ { UD_Icvttpd2pi, O_P, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0163 */ { UD_Icvttps2dq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0164 */ { UD_Ivcvttps2dq, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0165 */ { UD_Icvttps2pi, O_P, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0166 */ { UD_Icvttsd2si, O_Gy, O_MqU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0167 */ { UD_Ivcvttsd2si, O_Gy, O_MqU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0168 */ { UD_Icvttss2si, O_Gy, O_MdU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0169 */ { UD_Ivcvttss2si, O_Gy, O_MdU, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0170 */ { UD_Icwd, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0171 */ { UD_Icdq, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0172 */ { UD_Icqo, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0173 */ { UD_Idaa, O_NONE, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 0174 */ { UD_Idas, O_NONE, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 0175 */ { UD_Idec, O_R0z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0176 */ { UD_Idec, O_R1z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0177 */ { UD_Idec, O_R2z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0178 */ { UD_Idec, O_R3z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0179 */ { UD_Idec, O_R4z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0180 */ { UD_Idec, O_R5z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0181 */ { UD_Idec, O_R6z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0182 */ { UD_Idec, O_R7z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0183 */ { UD_Idec, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0184 */ { UD_Idec, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0185 */ { UD_Idiv, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0186 */ { UD_Idiv, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0187 */ { UD_Idivpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0188 */ { UD_Ivdivpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0189 */ { UD_Idivps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0190 */ { UD_Ivdivps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0191 */ { UD_Idivsd, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0192 */ { UD_Ivdivsd, O_Vx, O_Hx, O_MqU, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0193 */ { UD_Idivss, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0194 */ { UD_Ivdivss, O_Vx, O_Hx, O_MdU, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0195 */ { UD_Idppd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0196 */ { UD_Ivdppd, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0197 */ { UD_Idpps, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0198 */ { UD_Ivdpps, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0199 */ { UD_Iemms, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0200 */ { UD_Ienter, O_Iw, O_Ib, O_NONE, O_NONE, P_def64 },
  /* 0201 */ { UD_Iextractps, O_MdRy, O_V, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0202 */ { UD_Ivextractps, O_MdRy, O_Vx, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0203 */ { UD_If2xm1, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0204 */ { UD_Ifabs, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0205 */ { UD_Ifadd, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0206 */ { UD_Ifadd, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0207 */ { UD_Ifadd, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0208 */ { UD_Ifadd, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0209 */ { UD_Ifadd, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0210 */ { UD_Ifadd, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0211 */ { UD_Ifadd, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0212 */ { UD_Ifadd, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0213 */ { UD_Ifadd, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0214 */ { UD_Ifadd, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0215 */ { UD_Ifadd, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0216 */ { UD_Ifadd, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0217 */ { UD_Ifadd, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0218 */ { UD_Ifadd, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0219 */ { UD_Ifadd, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0220 */ { UD_Ifadd, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0221 */ { UD_Ifadd, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0222 */ { UD_Ifadd, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0223 */ { UD_Ifaddp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0224 */ { UD_Ifaddp, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0225 */ { UD_Ifaddp, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0226 */ { UD_Ifaddp, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0227 */ { UD_Ifaddp, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0228 */ { UD_Ifaddp, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0229 */ { UD_Ifaddp, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0230 */ { UD_Ifaddp, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0231 */ { UD_Ifbld, O_Mt, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0232 */ { UD_Ifbstp, O_Mt, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0233 */ { UD_Ifchs, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0234 */ { UD_Ifclex, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0235 */ { UD_Ifcmovb, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0236 */ { UD_Ifcmovb, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0237 */ { UD_Ifcmovb, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0238 */ { UD_Ifcmovb, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0239 */ { UD_Ifcmovb, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0240 */ { UD_Ifcmovb, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0241 */ { UD_Ifcmovb, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0242 */ { UD_Ifcmovb, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0243 */ { UD_Ifcmove, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0244 */ { UD_Ifcmove, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0245 */ { UD_Ifcmove, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0246 */ { UD_Ifcmove, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0247 */ { UD_Ifcmove, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0248 */ { UD_Ifcmove, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0249 */ { UD_Ifcmove, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0250 */ { UD_Ifcmove, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0251 */ { UD_Ifcmovbe, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0252 */ { UD_Ifcmovbe, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0253 */ { UD_Ifcmovbe, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0254 */ { UD_Ifcmovbe, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0255 */ { UD_Ifcmovbe, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0256 */ { UD_Ifcmovbe, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0257 */ { UD_Ifcmovbe, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0258 */ { UD_Ifcmovbe, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0259 */ { UD_Ifcmovu, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0260 */ { UD_Ifcmovu, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0261 */ { UD_Ifcmovu, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0262 */ { UD_Ifcmovu, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0263 */ { UD_Ifcmovu, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0264 */ { UD_Ifcmovu, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0265 */ { UD_Ifcmovu, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0266 */ { UD_Ifcmovu, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0267 */ { UD_Ifcmovnb, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0268 */ { UD_Ifcmovnb, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0269 */ { UD_Ifcmovnb, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0270 */ { UD_Ifcmovnb, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0271 */ { UD_Ifcmovnb, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0272 */ { UD_Ifcmovnb, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0273 */ { UD_Ifcmovnb, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0274 */ { UD_Ifcmovnb, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0275 */ { UD_Ifcmovne, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0276 */ { UD_Ifcmovne, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0277 */ { UD_Ifcmovne, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0278 */ { UD_Ifcmovne, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0279 */ { UD_Ifcmovne, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0280 */ { UD_Ifcmovne, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0281 */ { UD_Ifcmovne, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0282 */ { UD_Ifcmovne, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0283 */ { UD_Ifcmovnbe, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0284 */ { UD_Ifcmovnbe, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0285 */ { UD_Ifcmovnbe, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0286 */ { UD_Ifcmovnbe, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0287 */ { UD_Ifcmovnbe, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0288 */ { UD_Ifcmovnbe, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0289 */ { UD_Ifcmovnbe, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0290 */ { UD_Ifcmovnbe, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0291 */ { UD_Ifcmovnu, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0292 */ { UD_Ifcmovnu, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0293 */ { UD_Ifcmovnu, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0294 */ { UD_Ifcmovnu, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0295 */ { UD_Ifcmovnu, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0296 */ { UD_Ifcmovnu, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0297 */ { UD_Ifcmovnu, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0298 */ { UD_Ifcmovnu, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0299 */ { UD_Ifucomi, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0300 */ { UD_Ifucomi, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0301 */ { UD_Ifucomi, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0302 */ { UD_Ifucomi, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0303 */ { UD_Ifucomi, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0304 */ { UD_Ifucomi, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0305 */ { UD_Ifucomi, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0306 */ { UD_Ifucomi, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0307 */ { UD_Ifcom, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0308 */ { UD_Ifcom, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0309 */ { UD_Ifcom, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0310 */ { UD_Ifcom, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0311 */ { UD_Ifcom, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0312 */ { UD_Ifcom, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0313 */ { UD_Ifcom, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0314 */ { UD_Ifcom, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0315 */ { UD_Ifcom, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0316 */ { UD_Ifcom, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0317 */ { UD_Ifcom2, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0318 */ { UD_Ifcom2, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0319 */ { UD_Ifcom2, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0320 */ { UD_Ifcom2, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0321 */ { UD_Ifcom2, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0322 */ { UD_Ifcom2, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0323 */ { UD_Ifcom2, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0324 */ { UD_Ifcom2, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0325 */ { UD_Ifcomp3, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0326 */ { UD_Ifcomp3, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0327 */ { UD_Ifcomp3, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0328 */ { UD_Ifcomp3, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0329 */ { UD_Ifcomp3, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0330 */ { UD_Ifcomp3, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0331 */ { UD_Ifcomp3, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0332 */ { UD_Ifcomp3, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0333 */ { UD_Ifcomi, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0334 */ { UD_Ifcomi, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0335 */ { UD_Ifcomi, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0336 */ { UD_Ifcomi, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0337 */ { UD_Ifcomi, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0338 */ { UD_Ifcomi, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0339 */ { UD_Ifcomi, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0340 */ { UD_Ifcomi, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0341 */ { UD_Ifucomip, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0342 */ { UD_Ifucomip, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0343 */ { UD_Ifucomip, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0344 */ { UD_Ifucomip, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0345 */ { UD_Ifucomip, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0346 */ { UD_Ifucomip, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0347 */ { UD_Ifucomip, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0348 */ { UD_Ifucomip, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0349 */ { UD_Ifcomip, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0350 */ { UD_Ifcomip, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0351 */ { UD_Ifcomip, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0352 */ { UD_Ifcomip, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0353 */ { UD_Ifcomip, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0354 */ { UD_Ifcomip, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0355 */ { UD_Ifcomip, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0356 */ { UD_Ifcomip, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0357 */ { UD_Ifcomp, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0358 */ { UD_Ifcomp, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0359 */ { UD_Ifcomp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0360 */ { UD_Ifcomp, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0361 */ { UD_Ifcomp, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0362 */ { UD_Ifcomp, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0363 */ { UD_Ifcomp, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0364 */ { UD_Ifcomp, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0365 */ { UD_Ifcomp, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0366 */ { UD_Ifcomp, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0367 */ { UD_Ifcomp5, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0368 */ { UD_Ifcomp5, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0369 */ { UD_Ifcomp5, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0370 */ { UD_Ifcomp5, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0371 */ { UD_Ifcomp5, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0372 */ { UD_Ifcomp5, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0373 */ { UD_Ifcomp5, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0374 */ { UD_Ifcomp5, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0375 */ { UD_Ifcompp, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0376 */ { UD_Ifcos, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0377 */ { UD_Ifdecstp, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0378 */ { UD_Ifdiv, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0379 */ { UD_Ifdiv, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0380 */ { UD_Ifdiv, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0381 */ { UD_Ifdiv, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0382 */ { UD_Ifdiv, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0383 */ { UD_Ifdiv, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0384 */ { UD_Ifdiv, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0385 */ { UD_Ifdiv, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0386 */ { UD_Ifdiv, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0387 */ { UD_Ifdiv, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0388 */ { UD_Ifdiv, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0389 */ { UD_Ifdiv, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0390 */ { UD_Ifdiv, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0391 */ { UD_Ifdiv, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0392 */ { UD_Ifdiv, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0393 */ { UD_Ifdiv, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0394 */ { UD_Ifdiv, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0395 */ { UD_Ifdiv, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0396 */ { UD_Ifdivp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0397 */ { UD_Ifdivp, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0398 */ { UD_Ifdivp, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0399 */ { UD_Ifdivp, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0400 */ { UD_Ifdivp, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0401 */ { UD_Ifdivp, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0402 */ { UD_Ifdivp, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0403 */ { UD_Ifdivp, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0404 */ { UD_Ifdivr, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0405 */ { UD_Ifdivr, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0406 */ { UD_Ifdivr, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0407 */ { UD_Ifdivr, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0408 */ { UD_Ifdivr, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0409 */ { UD_Ifdivr, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0410 */ { UD_Ifdivr, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0411 */ { UD_Ifdivr, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0412 */ { UD_Ifdivr, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0413 */ { UD_Ifdivr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0414 */ { UD_Ifdivr, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0415 */ { UD_Ifdivr, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0416 */ { UD_Ifdivr, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0417 */ { UD_Ifdivr, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0418 */ { UD_Ifdivr, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0419 */ { UD_Ifdivr, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0420 */ { UD_Ifdivr, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0421 */ { UD_Ifdivr, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0422 */ { UD_Ifdivrp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0423 */ { UD_Ifdivrp, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0424 */ { UD_Ifdivrp, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0425 */ { UD_Ifdivrp, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0426 */ { UD_Ifdivrp, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0427 */ { UD_Ifdivrp, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0428 */ { UD_Ifdivrp, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0429 */ { UD_Ifdivrp, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0430 */ { UD_Ifemms, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0431 */ { UD_Iffree, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0432 */ { UD_Iffree, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0433 */ { UD_Iffree, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0434 */ { UD_Iffree, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0435 */ { UD_Iffree, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0436 */ { UD_Iffree, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0437 */ { UD_Iffree, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0438 */ { UD_Iffree, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0439 */ { UD_Iffreep, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0440 */ { UD_Iffreep, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0441 */ { UD_Iffreep, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0442 */ { UD_Iffreep, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0443 */ { UD_Iffreep, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0444 */ { UD_Iffreep, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0445 */ { UD_Iffreep, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0446 */ { UD_Iffreep, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0447 */ { UD_Ificom, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0448 */ { UD_Ificom, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0449 */ { UD_Ificomp, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0450 */ { UD_Ificomp, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0451 */ { UD_Ifild, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0452 */ { UD_Ifild, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0453 */ { UD_Ifild, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0454 */ { UD_Ifincstp, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0455 */ { UD_Ifninit, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0456 */ { UD_Ifiadd, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0457 */ { UD_Ifiadd, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0458 */ { UD_Ifidivr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0459 */ { UD_Ifidivr, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0460 */ { UD_Ifidiv, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0461 */ { UD_Ifidiv, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0462 */ { UD_Ifisub, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0463 */ { UD_Ifisub, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0464 */ { UD_Ifisubr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0465 */ { UD_Ifisubr, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0466 */ { UD_Ifist, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0467 */ { UD_Ifist, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0468 */ { UD_Ifistp, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0469 */ { UD_Ifistp, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0470 */ { UD_Ifistp, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0471 */ { UD_Ifisttp, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0472 */ { UD_Ifisttp, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0473 */ { UD_Ifisttp, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0474 */ { UD_Ifld, O_Mt, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0475 */ { UD_Ifld, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0476 */ { UD_Ifld, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0477 */ { UD_Ifld, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0478 */ { UD_Ifld, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0479 */ { UD_Ifld, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0480 */ { UD_Ifld, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0481 */ { UD_Ifld, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0482 */ { UD_Ifld, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0483 */ { UD_Ifld, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0484 */ { UD_Ifld, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0485 */ { UD_Ifld1, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0486 */ { UD_Ifldl2t, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0487 */ { UD_Ifldl2e, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0488 */ { UD_Ifldpi, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0489 */ { UD_Ifldlg2, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0490 */ { UD_Ifldln2, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0491 */ { UD_Ifldz, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0492 */ { UD_Ifldcw, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0493 */ { UD_Ifldenv, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0494 */ { UD_Ifmul, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0495 */ { UD_Ifmul, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0496 */ { UD_Ifmul, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0497 */ { UD_Ifmul, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0498 */ { UD_Ifmul, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0499 */ { UD_Ifmul, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0500 */ { UD_Ifmul, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0501 */ { UD_Ifmul, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0502 */ { UD_Ifmul, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0503 */ { UD_Ifmul, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0504 */ { UD_Ifmul, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0505 */ { UD_Ifmul, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0506 */ { UD_Ifmul, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0507 */ { UD_Ifmul, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0508 */ { UD_Ifmul, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0509 */ { UD_Ifmul, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0510 */ { UD_Ifmul, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0511 */ { UD_Ifmul, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0512 */ { UD_Ifmulp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0513 */ { UD_Ifmulp, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0514 */ { UD_Ifmulp, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0515 */ { UD_Ifmulp, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0516 */ { UD_Ifmulp, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0517 */ { UD_Ifmulp, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0518 */ { UD_Ifmulp, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0519 */ { UD_Ifmulp, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0520 */ { UD_Ifimul, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0521 */ { UD_Ifimul, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0522 */ { UD_Ifnop, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0523 */ { UD_Ifndisi, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0524 */ { UD_Ifneni, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0525 */ { UD_Ifnsetpm, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0526 */ { UD_Ifpatan, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0527 */ { UD_Ifprem, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0528 */ { UD_Ifprem1, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0529 */ { UD_Ifptan, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0530 */ { UD_Ifrndint, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0531 */ { UD_Ifrstor, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0532 */ { UD_Ifrstpm, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0533 */ { UD_Ifnsave, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0534 */ { UD_Ifscale, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0535 */ { UD_Ifsin, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0536 */ { UD_Ifsincos, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0537 */ { UD_Ifsqrt, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0538 */ { UD_Ifstp, O_Mt, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0539 */ { UD_Ifstp, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0540 */ { UD_Ifstp, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0541 */ { UD_Ifstp, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0542 */ { UD_Ifstp, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0543 */ { UD_Ifstp, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0544 */ { UD_Ifstp, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0545 */ { UD_Ifstp, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0546 */ { UD_Ifstp, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0547 */ { UD_Ifstp, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0548 */ { UD_Ifstp, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0549 */ { UD_Ifstp1, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0550 */ { UD_Ifstp1, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0551 */ { UD_Ifstp1, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0552 */ { UD_Ifstp1, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0553 */ { UD_Ifstp1, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0554 */ { UD_Ifstp1, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0555 */ { UD_Ifstp1, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0556 */ { UD_Ifstp1, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0557 */ { UD_Ifstp8, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0558 */ { UD_Ifstp8, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0559 */ { UD_Ifstp8, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0560 */ { UD_Ifstp8, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0561 */ { UD_Ifstp8, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0562 */ { UD_Ifstp8, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0563 */ { UD_Ifstp8, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0564 */ { UD_Ifstp8, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0565 */ { UD_Ifstp9, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0566 */ { UD_Ifstp9, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0567 */ { UD_Ifstp9, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0568 */ { UD_Ifstp9, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0569 */ { UD_Ifstp9, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0570 */ { UD_Ifstp9, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0571 */ { UD_Ifstp9, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0572 */ { UD_Ifstp9, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0573 */ { UD_Ifst, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0574 */ { UD_Ifst, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0575 */ { UD_Ifst, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0576 */ { UD_Ifst, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0577 */ { UD_Ifst, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0578 */ { UD_Ifst, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0579 */ { UD_Ifst, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0580 */ { UD_Ifst, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0581 */ { UD_Ifst, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0582 */ { UD_Ifst, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0583 */ { UD_Ifnstcw, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0584 */ { UD_Ifnstenv, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0585 */ { UD_Ifnstsw, O_Mw, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0586 */ { UD_Ifnstsw, O_AX, O_NONE, O_NONE, O_NONE, P_none },
  /* 0587 */ { UD_Ifsub, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0588 */ { UD_Ifsub, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0589 */ { UD_Ifsub, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0590 */ { UD_Ifsub, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0591 */ { UD_Ifsub, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0592 */ { UD_Ifsub, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0593 */ { UD_Ifsub, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0594 */ { UD_Ifsub, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0595 */ { UD_Ifsub, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0596 */ { UD_Ifsub, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0597 */ { UD_Ifsub, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0598 */ { UD_Ifsub, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0599 */ { UD_Ifsub, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0600 */ { UD_Ifsub, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0601 */ { UD_Ifsub, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0602 */ { UD_Ifsub, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0603 */ { UD_Ifsub, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0604 */ { UD_Ifsub, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0605 */ { UD_Ifsubp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0606 */ { UD_Ifsubp, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0607 */ { UD_Ifsubp, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0608 */ { UD_Ifsubp, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0609 */ { UD_Ifsubp, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0610 */ { UD_Ifsubp, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0611 */ { UD_Ifsubp, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0612 */ { UD_Ifsubp, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0613 */ { UD_Ifsubr, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0614 */ { UD_Ifsubr, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0615 */ { UD_Ifsubr, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0616 */ { UD_Ifsubr, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0617 */ { UD_Ifsubr, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0618 */ { UD_Ifsubr, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0619 */ { UD_Ifsubr, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0620 */ { UD_Ifsubr, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0621 */ { UD_Ifsubr, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0622 */ { UD_Ifsubr, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0623 */ { UD_Ifsubr, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0624 */ { UD_Ifsubr, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0625 */ { UD_Ifsubr, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0626 */ { UD_Ifsubr, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0627 */ { UD_Ifsubr, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0628 */ { UD_Ifsubr, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0629 */ { UD_Ifsubr, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0630 */ { UD_Ifsubr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0631 */ { UD_Ifsubrp, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0632 */ { UD_Ifsubrp, O_ST1, O_ST0, O_NONE, O_NONE, P_none },
  /* 0633 */ { UD_Ifsubrp, O_ST2, O_ST0, O_NONE, O_NONE, P_none },
  /* 0634 */ { UD_Ifsubrp, O_ST3, O_ST0, O_NONE, O_NONE, P_none },
  /* 0635 */ { UD_Ifsubrp, O_ST4, O_ST0, O_NONE, O_NONE, P_none },
  /* 0636 */ { UD_Ifsubrp, O_ST5, O_ST0, O_NONE, O_NONE, P_none },
  /* 0637 */ { UD_Ifsubrp, O_ST6, O_ST0, O_NONE, O_NONE, P_none },
  /* 0638 */ { UD_Ifsubrp, O_ST7, O_ST0, O_NONE, O_NONE, P_none },
  /* 0639 */ { UD_Iftst, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0640 */ { UD_Ifucom, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0641 */ { UD_Ifucom, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0642 */ { UD_Ifucom, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0643 */ { UD_Ifucom, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0644 */ { UD_Ifucom, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0645 */ { UD_Ifucom, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0646 */ { UD_Ifucom, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0647 */ { UD_Ifucom, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0648 */ { UD_Ifucomp, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0649 */ { UD_Ifucomp, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0650 */ { UD_Ifucomp, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0651 */ { UD_Ifucomp, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0652 */ { UD_Ifucomp, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0653 */ { UD_Ifucomp, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0654 */ { UD_Ifucomp, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0655 */ { UD_Ifucomp, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0656 */ { UD_Ifucompp, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0657 */ { UD_Ifxam, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0658 */ { UD_Ifxch, O_ST0, O_ST0, O_NONE, O_NONE, P_none },
  /* 0659 */ { UD_Ifxch, O_ST0, O_ST1, O_NONE, O_NONE, P_none },
  /* 0660 */ { UD_Ifxch, O_ST0, O_ST2, O_NONE, O_NONE, P_none },
  /* 0661 */ { UD_Ifxch, O_ST0, O_ST3, O_NONE, O_NONE, P_none },
  /* 0662 */ { UD_Ifxch, O_ST0, O_ST4, O_NONE, O_NONE, P_none },
  /* 0663 */ { UD_Ifxch, O_ST0, O_ST5, O_NONE, O_NONE, P_none },
  /* 0664 */ { UD_Ifxch, O_ST0, O_ST6, O_NONE, O_NONE, P_none },
  /* 0665 */ { UD_Ifxch, O_ST0, O_ST7, O_NONE, O_NONE, P_none },
  /* 0666 */ { UD_Ifxch4, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0667 */ { UD_Ifxch4, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0668 */ { UD_Ifxch4, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0669 */ { UD_Ifxch4, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0670 */ { UD_Ifxch4, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0671 */ { UD_Ifxch4, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0672 */ { UD_Ifxch4, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0673 */ { UD_Ifxch4, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0674 */ { UD_Ifxch7, O_ST0, O_NONE, O_NONE, O_NONE, P_none },
  /* 0675 */ { UD_Ifxch7, O_ST1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0676 */ { UD_Ifxch7, O_ST2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0677 */ { UD_Ifxch7, O_ST3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0678 */ { UD_Ifxch7, O_ST4, O_NONE, O_NONE, O_NONE, P_none },
  /* 0679 */ { UD_Ifxch7, O_ST5, O_NONE, O_NONE, O_NONE, P_none },
  /* 0680 */ { UD_Ifxch7, O_ST6, O_NONE, O_NONE, O_NONE, P_none },
  /* 0681 */ { UD_Ifxch7, O_ST7, O_NONE, O_NONE, O_NONE, P_none },
  /* 0682 */ { UD_Ifxrstor, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0683 */ { UD_Ifxsave, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0684 */ { UD_Ifxtract, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0685 */ { UD_Ifyl2x, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0686 */ { UD_Ifyl2xp1, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0687 */ { UD_Ihlt, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0688 */ { UD_Iidiv, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0689 */ { UD_Iidiv, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0690 */ { UD_Iin, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 0691 */ { UD_Iin, O_eAX, O_Ib, O_NONE, O_NONE, P_oso },
  /* 0692 */ { UD_Iin, O_AL, O_DX, O_NONE, O_NONE, P_none },
  /* 0693 */ { UD_Iin, O_eAX, O_DX, O_NONE, O_NONE, P_oso },
  /* 0694 */ { UD_Iimul, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0695 */ { UD_Iimul, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0696 */ { UD_Iimul, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0697 */ { UD_Iimul, O_Gv, O_Ev, O_Iz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0698 */ { UD_Iimul, O_Gv, O_Ev, O_sIb, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0699 */ { UD_Iinc, O_R0z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0700 */ { UD_Iinc, O_R1z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0701 */ { UD_Iinc, O_R2z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0702 */ { UD_Iinc, O_R3z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0703 */ { UD_Iinc, O_R4z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0704 */ { UD_Iinc, O_R5z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0705 */ { UD_Iinc, O_R6z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0706 */ { UD_Iinc, O_R7z, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0707 */ { UD_Iinc, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0708 */ { UD_Iinc, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0709 */ { UD_Iinsb, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0710 */ { UD_Iinsw, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_oso|P_seg },
  /* 0711 */ { UD_Iinsd, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_oso|P_seg },
  /* 0712 */ { UD_Iint1, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0713 */ { UD_Iint3, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0714 */ { UD_Iint, O_Ib, O_NONE, O_NONE, O_NONE, P_none },
  /* 0715 */ { UD_Iinto, O_NONE, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 0716 */ { UD_Iinvd, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0717 */ { UD_Iinvept, O_Gd, O_Mo, O_NONE, O_NONE, P_none },
  /* 0718 */ { UD_Iinvept, O_Gq, O_Mo, O_NONE, O_NONE, P_none },
  /* 0719 */ { UD_Iinvlpg, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0720 */ { UD_Iinvlpga, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0721 */ { UD_Iinvvpid, O_Gd, O_Mo, O_NONE, O_NONE, P_none },
  /* 0722 */ { UD_Iinvvpid, O_Gq, O_Mo, O_NONE, O_NONE, P_none },
  /* 0723 */ { UD_Iiretw, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0724 */ { UD_Iiretd, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0725 */ { UD_Iiretq, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0726 */ { UD_Ijo, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0727 */ { UD_Ijo, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0728 */ { UD_Ijno, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0729 */ { UD_Ijno, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0730 */ { UD_Ijb, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0731 */ { UD_Ijb, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0732 */ { UD_Ijae, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0733 */ { UD_Ijae, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0734 */ { UD_Ijz, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0735 */ { UD_Ijz, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0736 */ { UD_Ijnz, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0737 */ { UD_Ijnz, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0738 */ { UD_Ijbe, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0739 */ { UD_Ijbe, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0740 */ { UD_Ija, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0741 */ { UD_Ija, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0742 */ { UD_Ijs, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0743 */ { UD_Ijs, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0744 */ { UD_Ijns, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0745 */ { UD_Ijns, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0746 */ { UD_Ijp, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0747 */ { UD_Ijp, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0748 */ { UD_Ijnp, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0749 */ { UD_Ijnp, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0750 */ { UD_Ijl, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0751 */ { UD_Ijl, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0752 */ { UD_Ijge, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0753 */ { UD_Ijge, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0754 */ { UD_Ijle, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0755 */ { UD_Ijle, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0756 */ { UD_Ijg, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0757 */ { UD_Ijg, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0758 */ { UD_Ijcxz, O_Jb, O_NONE, O_NONE, O_NONE, P_aso },
  /* 0759 */ { UD_Ijecxz, O_Jb, O_NONE, O_NONE, O_NONE, P_aso },
  /* 0760 */ { UD_Ijrcxz, O_Jb, O_NONE, O_NONE, O_NONE, P_aso },
  /* 0761 */ { UD_Ijmp, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 0762 */ { UD_Ijmp, O_Fv, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0763 */ { UD_Ijmp, O_Jz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0764 */ { UD_Ijmp, O_Av, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0765 */ { UD_Ijmp, O_Jb, O_NONE, O_NONE, O_NONE, P_def64 },
  /* 0766 */ { UD_Ilahf, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0767 */ { UD_Ilar, O_Gv, O_Ew, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0768 */ { UD_Ildmxcsr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0769 */ { UD_Ilds, O_Gv, O_M, O_NONE, O_NONE, P_aso|P_oso },
  /* 0770 */ { UD_Ilea, O_Gv, O_M, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0771 */ { UD_Iles, O_Gv, O_M, O_NONE, O_NONE, P_aso|P_oso },
  /* 0772 */ { UD_Ilfs, O_Gz, O_M, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0773 */ { UD_Ilgs, O_Gz, O_M, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0774 */ { UD_Ilidt, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0775 */ { UD_Ilss, O_Gv, O_M, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0776 */ { UD_Ileave, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0777 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0778 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0779 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0780 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0781 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0782 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0783 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0784 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0785 */ { UD_Ilgdt, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0786 */ { UD_Illdt, O_Ew, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0787 */ { UD_Ilmsw, O_Ew, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0788 */ { UD_Ilmsw, O_Ew, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0789 */ { UD_Ilock, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0790 */ { UD_Ilodsb, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0791 */ { UD_Ilodsw, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0792 */ { UD_Ilodsd, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0793 */ { UD_Ilodsq, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0794 */ { UD_Iloopne, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0795 */ { UD_Iloope, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0796 */ { UD_Iloop, O_Jb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0797 */ { UD_Ilsl, O_Gv, O_Ew, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0798 */ { UD_Iltr, O_Ew, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0799 */ { UD_Imaskmovq, O_P, O_N, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0800 */ { UD_Imaxpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0801 */ { UD_Ivmaxpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0802 */ { UD_Imaxps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0803 */ { UD_Ivmaxps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0804 */ { UD_Imaxsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0805 */ { UD_Ivmaxsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0806 */ { UD_Imaxss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0807 */ { UD_Ivmaxss, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0808 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0809 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0810 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0811 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0812 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0813 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0814 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0815 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0816 */ { UD_Iminpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0817 */ { UD_Ivminpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0818 */ { UD_Iminps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0819 */ { UD_Ivminps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0820 */ { UD_Iminsd, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0821 */ { UD_Ivminsd, O_Vx, O_Hx, O_MqU, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0822 */ { UD_Iminss, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0823 */ { UD_Ivminss, O_Vx, O_Hx, O_MdU, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0824 */ { UD_Imonitor, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0825 */ { UD_Imontmul, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0826 */ { UD_Imov, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0827 */ { UD_Imov, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0828 */ { UD_Imov, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0829 */ { UD_Imov, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0830 */ { UD_Imov, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0831 */ { UD_Imov, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0832 */ { UD_Imov, O_MwRv, O_S, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0833 */ { UD_Imov, O_S, O_MwRv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0834 */ { UD_Imov, O_AL, O_Ob, O_NONE, O_NONE, P_none },
  /* 0835 */ { UD_Imov, O_rAX, O_Ov, O_NONE, O_NONE, P_aso|P_oso|P_rexw },
  /* 0836 */ { UD_Imov, O_Ob, O_AL, O_NONE, O_NONE, P_none },
  /* 0837 */ { UD_Imov, O_Ov, O_rAX, O_NONE, O_NONE, P_aso|P_oso|P_rexw },
  /* 0838 */ { UD_Imov, O_R0b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0839 */ { UD_Imov, O_R1b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0840 */ { UD_Imov, O_R2b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0841 */ { UD_Imov, O_R3b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0842 */ { UD_Imov, O_R4b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0843 */ { UD_Imov, O_R5b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0844 */ { UD_Imov, O_R6b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0845 */ { UD_Imov, O_R7b, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 0846 */ { UD_Imov, O_R0v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0847 */ { UD_Imov, O_R1v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0848 */ { UD_Imov, O_R2v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0849 */ { UD_Imov, O_R3v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0850 */ { UD_Imov, O_R4v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0851 */ { UD_Imov, O_R5v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0852 */ { UD_Imov, O_R6v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0853 */ { UD_Imov, O_R7v, O_Iv, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0854 */ { UD_Imov, O_R, O_C, O_NONE, O_NONE, P_rexr|P_rexw|P_rexb },
  /* 0855 */ { UD_Imov, O_R, O_D, O_NONE, O_NONE, P_rexr|P_rexw|P_rexb },
  /* 0856 */ { UD_Imov, O_C, O_R, O_NONE, O_NONE, P_rexr|P_rexw|P_rexb },
  /* 0857 */ { UD_Imov, O_D, O_R, O_NONE, O_NONE, P_rexr|P_rexw|P_rexb },
  /* 0858 */ { UD_Imovapd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0859 */ { UD_Ivmovapd, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0860 */ { UD_Imovapd, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0861 */ { UD_Ivmovapd, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0862 */ { UD_Imovaps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0863 */ { UD_Ivmovaps, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0864 */ { UD_Imovaps, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0865 */ { UD_Ivmovaps, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0866 */ { UD_Imovd, O_P, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0867 */ { UD_Imovd, O_P, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0868 */ { UD_Imovd, O_V, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0869 */ { UD_Ivmovd, O_Vx, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0870 */ { UD_Imovd, O_V, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0871 */ { UD_Ivmovd, O_Vx, O_Ey, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0872 */ { UD_Imovd, O_Ey, O_P, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0873 */ { UD_Imovd, O_Ey, O_P, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0874 */ { UD_Imovd, O_Ey, O_V, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0875 */ { UD_Ivmovd, O_Ey, O_Vx, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0876 */ { UD_Imovd, O_Ey, O_V, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0877 */ { UD_Ivmovd, O_Ey, O_Vx, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0878 */ { UD_Imovhpd, O_V, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0879 */ { UD_Ivmovhpd, O_Vx, O_Hx, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0880 */ { UD_Imovhpd, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0881 */ { UD_Ivmovhpd, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0882 */ { UD_Imovhps, O_V, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0883 */ { UD_Ivmovhps, O_Vx, O_Hx, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0884 */ { UD_Imovhps, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0885 */ { UD_Ivmovhps, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0886 */ { UD_Imovlhps, O_V, O_U, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0887 */ { UD_Ivmovlhps, O_Vx, O_Hx, O_Ux, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0888 */ { UD_Imovlpd, O_V, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0889 */ { UD_Ivmovlpd, O_Vx, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0890 */ { UD_Imovlpd, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0891 */ { UD_Ivmovlpd, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0892 */ { UD_Imovlps, O_V, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0893 */ { UD_Ivmovlps, O_Vx, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0894 */ { UD_Imovlps, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0895 */ { UD_Ivmovlps, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0896 */ { UD_Imovhlps, O_V, O_U, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0897 */ { UD_Ivmovhlps, O_Vx, O_Ux, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0898 */ { UD_Imovmskpd, O_Gd, O_U, O_NONE, O_NONE, P_oso|P_rexr|P_rexb },
  /* 0899 */ { UD_Ivmovmskpd, O_Gd, O_Ux, O_NONE, O_NONE, P_oso|P_rexr|P_rexb|P_vexl },
  /* 0900 */ { UD_Imovmskps, O_Gd, O_U, O_NONE, O_NONE, P_oso|P_rexr|P_rexb },
  /* 0901 */ { UD_Ivmovmskps, O_Gd, O_Ux, O_NONE, O_NONE, P_oso|P_rexr|P_rexb },
  /* 0902 */ { UD_Imovntdq, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0903 */ { UD_Ivmovntdq, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0904 */ { UD_Imovnti, O_M, O_Gy, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0905 */ { UD_Imovntpd, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0906 */ { UD_Ivmovntpd, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0907 */ { UD_Imovntps, O_M, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0908 */ { UD_Ivmovntps, O_M, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0909 */ { UD_Imovntq, O_M, O_P, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0910 */ { UD_Imovq, O_P, O_Eq, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0911 */ { UD_Imovq, O_V, O_Eq, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0912 */ { UD_Ivmovq, O_Vx, O_Eq, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0913 */ { UD_Imovq, O_Eq, O_P, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0914 */ { UD_Imovq, O_Eq, O_V, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0915 */ { UD_Ivmovq, O_Eq, O_Vx, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0916 */ { UD_Imovq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0917 */ { UD_Ivmovq, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0918 */ { UD_Imovq, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0919 */ { UD_Ivmovq, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0920 */ { UD_Imovq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0921 */ { UD_Imovq, O_Q, O_P, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0922 */ { UD_Imovsb, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0923 */ { UD_Imovsw, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0924 */ { UD_Imovsd, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0925 */ { UD_Imovsd, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0926 */ { UD_Imovsd, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0927 */ { UD_Imovsq, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0928 */ { UD_Imovss, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0929 */ { UD_Imovss, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0930 */ { UD_Imovsx, O_Gv, O_Eb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0931 */ { UD_Imovsx, O_Gy, O_Ew, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0932 */ { UD_Imovupd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0933 */ { UD_Ivmovupd, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0934 */ { UD_Imovupd, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0935 */ { UD_Ivmovupd, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0936 */ { UD_Imovups, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0937 */ { UD_Ivmovups, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0938 */ { UD_Imovups, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0939 */ { UD_Ivmovups, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0940 */ { UD_Imovzx, O_Gv, O_Eb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0941 */ { UD_Imovzx, O_Gy, O_Ew, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0942 */ { UD_Imul, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0943 */ { UD_Imul, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0944 */ { UD_Imulpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0945 */ { UD_Ivmulpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0946 */ { UD_Imulps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0947 */ { UD_Ivmulps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0948 */ { UD_Imulsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0949 */ { UD_Ivmulsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0950 */ { UD_Imulss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0951 */ { UD_Ivmulss, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0952 */ { UD_Imwait, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 0953 */ { UD_Ineg, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0954 */ { UD_Ineg, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0955 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0956 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0957 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0958 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0959 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0960 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0961 */ { UD_Inop, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0962 */ { UD_Inot, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0963 */ { UD_Inot, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0964 */ { UD_Ior, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0965 */ { UD_Ior, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0966 */ { UD_Ior, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0967 */ { UD_Ior, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0968 */ { UD_Ior, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 0969 */ { UD_Ior, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0970 */ { UD_Ior, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0971 */ { UD_Ior, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0972 */ { UD_Ior, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0973 */ { UD_Ior, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0974 */ { UD_Iorpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0975 */ { UD_Ivorpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0976 */ { UD_Iorps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0977 */ { UD_Ivorps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0978 */ { UD_Iout, O_Ib, O_AL, O_NONE, O_NONE, P_none },
  /* 0979 */ { UD_Iout, O_Ib, O_eAX, O_NONE, O_NONE, P_oso },
  /* 0980 */ { UD_Iout, O_DX, O_AL, O_NONE, O_NONE, P_none },
  /* 0981 */ { UD_Iout, O_DX, O_eAX, O_NONE, O_NONE, P_oso },
  /* 0982 */ { UD_Ioutsb, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0983 */ { UD_Ioutsw, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_oso|P_seg },
  /* 0984 */ { UD_Ioutsd, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_oso|P_seg },
  /* 0985 */ { UD_Ipacksswb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0986 */ { UD_Ivpacksswb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0987 */ { UD_Ipacksswb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0988 */ { UD_Ipackssdw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0989 */ { UD_Ivpackssdw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0990 */ { UD_Ipackssdw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0991 */ { UD_Ipackuswb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0992 */ { UD_Ivpackuswb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0993 */ { UD_Ipackuswb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0994 */ { UD_Ipaddb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0995 */ { UD_Ivpaddb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 0996 */ { UD_Ipaddb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0997 */ { UD_Ipaddw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0998 */ { UD_Ipaddw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0999 */ { UD_Ivpaddw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1000 */ { UD_Ipaddd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1001 */ { UD_Ipaddd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1002 */ { UD_Ivpaddd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1003 */ { UD_Ipaddsb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1004 */ { UD_Ipaddsb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1005 */ { UD_Ivpaddsb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1006 */ { UD_Ipaddsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1007 */ { UD_Ipaddsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1008 */ { UD_Ivpaddsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1009 */ { UD_Ipaddusb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1010 */ { UD_Ipaddusb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1011 */ { UD_Ivpaddusb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1012 */ { UD_Ipaddusw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1013 */ { UD_Ipaddusw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1014 */ { UD_Ivpaddusw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1015 */ { UD_Ipand, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1016 */ { UD_Ivpand, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1017 */ { UD_Ipand, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1018 */ { UD_Ipandn, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1019 */ { UD_Ivpandn, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1020 */ { UD_Ipandn, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1021 */ { UD_Ipavgb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1022 */ { UD_Ivpavgb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1023 */ { UD_Ipavgb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1024 */ { UD_Ipavgw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1025 */ { UD_Ivpavgw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1026 */ { UD_Ipavgw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1027 */ { UD_Ipcmpeqb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1028 */ { UD_Ipcmpeqb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1029 */ { UD_Ivpcmpeqb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1030 */ { UD_Ipcmpeqw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1031 */ { UD_Ipcmpeqw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1032 */ { UD_Ivpcmpeqw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1033 */ { UD_Ipcmpeqd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1034 */ { UD_Ipcmpeqd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1035 */ { UD_Ivpcmpeqd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1036 */ { UD_Ipcmpgtb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1037 */ { UD_Ivpcmpgtb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1038 */ { UD_Ipcmpgtb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1039 */ { UD_Ipcmpgtw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1040 */ { UD_Ivpcmpgtw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1041 */ { UD_Ipcmpgtw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1042 */ { UD_Ipcmpgtd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1043 */ { UD_Ivpcmpgtd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1044 */ { UD_Ipcmpgtd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1045 */ { UD_Ipextrb, O_MbRv, O_V, O_Ib, O_NONE, P_aso|P_rexx|P_rexr|P_rexb|P_def64 },
  /* 1046 */ { UD_Ivpextrb, O_MbRv, O_Vx, O_Ib, O_NONE, P_aso|P_rexx|P_rexr|P_rexb|P_def64 },
  /* 1047 */ { UD_Ipextrd, O_Ed, O_V, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexw|P_rexb },
  /* 1048 */ { UD_Ivpextrd, O_Ed, O_Vx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexw|P_rexb },
  /* 1049 */ { UD_Ipextrd, O_Ed, O_V, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexw|P_rexb },
  /* 1050 */ { UD_Ivpextrd, O_Ed, O_Vx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexw|P_rexb },
  /* 1051 */ { UD_Ipextrq, O_Eq, O_V, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexb|P_def64 },
  /* 1052 */ { UD_Ivpextrq, O_Eq, O_Vx, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexb|P_def64 },
  /* 1053 */ { UD_Ipextrw, O_Gd, O_U, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexb },
  /* 1054 */ { UD_Ivpextrw, O_Gd, O_Ux, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexb },
  /* 1055 */ { UD_Ipextrw, O_Gd, O_N, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1056 */ { UD_Ipextrw, O_MwRd, O_V, O_Ib, O_NONE, P_aso|P_rexw|P_rexx|P_rexr|P_rexb },
  /* 1057 */ { UD_Ivpextrw, O_MwRd, O_Vx, O_Ib, O_NONE, P_aso|P_rexw|P_rexx|P_rexr|P_rexb },
  /* 1058 */ { UD_Ipinsrb, O_V, O_MbRd, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1059 */ { UD_Ipinsrw, O_P, O_MwRy, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1060 */ { UD_Ipinsrw, O_V, O_MwRy, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1061 */ { UD_Ivpinsrw, O_Vx, O_MwRy, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1062 */ { UD_Ipinsrd, O_V, O_Ed, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1063 */ { UD_Ipinsrd, O_V, O_Ed, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1064 */ { UD_Ipinsrq, O_V, O_Eq, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1065 */ { UD_Ivpinsrb, O_V, O_H, O_MbRd, O_Ib, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1066 */ { UD_Ivpinsrd, O_V, O_H, O_Ed, O_Ib, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1067 */ { UD_Ivpinsrd, O_V, O_H, O_Ed, O_Ib, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1068 */ { UD_Ivpinsrq, O_V, O_H, O_Eq, O_Ib, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1069 */ { UD_Ipmaddwd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1070 */ { UD_Ipmaddwd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1071 */ { UD_Ivpmaddwd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1072 */ { UD_Ipmaxsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1073 */ { UD_Ivpmaxsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1074 */ { UD_Ipmaxsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1075 */ { UD_Ipmaxub, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1076 */ { UD_Ipmaxub, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1077 */ { UD_Ivpmaxub, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1078 */ { UD_Ipminsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1079 */ { UD_Ivpminsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1080 */ { UD_Ipminsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1081 */ { UD_Ipminub, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1082 */ { UD_Ivpminub, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1083 */ { UD_Ipminub, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1084 */ { UD_Ipmovmskb, O_Gd, O_U, O_NONE, O_NONE, P_oso|P_rexr|P_rexw|P_rexb },
  /* 1085 */ { UD_Ivpmovmskb, O_Gd, O_Ux, O_NONE, O_NONE, P_oso|P_rexr|P_rexw|P_rexb },
  /* 1086 */ { UD_Ipmovmskb, O_Gd, O_N, O_NONE, O_NONE, P_oso|P_rexr|P_rexw|P_rexb },
  /* 1087 */ { UD_Ipmulhuw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1088 */ { UD_Ipmulhuw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1089 */ { UD_Ivpmulhuw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1090 */ { UD_Ipmulhw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1091 */ { UD_Ivpmulhw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1092 */ { UD_Ipmulhw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1093 */ { UD_Ipmullw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1094 */ { UD_Ipmullw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1095 */ { UD_Ivpmullw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1096 */ { UD_Ipop, O_ES, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1097 */ { UD_Ipop, O_SS, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1098 */ { UD_Ipop, O_DS, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1099 */ { UD_Ipop, O_GS, O_NONE, O_NONE, O_NONE, P_none },
  /* 1100 */ { UD_Ipop, O_FS, O_NONE, O_NONE, O_NONE, P_none },
  /* 1101 */ { UD_Ipop, O_R0v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1102 */ { UD_Ipop, O_R1v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1103 */ { UD_Ipop, O_R2v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1104 */ { UD_Ipop, O_R3v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1105 */ { UD_Ipop, O_R4v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1106 */ { UD_Ipop, O_R5v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1107 */ { UD_Ipop, O_R6v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1108 */ { UD_Ipop, O_R7v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1109 */ { UD_Ipop, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1110 */ { UD_Ipopa, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_inv64 },
  /* 1111 */ { UD_Ipopad, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_inv64 },
  /* 1112 */ { UD_Ipopfw, O_NONE, O_NONE, O_NONE, O_NONE, P_oso },
  /* 1113 */ { UD_Ipopfd, O_NONE, O_NONE, O_NONE, O_NONE, P_oso },
  /* 1114 */ { UD_Ipopfq, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 1115 */ { UD_Ipopfq, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 1116 */ { UD_Ipor, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1117 */ { UD_Ivpor, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1118 */ { UD_Ipor, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1119 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1120 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1121 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1122 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1123 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1124 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1125 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1126 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1127 */ { UD_Iprefetchnta, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1128 */ { UD_Iprefetcht0, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1129 */ { UD_Iprefetcht1, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1130 */ { UD_Iprefetcht2, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1131 */ { UD_Ipsadbw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1132 */ { UD_Ivpsadbw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1133 */ { UD_Ipsadbw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1134 */ { UD_Ipshufw, O_P, O_Q, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1135 */ { UD_Ipsllw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1136 */ { UD_Ipsllw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1137 */ { UD_Ipsllw, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1138 */ { UD_Ipsllw, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1139 */ { UD_Ipslld, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1140 */ { UD_Ipslld, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1141 */ { UD_Ipslld, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1142 */ { UD_Ipslld, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1143 */ { UD_Ipsllq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1144 */ { UD_Ipsllq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1145 */ { UD_Ipsllq, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1146 */ { UD_Ipsllq, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1147 */ { UD_Ipsraw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1148 */ { UD_Ipsraw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1149 */ { UD_Ivpsraw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1150 */ { UD_Ipsraw, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1151 */ { UD_Ivpsraw, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1152 */ { UD_Ipsraw, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1153 */ { UD_Ipsrad, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1154 */ { UD_Ipsrad, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1155 */ { UD_Ivpsrad, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1156 */ { UD_Ipsrad, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1157 */ { UD_Ipsrad, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1158 */ { UD_Ivpsrad, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1159 */ { UD_Ipsrlw, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1160 */ { UD_Ipsrlw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1161 */ { UD_Ipsrlw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1162 */ { UD_Ivpsrlw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1163 */ { UD_Ipsrlw, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1164 */ { UD_Ivpsrlw, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1165 */ { UD_Ipsrld, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1166 */ { UD_Ipsrld, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1167 */ { UD_Ipsrld, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1168 */ { UD_Ivpsrld, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1169 */ { UD_Ipsrld, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1170 */ { UD_Ivpsrld, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1171 */ { UD_Ipsrlq, O_N, O_Ib, O_NONE, O_NONE, P_none },
  /* 1172 */ { UD_Ipsrlq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1173 */ { UD_Ipsrlq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1174 */ { UD_Ivpsrlq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1175 */ { UD_Ipsrlq, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1176 */ { UD_Ivpsrlq, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1177 */ { UD_Ipsubb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1178 */ { UD_Ivpsubb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1179 */ { UD_Ipsubb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1180 */ { UD_Ipsubw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1181 */ { UD_Ivpsubw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1182 */ { UD_Ipsubw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1183 */ { UD_Ipsubd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1184 */ { UD_Ipsubd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1185 */ { UD_Ivpsubd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1186 */ { UD_Ipsubsb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1187 */ { UD_Ipsubsb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1188 */ { UD_Ivpsubsb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1189 */ { UD_Ipsubsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1190 */ { UD_Ipsubsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1191 */ { UD_Ivpsubsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1192 */ { UD_Ipsubusb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1193 */ { UD_Ipsubusb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1194 */ { UD_Ivpsubusb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1195 */ { UD_Ipsubusw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1196 */ { UD_Ipsubusw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1197 */ { UD_Ivpsubusw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1198 */ { UD_Ipunpckhbw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1199 */ { UD_Ivpunpckhbw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1200 */ { UD_Ipunpckhbw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1201 */ { UD_Ipunpckhwd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1202 */ { UD_Ivpunpckhwd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1203 */ { UD_Ipunpckhwd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1204 */ { UD_Ipunpckhdq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1205 */ { UD_Ivpunpckhdq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1206 */ { UD_Ipunpckhdq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1207 */ { UD_Ipunpcklbw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1208 */ { UD_Ivpunpcklbw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1209 */ { UD_Ipunpcklbw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1210 */ { UD_Ipunpcklwd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1211 */ { UD_Ivpunpcklwd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1212 */ { UD_Ipunpcklwd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1213 */ { UD_Ipunpckldq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1214 */ { UD_Ivpunpckldq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1215 */ { UD_Ipunpckldq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1216 */ { UD_Ipi2fw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1217 */ { UD_Ipi2fd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1218 */ { UD_Ipf2iw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1219 */ { UD_Ipf2id, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1220 */ { UD_Ipfnacc, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1221 */ { UD_Ipfpnacc, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1222 */ { UD_Ipfcmpge, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1223 */ { UD_Ipfmin, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1224 */ { UD_Ipfrcp, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1225 */ { UD_Ipfrsqrt, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1226 */ { UD_Ipfsub, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1227 */ { UD_Ipfadd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1228 */ { UD_Ipfcmpgt, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1229 */ { UD_Ipfmax, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1230 */ { UD_Ipfrcpit1, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1231 */ { UD_Ipfrsqit1, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1232 */ { UD_Ipfsubr, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1233 */ { UD_Ipfacc, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1234 */ { UD_Ipfcmpeq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1235 */ { UD_Ipfmul, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1236 */ { UD_Ipfrcpit2, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1237 */ { UD_Ipmulhrw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1238 */ { UD_Ipswapd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1239 */ { UD_Ipavgusb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1240 */ { UD_Ipush, O_ES, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1241 */ { UD_Ipush, O_CS, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1242 */ { UD_Ipush, O_SS, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1243 */ { UD_Ipush, O_DS, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1244 */ { UD_Ipush, O_GS, O_NONE, O_NONE, O_NONE, P_none },
  /* 1245 */ { UD_Ipush, O_FS, O_NONE, O_NONE, O_NONE, P_none },
  /* 1246 */ { UD_Ipush, O_R0v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1247 */ { UD_Ipush, O_R1v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1248 */ { UD_Ipush, O_R2v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1249 */ { UD_Ipush, O_R3v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1250 */ { UD_Ipush, O_R4v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1251 */ { UD_Ipush, O_R5v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1252 */ { UD_Ipush, O_R6v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1253 */ { UD_Ipush, O_R7v, O_NONE, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 1254 */ { UD_Ipush, O_sIz, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 1255 */ { UD_Ipush, O_Ev, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1256 */ { UD_Ipush, O_sIb, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 1257 */ { UD_Ipusha, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_inv64 },
  /* 1258 */ { UD_Ipushad, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_inv64 },
  /* 1259 */ { UD_Ipushfw, O_NONE, O_NONE, O_NONE, O_NONE, P_oso },
  /* 1260 */ { UD_Ipushfw, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_def64 },
  /* 1261 */ { UD_Ipushfd, O_NONE, O_NONE, O_NONE, O_NONE, P_oso },
  /* 1262 */ { UD_Ipushfq, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_def64 },
  /* 1263 */ { UD_Ipushfq, O_NONE, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_def64 },
  /* 1264 */ { UD_Ipxor, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1265 */ { UD_Ivpxor, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1266 */ { UD_Ipxor, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1267 */ { UD_Ircl, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1268 */ { UD_Ircl, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1269 */ { UD_Ircl, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1270 */ { UD_Ircl, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1271 */ { UD_Ircl, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1272 */ { UD_Ircl, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1273 */ { UD_Ircr, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1274 */ { UD_Ircr, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1275 */ { UD_Ircr, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1276 */ { UD_Ircr, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1277 */ { UD_Ircr, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1278 */ { UD_Ircr, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1279 */ { UD_Irol, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1280 */ { UD_Irol, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1281 */ { UD_Irol, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1282 */ { UD_Irol, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1283 */ { UD_Irol, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1284 */ { UD_Irol, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1285 */ { UD_Iror, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1286 */ { UD_Iror, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1287 */ { UD_Iror, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1288 */ { UD_Iror, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1289 */ { UD_Iror, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1290 */ { UD_Iror, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1291 */ { UD_Ircpps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1292 */ { UD_Ivrcpps, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1293 */ { UD_Ircpss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1294 */ { UD_Ivrcpss, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1295 */ { UD_Irdmsr, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1296 */ { UD_Irdpmc, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1297 */ { UD_Irdtsc, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1298 */ { UD_Irdtscp, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1299 */ { UD_Irepne, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1300 */ { UD_Irep, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1301 */ { UD_Iret, O_Iw, O_NONE, O_NONE, O_NONE, P_none },
  /* 1302 */ { UD_Iret, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1303 */ { UD_Iretf, O_Iw, O_NONE, O_NONE, O_NONE, P_none },
  /* 1304 */ { UD_Iretf, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1305 */ { UD_Irsm, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1306 */ { UD_Irsqrtps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1307 */ { UD_Ivrsqrtps, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1308 */ { UD_Irsqrtss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1309 */ { UD_Ivrsqrtss, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1310 */ { UD_Isahf, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1311 */ { UD_Isalc, O_NONE, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 1312 */ { UD_Isar, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1313 */ { UD_Isar, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1314 */ { UD_Isar, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1315 */ { UD_Isar, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1316 */ { UD_Isar, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1317 */ { UD_Isar, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1318 */ { UD_Ishl, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1319 */ { UD_Ishl, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1320 */ { UD_Ishl, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1321 */ { UD_Ishl, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1322 */ { UD_Ishl, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1323 */ { UD_Ishl, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1324 */ { UD_Ishl, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1325 */ { UD_Ishl, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1326 */ { UD_Ishl, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1327 */ { UD_Ishl, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1328 */ { UD_Ishl, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1329 */ { UD_Ishl, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1330 */ { UD_Ishr, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1331 */ { UD_Ishr, O_Eb, O_CL, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1332 */ { UD_Ishr, O_Ev, O_I1, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1333 */ { UD_Ishr, O_Eb, O_I1, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1334 */ { UD_Ishr, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1335 */ { UD_Ishr, O_Ev, O_CL, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1336 */ { UD_Isbb, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1337 */ { UD_Isbb, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1338 */ { UD_Isbb, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1339 */ { UD_Isbb, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1340 */ { UD_Isbb, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 1341 */ { UD_Isbb, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 1342 */ { UD_Isbb, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1343 */ { UD_Isbb, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1344 */ { UD_Isbb, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 1345 */ { UD_Isbb, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1346 */ { UD_Iscasb, O_NONE, O_NONE, O_NONE, O_NONE, P_strz },
  /* 1347 */ { UD_Iscasw, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw },
  /* 1348 */ { UD_Iscasd, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw },
  /* 1349 */ { UD_Iscasq, O_NONE, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw },
  /* 1350 */ { UD_Iseto, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1351 */ { UD_Isetno, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1352 */ { UD_Isetb, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1353 */ { UD_Isetae, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1354 */ { UD_Isetz, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1355 */ { UD_Isetnz, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1356 */ { UD_Isetbe, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1357 */ { UD_Iseta, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1358 */ { UD_Isets, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1359 */ { UD_Isetns, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1360 */ { UD_Isetp, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1361 */ { UD_Isetnp, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1362 */ { UD_Isetl, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1363 */ { UD_Isetge, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1364 */ { UD_Isetle, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1365 */ { UD_Isetg, O_Eb, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1366 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1367 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1368 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1369 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1370 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1371 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1372 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1373 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1374 */ { UD_Isgdt, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1375 */ { UD_Ishld, O_Ev, O_Gv, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1376 */ { UD_Ishld, O_Ev, O_Gv, O_CL, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1377 */ { UD_Ishrd, O_Ev, O_Gv, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1378 */ { UD_Ishrd, O_Ev, O_Gv, O_CL, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1379 */ { UD_Ishufpd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1380 */ { UD_Ivshufpd, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1381 */ { UD_Ishufps, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1382 */ { UD_Ivshufps, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1383 */ { UD_Isidt, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1384 */ { UD_Isldt, O_MwRv, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1385 */ { UD_Ismsw, O_MwRv, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1386 */ { UD_Ismsw, O_MwRv, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1387 */ { UD_Isqrtps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1388 */ { UD_Ivsqrtps, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1389 */ { UD_Isqrtpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1390 */ { UD_Ivsqrtpd, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1391 */ { UD_Isqrtsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1392 */ { UD_Ivsqrtsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1393 */ { UD_Isqrtss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1394 */ { UD_Ivsqrtss, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1395 */ { UD_Istc, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1396 */ { UD_Istd, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1397 */ { UD_Istgi, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1398 */ { UD_Isti, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1399 */ { UD_Iskinit, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1400 */ { UD_Istmxcsr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1401 */ { UD_Ivstmxcsr, O_Md, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1402 */ { UD_Istosb, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 1403 */ { UD_Istosw, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 1404 */ { UD_Istosd, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 1405 */ { UD_Istosq, O_NONE, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 1406 */ { UD_Istr, O_MwRv, O_NONE, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1407 */ { UD_Isub, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1408 */ { UD_Isub, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1409 */ { UD_Isub, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1410 */ { UD_Isub, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1411 */ { UD_Isub, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 1412 */ { UD_Isub, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 1413 */ { UD_Isub, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1414 */ { UD_Isub, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1415 */ { UD_Isub, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 1416 */ { UD_Isub, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1417 */ { UD_Isubpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1418 */ { UD_Ivsubpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1419 */ { UD_Isubps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1420 */ { UD_Ivsubps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1421 */ { UD_Isubsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1422 */ { UD_Ivsubsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1423 */ { UD_Isubss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1424 */ { UD_Ivsubss, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1425 */ { UD_Iswapgs, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1426 */ { UD_Isyscall, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1427 */ { UD_Isysenter, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1428 */ { UD_Isysenter, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1429 */ { UD_Isysexit, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1430 */ { UD_Isysexit, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1431 */ { UD_Isysret, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1432 */ { UD_Itest, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1433 */ { UD_Itest, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1434 */ { UD_Itest, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1435 */ { UD_Itest, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 1436 */ { UD_Itest, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 1437 */ { UD_Itest, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1438 */ { UD_Itest, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1439 */ { UD_Itest, O_Ev, O_Iz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1440 */ { UD_Iucomisd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1441 */ { UD_Ivucomisd, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1442 */ { UD_Iucomiss, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1443 */ { UD_Ivucomiss, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1444 */ { UD_Iud2, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1445 */ { UD_Iunpckhpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1446 */ { UD_Ivunpckhpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1447 */ { UD_Iunpckhps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1448 */ { UD_Ivunpckhps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1449 */ { UD_Iunpcklps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1450 */ { UD_Ivunpcklps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1451 */ { UD_Iunpcklpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1452 */ { UD_Ivunpcklpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1453 */ { UD_Iverr, O_Ew, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1454 */ { UD_Iverw, O_Ew, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1455 */ { UD_Ivmcall, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1456 */ { UD_Irdrand, O_R, O_NONE, O_NONE, O_NONE, P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1457 */ { UD_Ivmclear, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1458 */ { UD_Ivmxon, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1459 */ { UD_Ivmptrld, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1460 */ { UD_Ivmptrst, O_Mq, O_NONE, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1461 */ { UD_Ivmlaunch, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1462 */ { UD_Ivmresume, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1463 */ { UD_Ivmxoff, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1464 */ { UD_Ivmread, O_Ey, O_Gy, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1465 */ { UD_Ivmwrite, O_Gy, O_Ey, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1466 */ { UD_Ivmrun, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1467 */ { UD_Ivmmcall, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1468 */ { UD_Ivmload, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1469 */ { UD_Ivmsave, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1470 */ { UD_Iwait, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1471 */ { UD_Iwbinvd, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1472 */ { UD_Iwrmsr, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1473 */ { UD_Ixadd, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexx|P_rexb },
  /* 1474 */ { UD_Ixadd, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1475 */ { UD_Ixchg, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1476 */ { UD_Ixchg, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1477 */ { UD_Ixchg, O_R0v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1478 */ { UD_Ixchg, O_R1v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1479 */ { UD_Ixchg, O_R2v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1480 */ { UD_Ixchg, O_R3v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1481 */ { UD_Ixchg, O_R4v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1482 */ { UD_Ixchg, O_R5v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1483 */ { UD_Ixchg, O_R6v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1484 */ { UD_Ixchg, O_R7v, O_rAX, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1485 */ { UD_Ixgetbv, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1486 */ { UD_Ixlatb, O_NONE, O_NONE, O_NONE, O_NONE, P_rexw|P_seg },
  /* 1487 */ { UD_Ixor, O_Eb, O_Gb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1488 */ { UD_Ixor, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1489 */ { UD_Ixor, O_Gb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1490 */ { UD_Ixor, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1491 */ { UD_Ixor, O_AL, O_Ib, O_NONE, O_NONE, P_none },
  /* 1492 */ { UD_Ixor, O_rAX, O_sIz, O_NONE, O_NONE, P_oso|P_rexw },
  /* 1493 */ { UD_Ixor, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1494 */ { UD_Ixor, O_Ev, O_sIz, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1495 */ { UD_Ixor, O_Eb, O_Ib, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 1496 */ { UD_Ixor, O_Ev, O_sIb, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1497 */ { UD_Ixorpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1498 */ { UD_Ivxorpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1499 */ { UD_Ixorps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1500 */ { UD_Ivxorps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1501 */ { UD_Ixcryptecb, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1502 */ { UD_Ixcryptcbc, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1503 */ { UD_Ixcryptctr, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1504 */ { UD_Ixcryptcfb, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1505 */ { UD_Ixcryptofb, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1506 */ { UD_Ixrstor, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1507 */ { UD_Ixsave, O_M, O_NONE, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1508 */ { UD_Ixsetbv, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1509 */ { UD_Ixsha1, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1510 */ { UD_Ixsha256, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1511 */ { UD_Ixstore, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1512 */ { UD_Ipclmulqdq, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1513 */ { UD_Ivpclmulqdq, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1514 */ { UD_Igetsec, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1515 */ { UD_Imovdqa, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1516 */ { UD_Ivmovdqa, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1517 */ { UD_Imovdqa, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1518 */ { UD_Ivmovdqa, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1519 */ { UD_Imaskmovdqu, O_V, O_U, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1520 */ { UD_Ivmaskmovdqu, O_Vx, O_Ux, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1521 */ { UD_Imovdq2q, O_P, O_U, O_NONE, O_NONE, P_aso|P_rexb },
  /* 1522 */ { UD_Imovdqu, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1523 */ { UD_Ivmovdqu, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1524 */ { UD_Imovdqu, O_W, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1525 */ { UD_Ivmovdqu, O_Wx, O_Vx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1526 */ { UD_Imovq2dq, O_V, O_N, O_NONE, O_NONE, P_aso|P_rexr },
  /* 1527 */ { UD_Ipaddq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1528 */ { UD_Ipaddq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1529 */ { UD_Ivpaddq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1530 */ { UD_Ipsubq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1531 */ { UD_Ivpsubq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1532 */ { UD_Ipsubq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1533 */ { UD_Ipmuludq, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1534 */ { UD_Ipmuludq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1535 */ { UD_Ipshufhw, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1536 */ { UD_Ivpshufhw, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1537 */ { UD_Ipshuflw, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1538 */ { UD_Ivpshuflw, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1539 */ { UD_Ipshufd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1540 */ { UD_Ivpshufd, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1541 */ { UD_Ipslldq, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1542 */ { UD_Ivpslldq, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1543 */ { UD_Ipsrldq, O_U, O_Ib, O_NONE, O_NONE, P_rexb },
  /* 1544 */ { UD_Ivpsrldq, O_Hx, O_Ux, O_Ib, O_NONE, P_rexb },
  /* 1545 */ { UD_Ipunpckhqdq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1546 */ { UD_Ivpunpckhqdq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1547 */ { UD_Ipunpcklqdq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1548 */ { UD_Ivpunpcklqdq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1549 */ { UD_Ihaddpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1550 */ { UD_Ivhaddpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1551 */ { UD_Ihaddps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1552 */ { UD_Ivhaddps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1553 */ { UD_Ihsubpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1554 */ { UD_Ivhsubpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1555 */ { UD_Ihsubps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1556 */ { UD_Ivhsubps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1557 */ { UD_Iinsertps, O_V, O_Md, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1558 */ { UD_Ivinsertps, O_Vx, O_Hx, O_Md, O_Ib, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1559 */ { UD_Ilddqu, O_V, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1560 */ { UD_Ivlddqu, O_Vx, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1561 */ { UD_Imovddup, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1562 */ { UD_Ivmovddup, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1563 */ { UD_Imovddup, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1564 */ { UD_Ivmovddup, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1565 */ { UD_Imovshdup, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1566 */ { UD_Ivmovshdup, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1567 */ { UD_Imovshdup, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1568 */ { UD_Ivmovshdup, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1569 */ { UD_Imovsldup, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1570 */ { UD_Ivmovsldup, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1571 */ { UD_Imovsldup, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1572 */ { UD_Ivmovsldup, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1573 */ { UD_Ipabsb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1574 */ { UD_Ipabsb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1575 */ { UD_Ivpabsb, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1576 */ { UD_Ipabsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1577 */ { UD_Ipabsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1578 */ { UD_Ivpabsw, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1579 */ { UD_Ipabsd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1580 */ { UD_Ipabsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1581 */ { UD_Ivpabsd, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1582 */ { UD_Ipshufb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1583 */ { UD_Ipshufb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1584 */ { UD_Ivpshufb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1585 */ { UD_Iphaddw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1586 */ { UD_Iphaddw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1587 */ { UD_Ivphaddw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1588 */ { UD_Iphaddd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1589 */ { UD_Iphaddd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1590 */ { UD_Ivphaddd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1591 */ { UD_Iphaddsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1592 */ { UD_Iphaddsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1593 */ { UD_Ivphaddsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1594 */ { UD_Ipmaddubsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1595 */ { UD_Ipmaddubsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1596 */ { UD_Ivpmaddubsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1597 */ { UD_Iphsubw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1598 */ { UD_Iphsubw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1599 */ { UD_Ivphsubw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1600 */ { UD_Iphsubd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1601 */ { UD_Iphsubd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1602 */ { UD_Ivphsubd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1603 */ { UD_Iphsubsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1604 */ { UD_Iphsubsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1605 */ { UD_Ivphsubsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1606 */ { UD_Ipsignb, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1607 */ { UD_Ipsignb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1608 */ { UD_Ivpsignb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1609 */ { UD_Ipsignd, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1610 */ { UD_Ipsignd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1611 */ { UD_Ivpsignd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1612 */ { UD_Ipsignw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1613 */ { UD_Ipsignw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1614 */ { UD_Ivpsignw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1615 */ { UD_Ipmulhrsw, O_P, O_Q, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1616 */ { UD_Ipmulhrsw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1617 */ { UD_Ivpmulhrsw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1618 */ { UD_Ipalignr, O_P, O_Q, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1619 */ { UD_Ipalignr, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1620 */ { UD_Ivpalignr, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1621 */ { UD_Ipblendvb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1622 */ { UD_Ipmuldq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1623 */ { UD_Ivpmuldq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1624 */ { UD_Ipminsb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1625 */ { UD_Ivpminsb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1626 */ { UD_Ipminsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1627 */ { UD_Ivpminsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1628 */ { UD_Ipminuw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1629 */ { UD_Ivpminuw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1630 */ { UD_Ipminud, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1631 */ { UD_Ivpminud, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1632 */ { UD_Ipmaxsb, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1633 */ { UD_Ivpmaxsb, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1634 */ { UD_Ipmaxsd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1635 */ { UD_Ivpmaxsd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1636 */ { UD_Ipmaxud, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1637 */ { UD_Ivpmaxud, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1638 */ { UD_Ipmaxuw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1639 */ { UD_Ivpmaxuw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1640 */ { UD_Ipmulld, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1641 */ { UD_Ivpmulld, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1642 */ { UD_Iphminposuw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1643 */ { UD_Ivphminposuw, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1644 */ { UD_Iroundps, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1645 */ { UD_Ivroundps, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1646 */ { UD_Iroundpd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1647 */ { UD_Ivroundpd, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1648 */ { UD_Iroundss, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1649 */ { UD_Ivroundss, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1650 */ { UD_Iroundsd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1651 */ { UD_Ivroundsd, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1652 */ { UD_Iblendpd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1653 */ { UD_Ivblendpd, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1654 */ { UD_Iblendps, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1655 */ { UD_Ivblendps, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1656 */ { UD_Iblendvpd, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1657 */ { UD_Iblendvps, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1658 */ { UD_Ibound, O_Gv, O_M, O_NONE, O_NONE, P_aso|P_oso },
  /* 1659 */ { UD_Ibsf, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1660 */ { UD_Ibsr, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1661 */ { UD_Ibswap, O_R0y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1662 */ { UD_Ibswap, O_R1y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1663 */ { UD_Ibswap, O_R2y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1664 */ { UD_Ibswap, O_R3y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1665 */ { UD_Ibswap, O_R4y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1666 */ { UD_Ibswap, O_R5y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1667 */ { UD_Ibswap, O_R6y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1668 */ { UD_Ibswap, O_R7y, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 1669 */ { UD_Ibt, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1670 */ { UD_Ibt, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1671 */ { UD_Ibtc, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1672 */ { UD_Ibtc, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1673 */ { UD_Ibtr, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1674 */ { UD_Ibtr, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1675 */ { UD_Ibts, O_Ev, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1676 */ { UD_Ibts, O_Ev, O_Ib, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1677 */ { UD_Ipblendw, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1678 */ { UD_Ivpblendw, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1679 */ { UD_Impsadbw, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1680 */ { UD_Ivmpsadbw, O_Vx, O_Hx, O_Wx, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1681 */ { UD_Imovntdqa, O_V, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1682 */ { UD_Ivmovntdqa, O_Vx, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb|P_vexl },
  /* 1683 */ { UD_Ipackusdw, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1684 */ { UD_Ivpackusdw, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb|P_vexl },
  /* 1685 */ { UD_Ipmovsxbw, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1686 */ { UD_Ivpmovsxbw, O_Vx, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1687 */ { UD_Ipmovsxbd, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1688 */ { UD_Ivpmovsxbd, O_Vx, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1689 */ { UD_Ipmovsxbq, O_V, O_MwU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1690 */ { UD_Ivpmovsxbq, O_Vx, O_MwU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1691 */ { UD_Ipmovsxwd, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1692 */ { UD_Ivpmovsxwd, O_Vx, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1693 */ { UD_Ipmovsxwq, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1694 */ { UD_Ivpmovsxwq, O_Vx, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1695 */ { UD_Ipmovsxdq, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1696 */ { UD_Ipmovzxbw, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1697 */ { UD_Ivpmovzxbw, O_Vx, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1698 */ { UD_Ipmovzxbd, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1699 */ { UD_Ivpmovzxbd, O_Vx, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1700 */ { UD_Ipmovzxbq, O_V, O_MwU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1701 */ { UD_Ivpmovzxbq, O_Vx, O_MwU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1702 */ { UD_Ipmovzxwd, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1703 */ { UD_Ivpmovzxwd, O_Vx, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1704 */ { UD_Ipmovzxwq, O_V, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1705 */ { UD_Ivpmovzxwq, O_Vx, O_MdU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1706 */ { UD_Ipmovzxdq, O_V, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1707 */ { UD_Ivpmovzxdq, O_Vx, O_MqU, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1708 */ { UD_Ipcmpeqq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1709 */ { UD_Ivpcmpeqq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1710 */ { UD_Ipopcnt, O_Gv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1711 */ { UD_Iptest, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1712 */ { UD_Ivptest, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb|P_vexl },
  /* 1713 */ { UD_Ipcmpestri, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1714 */ { UD_Ivpcmpestri, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1715 */ { UD_Ipcmpestrm, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1716 */ { UD_Ivpcmpestrm, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1717 */ { UD_Ipcmpgtq, O_V, O_W, O_NONE, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1718 */ { UD_Ivpcmpgtq, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1719 */ { UD_Ipcmpistri, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1720 */ { UD_Ivpcmpistri, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1721 */ { UD_Ipcmpistrm, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1722 */ { UD_Ivpcmpistrm, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1723 */ { UD_Imovbe, O_Gv, O_Mv, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1724 */ { UD_Imovbe, O_Mv, O_Gv, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1725 */ { UD_Icrc32, O_Gy, O_Eb, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1726 */ { UD_Icrc32, O_Gy, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 1727 */ { UD_Ivbroadcastss, O_V, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1728 */ { UD_Ivbroadcastsd, O_Vqq, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1729 */ { UD_Ivextractf128, O_Wdq, O_Vqq, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1730 */ { UD_Ivinsertf128, O_Vqq, O_Hqq, O_Wdq, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1731 */ { UD_Ivmaskmovps, O_V, O_H, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1732 */ { UD_Ivmaskmovps, O_M, O_H, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1733 */ { UD_Ivmaskmovpd, O_V, O_H, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1734 */ { UD_Ivmaskmovpd, O_M, O_H, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1735 */ { UD_Ivpermilpd, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1736 */ { UD_Ivpermilpd, O_V, O_W, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1737 */ { UD_Ivpermilps, O_Vx, O_Hx, O_Wx, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1738 */ { UD_Ivpermilps, O_Vx, O_Wx, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1739 */ { UD_Ivperm2f128, O_Vqq, O_Hqq, O_Wqq, O_Ib, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1740 */ { UD_Ivtestps, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1741 */ { UD_Ivtestpd, O_Vx, O_Wx, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1742 */ { UD_Ivzeroupper, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1743 */ { UD_Ivzeroall, O_NONE, O_NONE, O_NONE, O_NONE, P_none },
  /* 1744 */ { UD_Ivblendvpd, O_Vx, O_Hx, O_Wx, O_Lx, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1745 */ { UD_Ivblendvps, O_Vx, O_Hx, O_Wx, O_Lx, P_aso|P_rexr|P_rexx|P_rexb|P_vexl },
  /* 1746 */ { UD_Ivmovsd, O_V, O_H, O_U, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1747 */ { UD_Ivmovsd, O_V, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1748 */ { UD_Ivmovsd, O_U, O_H, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1749 */ { UD_Ivmovsd, O_Mq, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1750 */ { UD_Ivmovss, O_V, O_H, O_U, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1751 */ { UD_Ivmovss, O_V, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1752 */ { UD_Ivmovss, O_U, O_H, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1753 */ { UD_Ivmovss, O_Md, O_V, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1754 */ { UD_Ivpblendvb, O_V, O_H, O_W, O_L, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1755 */ { UD_Ivpsllw, O_V, O_H, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1756 */ { UD_Ivpsllw, O_H, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1757 */ { UD_Ivpslld, O_V, O_H, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1758 */ { UD_Ivpslld, O_H, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1759 */ { UD_Ivpsllq, O_V, O_H, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1760 */ { UD_Ivpsllq, O_H, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
};


const char* ud_mnemonics_str[] = {
    "aaa",
    "aad",
    "aam",
    "aas",
    "adc",
    "add",
    "addpd",
    "addps",
    "addsd",
    "addss",
    "addsubpd",
    "addsubps",
    "aesdec",
    "aesdeclast",
    "aesenc",
    "aesenclast",
    "aesimc",
    "aeskeygenassist",
    "and",
    "andnpd",
    "andnps",
    "andpd",
    "andps",
    "arpl",
    "blendpd",
    "blendps",
    "blendvpd",
    "blendvps",
    "bound",
    "bsf",
    "bsr",
    "bswap",
    "bt",
    "btc",
    "btr",
    "bts",
    "call",
    "cbw",
    "cdq",
    "cdqe",
    "clc",
    "cld",
    "clflush",
    "clgi",
    "cli",
    "clts",
    "cmc",
    "cmova",
    "cmovae",
    "cmovb",
    "cmovbe",
    "cmovg",
    "cmovge",
    "cmovl",
    "cmovle",
    "cmovno",
    "cmovnp",
    "cmovns",
    "cmovnz",
    "cmovo",
    "cmovp",
    "cmovs",
    "cmovz",
    "cmp",
    "cmppd",
    "cmpps",
    "cmpsb",
    "cmpsd",
    "cmpsq",
    "cmpss",
    "cmpsw",
    "cmpxchg",
    "cmpxchg16b",
    "cmpxchg8b",
    "comisd",
    "comiss",
    "cpuid",
    "cqo",
    "crc32",
    "cvtdq2pd",
    "cvtdq2ps",
    "cvtpd2dq",
    "cvtpd2pi",
    "cvtpd2ps",
    "cvtpi2pd",
    "cvtpi2ps",
    "cvtps2dq",
    "cvtps2pd",
    "cvtps2pi",
    "cvtsd2si",
    "cvtsd2ss",
    "cvtsi2sd",
    "cvtsi2ss",
    "cvtss2sd",
    "cvtss2si",
    "cvttpd2dq",
    "cvttpd2pi",
    "cvttps2dq",
    "cvttps2pi",
    "cvttsd2si",
    "cvttss2si",
    "cwd",
    "cwde",
    "daa",
    "das",
    "dec",
    "div",
    "divpd",
    "divps",
    "divsd",
    "divss",
    "dppd",
    "dpps",
    "emms",
    "enter",
    "extractps",
    "f2xm1",
    "fabs",
    "fadd",
    "faddp",
    "fbld",
    "fbstp",
    "fchs",
    "fclex",
    "fcmovb",
    "fcmovbe",
    "fcmove",
    "fcmovnb",
    "fcmovnbe",
    "fcmovne",
    "fcmovnu",
    "fcmovu",
    "fcom",
    "fcom2",
    "fcomi",
    "fcomip",
    "fcomp",
    "fcomp3",
    "fcomp5",
    "fcompp",
    "fcos",
    "fdecstp",
    "fdiv",
    "fdivp",
    "fdivr",
    "fdivrp",
    "femms",
    "ffree",
    "ffreep",
    "fiadd",
    "ficom",
    "ficomp",
    "fidiv",
    "fidivr",
    "fild",
    "fimul",
    "fincstp",
    "fist",
    "fistp",
    "fisttp",
    "fisub",
    "fisubr",
    "fld",
    "fld1",
    "fldcw",
    "fldenv",
    "fldl2e",
    "fldl2t",
    "fldlg2",
    "fldln2",
    "fldpi",
    "fldz",
    "fmul",
    "fmulp",
    "fndisi",
    "fneni",
    "fninit",
    "fnop",
    "fnsave",
    "fnsetpm",
    "fnstcw",
    "fnstenv",
    "fnstsw",
    "fpatan",
    "fprem",
    "fprem1",
    "fptan",
    "frndint",
    "frstor",
    "frstpm",
    "fscale",
    "fsin",
    "fsincos",
    "fsqrt",
    "fst",
    "fstp",
    "fstp1",
    "fstp8",
    "fstp9",
    "fsub",
    "fsubp",
    "fsubr",
    "fsubrp",
    "ftst",
    "fucom",
    "fucomi",
    "fucomip",
    "fucomp",
    "fucompp",
    "fxam",
    "fxch",
    "fxch4",
    "fxch7",
    "fxrstor",
    "fxsave",
    "fxtract",
    "fyl2x",
    "fyl2xp1",
    "getsec",
    "haddpd",
    "haddps",
    "hlt",
    "hsubpd",
    "hsubps",
    "idiv",
    "imul",
    "in",
    "inc",
    "insb",
    "insd",
    "insertps",
    "insw",
    "int",
    "int1",
    "int3",
    "into",
    "invd",
    "invept",
    "invlpg",
    "invlpga",
    "invvpid",
    "iretd",
    "iretq",
    "iretw",
    "ja",
    "jae",
    "jb",
    "jbe",
    "jcxz",
    "jecxz",
    "jg",
    "jge",
    "jl",
    "jle",
    "jmp",
    "jno",
    "jnp",
    "jns",
    "jnz",
    "jo",
    "jp",
    "jrcxz",
    "js",
    "jz",
    "lahf",
    "lar",
    "lddqu",
    "ldmxcsr",
    "lds",
    "lea",
    "leave",
    "les",
    "lfence",
    "lfs",
    "lgdt",
    "lgs",
    "lidt",
    "lldt",
    "lmsw",
    "lock",
    "lodsb",
    "lodsd",
    "lodsq",
    "lodsw",
    "loop",
    "loope",
    "loopne",
    "lsl",
    "lss",
    "ltr",
    "maskmovdqu",
    "maskmovq",
    "maxpd",
    "maxps",
    "maxsd",
    "maxss",
    "mfence",
    "minpd",
    "minps",
    "minsd",
    "minss",
    "monitor",
    "montmul",
    "mov",
    "movapd",
    "movaps",
    "movbe",
    "movd",
    "movddup",
    "movdq2q",
    "movdqa",
    "movdqu",
    "movhlps",
    "movhpd",
    "movhps",
    "movlhps",
    "movlpd",
    "movlps",
    "movmskpd",
    "movmskps",
    "movntdq",
    "movntdqa",
    "movnti",
    "movntpd",
    "movntps",
    "movntq",
    "movq",
    "movq2dq",
    "movsb",
    "movsd",
    "movshdup",
    "movsldup",
    "movsq",
    "movss",
    "movsw",
    "movsx",
    "movsxd",
    "movupd",
    "movups",
    "movzx",
    "mpsadbw",
    "mul",
    "mulpd",
    "mulps",
    "mulsd",
    "mulss",
    "mwait",
    "neg",
    "nop",
    "not",
    "or",
    "orpd",
    "orps",
    "out",
    "outsb",
    "outsd",
    "outsw",
    "pabsb",
    "pabsd",
    "pabsw",
    "packssdw",
    "packsswb",
    "packusdw",
    "packuswb",
    "paddb",
    "paddd",
    "paddq",
    "paddsb",
    "paddsw",
    "paddusb",
    "paddusw",
    "paddw",
    "palignr",
    "pand",
    "pandn",
    "pavgb",
    "pavgusb",
    "pavgw",
    "pblendvb",
    "pblendw",
    "pclmulqdq",
    "pcmpeqb",
    "pcmpeqd",
    "pcmpeqq",
    "pcmpeqw",
    "pcmpestri",
    "pcmpestrm",
    "pcmpgtb",
    "pcmpgtd",
    "pcmpgtq",
    "pcmpgtw",
    "pcmpistri",
    "pcmpistrm",
    "pextrb",
    "pextrd",
    "pextrq",
    "pextrw",
    "pf2id",
    "pf2iw",
    "pfacc",
    "pfadd",
    "pfcmpeq",
    "pfcmpge",
    "pfcmpgt",
    "pfmax",
    "pfmin",
    "pfmul",
    "pfnacc",
    "pfpnacc",
    "pfrcp",
    "pfrcpit1",
    "pfrcpit2",
    "pfrsqit1",
    "pfrsqrt",
    "pfsub",
    "pfsubr",
    "phaddd",
    "phaddsw",
    "phaddw",
    "phminposuw",
    "phsubd",
    "phsubsw",
    "phsubw",
    "pi2fd",
    "pi2fw",
    "pinsrb",
    "pinsrd",
    "pinsrq",
    "pinsrw",
    "pmaddubsw",
    "pmaddwd",
    "pmaxsb",
    "pmaxsd",
    "pmaxsw",
    "pmaxub",
    "pmaxud",
    "pmaxuw",
    "pminsb",
    "pminsd",
    "pminsw",
    "pminub",
    "pminud",
    "pminuw",
    "pmovmskb",
    "pmovsxbd",
    "pmovsxbq",
    "pmovsxbw",
    "pmovsxdq",
    "pmovsxwd",
    "pmovsxwq",
    "pmovzxbd",
    "pmovzxbq",
    "pmovzxbw",
    "pmovzxdq",
    "pmovzxwd",
    "pmovzxwq",
    "pmuldq",
    "pmulhrsw",
    "pmulhrw",
    "pmulhuw",
    "pmulhw",
    "pmulld",
    "pmullw",
    "pmuludq",
    "pop",
    "popa",
    "popad",
    "popcnt",
    "popfd",
    "popfq",
    "popfw",
    "por",
    "prefetch",
    "prefetchnta",
    "prefetcht0",
    "prefetcht1",
    "prefetcht2",
    "psadbw",
    "pshufb",
    "pshufd",
    "pshufhw",
    "pshuflw",
    "pshufw",
    "psignb",
    "psignd",
    "psignw",
    "pslld",
    "pslldq",
    "psllq",
    "psllw",
    "psrad",
    "psraw",
    "psrld",
    "psrldq",
    "psrlq",
    "psrlw",
    "psubb",
    "psubd",
    "psubq",
    "psubsb",
    "psubsw",
    "psubusb",
    "psubusw",
    "psubw",
    "pswapd",
    "ptest",
    "punpckhbw",
    "punpckhdq",
    "punpckhqdq",
    "punpckhwd",
    "punpcklbw",
    "punpckldq",
    "punpcklqdq",
    "punpcklwd",
    "push",
    "pusha",
    "pushad",
    "pushfd",
    "pushfq",
    "pushfw",
    "pxor",
    "rcl",
    "rcpps",
    "rcpss",
    "rcr",
    "rdmsr",
    "rdpmc",
    "rdrand",
    "rdtsc",
    "rdtscp",
    "rep",
    "repne",
    "ret",
    "retf",
    "rol",
    "ror",
    "roundpd",
    "roundps",
    "roundsd",
    "roundss",
    "rsm",
    "rsqrtps",
    "rsqrtss",
    "sahf",
    "salc",
    "sar",
    "sbb",
    "scasb",
    "scasd",
    "scasq",
    "scasw",
    "seta",
    "setae",
    "setb",
    "setbe",
    "setg",
    "setge",
    "setl",
    "setle",
    "setno",
    "setnp",
    "setns",
    "setnz",
    "seto",
    "setp",
    "sets",
    "setz",
    "sfence",
    "sgdt",
    "shl",
    "shld",
    "shr",
    "shrd",
    "shufpd",
    "shufps",
    "sidt",
    "skinit",
    "sldt",
    "smsw",
    "sqrtpd",
    "sqrtps",
    "sqrtsd",
    "sqrtss",
    "stc",
    "std",
    "stgi",
    "sti",
    "stmxcsr",
    "stosb",
    "stosd",
    "stosq",
    "stosw",
    "str",
    "sub",
    "subpd",
    "subps",
    "subsd",
    "subss",
    "swapgs",
    "syscall",
    "sysenter",
    "sysexit",
    "sysret",
    "test",
    "ucomisd",
    "ucomiss",
    "ud2",
    "unpckhpd",
    "unpckhps",
    "unpcklpd",
    "unpcklps",
    "vaddpd",
    "vaddps",
    "vaddsd",
    "vaddss",
    "vaddsubpd",
    "vaddsubps",
    "vaesdec",
    "vaesdeclast",
    "vaesenc",
    "vaesenclast",
    "vaesimc",
    "vaeskeygenassist",
    "vandnpd",
    "vandnps",
    "vandpd",
    "vandps",
    "vblendpd",
    "vblendps",
    "vblendvpd",
    "vblendvps",
    "vbroadcastsd",
    "vbroadcastss",
    "vcmppd",
    "vcmpps",
    "vcmpsd",
    "vcmpss",
    "vcomisd",
    "vcomiss",
    "vcvtdq2pd",
    "vcvtdq2ps",
    "vcvtpd2dq",
    "vcvtpd2ps",
    "vcvtps2dq",
    "vcvtps2pd",
    "vcvtsd2si",
    "vcvtsd2ss",
    "vcvtsi2sd",
    "vcvtsi2ss",
    "vcvtss2sd",
    "vcvtss2si",
    "vcvttpd2dq",
    "vcvttps2dq",
    "vcvttsd2si",
    "vcvttss2si",
    "vdivpd",
    "vdivps",
    "vdivsd",
    "vdivss",
    "vdppd",
    "vdpps",
    "verr",
    "verw",
    "vextractf128",
    "vextractps",
    "vhaddpd",
    "vhaddps",
    "vhsubpd",
    "vhsubps",
    "vinsertf128",
    "vinsertps",
    "vlddqu",
    "vmaskmovdqu",
    "vmaskmovpd",
    "vmaskmovps",
    "vmaxpd",
    "vmaxps",
    "vmaxsd",
    "vmaxss",
    "vmcall",
    "vmclear",
    "vminpd",
    "vminps",
    "vminsd",
    "vminss",
    "vmlaunch",
    "vmload",
    "vmmcall",
    "vmovapd",
    "vmovaps",
    "vmovd",
    "vmovddup",
    "vmovdqa",
    "vmovdqu",
    "vmovhlps",
    "vmovhpd",
    "vmovhps",
    "vmovlhps",
    "vmovlpd",
    "vmovlps",
    "vmovmskpd",
    "vmovmskps",
    "vmovntdq",
    "vmovntdqa",
    "vmovntpd",
    "vmovntps",
    "vmovq",
    "vmovsd",
    "vmovshdup",
    "vmovsldup",
    "vmovss",
    "vmovupd",
    "vmovups",
    "vmpsadbw",
    "vmptrld",
    "vmptrst",
    "vmread",
    "vmresume",
    "vmrun",
    "vmsave",
    "vmulpd",
    "vmulps",
    "vmulsd",
    "vmulss",
    "vmwrite",
    "vmxoff",
    "vmxon",
    "vorpd",
    "vorps",
    "vpabsb",
    "vpabsd",
    "vpabsw",
    "vpackssdw",
    "vpacksswb",
    "vpackusdw",
    "vpackuswb",
    "vpaddb",
    "vpaddd",
    "vpaddq",
    "vpaddsb",
    "vpaddsw",
    "vpaddusb",
    "vpaddusw",
    "vpaddw",
    "vpalignr",
    "vpand",
    "vpandn",
    "vpavgb",
    "vpavgw",
    "vpblendvb",
    "vpblendw",
    "vpclmulqdq",
    "vpcmpeqb",
    "vpcmpeqd",
    "vpcmpeqq",
    "vpcmpeqw",
    "vpcmpestri",
    "vpcmpestrm",
    "vpcmpgtb",
    "vpcmpgtd",
    "vpcmpgtq",
    "vpcmpgtw",
    "vpcmpistri",
    "vpcmpistrm",
    "vperm2f128",
    "vpermilpd",
    "vpermilps",
    "vpextrb",
    "vpextrd",
    "vpextrq",
    "vpextrw",
    "vphaddd",
    "vphaddsw",
    "vphaddw",
    "vphminposuw",
    "vphsubd",
    "vphsubsw",
    "vphsubw",
    "vpinsrb",
    "vpinsrd",
    "vpinsrq",
    "vpinsrw",
    "vpmaddubsw",
    "vpmaddwd",
    "vpmaxsb",
    "vpmaxsd",
    "vpmaxsw",
    "vpmaxub",
    "vpmaxud",
    "vpmaxuw",
    "vpminsb",
    "vpminsd",
    "vpminsw",
    "vpminub",
    "vpminud",
    "vpminuw",
    "vpmovmskb",
    "vpmovsxbd",
    "vpmovsxbq",
    "vpmovsxbw",
    "vpmovsxwd",
    "vpmovsxwq",
    "vpmovzxbd",
    "vpmovzxbq",
    "vpmovzxbw",
    "vpmovzxdq",
    "vpmovzxwd",
    "vpmovzxwq",
    "vpmuldq",
    "vpmulhrsw",
    "vpmulhuw",
    "vpmulhw",
    "vpmulld",
    "vpmullw",
    "vpor",
    "vpsadbw",
    "vpshufb",
    "vpshufd",
    "vpshufhw",
    "vpshuflw",
    "vpsignb",
    "vpsignd",
    "vpsignw",
    "vpslld",
    "vpslldq",
    "vpsllq",
    "vpsllw",
    "vpsrad",
    "vpsraw",
    "vpsrld",
    "vpsrldq",
    "vpsrlq",
    "vpsrlw",
    "vpsubb",
    "vpsubd",
    "vpsubq",
    "vpsubsb",
    "vpsubsw",
    "vpsubusb",
    "vpsubusw",
    "vpsubw",
    "vptest",
    "vpunpckhbw",
    "vpunpckhdq",
    "vpunpckhqdq",
    "vpunpckhwd",
    "vpunpcklbw",
    "vpunpckldq",
    "vpunpcklqdq",
    "vpunpcklwd",
    "vpxor",
    "vrcpps",
    "vrcpss",
    "vroundpd",
    "vroundps",
    "vroundsd",
    "vroundss",
    "vrsqrtps",
    "vrsqrtss",
    "vshufpd",
    "vshufps",
    "vsqrtpd",
    "vsqrtps",
    "vsqrtsd",
    "vsqrtss",
    "vstmxcsr",
    "vsubpd",
    "vsubps",
    "vsubsd",
    "vsubss",
    "vtestpd",
    "vtestps",
    "vucomisd",
    "vucomiss",
    "vunpckhpd",
    "vunpckhps",
    "vunpcklpd",
    "vunpcklps",
    "vxorpd",
    "vxorps",
    "vzeroall",
    "vzeroupper",
    "wait",
    "wbinvd",
    "wrmsr",
    "xadd",
    "xchg",
    "xcryptcbc",
    "xcryptcfb",
    "xcryptctr",
    "xcryptecb",
    "xcryptofb",
    "xgetbv",
    "xlatb",
    "xor",
    "xorpd",
    "xorps",
    "xrstor",
    "xsave",
    "xsetbv",
    "xsha1",
    "xsha256",
    "xstore",
    "invalid",
    "3dnow",
    "none",
    "db",
    "pause"
};

```

`deps/extra/udis86/libudis86/itab.h`:

```h
#ifndef UD_ITAB_H
#define UD_ITAB_H

/* itab.h -- generated by udis86:scripts/ud_itab.py, do no edit */

/* ud_table_type -- lookup table types (see decode.c) */
enum ud_table_type {
    UD_TAB__OPC_VEX,
    UD_TAB__OPC_TABLE,
    UD_TAB__OPC_X87,
    UD_TAB__OPC_MOD,
    UD_TAB__OPC_RM,
    UD_TAB__OPC_OSIZE,
    UD_TAB__OPC_MODE,
    UD_TAB__OPC_VEX_L,
    UD_TAB__OPC_3DNOW,
    UD_TAB__OPC_REG,
    UD_TAB__OPC_ASIZE,
    UD_TAB__OPC_VEX_W,
    UD_TAB__OPC_SSE,
    UD_TAB__OPC_VENDOR
};

/* ud_mnemonic -- mnemonic constants */
enum ud_mnemonic_code {
    UD_Iaaa,
    UD_Iaad,
    UD_Iaam,
    UD_Iaas,
    UD_Iadc,
    UD_Iadd,
    UD_Iaddpd,
    UD_Iaddps,
    UD_Iaddsd,
    UD_Iaddss,
    UD_Iaddsubpd,
    UD_Iaddsubps,
    UD_Iaesdec,
    UD_Iaesdeclast,
    UD_Iaesenc,
    UD_Iaesenclast,
    UD_Iaesimc,
    UD_Iaeskeygenassist,
    UD_Iand,
    UD_Iandnpd,
    UD_Iandnps,
    UD_Iandpd,
    UD_Iandps,
    UD_Iarpl,
    UD_Iblendpd,
    UD_Iblendps,
    UD_Iblendvpd,
    UD_Iblendvps,
    UD_Ibound,
    UD_Ibsf,
    UD_Ibsr,
    UD_Ibswap,
    UD_Ibt,
    UD_Ibtc,
    UD_Ibtr,
    UD_Ibts,
    UD_Icall,
    UD_Icbw,
    UD_Icdq,
    UD_Icdqe,
    UD_Iclc,
    UD_Icld,
    UD_Iclflush,
    UD_Iclgi,
    UD_Icli,
    UD_Iclts,
    UD_Icmc,
    UD_Icmova,
    UD_Icmovae,
    UD_Icmovb,
    UD_Icmovbe,
    UD_Icmovg,
    UD_Icmovge,
    UD_Icmovl,
    UD_Icmovle,
    UD_Icmovno,
    UD_Icmovnp,
    UD_Icmovns,
    UD_Icmovnz,
    UD_Icmovo,
    UD_Icmovp,
    UD_Icmovs,
    UD_Icmovz,
    UD_Icmp,
    UD_Icmppd,
    UD_Icmpps,
    UD_Icmpsb,
    UD_Icmpsd,
    UD_Icmpsq,
    UD_Icmpss,
    UD_Icmpsw,
    UD_Icmpxchg,
    UD_Icmpxchg16b,
    UD_Icmpxchg8b,
    UD_Icomisd,
    UD_Icomiss,
    UD_Icpuid,
    UD_Icqo,
    UD_Icrc32,
    UD_Icvtdq2pd,
    UD_Icvtdq2ps,
    UD_Icvtpd2dq,
    UD_Icvtpd2pi,
    UD_Icvtpd2ps,
    UD_Icvtpi2pd,
    UD_Icvtpi2ps,
    UD_Icvtps2dq,
    UD_Icvtps2pd,
    UD_Icvtps2pi,
    UD_Icvtsd2si,
    UD_Icvtsd2ss,
    UD_Icvtsi2sd,
    UD_Icvtsi2ss,
    UD_Icvtss2sd,
    UD_Icvtss2si,
    UD_Icvttpd2dq,
    UD_Icvttpd2pi,
    UD_Icvttps2dq,
    UD_Icvttps2pi,
    UD_Icvttsd2si,
    UD_Icvttss2si,
    UD_Icwd,
    UD_Icwde,
    UD_Idaa,
    UD_Idas,
    UD_Idec,
    UD_Idiv,
    UD_Idivpd,
    UD_Idivps,
    UD_Idivsd,
    UD_Idivss,
    UD_Idppd,
    UD_Idpps,
    UD_Iemms,
    UD_Ienter,
    UD_Iextractps,
    UD_If2xm1,
    UD_Ifabs,
    UD_Ifadd,
    UD_Ifaddp,
    UD_Ifbld,
    UD_Ifbstp,
    UD_Ifchs,
    UD_Ifclex,
    UD_Ifcmovb,
    UD_Ifcmovbe,
    UD_Ifcmove,
    UD_Ifcmovnb,
    UD_Ifcmovnbe,
    UD_Ifcmovne,
    UD_Ifcmovnu,
    UD_Ifcmovu,
    UD_Ifcom,
    UD_Ifcom2,
    UD_Ifcomi,
    UD_Ifcomip,
    UD_Ifcomp,
    UD_Ifcomp3,
    UD_Ifcomp5,
    UD_Ifcompp,
    UD_Ifcos,
    UD_Ifdecstp,
    UD_Ifdiv,
    UD_Ifdivp,
    UD_Ifdivr,
    UD_Ifdivrp,
    UD_Ifemms,
    UD_Iffree,
    UD_Iffreep,
    UD_Ifiadd,
    UD_Ificom,
    UD_Ificomp,
    UD_Ifidiv,
    UD_Ifidivr,
    UD_Ifild,
    UD_Ifimul,
    UD_Ifincstp,
    UD_Ifist,
    UD_Ifistp,
    UD_Ifisttp,
    UD_Ifisub,
    UD_Ifisubr,
    UD_Ifld,
    UD_Ifld1,
    UD_Ifldcw,
    UD_Ifldenv,
    UD_Ifldl2e,
    UD_Ifldl2t,
    UD_Ifldlg2,
    UD_Ifldln2,
    UD_Ifldpi,
    UD_Ifldz,
    UD_Ifmul,
    UD_Ifmulp,
    UD_Ifndisi,
    UD_Ifneni,
    UD_Ifninit,
    UD_Ifnop,
    UD_Ifnsave,
    UD_Ifnsetpm,
    UD_Ifnstcw,
    UD_Ifnstenv,
    UD_Ifnstsw,
    UD_Ifpatan,
    UD_Ifprem,
    UD_Ifprem1,
    UD_Ifptan,
    UD_Ifrndint,
    UD_Ifrstor,
    UD_Ifrstpm,
    UD_Ifscale,
    UD_Ifsin,
    UD_Ifsincos,
    UD_Ifsqrt,
    UD_Ifst,
    UD_Ifstp,
    UD_Ifstp1,
    UD_Ifstp8,
    UD_Ifstp9,
    UD_Ifsub,
    UD_Ifsubp,
    UD_Ifsubr,
    UD_Ifsubrp,
    UD_Iftst,
    UD_Ifucom,
    UD_Ifucomi,
    UD_Ifucomip,
    UD_Ifucomp,
    UD_Ifucompp,
    UD_Ifxam,
    UD_Ifxch,
    UD_Ifxch4,
    UD_Ifxch7,
    UD_Ifxrstor,
    UD_Ifxsave,
    UD_Ifxtract,
    UD_Ifyl2x,
    UD_Ifyl2xp1,
    UD_Igetsec,
    UD_Ihaddpd,
    UD_Ihaddps,
    UD_Ihlt,
    UD_Ihsubpd,
    UD_Ihsubps,
    UD_Iidiv,
    UD_Iimul,
    UD_Iin,
    UD_Iinc,
    UD_Iinsb,
    UD_Iinsd,
    UD_Iinsertps,
    UD_Iinsw,
    UD_Iint,
    UD_Iint1,
    UD_Iint3,
    UD_Iinto,
    UD_Iinvd,
    UD_Iinvept,
    UD_Iinvlpg,
    UD_Iinvlpga,
    UD_Iinvvpid,
    UD_Iiretd,
    UD_Iiretq,
    UD_Iiretw,
    UD_Ija,
    UD_Ijae,
    UD_Ijb,
    UD_Ijbe,
    UD_Ijcxz,
    UD_Ijecxz,
    UD_Ijg,
    UD_Ijge,
    UD_Ijl,
    UD_Ijle,
    UD_Ijmp,
    UD_Ijno,
    UD_Ijnp,
    UD_Ijns,
    UD_Ijnz,
    UD_Ijo,
    UD_Ijp,
    UD_Ijrcxz,
    UD_Ijs,
    UD_Ijz,
    UD_Ilahf,
    UD_Ilar,
    UD_Ilddqu,
    UD_Ildmxcsr,
    UD_Ilds,
    UD_Ilea,
    UD_Ileave,
    UD_Iles,
    UD_Ilfence,
    UD_Ilfs,
    UD_Ilgdt,
    UD_Ilgs,
    UD_Ilidt,
    UD_Illdt,
    UD_Ilmsw,
    UD_Ilock,
    UD_Ilodsb,
    UD_Ilodsd,
    UD_Ilodsq,
    UD_Ilodsw,
    UD_Iloop,
    UD_Iloope,
    UD_Iloopne,
    UD_Ilsl,
    UD_Ilss,
    UD_Iltr,
    UD_Imaskmovdqu,
    UD_Imaskmovq,
    UD_Imaxpd,
    UD_Imaxps,
    UD_Imaxsd,
    UD_Imaxss,
    UD_Imfence,
    UD_Iminpd,
    UD_Iminps,
    UD_Iminsd,
    UD_Iminss,
    UD_Imonitor,
    UD_Imontmul,
    UD_Imov,
    UD_Imovapd,
    UD_Imovaps,
    UD_Imovbe,
    UD_Imovd,
    UD_Imovddup,
    UD_Imovdq2q,
    UD_Imovdqa,
    UD_Imovdqu,
    UD_Imovhlps,
    UD_Imovhpd,
    UD_Imovhps,
    UD_Imovlhps,
    UD_Imovlpd,
    UD_Imovlps,
    UD_Imovmskpd,
    UD_Imovmskps,
    UD_Imovntdq,
    UD_Imovntdqa,
    UD_Imovnti,
    UD_Imovntpd,
    UD_Imovntps,
    UD_Imovntq,
    UD_Imovq,
    UD_Imovq2dq,
    UD_Imovsb,
    UD_Imovsd,
    UD_Imovshdup,
    UD_Imovsldup,
    UD_Imovsq,
    UD_Imovss,
    UD_Imovsw,
    UD_Imovsx,
    UD_Imovsxd,
    UD_Imovupd,
    UD_Imovups,
    UD_Imovzx,
    UD_Impsadbw,
    UD_Imul,
    UD_Imulpd,
    UD_Imulps,
    UD_Imulsd,
    UD_Imulss,
    UD_Imwait,
    UD_Ineg,
    UD_Inop,
    UD_Inot,
    UD_Ior,
    UD_Iorpd,
    UD_Iorps,
    UD_Iout,
    UD_Ioutsb,
    UD_Ioutsd,
    UD_Ioutsw,
    UD_Ipabsb,
    UD_Ipabsd,
    UD_Ipabsw,
    UD_Ipackssdw,
    UD_Ipacksswb,
    UD_Ipackusdw,
    UD_Ipackuswb,
    UD_Ipaddb,
    UD_Ipaddd,
    UD_Ipaddq,
    UD_Ipaddsb,
    UD_Ipaddsw,
    UD_Ipaddusb,
    UD_Ipaddusw,
    UD_Ipaddw,
    UD_Ipalignr,
    UD_Ipand,
    UD_Ipandn,
    UD_Ipavgb,
    UD_Ipavgusb,
    UD_Ipavgw,
    UD_Ipblendvb,
    UD_Ipblendw,
    UD_Ipclmulqdq,
    UD_Ipcmpeqb,
    UD_Ipcmpeqd,
    UD_Ipcmpeqq,
    UD_Ipcmpeqw,
    UD_Ipcmpestri,
    UD_Ipcmpestrm,
    UD_Ipcmpgtb,
    UD_Ipcmpgtd,
    UD_Ipcmpgtq,
    UD_Ipcmpgtw,
    UD_Ipcmpistri,
    UD_Ipcmpistrm,
    UD_Ipextrb,
    UD_Ipextrd,
    UD_Ipextrq,
    UD_Ipextrw,
    UD_Ipf2id,
    UD_Ipf2iw,
    UD_Ipfacc,
    UD_Ipfadd,
    UD_Ipfcmpeq,
    UD_Ipfcmpge,
    UD_Ipfcmpgt,
    UD_Ipfmax,
    UD_Ipfmin,
    UD_Ipfmul,
    UD_Ipfnacc,
    UD_Ipfpnacc,
    UD_Ipfrcp,
    UD_Ipfrcpit1,
    UD_Ipfrcpit2,
    UD_Ipfrsqit1,
    UD_Ipfrsqrt,
    UD_Ipfsub,
    UD_Ipfsubr,
    UD_Iphaddd,
    UD_Iphaddsw,
    UD_Iphaddw,
    UD_Iphminposuw,
    UD_Iphsubd,
    UD_Iphsubsw,
    UD_Iphsubw,
    UD_Ipi2fd,
    UD_Ipi2fw,
    UD_Ipinsrb,
    UD_Ipinsrd,
    UD_Ipinsrq,
    UD_Ipinsrw,
    UD_Ipmaddubsw,
    UD_Ipmaddwd,
    UD_Ipmaxsb,
    UD_Ipmaxsd,
    UD_Ipmaxsw,
    UD_Ipmaxub,
    UD_Ipmaxud,
    UD_Ipmaxuw,
    UD_Ipminsb,
    UD_Ipminsd,
    UD_Ipminsw,
    UD_Ipminub,
    UD_Ipminud,
    UD_Ipminuw,
    UD_Ipmovmskb,
    UD_Ipmovsxbd,
    UD_Ipmovsxbq,
    UD_Ipmovsxbw,
    UD_Ipmovsxdq,
    UD_Ipmovsxwd,
    UD_Ipmovsxwq,
    UD_Ipmovzxbd,
    UD_Ipmovzxbq,
    UD_Ipmovzxbw,
    UD_Ipmovzxdq,
    UD_Ipmovzxwd,
    UD_Ipmovzxwq,
    UD_Ipmuldq,
    UD_Ipmulhrsw,
    UD_Ipmulhrw,
    UD_Ipmulhuw,
    UD_Ipmulhw,
    UD_Ipmulld,
    UD_Ipmullw,
    UD_Ipmuludq,
    UD_Ipop,
    UD_Ipopa,
    UD_Ipopad,
    UD_Ipopcnt,
    UD_Ipopfd,
    UD_Ipopfq,
    UD_Ipopfw,
    UD_Ipor,
    UD_Iprefetch,
    UD_Iprefetchnta,
    UD_Iprefetcht0,
    UD_Iprefetcht1,
    UD_Iprefetcht2,
    UD_Ipsadbw,
    UD_Ipshufb,
    UD_Ipshufd,
    UD_Ipshufhw,
    UD_Ipshuflw,
    UD_Ipshufw,
    UD_Ipsignb,
    UD_Ipsignd,
    UD_Ipsignw,
    UD_Ipslld,
    UD_Ipslldq,
    UD_Ipsllq,
    UD_Ipsllw,
    UD_Ipsrad,
    UD_Ipsraw,
    UD_Ipsrld,
    UD_Ipsrldq,
    UD_Ipsrlq,
    UD_Ipsrlw,
    UD_Ipsubb,
    UD_Ipsubd,
    UD_Ipsubq,
    UD_Ipsubsb,
    UD_Ipsubsw,
    UD_Ipsubusb,
    UD_Ipsubusw,
    UD_Ipsubw,
    UD_Ipswapd,
    UD_Iptest,
    UD_Ipunpckhbw,
    UD_Ipunpckhdq,
    UD_Ipunpckhqdq,
    UD_Ipunpckhwd,
    UD_Ipunpcklbw,
    UD_Ipunpckldq,
    UD_Ipunpcklqdq,
    UD_Ipunpcklwd,
    UD_Ipush,
    UD_Ipusha,
    UD_Ipushad,
    UD_Ipushfd,
    UD_Ipushfq,
    UD_Ipushfw,
    UD_Ipxor,
    UD_Ircl,
    UD_Ircpps,
    UD_Ircpss,
    UD_Ircr,
    UD_Irdmsr,
    UD_Irdpmc,
    UD_Irdrand,
    UD_Irdtsc,
    UD_Irdtscp,
    UD_Irep,
    UD_Irepne,
    UD_Iret,
    UD_Iretf,
    UD_Irol,
    UD_Iror,
    UD_Iroundpd,
    UD_Iroundps,
    UD_Iroundsd,
    UD_Iroundss,
    UD_Irsm,
    UD_Irsqrtps,
    UD_Irsqrtss,
    UD_Isahf,
    UD_Isalc,
    UD_Isar,
    UD_Isbb,
    UD_Iscasb,
    UD_Iscasd,
    UD_Iscasq,
    UD_Iscasw,
    UD_Iseta,
    UD_Isetae,
    UD_Isetb,
    UD_Isetbe,
    UD_Isetg,
    UD_Isetge,
    UD_Isetl,
    UD_Isetle,
    UD_Isetno,
    UD_Isetnp,
    UD_Isetns,
    UD_Isetnz,
    UD_Iseto,
    UD_Isetp,
    UD_Isets,
    UD_Isetz,
    UD_Isfence,
    UD_Isgdt,
    UD_Ishl,
    UD_Ishld,
    UD_Ishr,
    UD_Ishrd,
    UD_Ishufpd,
    UD_Ishufps,
    UD_Isidt,
    UD_Iskinit,
    UD_Isldt,
    UD_Ismsw,
    UD_Isqrtpd,
    UD_Isqrtps,
    UD_Isqrtsd,
    UD_Isqrtss,
    UD_Istc,
    UD_Istd,
    UD_Istgi,
    UD_Isti,
    UD_Istmxcsr,
    UD_Istosb,
    UD_Istosd,
    UD_Istosq,
    UD_Istosw,
    UD_Istr,
    UD_Isub,
    UD_Isubpd,
    UD_Isubps,
    UD_Isubsd,
    UD_Isubss,
    UD_Iswapgs,
    UD_Isyscall,
    UD_Isysenter,
    UD_Isysexit,
    UD_Isysret,
    UD_Itest,
    UD_Iucomisd,
    UD_Iucomiss,
    UD_Iud2,
    UD_Iunpckhpd,
    UD_Iunpckhps,
    UD_Iunpcklpd,
    UD_Iunpcklps,
    UD_Ivaddpd,
    UD_Ivaddps,
    UD_Ivaddsd,
    UD_Ivaddss,
    UD_Ivaddsubpd,
    UD_Ivaddsubps,
    UD_Ivaesdec,
    UD_Ivaesdeclast,
    UD_Ivaesenc,
    UD_Ivaesenclast,
    UD_Ivaesimc,
    UD_Ivaeskeygenassist,
    UD_Ivandnpd,
    UD_Ivandnps,
    UD_Ivandpd,
    UD_Ivandps,
    UD_Ivblendpd,
    UD_Ivblendps,
    UD_Ivblendvpd,
    UD_Ivblendvps,
    UD_Ivbroadcastsd,
    UD_Ivbroadcastss,
    UD_Ivcmppd,
    UD_Ivcmpps,
    UD_Ivcmpsd,
    UD_Ivcmpss,
    UD_Ivcomisd,
    UD_Ivcomiss,
    UD_Ivcvtdq2pd,
    UD_Ivcvtdq2ps,
    UD_Ivcvtpd2dq,
    UD_Ivcvtpd2ps,
    UD_Ivcvtps2dq,
    UD_Ivcvtps2pd,
    UD_Ivcvtsd2si,
    UD_Ivcvtsd2ss,
    UD_Ivcvtsi2sd,
    UD_Ivcvtsi2ss,
    UD_Ivcvtss2sd,
    UD_Ivcvtss2si,
    UD_Ivcvttpd2dq,
    UD_Ivcvttps2dq,
    UD_Ivcvttsd2si,
    UD_Ivcvttss2si,
    UD_Ivdivpd,
    UD_Ivdivps,
    UD_Ivdivsd,
    UD_Ivdivss,
    UD_Ivdppd,
    UD_Ivdpps,
    UD_Iverr,
    UD_Iverw,
    UD_Ivextractf128,
    UD_Ivextractps,
    UD_Ivhaddpd,
    UD_Ivhaddps,
    UD_Ivhsubpd,
    UD_Ivhsubps,
    UD_Ivinsertf128,
    UD_Ivinsertps,
    UD_Ivlddqu,
    UD_Ivmaskmovdqu,
    UD_Ivmaskmovpd,
    UD_Ivmaskmovps,
    UD_Ivmaxpd,
    UD_Ivmaxps,
    UD_Ivmaxsd,
    UD_Ivmaxss,
    UD_Ivmcall,
    UD_Ivmclear,
    UD_Ivminpd,
    UD_Ivminps,
    UD_Ivminsd,
    UD_Ivminss,
    UD_Ivmlaunch,
    UD_Ivmload,
    UD_Ivmmcall,
    UD_Ivmovapd,
    UD_Ivmovaps,
    UD_Ivmovd,
    UD_Ivmovddup,
    UD_Ivmovdqa,
    UD_Ivmovdqu,
    UD_Ivmovhlps,
    UD_Ivmovhpd,
    UD_Ivmovhps,
    UD_Ivmovlhps,
    UD_Ivmovlpd,
    UD_Ivmovlps,
    UD_Ivmovmskpd,
    UD_Ivmovmskps,
    UD_Ivmovntdq,
    UD_Ivmovntdqa,
    UD_Ivmovntpd,
    UD_Ivmovntps,
    UD_Ivmovq,
    UD_Ivmovsd,
    UD_Ivmovshdup,
    UD_Ivmovsldup,
    UD_Ivmovss,
    UD_Ivmovupd,
    UD_Ivmovups,
    UD_Ivmpsadbw,
    UD_Ivmptrld,
    UD_Ivmptrst,
    UD_Ivmread,
    UD_Ivmresume,
    UD_Ivmrun,
    UD_Ivmsave,
    UD_Ivmulpd,
    UD_Ivmulps,
    UD_Ivmulsd,
    UD_Ivmulss,
    UD_Ivmwrite,
    UD_Ivmxoff,
    UD_Ivmxon,
    UD_Ivorpd,
    UD_Ivorps,
    UD_Ivpabsb,
    UD_Ivpabsd,
    UD_Ivpabsw,
    UD_Ivpackssdw,
    UD_Ivpacksswb,
    UD_Ivpackusdw,
    UD_Ivpackuswb,
    UD_Ivpaddb,
    UD_Ivpaddd,
    UD_Ivpaddq,
    UD_Ivpaddsb,
    UD_Ivpaddsw,
    UD_Ivpaddusb,
    UD_Ivpaddusw,
    UD_Ivpaddw,
    UD_Ivpalignr,
    UD_Ivpand,
    UD_Ivpandn,
    UD_Ivpavgb,
    UD_Ivpavgw,
    UD_Ivpblendvb,
    UD_Ivpblendw,
    UD_Ivpclmulqdq,
    UD_Ivpcmpeqb,
    UD_Ivpcmpeqd,
    UD_Ivpcmpeqq,
    UD_Ivpcmpeqw,
    UD_Ivpcmpestri,
    UD_Ivpcmpestrm,
    UD_Ivpcmpgtb,
    UD_Ivpcmpgtd,
    UD_Ivpcmpgtq,
    UD_Ivpcmpgtw,
    UD_Ivpcmpistri,
    UD_Ivpcmpistrm,
    UD_Ivperm2f128,
    UD_Ivpermilpd,
    UD_Ivpermilps,
    UD_Ivpextrb,
    UD_Ivpextrd,
    UD_Ivpextrq,
    UD_Ivpextrw,
    UD_Ivphaddd,
    UD_Ivphaddsw,
    UD_Ivphaddw,
    UD_Ivphminposuw,
    UD_Ivphsubd,
    UD_Ivphsubsw,
    UD_Ivphsubw,
    UD_Ivpinsrb,
    UD_Ivpinsrd,
    UD_Ivpinsrq,
    UD_Ivpinsrw,
    UD_Ivpmaddubsw,
    UD_Ivpmaddwd,
    UD_Ivpmaxsb,
    UD_Ivpmaxsd,
    UD_Ivpmaxsw,
    UD_Ivpmaxub,
    UD_Ivpmaxud,
    UD_Ivpmaxuw,
    UD_Ivpminsb,
    UD_Ivpminsd,
    UD_Ivpminsw,
    UD_Ivpminub,
    UD_Ivpminud,
    UD_Ivpminuw,
    UD_Ivpmovmskb,
    UD_Ivpmovsxbd,
    UD_Ivpmovsxbq,
    UD_Ivpmovsxbw,
    UD_Ivpmovsxwd,
    UD_Ivpmovsxwq,
    UD_Ivpmovzxbd,
    UD_Ivpmovzxbq,
    UD_Ivpmovzxbw,
    UD_Ivpmovzxdq,
    UD_Ivpmovzxwd,
    UD_Ivpmovzxwq,
    UD_Ivpmuldq,
    UD_Ivpmulhrsw,
    UD_Ivpmulhuw,
    UD_Ivpmulhw,
    UD_Ivpmulld,
    UD_Ivpmullw,
    UD_Ivpor,
    UD_Ivpsadbw,
    UD_Ivpshufb,
    UD_Ivpshufd,
    UD_Ivpshufhw,
    UD_Ivpshuflw,
    UD_Ivpsignb,
    UD_Ivpsignd,
    UD_Ivpsignw,
    UD_Ivpslld,
    UD_Ivpslldq,
    UD_Ivpsllq,
    UD_Ivpsllw,
    UD_Ivpsrad,
    UD_Ivpsraw,
    UD_Ivpsrld,
    UD_Ivpsrldq,
    UD_Ivpsrlq,
    UD_Ivpsrlw,
    UD_Ivpsubb,
    UD_Ivpsubd,
    UD_Ivpsubq,
    UD_Ivpsubsb,
    UD_Ivpsubsw,
    UD_Ivpsubusb,
    UD_Ivpsubusw,
    UD_Ivpsubw,
    UD_Ivptest,
    UD_Ivpunpckhbw,
    UD_Ivpunpckhdq,
    UD_Ivpunpckhqdq,
    UD_Ivpunpckhwd,
    UD_Ivpunpcklbw,
    UD_Ivpunpckldq,
    UD_Ivpunpcklqdq,
    UD_Ivpunpcklwd,
    UD_Ivpxor,
    UD_Ivrcpps,
    UD_Ivrcpss,
    UD_Ivroundpd,
    UD_Ivroundps,
    UD_Ivroundsd,
    UD_Ivroundss,
    UD_Ivrsqrtps,
    UD_Ivrsqrtss,
    UD_Ivshufpd,
    UD_Ivshufps,
    UD_Ivsqrtpd,
    UD_Ivsqrtps,
    UD_Ivsqrtsd,
    UD_Ivsqrtss,
    UD_Ivstmxcsr,
    UD_Ivsubpd,
    UD_Ivsubps,
    UD_Ivsubsd,
    UD_Ivsubss,
    UD_Ivtestpd,
    UD_Ivtestps,
    UD_Ivucomisd,
    UD_Ivucomiss,
    UD_Ivunpckhpd,
    UD_Ivunpckhps,
    UD_Ivunpcklpd,
    UD_Ivunpcklps,
    UD_Ivxorpd,
    UD_Ivxorps,
    UD_Ivzeroall,
    UD_Ivzeroupper,
    UD_Iwait,
    UD_Iwbinvd,
    UD_Iwrmsr,
    UD_Ixadd,
    UD_Ixchg,
    UD_Ixcryptcbc,
    UD_Ixcryptcfb,
    UD_Ixcryptctr,
    UD_Ixcryptecb,
    UD_Ixcryptofb,
    UD_Ixgetbv,
    UD_Ixlatb,
    UD_Ixor,
    UD_Ixorpd,
    UD_Ixorps,
    UD_Ixrstor,
    UD_Ixsave,
    UD_Ixsetbv,
    UD_Ixsha1,
    UD_Ixsha256,
    UD_Ixstore,
    UD_Iinvalid,
    UD_I3dnow,
    UD_Inone,
    UD_Idb,
    UD_Ipause,
    UD_MAX_MNEMONIC_CODE
};

extern const char * ud_mnemonics_str[];

#endif /* UD_ITAB_H */

```

`deps/premake/asmjit.lua`:

```lua
asmjit = {
	source = path.join(dependencies.basePath, "asmjit"),
}

function asmjit.import()
	links { "asmjit" }
	asmjit.includes()
end

function asmjit.includes()
	includedirs {
		path.join(asmjit.source, "src")
	}
	
	defines {
		"ASMJIT_STATIC",
		"ASMJIT_NO_AARCH64",
		"ASMJIT_NO_FOREIGN",
	}
end

function asmjit.project()
	project "asmjit"
		language "C++"

		asmjit.includes()

		files {
			path.join(asmjit.source, "src/**.cpp"),
		}

		warnings "Off"
		kind "StaticLib"
end

table.insert(dependencies, asmjit)

```

`deps/premake/discord-rpc.lua`:

```lua
discordrpc = {
	source = path.join(dependencies.basePath, "discord-rpc"),
}

function discordrpc.import()
	links { "discord-rpc" }
	discordrpc.includes()
end

function discordrpc.includes()
	includedirs {
		path.join(discordrpc.source, "include"),
	}
end

function discordrpc.project()
	project "discord-rpc"
		language "C++"

		discordrpc.includes()
		rapidjson.import();

		files {
			path.join(discordrpc.source, "src/*.h"),
			path.join(discordrpc.source, "src/*.cpp"),
		}
		
		removefiles {
			path.join(discordrpc.source, "src/dllmain.cpp"),
			path.join(discordrpc.source, "src/*_linux.cpp"),
			path.join(discordrpc.source, "src/*_unix.cpp"),
			path.join(discordrpc.source, "src/*_osx.cpp"),
		}

		warnings "Off"
		kind "StaticLib"
end

table.insert(dependencies, discordrpc)
```

`deps/premake/libtomcrypt.lua`:

```lua
libtomcrypt = {
	source = path.join(dependencies.basePath, "libtomcrypt"),
}

function libtomcrypt.import()
	links {
		"libtomcrypt"
	}

	libtomcrypt.includes()
end

function libtomcrypt.includes()
	includedirs {
		path.join(libtomcrypt.source, "src/headers")
	}

	defines {
		"LTC_NO_FAST",
		"LTC_NO_PROTOTYPES",
		"LTC_NO_RSA_BLINDING",
		"LTC_NO_FILE",
		"ARGTYPE=4",
	}
end

function libtomcrypt.project()
	project "libtomcrypt"
		language "C"

		libtomcrypt.includes()
		libtommath.import()

		files {
			path.join(libtomcrypt.source, "src/**.c"),
		}

		removefiles {
			path.join(libtomcrypt.source, "src/**/*_test.c"),
			path.join(libtomcrypt.source, "src/**/*tab.c"),
			path.join(libtomcrypt.source, "src/encauth/ocb3/**.c"),
		}

		defines {
			"_CRT_SECURE_NO_WARNINGS",
			"LTC_SOURCE",
			"_LIB",
			"USE_LTM"
		}

		removedefines {
			"_DLL",
			"_USRDLL"
		}

		linkoptions {
			"-IGNORE:4221"
		}

		warnings "Off"
		kind "StaticLib"
end

table.insert(dependencies, libtomcrypt)

```

`deps/premake/libtommath.lua`:

```lua
libtommath = {
	source = path.join(dependencies.basePath, "libtommath"),
}

function libtommath.import()
	links {
		"libtommath"
	}

	libtommath.includes()
end

function libtommath.includes()
	includedirs {
		libtommath.source
	}

	defines {
		"LTM_DESC",
		"__STDC_IEC_559__",
		"MP_NO_DEV_URANDOM",
		"ARGTYPE=4",
	}
end

function libtommath.project()
	project "libtommath"
		language "C"

		libtommath.includes()

		files {
			path.join(libtommath.source, "*.c"),
		}

		defines {
			"_LIB"
		}

		removedefines {
			"_DLL",
			"_USRDLL"
		}

		linkoptions {
			"-IGNORE:4221"
		}

		warnings "Off"
		kind "StaticLib"
end

table.insert(dependencies, libtommath)

```

`deps/premake/minhook.lua`:

```lua
minhook = {
	source = path.join(dependencies.basePath, "minhook"),
}

function minhook.import()
	links { "minhook" }
	minhook.includes()
end

function minhook.includes()
	includedirs {
		path.join(minhook.source, "include")
	}
end

function minhook.project()
	project "minhook"
		language "C"

		minhook.includes()

		files {
			path.join(minhook.source, "src/**.h"),
			path.join(minhook.source, "src/**.c"),
		}

		warnings "Off"
		kind "StaticLib"
end

table.insert(dependencies, minhook)

```

`deps/premake/minizip.lua`:

```lua
minizip = {
	source = path.join(dependencies.basePath, "zlib/contrib/minizip"),
}

function minizip.import()
	links { "minizip" }
	zlib.import()
	minizip.includes()
end

function minizip.includes()
	includedirs {
		minizip.source
	}

	zlib.includes()
end

function minizip.project()
	project "minizip"
		language "C"

		minizip.includes()

		files {
			path.join(minizip.source, "*.h"),
			path.join(minizip.source, "*.c"),
		}

		removefiles {
			path.join(minizip.source, "miniunz.c"),
			path.join(minizip.source, "minizip.c"),
		}

		defines {
			"_CRT_SECURE_NO_DEPRECATE",
		}

		warnings "Off"
		kind "StaticLib"
end

table.insert(dependencies, minizip)

```

`deps/premake/rapidjson.lua`:

```lua
rapidjson = {
	source = path.join(dependencies.basePath, "rapidjson"),
}

function rapidjson.import()
	defines{"RAPIDJSON_HAS_STDSTRING"}
	rapidjson.includes()
end

function rapidjson.includes()
	includedirs {
		path.join(rapidjson.source, "include"),
	}
end

function rapidjson.project()

end

table.insert(dependencies, rapidjson)

```

`deps/premake/stb.lua`:

```lua
stb = {
	source = path.join(dependencies.basePath, "stb"),
}

function stb.import()
	stb.includes()
end

function stb.includes()
	includedirs {
		stb.source
	}
end

function stb.project()

end

table.insert(dependencies, stb)

```

`deps/premake/udis86.lua`:

```lua
udis86 = {
	source = path.join(dependencies.basePath, "udis86"),
}

function udis86.import()
	links {
		"udis86"
	}

	udis86.includes()
end

function udis86.includes()
	includedirs {
		udis86.source,
		path.join(udis86.source, "libudis86"),
		path.join(dependencies.basePath, "extra/udis86"),
		path.join(dependencies.basePath, "extra/udis86/libudis86"),
	}
end

function udis86.project()
	project "udis86"
		language "C"

		udis86.includes()

		files {
			path.join(udis86.source, "libudis86/*.c"),
			path.join(dependencies.basePath, "extra/udis86/libudis86/*.c"),
		}

		warnings "Off"
		kind "StaticLib"
end

table.insert(dependencies, udis86)

```

`deps/premake/zlib.lua`:

```lua
zlib = {
	source = path.join(dependencies.basePath, "zlib"),
}

function zlib.import()
	links { "zlib" }
	zlib.includes()
end

function zlib.includes()
	includedirs {
		zlib.source
	}

	defines {
		"ZLIB_CONST",
	}
end

function zlib.project()
	project "zlib"
		language "C"

		zlib.includes()

		files {
			path.join(zlib.source, "*.h"),
			path.join(zlib.source, "*.c"),
		}

		defines {
			"_CRT_SECURE_NO_DEPRECATE",
		}

		warnings "Off"
		kind "StaticLib"
end

table.insert(dependencies, zlib)

```

`generate.bat`:

```bat
@echo off
git submodule update --init --recursive
tools\premake5 %* vs2022
```

`premake5.lua`:

```lua
gitVersioningCommand = "git describe --tags --dirty --always"
gitCurrentBranchCommand = "git symbolic-ref -q --short HEAD"

-- Quote the given string input as a C string
function cstrquote(value)
	if value == nil then
		return "\"\""
	end
	result = value:gsub("\\", "\\\\")
	result = result:gsub("\"", "\\\"")
	result = result:gsub("\n", "\\n")
	result = result:gsub("\t", "\\t")
	result = result:gsub("\r", "\\r")
	result = result:gsub("\a", "\\a")
	result = result:gsub("\b", "\\b")
	result = "\"" .. result .. "\""
	return result
end

-- Converts tags in "vX.X.X" format and given revision number Y to an array of numbers {X,X,X,Y}.
-- In the case where the format does not work fall back to padding with zeroes and just ending with the revision number.
-- partscount can be either 3 or 4.
function vertonumarr(value, vernumber, partscount)
	vernum = {}
	for num in string.gmatch(value or "", "%d+") do
		if #vernum < 3 then
			table.insert(vernum, tonumber(num))
		end
	end
	while #vernum < 3 do
		table.insert(vernum, 0)
	end
	if #vernum < partscount then
		table.insert(vernum, tonumber(vernumber))
	end
	return vernum
end

dependencies = {
	basePath = "./deps"
}

function dependencies.load()
	dir = path.join(dependencies.basePath, "premake/*.lua")
	deps = os.matchfiles(dir)

	for i, dep in pairs(deps) do
		dep = dep:gsub(".lua", "")
		require(dep)
	end
end

function dependencies.imports()
	for i, proj in pairs(dependencies) do
		if type(i) == 'number' then
			proj.import()
		end
	end
end

function dependencies.projects()
	for i, proj in pairs(dependencies) do
		if type(i) == 'number' then
			proj.project()
		end
	end
end

newoption {
	trigger = "copy-to",
	description = "Optional, copy the EXE to a custom folder after build, define the path here if wanted.",
	value = "PATH"
}

newoption {
	trigger = "dev-build",
	description = "Enable development builds of the client."
}

newaction {
	trigger = "version",
	description = "Returns the version string for the current commit of the source code.",
	onWorkspace = function(wks)
		-- get current version via git
		local proc = assert(io.popen(gitVersioningCommand, "r"))
		local gitDescribeOutput = assert(proc:read('*a')):gsub("%s+", "")
		proc:close()
		local version = gitDescribeOutput

		proc = assert(io.popen(gitCurrentBranchCommand, "r"))
		local gitCurrentBranchOutput = assert(proc:read('*a')):gsub("%s+", "")
		local gitCurrentBranchSuccess = proc:close()
		if gitCurrentBranchSuccess then
			-- We got a branch name, check if it is a feature branch
			if gitCurrentBranchOutput ~= "develop" and gitCurrentBranchOutput ~= "master" and gitCurrentBranchOutput ~= "main" then
				version = version .. "-" .. gitCurrentBranchOutput
			end
		end

		print(version)
		os.exit(0)
	end
}

newaction {
	trigger = "generate-buildinfo",
	description = "Sets up build information file like version.h.",
	onWorkspace = function(wks)
		-- get old version number from version.hpp if any
		local oldVersion = "(none)"
		local oldVersionHeader = io.open(wks.location .. "/src/version.h", "r")
		if oldVersionHeader ~= nil then
			local oldVersionHeaderContent = assert(oldVersionHeader:read('*l'))
			while oldVersionHeaderContent do
				m = string.match(oldVersionHeaderContent, "#define GIT_DESCRIBE (.+)%s*$")
				if m ~= nil then
						oldVersion = m
				end

				oldVersionHeaderContent = oldVersionHeader:read('*l')
			end
		end

		-- get current version via git
		local proc = assert(io.popen(gitVersioningCommand, "r"))
		local gitDescribeOutput = assert(proc:read('*a')):gsub("%s+", "")
		proc:close()

		-- generate version.hpp with a revision number if not equal
		gitDescribeOutputQuoted = cstrquote(gitDescribeOutput)
		if oldVersion ~= gitDescribeOutputQuoted then
			-- get current git hash and write to version.txt (used by the preliminary updater)
			-- TODO - remove once proper updater and release versioning exists
			local proc = assert(io.popen("git rev-parse HEAD", "r"))
			local gitCommitHash = assert(proc:read('*a')):gsub("%s+", "")
			proc:close()

			-- get whether this is a clean revision (no uncommitted changes)
			proc = assert(io.popen("git status --porcelain", "r"))
			local revDirty = (assert(proc:read('*a')) ~= "")
			if revDirty then revDirty = 1 else revDirty = 0 end
			proc:close()

			-- get current tag name
			proc = assert(io.popen("git describe --tags --abbrev=0"))
			local tagName = proc:read('*l')

			-- get current branch name
			proc = assert(io.popen("git branch --show-current"))
			local branchName = proc:read('*l')

			-- branch for ci
			if branchName == nil or branchName == '' then
				proc = assert(io.popen("git show -s --pretty=%d HEAD"))
				local branchInfo = proc:read('*l')
				m = string.match(branchInfo, ".+,.+, ([^)]+)")
				if m ~= nil then
					branchName = m
				end
			end

			if branchName == nil then
				branchName = "develop"
			end

			print("Detected branch: " .. branchName)

			-- get revision number via git
			local proc = assert(io.popen("git rev-list --count HEAD", "r"))
			local revNumber = assert(proc:read('*a')):gsub("%s+", "")

			print ("Update " .. oldVersion .. " -> " .. gitDescribeOutputQuoted)

			-- write to version.txt for preliminary updater
			-- NOTE - remove this once we have a proper updater and proper release versioning
			local versionFile = assert(io.open(wks.location .. "/version.txt", "w"))
			versionFile:write(gitCommitHash)
			versionFile:close()

			-- write version header
			local versionHeader = assert(io.open(wks.location .. "/src/version.h", "w"))
			versionHeader:write("/*\n")
			versionHeader:write(" * Automatically generated by premake5.\n")
			versionHeader:write(" * Do not touch!\n")
			versionHeader:write(" */\n")
			versionHeader:write("\n")
			versionHeader:write("#define GIT_DESCRIBE " .. gitDescribeOutputQuoted .. "\n")
			versionHeader:write("#define GIT_DIRTY " .. revDirty .. "\n")
			versionHeader:write("#define GIT_HASH " .. cstrquote(gitCommitHash) .. "\n")
			versionHeader:write("#define GIT_TAG " .. cstrquote(tagName) .. "\n")
			versionHeader:write("#define GIT_BRANCH " .. cstrquote(branchName) .. "\n")
			versionHeader:write("\n")
			versionHeader:write("// Version transformed for RC files\n")
			versionHeader:write("#define VERSION_PRODUCT_RC " .. table.concat(vertonumarr(tagName, revNumber, 3), ",") .. "\n")
			versionHeader:write("#define VERSION_PRODUCT " .. cstrquote(table.concat(vertonumarr(tagName, revNumber, 3), ".")) .. "\n")
			versionHeader:write("#define VERSION_FILE_RC " .. table.concat(vertonumarr(tagName, revNumber, 4), ",") .. "\n")
			versionHeader:write("#define VERSION_FILE " .. cstrquote(table.concat(vertonumarr(tagName, revNumber, 4), ".")) .. "\n")
			versionHeader:write("\n")
			versionHeader:write("// Alias definitions\n")
			versionHeader:write("#define VERSION GIT_DESCRIBE\n")
			versionHeader:write("#define SHORTVERSION VERSION_PRODUCT\n")
			versionHeader:close()
			local versionHeader = assert(io.open(wks.location .. "/src/version.hpp", "w"))
			versionHeader:write("/*\n")
			versionHeader:write(" * Automatically generated by premake5.\n")
			versionHeader:write(" * Do not touch!\n")
			versionHeader:write(" *\n")
			versionHeader:write(" * This file exists for reasons of complying with our coding standards.\n")
			versionHeader:write(" *\n")
			versionHeader:write(" * The Resource Compiler will ignore any content from C++ header files if they're not from STDInclude.hpp.\n")
			versionHeader:write(" * That's the reason why we now place all version info in version.h instead.\n")
			versionHeader:write(" */\n")
			versionHeader:write("\n")
			versionHeader:write("#include \".\\version.h\"\n")
			versionHeader:close()
		end
	end
}

dependencies.load()

workspace "boiii"
	startproject "client"
	location "./build"
	objdir "%{wks.location}/obj"
	targetdir "%{wks.location}/bin/%{cfg.platform}/%{cfg.buildcfg}"

	configurations {"Debug", "Release"}

	language "C++"
	cppdialect "C++20"

	architecture "x86_64"
	platforms "x64"

	systemversion "latest"
	symbols "On"
	staticruntime "On"
	editandcontinue "Off"
	warnings "Extra"
	characterset "ASCII"

	if _OPTIONS["dev-build"] then
		defines {"DEV_BUILD"}
	end

	if os.getenv("CI") then
		defines {"CI"}
	end

	flags {"NoIncrementalLink", "NoMinimalRebuild", "MultiProcessorCompile", "No64BitChecks"}

	filter "platforms:x64"
		defines {"_WINDOWS", "WIN32"}
	filter {}

	filter "configurations:Release"
		optimize "Size"
		buildoptions {"/GL"}
		linkoptions {"/IGNORE:4702", "/LTCG"}
		defines {"NDEBUG"}
		flags {"FatalCompileWarnings"}
	filter {}

	filter "configurations:Debug"
		optimize "Debug"
		defines {"DEBUG", "_DEBUG"}
	filter {}

project "common"
	kind "StaticLib"
	language "C++"

	files {"./src/common/**.hpp", "./src/common/**.cpp"}

	includedirs {"./src/common", "%{prj.location}/src"}

	resincludedirs {"$(ProjectDir)src"}

	dependencies.imports()

project "client"
	kind "WindowedApp"
	language "C++"

	targetname "boiii"

	pchheader "std_include.hpp"
	pchsource "src/client/std_include.cpp"

	files {"./src/client/**.rc", "./src/client/**.hpp", "./src/client/**.cpp", "./src/client/resources/**.*"}

	includedirs {"./src/client", "./src/common", "%{prj.location}/src"}

	resincludedirs {"$(ProjectDir)src"}

	dependson {"tlsdll"}

	links {"common"}

	prebuildcommands {"pushd %{_MAIN_SCRIPT_DIR}", "tools\\premake5 generate-buildinfo", "popd"}

	if _OPTIONS["copy-to"] then
		postbuildcommands {"copy /y \"$(TargetPath)\" \"" .. _OPTIONS["copy-to"] .. "\""}
	end

	dependencies.imports()

project "tlsdll"
	kind "SharedLib"
	language "C++"

	symbols 'Off'
	exceptionhandling "Off"

	flags {"NoRuntimeChecks", "NoBufferSecurityCheck",  "OmitDefaultLibrary"}

	buildoptions {"/Zc:threadSafeInit-"}
	linkoptions {"/NODEFAULTLIB", "/IGNORE:4210"}

	removebuildoptions {"/GL"}
	removelinkoptions {"/LTCG"}

	files {"./src/tlsdll/**.rc", "./src/tlsdll/**.hpp", "./src/tlsdll/**.cpp", "./src/tlsdll/resources/**.*"}

	includedirs {"./src/tlsdll", "%{prj.location}/src"}

	links {"common"}

	resincludedirs {"$(ProjectDir)src"}


group "Dependencies"
	dependencies.projects()

```

`src/client/component/arxan.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"
#include "scheduler.hpp"

#include "game/game.hpp"
#include "steam/steam.hpp"
#include <utils/hook.hpp>

#include <utils/io.hpp>
#include <utils/string.hpp>
#include <utils/thread.hpp>

#define ProcessDebugPort 7
#define ProcessDebugObjectHandle 30
#define ProcessDebugFlags 31
#define ProcessImageFileNameWin32 43

namespace arxan
{
	namespace
	{
		constexpr auto pseudo_steam_id = 0x1337;
		const auto pseudo_steam_handle = reinterpret_cast<HANDLE>(reinterpret_cast<uint64_t>(INVALID_HANDLE_VALUE) -
			pseudo_steam_id);

		utils::hook::detour nt_close_hook;
		utils::hook::detour nt_query_system_information_hook;
		utils::hook::detour nt_query_information_process_hook;
		utils::hook::detour create_mutex_ex_a_hook;
		utils::hook::detour open_process_hook;
		utils::hook::detour create_thread_hook;
		utils::hook::detour get_thread_context_hook;
		utils::hook::detour zw_terminate_process_hook;
		utils::hook::detour get_proc_address_hook;

		void* original_first_tls_callback = nullptr;

		void** get_tls_callbacks()
		{
			const utils::nt::library game{};
			const auto& entry = game.get_optional_header()->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
			if (!entry.VirtualAddress || !entry.Size)
			{
				return nullptr;
			}

			const auto* tls_dir = reinterpret_cast<IMAGE_TLS_DIRECTORY*>(game.get_ptr() + entry.VirtualAddress);
			return reinterpret_cast<void**>(tls_dir->AddressOfCallBacks);
		}

		void disable_tls_callbacks()
		{
			auto* tls_callbacks = get_tls_callbacks();
			if (tls_callbacks)
			{
				original_first_tls_callback = *tls_callbacks;
			}

			utils::hook::set(tls_callbacks, nullptr);
		}

		void restore_tls_callbacks()
		{
			auto* tls_callbacks = get_tls_callbacks();
			if (tls_callbacks)
			{
				utils::hook::set(tls_callbacks, original_first_tls_callback);
			}
		}

		HANDLE WINAPI create_thread_stub(const LPSECURITY_ATTRIBUTES thread_attributes, const SIZE_T stack_size,
		                                 const LPTHREAD_START_ROUTINE start_address, const LPVOID parameter,
		                                 const DWORD creation_flags,
		                                 const LPDWORD thread_id)
		{
			if (utils::nt::library::get_by_address(start_address) == utils::nt::library{})
			{
				restore_tls_callbacks();

				create_thread_hook.clear();
				return CreateThread(thread_attributes, stack_size, start_address, parameter, creation_flags,
				                    thread_id);
			}

			return create_thread_hook.invoke<HANDLE>(thread_attributes, stack_size, start_address, parameter,
			                                         creation_flags, thread_id);
		}

		HANDLE process_id_to_handle(const DWORD pid)
		{
			return reinterpret_cast<HANDLE>(static_cast<DWORD64>(pid));
		}

		HANDLE WINAPI open_process_stub(const DWORD access, const BOOL inherit, const DWORD pid)
		{
			if (pid == pseudo_steam_id)
			{
				return pseudo_steam_handle;
			}

			return open_process_hook.invoke<HANDLE>(access, inherit, pid);
		}


		HANDLE create_mutex_ex_a_stub(const LPSECURITY_ATTRIBUTES attributes, const LPCSTR name, const DWORD flags,
		                              const DWORD access)
		{
			if (name == "$ IDA trusted_idbs"s || name == "$ IDA registry mutex $"s)
			{
				return nullptr;
			}

			return create_mutex_ex_a_hook.invoke<HANDLE>(attributes, name, flags, access);
		}

		bool remove_evil_keywords_from_string(const UNICODE_STRING& string)
		{
			static const std::wstring evil_keywords[] =
			{
				L"IDA",
				L"ida",
				L"HxD",
				L"cheatengine",
				L"Cheat Engine",
				L"x96dbg",
				L"x32dbg",
				L"x64dbg",
				L"Wireshark",
			};

			if (!string.Buffer || !string.Length)
			{
				return false;
			}

			const std::wstring_view path(string.Buffer, string.Length / sizeof(string.Buffer[0]));

			bool modified = false;
			for (const auto& keyword : evil_keywords)
			{
				while (true)
				{
					const auto pos = path.find(keyword);
					if (pos == std::wstring::npos)
					{
						break;
					}

					modified = true;

					for (size_t i = 0; i < keyword.size(); ++i)
					{
						string.Buffer[pos + i] = L'a';
					}
				}
			}

			return modified;
		}

		bool remove_evil_keywords_from_string(wchar_t* str, const size_t length)
		{
			UNICODE_STRING unicode_string{};
			unicode_string.Buffer = str;
			unicode_string.Length = static_cast<uint16_t>(length);
			unicode_string.MaximumLength = unicode_string.Length;

			return remove_evil_keywords_from_string(unicode_string);
		}

		bool remove_evil_keywords_from_string(char* str, const size_t length)
		{
			std::string_view str_view(str, length);
			std::wstring wstr(str_view.begin(), str_view.end());

			if (!remove_evil_keywords_from_string(wstr.data(), wstr.size()))
			{
				return false;
			}

			const std::string regular_str(wstr.begin(), wstr.end());
			memcpy(str, regular_str.data(), length);

			return true;
		}


		int WINAPI get_window_text_a_stub(const HWND wnd, const LPSTR str, const int max_count)
		{
			std::wstring wstr{};
			wstr.resize(max_count);

			const auto res = GetWindowTextW(wnd, wstr.data(), max_count);
			if (res)
			{
				remove_evil_keywords_from_string(wstr.data(), res);

				const std::string regular_str(wstr.begin(), wstr.end());
				memset(str, 0, max_count);
				memcpy(str, regular_str.data(), res);
			}

			return res;
		}

		NTSTATUS NTAPI nt_query_system_information_stub(const SYSTEM_INFORMATION_CLASS system_information_class,
		                                                const PVOID system_information,
		                                                const ULONG system_information_length,
		                                                const PULONG return_length)
		{
			const auto status = nt_query_system_information_hook.invoke<NTSTATUS>(
				system_information_class, system_information, system_information_length, return_length);

			if (NT_SUCCESS(status))
			{
				if (system_information_class == SystemProcessInformation && !utils::nt::is_shutdown_in_progress())
				{
					bool injected_steam = false;
					auto addr = static_cast<uint8_t*>(system_information);
					while (true)
					{
						const auto info = reinterpret_cast<SYSTEM_PROCESS_INFORMATION*>(addr);
						remove_evil_keywords_from_string(info->ImageName);

						static const auto our_pid = process_id_to_handle(GetCurrentProcessId());

						if (!injected_steam && info->UniqueProcessId != our_pid)
						{
							static wchar_t steam_path[] = L"steam.exe";

							info->UniqueProcessId = process_id_to_handle(pseudo_steam_id);
							info->ImageName.Buffer = steam_path;
							info->ImageName.Length = static_cast<uint16_t>(wcslen(steam_path) * 2u);
							info->ImageName.MaximumLength = info->ImageName.Length;

							injected_steam = true;
						}

						if (!info->NextEntryOffset)
						{
							break;
						}

						addr = addr + info->NextEntryOffset;
					}
				}
			}

			return status;
		}

		bool handle_pseudo_steam_process(const HANDLE handle, const PROCESSINFOCLASS info_class,
		                                 const PVOID info,
		                                 const ULONG info_length, const PULONG ret_length, NTSTATUS* status)
		{
			if (handle != pseudo_steam_handle || static_cast<int>(info_class) != 43)
			{
				return false;
			}

			const auto steam_folder = steam::SteamAPI_GetSteamInstallPath();
			const auto steam_path = steam_folder + "\\steam.exe"s;
			const std::wstring wide_path(steam_path.begin(), steam_path.end());

			const auto required_size = static_cast<ULONG>((wide_path.size() + 1u) * 2u + sizeof(UNICODE_STRING));

			if (ret_length)
			{
				*ret_length = required_size;
			}

			if (info_length < required_size)
			{
				*status = static_cast<LONG>(0xC0000004);
				return true;
			}

			memset(info, 0, info_length);

			auto& str = *static_cast<UNICODE_STRING*>(info);
			str.Buffer = reinterpret_cast<wchar_t*>(&str + 1);
			str.Length = static_cast<uint16_t>(wide_path.size() * 2u);
			str.MaximumLength = str.Length;

			memcpy(str.Buffer, wide_path.data(), str.Length);

			*status = 0;
			return true;
		}

		NTSTATUS WINAPI nt_query_information_process_stub(const HANDLE handle, const PROCESSINFOCLASS info_class,
		                                                  const PVOID info,
		                                                  const ULONG info_length, const PULONG ret_length)
		{
			NTSTATUS status{0};
			if (handle_pseudo_steam_process(handle, info_class, info, info_length, ret_length, &status))
			{
				return status;
			}

			status = nt_query_information_process_hook.invoke<NTSTATUS>(handle, info_class, info, info_length,
			                                                            ret_length);

			if (NT_SUCCESS(status))
			{
				if (info_class == ProcessBasicInformation)
				{
					static_cast<PPROCESS_BASIC_INFORMATION>(info)->Reserved3 = process_id_to_handle(pseudo_steam_id);
				}
				else if (info_class == ProcessDebugObjectHandle)
				{
					*static_cast<HANDLE*>(info) = nullptr;
					return static_cast<LONG>(0xC0000353);
				}
				else if (info_class == ProcessImageFileName || static_cast<int>(info_class) ==
					ProcessImageFileNameWin32)
				{
					remove_evil_keywords_from_string(*static_cast<UNICODE_STRING*>(info));
				}
				else if (info_class == ProcessDebugPort)
				{
					*static_cast<HANDLE*>(info) = nullptr;
				}
				else if (info_class == ProcessDebugFlags)
				{
					*static_cast<ULONG*>(info) = 1;
				}
			}

			return status;
		}

		NTSTATUS NTAPI nt_close_stub(const HANDLE handle)
		{
			if (handle == pseudo_steam_handle)
			{
				return 0;
			}

			char info[16];
			if (NtQueryObject(handle, OBJECT_INFORMATION_CLASS(4), &info, 2, nullptr) >= 0 && size_t(handle) != 0x12345)
			{
				return nt_close_hook.invoke<NTSTATUS>(handle);
			}

			return STATUS_INVALID_HANDLE;
		}

		void hide_being_debugged()
		{
			auto* const peb = reinterpret_cast<PPEB>(__readgsqword(0x60));
			peb->BeingDebugged = false;
			*reinterpret_cast<PDWORD>(LPSTR(peb) + 0xBC) &= ~0x70;
		}

		void restore_debug_functions()
		{
			static const char* functions[] = {
				"DbgBreakPoint",
				"DbgUserBreakPoint",
				"DbgUiConnectToDbg",
				"DbgUiContinue",
				"DbgUiConvertStateChangeStructure",
				"DbgUiDebugActiveProcess",
				"DbgUiGetThreadDebugObject",
				"DbgUiIssueRemoteBreakin",
				"DbgUiRemoteBreakin",
				"DbgUiSetThreadDebugObject",
				"DbgUiStopDebugging",
				"DbgUiWaitStateChange",
				"DbgPrintReturnControlC",
				"DbgPrompt",
			};

			using buffer = uint8_t[15];
			static buffer buffers[ARRAYSIZE(functions)] = {};
			static bool loaded = false;

			const utils::nt::library ntdll("ntdll.dll");

			for (auto i = 0u; i < ARRAYSIZE(functions); ++i)
			{
				const auto func = ntdll.get_proc<void*>(functions[i]);
				if (!func)
				{
					continue;
				}

				if (!loaded)
				{
					memcpy(buffers[i], func, sizeof(buffer));
				}
				else
				{
					utils::hook::copy(func, buffers[i], sizeof(buffer));
				}
			}

			loaded = true;
		}

		const std::vector<std::pair<uint8_t*, size_t>>& get_text_sections()
		{
			static const std::vector<std::pair<uint8_t*, size_t>> text = []
			{
				std::vector<std::pair<uint8_t*, size_t>> texts{};

				const utils::nt::library game{};
				for (const auto& section : game.get_section_headers())
				{
					if (section->Characteristics & IMAGE_SCN_MEM_EXECUTE)
					{
						texts.emplace_back(game.get_ptr() + section->VirtualAddress, section->Misc.VirtualSize);
					}
				}

				return texts;
			}();

			return text;
		}

		bool is_in_texts(const uint64_t addr)
		{
			const auto& texts = get_text_sections();
			for (const auto& text : texts)
			{
				const auto start = reinterpret_cast<ULONG_PTR>(text.first);
				if (addr >= start && addr <= (start + text.second))
				{
					return true;
				}
			}

			return false;
		}

		bool is_in_texts(const void* addr)
		{
			return is_in_texts(reinterpret_cast<uint64_t>(addr));
		}

		struct integrity_handler_context
		{
			uint32_t* computed_checksum;
			uint32_t* original_checksum;
		};

		bool is_on_stack(uint8_t* stack_frame, const void* pointer)
		{
			const auto stack_value = reinterpret_cast<uint64_t>(stack_frame);
			const auto pointer_value = reinterpret_cast<uint64_t>(pointer);

			const auto diff = static_cast<int64_t>(stack_value - pointer_value);
			return std::abs(diff) < 0x1000;
		}

		// Pretty trashy, but working, heuristic to search the integrity handler context
		bool is_handler_context(uint8_t* stack_frame, const uint32_t computed_checksum, const uint32_t frame_offset)
		{
			const auto* potential_context = reinterpret_cast<integrity_handler_context*>(stack_frame + frame_offset);
			return is_on_stack(stack_frame, potential_context->computed_checksum)
				&& *potential_context->computed_checksum == computed_checksum
				&& is_in_texts(potential_context->original_checksum);
		}

		integrity_handler_context* search_handler_context(uint8_t* stack_frame, const uint32_t computed_checksum)
		{
			for (uint32_t frame_offset = 0; frame_offset < 0x90; frame_offset += 8)
			{
				if (is_handler_context(stack_frame, computed_checksum, frame_offset))
				{
					return reinterpret_cast<integrity_handler_context*>(stack_frame + frame_offset);
				}
			}

			return nullptr;
		}

		uint32_t adjust_integrity_checksum(const uint64_t return_address, uint8_t* stack_frame,
		                                   const uint32_t current_checksum)
		{
			const auto handler_address = game::derelocate(return_address - 5);
			const auto* context = search_handler_context(stack_frame, current_checksum);

			if (!context)
			{
				MessageBoxA(nullptr, utils::string::va("No frame offset for: %llX", handler_address), "Error",
				            MB_ICONERROR);
				TerminateProcess(GetCurrentProcess(), 0xBAD);
				return current_checksum;
			}

			const auto correct_checksum = *context->original_checksum;
			*context->computed_checksum = correct_checksum;

			if (current_checksum != correct_checksum)
			{
#ifndef NDEBUG
				/*printf("Adjusting checksum (%llX): %X -> %X\n", handler_address,
				       current_checksum, correct_checksum);*/
#endif
			}

			return correct_checksum;
		}

		void patch_intact_basic_block_integrity_check(void* address)
		{
			const auto game_address = reinterpret_cast<uint64_t>(address);
			constexpr auto inst_len = 3;

			const auto next_inst_addr = game_address + inst_len;
			const auto next_inst = *reinterpret_cast<uint32_t*>(next_inst_addr);

			if ((next_inst & 0xFF00FFFF) != 0xFF004583)
			{
				throw std::runtime_error(utils::string::va("Unable to patch intact basic block: %llX", game_address));
			}

			const auto other_frame_offset = static_cast<uint8_t>(next_inst >> 16);
			static const auto stub = utils::hook::assemble([](utils::hook::assembler& a)
			{
				a.push(rax);

				a.mov(rax, qword_ptr(rsp, 8));
				a.sub(rax, 2); // Skip the push we inserted

				a.push(rax);
				a.pushad64();

				a.mov(r8, qword_ptr(rsp, 0x88));
				a.mov(rcx, rax);
				a.mov(rdx, rbp);
				a.call_aligned(adjust_integrity_checksum);

				a.mov(qword_ptr(rsp, 0x80), rax);

				a.popad64();
				a.pop(rax);

				a.add(rsp, 8);

				a.mov(dword_ptr(rdx, rcx, 4), eax);

				a.pop(rax); // return addr
				a.xchg(rax, qword_ptr(rsp)); // switch with push

				a.add(dword_ptr(rbp, rax), 0xFFFFFFFF);

				a.mov(rax, dword_ptr(rdx, rcx, 4)); // restore rax

				a.ret();
			});

			// push other_frame_offset
			utils::hook::set<uint16_t>(game_address, static_cast<uint16_t>(0x6A | (other_frame_offset << 8)));
			utils::hook::call(game_address + 2, stub);
		}

		void patch_split_basic_block_integrity_check(void* address)
		{
			const auto game_address = reinterpret_cast<uint64_t>(address);
			constexpr auto inst_len = 3;

			const auto next_inst_addr = game_address + inst_len;

			if (*reinterpret_cast<uint8_t*>(next_inst_addr) != 0xE9)
			{
				throw std::runtime_error(utils::string::va("Unable to patch split basic block: %llX", game_address));
			}

			const auto jump_target = utils::hook::extract<void*>(reinterpret_cast<void*>(next_inst_addr + 1));
			const auto stub = utils::hook::assemble([jump_target](utils::hook::assembler& a)
			{
				a.push(rax);

				a.mov(rax, qword_ptr(rsp, 8));
				a.push(rax);

				a.pushad64();

				a.mov(r8, qword_ptr(rsp, 0x88));
				a.mov(rcx, rax);
				a.mov(rdx, rbp);
				a.call_aligned(adjust_integrity_checksum);

				a.mov(qword_ptr(rsp, 0x80), rax);

				a.popad64();
				a.pop(rax);

				a.add(rsp, 8);

				a.mov(dword_ptr(rdx, rcx, 4), eax);

				a.add(rsp, 8);

				a.jmp(jump_target);
			});

			utils::hook::call(game_address, stub);
		}

		void search_and_patch_integrity_checks()
		{
			// There seem to be 1219 results.
			// Searching them is quite slow.
			// Maybe precomputing that might be better?
			const auto intact_results = "89 04 8A 83 45 ? FF"_sig;
			const auto split_results = "89 04 8A E9"_sig;

			for (auto* i : intact_results)
			{
				patch_intact_basic_block_integrity_check(i);
			}

			for (auto* i : split_results)
			{
				patch_split_basic_block_integrity_check(i);
			}
		}

		LONG WINAPI exception_filter(const LPEXCEPTION_POINTERS info)
		{
			if (info->ExceptionRecord->ExceptionCode == STATUS_INVALID_HANDLE)
			{
				return EXCEPTION_CONTINUE_EXECUTION;
			}

			return EXCEPTION_CONTINUE_SEARCH;
		}

		const char* get_command_line_a_stub()
		{
			static auto cmd = []
			{
				std::string cmd_line = GetCommandLineA();
				if (!strstr(cmd_line.data(), "fs_game"))
				{
					cmd_line += " +set fs_game \"boiii\"";
				}

				return cmd_line;
			}();

			return cmd.data();
		}
	}

	int WINAPI get_system_metrics_stub(const int index)
	{
		if (SM_REMOTESESSION == index)
		{
			return 0;
		}

		return GetSystemMetrics(index);
	}

	BOOL WINAPI get_thread_context_stub(const HANDLE thread_handle, const LPCONTEXT context)
	{
		constexpr auto debug_registers_flag = (CONTEXT_DEBUG_REGISTERS & ~CONTEXT_AMD64);
		if (context->ContextFlags & debug_registers_flag)
		{
			auto* source = _ReturnAddress();
			const auto game = utils::nt::library{};
			const auto source_module = utils::nt::library::get_by_address(source);

			if (source_module == game)
			{
				context->ContextFlags &= ~debug_registers_flag;
			}
		}

		return get_thread_context_hook.invoke<BOOL>(thread_handle, context);
	}

	NTSTATUS NTAPI get_proc_address_stub(const HMODULE module_handle, const PANSI_STRING function_name,
	                                     const WORD oridinal,
	                                     PVOID* function_address, const BOOL b_value,
	                                     PVOID* callback_address)
	{
		OutputDebugStringA(utils::string::va("Proc: %s %X\n",
		                                     (function_name && function_name->Buffer)
			                                     ? function_name->Buffer
			                                     : "(null)", static_cast<DWORD>(oridinal)));

		return get_proc_address_hook.invoke<NTSTATUS>(module_handle, function_name, oridinal, function_address, b_value,
		                                              callback_address);
	}

	NTSTATUS zw_terminate_process_stub(const HANDLE process_handle, const NTSTATUS exit_status)
	{
		MessageBoxA(nullptr, "TERMINATING", nullptr, 0);
		return zw_terminate_process_hook.invoke<NTSTATUS>(process_handle, exit_status);
	}

	struct component final : generic_component
	{
		void post_load() override
		{
			auto* dll_characteristics = &utils::nt::library().get_optional_header()->DllCharacteristics;
			utils::hook::set<WORD>(dll_characteristics, *dll_characteristics | IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE);

			disable_tls_callbacks();
			restore_debug_functions();

			hide_being_debugged();
			scheduler::loop(hide_being_debugged, scheduler::pipeline::async);

			create_thread_hook.create(CreateThread, create_thread_stub);
			create_mutex_ex_a_hook.create(CreateMutexExA, create_mutex_ex_a_stub);

			const utils::nt::library ntdll("ntdll.dll");
			nt_close_hook.create(ntdll.get_proc<void*>("NtClose"), nt_close_stub);

			const auto nt_query_information_process = ntdll.get_proc<void*>("NtQueryInformationProcess");
			nt_query_information_process_hook.create(nt_query_information_process,
			                                         nt_query_information_process_stub);

			const auto nt_query_system_information = ntdll.get_proc<void*>("NtQuerySystemInformation");
			nt_query_system_information_hook.create(nt_query_system_information, nt_query_system_information_stub);
			nt_query_system_information_hook.move();

			open_process_hook.create(OpenProcess, open_process_stub);

#ifndef NDEBUG
			auto* get_thread_context_func = utils::nt::library("kernelbase.dll").get_proc<void*>("GetThreadContext");
			get_thread_context_hook.create(get_thread_context_func, get_thread_context_stub);
#endif

			utils::hook::copy(this->window_text_buffer_, GetWindowTextA, sizeof(this->window_text_buffer_));
			utils::hook::jump(GetWindowTextA, get_window_text_a_stub, true, true);
			utils::hook::move_hook(GetWindowTextA);

			AddVectoredExceptionHandler(1, exception_filter);

			auto* sys_met_import = utils::nt::library{}.get_iat_entry("user32.dll", "GetSystemMetrics");
			if (sys_met_import) utils::hook::set(sys_met_import, get_system_metrics_stub);

			// TODO: Remove as soon as real hooking works
			//auto* get_cmd_import = utils::nt::library{}.get_iat_entry("kernel32.dll", "GetCommandLineA");
			//if (get_cmd_import) utils::hook::set(get_cmd_import, get_command_line_a_stub);

			//zw_terminate_process_hook.create(ntdll.get_proc<void*>("ZwTerminateProcess"), zw_terminate_process_stub);
			//zw_terminate_process_hook.move();

			//auto* gpafc = ntdll.get_proc<void*>("LdrGetProcedureAddressForCaller");
			//get_proc_address_hook.create(gpafc, get_proc_address_stub);
			//get_proc_address_hook.move();
		}

		void post_unpack() override
		{
			search_and_patch_integrity_checks();
			//restore_debug_functions();
		}

		component_priority priority() const override
		{
			return component_priority::arxan;
		}

	private:
		uint8_t window_text_buffer_[15]{};
	};
}

REGISTER_COMPONENT(arxan::component)

```

`src/client/component/auth.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "auth.hpp"

#include <game/game.hpp>

#include <utils/nt.hpp>
#include <utils/hook.hpp>
#include <utils/string.hpp>
#include <utils/smbios.hpp>
#include <utils/cryptography.hpp>

namespace auth
{
	namespace
	{
		std::string get_hdd_serial()
		{
			DWORD serial{};
			if (!GetVolumeInformationA("C:\\", nullptr, 0, &serial, nullptr, nullptr, nullptr, 0))
			{
				return {};
			}

			return utils::string::va("%08X", serial);
		}

		std::string get_hw_profile_guid()
		{
			HW_PROFILE_INFO info;
			if (!GetCurrentHwProfileA(&info))
			{
				return {};
			}

			return std::string{info.szHwProfileGuid, sizeof(info.szHwProfileGuid)};
		}

		std::string get_protected_data()
		{
			std::string input = "momo5502-boiii-auth";

			DATA_BLOB data_in{}, data_out{};
			data_in.pbData = reinterpret_cast<uint8_t*>(input.data());
			data_in.cbData = static_cast<DWORD>(input.size());
			if (CryptProtectData(&data_in, nullptr, nullptr, nullptr, nullptr, CRYPTPROTECT_LOCAL_MACHINE,
			                     &data_out) != TRUE)
			{
				return {};
			}

			const auto size = std::min(data_out.cbData, 52ul);
			std::string result{reinterpret_cast<char*>(data_out.pbData), size};
			LocalFree(data_out.pbData);

			return result;
		}

		std::string get_key_entropy()
		{
			std::string entropy{};
			entropy.append(utils::smbios::get_uuid());
			entropy.append(get_hw_profile_guid());
			entropy.append(get_protected_data());
			entropy.append(get_hdd_serial());

			if (entropy.empty())
			{
				entropy.resize(32);
				utils::cryptography::random::get_data(entropy.data(), entropy.size());
			}

			return entropy;
		}

		utils::cryptography::ecc::key& get_key()
		{
			static auto key = utils::cryptography::ecc::generate_key(512, get_key_entropy());
			return key;
		}

		bool is_second_instance()
		{
			static const auto is_first = []
			{
				static utils::nt::handle<> mutex = CreateMutexA(nullptr, FALSE, "boiii_mutex");
				return mutex && GetLastError() != ERROR_ALREADY_EXISTS;
			}();

			return !is_first;
		}
	}

	uint64_t get_guid()
	{
		static const auto guid = []() -> uint64_t
		{
			if (game::is_server() || is_second_instance())
			{
				return 0x110000100000000 | (::utils::cryptography::random::get_integer() & ~0x80000000);
			}

			return get_key().get_hash();
		}();

		return guid;
	}

	struct component final : client_component
	{
		void post_unpack() override
		{
			// Patch steam id bit check
			std::vector<std::pair<size_t, size_t>> patches{};
			const auto p = [&patches](const size_t a, const size_t b)
			{
				patches.emplace_back(a, b);
			};

			if (game::is_server())
			{
				p(0x1404747C6_g, 0x140474806_g);
				p(0x140474A24_g, 0x140474A68_g);
				p(0x140474A85_g, 0x140474AC6_g);
				p(0x140457ED0_g, 0x140457F26_g);
				p(0x140473DD8_g, 0x140473E19_g);
				p(0x1404743D5_g, 0x140474423_g);
				p(0x1404744FD_g, 0x140474553_g);
				p(0x14047462D_g, 0x140474677_g);
				p(0x140475057_g, 0x14047509F_g); // ?
				p(0x140475672_g, 0x1404756B5_g);
				p(0x140477322_g, 0x140477365_g); // ?
			}
			else
			{
				p(0x141E19D7D_g, 0x141E19DCB_g);
				p(0x141EB2D06_g, 0x141EB2D46_g);
				p(0x141EB2E3D_g, 0x141EB2E82_g);
				p(0x141EB3CC5_g, 0x141EB3D06_g);
				p(0x141E19B60_g, 0x141E19BB6_g);
				//
				p(0x141EB0F78_g, 0x141EB0FB9_g);
				p(0x141EB1038_g, 0x141EB1079_g);
				p(0x141EB25B5_g, 0x141EB2603_g);
				p(0x141EB26DD_g, 0x141EB2733_g);
				p(0x141EB280D_g, 0x141EB2857_g);

				p(0x141EB2B7A_g, 0x141EB2B8A_g);
				p(0x141EB2B91_g, 0x141EB2BC3_g);

				p(0x141EB31C7_g, 0x141EB31D7_g);
				p(0x141EB31DE_g, 0x141EB320F_g);

				p(0x141EB5407_g, 0x141EB544F_g); // ?
				p(0x141EB5A22_g, 0x141EB5A65_g);
				p(0x141EB7562_g, 0x141EB75A5_g); // ?
			}

			for (const auto& patch : patches)
			{
				utils::hook::jump(patch.first, patch.second);
			}
		}
	};
}

REGISTER_COMPONENT(auth::component)

```

`src/client/component/auth.hpp`:

```hpp
#pragma once

namespace auth
{
	uint64_t get_guid();
}

```

`src/client/component/bots.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "command.hpp"

#include <utils/nt.hpp>
#include <utils/hook.hpp>

#include <game/game.hpp>

namespace bots
{
	namespace
	{
		const std::vector<std::string>& get_bot_names()
		{
			static const auto bot_names = []
			{
				std::vector<std::string> names{
					"momo5502",
					"Maurice",
					"Jasmin",
				};

				std::random_device rd;
				std::mt19937 gen(rd());
				std::ranges::shuffle(names, gen);
				return names;
			}();

			return bot_names;
		}

		const char* get_bot_name()
		{
			static size_t current = 0;
			const auto& names = get_bot_names();

			current = (current + 1) % names.size();
			return names.at(current).data();
		}
	}

	struct component final : generic_component
	{
		void post_unpack() override
		{
			utils::hook::jump(game::select(0x141653B70, 0x1402732E0), get_bot_name);

			if (!game::is_server())
			{
				utils::hook::jump(0x141654280_g, get_bot_name);
			}

			command::add("spawnBot", [](const command::params& params)
			{
				size_t count = 1;
				if (params.size() > 1)
				{
					if (params[1] == "all"s)
					{
						count = 18;
					}
					else
					{
						count = atoi(params[1]);
					}
				}

				for (size_t i = 0; i < count; ++i)
				{
					if (!game::SV_AddTestClient())
					{
						break;
					}
				}
			});
		}
	};
}

REGISTER_COMPONENT(bots::component)

```

`src/client/component/branding.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"
#include "game/game.hpp"
#include "version.hpp"

#include "scheduler.hpp"

namespace branding
{
	namespace
	{
		void draw_branding()
		{
			constexpr auto x = 4;
			constexpr auto y = 0;
			constexpr auto scale = 0.45f;
			float color[4] = {0.666f, 0.666f, 0.666f, 0.666f};

			const auto* font = reinterpret_cast<uint32_t*(*)()>(0x141CAC8E0_g)();
			if (!font) return;

			game::R_AddCmdDrawText("BOIII: " VERSION, std::numeric_limits<int>::max(), font, static_cast<float>(x),
			                       y + static_cast<float>(font[2]) * scale,
			                       scale, scale, 0.0f, color, game::ITEM_TEXTSTYLE_NORMAL);
		}
	}

	struct component final : client_component
	{
		void post_unpack() override
		{
			scheduler::loop(draw_branding, scheduler::renderer);
		}
	};
}

REGISTER_COMPONENT(branding::component)

```

`src/client/component/chat.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"
#include "game/game.hpp"

#include <utils/string.hpp>
#include <utils/hook.hpp>

#include "command.hpp"
#include "client_command.hpp"

namespace chat
{
	namespace
	{
		void cmd_say_f(game::gentity_s* ent, const command::params_sv& params)
		{
			if (params.size() < 2)
			{
				return;
			}

			auto mode = 0;
			if (std::strcmp(params[0], "say_team") == 0)
			{
				mode = 1;
			}

			auto p = params.join(1);
			game::Scr_AddString(game::SCRIPTINSTANCE_SERVER, p.data() + 1); // Skip special char
			game::Scr_Notify_Canon(ent, game::Scr_CanonHash(params[0]), 1);

			game::G_Say(ent, nullptr, mode, p.data());
		}

		void cmd_chat_f(game::gentity_s* ent, const command::params_sv& params)
		{
			auto p = params.join(1);

			// Not a mistake! + 2 is necessary for the GSC script to receive only the actual chat text
			game::Scr_AddString(game::SCRIPTINSTANCE_SERVER, p.data() + 2);
			game::Scr_Notify_Canon(ent, game::Scr_CanonHash(params[0]), 1);

			utils::hook::invoke<void>(0x140298E70_g, ent, p.data());
		}
	}

	class component final : public server_component
	{
	public:
		void post_unpack() override
		{
			client_command::add("say", cmd_say_f);
			client_command::add("say_team", cmd_say_f);

			client_command::add("chat", cmd_chat_f);
		}
	};
}

REGISTER_COMPONENT(chat::component)

```

`src/client/component/client_command.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "game/game.hpp"

#include <utils/hook.hpp>
#include <utils/string.hpp>

#include "command.hpp"
#include "client_command.hpp"

namespace client_command
{
	namespace
	{
		std::unordered_map<std::string, callback> handlers;

		void client_command_stub(const int client_num)
		{
			const auto ent = &game::g_entities[client_num];

			if (ent->client == nullptr)
			{
				// Client is not fully in game
				return;
			}

			const command::params_sv params;

			const auto command = utils::string::to_lower(params.get(0));
			if (const auto got = handlers.find(command); got != handlers.end())
			{
				got->second(ent, params);
				return;
			}

			utils::hook::invoke<void>(0x140295C40_g, client_num);
		}
	}

	void add(const std::string& name, const callback& cmd)
	{
		const auto command = utils::string::to_lower(name);
		handlers[command] = cmd;
	}

	class component final : public server_component
	{
	public:
		void post_unpack() override
		{
			utils::hook::call(0x14052F81B_g, client_command_stub);
		}
	};
}

REGISTER_COMPONENT(client_command::component)

```

`src/client/component/client_command.hpp`:

```hpp
#pragma once

namespace client_command
{
	using callback = std::function<void(game::gentity_s* ent, const command::params_sv& params)>;
	void add(const std::string& name, const callback& cmd);
}

```

`src/client/component/colors.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "game/game.hpp"

#include <utils/hook.hpp>
#include <utils/string.hpp>

namespace colors
{
	namespace
	{
		utils::hook::detour get_player_name_hook;
		utils::hook::detour get_gamer_tag_hook;

		template <size_t index>
		void patch_color(const uint8_t r, const uint8_t g, const uint8_t b, const uint8_t a = 255)
		{
			auto* color_table = reinterpret_cast<uint8_t*>(0x142FF0E20_g);
			auto* g_color_table = reinterpret_cast<float*>(0x142FB6CF0_g);

			uint8_t color_int[4];
			color_int[0] = r;
			color_int[1] = g;
			color_int[2] = b;
			color_int[3] = a;

			utils::hook::copy(color_table + index * 4, color_int, sizeof(color_int));

			float color_float[4];
			color_float[0] = static_cast<float>(r) / 255.0f;
			color_float[1] = static_cast<float>(g) / 255.0f;
			color_float[2] = static_cast<float>(b) / 255.0f;
			color_float[3] = static_cast<float>(a) / 255.0f;

			utils::hook::copy(g_color_table + index * 4, color_float, sizeof(color_float));
		}

		uint64_t get_player_name_stub(const uint64_t client, int client_num, char* buffer, const int size,
		                              const bool has_clan_tag)
		{
			const auto res = get_player_name_hook.invoke<uint64_t>(client, client_num, buffer, size, has_clan_tag);

			if (_ReturnAddress() != reinterpret_cast<void*>(0x1406A7B56_g))
			{
				const auto val = utils::string::va("^%d%s", rand() % 7, buffer);
				strncpy_s(buffer, size, val, size);
			}

			return res;
		}

		const char* get_gamer_tag_stub(const uint64_t num)
		{
			return utils::string::va("^3%s", get_gamer_tag_hook.invoke<const char*>(num));
		}
	}

	struct component final : client_component
	{
		void post_unpack() override
		{
			patch_color<1>(255, 49, 49); // 1  - Red
			patch_color<2>(134, 192, 0); // 2  - Green
			patch_color<3>(255, 173, 34); // 3  - Yellow
			patch_color<4>(0, 135, 193); // 4  - Blue
			patch_color<5>(32, 197, 255); // 5  - Light Blue
			patch_color<6>(151, 80, 221); // 6  - Pink

			//get_player_name_hook.create(0x1413E3140_g, get_player_name_stub);
			//get_gamer_tag_hook.create(0x141EC7370_g, get_gamer_tag_stub);
		}
	};
}

REGISTER_COMPONENT(colors::component)

```

`src/client/component/command.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "command.hpp"
#include <utils/hook.hpp>
#include <utils/string.hpp>
#include <utils/memory.hpp>

#include <game/game.hpp>

namespace command
{
	namespace
	{
		std::unordered_map<std::string, command_param_function>& get_command_map()
		{
			static std::unordered_map<std::string, command_param_function> command_map{};
			return command_map;
		}

		std::unordered_map<std::string, sv_command_param_function>& get_sv_command_map()
		{
			static std::unordered_map<std::string, sv_command_param_function> command_map{};
			return command_map;
		}

		void execute_custom_command()
		{
			const params params{};
			const auto command = utils::string::to_lower(params[0]);

			auto& map = get_command_map();
			const auto entry = map.find(command);
			if (entry != map.end())
			{
				entry->second(params);
			}
		}

		void execute_custom_sv_command()
		{
			const params_sv params{};
			const auto command = utils::string::to_lower(params[0]);

			auto& map = get_sv_command_map();
			const auto entry = map.find(command);
			if (entry != map.end())
			{
				entry->second(params);
			}
		}

		game::CmdArgs* get_cmd_args()
		{
			return game::Sys_GetTLS()->cmdArgs;
		}

		void update_whitelist_stub()
		{
			game::cmd_function_s* current_function = game::cmd_functions;
			while (current_function)
			{
				current_function->autoComplete = 1;
				current_function = current_function->next;
			}
		}
	}

	struct component final : generic_component
	{
		void post_unpack() override
		{
			// Disable whitelist
			utils::hook::jump(game::select(0x1420EF190, 0x1404F9CD0), update_whitelist_stub);
		}
	};

	params::params()
		: nesting_(get_cmd_args()->nesting)
	{
		assert(this->nesting_ < game::CMD_MAX_NESTING);
	}

	int params::size() const
	{
		return get_cmd_args()->argc[this->nesting_];
	}

	params_sv::params_sv()
		: nesting_(game::sv_cmd_args->nesting)
	{
		assert(this->nesting_ < game::CMD_MAX_NESTING);
	}

	int params_sv::size() const
	{
		return game::sv_cmd_args->argc[this->nesting_];
	}

	const char* params_sv::get(const int index) const
	{
		if (index >= this->size())
		{
			return "";
		}

		return game::sv_cmd_args->argv[this->nesting_][index];
	}

	std::string params_sv::join(const int index) const
	{
		std::string result;

		for (auto i = index; i < this->size(); ++i)
		{
			if (i > index) result.append(" ");
			result.append(this->get(i));
		}

		return result;
	}

	const char* params::get(const int index) const
	{
		if (index >= this->size())
		{
			return "";
		}

		return get_cmd_args()->argv[this->nesting_][index];
	}

	std::string params::join(const int index) const
	{
		std::string result = {};

		for (auto i = index; i < this->size(); i++)
		{
			if (i > index) result.append(" ");
			result.append(this->get(i));
		}
		return result;
	}

	void add(const std::string& command, command_function function)
	{
		add(command, [f = std::move(function)](const params&)
		{
			f();
		});
	}

	void add(const std::string& command, command_param_function function)
	{
		auto lower_command = utils::string::to_lower(command);

		auto& map = get_command_map();
		const auto is_registered = map.contains(lower_command);

		map[std::move(lower_command)] = std::move(function);

		if (is_registered)
		{
			return;
		}

		auto& allocator = *utils::memory::get_allocator();
		auto* cmd_function = allocator.allocate<game::cmd_function_s>();
		const auto* cmd_string = allocator.duplicate_string(command);

		game::Cmd_AddCommandInternal(cmd_string, execute_custom_command, cmd_function);
		cmd_function->autoComplete = 1;
	}

	void add_sv(const std::string& command, sv_command_param_function function)
	{
		auto lower_command = utils::string::to_lower(command);

		auto& map = get_sv_command_map();
		const auto is_registered = map.contains(lower_command);

		map[std::move(lower_command)] = std::move(function);

		if (is_registered)
		{
			return;
		}

		auto& allocator = *utils::memory::get_allocator();
		const auto* cmd_string = allocator.duplicate_string(command);

		game::Cmd_AddCommandInternal(cmd_string, game::Cbuf_AddServerText_f, allocator.allocate<game::cmd_function_s>());
		game::Cmd_AddServerCommandInternal(cmd_string, execute_custom_sv_command, allocator.allocate<game::cmd_function_s>());
	}
}

REGISTER_COMPONENT(command::component)

```

`src/client/component/command.hpp`:

```hpp
#pragma once

namespace command
{
	class params
	{
	public:
		params();

		[[nodiscard]] int size() const;
		[[nodiscard]] const char* get(int index) const;
		[[nodiscard]] std::string join(int index) const;

		[[nodiscard]] const char* operator[](const int index) const
		{
			return this->get(index); //
		}

	private:
		int nesting_;
	};

	class params_sv
	{
	public:
		params_sv();

		[[nodiscard]] int size() const;
		[[nodiscard]] const char* get(int index) const;
		[[nodiscard]] std::string join(int index) const;

		[[nodiscard]] const char* operator[](const int index) const
		{
			return this->get(index); //
		}

	private:
		int nesting_;
	};

	using command_function = std::function<void()>;
	using command_param_function = std::function<void(const params&)>;
	using sv_command_param_function = std::function<void(const params_sv&)>;

	void add(const std::string& command, command_function function);
	void add(const std::string& command, command_param_function function);

	void add_sv(const std::string& command, sv_command_param_function function);
}

```

`src/client/component/console.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"
#include "resource.hpp"

#include "game/game.hpp"

#include <utils/thread.hpp>
#include <utils/hook.hpp>
#include <utils/concurrency.hpp>
#include <utils/image.hpp>

#define CONSOLE_BUFFER_SIZE 16384
#define WINDOW_WIDTH 608

namespace console
{
	namespace
	{
		utils::image::object logo;
		std::atomic_bool started{false};
		std::atomic_bool terminate_runner{false};
		utils::concurrency::container<std::queue<std::string>> message_queue{};

		void print_message(const char* message)
		{
#ifndef NDEBUG
			OutputDebugStringA(message);
#endif

			if (started && !terminate_runner)
			{
				game::Com_Printf(0, 0, "%s", message);
			}
		}

		void queue_message(const char* message)
		{
			message_queue.access([message](std::queue<std::string>& queue)
			{
				queue.push(message);
			});
		}

		void print_message_to_console(const char* message)
		{
			static auto print_func = utils::hook::assemble([](utils::hook::assembler& a)
			{
				a.push(rbx);
				a.mov(eax, 0x8030);
				a.jmp(game::select(0x142333667, 0x140597527));
			});

			static_cast<void(*)(const char*)>(print_func)(message);
		}

		std::queue<std::string> empty_message_queue()
		{
			std::queue<std::string> current_queue{};

			message_queue.access([&](std::queue<std::string>& queue)
			{
				current_queue = std::move(queue);
				queue = {};
			});

			return current_queue;
		}

		void print_stub(const char* fmt, ...)
		{
			va_list ap;
			va_start(ap, fmt);

			char buffer[1024]{0};
			const int res = vsnprintf_s(buffer, sizeof(buffer), _TRUNCATE, fmt, ap);
			(void)res;
			print_message(buffer);

			va_end(ap);
		}

		INT_PTR get_gray_brush()
		{
			static utils::image::object b(CreateSolidBrush(RGB(50, 50, 50)));
			return reinterpret_cast<INT_PTR>(b.get());
		}

		LRESULT con_wnd_proc(const HWND hwnd, const UINT msg, const WPARAM wparam, const LPARAM lparam)
		{
			switch (msg)
			{
			case WM_CTLCOLOREDIT:
			case WM_CTLCOLORSTATIC:
				SetBkColor(reinterpret_cast<HDC>(wparam), RGB(50, 50, 50));
				SetTextColor(reinterpret_cast<HDC>(wparam), RGB(232, 230, 227));
				return get_gray_brush();
			case WM_CLOSE:
				game::Cbuf_AddText(0, "quit\n");
				[[fallthrough]];
			default:
				return utils::hook::invoke<LRESULT>(game::select(0x142333520, 0x1405973E0), hwnd, msg, wparam, lparam);
			}
		}

		LRESULT input_line_wnd_proc(const HWND hwnd, const UINT msg, const WPARAM wparam, const LPARAM lparam)
		{
			return utils::hook::invoke<LRESULT>(game::select(0x142333820, 0x1405976E0), hwnd, msg, wparam, lparam);
		}

		void sys_create_console_stub(const HINSTANCE h_instance)
		{
			char text[CONSOLE_BUFFER_SIZE]{0};

			const auto* class_name = "BOIII WinConsole";
			const auto* window_name = game::is_server() ? "BOIII Server" : "BOIII Console";

			WNDCLASSA wnd_class{};
			wnd_class.style = 0;
			wnd_class.lpfnWndProc = con_wnd_proc;
			wnd_class.cbClsExtra = 0;
			wnd_class.cbWndExtra = 0;
			wnd_class.hInstance = h_instance;
			wnd_class.hIcon = LoadIconA(h_instance, reinterpret_cast<LPCSTR>(1));
			wnd_class.hCursor = LoadCursorA(nullptr, reinterpret_cast<LPCSTR>(0x7F00));
			wnd_class.hbrBackground = CreateSolidBrush(RGB(50, 50, 50));
			wnd_class.lpszMenuName = nullptr;
			wnd_class.lpszClassName = class_name;

			if (!RegisterClassA(&wnd_class))
			{
				return;
			}

			RECT rect{};
			rect.left = 0;
			rect.right = 620;
			rect.top = 0;
			rect.bottom = 450;
			AdjustWindowRect(&rect, 0x80CA0000, 0);

			auto dc = GetDC(GetDesktopWindow());
			const auto swidth = GetDeviceCaps(dc, 8);
			const auto sheight = GetDeviceCaps(dc, 10);
			ReleaseDC(GetDesktopWindow(), dc);

			utils::hook::set<int>(game::s_wcd::windowWidth, (rect.right - rect.left + 1));
			utils::hook::set<int>(game::s_wcd::windowHeight, (rect.bottom - rect.top + 1));

			utils::hook::set<HWND>(game::s_wcd::hWnd, CreateWindowExA(
				                       0, class_name, window_name, 0x80CA0000, (swidth - 600) / 2, (sheight - 450) / 2,
				                       rect.right - rect.left + 1, rect.bottom - rect.top + 1, nullptr, nullptr,
				                       h_instance, nullptr));

			if (!*game::s_wcd::hWnd)
			{
				return;
			}

			// create fonts
			dc = GetDC(*game::s_wcd::hWnd);
			const auto n_height = MulDiv(8, GetDeviceCaps(dc, 90), 72);

			utils::hook::set<HFONT>(game::s_wcd::hfBufferFont, CreateFontA(
				                        -n_height, 0, 0, 0, 300, 0, 0, 0, 1u, 0, 0, 0, 0x31u, "Courier New"));

			ReleaseDC(*game::s_wcd::hWnd, dc);

			if (logo)
			{
				utils::hook::set<HWND>(game::s_wcd::codLogo, CreateWindowExA(
					                       0, "Static", nullptr, 0x5000000Eu, 5, 5, 0, 0, *game::s_wcd::hWnd,
					                       reinterpret_cast<HMENU>(1), h_instance, nullptr));
				SendMessageA(*game::s_wcd::codLogo, STM_SETIMAGE, IMAGE_BITMAP, logo);
			}

			// create the input line
			utils::hook::set<HWND>(game::s_wcd::hwndInputLine, CreateWindowExA(
				                       0, "edit", nullptr, 0x50800080u, 6, 400, WINDOW_WIDTH, 20, *game::s_wcd::hWnd,
				                       reinterpret_cast<HMENU>(0x65), h_instance, nullptr));
			utils::hook::set<HWND>(game::s_wcd::hwndBuffer, CreateWindowExA(
				                       0, "edit", nullptr, 0x50A00844u, 6, 70, WINDOW_WIDTH, 324, *game::s_wcd::hWnd,
				                       reinterpret_cast<HMENU>(0x64), h_instance, nullptr));
			SendMessageA(*game::s_wcd::hwndBuffer, WM_SETFONT, reinterpret_cast<WPARAM>(*game::s_wcd::hfBufferFont), 0);

			utils::hook::set<WNDPROC>(game::s_wcd::SysInputLineWndProc, reinterpret_cast<WNDPROC>(SetWindowLongPtrA(
				                          *game::s_wcd::hwndInputLine, -4,
				                          reinterpret_cast<LONG_PTR>(input_line_wnd_proc))));
			SendMessageA(*game::s_wcd::hwndInputLine, WM_SETFONT, reinterpret_cast<WPARAM>(*game::s_wcd::hfBufferFont),
			             0);

			SetFocus(*game::s_wcd::hwndInputLine);
			game::Con_GetTextCopy(text, std::min(0x4000, static_cast<int>(sizeof(text))));
			SetWindowTextA(*game::s_wcd::hwndBuffer, text);
		}
	}

	struct component final : generic_component
	{
		void post_unpack() override
		{
			utils::hook::jump(printf, print_stub);

			if (!game::is_server())
			{
				utils::hook::set<uint8_t>(0x14133D2FE_g, 0xEB); // Always enable ingame console
			}

			utils::hook::jump(game::select(0x1423337F0, 0x1405976B0), queue_message);
			utils::hook::nop(game::select(0x14233380A, 0x1405976CA), 2); // Print from every thread

			//const auto self = utils::nt::library::get_by_address(sys_create_console_stub);
			//logo = LoadImageA(self.get_handle(), MAKEINTRESOURCEA(IMAGE_LOGO), 0, 0, 0, LR_COPYFROMRESOURCE);

			const auto res = utils::nt::load_resource(IMAGE_LOGO);
			const auto img = utils::image::load_image(res);
			logo = utils::image::create_bitmap(img);

			terminate_runner = false;

			this->message_runner_ = utils::thread::create_named_thread("Console IO", []
			{
				while (!terminate_runner)
				{
					std::string message_buffer{};
					auto current_queue = empty_message_queue();

					while (!current_queue.empty())
					{
						const auto& msg = current_queue.front();
						message_buffer.append(msg);
						current_queue.pop();
					}

					if (!message_buffer.empty())
					{
						print_message_to_console(message_buffer.data());
					}

					std::this_thread::sleep_for(5ms);
				}
			});

			this->console_runner_ = utils::thread::create_named_thread("Console Window", [this]
			{
				{
					static utils::hook::detour sys_create_console_hook;
					sys_create_console_hook.create(game::select(0x1423339C0, 0x140597880), sys_create_console_stub);

					game::Sys_ShowConsole();
					started = true;
				}

				MSG msg{};
				while (!terminate_runner)
				{
					if (PeekMessageW(&msg, nullptr, NULL, NULL, PM_REMOVE))
					{
						TranslateMessage(&msg);
						DispatchMessageW(&msg);
					}
					else
					{
						std::this_thread::sleep_for(5ms);
					}
				}
			});

			while (!started)
			{
				std::this_thread::sleep_for(10ms);
			}
		}

		void pre_destroy() override
		{
			terminate_runner = true;

			if (this->message_runner_.joinable())
			{
				this->message_runner_.join();
			}

			if (this->console_runner_.joinable())
			{
				this->console_runner_.join();
			}
		}

	private:
		std::thread console_runner_{};
		std::thread message_runner_{};
	};
}

REGISTER_COMPONENT(console::component)

```

`src/client/component/console_command.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "game/game.hpp"

#include <utils/hook.hpp>
#include <utils/string.hpp>

#include "command.hpp"
#include "console_command.hpp"

namespace console_command
{
	namespace
	{
		utils::hook::detour console_command_hook;

		std::unordered_map<std::string, callback> handlers;

		int console_command_stub()
		{
			const command::params params;

			const auto command = utils::string::to_lower(params.get(0));
			if (const auto got = handlers.find(command); got != handlers.end())
			{
				got->second(params);
				return 1;
			}

			return console_command_hook.invoke<int>();
		}
	}

	void add_console(const std::string& name, const callback& cmd)
	{
		const auto command = utils::string::to_lower(name);
		handlers[command] = cmd;
	}

	class component final : public server_component
	{
	public:
		void post_unpack() override
		{
			console_command_hook.create(0x1402FF8C0_g, &console_command_stub);
		}
	};
}

REGISTER_COMPONENT(console_command::component)

```

`src/client/component/console_command.hpp`:

```hpp
#pragma once

namespace console_command
{
	using callback = std::function<void(const command::params& params)>;
	void add_console(const std::string& name, const callback& cmd);
}

```

`src/client/component/dedi_patches.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "game/game.hpp"

#include <utils/hook.hpp>

namespace patches
{
	namespace
	{
		void scr_are_textures_loaded_stub([[maybe_unused]] game::scriptInstance_t inst)
		{
			game::Scr_AddInt(game::SCRIPTINSTANCE_SERVER, 1);
		}
	}

	struct component final : server_component
	{
		void post_unpack() override
		{
			// Fix infinite loop
			utils::hook::jump(0x1402E86B0_g, scr_are_textures_loaded_stub);
		}
	};
}

REGISTER_COMPONENT(patches::component)

```

`src/client/component/dedicated.cpp`:

```cpp
#include <std_include.hpp>
#include "dedicated.hpp"
#include "loader/component_loader.hpp"

#include "game/game.hpp"
#include "command.hpp"
#include "network.hpp"
#include "scheduler.hpp"
#include "server_list.hpp"

#include <utils/hook.hpp>

namespace dedicated
{
	namespace
	{
		void sv_con_tell_f_stub(game::client_s* cl_0, game::svscmd_type type, [[maybe_unused]] const char* fmt,
		                        [[maybe_unused]] int c, char* text)
		{
			game::SV_SendServerCommand(cl_0, type, "%c \"GAME_SERVER\x15: %s\"", 79, text);
		}
	}

	void send_heartbeat()
	{
		if (!game::is_server())
		{
			return;
		}

		game::netadr_t target{};
		if (server_list::get_master_server(target))
		{
			network::send(target, "heartbeat", "T7");
		}
	}

	struct component final : server_component
	{
		void post_unpack() override
		{
			// Ignore "bad stats"
			//utils::hook::set<uint8_t>(0x14052D523_g, 0xEB);
			//utils::hook::nop(0x14052D4E4_g, 2);

			// Fix tell command for IW4M
			utils::hook::call(0x14052A8CF_g, sv_con_tell_f_stub);

			scheduler::loop(send_heartbeat, scheduler::pipeline::server, 10min);
			command::add("heartbeat", send_heartbeat);
		}
	};
}

REGISTER_COMPONENT(dedicated::component)

```

`src/client/component/dedicated.hpp`:

```hpp
#pragma once

namespace dedicated
{
	void send_heartbeat();
}

```

`src/client/component/demonware.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include <utils/hook.hpp>
#include <utils/thread.hpp>

#include "game/game.hpp"
#include "game/demonware/servers/lobby_server.hpp"
#include "game/demonware/servers/auth3_server.hpp"
#include "game/demonware/servers/stun_server.hpp"
#include "game/demonware/servers/umbrella_server.hpp"
#include "game/demonware/server_registry.hpp"

#define TCP_BLOCKING true
#define UDP_BLOCKING false

namespace demonware
{
	namespace
	{
		std::atomic_bool exit_server{false};
		std::thread server_thread{};
		utils::concurrency::container<std::unordered_map<SOCKET, bool>> blocking_sockets{};
		utils::concurrency::container<std::unordered_map<SOCKET, tcp_server*>> socket_map{};
		server_registry<tcp_server> tcp_servers{};
		server_registry<udp_server> udp_servers{};
		std::unordered_map<void*, void*> original_imports{};

		tcp_server* find_server(const SOCKET socket)
		{
			return socket_map.access<tcp_server*>([&](const std::unordered_map<SOCKET, tcp_server*>& map) -> tcp_server*
			{
				const auto entry = map.find(socket);
				if (entry == map.end())
				{
					return nullptr;
				}

				return entry->second;
			});
		}

		bool socket_link(const SOCKET socket, const uint32_t address)
		{
			auto* server = tcp_servers.find(address);
			if (!server)
			{
				return false;
			}

			socket_map.access([&](std::unordered_map<SOCKET, tcp_server*>& map)
			{
				map[socket] = server;
			});

			return true;
		}

		void socket_unlink(const SOCKET socket)
		{
			socket_map.access([&](std::unordered_map<SOCKET, tcp_server*>& map)
			{
				const auto entry = map.find(socket);
				if (entry != map.end())
				{
					map.erase(entry);
				}
			});
		}

		bool is_socket_blocking(const SOCKET socket, const bool def)
		{
			return blocking_sockets.access<bool>([&](std::unordered_map<SOCKET, bool>& map)
			{
				const auto entry = map.find(socket);
				if (entry == map.end())
				{
					return def;
				}

				return entry->second;
			});
		}

		void remove_blocking_socket(const SOCKET socket)
		{
			blocking_sockets.access([&](std::unordered_map<SOCKET, bool>& map)
			{
				const auto entry = map.find(socket);
				if (entry != map.end())
				{
					map.erase(entry);
				}
			});
		}

		void add_blocking_socket(const SOCKET socket, const bool block)
		{
			blocking_sockets.access([&](std::unordered_map<SOCKET, bool>& map)
			{
				map[socket] = block;
			});
		}

		void server_main()
		{
			exit_server = false;

			while (!exit_server)
			{
				tcp_servers.frame();
				udp_servers.frame();
				std::this_thread::sleep_for(50ms);
			}
		}

		namespace io
		{
			int getaddrinfo_stub(const char* name, const char* service,
			                     const addrinfo* hints, addrinfo** res)
			{
#ifndef NDEBUG
				printf("[ network ]: [getaddrinfo]: \"%s\" \"%s\"\n", name, service);
#endif

				base_server* server = tcp_servers.find(name);
				if (!server)
				{
					server = udp_servers.find(name);
				}

				if (!server)
				{
					return getaddrinfo(name, service, hints, res);
				}

				const auto address = utils::memory::get_allocator()->allocate<sockaddr>();
				const auto ai = utils::memory::get_allocator()->allocate<addrinfo>();

				auto in_addr = reinterpret_cast<sockaddr_in*>(address);
				in_addr->sin_addr.s_addr = server->get_address();
				in_addr->sin_family = AF_INET;

				ai->ai_family = AF_INET;
				ai->ai_socktype = SOCK_STREAM;
				ai->ai_addr = address;
				ai->ai_addrlen = sizeof(sockaddr);
				ai->ai_next = nullptr;
				ai->ai_flags = 0;
				ai->ai_protocol = 0;
				ai->ai_canonname = const_cast<char*>(name);

				*res = ai;

				return 0;
			}

			void freeaddrinfo_stub(addrinfo* ai)
			{
				if (!utils::memory::get_allocator()->find(ai))
				{
					return freeaddrinfo(ai);
				}

				utils::memory::get_allocator()->free(ai->ai_addr);
				utils::memory::get_allocator()->free(ai);
			}

			int getpeername_stub(const SOCKET s, sockaddr* addr, socklen_t* addrlen)
			{
				auto* server = find_server(s);

				if (server)
				{
					auto in_addr = reinterpret_cast<sockaddr_in*>(addr);
					in_addr->sin_addr.s_addr = server->get_address();
					in_addr->sin_family = AF_INET;
					*addrlen = sizeof(sockaddr);

					return 0;
				}

				return getpeername(s, addr, addrlen);
			}

			int getsockname_stub(const SOCKET s, sockaddr* addr, socklen_t* addrlen)
			{
				auto* server = find_server(s);

				if (server)
				{
					auto in_addr = reinterpret_cast<sockaddr_in*>(addr);
					in_addr->sin_addr.s_addr = server->get_address();
					in_addr->sin_family = AF_INET;
					*addrlen = sizeof(sockaddr);

					return 0;
				}

				return getsockname(s, addr, addrlen);
			}

			hostent* gethostbyname_stub(const char* name)
			{
#ifndef NDEBUG
				printf("[ network ]: [gethostbyname]: \"%s\"\n", name);
#endif

				base_server* server = tcp_servers.find(name);
				if (!server)
				{
					server = udp_servers.find(name);
				}

				if (!server)
				{
#pragma warning(push)
#pragma warning(disable: 4996)
					return gethostbyname(name);
#pragma warning(pop)
				}

				static thread_local in_addr address{};
				address.s_addr = server->get_address();

				static thread_local in_addr* addr_list[2]{};
				addr_list[0] = &address;
				addr_list[1] = nullptr;

				static thread_local hostent host{};
				host.h_name = const_cast<char*>(name);
				host.h_aliases = nullptr;
				host.h_addrtype = AF_INET;
				host.h_length = sizeof(in_addr);
				host.h_addr_list = reinterpret_cast<char**>(addr_list);

				return &host;
			}

			int connect_stub(const SOCKET s, const struct sockaddr* addr, const int len)
			{
				if (len == sizeof(sockaddr_in))
				{
					const auto* in_addr = reinterpret_cast<const sockaddr_in*>(addr);
					if (socket_link(s, in_addr->sin_addr.s_addr)) return 0;
				}

				return connect(s, addr, len);
			}

			int closesocket_stub(const SOCKET s)
			{
				remove_blocking_socket(s);
				socket_unlink(s);

				return closesocket(s);
			}

			int send_stub(const SOCKET s, const char* buf, const int len, const int flags)
			{
				auto* server = find_server(s);

				if (server)
				{
					server->handle_input(buf, len);
					return len;
				}

				return send(s, buf, len, flags);
			}

			int recv_stub(const SOCKET s, char* buf, const int len, const int flags)
			{
				auto* server = find_server(s);

				if (server)
				{
					if (server->pending_data())
					{
						return static_cast<int>(server->handle_output(buf, len));
					}
					else
					{
						WSASetLastError(WSAEWOULDBLOCK);
						return -1;
					}
				}

				return recv(s, buf, len, flags);
			}

			int sendto_stub(const SOCKET s, const char* buf, const int len, const int flags, const sockaddr* to,
			                const int tolen)
			{
				const auto* in_addr = reinterpret_cast<const sockaddr_in*>(to);
				auto* server = udp_servers.find(in_addr->sin_addr.s_addr);

				if (server)
				{
					server->handle_input(buf, len, {s, to, tolen});
					return len;
				}

				return sendto(s, buf, len, flags, to, tolen);
			}

			int recvfrom_stub(const SOCKET s, char* buf, const int len, const int flags, struct sockaddr* from,
			                  int* fromlen)
			{
				// Not supported yet
				if (is_socket_blocking(s, UDP_BLOCKING))
				{
					return recvfrom(s, buf, len, flags, from, fromlen);
				}

				size_t result = 0;
				udp_servers.for_each([&](udp_server& server)
				{
					if (server.pending_data(s))
					{
						result = server.handle_output(
							s, buf, static_cast<size_t>(len), from, fromlen);
					}
				});

				if (result)
				{
					return static_cast<int>(result);
				}

				return recvfrom(s, buf, len, flags, from, fromlen);
			}

			int select_stub(const int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds,
			                struct timeval* timeout)
			{
				if (exit_server)
				{
					return select(nfds, readfds, writefds, exceptfds, timeout);
				}

				auto result = 0;
				std::vector<SOCKET> read_sockets;
				std::vector<SOCKET> write_sockets;

				socket_map.access([&](std::unordered_map<SOCKET, tcp_server*>& sockets)
				{
					for (auto& s : sockets)
					{
						if (readfds)
						{
							if (FD_ISSET(s.first, readfds))
							{
								if (s.second->pending_data())
								{
									read_sockets.push_back(s.first);
									FD_CLR(s.first, readfds);
								}
							}
						}

						if (writefds)
						{
							if (FD_ISSET(s.first, writefds))
							{
								write_sockets.push_back(s.first);
								FD_CLR(s.first, writefds);
							}
						}

						if (exceptfds)
						{
							if (FD_ISSET(s.first, exceptfds))
							{
								FD_CLR(s.first, exceptfds);
							}
						}
					}
				});

				if ((!readfds || readfds->fd_count == 0) && (!writefds || writefds->fd_count == 0))
				{
					timeout->tv_sec = 0;
					timeout->tv_usec = 0;
				}

				result = select(nfds, readfds, writefds, exceptfds, timeout);
				if (result < 0) result = 0;

				for (const auto& socket : read_sockets)
				{
					if (readfds)
					{
						FD_SET(socket, readfds);
						result++;
					}
				}

				for (const auto& socket : write_sockets)
				{
					if (writefds)
					{
						FD_SET(socket, writefds);
						result++;
					}
				}

				return result;
			}

			int ioctlsocket_stub(const SOCKET s, const long cmd, u_long* argp)
			{
				if (static_cast<unsigned long>(cmd) == (FIONBIO))
				{
					add_blocking_socket(s, *argp == 0);
				}

				return ioctlsocket(s, cmd, argp);
			}
		}

		void register_hook(const std::string& process, void* stub)
		{
			const utils::nt::library game_module{};

			std::optional<std::pair<void*, void*>> result{};
			if (!result) result = utils::hook::iat(game_module, "wsock32.dll", process, stub);
			if (!result) result = utils::hook::iat(game_module, "WS2_32.dll", process, stub);

			if (!result)
			{
				throw std::runtime_error("Failed to hook: " + process);
			}

			original_imports[result->first] = result->second;
		}

		const char* get_ffotd_name()
		{
			return "core_ffotd_tu32_593";
		}
	}

	struct component final : generic_component
	{
		component()
		{
			udp_servers.create<stun_server>("stun.us.demonware.net");
			udp_servers.create<stun_server>("stun.eu.demonware.net");
			udp_servers.create<stun_server>("stun.jp.demonware.net");
			udp_servers.create<stun_server>("stun.au.demonware.net");

			tcp_servers.create<auth3_server>("ops3-pc-auth3.prod.demonware.net");
			tcp_servers.create<lobby_server>("ops3-pc-lobby.prod.demonware.net");
			tcp_servers.create<umbrella_server>("prod.umbrella.demonware.net");
		}

		void post_load() override
		{
			register_hook("send", io::send_stub);
			register_hook("recv", io::recv_stub);
			register_hook("sendto", io::sendto_stub);
			register_hook("recvfrom", io::recvfrom_stub);
			register_hook("connect", io::connect_stub);
			register_hook("select", io::select_stub);
			register_hook("closesocket", io::closesocket_stub);
			register_hook("ioctlsocket", io::ioctlsocket_stub);
			register_hook("gethostbyname", io::gethostbyname_stub);
			register_hook("getaddrinfo", io::getaddrinfo_stub);
			register_hook("freeaddrinfo", io::freeaddrinfo_stub);
			register_hook("getpeername", io::getpeername_stub);
			register_hook("getsockname", io::getsockname_stub);
		}

		void post_unpack() override
		{
			server_thread = utils::thread::create_named_thread("Demonware", server_main);


			utils::hook::set<uint8_t>(game::select(0x14293E829, 0x1407D5879), 0x0); // CURLOPT_SSL_VERIFYPEER
			utils::hook::set<uint8_t>(game::select(0x15F3CCFED, 0x1407D5865), 0xAF); // CURLOPT_SSL_VERIFYHOST

			utils::hook::copy_string(game::select(0x1430B96E0, 0x140EE4C68), "http://prod.umbrella.demonware.net");

			if (game::is_server())
			{
				return;
			}

			utils::hook::copy_string(0x1430B9BE0_g, "http://prod.uno.demonware.net/v1.0");

			utils::hook::set<uint8_t>(0x1430B9810_g, 0x0); // HTTPS -> HTTP
			utils::hook::copy_string(0x1430B93C8_g, "http://%s:%d/auth/");

			utils::hook::set<uint32_t>(0x141EC4B50_g, 0xC3D08948); // Skip publisher file signature stuff
			utils::hook::call(0x141EC458C_g, get_ffotd_name); // Return unlocalized ffotd name
			utils::hook::set<uint64_t>(0x141F04550_g, 0xC300000001B8); // Kill LPC_File_SafeWrite
			utils::hook::set<uint64_t>(0x141F03180_g, 0xC300000001B8); // Kill LPC_DeleteStale

			utils::hook::set<uint8_t>(0x141E0AAAB_g, 0xEB); // Release un-handled reportReward spamming loop
		}

		void pre_destroy() override
		{
			exit_server = true;
			if (server_thread.joinable())
			{
				server_thread.join();
			}

			for (const auto& import : original_imports)
			{
				utils::hook::set(import.first, import.second);
			}
		}
	};
}

REGISTER_COMPONENT(demonware::component)

```

`src/client/component/discord.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include <discord_rpc.h>

#include "scheduler.hpp"

namespace discord
{
	namespace
	{
		void ready(const DiscordUser* /*request*/)
		{
			printf("Discord: Ready\n");

			DiscordRichPresence discord_presence{};
			ZeroMemory(&discord_presence, sizeof(discord_presence));

			discord_presence.instance = 1;
			//discord_presence.state = "BOIII";

			discord_presence.partySize = 0;
			discord_presence.partyMax = 0;
			discord_presence.startTimestamp = 0;

			Discord_UpdatePresence(&discord_presence);
		}

		void errored(const int error_code, const char* message)
		{
			printf("Discord: Error (%i): %s\n", error_code, message);
		}
	}

	class component final : public client_component
	{
	public:
		void post_load() override
		{
			DiscordEventHandlers handlers;
			ZeroMemory(&handlers, sizeof(handlers));
			handlers.ready = ready;
			handlers.errored = errored;
			handlers.disconnected = errored;
			handlers.joinGame = nullptr;
			handlers.spectateGame = nullptr;
			handlers.joinRequest = nullptr;

			Discord_Initialize("1047539933922988112", &handlers, 1, nullptr);

			this->initialized_ = true;

			scheduler::loop(Discord_RunCallbacks, scheduler::pipeline::async, 1s);
		}

		void pre_destroy() override
		{
			if (this->initialized_)
			{
				Discord_Shutdown();
			}
		}

	private:
		bool initialized_ = false;
	};
}

#ifndef DEV_BUILD
REGISTER_COMPONENT(discord::component)
#endif

```

`src/client/component/exception.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "game/game.hpp"

#include <utils/hook.hpp>
#include <utils/io.hpp>
#include <utils/string.hpp>
#include <utils/thread.hpp>
#include <utils/compression.hpp>

#include <exception/minidump.hpp>

#include <version.hpp>

namespace exception
{
	namespace
	{
		DWORD main_thread_id{};

		thread_local struct
		{
			DWORD code = 0;
			PVOID address = nullptr;
		} exception_data{};

		struct
		{
			std::chrono::time_point<std::chrono::high_resolution_clock> last_recovery{};
			std::atomic<int> recovery_counts = {0};
		} recovery_data{};

		bool is_game_thread()
		{
			return main_thread_id == GetCurrentThreadId();
		}

		bool is_exception_interval_too_short()
		{
			const auto delta = std::chrono::high_resolution_clock::now() - recovery_data.last_recovery;
			return delta < 1min;
		}

		bool too_many_exceptions_occured()
		{
			return recovery_data.recovery_counts >= 3;
		}

		volatile bool& is_initialized()
		{
			static volatile bool initialized = false;
			return initialized;
		}

		bool is_recoverable()
		{
			return is_initialized()
				&& is_game_thread()
				&& !is_exception_interval_too_short()
				&& !too_many_exceptions_occured();
		}

		void show_mouse_cursor()
		{
			while (ShowCursor(TRUE) < 0);
		}

		void display_error_dialog()
		{
			const std::string error_str = utils::string::va("Fatal error (0x%08X) at 0x%p (0x%p).\n"
			                                                "A minidump has been written.\n",
			                                                exception_data.code, exception_data.address,
				                                            game::derelocate(reinterpret_cast<uint64_t>(exception_data.address)));

			utils::thread::suspend_other_threads();
			show_mouse_cursor();

			MessageBoxA(nullptr, error_str.data(), "BOIII ERROR", MB_ICONERROR);
			TerminateProcess(GetCurrentProcess(), exception_data.code);
		}

		void reset_state()
		{
			if (is_recoverable())
			{
				recovery_data.last_recovery = std::chrono::high_resolution_clock::now();
				++recovery_data.recovery_counts;

				game::Com_Error(game::ERR_DROP, "Fatal error (0x%08X) at 0x%p (0x%p).\nA minidump has been written.\n\n"
				                "BOIII has tried to recover your game, but it might not run stable anymore.\n\n"
				                "Make sure to update your graphics card drivers and install operating system updates!\n"
				                "Closing or restarting Steam might also help.",
				                exception_data.code, exception_data.address,
					            game::derelocate(reinterpret_cast<uint64_t>(exception_data.address)));
			}
			else
			{
				display_error_dialog();
			}
		}

		size_t get_reset_state_stub()
		{
			static auto* stub = utils::hook::assemble([](utils::hook::assembler& a)
			{
				a.sub(rsp, 0x10);
				a.or_(rsp, 0x8);
				a.jmp(reset_state);
			});

			return reinterpret_cast<size_t>(stub);
		}

		std::string get_timestamp()
		{
			tm ltime{};
			char timestamp[MAX_PATH] = {0};
			const auto time = _time64(nullptr);

			_localtime64_s(&ltime, &time);
			strftime(timestamp, sizeof(timestamp) - 1, "%Y-%m-%d-%H-%M-%S", &ltime);

			return timestamp;
		}

		std::string generate_crash_info(const LPEXCEPTION_POINTERS exceptioninfo)
		{
			std::string info{};
			const auto line = [&info](const std::string& text)
			{
				info.append(text);
				info.append("\r\n");
			};

			line("BOIII Crash Dump");
			line("");
			line("Version: "s + VERSION);
			line("Timestamp: "s + get_timestamp());
			line(utils::string::va("Exception: 0x%08X", exceptioninfo->ExceptionRecord->ExceptionCode));
			line(utils::string::va("Address: 0x%llX", exceptioninfo->ExceptionRecord->ExceptionAddress));
			line(utils::string::va("Base: 0x%llX", game::get_base()));

#pragma warning(push)
#pragma warning(disable: 4996)
			OSVERSIONINFOEXA version_info;
			ZeroMemory(&version_info, sizeof(version_info));
			version_info.dwOSVersionInfoSize = sizeof(version_info);
			GetVersionExA(reinterpret_cast<LPOSVERSIONINFOA>(&version_info));
#pragma warning(pop)

			line(utils::string::va("OS Version: %u.%u", version_info.dwMajorVersion, version_info.dwMinorVersion));

			return info;
		}

		void write_minidump(const LPEXCEPTION_POINTERS exceptioninfo)
		{
			const std::string crash_name = utils::string::va("minidumps/boiii-crash-%s.zip",
			                                                 get_timestamp().data());

			utils::compression::zip::archive zip_file{};
			zip_file.add("crash.dmp", create_minidump(exceptioninfo));
			zip_file.add("info.txt", generate_crash_info(exceptioninfo));
			zip_file.write(crash_name, "BOIII Crash Dump");
		}

		bool is_harmless_error(const LPEXCEPTION_POINTERS exceptioninfo)
		{
			const auto code = exceptioninfo->ExceptionRecord->ExceptionCode;
			return code == STATUS_INTEGER_OVERFLOW || code == STATUS_FLOAT_OVERFLOW || code == STATUS_SINGLE_STEP;
		}

		LONG WINAPI exception_filter(const LPEXCEPTION_POINTERS exceptioninfo)
		{
			if (is_harmless_error(exceptioninfo))
			{
				return EXCEPTION_CONTINUE_EXECUTION;
			}

			write_minidump(exceptioninfo);

			exception_data.code = exceptioninfo->ExceptionRecord->ExceptionCode;
			exception_data.address = exceptioninfo->ExceptionRecord->ExceptionAddress;
			exceptioninfo->ContextRecord->Rip = get_reset_state_stub();

			return EXCEPTION_CONTINUE_EXECUTION;
		}

		void WINAPI set_unhandled_exception_filter_stub(LPTOP_LEVEL_EXCEPTION_FILTER)
		{
			// Don't register anything here...
		}
	}

	struct component final : generic_component
	{
		component()
		{
			main_thread_id = GetCurrentThreadId();
			SetUnhandledExceptionFilter(exception_filter);
		}

		void post_load() override
		{
			const utils::nt::library ntdll("ntdll.dll");
			auto* set_filter = ntdll.get_proc<void(*)(LPTOP_LEVEL_EXCEPTION_FILTER)>("RtlSetUnhandledExceptionFilter");

			set_filter(exception_filter);
			utils::hook::jump(set_filter, set_unhandled_exception_filter_stub);
		}
	};
}

REGISTER_COMPONENT(exception::component)

```

`src/client/component/game_log.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "game/game.hpp"

#include <utils/hook.hpp>
#include <utils/string.hpp>
#include <utils/io.hpp>

namespace game_log
{
	namespace
	{
		void g_scr_log_print()
		{
			char string[1024]{};
			std::size_t i_string_len = 0;

			const auto i_num_parms = game::Scr_GetNumParam(game::SCRIPTINSTANCE_SERVER);
			for (std::uint32_t i = 0; i < i_num_parms; ++i)
			{
				const auto* psz_token = game::Scr_GetString(game::SCRIPTINSTANCE_SERVER, i);
				const auto i_token_len = std::strlen(psz_token);

				i_string_len += i_token_len;
				if (i_string_len >= sizeof(string))
				{
					// Do not overflow the buffer
					break;
				}

				strncat_s(string, psz_token, _TRUNCATE);
			}

			game::G_LogPrintf("%s", string);
		}

		void g_log_printf_stub(const char* fmt, ...)
		{
			char va_buffer[0x400] = { 0 };

			va_list ap;
			va_start(ap, fmt);
			vsprintf_s(va_buffer, fmt, ap);
			va_end(ap);

			const auto* file = "games_mp.log";
			const auto time = *game::level_time / 1000;

			utils::io::write_file(file, utils::string::va("%3i:%i%i %s",
				time / 60,
				time % 60 / 10,
				time % 60 % 10,
				va_buffer
			), true);
		}
	}

	class component final : public server_component
	{
	public:
		void post_unpack() override
		{
			// Fix format string vulnerability & make it work
			utils::hook::jump(0x1402D9300_g, g_scr_log_print);
			utils::hook::jump(0x1402A7BB0_g, g_log_printf_stub);
		}
	};
}

REGISTER_COMPONENT(game_log::component)

```

`src/client/component/getinfo.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "game/game.hpp"
#include "steam/steam.hpp"

#include "network.hpp"

#include <utils/hook.hpp>
#include <utils/string.hpp>
#include <utils/info_string.hpp>

#include <version.hpp>

namespace getinfo
{
	namespace
	{
		std::string get_dvar_string(const char* dvar_name)
		{
			const auto dvar = game::Dvar_FindVar(dvar_name);
			if (!dvar)
			{
				return {};
			}

			return game::Dvar_GetString(dvar);
		}

		int get_dvar_int(const char* dvar_name)
		{
			const auto dvar = game::Dvar_FindVar(dvar_name);
			if (!dvar)
			{
				return {};
			}

			return game::Dvar_GetInt(dvar);
		}

		int get_max_client_count()
		{
			return get_dvar_int("com_maxclients");
		}

		int get_client_count()
		{
			int count = 0;
			const auto client_states = *reinterpret_cast<uint64_t*>(game::select(0x1576FB318, 0x14A178E98));
			const auto object_length = game::is_server() ? 0xE5110 : 0xE5170;

			for (int i = 0; i < get_max_client_count(); ++i)
			{
				const auto client_state = *reinterpret_cast<int*>(client_states + (i * object_length));
				if (client_state > 0)
				{
					++count;
				}
			}

			return count;
		}

		int Com_SessionMode_GetGameMode()
		{
			return *reinterpret_cast<int*>(game::select(0x1568EF7F4, 0x14948DB04)) << 14 >> 28;
		}
	}

	int get_assigned_team()
	{
		return (rand() % 2) + 1;
	}

	struct component final : generic_component
	{
		void post_unpack() override
		{
			//utils::hook::jump(game::select(0x142254EF0, 0x140537730), get_assigned_team);

			network::on("getInfo", [](const game::netadr_t& target, const network::data_view& data)
			{
				utils::info_string info{};
				info.set("challenge", std::string(data.begin(), data.end()));
				info.set("gamename", "T7");
				info.set("hostname", get_dvar_string(game::is_server() ? "live_steam_server_name" : "sv_hostname"));
				info.set("gametype", get_dvar_string("g_gametype"));
				//info.set("sv_motd", get_dvar_string("sv_motd"));
				info.set("description", game::is_server() ? get_dvar_string("live_steam_server_description") : "");
				info.set("xuid", utils::string::va("%llX", steam::SteamUser()->GetSteamID().bits));
				info.set("mapname", get_dvar_string("mapname"));
				info.set("isPrivate", get_dvar_string("g_password").empty() ? "0" : "1");
				info.set("clients", utils::string::va("%i", get_client_count()));
				info.set("bots", utils::string::va("%i", /*get_bot_count()*/0));
				info.set("sv_maxclients", utils::string::va("%i", get_max_client_count()));
				info.set("protocol", utils::string::va("%i", PROTOCOL));
				info.set("playmode", utils::string::va("%i", game::Com_SessionMode_GetMode()));
				info.set("gamemode", utils::string::va("%i", Com_SessionMode_GetGameMode()));
				//info.set("sv_running", utils::string::va("%i", get_dvar_bool("sv_running")));
				info.set("dedicated", utils::string::va("%i", game::is_server() ? 1 : 0));
				info.set("shortversion", SHORTVERSION);

				network::send(target, "infoResponse", info.build(), '\n');
			});
		}
	};
}

REGISTER_COMPONENT(getinfo::component)

```

`src/client/component/icon.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"
#include "resource.hpp"

#include <utils/nt.hpp>
#include <utils/hook.hpp>

namespace icon
{
	namespace
	{
		utils::hook::detour load_icon_a_hook;

		HINSTANCE get_current_module()
		{
			return utils::nt::library::get_by_address(get_current_module);
		}

		HICON WINAPI load_icon_a_stub(HINSTANCE module, LPCSTR icon_name)
		{
			static const utils::nt::library game{};
			if (game == module && icon_name == MAKEINTRESOURCEA(1))
			{
				module = get_current_module();
				icon_name = MAKEINTRESOURCEA(ID_ICON);
			}

			return load_icon_a_hook.invoke<HICON>(module, icon_name);
		}
	}

	struct component final : generic_component
	{
		void post_load() override
		{
			load_icon_a_hook.create(LoadIconA, load_icon_a_stub);
		}
	};
}

//REGISTER_COMPONENT(icon::component)

```

`src/client/component/intro.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"
#include "game/game.hpp"

#include <utils/hook.hpp>

namespace intro
{
	namespace
	{
		utils::hook::detour cinematic_start_playback_hook;

		void ccc(const char* name, const char* key, const unsigned int playback_flags, const float volume,
		         void* callback_info, const int id)
		{
			if (name == "BO3_Global_Logo_LogoSequence"s)
			{
				return;
			}

			cinematic_start_playback_hook.invoke(name, key, playback_flags, volume, callback_info, id);
		}
	}

	class component final : public client_component
	{
	public:
		void post_unpack() override
		{
			cinematic_start_playback_hook.create(game::Cinematic_StartPlayback, ccc);
		}
	};
}

#ifdef DEV_BUILD
REGISTER_COMPONENT(intro::component)
#endif

```

`src/client/component/loot.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include <utils/hook.hpp>

#include "scheduler.hpp"
#include "game/game.hpp"

namespace loot
{
	namespace
	{
		utils::hook::detour loot_getitemquantity_hook;
		utils::hook::detour liveinventory_getitemquantity_hook;
		utils::hook::detour liveinventory_areextraslotspurchased_hook;

		int loot_getitemquantity_stub(const game::ControllerIndex_t /*controller_index*/, const game::eModes mode,
		                              const int /*item_id*/)
		{
			if (mode == game::eModes::MODE_ZOMBIES)
			{
				return 999;
			}

			return 1;
		}

		int liveinventory_getitemquantity_stub(const game::ControllerIndex_t controller_index, const int item_id)
		{
			// Item id's for extra CaC slots, CWL camo's and paid specialist outfits
			if (item_id == 99003 || item_id >= 99018 && item_id <= 99021 || item_id == 99025 || item_id >= 90047 &&
				item_id <= 90064)
			{
				return 1;
			}

			return liveinventory_getitemquantity_hook.invoke<int>(controller_index, item_id);
		}

		bool liveinventory_areextraslotspurchased_stub(const game::ControllerIndex_t /*controller_index*/)
		{
			return true;
		}

		void set_dvars_on_startup()
		{
			game::Dvar_SetFromStringByName("ui_enableAllHeroes", "1", true);
			game::Dvar_SetFromStringByName("ui_allLootUnlocked", "1", true);
		}
	};

	struct component final : client_component
	{
		void post_unpack() override
		{
			scheduler::once(set_dvars_on_startup, scheduler::pipeline::main);
			loot_getitemquantity_hook.create(0x141E82C90_g, loot_getitemquantity_stub);
			liveinventory_getitemquantity_hook.create(0x141E090C0_g, liveinventory_getitemquantity_stub);
			liveinventory_areextraslotspurchased_hook.create(0x141E089E0_g, liveinventory_areextraslotspurchased_stub);
		}
	};
};

REGISTER_COMPONENT(loot::component)

```

`src/client/component/network.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "scheduler.hpp"
#include "game/game.hpp"

#include <utils/hook.hpp>
#include <utils/string.hpp>
#include <utils/finally.hpp>

#include "network.hpp"

namespace network
{
	namespace
	{
		std::unordered_map<std::string, callback>& get_callbacks()
		{
			static std::unordered_map<std::string, callback> callbacks{};
			return callbacks;
		}

		uint64_t handle_command(const game::netadr_t* address, const char* command, const game::msg_t* message)
		{
			const auto cmd_string = utils::string::to_lower(command);
			auto& callbacks = get_callbacks();
			const auto handler = callbacks.find(cmd_string);
			const auto offset = cmd_string.size() + 5;
			if (message->cursize < 0 || static_cast<size_t>(message->cursize) < offset || handler == callbacks.end())
			{
				return 1;
			}

			const std::basic_string_view data(message->data + offset, message->cursize - offset);

			handler->second(*address, data);
			return 0;
		}

		void handle_command_stub(utils::hook::assembler& a)
		{
			const auto sv = game::is_server();

			a.pushad64();

			a.mov(rdx, rcx);            // command
			a.mov(r8, sv ? r15 : r12);  // msg
			a.mov(rcx, sv ? r14 : r15); // address

			a.call_aligned(handle_command);

			a.mov(qword_ptr(rsp, 0x78), rax);

			a.popad64();

			a.ret();
		}

		bool socket_set_blocking(const SOCKET s, const bool blocking)
		{
			unsigned long mode = blocking ? 0 : 1;
			return ioctlsocket(s, FIONBIO, &mode) == 0;
		}

		void create_ip_socket()
		{
			auto& s = *game::ip_socket;
			if (s)
			{
				return;
			}

			s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
			if (s == INVALID_SOCKET)
			{
				throw std::runtime_error("Unable to create socket");
			}

			socket_set_blocking(s, false);

			const auto address = htonl(INADDR_ANY);
			const auto port = htons(28960);

			sockaddr_in server_addr{};
			server_addr.sin_family = AF_INET;
			server_addr.sin_addr.s_addr = address;
			server_addr.sin_port = port;

			int retries = 0;
			while (bind(s, reinterpret_cast<sockaddr*>(&server_addr), sizeof(server_addr)) ==
				SOCKET_ERROR)
			{
				if (++retries > 10) return;
				server_addr.sin_port = htons(ntohs(server_addr.sin_port) + 1);
			}
		}

		bool& socket_byte_missing()
		{
			static thread_local bool was_missing{false};
			return was_missing;
		}

		uint8_t read_socket_byte_stub(game::msg_t* msg)
		{
			auto& byte_missing = socket_byte_missing();
			byte_missing = msg->cursize >= 4 && *reinterpret_cast<int*>(msg->data) == -1;
			if (byte_missing)
			{
				return game::NS_SERVER | (game::NS_SERVER << 4);
			}

			const auto _ = utils::finally([msg]
			{
				++msg->data;
			});

			return game::MSG_ReadByte(msg);
		}

		int verify_checksum_stub(void* /*data*/, const int length)
		{
			return length + (socket_byte_missing() ? 1 : 0);
		}

		void con_restricted_execute_buf_stub(int local_client_num, game::ControllerIndex_t controller_index, const char* buffer)
		{
			game::Cbuf_ExecuteBuffer(local_client_num, controller_index, buffer);
		}
	}

	void on(const std::string& command, const callback& callback)
	{
		get_callbacks()[utils::string::to_lower(command)] = callback;
	}

	void send(const game::netadr_t& address, const std::string& command, const std::string& data, const char separator)
	{
		std::string packet = "\xFF\xFF\xFF\xFF";
		packet.append(command);
		packet.push_back(separator);
		packet.append(data);

		send_data(address, packet);
	}

	sockaddr_in convert_to_sockaddr(const game::netadr_t& address)
	{
		sockaddr_in to{};
		to.sin_family = AF_INET;
		to.sin_port = htons(address.port);
		to.sin_addr.S_un.S_addr = address.addr;
		return to;
	}

	void send_data(const game::netadr_t& address, const void* data, const size_t length)
	{
		//game::NET_SendPacket(game::NS_CLIENT1, static_cast<int>(size), data, &address);

		const auto to = convert_to_sockaddr(address);
		sendto(*game::ip_socket, static_cast<const char*>(data), static_cast<int>(length), 0,
		       reinterpret_cast<const sockaddr*>(&to), sizeof(to));
	}

	void send_data(const game::netadr_t& address, const std::string& data)
	{
		send_data(address, data.data(), data.size());
	}

	game::netadr_t address_from_string(const std::string& address)
	{
		game::netadr_t addr{};
		addr.localNetID = game::NS_SERVER;

		if (!game::NET_StringToAdr(address.data(), &addr))
		{
			addr.type = game::NA_BAD;
			return addr;
		}

		if (addr.type == game::NA_IP)
		{
			addr.type = game::NA_RAWIP;
		}

		return addr;
	}

	game::netadr_t address_from_ip(const uint32_t ip, const uint16_t port)
	{
		game::netadr_t addr{};
		addr.localNetID = game::NS_SERVER;
		addr.type = game::NA_RAWIP;
		addr.port = port;
		addr.addr = ip;

		return addr;
	}

	bool are_addresses_equal(const game::netadr_t& a, const game::netadr_t& b)
	{
		if (a.type != b.type)
		{
			return false;
		}

		if (a.type != game::NA_RAWIP && a.type != game::NA_IP)
		{
			return true;
		}

		return a.port == b.port && a.addr == b.addr;
	}

	uint64_t ret2()
	{
		return 2;
	}

	struct component final : generic_component
	{
		void post_unpack() override
		{
			utils::hook::nop(game::select(0x142332E76, 0x140596DF6), 4); // don't increment data pointer to optionally skip socket byte
			utils::hook::call(game::select(0x142332E43, 0x140596DC3), read_socket_byte_stub); // optionally read socket byte
			utils::hook::call(game::select(0x142332E81, 0x140596E01), verify_checksum_stub); // skip checksum verification
			utils::hook::set<uint8_t>(game::select(0x14233305E, 0x140596F2E), 0); // don't add checksum to packet

			utils::hook::set<uint32_t>(game::select(0x14134C6E0, 0x14018E574), 5); // set initial connection state to challenging

			// intercept command handling
			utils::hook::call(game::select(0x14134D146, 0x14018EED0), utils::hook::assemble(handle_command_stub));

			utils::hook::set<uint8_t>(game::select(0x14224E90D, 0x1405315F9), 0xEB); // don't kick clients without dw handle

			if (game::is_server())
			{
				// Remove restrictions for rcon commands
				utils::hook::call(0x140538D5C_g, con_restricted_execute_buf_stub); // SVC_RemoteCommand
			}

			// TODO: Fix that
			scheduler::once(create_ip_socket, scheduler::main);
		}
	};
}

REGISTER_COMPONENT(network::component)

```

`src/client/component/network.hpp`:

```hpp
#pragma once

namespace network
{
	using data_view = std::basic_string_view<uint8_t>;
	using callback = std::function<void(const game::netadr_t&, const data_view&)>;

	void on(const std::string& command, const callback& callback);
	void send(const game::netadr_t& address, const std::string& command, const std::string& data = {},
	          char separator = ' ');

	void send_data(const game::netadr_t& address, const void* data, size_t length);
	void send_data(const game::netadr_t& address, const std::string& data);

	game::netadr_t address_from_string(const std::string& address);
	game::netadr_t address_from_ip(uint32_t ip, uint16_t port);

	bool are_addresses_equal(const game::netadr_t& a, const game::netadr_t& b);
}

inline bool operator==(const game::netadr_t& a, const game::netadr_t& b)
{
	return network::are_addresses_equal(a, b); //
}

inline bool operator!=(const game::netadr_t& a, const game::netadr_t& b)
{
	return !(a == b); //
}

namespace std
{
	template <>
	struct equal_to<game::netadr_t>
	{
		using result_type = bool;

		bool operator()(const game::netadr_t& lhs, const game::netadr_t& rhs) const
		{
			return network::are_addresses_equal(lhs, rhs);
		}
	};

	template <>
	struct hash<game::netadr_t>
	{
		size_t operator()(const game::netadr_t& x) const noexcept
		{
			const auto type_hash = hash<uint32_t>()(x.type);

			if (x.type != game::NA_IP && x.type != game::NA_RAWIP)
			{
				return type_hash;
			}

			return type_hash ^ hash<uint32_t>()(x.addr) ^ hash<
				uint16_t>()(x.port);
		}
	};
}

```

`src/client/component/party.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"
#include "game/game.hpp"

#include "party.hpp"
#include "network.hpp"
#include "scheduler.hpp"

#include <utils/hook.hpp>
#include <utils/info_string.hpp>
#include <utils/cryptography.hpp>
#include <utils/concurrency.hpp>

namespace party
{
	namespace
	{
		std::atomic_bool is_connecting_to_dedi{false};
		game::netadr_t connect_host{{}, {}, game::NA_BAD, {}};

		struct server_query
		{
			bool sent{false};
			game::netadr_t host{};
			std::string challenge{};
			query_callback callback{};
			std::chrono::high_resolution_clock::time_point query_time{};
		};

		utils::concurrency::container<std::vector<server_query>>& get_server_queries()
		{
			static utils::concurrency::container<std::vector<server_query>> server_queries;
			return server_queries;
		}

		void stop_zombies_intro_if_needed()
		{
			if (game::Com_SessionMode_GetMode() != game::MODE_ZOMBIES)
			{
				return;
			}

			scheduler::once([]
			{
				scheduler::schedule([]
				{
					if (!game::Sys_IsDatabaseReady())
					{
						return scheduler::cond_continue;
					}

					game::Cinematic_StopPlayback(0, true);
					return scheduler::cond_end;
				}, scheduler::main);
			}, scheduler::main, 15s);
		}

		void connect_to_lobby(const game::netadr_t& addr, const std::string& mapname, const std::string& gamemode)
		{
			game::XSESSION_INFO info{};
			game::CL_ConnectFromLobby(0, &info, &addr, 1, 0, mapname.data(), gamemode.data());

			stop_zombies_intro_if_needed();
		}

		void launch_mode(const game::eModes mode)
		{
			scheduler::once([=]
			{
				const auto local_client = *reinterpret_cast<DWORD*>(0x14342355C_g);
				const auto current_mode = game::Com_SessionMode_GetMode();
				game::Com_SwitchMode(local_client, current_mode, mode, 6);
			}, scheduler::main);
		}

		void connect_to_lobby_with_mode(const game::netadr_t& addr, const game::eModes mode, const std::string& mapname,
		                                const std::string& gametype, const bool was_retried = false)
		{
			if (game::Com_SessionMode_IsMode(mode))
			{
				connect_to_lobby(addr, mapname, gametype);
				return;
			}

			if (!was_retried)
			{
				scheduler::once([=]
				{
					connect_to_lobby_with_mode(addr, mode, mapname, gametype, true);
				}, scheduler::main, 5s);

				launch_mode(mode);
			}
		}

		game::LobbyMainMode convert_mode(const game::eModes mode)
		{
			switch (mode)
			{
			case game::MODE_CAMPAIGN:
				return game::LOBBY_MAINMODE_CP;
			case game::MODE_MULTIPLAYER:
				return game::LOBBY_MAINMODE_MP;
			case game::MODE_ZOMBIES:
				return game::LOBBY_MAINMODE_ZM;
			default:
				return game::LOBBY_MAINMODE_INVALID;
			}
		}

		void connect_to_session(const game::netadr_t& addr, const std::string& hostname, const uint64_t xuid,
		                        const game::eModes mode)
		{
			const auto LobbyJoin_Begin = reinterpret_cast<bool(*)(int actionId, game::ControllerIndex_t controllerIndex,
			                                                      game::LobbyType sourceLobbyType,
			                                                      game::LobbyType targetLobbyType)>(0x141ED9540_g);

			if (!LobbyJoin_Begin(0, game::CONTROLLER_INDEX_FIRST, game::LOBBY_TYPE_PRIVATE, game::LOBBY_TYPE_PRIVATE))
			{
				return;
			}

			auto& join = *game::s_join;

			auto& host = join.hostList[0];
			memset(&host, 0, sizeof(host));

			host.info.netAdr = addr;
			host.info.xuid = xuid;
			strcpy_s(host.info.name, hostname.data());

			host.lobbyType = game::LOBBY_TYPE_PRIVATE;
			host.lobbyParams.networkMode = game::LOBBY_NETWORKMODE_LIVE;
			host.lobbyParams.mainMode = convert_mode(mode);

			host.retryCount = 0;
			host.retryTime = game::Sys_Milliseconds();

			join.potentialHost = host;
			join.hostCount = 1;
			join.processedCount = 1;
			join.state = game::JOIN_SOURCE_STATE_ASSOCIATING;
			join.startTime = game::Sys_Milliseconds();

			/*join.targetLobbyType = game::LOBBY_TYPE_PRIVATE;
			join.sourceLobbyType = game::LOBBY_TYPE_PRIVATE;
			join.controllerIndex = game::CONTROLLER_INDEX_FIRST;
			join.joinType = game::JOIN_TYPE_NORMAL;
			join.joinResult = game::JOIN_RESULT_INVALID;
			join.isFinalized = false;*/

			// LobbyJoinSource_Finalize
			join.isFinalized = true;
		}

		void handle_connect_query_response(const bool success, const game::netadr_t& target,
		                                   const utils::info_string& info, uint32_t ping)
		{
			if (!success)
			{
				return;
			}

			is_connecting_to_dedi = info.get("dedicated") == "1";

			const auto gamename = info.get("gamename");
			if (gamename != "T7"s)
			{
				const auto str = "Invalid gamename.";
				printf("%s\n", str);
				return;
			}

			const auto mapname = info.get("mapname");
			if (mapname.empty())
			{
				const auto str = "Invalid map.";
				printf("%s\n", str);
				return;
			}

			const auto gametype = info.get("gametype");
			if (gametype.empty())
			{
				const auto str = "Invalid gametype.";
				printf("%s\n", str);
				return;
			}

			//const auto hostname = info.get("sv_hostname");
			const auto playmode = info.get("playmode");
			const auto mode = game::eModes(std::atoi(playmode.data()));
			//const auto xuid = strtoull(info.get("xuid").data(), nullptr, 16);

			scheduler::once([=]
			{
				//connect_to_session(target, hostname, xuid, mode);
				connect_to_lobby_with_mode(target, mode, mapname, gametype);
			}, scheduler::main);
		}

		void connect_stub(const char* address)
		{
			const auto target = network::address_from_string(address);
			if (target.type == game::NA_BAD)
			{
				return;
			}

			connect_host = target;
			query_server(target, handle_connect_query_response);
		}

		void send_server_query(server_query& query)
		{
			query.sent = true;
			query.query_time = std::chrono::high_resolution_clock::now();
			query.challenge = utils::cryptography::random::get_challenge();

			network::send(query.host, "getInfo", query.challenge);
		}
	}

	void query_server(const game::netadr_t& host, query_callback callback)
	{
		server_query query{};
		query.sent = false;
		query.host = host;
		query.callback = std::move(callback);

		get_server_queries().access([&](std::vector<server_query>& server_queries)
		{
			server_queries.emplace_back(std::move(query));
		});
	}

	int should_transfer_stub(uint8_t* storage_file_info)
	{
		auto should_transfer = game::ShouldTransfer(storage_file_info);

		const auto offset = storage_file_info - reinterpret_cast<uint8_t*>(0x14343CDF0_g);
		const auto index = offset / 120;

		if (is_connecting_to_dedi && index >= 12 && index <= 15)
		{
			should_transfer = !should_transfer;
		}

		return should_transfer;
	}

	struct component final : client_component
	{
		void post_unpack() override
		{
			utils::hook::jump(0x141EE6030_g, connect_stub);
			utils::hook::call(0x1422781E3_g, should_transfer_stub);

			network::on("infoResponse", [](const game::netadr_t& target, const network::data_view& data)
			{
				bool found_query = false;
				server_query query{};

				const utils::info_string info{data};

				get_server_queries().access([&](std::vector<server_query>& server_queries)
				{
					for (auto i = server_queries.begin(); i != server_queries.end(); ++i)
					{
						if (i->host == target && i->challenge == info.get("challenge"))
						{
							found_query = true;
							query = std::move(*i);
							i = server_queries.erase(i);
							break;
						}
					}
				});

				if (found_query)
				{
					const auto ping = std::chrono::high_resolution_clock::now() - query.query_time;
					const auto ping_ms = std::chrono::duration_cast<std::chrono::milliseconds>(ping).count();

					query.callback(true, query.host, info, static_cast<uint32_t>(ping_ms));
				}
			});

			scheduler::loop([]
			{
				std::vector<server_query> removed_queries{};

				get_server_queries().access([&](std::vector<server_query>& server_queries)
				{
					size_t sent_queries = 0;

					const auto now = std::chrono::high_resolution_clock::now();
					for (auto i = server_queries.begin(); i != server_queries.end();)
					{
						if (!i->sent)
						{
							if (++sent_queries < 10)
							{
								send_server_query(*i);
							}

							++i;
							continue;
						}

						if ((now - i->query_time) < 2s)
						{
							++i;
							continue;
						}

						removed_queries.emplace_back(std::move(*i));
						i = server_queries.erase(i);
					}
				});

				const utils::info_string empty{};
				for (const auto& query : removed_queries)
				{
					query.callback(false, query.host, empty, 0);
				}
			}, scheduler::async, 200ms);
		}

		void pre_destroy() override
		{
			get_server_queries().access([](std::vector<server_query>& s)
			{
				s = {};
			});
		}
	};
}

REGISTER_COMPONENT(party::component)

```

`src/client/component/party.hpp`:

```hpp
#pragma once
#include <utils/info_string.hpp>

namespace party
{
	using query_callback_func = void(bool success, const game::netadr_t& host, const ::utils::info_string& info, uint32_t ping);
	using query_callback = std::function<query_callback_func>;

	void query_server(const game::netadr_t& host, query_callback callback);
}

```

`src/client/component/scheduler.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "scheduler.hpp"

#include "game/game.hpp"

#include <utils/hook.hpp>
#include <utils/concurrency.hpp>
#include <utils/thread.hpp>

namespace scheduler
{
	namespace
	{
		struct task
		{
			std::function<bool()> handler{};
			std::chrono::milliseconds interval{};
			std::chrono::high_resolution_clock::time_point last_call{};
		};

		using task_list = std::vector<task>;

		class task_pipeline
		{
		public:
			void add(task&& task)
			{
				new_callbacks_.access([&task](task_list& tasks)
				{
					tasks.emplace_back(std::move(task));
				});
			}

			void execute()
			{
				callbacks_.access([&](task_list& tasks)
				{
					this->merge_callbacks();

					for (auto i = tasks.begin(); i != tasks.end();)
					{
						const auto now = std::chrono::high_resolution_clock::now();
						const auto diff = now - i->last_call;

						if (diff < i->interval)
						{
							++i;
							continue;
						}

						i->last_call = now;

						const auto res = i->handler();
						if (res == cond_end)
						{
							i = tasks.erase(i);
						}
						else
						{
							++i;
						}
					}
				});
			}

		private:
			utils::concurrency::container<task_list> new_callbacks_;
			utils::concurrency::container<task_list, std::recursive_mutex> callbacks_;

			void merge_callbacks()
			{
				callbacks_.access([&](task_list& tasks)
				{
					new_callbacks_.access([&](task_list& new_tasks)
					{
						tasks.insert(tasks.end(), std::move_iterator(new_tasks.begin()),
						             std::move_iterator(new_tasks.end()));
						new_tasks = {};
					});
				});
			}
		};

		volatile bool kill = false;
		std::thread thread;
		task_pipeline pipelines[pipeline::count];

		utils::hook::detour r_end_frame_hook;
		utils::hook::detour g_run_frame_hook;
		utils::hook::detour main_frame_hook;

		void execute(const pipeline type)
		{
			assert(type >= 0 && type < pipeline::count);
			pipelines[type].execute();
		}

		void r_end_frame_stub()
		{
			execute(pipeline::renderer);
			r_end_frame_hook.invoke<void>();
		}

		void server_frame_stub()
		{
			g_run_frame_hook.invoke<void>();
			execute(pipeline::server);
		}

		void main_frame_stub()
		{
			main_frame_hook.invoke<void>();
			execute(pipeline::main);
		}
	}

	void schedule(const std::function<bool()>& callback, const pipeline type,
	              const std::chrono::milliseconds delay)
	{
		assert(type >= 0 && type < pipeline::count);

		task task;
		task.handler = callback;
		task.interval = delay;
		task.last_call = std::chrono::high_resolution_clock::now();

		pipelines[type].add(std::move(task));
	}

	void loop(const std::function<void()>& callback, const pipeline type,
	          const std::chrono::milliseconds delay)
	{
		schedule([callback]()
		{
			callback();
			return cond_continue;
		}, type, delay);
	}

	void once(const std::function<void()>& callback, const pipeline type,
	          const std::chrono::milliseconds delay)
	{
		schedule([callback]()
		{
			callback();
			return cond_end;
		}, type, delay);
	}

	struct component final : generic_component
	{
		void post_load() override
		{
			thread = utils::thread::create_named_thread("Async Scheduler", []()
			{
				while (!kill)
				{
					execute(pipeline::async);
					std::this_thread::sleep_for(10ms);
				}
			});
		}

		void post_unpack() override
		{
			if (!game::is_server())
			{
				r_end_frame_hook.create(0x142273560_g, r_end_frame_stub);
				// some func called before R_EndFrame, maybe SND_EndFrame?
			}

			//g_run_frame_hook.create(0x14065C360_g, server_frame_stub); // GlassSv_Update
			main_frame_hook.create(game::select(0x1420F9860, 0x1405020E0), main_frame_stub);
			// Com_Frame_Try_Block_Function
		}

		void pre_destroy() override
		{
			kill = true;
			if (thread.joinable())
			{
				thread.join();
			}
		}
	};
}

REGISTER_COMPONENT(scheduler::component)

```

`src/client/component/scheduler.hpp`:

```hpp
#pragma once

namespace scheduler
{
	enum pipeline
	{
		// Asynchronuous pipeline, disconnected from the game
		async = 0,

		// The game's rendering pipeline
		renderer,

		// The game's server thread
		server,

		// The game's main thread
		main,

		count,
	};

	static const bool cond_continue = false;
	static const bool cond_end = true;

	void schedule(const std::function<bool()>& callback, pipeline type = pipeline::async,
	              std::chrono::milliseconds delay = 0ms);
	void loop(const std::function<void()>& callback, pipeline type = pipeline::async,
	          std::chrono::milliseconds delay = 0ms);
	void once(const std::function<void()>& callback, pipeline type = pipeline::async,
	          std::chrono::milliseconds delay = 0ms);
	void on_game_initialized(const std::function<void()>& callback, pipeline type = pipeline::async,
	                         std::chrono::milliseconds delay = 0ms);
}

```

`src/client/component/server_list.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"
#include "server_list.hpp"

#include "game/game.hpp"

#include <utils/string.hpp>
#include <utils/concurrency.hpp>

#include "network.hpp"
#include "scheduler.hpp"

namespace server_list
{
	namespace
	{
		struct state
		{
			game::netadr_t address{};
			bool requesting{false};
			std::chrono::high_resolution_clock::time_point query_start{};
			callback callback{};
		};

		utils::concurrency::container<state> master_state;

		void handle_server_list_response(const game::netadr_t& target,
		                                 const network::data_view& data, state& s)
		{
			if (!s.requesting || s.address != target)
			{
				return;
			}

			s.requesting = false;
			const auto callback = std::move(s.callback);

			std::optional<size_t> start{};

			for (size_t i = 0; i + 6 < data.size(); ++i)
			{
				if (data[i + 6] == '\\')
				{
					start.emplace(i);
					break;
				}
			}

			if (!start.has_value())
			{
				callback(true, {});
				return;
			}

			std::unordered_set<game::netadr_t> result{};

			for (auto i = start.value(); i + 6 < data.size(); i += 7)
			{
				if (data[i + 6] != '\\')
				{
					break;
				}

				game::netadr_t address{};
				address.type = game::NA_RAWIP;
				address.localNetID = game::NS_CLIENT1;
				memcpy(&address.ipv4.a, data.data() + i + 0, 4);
				memcpy(&address.port, data.data() + i + 4, 2);
				address.port = ntohs(address.port);

				result.emplace(address);
			}

			callback(true, result);
		}
	}

	bool get_master_server(game::netadr_t& address)
	{
		address = network::address_from_string("server.boiii.re:20810");
		return address.type != game::NA_BAD;
	}

	void request_servers(callback callback)
	{
		master_state.access([&callback](state& s)
		{
			game::netadr_t addr{};
			if (!get_master_server(addr))
			{
				return;
			}

			s.requesting = true;
			s.address = addr;
			s.callback = std::move(callback);
			s.query_start = std::chrono::high_resolution_clock::now();

			network::send(s.address, "getservers", utils::string::va("T7 %i full empty", PROTOCOL));
		});
	}

	struct component final : client_component
	{
		void post_unpack() override
		{
			network::on("getServersResponse", [](const game::netadr_t& target, const network::data_view& data)
			{
				master_state.access([&](state& s)
				{
					handle_server_list_response(target, data, s);
				});
			});

			scheduler::loop([]
			{
				master_state.access([](state& s)
				{
					if (!s.requesting)
					{
						return;
					}

					const auto now = std::chrono::high_resolution_clock::now();
					if ((now - s.query_start) < 2s)
					{
						return;
					}

					s.requesting = false;
					s.callback(false, {});
					s.callback = {};
				});
			}, scheduler::async, 200ms);
		}

		void pre_destroy() override
		{
			master_state.access([](state& s)
			{
				s.requesting = false;
				s.callback = {};
			});
		}
	};
}

REGISTER_COMPONENT(server_list::component)

```

`src/client/component/server_list.hpp`:

```hpp
#pragma once
#include <game/game.hpp>

namespace server_list
{
	bool get_master_server(game::netadr_t& address);

	using callback = std::function<void(bool, const std::unordered_set<game::netadr_t>&)>;
	void request_servers(callback callback);
}

```

`src/client/component/splash.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include "splash.hpp"
#include "resource.hpp"

#include <utils/nt.hpp>
#include <utils/image.hpp>

namespace splash
{
	namespace
	{
		HWND window{};
		utils::image::object image{};
		std::thread window_thread{};

		utils::image::object load_splash_image()
		{
			//const auto self = utils::nt::library::get_by_address(load_splash_image);
			//return LoadImageA(self, MAKEINTRESOURCE(IMAGE_SPLASH), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);

			const auto res = utils::nt::load_resource(IMAGE_SPLASH);
			const auto img = utils::image::load_image(res);
			return utils::image::create_bitmap(img);
		}

		void destroy_window()
		{
			if (window && IsWindow(window))
			{
				ShowWindow(window, SW_HIDE);
				DestroyWindow(window);
				window = nullptr;

				if (window_thread.joinable())
				{
					window_thread.join();
				}

				window = nullptr;
			}
			else if (window_thread.joinable())
			{
				window_thread.detach();
			}
		}

		void show()
		{
			WNDCLASSA wnd_class;

			const auto self = utils::nt::library::get_by_address(load_splash_image);

			wnd_class.style = CS_DROPSHADOW;
			wnd_class.cbClsExtra = 0;
			wnd_class.cbWndExtra = 0;
			wnd_class.lpszMenuName = nullptr;
			wnd_class.lpfnWndProc = DefWindowProcA;
			wnd_class.hInstance = self;
			wnd_class.hIcon = LoadIconA(self, MAKEINTRESOURCEA(ID_ICON));
			wnd_class.hCursor = LoadCursorA(nullptr, IDC_APPSTARTING);
			wnd_class.hbrBackground = reinterpret_cast<HBRUSH>(6);
			wnd_class.lpszClassName = "Black Ops III Splash Screen";

			if (RegisterClassA(&wnd_class))
			{
				const auto x_pixels = GetSystemMetrics(SM_CXFULLSCREEN);
				const auto y_pixels = GetSystemMetrics(SM_CYFULLSCREEN);

				if (image)
				{
					window = CreateWindowExA(WS_EX_APPWINDOW, "Black Ops III Splash Screen", "BOIII",
					                         WS_POPUP | WS_SYSMENU,
					                         (x_pixels - 320) / 2, (y_pixels - 100) / 2, 320, 100, nullptr,
					                         nullptr,
					                         self, nullptr);

					if (window)
					{
						auto* const image_window = CreateWindowExA(0, "Static", nullptr, WS_CHILD | WS_VISIBLE | 0xEu,
						                                           0, 0,
						                                           320, 100, window, nullptr, self, nullptr);
						if (image_window)
						{
							RECT rect;
							SendMessageA(image_window, STM_SETIMAGE, IMAGE_BITMAP, image);
							GetWindowRect(image_window, &rect);

							const int width = rect.right - rect.left;
							rect.left = (x_pixels - width) / 2;

							const int height = rect.bottom - rect.top;
							rect.top = (y_pixels - height) / 2;

							rect.right = rect.left + width;
							rect.bottom = rect.top + height;
							AdjustWindowRect(&rect, WS_CHILD | WS_VISIBLE | 0xEu, 0);
							SetWindowPos(window, nullptr, rect.left, rect.top, rect.right - rect.left,
							             rect.bottom - rect.top, SWP_NOZORDER);

							SetWindowRgn(window,
							             CreateRoundRectRgn(0, 0, rect.right - rect.left, rect.bottom - rect.top, 15,
							                                15), TRUE);

							ShowWindow(window, SW_SHOW);
							UpdateWindow(window);
						}
					}
				}
			}
		}

		bool draw_frame()
		{
			if (!window)
			{
				return false;
			}

			MSG msg{};
			bool success = true;

			while (PeekMessageW(&msg, nullptr, NULL, NULL, PM_REMOVE))
			{
				TranslateMessage(&msg);
				DispatchMessageW(&msg);

				if (msg.message == WM_DESTROY && msg.hwnd == window)
				{
					PostQuitMessage(0);
				}

				if (msg.message == WM_QUIT)
				{
					success = false;
				}
			}
			return success;
		}

		void draw()
		{
			show();
			while (draw_frame())
			{
				std::this_thread::sleep_for(1ms);
			}

			window = nullptr;
			UnregisterClassA("Black Ops III Splash Screen", utils::nt::library{});
		}
	}

	struct component final : client_component
	{
		component()
		{
			image = load_splash_image();
			window_thread = std::thread([this]
			{
				draw();
			});
		}

		void pre_destroy() override
		{
			destroy_window();
			if (window_thread.joinable())
			{
				window_thread.detach();
			}
		}

		void post_unpack() override
		{
			destroy_window();
		}
	};

	void hide()
	{
		if (window && IsWindow(window))
		{
			ShowWindow(window, SW_HIDE);
			UpdateWindow(window);
		}

		destroy_window();
	}

	HWND get_window()
	{
		return window;
	}
}

REGISTER_COMPONENT(splash::component)

```

`src/client/component/splash.hpp`:

```hpp
#pragma once

namespace splash
{
	void hide();
	HWND get_window();
}

```

`src/client/component/steam_proxy.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"

#include <utils/nt.hpp>
#include <utils/flags.hpp>
#include <utils/string.hpp>
#include <utils/finally.hpp>
#include <utils/concurrency.hpp>

#include "steam/interface.hpp"
#include "steam/steam.hpp"

#include "steam_proxy.hpp"
#include "scheduler.hpp"

namespace steam_proxy
{
	namespace
	{
		utils::nt::library steam_client_module{};
		utils::nt::library steam_overlay_module{};

		void* steam_pipe = nullptr;
		void* global_user = nullptr;

		steam::interface client_engine{};
		steam::interface client_user{};
		steam::interface client_utils{};
		steam::interface client_friends{};
		steam::interface client_ugc{};

		utils::concurrency::container<subscribed_item_map> subscribed_items;

		enum class ownership_state
		{
			success,
			unowned,
			nosteam,
			error,
		};

		bool is_disabled()
		{
			static const auto disabled = utils::flags::has_flag("nosteam");
			return disabled;
		}

		void* load_client_engine()
		{
			if (!steam_client_module) return nullptr;

			for (auto i = 1; i <= 999; ++i)
			{
				std::string name = utils::string::va("CLIENTENGINE_INTERFACE_VERSION%03i", i);
				auto* const temp_client_engine = steam_client_module
					.invoke<void*>("CreateInterface", name.data(), nullptr);
				if (temp_client_engine) return temp_client_engine;
			}

			return nullptr;
		}

		void load_client()
		{
			const std::filesystem::path steam_path = steam::SteamAPI_GetSteamInstallPath();
			if (steam_path.empty()) return;

			utils::nt::library::load(steam_path / "tier0_s64.dll");
			utils::nt::library::load(steam_path / "vstdlib_s64.dll");
			steam_overlay_module = utils::nt::library::load(steam_path / "gameoverlayrenderer64.dll");
			steam_client_module = utils::nt::library::load(steam_path / "steamclient64.dll");
			if (!steam_client_module) return;

			client_engine = load_client_engine();
			if (!client_engine) return;

			steam_pipe = steam_client_module.invoke<void*>("Steam_CreateSteamPipe");
			global_user = steam_client_module.invoke<void*>(
				"Steam_ConnectToGlobalUser", steam_pipe);

			client_user = client_engine.invoke<void*>(8, global_user, steam_pipe);
			client_utils = client_engine.invoke<void*>(14, steam_pipe);
			client_friends = client_engine.invoke<void*>(13, global_user, steam_pipe);
			client_ugc = client_engine.invoke<void*>(62, global_user, steam_pipe);
		}

		void do_cleanup()
		{
			client_engine = nullptr;
			client_user = nullptr;
			client_utils = nullptr;
			client_friends = nullptr;
			client_ugc = nullptr;

			steam_pipe = nullptr;
			global_user = nullptr;

			steam_client_module = utils::nt::library{nullptr};
		}

		bool perform_cleanup_if_needed()
		{
			if (steam_client_module
				&& steam_pipe
				&& global_user
				&& steam_client_module.invoke<bool>("Steam_BConnected", global_user,
				                                    steam_pipe)
				&& steam_client_module.invoke<bool>("Steam_BLoggedOn", global_user, steam_pipe)
			)
			{
				return false;
			}

			do_cleanup();
			return true;
		}

		void clean_up_on_error()
		{
			scheduler::schedule([]
			{
				if (perform_cleanup_if_needed())
				{
					return scheduler::cond_end;
				}

				return scheduler::cond_continue;
			}, scheduler::main);
		}

		ownership_state start_mod_unsafe(const std::string& title, size_t app_id)
		{
			if (!client_utils || !client_user)
			{
				return ownership_state::nosteam;
			}

			if (!client_user.invoke<bool>("BIsSubscribedApp", app_id))
			{
#ifdef DEV_BUILD
				app_id = 480; // Spacewar
#else
				return ownership_state::unowned;
#endif
			}

			if (is_disabled())
			{
				return ownership_state::success;
			}

			client_utils.invoke<void>("SetAppIDForCurrentPipe", app_id, false);

			char our_directory[MAX_PATH] = {0};
			GetCurrentDirectoryA(sizeof(our_directory), our_directory);

			const auto self = utils::nt::library::get_by_address(start_mod_unsafe);
			const auto path = self.get_path();
			const auto* cmdline = utils::string::va("\"%s\" -proc %d", path.generic_string().data(),
			                                        GetCurrentProcessId());

			steam::game_id game_id;
			game_id.raw.type = 1; // k_EGameIDTypeGameMod
			game_id.raw.app_id = app_id & 0xFFFFFF;

			const auto* mod_id = "bo3";
			game_id.raw.mod_id = *reinterpret_cast<const unsigned int*>(mod_id) | 0x80000000;

			client_user.invoke<bool>("SpawnProcess", path.generic_string().data(), cmdline, our_directory,
			                         &game_id.bits, title.data(), 0, 0, 0);

			return ownership_state::success;
		}

		ownership_state start_mod(const std::string& title, const size_t app_id)
		{
			__try
			{
				return start_mod_unsafe(title, app_id);
			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				do_cleanup();
				return ownership_state::error;
			}
		}

		void evaluate_ownership_state(const ownership_state state)
		{
#ifdef DEV_BUILD
			(void)state;
#else
			switch (state)
			{
			case ownership_state::nosteam:
				throw std::runtime_error("Steam must be running to play this game!");
			case ownership_state::unowned:
				throw std::runtime_error("You must own the game on steam to play this mod!");
			case ownership_state::error:
				throw std::runtime_error("Failed to verify ownership of the game!");
			case ownership_state::success:
				break;
			}
#endif
		}
	}

	struct component final : client_component
	{
		void post_load() override
		{
			load_client();
			perform_cleanup_if_needed();
		}

		void post_unpack() override
		{
			const auto res = start_mod("\xE2\x98\x84\xEF\xB8\x8F" " BOIII"s, steam::SteamUtils()->GetAppID());
			evaluate_ownership_state(res);
			clean_up_on_error();
		}

		void pre_destroy() override
		{
			if (steam_client_module && steam_pipe)
			{
				if (global_user)
				{
					steam_client_module.invoke<void>("Steam_ReleaseUser", steam_pipe,
					                                 global_user);
				}

				steam_client_module.invoke<bool>("Steam_BReleaseSteamPipe", steam_pipe);
			}
		}

		component_priority priority() const override
		{
			return component_priority::steam_proxy;
		}
	};

	const utils::nt::library& get_overlay_module()
	{
		return steam_overlay_module;
	}

	const char* get_player_name()
	{
		if (client_friends)
		{
			return client_friends.invoke<const char*>("GetPersonaName");
		}

		return "boiii";
	}

	void update_subscribed_items()
	{
		subscribed_item_map map{};

		const auto _ = utils::finally([&]
		{
			subscribed_items.access([&](subscribed_item_map& items)
			{
				items = std::move(map);
			});
		});

		if (!client_ugc)
		{
			return;
		}

		try
		{
			const auto app_id = steam::SteamUtils()->GetAppID();
			const auto num_items = client_ugc.invoke<uint32_t>("GetNumSubscribedItems", app_id);

			if (!num_items)
			{
				return;
			}

			std::vector<uint64_t> ids;
			ids.resize(num_items);

			auto result = client_ugc.invoke<uint32_t>("GetSubscribedItems", app_id, ids.data(),
			                                          num_items);
			result = std::min(num_items, result);

			for (uint32_t i = 0; i < result; ++i)
			{
				char buffer[0x1000] = {0};
				subscribed_item item{};

				item.state = client_ugc.invoke<uint32_t>("GetItemState", app_id, ids[i]);
				item.available = client_ugc.invoke<bool>("GetItemInstallInfo", app_id, ids[i],
				                                         &item.size_on_disk,
				                                         buffer,
				                                         sizeof(buffer), &item.time_stamp);
				item.path = buffer;

				map[ids[i]] = std::move(item);
			}
		}
		catch (...)
		{
			client_ugc = {};
		}
	}

	void access_subscribed_items(
		const std::function<void(const subscribed_item_map&)>& callback)
	{
		subscribed_items.access(callback);
	}
}

REGISTER_COMPONENT(steam_proxy::component)

```

`src/client/component/steam_proxy.hpp`:

```hpp
#pragma once

namespace steam_proxy
{
	const utils::nt::library& get_overlay_module();
	const char* get_player_name();

	struct subscribed_item
	{
		bool available;
		std::string path;
		uint32_t state;
		uint32_t time_stamp;
		uint64_t size_on_disk;
	};

	using subscribed_item_map = std::unordered_map<uint64_t, subscribed_item>;

	void update_subscribed_items();
	void access_subscribed_items(const std::function<void(const subscribed_item_map&)>& callback);
}

```

`src/client/component/updater.cpp`:

```cpp
#include <std_include.hpp>
#include "loader/component_loader.hpp"
#include "splash.hpp"
#include "updater.hpp"

#include <version.hpp>

#include <utils/io.hpp>
#include <utils/http.hpp>
#include <utils/compression.hpp>
#include <utils/progress_ui.hpp>

#define VERSION_URL "https://nightly.link/momo5502/boiii/workflows/build/" GIT_BRANCH "/Version.zip"
#define BINARY_URL "https://nightly.link/momo5502/boiii/workflows/build/" GIT_BRANCH "/Release%20Binary.zip"

namespace updater
{
	namespace
	{
		std::string get_version_zip()
		{
			const auto version_zip = utils::http::get_data(VERSION_URL);
			if (!version_zip || version_zip->empty())
			{
				throw std::runtime_error("Invalid version data");
			}

			return *version_zip;
		}

		std::string get_version()
		{
			const auto zip = get_version_zip();
			auto res = utils::compression::zip::extract(zip);
			return res["version.txt"];
		}

		bool requires_update()
		{
			return get_version() != GIT_HASH;
		}

		std::string get_self_file()
		{
			const auto self = utils::nt::library::get_by_address(get_self_file);
			return self.get_path().generic_string();
		}

		std::string get_leftover_file()
		{
			return get_self_file() + ".old";
		}

		std::string download_update()
		{
			const auto data = utils::http::get_data(BINARY_URL);

			if (!data)
			{
				throw std::runtime_error("Invalid binary");
			}

			return *data;
		}

		void activate_update()
		{
			utils::nt::relaunch_self();
			TerminateProcess(GetCurrentProcess(), 0);
		}

		std::string get_binary(const std::string& data)
		{
			auto res = utils::compression::zip::extract(data);
			if (res.size() == 1)
			{
				return std::move(res.begin()->second);
			}

			throw std::runtime_error("Invalid data");
		}

		void cleanup_update()
		{
			const auto leftover_file = get_leftover_file();
			for (size_t i = 0; i < 3; ++i)
			{
				if (utils::io::remove_file(leftover_file))
				{
					break;
				}

				std::this_thread::sleep_for(1s);
			}
		}

		void perform_update(const HWND parent_window)
		{
			const utils::progress_ui progress_ui{};
			progress_ui.set_title("Updating BOIII");
			progress_ui.set_line(1, "Downloading update...");
			progress_ui.show(true, parent_window);

			const auto update_data = download_update();

			if (progress_ui.is_cancelled())
			{
				return;
			}

			// Is it good to add artificial sleeps?
			// Makes the ui nice, for sure.
			std::this_thread::sleep_for(2s);

			progress_ui.set_line(1, "Installing update...");
			progress_ui.set_progress(1, 1);

			const auto self_file = get_self_file();
			const auto leftover_file = get_leftover_file();

			const auto binary = get_binary(update_data);

			cleanup_update();
			utils::io::move_file(self_file, leftover_file);
			utils::io::write_file(self_file, binary);

			std::this_thread::sleep_for(2s);
		}
	}

	void update()
	{
		cleanup_update();

#if defined(NDEBUG) && defined(CI)
		try
		{
			if (requires_update())
			{
				perform_update(splash::get_window());
				activate_update();
			}
		}
		catch (...)
		{
		}
#endif
	}

	class component final : public generic_component
	{
	public:
		component()
		{
			this->update_thread_ = std::thread([this]
			{
				update();
			});
		}

		void pre_destroy() override
		{
			join();
		}

		void post_unpack() override
		{
			join();
		}

		component_priority priority() const override
		{
			return component_priority::updater;
		}

	private:
		std::thread update_thread_{};

		void join()
		{
			if (this->update_thread_.joinable())
			{
				this->update_thread_.join();
			}
		}
	};
}

#if defined(NDEBUG) && defined(CI)
REGISTER_COMPONENT(updater::component)
#endif

```

`src/client/component/updater.hpp`:

```hpp
#pragma once

namespace updater
{
	void update();
}

```

`src/client/game/demonware/bit_buffer.cpp`:

```cpp
#include <std_include.hpp>
#include "bit_buffer.hpp"

namespace demonware
{
	bool bit_buffer::read_bytes(const unsigned int bytes, unsigned char* output)
	{
		return this->read(bytes * 8, output);
	}

	bool bit_buffer::read_bool(bool* output)
	{
		if (!this->read_data_type(1))
		{
			return false;
		}

		return this->read(1, output);
	}

	bool bit_buffer::read_uint32(unsigned int* output)
	{
		if (!this->read_data_type(8))
		{
			return false;
		}

		return this->read(32, output);
	}

	bool bit_buffer::read_data_type(const char expected)
	{
		char data_type = 0;

		if (!this->use_data_types_) return true;
		if (this->read(5, &data_type))
		{
			return (data_type == expected);
		}

		return false;
	}

	bool bit_buffer::write_bytes(const unsigned int bytes, const char* data)
	{
		return this->write_bytes(bytes, reinterpret_cast<const unsigned char*>(data));
	}

	bool bit_buffer::write_bytes(const unsigned int bytes, const unsigned char* data)
	{
		return this->write(bytes * 8, data);
	}

	bool bit_buffer::write_bool(bool data)
	{
		if (this->write_data_type(1))
		{
			return this->write(1, &data);
		}

		return false;
	}

	bool bit_buffer::write_int32(int data)
	{
		if (this->write_data_type(7))
		{
			return this->write(32, &data);
		}

		return false;
	}

	bool bit_buffer::write_uint32(unsigned int data)
	{
		if (this->write_data_type(8))
		{
			return this->write(32, &data);
		}

		return false;
	}

	bool bit_buffer::write_data_type(char data)
	{
		if (!this->use_data_types_)
		{
			return true;
		}

		return this->write(5, &data);
	}

	bool bit_buffer::read(unsigned int bits, void* output)
	{
		if (bits == 0) return false;
		if ((this->current_bit_ + bits) > (this->buffer_.size() * 8)) return false;

		int cur_byte = this->current_bit_ >> 3;
		auto cur_out = 0;

		const char* bytes = this->buffer_.data();
		const auto output_bytes = static_cast<unsigned char*>(output);

		while (bits > 0)
		{
			const int min_bit = (bits < 8) ? bits : 8;
			const auto this_byte = bytes[cur_byte++] & 0xFF;
			const int remain = this->current_bit_ & 7;

			if ((min_bit + remain) <= 8)
			{
				output_bytes[cur_out] = BYTE((0xFF >> (8 - min_bit)) & (this_byte >> remain));
			}
			else
			{
				output_bytes[cur_out] = BYTE(
					(0xFF >> (8 - min_bit)) & (bytes[cur_byte] << (8 - remain)) | (this_byte >> remain));
			}

			cur_out++;
			this->current_bit_ += min_bit;
			bits -= min_bit;
		}

		return true;
	}

	bool bit_buffer::write(const unsigned int bits, const void* data)
	{
		if (bits == 0) return false;
		this->buffer_.resize(this->buffer_.size() + (bits >> 3) + 1);

		int bit = bits;
		const auto bytes = const_cast<char*>(this->buffer_.data());
		const auto* input_bytes = static_cast<const unsigned char*>(data);

		while (bit > 0)
		{
			const int bit_pos = this->current_bit_ & 7;
			auto rem_bit = 8 - bit_pos;
			const auto this_write = (bit < rem_bit) ? bit : rem_bit;

			const BYTE mask = ((0xFF >> rem_bit) | (0xFF << (bit_pos + this_write)));
			const int byte_pos = this->current_bit_ >> 3;

			const BYTE temp_byte = (mask & bytes[byte_pos]);
			const BYTE this_bit = ((bits - bit) & 7);
			const auto this_byte = (bits - bit) >> 3;

			auto this_data = input_bytes[this_byte];

			const auto next_byte = (((bits - 1) >> 3) > this_byte) ? input_bytes[this_byte + 1] : 0;

			this_data = BYTE((next_byte << (8 - this_bit)) | (this_data >> this_bit));

			const BYTE out_byte = (~mask & (this_data << bit_pos) | temp_byte);
			bytes[byte_pos] = out_byte;

			this->current_bit_ += this_write;
			bit -= this_write;
		}

		return true;
	}

	void bit_buffer::set_use_data_types(const bool use_data_types)
	{
		this->use_data_types_ = use_data_types;
	}

	unsigned int bit_buffer::size() const
	{
		return this->current_bit_ / 8 + (this->current_bit_ % 8 ? 1 : 0);
	}

	std::string& bit_buffer::get_buffer()
	{
		this->buffer_.resize(this->size());
		return this->buffer_;
	}
}

```

`src/client/game/demonware/bit_buffer.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bit_buffer final
	{
	public:
		bit_buffer() = default;

		explicit bit_buffer(std::string buffer) : buffer_(std::move(buffer))
		{
		}

		bool read_bytes(unsigned int bytes, unsigned char* output);
		bool read_bool(bool* output);
		bool read_uint32(unsigned int* output);
		bool read_data_type(char expected);

		bool write_bytes(unsigned int bytes, const char* data);
		bool write_bytes(unsigned int bytes, const unsigned char* data);
		bool write_bool(bool data);
		bool write_int32(int data);
		bool write_uint32(unsigned int data);
		bool write_data_type(char data);

		bool read(unsigned int bits, void* output);
		bool write(unsigned int bits, const void* data);

		void set_use_data_types(bool use_data_types);

		unsigned int size() const;

		std::string& get_buffer();

	private:
		std::string buffer_{};
		unsigned int current_bit_ = 0;
		bool use_data_types_ = true;
	};
}

```

`src/client/game/demonware/byte_buffer.cpp`:

```cpp
#include <std_include.hpp>
#include "byte_buffer.hpp"

namespace demonware
{
	bool byte_buffer::read_bool(bool* output)
	{
		if (!this->read_data_type(1)) return false;
		return this->read(1, output);
	}

	bool byte_buffer::read_byte(char* output)
	{
		if (!this->read_data_type(2)) return false;
		return this->read(1, output);
	}

	bool byte_buffer::read_ubyte(unsigned char* output)
	{
		if (!this->read_data_type(3)) return false;
		return this->read(1, output);
	}

	bool byte_buffer::read_int16(short* output)
	{
		if (!this->read_data_type(5)) return false;
		return this->read(2, output);
	}

	bool byte_buffer::read_uint16(unsigned short* output)
	{
		if (!this->read_data_type(6)) return false;
		return this->read(2, output);
	}

	bool byte_buffer::read_int32(int* output)
	{
		if (!this->read_data_type(7)) return false;
		return this->read(4, output);
	}

	bool byte_buffer::read_uint32(unsigned int* output)
	{
		if (!this->read_data_type(8)) return false;
		return this->read(4, output);
	}

	bool byte_buffer::read_int64(__int64* output)
	{
		if (!this->read_data_type(9)) return false;
		return this->read(8, output);
	}

	bool byte_buffer::read_uint64(unsigned __int64* output)
	{
		if (!this->read_data_type(10)) return false;
		return this->read(8, output);
	}

	bool byte_buffer::read_float(float* output)
	{
		if (!this->read_data_type(13)) return false;
		return this->read(4, output);
	}

	bool byte_buffer::read_string(std::string* output)
	{
		char* out_data;
		if (this->read_string(&out_data))
		{
			output->clear();
			output->append(out_data);
			return true;
		}

		return false;
	}

	bool byte_buffer::read_string(char** output)
	{
		if (!this->read_data_type(16)) return false;

		*output = const_cast<char*>(this->buffer_.data()) + this->current_byte_;
		this->current_byte_ += strlen(*output) + 1;

		return true;
	}

	bool byte_buffer::read_string(char* output, const int length)
	{
		if (!this->read_data_type(16)) return false;

		strcpy_s(output, length, const_cast<char*>(this->buffer_.data()) + this->current_byte_);
		this->current_byte_ += strlen(output) + 1;

		return true;
	}

	bool byte_buffer::read_blob(std::string* output)
	{
		char* out_data;
		int length;
		if (this->read_blob(&out_data, &length))
		{
			output->clear();
			output->append(out_data, length);
			return true;
		}

		return false;
	}

	bool byte_buffer::read_blob(char** output, int* length)
	{
		if (!this->read_data_type(0x13))
		{
			return false;
		}

		unsigned int size;
		this->read_uint32(&size);

		*output = const_cast<char*>(this->buffer_.data()) + this->current_byte_;
		*length = static_cast<int>(size);

		this->current_byte_ += size;

		return true;
	}

	bool byte_buffer::read_data_type(const char expected)
	{
		if (!this->use_data_types_) return true;

		char type;
		this->read(1, &type);
		return type == expected;
	}

	bool byte_buffer::read_array_header(const unsigned char expected, unsigned int* element_count,
	                                    unsigned int* element_size)
	{
		if (element_count) *element_count = 0;
		if (element_size) *element_size = 0;

		if (!this->read_data_type(expected + 100)) return false;

		uint32_t array_size, el_count;
		if (!this->read_uint32(&array_size)) return false;

		this->set_use_data_types(false);
		this->read_uint32(&el_count);
		this->set_use_data_types(true);

		if (element_count) *element_count = el_count;
		if (element_size) *element_size = array_size / el_count;

		return true;
	}

	bool byte_buffer::write_bool(bool data)
	{
		this->write_data_type(1);
		return this->write(1, &data);
	}

	bool byte_buffer::write_byte(char data)
	{
		this->write_data_type(2);
		return this->write(1, &data);
	}

	bool byte_buffer::write_ubyte(unsigned char data)
	{
		this->write_data_type(3);
		return this->write(1, &data);
	}

	bool byte_buffer::write_int16(short data)
	{
		this->write_data_type(5);
		return this->write(2, &data);
	}

	bool byte_buffer::write_uint16(unsigned short data)
	{
		this->write_data_type(6);
		return this->write(2, &data);
	}

	bool byte_buffer::write_int32(int data)
	{
		this->write_data_type(7);
		return this->write(4, &data);
	}

	bool byte_buffer::write_uint32(unsigned int data)
	{
		this->write_data_type(8);
		return this->write(4, &data);
	}

	bool byte_buffer::write_int64(__int64 data)
	{
		this->write_data_type(9);
		return this->write(8, &data);
	}

	bool byte_buffer::write_uint64(unsigned __int64 data)
	{
		this->write_data_type(10);
		return this->write(8, &data);
	}

	bool byte_buffer::write_data_type(char data)
	{
		if (!this->use_data_types_) return true;
		return this->write(1, &data);
	}

	bool byte_buffer::write_float(float data)
	{
		this->write_data_type(13);
		return this->write(4, &data);
	}

	bool byte_buffer::write_string(const std::string& data)
	{
		return this->write_string(data.data());
	}

	bool byte_buffer::write_string(const char* data)
	{
		this->write_data_type(16);
		return this->write(static_cast<int>(strlen(data)) + 1, data);
	}

	bool byte_buffer::write_blob(const std::string& data)
	{
		return this->write_blob(data.data(), INT(data.size()));
	}

	bool byte_buffer::write_blob(const char* data, const int length)
	{
		this->write_data_type(0x13);
		this->write_uint32(length);

		return this->write(length, data);
	}

	bool byte_buffer::write_array_header(const unsigned char type, const unsigned int element_count,
	                                     const unsigned int element_size)
	{
		const auto using_types = this->is_using_data_types();
		this->set_use_data_types(false);

		auto result = this->write_ubyte(type + 100);

		this->set_use_data_types(true);
		result &= this->write_uint32(element_count * element_size);
		this->set_use_data_types(false);

		result &= this->write_uint32(element_count);

		this->set_use_data_types(using_types);
		return result;
	}

	bool byte_buffer::read(const int bytes, void* output)
	{
		if (bytes + this->current_byte_ > this->buffer_.size()) return false;

		std::memmove(output, this->buffer_.data() + this->current_byte_, bytes);
		this->current_byte_ += bytes;

		return true;
	}

	bool byte_buffer::write(const int bytes, const void* data)
	{
		this->buffer_.append(static_cast<const char*>(data), bytes);
		this->current_byte_ += bytes;
		return true;
	}

	bool byte_buffer::write(const std::string& data)
	{
		return this->write(static_cast<int>(data.size()), data.data());
	}

	void byte_buffer::set_use_data_types(const bool use_data_types)
	{
		this->use_data_types_ = use_data_types;
	}

	size_t byte_buffer::size() const
	{
		return this->buffer_.size();
	}

	bool byte_buffer::is_using_data_types() const
	{
		return use_data_types_;
	}

	std::string& byte_buffer::get_buffer()
	{
		return this->buffer_;
	}

	std::string byte_buffer::get_remaining()
	{
		return std::string(this->buffer_.begin() + this->current_byte_, this->buffer_.end());
	}

	bool byte_buffer::has_more_data() const
	{
		return this->buffer_.size() > this->current_byte_;
	}
}

```

`src/client/game/demonware/byte_buffer.hpp`:

```hpp
#pragma once

namespace demonware
{
	class byte_buffer final
	{
	public:
		byte_buffer() = default;

		explicit byte_buffer(std::string buffer) : buffer_(std::move(buffer))
		{
		}

		bool read_bool(bool* output);
		bool read_byte(char* output);
		bool read_ubyte(unsigned char* output);
		bool read_int16(short* output);
		bool read_uint16(unsigned short* output);
		bool read_int32(int* output);
		bool read_uint32(unsigned int* output);
		bool read_int64(__int64* output);
		bool read_uint64(unsigned __int64* output);
		bool read_float(float* output);
		bool read_string(char** output);
		bool read_string(char* output, int length);
		bool read_string(std::string* output);
		bool read_blob(char** output, int* length);
		bool read_blob(std::string* output);
		bool read_data_type(char expected);

		bool read_array_header(unsigned char expected, unsigned int* element_count,
		                       unsigned int* element_size = nullptr);

		bool write_bool(bool data);
		bool write_byte(char data);
		bool write_ubyte(unsigned char data);
		bool write_int16(short data);
		bool write_uint16(unsigned short data);
		bool write_int32(int data);
		bool write_uint32(unsigned int data);
		bool write_int64(__int64 data);
		bool write_uint64(unsigned __int64 data);
		bool write_data_type(char data);
		bool write_float(float data);
		bool write_string(const char* data);
		bool write_string(const std::string& data);
		bool write_blob(const char* data, int length);
		bool write_blob(const std::string& data);

		bool write_array_header(unsigned char type, unsigned int element_count, unsigned int element_size);

		bool read(int bytes, void* output);
		bool write(int bytes, const void* data);
		bool write(const std::string& data);

		void set_use_data_types(bool use_data_types);
		size_t size() const;

		bool is_using_data_types() const;

		std::string& get_buffer();
		std::string get_remaining();

		bool has_more_data() const;

	private:
		std::string buffer_;
		size_t current_byte_ = 0;
		bool use_data_types_ = true;
	};
}

```

`src/client/game/demonware/data_types.hpp`:

```hpp
#pragma once

#include "byte_buffer.hpp"
#include "game/structs.hpp"

namespace demonware
{
	class bdTaskResult
	{
	public:
		virtual ~bdTaskResult() = default;

		virtual void serialize(byte_buffer*)
		{
		}

		virtual void deserialize(byte_buffer*)
		{
		}
	};

	class bdFileData final : public bdTaskResult
	{
	public:
		std::string file_data;

		explicit bdFileData(std::string buffer) : file_data(std::move(buffer))
		{
		}

		void serialize(byte_buffer* buffer) override
		{
			buffer->write_blob(this->file_data);
		}

		void deserialize(byte_buffer* buffer) override
		{
			buffer->read_blob(&this->file_data);
		}
	};

	class bdFileInfo final : public bdTaskResult
	{
	public:
		uint64_t file_id;
		uint32_t create_time;
		uint32_t modified_time;
		bool priv;
		uint64_t owner_id;
		std::string filename;
		uint32_t file_size;

		void serialize(byte_buffer* buffer) override
		{
			buffer->write_uint32(this->file_size);
			buffer->write_uint64(this->file_id);
			buffer->write_uint32(this->create_time);
			buffer->write_uint32(this->modified_time);
			buffer->write_bool(this->priv);
			buffer->write_uint64(this->owner_id);
			buffer->write_string(this->filename);
		}

		void deserialize(byte_buffer* buffer) override
		{
			buffer->read_uint32(&this->file_size);
			buffer->read_uint64(&this->file_id);
			buffer->read_uint32(&this->create_time);
			buffer->read_uint32(&this->modified_time);
			buffer->read_bool(&this->priv);
			buffer->read_uint64(&this->owner_id);
			buffer->read_string(&this->filename);
		}
	};

	struct bdFileQueryResult final : public bdTaskResult
	{
		std::uint64_t user_id;
		std::string platform;
		std::string filename;
		std::uint32_t errorcode;
		std::string filedata;

		void serialize(byte_buffer* data) override
		{
			data->write_uint64(user_id);
			data->write_string(platform);
			data->write_string(filename);
			data->write_uint32(errorcode);
			data->write_blob(filedata);
		}

		void deserialize(byte_buffer* data) override
		{
			data->read_uint64(&user_id);
			data->read_string(&platform);
			data->read_string(&filename);
			data->read_uint32(&errorcode);
			data->read_blob(&filedata);
		}
	};

	class bdTimeStamp final : public bdTaskResult
	{
	public:
		uint32_t unix_time;

		void serialize(byte_buffer* buffer) override
		{
			buffer->write_uint32(this->unix_time);
		}

		void deserialize(byte_buffer* buffer) override
		{
			buffer->read_uint32(&this->unix_time);
		}
	};

	class bdDMLInfo : public bdTaskResult
	{
	public:
		std::string country_code; // Char [3]
		std::string country; // Char [65]
		std::string region; // Char [65]
		std::string city; // Char [129]
		float latitude;
		float longitude;

		void serialize(byte_buffer* buffer) override
		{
			buffer->write_string(this->country_code);
			buffer->write_string(this->country);
			buffer->write_string(this->region);
			buffer->write_string(this->city);
			buffer->write_float(this->latitude);
			buffer->write_float(this->longitude);
		}

		void deserialize(byte_buffer* buffer) override
		{
			buffer->read_string(&this->country_code);
			buffer->read_string(&this->country);
			buffer->read_string(&this->region);
			buffer->read_string(&this->city);
			buffer->read_float(&this->latitude);
			buffer->read_float(&this->longitude);
		}
	};

	class bdDMLRawData final : public bdDMLInfo
	{
	public:
		uint32_t asn; // Autonomous System Number.
		std::string timezone;

		void serialize(byte_buffer* buffer) override
		{
			bdDMLInfo::serialize(buffer);

			buffer->write_uint32(this->asn);
			buffer->write_string(this->timezone);
		}

		void deserialize(byte_buffer* buffer) override
		{
			bdDMLInfo::deserialize(buffer);

			buffer->read_uint32(&this->asn);
			buffer->read_string(&this->timezone);
		}
	};

	// made up name
	class bdFile final : public bdTaskResult
	{
	public:
		uint64_t owner_id;
		std::string platform;
		std::string filename;
		uint32_t unk;
		std::string data;

		void serialize(byte_buffer* buffer) override
		{
			buffer->write_uint64(this->owner_id);
			buffer->write_string(this->platform);
			buffer->write_string(this->filename);
			buffer->write_uint32(this->unk);
			buffer->write_blob(this->data);
		}

		void deserialize(byte_buffer* buffer) override
		{
			buffer->read_uint64(&this->owner_id);
			buffer->read_string(&this->platform);
			buffer->read_string(&this->filename);
			buffer->read_uint32(&this->unk);
			buffer->read_blob(&this->data);
		}
	};

	class bdFile2 final : public bdTaskResult
	{
	public:
		uint32_t unk1;
		uint32_t unk2;
		uint32_t unk3;
		bool priv;
		uint64_t owner_id;
		std::string platform;
		std::string filename;
		std::string data;

		void serialize(byte_buffer* buffer) override
		{
			buffer->write_uint32(this->unk1);
			buffer->write_uint32(this->unk2);
			buffer->write_uint32(this->unk3);
			buffer->write_bool(this->priv);
			buffer->write_uint64(this->owner_id);
			buffer->write_string(this->platform);
			buffer->write_string(this->filename);
			buffer->write_blob(this->data);
		}

		void deserialize(byte_buffer* buffer) override
		{
			buffer->read_uint32(&this->unk1);
			buffer->read_uint32(&this->unk2);
			buffer->read_uint32(&this->unk3);
			buffer->read_bool(&this->priv);
			buffer->read_uint64(&this->owner_id);
			buffer->read_string(&this->platform);
			buffer->read_string(&this->filename);
			buffer->read_blob(&this->data);
		}
	};

	class bdContextUserStorageFileInfo final : public bdTaskResult
	{
	public:
		uint32_t create_time;
		uint32_t modifed_time;
		bool priv;
		uint64_t owner_id;
		std::string account_type;
		std::string filename;

		void serialize(byte_buffer* buffer) override
		{
			buffer->write_uint32(this->create_time);
			buffer->write_uint32(this->modifed_time);
			buffer->write_bool(this->priv);
			buffer->write_uint64(this->owner_id);
			buffer->write_string(this->account_type);
			buffer->write_string(this->filename);
		}

		void deserialize(byte_buffer* buffer) override
		{
			buffer->read_uint32(&this->create_time);
			buffer->read_uint32(&this->modifed_time);
			buffer->read_bool(&this->priv);
			buffer->read_uint64(&this->owner_id);
			buffer->read_string(&this->account_type);
			buffer->read_string(&this->filename);
		}
	};

	class bdPerformanceValue final : public bdTaskResult
	{
	public:
		uint64_t user_id;
		int64_t performance;

		void serialize(byte_buffer* buffer) override
		{
			buffer->write_uint64(this->user_id);
			buffer->write_int64(this->performance);
		}

		void deserialize(byte_buffer* buffer) override
		{
			buffer->read_uint64(&this->user_id);
			buffer->read_int64(&this->performance);
		}
	};

	class bdDDLChecksumResult final : public bdTaskResult
	{
	public:
		std::string checksum{};
		bool checksum_matched{};

		void serialize(byte_buffer* buffer) override
		{
			buffer->write_string(this->checksum);
			buffer->write_bool(this->checksum_matched);
		}

		void deserialize(byte_buffer* buffer) override
		{
			buffer->read_string(&this->checksum);
		}
	};

	struct bdSockAddr final
	{
		bdSockAddr() : in_un(), m_family(AF_INET)
		{
		}

		union
		{
			struct
			{
				char m_b1;
				char m_b2;
				char m_b3;
				char m_b4;
			} m_caddr;

			unsigned int m_iaddr;

			struct
			{
				unsigned __int16 m_w1;
				unsigned __int16 m_w2;
				unsigned __int16 m_w3;
				unsigned __int16 m_w4;
				unsigned __int16 m_w5;
				unsigned __int16 m_w6;
				unsigned __int16 m_w7;
				unsigned __int16 m_w8;
			} m_caddr6;

			char m_iaddr6[16];
			char m_sockaddr_storage[128];
		} in_un;

		unsigned __int16 m_family;
	};

	struct bdInetAddr final : bdTaskResult
	{
		bdSockAddr m_addr;

		bool is_valid() const
		{
			return (this->m_addr.m_family == AF_INET /*|| this->m_addr.m_family == AF_INET6*/);
		}

		void serialize(byte_buffer* buffer) override
		{
			const auto data_types = buffer->is_using_data_types();
			buffer->set_use_data_types(false);

			if (this->m_addr.m_family == AF_INET)
			{
				buffer->write(4, &this->m_addr.in_un.m_caddr);
			}

			buffer->set_use_data_types(data_types);
		}

		void deserialize(byte_buffer* buffer) override
		{
			const auto data_types = buffer->is_using_data_types();
			buffer->set_use_data_types(false);

			if (this->m_addr.m_family == AF_INET)
			{
				buffer->read(4, &this->m_addr.in_un.m_caddr);
			}

			buffer->set_use_data_types(data_types);
		}
	};

	struct bdAddr final : bdTaskResult
	{
		bdInetAddr m_address;
		unsigned __int16 m_port{};

		void serialize(byte_buffer* buffer) override
		{
			const bool data_types = buffer->is_using_data_types();
			buffer->set_use_data_types(false);

			this->m_address.serialize(buffer);
			buffer->write_uint16(this->m_port);

			buffer->set_use_data_types(data_types);
		}

		void deserialize(byte_buffer* buffer) override
		{
			const auto data_types = buffer->is_using_data_types();
			buffer->set_use_data_types(false);

			this->m_address.deserialize(buffer);
			buffer->read_uint16(&this->m_port);

			buffer->set_use_data_types(data_types);
		}
	};

	struct bdCommonAddr : bdTaskResult
	{
		bdAddr m_local_addrs[5];
		bdAddr m_public_addr;
		game::bdNATType m_nat_type;
		unsigned int m_hash;
		bool m_is_loopback;

		void serialize(byte_buffer* buffer) override
		{
			const auto data_types = buffer->is_using_data_types();
			buffer->set_use_data_types(false);

			auto valid = true;
			for (uint32_t i = 0; i < 5 && i < ARRAYSIZE(this->m_local_addrs) && valid; ++i)
			{
				this->m_local_addrs[i].serialize(buffer);
				valid = this->m_local_addrs[i].m_address.is_valid();
			}

			if (valid)
			{
				this->m_public_addr.serialize(buffer);
				buffer->write_byte(this->m_nat_type);
			}

			buffer->set_use_data_types(data_types);
		}

		void deserialize(byte_buffer* buffer) override
		{
			const auto data_types = buffer->is_using_data_types();
			buffer->set_use_data_types(false);

			auto valid = true;
			for (uint32_t i = 0; i < ARRAYSIZE(this->m_local_addrs) && valid; ++i)
			{
				bdAddr addr;
				addr.deserialize(buffer);
				this->m_local_addrs[i] = addr;
				valid = this->m_local_addrs[i].m_address.is_valid();
			}

			if (valid)
			{
				this->m_public_addr.deserialize(buffer);
				buffer->read_ubyte(reinterpret_cast<uint8_t*>(&this->m_nat_type));
			}

			buffer->set_use_data_types(data_types);
		}
	};

	class bdSessionID final : public bdTaskResult
	{
	public:
		uint64_t session_id;

		void serialize(byte_buffer* buffer) override
		{
			buffer->write_blob(LPSTR(&this->session_id), sizeof this->session_id);
		}

		void deserialize(byte_buffer* buffer) override
		{
			int size{};
			char* data{};
			buffer->read_blob(&data, &size);

			if (data && uint32_t(size) >= sizeof(this->session_id))
			{
				this->session_id = *reinterpret_cast<uint64_t*>(data);
			}
		}
	};

	class bdMatchMakingInfo final : bdTaskResult
	{
		bdSessionID m_sessionID;
		std::string m_hostAddr;
		uint32_t m_gameType;
		uint32_t m_maxPlayers;
		uint32_t m_numPlayers;

		void serialize(byte_buffer* buffer) override
		{
			buffer->write_blob(this->m_hostAddr);
			this->m_sessionID.serialize(buffer);
			buffer->write_uint32(this->m_gameType);
			buffer->write_uint32(this->m_maxPlayers);
			buffer->write_uint32(this->m_numPlayers);
		}

		void deserialize(byte_buffer* buffer) override
		{
			buffer->read_blob(&this->m_hostAddr);
			buffer->read_uint32(&this->m_gameType);
			buffer->read_uint32(&this->m_maxPlayers);
		}
	};
}

```

`src/client/game/demonware/keys.cpp`:

```cpp
#include <std_include.hpp>
#include "keys.hpp"

#include <utils/cryptography.hpp>
#include <utils/string.hpp>

namespace demonware
{
	struct data_t
	{
		char m_session_key[24];
		char m_response[8];
		char m_hmac_key[20];
		char m_enc_key[16];
		char m_dec_key[16];
	} data{};

	std::string packet_buffer;

	void calculate_hmacs_s1(const char* data_, const unsigned int data_size, const char* key,
	                        const unsigned int key_size,
	                        char* dst, const unsigned int dst_size)
	{
		char buffer[64];
		unsigned int pos = 0;
		unsigned int out_offset = 0;
		char count = 1;
		std::string result;

		// buffer add key
		std::memcpy(&buffer[pos], key, key_size);
		pos += key_size;

		// buffer add count
		buffer[pos] = count;
		pos++;

		// calculate hmac
		result = utils::cryptography::hmac_sha1::compute(std::string(buffer, pos), std::string(data_, data_size));

		// save output
		std::memcpy(dst, result.data(), std::min(20u, (dst_size - out_offset)));
		out_offset = 20;

		// second loop
		while (true)
		{
			// if we filled the output buffer, exit
			if (out_offset >= dst_size)
				break;

			// buffer add last result
			pos = 0;
			std::memcpy(&buffer[pos], result.data(), 20);
			pos += 20;

			// buffer add key
			std::memcpy(&buffer[pos], key, key_size);
			pos += key_size;

			// buffer add count
			count++;
			buffer[pos] = count;
			pos++;

			// calculate hmac
			result = utils::cryptography::hmac_sha1::compute(std::string(buffer, pos), std::string(data_, data_size));

			// save output
			std::memcpy(dst + out_offset, result.data(), std::min(20u, (dst_size - out_offset)));
			out_offset += 20;
		}
	}

	void derive_keys_s1()
	{
		const auto out_1 = utils::cryptography::sha1::compute(packet_buffer); // out_1 size 20

		auto data_3 = utils::cryptography::hmac_sha1::compute(data.m_session_key, out_1);

		char out_2[16];
		calculate_hmacs_s1(data_3.data(), 20, "CLIENTCHAL", 10, out_2, 16);

		char out_3[72];
		calculate_hmacs_s1(data_3.data(), 20, "BDDATA", 6, out_3, 72);

		std::memcpy(data.m_response, &out_2[8], 8);
		std::memcpy(data.m_hmac_key, &out_3[20], 20);
		std::memcpy(data.m_dec_key, &out_3[40], 16);
		std::memcpy(data.m_enc_key, &out_3[56], 16);

#ifndef NDEBUG
		printf("[DW] Response id: %s\n", utils::string::dump_hex(std::string(&out_2[8], 8)).data());
		printf("[DW] Hash verify: %s\n", utils::string::dump_hex(std::string(&out_3[20], 20)).data());
		printf("[DW] AES dec key: %s\n", utils::string::dump_hex(std::string(&out_3[40], 16)).data());
		printf("[DW] AES enc key: %s\n", utils::string::dump_hex(std::string(&out_3[56], 16)).data());
		printf("[DW] Bravo 6, going dark.\n");
#endif
	}

	void queue_packet_to_hash(const std::string& packet)
	{
		packet_buffer.append(packet);
	}

	void set_session_key(const std::string& key)
	{
		std::memcpy(data.m_session_key, key.data(), 24);
	}

	std::string get_decrypt_key()
	{
		return std::string(data.m_dec_key, 16);
	}

	std::string get_encrypt_key()
	{
		return std::string(data.m_enc_key, 16);
	}

	std::string get_hmac_key()
	{
		return std::string(data.m_hmac_key, 20);
	}

	std::string get_response_id()
	{
		return std::string(data.m_response, 8);
	}
}

```

`src/client/game/demonware/keys.hpp`:

```hpp
#pragma once

namespace demonware
{
	void derive_keys_s1();
	void queue_packet_to_hash(const std::string& packet);
	void set_session_key(const std::string& key);
	std::string get_decrypt_key();
	std::string get_encrypt_key();
	std::string get_hmac_key();
	std::string get_response_id();
}

```

`src/client/game/demonware/reply.cpp`:

```cpp
#include <std_include.hpp>
#include "keys.hpp"
#include "reply.hpp"
#include "servers/service_server.hpp"

#include <utils/cryptography.hpp>

namespace demonware
{
	std::string unencrypted_reply::data()
	{
		byte_buffer result;
		result.set_use_data_types(false);

		result.write_int32(static_cast<int>(this->buffer_.size()) + 2);
		result.write_bool(false);
		result.write_ubyte(this->type());
		result.write(this->buffer_);

		return result.get_buffer();
	}

	std::string encrypted_reply::data()
	{
		byte_buffer result;
		result.set_use_data_types(false);

		byte_buffer enc_buffer;
		enc_buffer.set_use_data_types(false);

		enc_buffer.write_uint32(static_cast<unsigned int>(this->buffer_.size())); // service data size CHECKTHIS!!
		enc_buffer.write_ubyte(this->type()); // TASK_REPLY type
		enc_buffer.write(this->buffer_); // service data

		auto aligned_data = enc_buffer.get_buffer();
		auto size = aligned_data.size();
		size = ~15 & (size + 15); // 16 byte align
		aligned_data.resize(size);

		// seed
		std::string seed("\x5E\xED\x5E\xED\x5E\xED\x5E\xED\x5E\xED\x5E\xED\x5E\xED\x5E\xED", 16);

		// encrypt
		const auto enc_data = utils::cryptography::aes::encrypt(aligned_data, seed, demonware::get_encrypt_key());

		// header : encrypted service data : hash
		static auto msg_count = 0;
		msg_count++;

		byte_buffer response;
		response.set_use_data_types(false);

		response.write_int32(30 + static_cast<int>(enc_data.size()));
		response.write_ubyte(static_cast<unsigned char>(0xAB));
		response.write_ubyte(static_cast<unsigned char>(0x85));
		response.write_int32(msg_count);
		response.write(16, seed.data());
		response.write(enc_data);

		// hash entire packet and append end
		auto hash_data = utils::cryptography::hmac_sha1::compute(response.get_buffer(), demonware::get_hmac_key());
		hash_data.resize(8);
		response.write(8, hash_data.data());

		return response.get_buffer();
	}

	void remote_reply::send(bit_buffer* buffer, const bool encrypted)
	{
		std::unique_ptr<typed_reply> reply;

		if (encrypted) reply = std::make_unique<encrypted_reply>(this->type_, buffer);
		else reply = std::make_unique<unencrypted_reply>(this->type_, buffer);

		this->server_->send_reply(reply.get());
	}

	void remote_reply::send(byte_buffer* buffer, const bool encrypted)
	{
		std::unique_ptr<typed_reply> reply;

		if (encrypted) reply = std::make_unique<encrypted_reply>(this->type_, buffer);
		else reply = std::make_unique<unencrypted_reply>(this->type_, buffer);

		this->server_->send_reply(reply.get());
	}
}

```

`src/client/game/demonware/reply.hpp`:

```hpp
#pragma once

#include "bit_buffer.hpp"
#include "byte_buffer.hpp"
#include "data_types.hpp"

namespace demonware
{
	class reply
	{
	public:
		reply() = default;

		reply(reply&&) = delete;
		reply(const reply&) = delete;
		reply& operator=(reply&&) = delete;
		reply& operator=(const reply&) = delete;

		virtual ~reply() = default;
		virtual std::string data() = 0;
	};

	class raw_reply : public reply
	{
	protected:
		std::string buffer_;

	public:
		raw_reply() = default;

		explicit raw_reply(std::string data) : buffer_(std::move(data))
		{
		}

		std::string data() override
		{
			return this->buffer_;
		}
	};

	class typed_reply : public raw_reply
	{
	public:
		typed_reply(const uint8_t _type) : type_(_type)
		{
		}

	protected:
		uint8_t type() const { return this->type_; }

	private:
		uint8_t type_;
	};

	class encrypted_reply final : public typed_reply
	{
	public:
		encrypted_reply(const uint8_t type, bit_buffer* bbuffer) : typed_reply(type)
		{
			this->buffer_.append(bbuffer->get_buffer());
		}

		encrypted_reply(const uint8_t type, byte_buffer* bbuffer) : typed_reply(type)
		{
			this->buffer_.append(bbuffer->get_buffer());
		}

		std::string data() override;
	};

	class unencrypted_reply final : public typed_reply
	{
	public:
		unencrypted_reply(const uint8_t _type, bit_buffer* bbuffer) : typed_reply(_type)
		{
			this->buffer_.append(bbuffer->get_buffer());
		}

		unencrypted_reply(const uint8_t _type, byte_buffer* bbuffer) : typed_reply(_type)
		{
			this->buffer_.append(bbuffer->get_buffer());
		}

		std::string data() override;
	};

	class service_server;

	class remote_reply final
	{
	public:
		remote_reply(service_server* server, uint8_t _type) : type_(_type), server_(server)
		{
		}

		void send(bit_buffer* buffer, bool encrypted);
		void send(byte_buffer* buffer, bool encrypted);

		uint8_t type() const { return this->type_; }

	private:
		uint8_t type_;
		service_server* server_;
	};

	class service_reply final
	{
	public:
		service_reply(service_server* _server, const uint8_t _type, const uint32_t _error)
			: type_(_type), error_(_error), reply_(_server, 1)
		{
		}

		uint64_t send()
		{
			static uint64_t id = 0x0000000000000000;
			const auto transaction_id = ++id;

			byte_buffer buffer;
			buffer.write_uint64(transaction_id);
			buffer.write_uint32(this->error_);
			buffer.write_ubyte(this->type_);

			if (!this->error_)
			{
				buffer.write_uint32(uint32_t(this->objects_.size()));
				if (!this->objects_.empty())
				{
					buffer.write_uint32(uint32_t(this->objects_.size()));

					for (auto& object : this->objects_)
					{
						object->serialize(&buffer);
					}

					this->objects_.clear();
				}
			}
			else
			{
				buffer.write_uint64(transaction_id);
			}

			this->reply_.send(&buffer, true);
			return transaction_id;
		}

		void add(const std::shared_ptr<bdTaskResult>& object)
		{
			this->objects_.push_back(object);
		}

		void add(bdTaskResult* object)
		{
			this->add(std::shared_ptr<bdTaskResult>(object));
		}

	private:
		uint8_t type_;
		uint32_t error_;
		remote_reply reply_;
		std::vector<std::shared_ptr<bdTaskResult>> objects_;
	};
}

```

`src/client/game/demonware/server_registry.hpp`:

```hpp
#pragma once

#include "servers/base_server.hpp"
#include <utils/cryptography.hpp>

namespace demonware
{
	template <typename T>
	class server_registry
	{
		static_assert(std::is_base_of<base_server, T>::value, "Invalid server registry type");

	public:
		template <typename S, typename ...Args>
		void create(Args&&... args)
		{
			static_assert(std::is_base_of<T, S>::value, "Invalid server type");

			auto server = std::make_unique<S>(std::forward<Args>(args)...);
			const auto address = server->get_address();
			servers_[address] = std::move(server);
		}

		void for_each(const std::function<void(T&)>& callback) const
		{
			for (auto& server : servers_)
			{
				callback(*server.second);
			}
		}

		T* find(const std::string& name)
		{
			const auto address = utils::cryptography::jenkins_one_at_a_time::compute(name);
			return find(address);
		}

		T* find(const uint32_t address)
		{
			const auto it = servers_.find(address);
			if (it == servers_.end())
			{
				return nullptr;
			}

			return it->second.get();
		}

		void frame()
		{
			for (auto& server : servers_)
			{
				server.second->frame();
			}
		}

	private:
		std::unordered_map<uint32_t, std::unique_ptr<T>> servers_;
	};
}

```

`src/client/game/demonware/servers/auth3_server.cpp`:

```cpp
#include <std_include.hpp>

#include "auth3_server.hpp"
#include "../keys.hpp"

#include <utils/cryptography.hpp>
#include <utils/string.hpp>

namespace demonware
{
	namespace
	{
#pragma pack(push, 1)
		struct auth_ticket
		{
			unsigned int m_magicNumber;
			char m_type;
			unsigned int m_titleID;
			unsigned int m_timeIssued;
			unsigned int m_timeExpires;
			unsigned __int64 m_licenseID;
			unsigned __int64 m_userID;
			char m_username[64];
			char m_sessionKey[24];
			char m_usingHashMagicNumber[3];
			char m_hash[4];
		};
#pragma pack(pop)
	}

	void auth3_server::send_reply(reply* data)
	{
		if (!data) return;
		this->send(data->data());
	}

	void auth3_server::handle(const std::string& packet)
	{
		if (packet.starts_with("POST /auth/"))
		{
#ifndef NDEBUG
			printf("[DW]: [auth]: user requested authentication.\n");
#endif
			return;
		}

		unsigned int title_id = 0;
		unsigned int iv_seed = 0;
		std::string identity{};
		std::string token{};

		rapidjson::Document j;
		j.Parse(packet.data(), packet.size());

		if (j.HasMember("title_id") && j["title_id"].IsString())
		{
			title_id = std::stoul(j["title_id"].GetString());
		}

		if (j.HasMember("iv_seed") && j["iv_seed"].IsString())
		{
			iv_seed = std::stoul(j["iv_seed"].GetString());
		}

		if (j.HasMember("identity") && j["identity"].IsString())
		{
			identity = j["identity"].GetString();
		}

		if (j.HasMember("extra_data") && j["extra_data"].IsString())
		{
			rapidjson::Document extra_data;
			auto& ed = j["extra_data"];
			extra_data.Parse(ed.GetString(), ed.GetStringLength());

			if (extra_data.HasMember("token") && extra_data["token"].IsString())
			{
				auto& token_field = extra_data["token"];
				std::string token_b64(token_field.GetString(), token_field.GetStringLength());
				token = utils::cryptography::base64::decode(token_b64);
			}
		}

#ifndef NDEBUG
		printf("[DW]: [auth]: authenticating user %s\n", token.data() + 64);
#endif

		std::string auth_key(reinterpret_cast<char*>(token.data() + 32), 24);
		std::string session_key(
			"\x13\x37\x13\x37\x13\x37\x13\x37\x13\x37\x13\x37\x13\x37\x13\x37\x13\x37\x13\x37\x13\x37\x13\x37", 24);

		// client_ticket
		auth_ticket ticket{};
		std::memset(&ticket, 0x0, sizeof ticket);
		ticket.m_magicNumber = 0x0EFBDADDE;
		ticket.m_type = 0;
		ticket.m_titleID = title_id;
		ticket.m_timeIssued = static_cast<uint32_t>(time(nullptr));
		ticket.m_timeExpires = ticket.m_timeIssued + 30000;
		ticket.m_licenseID = 0;
		ticket.m_userID = reinterpret_cast<uint64_t>(token.data() + 56);
		strncpy_s(ticket.m_username, sizeof(ticket.m_username), reinterpret_cast<char*>(token.data() + 64), 64);
		std::memcpy(ticket.m_sessionKey, session_key.data(), 24);

		const auto iv = utils::cryptography::tiger::compute(std::string(reinterpret_cast<char*>(&iv_seed), 4));
		const auto ticket_enc = utils::cryptography::des3::encrypt(
			std::string(reinterpret_cast<char*>(&ticket), sizeof(ticket)), iv, auth_key);
		const auto ticket_b64 = utils::cryptography::base64::encode(
			reinterpret_cast<const unsigned char*>(ticket_enc.data()), 128);

		// server_ticket
		uint8_t auth_data[128];
		std::memset(&auth_data, 0, sizeof auth_data);
		std::memcpy(auth_data, session_key.data(), 24);
		const auto auth_data_b64 = utils::cryptography::base64::encode(auth_data, 128);

		demonware::set_session_key(session_key);

		// header time
		char date[64];
		const auto now = time(nullptr);
		tm gmtm{};
		gmtime_s(&gmtm, &now);
		strftime(date, 64, "%a, %d %b %G %T", &gmtm);

		rapidjson::Document extra;
		extra.SetObject();

		std::string username = std::string(ticket.m_username, sizeof(ticket.m_username)).data();
		extra.AddMember("username", username, extra.GetAllocator());
		extra.AddMember("time_to_live", 9999, extra.GetAllocator());

		const auto lul = utils::cryptography::base64::encode("lul");
		extra.AddMember("extended_data", lul, extra.GetAllocator());

		rapidjson::StringBuffer extra_buffer{};
		rapidjson::Writer<rapidjson::StringBuffer, rapidjson::Document::EncodingType, rapidjson::ASCII<>>
			extra_writer(extra_buffer);
		extra.Accept(extra_writer);

		std::string extra_data{};
		extra_data.append(extra_buffer.GetString(), extra_buffer.GetLength());
		// json content
		rapidjson::Document doc;
		doc.SetObject();

		doc.AddMember("auth_task", "29", doc.GetAllocator());
		doc.AddMember("code", "700", doc.GetAllocator());

		auto seed = std::to_string(iv_seed);
		doc.AddMember("iv_seed", seed, doc.GetAllocator());
		doc.AddMember("client_ticket", ticket_b64, doc.GetAllocator());
		doc.AddMember("server_ticket", auth_data_b64, doc.GetAllocator());
		doc.AddMember("client_id", "", doc.GetAllocator());
		doc.AddMember("account_type", "steam", doc.GetAllocator());
		doc.AddMember("crossplay_enabled", false, doc.GetAllocator());
		doc.AddMember("loginqueue_eanbled", false, doc.GetAllocator());
		doc.AddMember("identity", identity, doc.GetAllocator());
		doc.AddMember("extra_data", extra_data, doc.GetAllocator());

		rapidjson::Value value{};
		doc.AddMember("lsg_endpoint", value, doc.GetAllocator());

		rapidjson::StringBuffer buffer{};
		rapidjson::Writer<rapidjson::StringBuffer, rapidjson::Document::EncodingType, rapidjson::ASCII<>>
			writer(buffer);
		doc.Accept(writer);

		// http stuff
		std::string result;
		result.append("HTTP/1.1 200 OK\r\n");
		result.append("Server: TornadoServer/4.5.3\r\n");
		result.append("Content-Type: application/json\r\n");
		result.append(utils::string::va("Date: %s GMT\r\n", date));
		result.append(utils::string::va("Content-Length: %d\r\n\r\n", buffer.GetLength()));
		result.append(buffer.GetString(), buffer.GetLength());

		raw_reply reply(result);

		this->send_reply(&reply);

#ifndef NDEBUG
		printf("[DW]: [auth]: user successfully authenticated.\n");
#endif
	}
}

```

`src/client/game/demonware/servers/auth3_server.hpp`:

```hpp
#pragma once
#include "tcp_server.hpp"
#include "../reply.hpp"

namespace demonware
{
	class auth3_server : public tcp_server
	{
	public:
		using tcp_server::tcp_server;

	private:
		void send_reply(reply* data);
		void handle(const std::string& packet) override;
	};
}

```

`src/client/game/demonware/servers/base_server.cpp`:

```cpp
#include <std_include.hpp>
#include "base_server.hpp"

#include <utils/cryptography.hpp>

namespace demonware
{
	base_server::base_server(std::string name): name_(std::move(name))
	{
		this->address_ = utils::cryptography::jenkins_one_at_a_time::compute(this->name_);
	}

	const std::string& base_server::get_name() const
	{
		return this->name_;
	}

	uint32_t base_server::get_address() const
	{
		return this->address_;
	}
}

```

`src/client/game/demonware/servers/base_server.hpp`:

```hpp
#pragma once

namespace demonware
{
	class base_server
	{
	public:
		using stream_queue = std::queue<char>;
		using data_queue = std::queue<std::string>;

		base_server(std::string name);

		base_server(base_server&&) = delete;
		base_server(const base_server&) = delete;
		base_server& operator=(base_server&&) = delete;
		base_server& operator=(const base_server&) = delete;

		virtual ~base_server() = default;

		const std::string& get_name() const;

		uint32_t get_address() const;

		virtual void frame() = 0;

	private:
		std::string name_;
		std::uint32_t address_ = 0;
	};
}

```

`src/client/game/demonware/servers/lobby_server.cpp`:

```cpp
#include <std_include.hpp>
#include "lobby_server.hpp"

#include "../services.hpp"
#include "../keys.hpp"

#include <utils/cryptography.hpp>

namespace demonware
{
	lobby_server::lobby_server(std::string name) : tcp_server(std::move(name))
	{
		this->register_service<bdAnticheat>();
		this->register_service<bdBandwidthTest>();
		this->register_service<bdContentStreaming>();
		this->register_service<bdCounter>();
		this->register_service<bdDML>();
		this->register_service<bdEventLog>();
		this->register_service<bdGroup>();
		this->register_service<bdTeams>();
		this->register_service<bdStats>();
		this->register_service<bdStats2>();
		this->register_service<bdStats3>();
		this->register_service<bdStorage>();
		this->register_service<bdTitleUtilities>();
		this->register_service<bdProfiles>();
		this->register_service<bdRichPresence>();
		this->register_service<bdFacebook>();
		this->register_service<bdUNK63>();
		this->register_service<bdUserGroups>();
		this->register_service<bdMarketplace>();
		this->register_service<bdLeague>();
		this->register_service<bdLeague2>();
		this->register_service<bdPublisherVariables>();
		this->register_service<bdDDL>();
		this->register_service<bdPresence>();
		this->register_service<bdMarketingComms>();
		this->register_service<bdMatchMaking>();
		this->register_service<bdReward>();
	};

	void lobby_server::send_reply(reply* data)
	{
		if (!data) return;
		this->send(data->data());
	}

	void lobby_server::handle(const std::string& packet)
	{
		byte_buffer buffer(packet);
		buffer.set_use_data_types(false);

		try
		{
			while (buffer.has_more_data())
			{
				int size;
				buffer.read_int32(&size);

				if (size <= 0)
				{
					const std::string zero("\x00\x00\x00\x00", 4);
					raw_reply reply(zero);
					this->send_reply(&reply);
					return;
				}
				else if (size == 0xC8)
				{
#ifndef NDEBUG
					printf("[DW]: [lobby]: received client_header_ack.\n");
#endif

					int c8;
					buffer.read_int32(&c8);
					std::string packet_1 = buffer.get_remaining();
					demonware::queue_packet_to_hash(packet_1);

					const std::string packet_2(
						"\x16\x00\x00\x00\xab\x81\xd2\x00\x00\x00\x13\x37\x13\x37\x13\x37\x13\x37\x13\x37\x13\x37\x13\x37\x13\x37",
						26);
					demonware::queue_packet_to_hash(packet_2);

					raw_reply reply(packet_2);
					this->send_reply(&reply);
#ifndef NDEBUG
					printf("[DW]: [lobby]: sending server_header_ack.\n");
#endif
					return;
				}

				if (buffer.size() < size_t(size)) return;

				uint8_t check_ab;
				buffer.read_ubyte(&check_ab);
				if (check_ab == 0xAB)
				{
					uint8_t type;
					buffer.read_ubyte(&type);

					if (type == 0x82)
					{
#ifndef NDEBUG
						printf("[DW]: [lobby]: received client_auth.\n");
#endif
						std::string packet_3(packet.data(), packet.size() - 8); // this 8 are client hash check?

						demonware::queue_packet_to_hash(packet_3);
						demonware::derive_keys_s1();

						char buff[14] = "\x0A\x00\x00\x00\xAB\x83";
						std::memcpy(&buff[6], demonware::get_response_id().data(), 8);
						std::string response(buff, 14);

						raw_reply reply(response);
						this->send_reply(&reply);

#ifndef NDEBUG
						printf("[DW]: [lobby]: sending server_auth_done.\n");
#endif
						return;
					}
					else if (type == 0x85)
					{
						uint32_t msg_count;
						buffer.read_uint32(&msg_count);

						char seed[16];
						buffer.read(16, &seed);

						std::string enc = buffer.get_remaining();

						char hash[8];
						std::memcpy(hash, &(enc.data()[enc.size() - 8]), 8);

						std::string dec = utils::cryptography::aes::decrypt(
							std::string(enc.data(), enc.size() - 8), std::string(seed, 16),
							demonware::get_decrypt_key());

						byte_buffer serv(dec);
						serv.set_use_data_types(false);

						uint32_t serv_size;
						serv.read_uint32(&serv_size);

						uint8_t magic; // 0x86
						serv.read_ubyte(&magic);

						uint8_t service_id;
						serv.read_ubyte(&service_id);

						this->call_service(service_id, serv.get_remaining());

						return;
					}
				}

				printf("[DW]: [lobby]: ERROR! received unk message.\n");
				return;
			}
		}
		catch (...)
		{
		}
	}

	void lobby_server::call_service(const uint8_t id, const std::string& data)
	{
		const auto& it = this->services_.find(id);

		if (it != this->services_.end())
		{
			it->second->exec_task(this, data);
		}
		else
		{
			printf("[DW]: [lobby]: missing service '%s'\n", utils::string::va("%d", id));

			// return no error
			byte_buffer buffer(data);
			uint8_t task_id;
			buffer.read_ubyte(&task_id);

			this->create_reply(task_id)->send();
		}
	}
}

```

`src/client/game/demonware/servers/lobby_server.hpp`:

```hpp
#pragma once

#include "tcp_server.hpp"
#include "service_server.hpp"
#include "../service.hpp"

namespace demonware
{
	class lobby_server : public tcp_server, service_server
	{
	public:
		lobby_server(std::string name);

		template <typename T>
		void register_service()
		{
			static_assert(std::is_base_of<service, T>::value, "service must inherit from service");

			auto service = std::make_unique<T>();
			const uint8_t id = service->id();

			this->services_[id] = std::move(service);
		}

		void send_reply(reply* data) override;

	private:
		std::unordered_map<uint8_t, std::unique_ptr<service>> services_;

		void handle(const std::string& packet) override;
		void call_service(uint8_t id, const std::string& data);
	};
}

```

`src/client/game/demonware/servers/service_server.hpp`:

```hpp
#pragma once

#include "../reply.hpp"

namespace demonware
{
	class service_server
	{
	public:
		virtual ~service_server() = default;

		virtual std::shared_ptr<remote_reply> create_message(uint8_t type)
		{
			auto reply = std::make_shared<remote_reply>(this, type);
			return reply;
		}


		virtual std::shared_ptr<service_reply> create_reply(uint8_t type, uint32_t error = 0)
		{
			auto reply = std::make_shared<service_reply>(this, type, error);
			return reply;
		}

		virtual void send_reply(reply* data) = 0;
	};
}

```

`src/client/game/demonware/servers/stun_server.cpp`:

```cpp
#include <std_include.hpp>
#include "stun_server.hpp"

#include "../byte_buffer.hpp"

namespace demonware
{
	void stun_server::handle(const endpoint_data& endpoint, const std::string& packet)
	{
		uint8_t type, version, padding;

		byte_buffer buffer(packet);
		buffer.set_use_data_types(false);
		buffer.read_ubyte(&type);
		buffer.read_ubyte(&version);
		buffer.read_ubyte(&padding);

		switch (type)
		{
		case 30:
			this->ip_discovery(endpoint);
			break;
		case 20:
			this->nat_discovery(endpoint);
			break;
		default:
			break;
		}
	}

	void stun_server::ip_discovery(const endpoint_data& endpoint)
	{
		const uint32_t ip = 0x0100007f;

		byte_buffer buffer;
		buffer.set_use_data_types(false);
		buffer.write_ubyte(31); // type
		buffer.write_ubyte(2); // version
		buffer.write_ubyte(0); // version
		buffer.write_uint32(ip); // external ip
		buffer.write_uint16(3074); // port

		this->send(endpoint, buffer.get_buffer());
	}

	void stun_server::nat_discovery(const endpoint_data& endpoint)
	{
		const uint32_t ip = 0x0100007f;

		byte_buffer buffer;
		buffer.set_use_data_types(false);
		buffer.write_ubyte(21); // type
		buffer.write_ubyte(2); // version
		buffer.write_ubyte(0); // version
		buffer.write_uint32(ip); // external ip
		buffer.write_uint16(3074); // port
		buffer.write_uint32(this->get_address()); // server ip
		buffer.write_uint16(3074); // server port

		this->send(endpoint, buffer.get_buffer());
	}
}

```

`src/client/game/demonware/servers/stun_server.hpp`:

```hpp
#pragma once

#include "udp_server.hpp"

namespace demonware
{
	class stun_server : public udp_server
	{
	public:
		using udp_server::udp_server;

	private:
		void handle(const endpoint_data& endpoint, const std::string& packet) override;

		void ip_discovery(const endpoint_data& endpoint);
		void nat_discovery(const endpoint_data& endpoint);
	};
}

```

`src/client/game/demonware/servers/tcp_server.cpp`:

```cpp
#include <std_include.hpp>
#include "tcp_server.hpp"

namespace demonware
{
	void tcp_server::handle_input(const char* buf, size_t size)
	{
		in_queue_.access([&](data_queue& queue)
		{
			queue.emplace(buf, size);
		});
	}

	size_t tcp_server::handle_output(char* buf, size_t size)
	{
		if (out_queue_.get_raw().empty())
		{
			return 0;
		}

		return out_queue_.access<size_t>([&](stream_queue& queue)
		{
			for (size_t i = 0; i < size; ++i)
			{
				if (queue.empty())
				{
					return i;
				}

				buf[i] = queue.front();
				queue.pop();
			}

			return size;
		});
	}

	bool tcp_server::pending_data()
	{
		return !this->out_queue_.get_raw().empty();
	}

	void tcp_server::frame()
	{
		if (this->in_queue_.get_raw().empty())
		{
			return;
		}

		while (true)
		{
			std::string packet{};
			const auto result = this->in_queue_.access<bool>([&](data_queue& queue)
			{
				if (queue.empty())
				{
					return false;
				}

				packet = std::move(queue.front());
				queue.pop();
				return true;
			});

			if (!result)
			{
				break;
			}

			this->handle(packet);
		}
	}

	void tcp_server::send(const std::string& data)
	{
		out_queue_.access([&](stream_queue& queue)
		{
			for (const auto& val : data)
			{
				queue.push(val);
			}
		});
	}
}

```

`src/client/game/demonware/servers/tcp_server.hpp`:

```hpp
#pragma once

#include "base_server.hpp"
#include <utils/concurrency.hpp>

namespace demonware
{
	class tcp_server : public base_server
	{
	public:
		using base_server::base_server;

		void handle_input(const char* buf, size_t size);
		size_t handle_output(char* buf, size_t size);
		bool pending_data();
		void frame() override;

	protected:
		virtual void handle(const std::string& data) = 0;

		void send(const std::string& data);

	private:
		utils::concurrency::container<data_queue> in_queue_;
		utils::concurrency::container<stream_queue> out_queue_;
	};
}

```

`src/client/game/demonware/servers/udp_server.cpp`:

```cpp
#include <std_include.hpp>
#include "udp_server.hpp"

namespace demonware
{
	void udp_server::handle_input(const char* buf, size_t size, endpoint_data endpoint)
	{
		in_queue_.access([&](in_queue& queue)
		{
			in_packet p;
			p.data = std::string{buf, size};
			p.endpoint = std::move(endpoint);

			queue.emplace(std::move(p));
		});
	}

	size_t udp_server::handle_output(SOCKET socket, char* buf, size_t size, sockaddr* address, int* addrlen)
	{
		return out_queue_.access<size_t>([&](socket_queue_map& map) -> size_t
		{
			const auto entry = map.find(socket);
			if (entry == map.end())
			{
				return 0;
			}

			auto& queue = entry->second;

			if (queue.empty())
			{
				return 0;
			}

			auto data = std::move(queue.front());
			queue.pop();

			const auto copy_size = std::min(size, data.data.size());
			std::memcpy(buf, data.data.data(), copy_size);
			std::memcpy(address, &data.address, sizeof(data.address));
			*addrlen = sizeof(data.address);

			return copy_size;
		});
	}

	bool udp_server::pending_data(SOCKET socket)
	{
		return this->out_queue_.access<bool>([&](const socket_queue_map& map)
		{
			const auto entry = map.find(socket);
			if (entry == map.end())
			{
				return false;
			}

			return !entry->second.empty();
		});
	}

	void udp_server::send(const endpoint_data& endpoint, std::string data)
	{
		out_queue_.access([&](socket_queue_map& map)
		{
			out_packet p;
			p.data = std::move(data);
			p.address = endpoint.address;

			map[endpoint.socket].emplace(std::move(p));
		});
	}

	void udp_server::frame()
	{
		if (this->in_queue_.get_raw().empty())
		{
			return;
		}

		while (true)
		{
			in_packet packet{};
			const auto result = this->in_queue_.access<bool>([&](in_queue& queue)
			{
				if (queue.empty())
				{
					return false;
				}

				packet = std::move(queue.front());
				queue.pop();
				return true;
			});

			if (!result)
			{
				break;
			}

			this->handle(packet.endpoint, std::move(packet.data));
		}
	}
}

```

`src/client/game/demonware/servers/udp_server.hpp`:

```hpp
#pragma once

#include "base_server.hpp"
#include <utils/concurrency.hpp>

namespace demonware
{
	class udp_server : public base_server
	{
	public:
		struct endpoint_data
		{
			SOCKET socket{};
			sockaddr_in address{};

			endpoint_data() = default;

			endpoint_data(const SOCKET sock, const sockaddr* addr, const int size)
			{
				if (size != sizeof(this->address))
				{
					throw std::runtime_error("Invalid size");
				}

				this->socket = sock;
				std::memcpy(&this->address, addr, sizeof(this->address));
			}
		};

		using base_server::base_server;

		void handle_input(const char* buf, size_t size, endpoint_data endpoint);
		size_t handle_output(SOCKET socket, char* buf, size_t size, sockaddr* address, int* addrlen);
		bool pending_data(SOCKET socket);

		void frame() override;

	protected:
		virtual void handle(const endpoint_data& endpoint, const std::string& data) = 0;
		void send(const endpoint_data& endpoint, std::string data);

	private:
		struct in_packet
		{
			std::string data;
			endpoint_data endpoint;
		};

		struct out_packet
		{
			std::string data;
			sockaddr_in address;
		};

		using in_queue = std::queue<in_packet>;
		using out_queue = std::queue<out_packet>;
		using socket_queue_map = std::unordered_map<SOCKET, out_queue>;

		utils::concurrency::container<in_queue> in_queue_;
		utils::concurrency::container<socket_queue_map> out_queue_;
	};
}

```

`src/client/game/demonware/servers/umbrella_server.cpp`:

```cpp
#include <std_include.hpp>

#include "umbrella_server.hpp"

namespace demonware
{
	void umbrella_server::handle(const std::string& packet)
	{
		// TODO:
	}
}

```

`src/client/game/demonware/servers/umbrella_server.hpp`:

```hpp
#pragma once
#include "tcp_server.hpp"

namespace demonware
{
	class umbrella_server : public tcp_server
	{
	public:
		using tcp_server::tcp_server;

	private:
		void handle(const std::string& packet) override;
	};
}

```

`src/client/game/demonware/service.hpp`:

```hpp
#pragma once
#include <utils/string.hpp>
#include "servers/service_server.hpp"

namespace demonware
{
	class service
	{
		using callback_t = std::function<void(service_server*, byte_buffer*)>;

		uint8_t id_;
		std::string name_;
		std::mutex mutex_;
		uint8_t task_id_;
		std::map<uint8_t, callback_t> tasks_;

	public:
		virtual ~service() = default;
		service(service&&) = delete;
		service(const service&) = delete;
		service& operator=(const service&) = delete;

		service(const uint8_t id, std::string name) : id_(id), name_(std::move(name)), task_id_(0)
		{
		}

		uint8_t id() const
		{
			return this->id_;
		}

		const std::string& name() const
		{
			return this->name_;
		}

		uint8_t task_id() const
		{
			return this->task_id_;
		}

		virtual void exec_task(service_server* server, const std::string& data)
		{
			std::lock_guard<std::mutex> _(this->mutex_);

			byte_buffer buffer(data);

			buffer.read_ubyte(&this->task_id_);

			const auto& it = this->tasks_.find(this->task_id_);

			if (it != this->tasks_.end())
			{
#ifndef NDEBUG
				printf("[DW] %s: executing task '%d'\n", name_.data(), this->task_id_);
#endif

				it->second(server, &buffer);
			}
			else
			{
				printf("[DW] %s: missing task '%d'\n", name_.data(), this->task_id_);

				// return no error
				server->create_reply(this->task_id_)->send();
			}
		}

	protected:

		template <typename Class, typename T, typename... Args>
		void register_task(const uint8_t id, T (Class::* callback)(Args ...) const)
		{
			this->tasks_[id] = [this, callback](Args ... args) -> T
			{
				return (reinterpret_cast<Class*>(this)->*callback)(args...);
			};
		}

		template <typename Class, typename T, typename... Args>
		void register_task(const uint8_t id, T (Class::* callback)(Args ...))
		{
			this->tasks_[id] = [this, callback](Args ... args) -> T
			{
				return (reinterpret_cast<Class*>(this)->*callback)(args...);
			};
		}
	};
}

```

`src/client/game/demonware/services.hpp`:

```hpp
#pragma once

#include "bit_buffer.hpp"
#include "byte_buffer.hpp"
#include "data_types.hpp"
#include "reply.hpp"
#include "service.hpp"
#include "servers/service_server.hpp"

#include "services/bdTeams.hpp"             //  3
#include "services/bdStats.hpp"             //  4
//#include "services/bdMessaging.hpp"       //  6
#include "services/bdProfiles.hpp"          //  8
#include "services/bdStorage.hpp"           // 10
#include "services/bdTitleUtilities.hpp"    // 12
#include "services/bdBandwidthTest.hpp"     // 18
#include "services/bdStats2.hpp"            // 19
#include "services/bdCounter.hpp"           // 23
#include "services/bdDML.hpp"               // 27
#include "services/bdGroup.hpp"             // 28
//#include "services/bdCMail.hpp"           // 29
#include "services/bdFacebook.hpp"          // 36
#include "services/bdAnticheat.hpp"         // 38
#include "services/bdContentStreaming.hpp"  // 50
//#include "services/bdTags.hpp"            // 52
#include "services/bdUNK63.hpp"             // 63
#include "services/bdUserGroups.hpp"        // 65
#include "services/bdEventLog.hpp"          // 67
#include "services/bdRichPresence.hpp"      // 68
//#include "services/bdTencent.hpp"			// 71
//#include "services/bdCodOnlineTeams.hpp"  // 72
#include "services/bdMarketplace.hpp"       // 80
#include "services/bdLeague.hpp"		    // 81
#include "services/bdLeague2.hpp"			// 82
#include "services/bdStats3.hpp"            // 91
#include "services/bdPublisherVariables.hpp"// 95
#include "services/bdDDL.hpp"               // 96
// AccountLinking                           // 86
#include "services/bdPresence.hpp"          //103
#include "services/bdMarketingComms.hpp"    //104
#include "services/bdMatchMaking.hpp"       //138
#include "services/bdReward.hpp"            //139

```

`src/client/game/demonware/services/bdAnticheat.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdAnticheat::bdAnticheat() : service(38, "bdAnticheat")
	{
		this->register_task(2, &bdAnticheat::answerChallenges);
		this->register_task(3, &bdAnticheat::reportConsoleID);
		this->register_task(4, &bdAnticheat::reportConsoleDetails);
		this->register_task(5, &bdAnticheat::answerTOTPChallenge);
		this->register_task(6, &bdAnticheat::idk);
	}

	void bdAnticheat::answerChallenges(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO: Read data as soon as needed
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdAnticheat::reportConsoleID(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO: Read data as soon as needed
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
	
	void bdAnticheat::reportConsoleDetails(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO: Read data as soon as needed
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdAnticheat::answerTOTPChallenge(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO: Read data as soon as needed
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdAnticheat::idk(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO: Read data as soon as needed
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdAnticheat.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdAnticheat final : public service
	{
	public:
		bdAnticheat();

	private:
		void answerChallenges(service_server* server, byte_buffer* buffer) const;
		void reportConsoleID(service_server* server, byte_buffer* buffer) const;
		void reportConsoleDetails(service_server* server, byte_buffer* buffer) const;
		void answerTOTPChallenge(service_server* server, byte_buffer* buffer) const;
		void idk(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdBandwidthTest.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	static uint8_t bandwidth_iw6[51] =
	{
		0x0F, 0xC1, 0x1C, 0x37, 0xB8, 0xEF, 0x7C, 0xD6, 0x00, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0xF4, 0x01, 0x00, 0x00, 0xD0, 0x07,
		0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x88, 0x13, 0x00, 0x00, 0xF4, 0x01,
		0x00, 0x00, 0x02, 0x0C, 0x88, 0xB3, 0x04, 0x65, 0x89, 0xBF, 0xC3, 0x6A,
		0x27, 0x94, 0xD4, 0x8F
	};

	bdBandwidthTest::bdBandwidthTest() : service(18, "bdBandwidthTest")
	{
	}

	void bdBandwidthTest::exec_task(service_server* server, const std::string& data)
	{
		byte_buffer buffer;
		buffer.write(sizeof bandwidth_iw6, bandwidth_iw6);

		auto reply = server->create_message(5);
		reply->send(&buffer, true);
	}
}

```

`src/client/game/demonware/services/bdBandwidthTest.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdBandwidthTest final : public service
	{
	public:
		bdBandwidthTest();

	private:
		void exec_task(service_server* server, const std::string& data) override;
	};
}

```

`src/client/game/demonware/services/bdContentStreaming.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"
#include "game/game.hpp"

namespace demonware
{
	bdContentStreaming::bdContentStreaming() : service(50, "bdContentStreaming")
	{
		this->register_task(2, &bdContentStreaming::unk2);
		this->register_task(3, &bdContentStreaming::list_all_publisher_files);
	}

	void bdContentStreaming::unk2(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdContentStreaming::list_all_publisher_files(service_server* server, byte_buffer* buffer) const
	{
		std::uint32_t start_date;
		buffer->read_uint32(&start_date);

		std::uint16_t max_num_results;
		buffer->read_uint16(&max_num_results);

		std::uint16_t offset;
		buffer->read_uint16(&offset);

		std::uint16_t category;
		buffer->read_uint16(&category);

		std::string filename;
		buffer->read_string(&filename);

		/*if(filename.empty())
		{
			server->create_reply(this->task_id(), game::BD_NO_FILE)->send();
			return;
		}*/

		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdContentStreaming.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdContentStreaming final : public service
	{
	public:
		bdContentStreaming();

	private:
		void unk2(service_server* server, byte_buffer* buffer) const;
		void list_all_publisher_files(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdCounter.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdCounter::bdCounter() : service(23, "bdCounter")
	{
		this->register_task(1, &bdCounter::incrementCounters);
		this->register_task(2, &bdCounter::getCounterTotals);
	}

	void bdCounter::incrementCounters(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdCounter::getCounterTotals(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdCounter.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdCounter final : public service
	{
	public:
		bdCounter();

	private:
		void incrementCounters(service_server* server, byte_buffer* buffer) const;
		void getCounterTotals(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdDDL.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdDDL::bdDDL() : service(96, "bdDDL")
	{
		this->register_task(1, &bdDDL::verifyDDLFiles);
	}

	void bdDDL::verifyDDLFiles(service_server* server, byte_buffer* buffer) const
	{
		uint32_t count;
		buffer->read_uint32(&count);

		const auto reply = server->create_reply(this->task_id());

		for (uint32_t i = 0; i < count; i++)
		{
			auto* checksum = new bdDDLChecksumResult;
			checksum->deserialize(buffer);
			checksum->checksum_matched = true;

			reply->add(checksum);
		}

		reply->send();
	}
}

```

`src/client/game/demonware/services/bdDDL.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdDDL final : public service
	{
	public:
		bdDDL();

	private:
		void verifyDDLFiles(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdDML.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdDML::bdDML() : service(27, "bdDML")
	{
		this->register_task(1, &bdDML::recordIP);
		this->register_task(2, &bdDML::getUserData);
		this->register_task(3, &bdDML::getUserHierarchicalData);
		this->register_task(4, &bdDML::getUsersLastLogonData);
	}

	void bdDML::recordIP(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdDML::getUserData(service_server* server, byte_buffer* /*buffer*/) const
	{
		auto result = new bdDMLRawData;
		result->country_code = "US";
		result->country_code = "'Murica";
		result->region = "New York";
		result->city = "New York";
		result->latitude = 0;
		result->longitude = 0;

		result->asn = 0x2119;
		result->timezone = "+01:00";

		auto reply = server->create_reply(this->task_id());
		reply->add(result);
		reply->send();
	}

	void bdDML::getUserHierarchicalData(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdDML::getUsersLastLogonData(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdDML.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdDML final : public service
	{
	public:
		bdDML();

	private:
		void recordIP(service_server* server, byte_buffer* buffer) const;
		void getUserData(service_server* server, byte_buffer* buffer) const;
		void getUserHierarchicalData(service_server* server, byte_buffer* buffer) const;
		void getUsersLastLogonData(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdEventLog.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdEventLog::bdEventLog() : service(67, "bdEventLog")
	{
		this->register_task(1, &bdEventLog::recordEvent);
		this->register_task(2, &bdEventLog::recordEventBin);
		this->register_task(3, &bdEventLog::recordEvents);
		this->register_task(4, &bdEventLog::recordEventsBin);
		this->register_task(6, &bdEventLog::initializeFiltering);
	}

	void bdEventLog::recordEvent(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdEventLog::recordEventBin(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdEventLog::recordEvents(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdEventLog::recordEventsBin(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdEventLog::initializeFiltering(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdEventLog.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdEventLog final : public service
	{
	public:
		bdEventLog();

	private:
		void recordEvent(service_server* server, byte_buffer* buffer) const;
		void recordEventBin(service_server* server, byte_buffer* buffer) const;
		void recordEvents(service_server* server, byte_buffer* buffer) const;
		void recordEventsBin(service_server* server, byte_buffer* buffer) const;
		void initializeFiltering(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdFacebook.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdFacebook::bdFacebook() : service(36, "bdFacebook")
	{
		this->register_task(1, &bdFacebook::registerAccount);
		this->register_task(2, &bdFacebook::post);
		this->register_task(3, &bdFacebook::unregisterAccount);
		this->register_task(5, &bdFacebook::isRegistered);
		this->register_task(6, &bdFacebook::getInfo);
		this->register_task(7, &bdFacebook::getRegisteredAccounts);
		this->register_task(8, &bdFacebook::getFriends);
		this->register_task(9, &bdFacebook::getProfilePictures);
		this->register_task(10, &bdFacebook::uploadPhoto);
		this->register_task(11, &bdFacebook::registerToken);
		this->register_task(12, &bdFacebook::uploadVideo);
		this->register_task(13, &bdFacebook::getFriendsByID);
		this->register_task(14, &bdFacebook::setLikeStatus);
	}

	void bdFacebook::registerAccount(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdFacebook::post(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdFacebook::unregisterAccount(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdFacebook::isRegistered(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdFacebook::getInfo(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdFacebook::getRegisteredAccounts(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdFacebook::getFriends(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdFacebook::getProfilePictures(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdFacebook::uploadPhoto(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdFacebook::registerToken(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdFacebook::uploadVideo(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdFacebook::getFriendsByID(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdFacebook::setLikeStatus(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdFacebook.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdFacebook final : public service
	{
	public:
		bdFacebook();

	private:
		void registerAccount(service_server* server, byte_buffer* buffer) const;
		void post(service_server* server, byte_buffer* buffer) const;
		void unregisterAccount(service_server* server, byte_buffer* buffer) const;
		void isRegistered(service_server* server, byte_buffer* buffer) const;
		void getInfo(service_server* server, byte_buffer* buffer) const;
		void getRegisteredAccounts(service_server* server, byte_buffer* buffer) const;
		void getFriends(service_server* server, byte_buffer* buffer) const;
		void getProfilePictures(service_server* server, byte_buffer* buffer) const;
		void uploadPhoto(service_server* server, byte_buffer* buffer) const;
		void registerToken(service_server* server, byte_buffer* buffer) const;
		void uploadVideo(service_server* server, byte_buffer* buffer) const;
		void getFriendsByID(service_server* server, byte_buffer* buffer) const;
		void setLikeStatus(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdGroup.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdGroup::bdGroup() : service(28, "bdGroup")
	{
		this->register_task(1, &bdGroup::setGroups);
		this->register_task(2, &bdGroup::setGroupsForEntity);
		this->register_task(3, &bdGroup::getEntityGroups);
		this->register_task(4, &bdGroup::getGroupCounts);
	}

	void bdGroup::setGroups(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdGroup::setGroupsForEntity(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdGroup::getEntityGroups(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdGroup::getGroupCounts(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdGroup.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdGroup final : public service
	{
	public:
		bdGroup();

	private:
		void setGroups(service_server* server, byte_buffer* buffer) const;
		void setGroupsForEntity(service_server* server, byte_buffer* buffer) const;
		void getEntityGroups(service_server* server, byte_buffer* buffer) const;
		void getGroupCounts(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdLeague.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdLeague::bdLeague() : service(81, "bdLeague")
	{
		this->register_task(1, &bdLeague::getTeamID);
		this->register_task(2, &bdLeague::getTeamIDsForUser);
		this->register_task(3, &bdLeague::getTeamSubdivisions);
		this->register_task(4, &bdLeague::setTeamName);
		this->register_task(5, &bdLeague::setTeamIcon);
		this->register_task(6, &bdLeague::getTeamInfos);
		this->register_task(7, &bdLeague::getTeamLeaguesAndSubdivisions);
		this->register_task(8, &bdLeague::getTeamMemberInfos);
		this->register_task(10, &bdLeague::incrementGamesPlayedCount);
		this->register_task(20, &bdLeague::getSubdivisionInfos);
		this->register_task(21, &bdLeague::getTeamSubdivisionHistory);
	}

	void bdLeague::getTeamID(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague::getTeamIDsForUser(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague::getTeamSubdivisions(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague::setTeamName(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague::setTeamIcon(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague::getTeamInfos(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague::getTeamLeaguesAndSubdivisions(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague::getTeamMemberInfos(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague::incrementGamesPlayedCount(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague::getSubdivisionInfos(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague::getTeamSubdivisionHistory(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}
```

`src/client/game/demonware/services/bdLeague.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdLeague final : public service
	{
	public:
		bdLeague();

	private:
		void getTeamID(service_server* server, byte_buffer* buffer) const;
		void getTeamIDsForUser(service_server* server, byte_buffer* buffer) const;
		void getTeamSubdivisions(service_server* server, byte_buffer* buffer) const;
		void setTeamName(service_server* server, byte_buffer* buffer) const;
		void setTeamIcon(service_server* server, byte_buffer* buffer) const;
		void getTeamInfos(service_server* server, byte_buffer* buffer) const;
		void getTeamLeaguesAndSubdivisions(service_server* server, byte_buffer* buffer) const;
		void getTeamMemberInfos(service_server* server, byte_buffer* buffer) const;
		void incrementGamesPlayedCount(service_server* server, byte_buffer* buffer) const;
		void getSubdivisionInfos(service_server* server, byte_buffer* buffer) const;
		void getTeamSubdivisionHistory(service_server* server, byte_buffer* buffer) const;
	};
}
```

`src/client/game/demonware/services/bdLeague2.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdLeague2::bdLeague2() : service(82, "bdLeague")
	{
		this->register_task(1, &bdLeague2::writeStats);
		this->register_task(2, &bdLeague2::readStatsByTeamID);
		this->register_task(3, &bdLeague2::readStatsByRank);
		this->register_task(4, &bdLeague2::readStatsByPivot);
	}

	void bdLeague2::writeStats(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague2::readStatsByTeamID(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague2::readStatsByRank(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdLeague2::readStatsByPivot(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}
```

`src/client/game/demonware/services/bdLeague2.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdLeague2 final : public service
	{
	public:
		bdLeague2();

	private:
		void writeStats(service_server* server, byte_buffer* buffer) const;
		void readStatsByTeamID(service_server* server, byte_buffer* buffer) const;
		void readStatsByRank(service_server* server, byte_buffer* buffer) const;
		void readStatsByPivot(service_server* server, byte_buffer* buffer) const;
	};
}
```

`src/client/game/demonware/services/bdMarketingComms.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdMarketingComms::bdMarketingComms() : service(104, "bdMarketingComms")
	{
		this->register_task(1, &bdMarketingComms::getMessages);
		this->register_task(4, &bdMarketingComms::reportFullMessagesViewed);
	}

	void bdMarketingComms::getMessages(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdMarketingComms::reportFullMessagesViewed(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdMarketingComms.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdMarketingComms final : public service
	{
	public:
		bdMarketingComms();

	private:
		void getMessages(service_server* server, byte_buffer* buffer) const;
		void reportFullMessagesViewed(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdMarketplace.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

#include <utils/io.hpp>

namespace demonware
{
	bdMarketplace::bdMarketplace() : service(80, "bdMarketplace")
	{
		this->register_task(42, &bdMarketplace::startExchangeTransaction); // COD POINTS purchase ?
		//this->register_task(43, &bdMarketplace::purchaseOnSteamInitialize); // COD POINTS purchase ?
		this->register_task(49, &bdMarketplace::getExpiredInventoryItems);
		this->register_task(60, &bdMarketplace::steamProcessDurable);
		this->register_task(122, &bdMarketplace::purchaseSkus);
		this->register_task(130, &bdMarketplace::getBalance);
		this->register_task(165, &bdMarketplace::getInventoryPaginated);
		this->register_task(193, &bdMarketplace::putPlayersInventoryItems);
		this->register_task(232, &bdMarketplace::getEntitlements);
	}

	void bdMarketplace::startExchangeTransaction(service_server* server, byte_buffer* buffer) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdMarketplace::purchaseOnSteamInitialize(service_server* server, byte_buffer* buffer) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdMarketplace::getExpiredInventoryItems(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdMarketplace::steamProcessDurable(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdMarketplace::purchaseSkus(service_server* server, byte_buffer* buffer) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdMarketplace::getBalance(service_server* server, byte_buffer* buffer) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());

		reply->send();
	}

	void bdMarketplace::getInventoryPaginated(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdMarketplace::putPlayersInventoryItems(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdMarketplace::getEntitlements(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdMarketplace.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdMarketplace final : public service
	{
	public:
		bdMarketplace();

	private:
		void startExchangeTransaction(service_server* server, byte_buffer* buffer) const;
		void purchaseOnSteamInitialize(service_server* server, byte_buffer* buffer) const;
		void getExpiredInventoryItems(service_server* server, byte_buffer* buffer) const;
		void steamProcessDurable(service_server* server, byte_buffer* buffer) const;
		void purchaseSkus(service_server* server, byte_buffer* buffer) const;
		void getBalance(service_server* server, byte_buffer* buffer) const;
		void getInventoryPaginated(service_server* server, byte_buffer* buffer) const;
		void putPlayersInventoryItems(service_server* server, byte_buffer* buffer) const;
		void getEntitlements(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdMatchMaking.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"
#include "steam/steam.hpp"

namespace demonware
{
	bdMatchMaking::bdMatchMaking() : service(21, "bdMatchMaking")
	{
		this->register_task(1, &bdMatchMaking::create_session);
		this->register_task(2, &bdMatchMaking::update_session);
		this->register_task(3, &bdMatchMaking::delete_session);
		this->register_task(5, &bdMatchMaking::find_sessions);
		this->register_task(10, &bdMatchMaking::get_performance);
	}

	void bdMatchMaking::create_session(service_server* server, byte_buffer* /*buffer*/) const
	{
		auto* id = new bdSessionID;
		id->session_id = steam::SteamUser()->GetSteamID().bits;

		auto reply = server->create_reply(this->task_id());
		reply->add(id);
		reply->send();
	}

	void bdMatchMaking::update_session(service_server* server, byte_buffer* buffer) const
	{
		/*MatchMakingInfo mmInfo;
		mmInfo.session_id.deserialize(buffer);
		mmInfo.deserialize(buffer);

		byte_buffer out_data;
		mmInfo.symmetric = true;
		mmInfo.serialize(&out_data);

		byte_buffer addr_buf(mmInfo.host_addr);
		bdCommonAddr addr;
		addr.deserialize(&addr_buf);*/

		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdMatchMaking::delete_session(service_server* server, byte_buffer* buffer) const
	{
		bdSessionID id;
		id.deserialize(buffer);

		byte_buffer out_data;
		id.serialize(&out_data);

		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdMatchMaking::get_performance(service_server* server, byte_buffer* /*buffer*/) const
	{
		auto* result = new bdPerformanceValue;
		result->user_id = steam::SteamUser()->GetSteamID().bits;
		result->performance = 10;

		auto reply = server->create_reply(this->task_id());
		reply->add(result);
		reply->send();
	}

	void bdMatchMaking::find_sessions(service_server* server, byte_buffer* /*buffer*/) const
	{
		auto reply = server->create_reply(this->task_id());

		//for (auto& session : sessions)
		{
			//reply->add(session.second);
		}

		reply->send();
	}
}

```

`src/client/game/demonware/services/bdMatchMaking.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdMatchMaking final : public service
	{
	public:
		bdMatchMaking();

	private:
		void create_session(service_server* server, byte_buffer* buffer) const;
		void update_session(service_server* server, byte_buffer* buffer) const;
		void delete_session(service_server* server, byte_buffer* buffer) const;
		void get_performance(service_server* server, byte_buffer* buffer) const;
		void find_sessions(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdPresence.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdPresence::bdPresence() : service(103, "bdPresence")
	{
		this->register_task(1, &bdPresence::unk1);
		this->register_task(3, &bdPresence::unk3);
	}

	void bdPresence::unk1(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdPresence::unk3(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdPresence.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdPresence final : public service
	{
	public:
		bdPresence();

	private:
		void unk1(service_server* server, byte_buffer* buffer) const;
		void unk3(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdProfiles.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdProfiles::bdProfiles() : service(8, "bdProfiles")
	{
		this->register_task(1, &bdProfiles::getPublicInfos);
		this->register_task(2, &bdProfiles::getPrivateInfo);
		this->register_task(3, &bdProfiles::setPublicInfo);
		this->register_task(4, &bdProfiles::setPrivateInfo);
		this->register_task(5, &bdProfiles::deleteProfile);
		this->register_task(6, &bdProfiles::setPrivateInfoByUserID);
		this->register_task(7, &bdProfiles::getPrivateInfoByUserID);
		this->register_task(8, &bdProfiles::setPublicInfoByUserID);
	}

	void bdProfiles::getPublicInfos(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdProfiles::setPublicInfo(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdProfiles::getPrivateInfo(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdProfiles::setPrivateInfo(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdProfiles::deleteProfile(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdProfiles::setPrivateInfoByUserID(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdProfiles::getPrivateInfoByUserID(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdProfiles::setPublicInfoByUserID(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdProfiles.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdProfiles final : public service
	{
	public:
		bdProfiles();

	private:
		void getPublicInfos(service_server* server, byte_buffer* buffer) const;
		void getPrivateInfo(service_server* server, byte_buffer* buffer) const;
		void setPublicInfo(service_server* server, byte_buffer* buffer) const;
		void setPrivateInfo(service_server* server, byte_buffer* buffer) const;
		void deleteProfile(service_server* server, byte_buffer* buffer) const;
		void setPrivateInfoByUserID(service_server* server, byte_buffer* buffer) const;
		void getPrivateInfoByUserID(service_server* server, byte_buffer* buffer) const;
		void setPublicInfoByUserID(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdPublisherVariables.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdPublisherVariables::bdPublisherVariables() : service(95, "bdPublisherVariables")
	{
		this->register_task(1, &bdPublisherVariables::retrievePublisherVariables);
	}

	void bdPublisherVariables::retrievePublisherVariables(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdPublisherVariables.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdPublisherVariables final : public service
	{
	public:
		bdPublisherVariables();

	private:
		void retrievePublisherVariables(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdReward.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdReward::bdReward() : service(139, "bdReward")
	{
		this->register_task(1, &bdReward::incrementTime);
		this->register_task(2, &bdReward::claimRewardRoll);
		this->register_task(3, &bdReward::claimClientAchievements);
		this->register_task(4, &bdReward::reportRewardEvents);
	}

	void bdReward::incrementTime(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdReward::claimRewardRoll(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdReward::claimClientAchievements(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdReward::reportRewardEvents(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdReward.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdReward final : public service
	{
	public:
		bdReward();

	private:
		void incrementTime(service_server* server, byte_buffer* buffer) const;
		void claimRewardRoll(service_server* server, byte_buffer* buffer) const;
		void claimClientAchievements(service_server* server, byte_buffer* buffer) const;
		void reportRewardEvents(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdRichPresence.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdRichPresence::bdRichPresence() : service(68, "bdRichPresence")
	{
		this->register_task(1, &bdRichPresence::setInfo);
		this->register_task(2, &bdRichPresence::getInfo);
	}

	void bdRichPresence::setInfo(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdRichPresence::getInfo(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdRichPresence.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdRichPresence final : public service
	{
	public:
		bdRichPresence();

	private:
		void setInfo(service_server* server, byte_buffer* buffer) const;
		void getInfo(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdStats.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdStats::bdStats() : service(4, "bdStats")
	{
		this->register_task(1, &bdStats::writeStats);
		this->register_task(2, &bdStats::deleteStats);
		this->register_task(3, &bdStats::unk3); // leaderboards
		this->register_task(4, &bdStats::readStatsByRank);
		this->register_task(5, &bdStats::readStatsByPivot);
		this->register_task(6, &bdStats::readStatsByRating);
		this->register_task(7, &bdStats::readStatsByMultipleRanks);
		this->register_task(8, &bdStats::readExternalTitleStats);
		this->register_task(10, &bdStats::readExternalTitleNamedStats);
		this->register_task(11, &bdStats::readStatsByLeaderboardIDsAndEntityIDs);
		this->register_task(12, &bdStats::readStatsByMultipleRatings);
		this->register_task(13, &bdStats::readStatsByEntityID);
		this->register_task(14, &bdStats::writeServerValidatedStats);
	}

	void bdStats::writeStats(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats::deleteStats(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats::unk3(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats::readStatsByRank(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats::readStatsByPivot(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats::readStatsByRating(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats::readStatsByMultipleRanks(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats::readExternalTitleStats(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats::readExternalTitleNamedStats(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats::readStatsByLeaderboardIDsAndEntityIDs(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats::readStatsByMultipleRatings(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats::readStatsByEntityID(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats::writeServerValidatedStats(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdStats.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdStats final : public service
	{
	public:
		bdStats();

	private:
		void writeStats(service_server* server, byte_buffer* buffer) const;
		void deleteStats(service_server* server, byte_buffer* buffer) const;
		void unk3(service_server* server, byte_buffer* buffer) const;
		void readStatsByRank(service_server* server, byte_buffer* buffer) const;
		void readStatsByPivot(service_server* server, byte_buffer* buffer) const;
		void readStatsByRating(service_server* server, byte_buffer* buffer) const;
		void readStatsByMultipleRanks(service_server* server, byte_buffer* buffer) const;
		void readExternalTitleStats(service_server* server, byte_buffer* buffer) const;
		void readExternalTitleNamedStats(service_server* server, byte_buffer* buffer) const;
		void readStatsByLeaderboardIDsAndEntityIDs(service_server* server, byte_buffer* buffer) const;
		void readStatsByMultipleRatings(service_server* server, byte_buffer* buffer) const;
		void readStatsByEntityID(service_server* server, byte_buffer* buffer) const;
		void writeServerValidatedStats(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdStats2.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdStats2::bdStats2() : service(19, "bdStats")
	{
		this->register_task(1, &bdStats2::startArbitratedSession);
		this->register_task(2, &bdStats2::writeArbitratedStats);
	}

	void bdStats2::startArbitratedSession(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats2::writeArbitratedStats(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}
```

`src/client/game/demonware/services/bdStats2.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdStats2 final : public service
	{
	public:
		bdStats2();

	private:
		void startArbitratedSession(service_server* server, byte_buffer* buffer) const;
		void writeArbitratedStats(service_server* server, byte_buffer* buffer) const;
	};
}
```

`src/client/game/demonware/services/bdStats3.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdStats3::bdStats3() : service(91, "bdStats")
	{
		this->register_task(1, &bdStats3::deleteCSFileStats);
		this->register_task(3, &bdStats3::readStatsByEntityID);
		this->register_task(4, &bdStats3::readStatsByRank);
		this->register_task(5, &bdStats3::readStatsByPivot);
		this->register_task(6, &bdStats3::readStatsByRating);
		this->register_task(7, &bdStats3::readStatsByMultipleRanks);
		this->register_task(11, &bdStats3::readStatsByLeaderboardIDsAndEntityIDs);
	}

	void bdStats3::deleteCSFileStats(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats3::readStatsByEntityID(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats3::readStatsByRank(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats3::readStatsByPivot(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats3::readStatsByRating(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats3::readStatsByMultipleRanks(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdStats3::readStatsByLeaderboardIDsAndEntityIDs(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}
```

`src/client/game/demonware/services/bdStats3.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdStats3 final : public service
	{
	public:
		bdStats3();

	private:
		void deleteCSFileStats(service_server* server, byte_buffer* buffer) const;
		void readStatsByEntityID(service_server* server, byte_buffer* buffer) const;
		void readStatsByRank(service_server* server, byte_buffer* buffer) const;
		void readStatsByPivot(service_server* server, byte_buffer* buffer) const;
		void readStatsByRating(service_server* server, byte_buffer* buffer) const;
		void readStatsByMultipleRanks(service_server* server, byte_buffer* buffer) const;
		void readStatsByLeaderboardIDsAndEntityIDs(service_server* server, byte_buffer* buffer) const;
	};
}
```

`src/client/game/demonware/services/bdStorage.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

#include <utils/nt.hpp>
#include <utils/io.hpp>
#include <utils/cryptography.hpp>
#include <utils/compression.hpp>

#include "resource.hpp"
#include "game/game.hpp"

namespace demonware
{
	bdStorage::bdStorage() : service(10, "bdStorage")
	{
		this->register_task(20, &bdStorage::list_publisher_files);
		this->register_task(21, &bdStorage::get_publisher_file);
		this->register_task(24, &bdStorage::upload_files);
		this->register_task(18, &bdStorage::upload_files_new);
		this->register_task(16, &bdStorage::get_files);
		this->register_task(12, &bdStorage::unk12);
		this->register_task(10, &bdStorage::set_user_file);

		this->map_publisher_resource("motd-.*\\.gz", DW_MOTD);
		this->map_publisher_resource("playlists(_.+)?\\.gz", DW_PLAYLISTS);
		this->map_publisher_resource("featured_cards(.+)?\\.gz", DW_CARDS);
		this->map_publisher_resource(".*ffotd.*\\.ff", DW_FASTFILE);
		this->map_publisher_resource("keys\\.txt", DW_KEYS);
		this->map_publisher_resource("qosconfig4\\.csv", DW_QOSCONFIG);
	}

	void bdStorage::map_publisher_resource(const std::string& expression, const INT id)
	{
		auto data = utils::nt::load_resource(id);
		this->map_publisher_resource_variant(expression, std::move(data));
	}

	void bdStorage::map_publisher_resource_variant(const std::string& expression, resource_variant resource)
	{
		if (resource.valueless_by_exception())
		{
			throw std::runtime_error("Publisher resource variant is empty!");
		}

		this->publisher_resources_.emplace_back(std::regex{expression}, std::move(resource));
	}

	bool bdStorage::load_publisher_resource(const std::string& name, std::string& buffer)
	{
		for (const auto& resource : this->publisher_resources_)
		{
			if (std::regex_match(name, resource.first))
			{
				if (std::holds_alternative<std::string>(resource.second))
				{
					buffer = std::get<std::string>(resource.second);
				}
				else
				{
					buffer = std::get<callback>(resource.second)();
				}

				if (utils::string::ends_with(name, ".gz"))
				{
					buffer = utils::compression::zlib::compress(buffer);
				}

				return true;
			}
		}

#ifndef NDEBUG
		printf("[DW]: [bdStorage]: missing publisher file: %s\n", name.data());
#endif

		return false;
	}

	void bdStorage::list_publisher_files(service_server* server, byte_buffer* buffer)
	{
		uint32_t date;
		uint16_t num_results, offset;
		std::string unk, filename, data;

		buffer->read_string(&unk);
		buffer->read_uint32(&date);
		buffer->read_uint16(&num_results);
		buffer->read_uint16(&offset);
		buffer->read_string(&filename);

#ifndef NDEBUG
		printf("[DW]: [bdStorage]: list publisher files: %s\n", filename.data());
#endif

		auto reply = server->create_reply(this->task_id());

		if (this->load_publisher_resource(filename, data))
		{
			auto* info = new bdFileInfo;

			info->file_id = *reinterpret_cast<const uint64_t*>(utils::cryptography::sha1::compute(filename).data());
			info->filename = filename;
			info->create_time = 0;
			info->modified_time = info->create_time;
			info->file_size = uint32_t(data.size());
			info->owner_id = 0;
			info->priv = false;

			reply->add(info);
		}

		reply->send();
	}

	void bdStorage::get_publisher_file(service_server* server, byte_buffer* buffer)
	{
		std::string unk, filename;
		buffer->read_string(&unk);
		buffer->read_string(&filename);

#ifndef NDEBUG
		printf("[DW]: [bdStorage]: loading publisher file: %s\n", filename.data());
#endif

		std::string data;

		if (this->load_publisher_resource(filename, data))
		{
#ifndef NDEBUG
			printf("[DW]: [bdStorage]: sending publisher file: %s, size: %lld\n", filename.data(), data.size());
#endif

			auto reply = server->create_reply(this->task_id());
			reply->add(new bdFileData(data));
			reply->send();
		}
		else
		{
			server->create_reply(this->task_id(), game::BD_NO_FILE)->send();
		}
	}

	void bdStorage::set_user_file(service_server* server, byte_buffer* buffer) const
	{
		bool priv;
		uint64_t owner;
		std::string game, filename, data;

		buffer->read_string(&game);
		buffer->read_string(&filename);
		buffer->read_bool(&priv);
		buffer->read_blob(&data);
		buffer->read_uint64(&owner);

		const auto path = get_user_file_path(filename);
		utils::io::write_file(path, data);

		auto* info = new bdFileInfo;

		info->file_id = *reinterpret_cast<const uint64_t*>(utils::cryptography::sha1::compute(filename).data());
		info->filename = filename;
		info->create_time = uint32_t(time(nullptr));
		info->modified_time = info->create_time;
		info->file_size = uint32_t(data.size());
		info->owner_id = owner;
		info->priv = priv;

		auto reply = server->create_reply(this->task_id());
		reply->add(info);
		reply->send();
	}

	std::string bdStorage::get_user_file_path(const std::string& name)
	{
		return "players/user/" + name;
	}

	void bdStorage::upload_files(service_server* server, byte_buffer* buffer) const
	{
		uint64_t owner;
		uint32_t numfiles;
		std::string game, platform;

		buffer->read_string(&game);
		buffer->read_uint64(&owner);
		buffer->read_string(&platform);
		buffer->read_uint32(&numfiles);

		auto reply = server->create_reply(this->task_id());

		for (uint32_t i = 0; i < numfiles; i++)
		{
			std::string filename, data;
			uint32_t unk;
			bool priv;

			buffer->read_string(&filename);
			buffer->read_blob(&data);
			buffer->read_uint32(&unk);
			buffer->read_bool(&priv);

			const auto path = get_user_file_path(filename);
			utils::io::write_file(path, data);

			auto* info = new bdFile2;

			info->unk1 = 0;
			info->unk2 = 0;
			info->unk3 = 0;
			info->priv = false;
			info->owner_id = owner;
			info->platform = platform;
			info->filename = filename;
			info->data = data;

#ifndef NDEBUG
			printf("[DW]: [bdStorage]: set user file: %s\n", filename.data());
#endif

			reply->add(info);
		}

		reply->send();
	}

	void bdStorage::upload_files_new(service_server* server, byte_buffer* buffer) const
	{
		uint64_t owner;
		uint32_t numfiles;
		std::string game, platform;

		buffer->read_string(&game);
		buffer->read_uint64(&owner);
		buffer->read_string(&platform);
		buffer->read_uint32(&numfiles);

		auto reply = server->create_reply(this->task_id());

		for (uint32_t i = 0; i < numfiles; i++)
		{
			std::string filename, data;
			uint32_t version;
			bool priv;

			buffer->read_string(&filename);
			buffer->read_blob(&data);
			buffer->read_uint32(&version);
			buffer->read_bool(&priv);

			const auto path = get_user_file_path(filename);
			utils::io::write_file(path, data);

			auto* info = new bdContextUserStorageFileInfo;

			info->modifed_time = static_cast<uint32_t>(time(nullptr));
			info->create_time = info->modifed_time;
			info->priv = priv;
			info->owner_id = owner;
			info->account_type = platform;
			info->filename = filename;

#ifndef NDEBUG
			printf("[DW]: [bdStorage]: set user file: %s\n", filename.data());
#endif

			reply->add(info);
		}

		reply->send();
	}

	void bdStorage::get_files(service_server* server, byte_buffer* buffer) const
	{
		std::string context;
		buffer->read_string(&context);

		uint32_t count;
		buffer->read_uint32(&count);

		std::vector<std::pair<uint64_t, std::string>> user_ctxs;

		for (auto i = 0u; i < count; i++)
		{
			uint64_t user_id;
			std::string acc_type;
			buffer->read_uint64(&user_id);
			buffer->read_string(&acc_type);

			user_ctxs.emplace_back(user_id, acc_type);
		}

		buffer->read_uint32(&count);

		std::vector<std::string> filenames;

		for (auto i = 0u; i < count; i++)
		{
			std::string filename;
			buffer->read_string(&filename);
			filenames.push_back(std::move(filename));
		}

		auto reply = server->create_reply(this->task_id());
		for (size_t i = 0u; i < filenames.size(); i++)
		{
			auto* entry = new bdFileQueryResult;
			entry->user_id = user_ctxs.at(i).first;
			entry->platform = user_ctxs.at(i).second;
			entry->filename = filenames.at(i);
			entry->errorcode = 0;

			auto& name = filenames.at(i);
			std::string filedata;
			if (utils::io::read_file(get_user_file_path(name), &filedata))
			{
				entry->filedata = filedata;
#ifndef NDEBUG
				printf("[DW]: [bdStorage]: get user file: %s\n", name.data());
#endif
			}
			else
			{
				entry->errorcode = game::BD_NO_FILE;
#ifndef NDEBUG
				printf("[DW]: [bdStorage]: missing user file: %s\n", name.data());
#endif
			}

			reply->add(entry);
		}

		reply->send();
	}

	void bdStorage::unk12(service_server* server, byte_buffer* buffer) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdStorage.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdStorage final : public service
	{
	public:
		bdStorage();

	private:
		using callback = std::function<std::string()>;
		using resource_variant = std::variant<std::string, callback>;
		std::vector<std::pair<std::regex, resource_variant>> publisher_resources_;

		void map_publisher_resource(const std::string& expression, INT id);
		void map_publisher_resource_variant(const std::string& expression, resource_variant resource);
		bool load_publisher_resource(const std::string& name, std::string& buffer);

		void list_publisher_files(service_server* server, byte_buffer* buffer);
		void get_publisher_file(service_server* server, byte_buffer* buffer);
		void set_user_file(service_server* server, byte_buffer* buffer) const;
		void upload_files(service_server* server, byte_buffer* buffer) const;
		void upload_files_new(service_server* server, byte_buffer* buffer) const;
		void get_files(service_server* server, byte_buffer* buffer) const;
		void unk12(service_server* server, byte_buffer* buffer) const;

		static std::string get_user_file_path(const std::string& name);
	};
}

```

`src/client/game/demonware/services/bdTeams.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdTeams::bdTeams() : service(3, "bdTeams")
	{
		this->register_task(30, &bdTeams::createTeam);
		this->register_task(31, &bdTeams::updateTeamName);
		this->register_task(32, &bdTeams::promoteMember);
		this->register_task(33, &bdTeams::kickMember);
		this->register_task(34, &bdTeams::leaveTeam);
		this->register_task(35, &bdTeams::proposeMembership);
		this->register_task(36, &bdTeams::rejectMembership);
		this->register_task(37, &bdTeams::acceptMembership);
		this->register_task(38, &bdTeams::getPublicProfiles);
		this->register_task(39, &bdTeams::getPrivateProfile);
		this->register_task(40, &bdTeams::getPublicMemberProfiles);
		this->register_task(41, &bdTeams::getPrivateMemberProfiles);
		this->register_task(42, &bdTeams::setPublicProfile);
		this->register_task(43, &bdTeams::setPrivateProfile);
		this->register_task(44, &bdTeams::setPublicMemberProfile);
		this->register_task(45, &bdTeams::setPrivateMemberProfile);
		this->register_task(46, &bdTeams::getMemberships);
		this->register_task(47, &bdTeams::getMembers);
		this->register_task(48, &bdTeams::getOutgoingProposals);
		this->register_task(49, &bdTeams::withdrawProposal);
		this->register_task(50, &bdTeams::demoteMember);
		this->register_task(51, &bdTeams::promoteMemberToOwner);
		this->register_task(52, &bdTeams::getTeamInfo);
		this->register_task(53, &bdTeams::getIncomingProposals);
		this->register_task(54, &bdTeams::sendInstantMessage);
		this->register_task(56, &bdTeams::getMembershipsUser);
		this->register_task(57, &bdTeams::sendInstantMessageToTeam);
		this->register_task(58, &bdTeams::searchPublicTeamProfiles);
		this->register_task(63, &bdTeams::addApplication);
		this->register_task(64, &bdTeams::getApplicationsByTeam);
		this->register_task(65, &bdTeams::acceptApplication);
		this->register_task(66, &bdTeams::rejectApplication);
		this->register_task(68, &bdTeams::autoJoinTeam);
		this->register_task(70, &bdTeams::createTeamWithProfiles);
		this->register_task(73, &bdTeams::banMember);
		this->register_task(74, &bdTeams::unbanMember);
		this->register_task(76, &bdTeams::blockApplication);
		this->register_task(78, &bdTeams::unblockApplication);
		this->register_task(80, &bdTeams::updateTeamType);
		this->register_task(82, &bdTeams::setOnline);
		this->register_task(83, &bdTeams::getMembershipsWithCounts);
		this->register_task(84, &bdTeams::getMembershipsWithCountsUser);
		this->register_task(85, &bdTeams::searchTeams);
		this->register_task(86, &bdTeams::createTeamWithProfilesAndTeamType);
		this->register_task(87, &bdTeams::getMembershipsWithCountsAndTeamTypeUser);
		this->register_task(88, &bdTeams::getMembershipsWithCountsAndTeamType);
		this->register_task(89, &bdTeams::getTeamInfoWithTeamType);
		this->register_task(91, &bdTeams::setTeamAutoJoin);
		this->register_task(92, &bdTeams::getTeamAutoJoin);
		this->register_task(94, &bdTeams::getMembersAndPrivileges);
	}

	void bdTeams::createTeam(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::updateTeamName(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::promoteMember(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::kickMember(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::leaveTeam(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::proposeMembership(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::rejectMembership(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::acceptMembership(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getPublicProfiles(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getPrivateProfile(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getPublicMemberProfiles(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getPrivateMemberProfiles(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::setPublicProfile(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::setPrivateProfile(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::setPublicMemberProfile(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::setPrivateMemberProfile(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getMemberships(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getMembers(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getOutgoingProposals(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::withdrawProposal(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::demoteMember(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::promoteMemberToOwner(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getTeamInfo(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getIncomingProposals(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::sendInstantMessage(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getMembershipsUser(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::sendInstantMessageToTeam(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::searchPublicTeamProfiles(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::addApplication(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getApplicationsByTeam(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::acceptApplication(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::rejectApplication(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::autoJoinTeam(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::createTeamWithProfiles(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::banMember(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::unbanMember(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::blockApplication(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::unblockApplication(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::updateTeamType(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::setOnline(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getMembershipsWithCounts(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getMembershipsWithCountsUser(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::searchTeams(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::createTeamWithProfilesAndTeamType(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getMembershipsWithCountsAndTeamTypeUser(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getMembershipsWithCountsAndTeamType(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getTeamInfoWithTeamType(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::setTeamAutoJoin(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getTeamAutoJoin(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdTeams::getMembersAndPrivileges(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdTeams.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdTeams final : public service
	{
	public:
		bdTeams();

	private:
		void createTeam(service_server* server, byte_buffer* buffer) const;
		void updateTeamName(service_server* server, byte_buffer* buffer) const;
		void promoteMember(service_server* server, byte_buffer* buffer) const;
		void kickMember(service_server* server, byte_buffer* buffer) const;
		void leaveTeam(service_server* server, byte_buffer* buffer) const;
		void proposeMembership(service_server* server, byte_buffer* buffer) const;
		void rejectMembership(service_server* server, byte_buffer* buffer) const;
		void acceptMembership(service_server* server, byte_buffer* buffer) const;
		void getPublicProfiles(service_server* server, byte_buffer* buffer) const;
		void getPrivateProfile(service_server* server, byte_buffer* buffer) const;
		void getPublicMemberProfiles(service_server* server, byte_buffer* buffer) const;
		void getPrivateMemberProfiles(service_server* server, byte_buffer* buffer) const;
		void setPublicProfile(service_server* server, byte_buffer* buffer) const;
		void setPrivateProfile(service_server* server, byte_buffer* buffer) const;
		void setPublicMemberProfile(service_server* server, byte_buffer* buffer) const;
		void setPrivateMemberProfile(service_server* server, byte_buffer* buffer) const;
		void getMemberships(service_server* server, byte_buffer* buffer) const;
		void getMembers(service_server* server, byte_buffer* buffer) const;
		void getOutgoingProposals(service_server* server, byte_buffer* buffer) const;
		void withdrawProposal(service_server* server, byte_buffer* buffer) const;
		void demoteMember(service_server* server, byte_buffer* buffer) const;
		void promoteMemberToOwner(service_server* server, byte_buffer* buffer) const;
		void getTeamInfo(service_server* server, byte_buffer* buffer) const;
		void getIncomingProposals(service_server* server, byte_buffer* buffer) const;
		void sendInstantMessage(service_server* server, byte_buffer* buffer) const;
		void getMembershipsUser(service_server* server, byte_buffer* buffer) const;
		void sendInstantMessageToTeam(service_server* server, byte_buffer* buffer) const;
		void searchPublicTeamProfiles(service_server* server, byte_buffer* buffer) const;
		void addApplication(service_server* server, byte_buffer* buffer) const;
		void getApplicationsByTeam(service_server* server, byte_buffer* buffer) const;
		void acceptApplication(service_server* server, byte_buffer* buffer) const;
		void rejectApplication(service_server* server, byte_buffer* buffer) const;
		void autoJoinTeam(service_server* server, byte_buffer* buffer) const;
		void createTeamWithProfiles(service_server* server, byte_buffer* buffer) const;
		void banMember(service_server* server, byte_buffer* buffer) const;
		void unbanMember(service_server* server, byte_buffer* buffer) const;
		void blockApplication(service_server* server, byte_buffer* buffer) const;
		void unblockApplication(service_server* server, byte_buffer* buffer) const;
		void updateTeamType(service_server* server, byte_buffer* buffer) const;
		void setOnline(service_server* server, byte_buffer* buffer) const;
		void getMembershipsWithCounts(service_server* server, byte_buffer* buffer) const;
		void getMembershipsWithCountsUser(service_server* server, byte_buffer* buffer) const;
		void searchTeams(service_server* server, byte_buffer* buffer) const;
		void createTeamWithProfilesAndTeamType(service_server* server, byte_buffer* buffer) const;
		void getMembershipsWithCountsAndTeamTypeUser(service_server* server, byte_buffer* buffer) const;
		void getMembershipsWithCountsAndTeamType(service_server* server, byte_buffer* buffer) const;
		void getTeamInfoWithTeamType(service_server* server, byte_buffer* buffer) const;
		void setTeamAutoJoin(service_server* server, byte_buffer* buffer) const;
		void getTeamAutoJoin(service_server* server, byte_buffer* buffer) const;
		void getMembersAndPrivileges(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdTitleUtilities.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdTitleUtilities::bdTitleUtilities() : service(12, "bdTitleUtilities")
	{
		this->register_task(6, &bdTitleUtilities::get_server_time);
	}

	void bdTitleUtilities::get_server_time(service_server* server, byte_buffer* /*buffer*/) const
	{
		auto* const time_result = new bdTimeStamp;
		time_result->unix_time = uint32_t(time(nullptr));

		auto reply = server->create_reply(this->task_id());
		reply->add(time_result);
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdTitleUtilities.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdTitleUtilities final : public service
	{
	public:
		bdTitleUtilities();

	private:
		void get_server_time(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdUNK63.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdUNK63::bdUNK63() : service(63, "bdUNK63")
	{
		//this->register_task(6, "unk6", &bdUNK63::unk6);
	}

	void bdUNK63::unk(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}

```

`src/client/game/demonware/services/bdUNK63.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdUNK63 final : public service
	{
	public:
		bdUNK63();

	private:
		void unk(service_server* server, byte_buffer* buffer) const;
	};
}

```

`src/client/game/demonware/services/bdUserGroups.cpp`:

```cpp
#include <std_include.hpp>
#include "../services.hpp"

namespace demonware
{
	bdUserGroups::bdUserGroups() : service(65, "bdUserGroups")
	{
		this->register_task(1, &bdUserGroups::createGroup);
		this->register_task(2, &bdUserGroups::deleteGroup);
		this->register_task(3, &bdUserGroups::joinGroup);
		this->register_task(4, &bdUserGroups::leaveGroup);
		this->register_task(5, &bdUserGroups::getMembershipInfo);
		this->register_task(6, &bdUserGroups::changeMemberType);
		this->register_task(7, &bdUserGroups::getNumMembers);
		this->register_task(8, &bdUserGroups::getMembers);
		this->register_task(9, &bdUserGroups::getMemberships);
		this->register_task(10, &bdUserGroups::readStatsByRank);
		this->register_task(11, &bdUserGroups::getGroupLists);
	}

	void bdUserGroups::createGroup(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdUserGroups::deleteGroup(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdUserGroups::joinGroup(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdUserGroups::leaveGroup(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdUserGroups::getMembershipInfo(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdUserGroups::changeMemberType(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdUserGroups::getNumMembers(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdUserGroups::getMembers(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdUserGroups::getMemberships(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdUserGroups::readStatsByRank(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}

	void bdUserGroups::getGroupLists(service_server* server, byte_buffer* /*buffer*/) const
	{
		// TODO:
		auto reply = server->create_reply(this->task_id());
		reply->send();
	}
}
```

`src/client/game/demonware/services/bdUserGroups.hpp`:

```hpp
#pragma once

namespace demonware
{
	class bdUserGroups final : public service
	{
	public:
		bdUserGroups();

	private:
		void createGroup(service_server* server, byte_buffer* buffer) const;
		void deleteGroup(service_server* server, byte_buffer* buffer) const;
		void joinGroup(service_server* server, byte_buffer* buffer) const;
		void leaveGroup(service_server* server, byte_buffer* buffer) const;
		void getMembershipInfo(service_server* server, byte_buffer* buffer) const;
		void changeMemberType(service_server* server, byte_buffer* buffer) const;
		void getNumMembers(service_server* server, byte_buffer* buffer) const;
		void getMembers(service_server* server, byte_buffer* buffer) const;
		void getMemberships(service_server* server, byte_buffer* buffer) const;
		void readStatsByRank(service_server* server, byte_buffer* buffer) const;
		void getGroupLists(service_server* server, byte_buffer* buffer) const;
	};
}
```

`src/client/game/game.cpp`:

```cpp
#include <std_include.hpp>

#include "game.hpp"
#include <utils/nt.hpp>

namespace game
{
	namespace
	{
		const utils::nt::library& get_host_library()
		{
			static const auto host_library = []
			{
				utils::nt::library host{};
				if (!host || host == utils::nt::library::get_by_address(get_base))
				{
					throw std::runtime_error("Invalid host application");
				}

				return host;
			}();

			return host_library;
		}
	}

	size_t get_base()
	{
		static const auto base = reinterpret_cast<size_t>(get_host_library().get_ptr());
		return base;
	}

	bool is_server()
	{
		static const auto server = get_host_library().get_optional_header()->CheckSum == 0x14C28B4;
		return server;
	}
}

```

`src/client/game/game.hpp`:

```hpp
#pragma once

namespace game
{
	size_t get_base();
	bool is_server();

	inline size_t relocate(const size_t val)
	{
		if (!val) return 0;

		const auto base = get_base();
		return base + (val - 0x140000000);
	}

	inline size_t derelocate(const size_t val)
	{
		if (!val) return 0;

		const auto base = get_base();
		return (val - base) + 0x140000000;
	}

	inline size_t derelocate(const void* val)
	{
		return derelocate(reinterpret_cast<size_t>(val));
	}

	inline size_t select(const size_t client_val, const size_t server_val)
	{
		return relocate(is_server() ? server_val : client_val);
	}

	inline size_t select(const void* client_val, const void* server_val)
	{
		return select(reinterpret_cast<size_t>(client_val), reinterpret_cast<size_t>(server_val));
	}

	template <typename T>
	class symbol
	{
	public:
		symbol(const size_t address)
			: address_(address)
		{
		}

		symbol(const size_t address, const size_t server_address)
			: address_(address)
			  , server_address_(server_address)
		{
		}

		T* get() const
		{
			return reinterpret_cast<T*>(select(this->address_, this->server_address_));
		}

		operator T*() const
		{
			return this->get();
		}

		T* operator->() const
		{
			return this->get();
		}

	private:
		size_t address_{};
		size_t server_address_{};
	};
}

inline size_t operator"" _g(const size_t val)
{
	return game::relocate(val);
}

#include "structs.hpp"
#include "symbols.hpp"

```

`src/client/game/structs.hpp`:

```hpp
#pragma once

#define PROTOCOL 1

#ifdef __cplusplus
namespace game
{
#endif
	enum XAssetType
	{
		ASSET_TYPE_LEADERBOARD = 0x32,
		ASSET_TYPE_DDL = 0x33,
	};

	enum ControllerIndex_t
	{
		INVALID_CONTROLLER_PORT = 0xFFFFFFFF,
		CONTROLLER_INDEX_FIRST = 0x0,
		CONTROLLER_INDEX_0 = 0x0,
		CONTROLLER_INDEX_1 = 0x1,
		CONTROLLER_INDEX_2 = 0x2,
		CONTROLLER_INDEX_3 = 0x3,
		CONTROLLER_INDEX_COUNT = 0x4,
	};

	enum eModes
	{
		MODE_ZOMBIES = 0x0,
		MODE_MULTIPLAYER = 0x1,
		MODE_CAMPAIGN = 0x2,
		MODE_COUNT = 0x3,
		MODE_INVALID = 0x3,
		MODE_FIRST = 0x0,
	};

	enum bdLobbyErrorCode
	{
		BD_NO_ERROR = 0x0,
		BD_TOO_MANY_TASKS = 0x1,
		BD_NOT_CONNECTED = 0x2,
		BD_SEND_FAILED = 0x3,
		BD_HANDLE_TASK_FAILED = 0x4,
		BD_START_TASK_FAILED = 0x5,
		BD_RESULT_EXCEEDS_BUFFER_SIZE = 0x64,
		BD_ACCESS_DENIED = 0x65,
		BD_EXCEPTION_IN_DB = 0x66,
		BD_MALFORMED_TASK_HEADER = 0x67,
		BD_INVALID_ROW = 0x68,
		BD_EMPTY_ARG_LIST = 0x69,
		BD_PARAM_PARSE_ERROR = 0x6A,
		BD_PARAM_MISMATCHED_TYPE = 0x6B,
		BD_SERVICE_NOT_AVAILABLE = 0x6C,
		BD_CONNECTION_RESET = 0x6D,
		BD_INVALID_USER_ID = 0x6E,
		BD_LOBBY_PROTOCOL_VERSION_FAILURE = 0x6F,
		BD_LOBBY_INTERNAL_FAILURE = 0x70,
		BD_LOBBY_PROTOCOL_ERROR = 0x71,
		BD_LOBBY_FAILED_TO_DECODE_UTF8 = 0x72,
		BD_LOBBY_ASCII_EXPECTED = 0x73,
		BD_ASYNCHRONOUS_ERROR = 0xC8,
		BD_STREAMING_COMPLETE = 0xC9,
		BD_MEMBER_NO_PROPOSAL = 0x12C,
		BD_TEAMNAME_ALREADY_EXISTS = 0x12D,
		BD_MAX_TEAM_MEMBERSHIPS_LIMITED = 0x12E,
		BD_MAX_TEAM_OWNERSHIPS_LIMITED = 0x12F,
		BD_NOT_A_TEAM_MEMBER = 0x130,
		BD_INVALID_TEAM_ID = 0x131,
		BD_INVALID_TEAM_NAME = 0x132,
		BD_NOT_A_TEAM_OWNER = 0x133,
		BD_NOT_AN_ADMIN_OR_OWNER = 0x134,
		BD_MEMBER_PROPOSAL_EXISTS = 0x135,
		BD_MEMBER_EXISTS = 0x136,
		BD_TEAM_FULL = 0x137,
		BD_VULGAR_TEAM_NAME = 0x138,
		BD_TEAM_USERID_BANNED = 0x139,
		BD_TEAM_EMPTY = 0x13A,
		BD_INVALID_TEAM_PROFILE_QUERY_ID = 0x13B,
		BD_TEAMNAME_TOO_SHORT = 0x13C,
		BD_UNIQUE_PROFILE_DATA_EXISTS_ALREADY = 0x13D,
		BD_INVALID_LEADERBOARD_ID = 0x190,
		BD_INVALID_STATS_SET = 0x191,
		BD_EMPTY_STATS_SET_IGNORED = 0x193,
		BD_NO_DIRECT_ACCESS_TO_ARBITRATED_LBS = 0x194,
		BD_STATS_WRITE_PERMISSION_DENIED = 0x195,
		BD_STATS_WRITE_TYPE_DATA_TYPE_MISMATCH = 0x196,
		BD_NO_STATS_FOR_USER = 0x197,
		BD_INVALID_ACCESS_TO_UNRANKED_LB = 0x198,
		BD_INVALID_EXTERNAL_TITLE_ID = 0x199,
		BD_DIFFERENT_LEADERBOARD_SCHEMAS = 0x19A,
		BD_TOO_MANY_LEADERBOARDS_REQUESTED = 0x19B,
		BD_ENTITLEMENTS_ERROR = 0x19C,
		BD_ENTITLEMENTS_INVALID_TITLEID = 0x19D,
		BD_ENTITLEMENTS_INVALID_LEADERBOARDID = 0x19E,
		BD_ENTITLEMENTS_INVALID_GET_MODE_FOR_TITLE = 0x19F,
		BD_ENTITLEMENTS_URL_CONNECTION_ERROR = 0x1A0,
		BD_ENTITLEMENTS_CONFIG_ERROR = 0x1A1,
		BD_ENTITLEMENTS_NAMED_PARENT_ERROR = 0x1A2,
		BD_ENTITLEMENTS_NAMED_KEY_ERROR = 0x1A3,
		BD_TOO_MANY_ENTITY_IDS_REQUESTED = 0x1A4,
		BD_STATS_READ_FAILED = 0x1A5,
		BD_INVALID_TITLE_ID = 0x1F4,
		BD_MESSAGING_INVALID_MAIL_ID = 0x258,
		BD_SELF_BLOCK_NOT_ALLOWED = 0x259,
		BD_GLOBAL_MESSAGE_ACCESS_DENIED = 0x25A,
		BD_GLOBAL_MESSAGES_USER_LIMIT_EXCEEDED = 0x25B,
		BD_MESSAGING_SENDER_DOES_NOT_EXIST = 0x25C,
		BD_AUTH_NO_ERROR = 0x2BC,
		BD_AUTH_BAD_REQUEST = 0x2BD,
		BD_AUTH_SERVER_CONFIG_ERROR = 0x2BE,
		BD_AUTH_BAD_TITLE_ID = 0x2BF,
		BD_AUTH_BAD_ACCOUNT = 0x2C0,
		BD_AUTH_ILLEGAL_OPERATION = 0x2C1,
		BD_AUTH_INCORRECT_LICENSE_CODE = 0x2C2,
		BD_AUTH_CREATE_USERNAME_EXISTS = 0x2C3,
		BD_AUTH_CREATE_USERNAME_ILLEGAL = 0x2C4,
		BD_AUTH_CREATE_USERNAME_VULGAR = 0x2C5,
		BD_AUTH_CREATE_MAX_ACC_EXCEEDED = 0x2C6,
		BD_AUTH_MIGRATE_NOT_SUPPORTED = 0x2C7,
		BD_AUTH_TITLE_DISABLED = 0x2C8,
		BD_AUTH_ACCOUNT_EXPIRED = 0x2C9,
		BD_AUTH_ACCOUNT_LOCKED = 0x2CA,
		BD_AUTH_UNKNOWN_ERROR = 0x2CB,
		BD_AUTH_INCORRECT_PASSWORD = 0x2CC,
		BD_AUTH_IP_NOT_IN_ALLOWED_RANGE = 0x2CD,
		BD_AUTH_WII_TOKEN_VERIFICATION_FAILED = 0x2CE,
		BD_AUTH_WII_AUTHENTICATION_FAILED = 0x2CF,
		BD_AUTH_IP_KEY_LIMIT_REACHED = 0x2D0,
		BD_AUTH_INVALID_GSPID = 0x2D1,
		BD_AUTH_INVALID_IP_RANGE_ID = 0x2D2,
		BD_AUTH_3DS_TOKEN_VERIFICATION_FAILED = 0x2D1,
		BD_AUTH_3DS_AUTHENTICATION_FAILED = 0x2D2,
		BD_AUTH_STEAM_APP_ID_MISMATCH = 0x2D3,
		BD_AUTH_ABACCOUNTS_APP_ID_MISMATCH = 0x2D4,
		BD_AUTH_CODO_USERNAME_NOT_SET = 0x2D5,
		BD_AUTH_WIIU_TOKEN_VERIFICATION_FAILED = 0x2D6,
		BD_AUTH_WIIU_AUTHENTICATION_FAILED = 0x2D7,
		BD_AUTH_CODO_USERNAME_NOT_BASE64 = 0x2D8,
		BD_AUTH_CODO_USERNAME_NOT_UTF8 = 0x2D9,
		BD_AUTH_TENCENT_TICKET_EXPIRED = 0x2DA,
		BD_AUTH_PS3_SERVICE_ID_MISMATCH = 0x2DB,
		BD_AUTH_CODOID_NOT_WHITELISTED = 0x2DC,
		BD_AUTH_PLATFORM_TOKEN_ERROR = 0x2DD,
		BD_AUTH_JSON_FORMAT_ERROR = 0x2DE,
		BD_AUTH_REPLY_CONTENT_ERROR = 0x2DF,
		BD_AUTH_THIRD_PARTY_TOKEN_EXPIRED = 0x2E0,
		BD_AUTH_CONTINUING = 0x2E1,
		BD_AUTH_PLATFORM_DEVICE_ID_ERROR = 0x2E4,
		BD_NO_PROFILE_INFO_EXISTS = 0x320,
		BD_FRIENDSHIP_NOT_REQUSTED = 0x384,
		BD_NOT_A_FRIEND = 0x385,
		BD_SELF_FRIENDSHIP_NOT_ALLOWED = 0x387,
		BD_FRIENDSHIP_EXISTS = 0x388,
		BD_PENDING_FRIENDSHIP_EXISTS = 0x389,
		BD_USERID_BANNED = 0x38A,
		BD_FRIENDS_FULL = 0x38C,
		BD_FRIENDS_NO_RICH_PRESENCE = 0x38D,
		BD_RICH_PRESENCE_TOO_LARGE = 0x38E,
		BD_NO_FILE = 0x3E8,
		BD_PERMISSION_DENIED = 0x3E9,
		BD_FILESIZE_LIMIT_EXCEEDED = 0x3EA,
		BD_FILENAME_MAX_LENGTH_EXCEEDED = 0x3EB,
		BD_EXTERNAL_STORAGE_SERVICE_ERROR = 0x3EC,
		BD_CHANNEL_DOES_NOT_EXIST = 0x44D,
		BD_CHANNEL_ALREADY_SUBSCRIBED = 0x44E,
		BD_CHANNEL_NOT_SUBSCRIBED = 0x44F,
		BD_CHANNEL_FULL = 0x450,
		BD_CHANNEL_SUBSCRIPTIONS_FULL = 0x451,
		BD_CHANNEL_NO_SELF_WHISPERING = 0x452,
		BD_CHANNEL_ADMIN_REQUIRED = 0x453,
		BD_CHANNEL_TARGET_NOT_SUBSCRIBED = 0x454,
		BD_CHANNEL_REQUIRES_PASSWORD = 0x455,
		BD_CHANNEL_TARGET_IS_SELF = 0x456,
		BD_CHANNEL_PUBLIC_BAN_NOT_ALLOWED = 0x457,
		BD_CHANNEL_USER_BANNED = 0x458,
		BD_CHANNEL_PUBLIC_PASSWORD_NOT_ALLOWED = 0x459,
		BD_CHANNEL_PUBLIC_KICK_NOT_ALLOWED = 0x45A,
		BD_CHANNEL_MUTED = 0x45B,
		BD_EVENT_DESC_TRUNCATED = 0x4B0,
		BD_CONTENT_UNLOCK_UNKNOWN_ERROR = 0x514,
		BD_UNLOCK_KEY_INVALID = 0x515,
		BD_UNLOCK_KEY_ALREADY_USED_UP = 0x516,
		BD_SHARED_UNLOCK_LIMIT_REACHED = 0x517,
		BD_DIFFERENT_HARDWARE_ID = 0x518,
		BD_INVALID_CONTENT_OWNER = 0x519,
		BD_CONTENT_UNLOCK_INVALID_USER = 0x51A,
		BD_CONTENT_UNLOCK_INVALID_CATEGORY = 0x51B,
		BD_KEY_ARCHIVE_INVALID_WRITE_TYPE = 0x5DC,
		BD_KEY_ARCHIVE_EXCEEDED_MAX_IDS_PER_REQUEST = 0x5DD,
		BD_BANDWIDTH_TEST_TRY_AGAIN = 0x712,
		BD_BANDWIDTH_TEST_STILL_IN_PROGRESS = 0x713,
		BD_BANDWIDTH_TEST_NOT_PROGRESS = 0x714,
		BD_BANDWIDTH_TEST_SOCKET_ERROR = 0x715,
		BD_INVALID_SESSION_NONCE = 0x76D,
		BD_ARBITRATION_FAILURE = 0x76F,
		BD_ARBITRATION_USER_NOT_REGISTERED = 0x771,
		BD_ARBITRATION_NOT_CONFIGURED = 0x772,
		BD_CONTENTSTREAMING_FILE_NOT_AVAILABLE = 0x7D0,
		BD_CONTENTSTREAMING_STORAGE_SPACE_EXCEEDED = 0x7D1,
		BD_CONTENTSTREAMING_NUM_FILES_EXCEEDED = 0x7D2,
		BD_CONTENTSTREAMING_UPLOAD_BANDWIDTH_EXCEEDED = 0x7D3,
		BD_CONTENTSTREAMING_FILENAME_MAX_LENGTH_EXCEEDED = 0x7D4,
		BD_CONTENTSTREAMING_MAX_THUMB_DATA_SIZE_EXCEEDED = 0x7D5,
		BD_CONTENTSTREAMING_DOWNLOAD_BANDWIDTH_EXCEEDED = 0x7D6,
		BD_CONTENTSTREAMING_NOT_ENOUGH_DOWNLOAD_BUFFER_SPACE = 0x7D7,
		BD_CONTENTSTREAMING_SERVER_NOT_CONFIGURED = 0x7D8,
		BD_CONTENTSTREAMING_INVALID_APPLE_RECEIPT = 0x7DA,
		BD_CONTENTSTREAMING_APPLE_STORE_NOT_AVAILABLE = 0x7DB,
		BD_CONTENTSTREAMING_APPLE_RECEIPT_FILENAME_MISMATCH = 0x7DC,
		BD_CONTENTSTREAMING_HTTP_ERROR = 0x7E4,
		BD_CONTENTSTREAMING_FAILED_TO_START_HTTP = 0x7E5,
		BD_CONTENTSTREAMING_LOCALE_INVALID = 0x7E6,
		BD_CONTENTSTREAMING_LOCALE_MISSING = 0x7E7,
		BD_VOTERANK_ERROR_EMPTY_RATING_SUBMISSION = 0x7EE,
		BD_VOTERANK_ERROR_MAX_VOTES_EXCEEDED = 0x7EF,
		BD_VOTERANK_ERROR_INVALID_RATING = 0x7F0,
		BD_MAX_NUM_TAGS_EXCEEDED = 0x82A,
		BD_TAGGED_COLLECTION_DOES_NOT_EXIST = 0x82B,
		BD_EMPTY_TAG_ARRAY = 0x82C,
		BD_INVALID_QUERY_ID = 0x834,
		BD_NO_ENTRY_TO_UPDATE = 0x835,
		BD_SESSION_INVITE_EXISTS = 0x836,
		BD_INVALID_SESSION_ID = 0x837,
		BD_ATTACHMENT_TOO_LARGE = 0x838,
		BD_INVALID_GROUP_ID = 0xAF0,
		BD_MAIL_INVALID_MAIL_ID_ERROR = 0xB55,
		BD_UCD_SERVICE_ERROR = 0xC80,
		BD_UCD_SERVICE_DISABLED = 0xC81,
		BD_UCD_UNINTIALIZED_ERROR = 0xC82,
		BD_UCD_ACCOUNT_ALREADY_REGISTERED = 0xC83,
		BD_UCD_ACCOUNT_NOT_REGISTERED = 0xC84,
		BD_UCD_AUTH_ATTEMPT_FAILED = 0xC85,
		BD_UCD_ACCOUNT_LINKING_ERROR = 0xC86,
		BD_UCD_ENCRYPTION_ERROR = 0xC87,
		BD_UCD_ACCOUNT_DATA_INVALID = 0xC88,
		BD_UCD_ACCOUNT_DATA_INVALID_FIRSTNAME = 0xC89,
		BD_UCD_ACCOUNT_DATA_INVALID_LASTNAME = 0xC8A,
		BD_UCD_ACCOUNT_DATA_INVALID_DOB = 0xC8B,
		BD_UCD_ACCOUNT_DATA_INVALID_EMAIL = 0xC8C,
		BD_UCD_ACCOUNT_DATA_INVALID_COUNTRY = 0xC8D,
		BD_UCD_ACCOUNT_DATA_INVALID_POSTCODE = 0xC8E,
		BD_UCD_ACCOUNT_DATA_INVALID_PASSWORD = 0xC8F,
		BD_UCD_ACCOUNT_NAME_ALREADY_RESISTERED = 0xC94,
		BD_UCD_ACCOUNT_EMAIL_ALREADY_RESISTERED = 0xC95,
		BD_UCD_GUEST_ACCOUNT_AUTH_CONFLICT = 0xC96,
		BD_TWITCH_SERVICE_ERROR = 0xC1D,
		BD_TWITCH_ACCOUNT_ALREADY_LINKED = 0xC1E,
		BD_TWITCH_NO_LINKED_ACCOUNT = 0xC1F,
		BD_YOUTUBE_SERVICE_ERROR = 0xCE5,
		BD_YOUTUBE_SERVICE_COMMUNICATION_ERROR = 0xCE6,
		BD_YOUTUBE_USER_DENIED_AUTHORIZATION = 0xCE7,
		BD_YOUTUBE_AUTH_MAX_TIME_EXCEEDED = 0xCE8,
		BD_YOUTUBE_USER_UNAUTHORIZED = 0xCE9,
		BD_YOUTUBE_UPLOAD_MAX_TIME_EXCEEDED = 0xCEA,
		BD_YOUTUBE_DUPLICATE_UPLOAD = 0xCEB,
		BD_YOUTUBE_FAILED_UPLOAD = 0xCEC,
		BD_YOUTUBE_ACCOUNT_ALREADY_REGISTERED = 0xCED,
		BD_YOUTUBE_ACCOUNT_NOT_REGISTERED = 0xCEE,
		BD_YOUTUBE_CONTENT_SERVER_ERROR = 0xCEF,
		BD_YOUTUBE_UPLOAD_DOES_NOT_EXIST = 0xCF0,
		BD_YOUTUBE_NO_LINKED_ACCOUNT = 0xCF1,
		BD_YOUTUBE_DEVELOPER_TAGS_INVALID = 0xCF2,
		BD_TWITTER_AUTH_ATTEMPT_FAILED = 0xDAD,
		BD_TWITTER_AUTH_TOKEN_INVALID = 0xDAE,
		BD_TWITTER_UPDATE_LIMIT_REACHED = 0xDAF,
		BD_TWITTER_UNAVAILABLE = 0xDB0,
		BD_TWITTER_ERROR = 0xDB1,
		BD_TWITTER_TIMED_OUT = 0xDB2,
		BD_TWITTER_DISABLED_FOR_USER = 0xDB3,
		BD_TWITTER_ACCOUNT_AMBIGUOUS = 0xDB4,
		BD_TWITTER_MAXIMUM_ACCOUNTS_REACHED = 0xDB5,
		BD_TWITTER_ACCOUNT_NOT_REGISTERED = 0xDB6,
		BD_TWITTER_DUPLICATE_STATUS = 0xDB7,
		BD_TWITTER_ACCOUNT_ALREADY_REGISTERED = 0xE1C,
		BD_FACEBOOK_AUTH_ATTEMPT_FAILED = 0xE11,
		BD_FACEBOOK_AUTH_TOKEN_INVALID = 0xE12,
		BD_FACEBOOK_PHOTO_DOES_NOT_EXIST = 0xE13,
		BD_FACEBOOK_PHOTO_INVALID = 0xE14,
		BD_FACEBOOK_PHOTO_ALBUM_FULL = 0xE15,
		BD_FACEBOOK_UNAVAILABLE = 0xE16,
		BD_FACEBOOK_ERROR = 0xE17,
		BD_FACEBOOK_TIMED_OUT = 0xE18,
		BD_FACEBOOK_DISABLED_FOR_USER = 0xE19,
		BD_FACEBOOK_ACCOUNT_AMBIGUOUS = 0xE1A,
		BD_FACEBOOK_MAXIMUM_ACCOUNTS_REACHED = 0xE1B,
		BD_FACEBOOK_INVALID_NUM_PICTURES_REQUESTED = 0xE1C,
		BD_FACEBOOK_VIDEO_DOES_NOT_EXIST = 0xE1D,
		BD_FACEBOOK_ACCOUNT_ALREADY_REGISTERED = 0xE1E,
		BD_APNS_INVALID_PAYLOAD = 0xE74,
		BD_APNS_INVALID_TOKEN_LENGTH_ERROR = 0xE76,
		BD_MAX_CONSOLEID_LENGTH_EXCEEDED = 0xEE1,
		BD_MAX_WHITELIST_LENGTH_EXCEEDED = 0xEE2,
		BD_USERGROUP_NAME_ALREADY_EXISTS = 0x1770,
		BD_INVALID_USERGROUP_ID = 0x1771,
		BD_USER_ALREADY_IN_USERGROUP = 0x1772,
		BD_USER_NOT_IN_USERGROUP = 0x1773,
		BD_INVALID_USERGROUP_MEMBER_TYPE = 0x1774,
		BD_TOO_MANY_MEMBERS_REQUESTED = 0x1775,
		BD_USERGROUP_NAME_TOO_SHORT = 0x1776,
		BD_RICH_PRESENCE_DATA_TOO_LARGE = 0x1A90,
		BD_RICH_PRESENCE_TOO_MANY_USERS = 0x1A91,
		BD_PRESENCE_DATA_TOO_LARGE = 0x283C,
		BD_PRESENCE_TOO_MANY_USERS = 0x283D,
		BD_USER_LOGGED_IN_OTHER_TITLE = 0x283E,
		BD_USER_NOT_LOGGED_IN = 0x283F,
		BD_SUBSCRIPTION_TOO_MANY_USERS = 0x1B58,
		BD_SUBSCRIPTION_TICKET_PARSE_ERROR = 0x1B59,
		BD_CODO_ID_INVALID_DATA = 0x1BBC,
		BD_INVALID_MESSAGE_FORMAT = 0x1BBD,
		BD_TLOG_TOO_MANY_MESSAGES = 0x1BBE,
		BD_CODO_ID_NOT_IN_WHITELIST = 0x1BBF,
		BD_TLOG_MESSAGE_TRANSFORMATION_ERROR = 0x1BC0,
		BD_REWARDS_NOT_ENABLED = 0x1BC1,
		BD_MARKETPLACE_ERROR = 0x1F40,
		BD_MARKETPLACE_RESOURCE_NOT_FOUND = 0x1F41,
		BD_MARKETPLACE_INVALID_CURRENCY = 0x1F42,
		BD_MARKETPLACE_INVALID_PARAMETER = 0x1F43,
		BD_MARKETPLACE_RESOURCE_CONFLICT = 0x1F44,
		BD_MARKETPLACE_STORAGE_ERROR = 0x1F45,
		BD_MARKETPLACE_INTEGRITY_ERROR = 0x1F46,
		BD_MARKETPLACE_INSUFFICIENT_FUNDS_ERROR = 0x1F47,
		BD_MARKETPLACE_MMP_SERVICE_ERROR = 0x1F48,
		BD_MARKETPLACE_PRECONDITION_REQUIRED = 0x1F49,
		BD_MARKETPLACE_ITEM_MULTIPLE_PURCHASE_ERROR = 0x1F4A,
		BD_MARKETPLACE_MISSING_REQUIRED_ENTITLEMENT = 0x1F4B,
		BD_MARKETPLACE_VALIDATION_ERROR = 0x1F4C,
		BD_MARKETPLACE_TENCENT_PAYMENT_ERROR = 0x1F4D,
		BD_MARKETPLACE_SKU_NOT_COUPON_ENABLED_ERROR = 0x1F4E,
		BD_LEAGUE_INVALID_TEAM_SIZE = 0x1FA4,
		BD_LEAGUE_INVALID_TEAM = 0x1FA5,
		BD_LEAGUE_INVALID_SUBDIVISION = 0x1FA6,
		BD_LEAGUE_INVALID_LEAGUE = 0x1FA7,
		BD_LEAGUE_TOO_MANY_RESULTS_REQUESTED = 0x1FA8,
		BD_LEAGUE_METADATA_TOO_LARGE = 0x1FA9,
		BD_LEAGUE_TEAM_ICON_TOO_LARGE = 0x1FAA,
		BD_LEAGUE_TEAM_NAME_TOO_LONG = 0x1FAB,
		BD_LEAGUE_ARRAY_SIZE_MISMATCH = 0x1FAC,
		BD_LEAGUE_SUBDIVISION_MISMATCH = 0x2008,
		BD_LEAGUE_INVALID_WRITE_TYPE = 0x2009,
		BD_LEAGUE_INVALID_STATS_DATA = 0x200A,
		BD_LEAGUE_SUBDIVISION_UNRANKED = 0x200B,
		BD_LEAGUE_CROSS_TEAM_STATS_WRITE_PREVENTED = 0x200C,
		BD_LEAGUE_INVALID_STATS_SEASON = 0x200D,
		BD_COMMERCE_ERROR = 0x206C,
		BD_COMMERCE_RESOURCE_NOT_FOUND = 0x206D,
		BD_COMMERCE_STORAGE_INVALID_PARAMETER = 0x206E,
		BD_COMMERCE_APPLICATION_INVALID_PARAMETER = 0x206F,
		BD_COMMERCE_RESOURCE_CONFLICT = 0x2070,
		BD_COMMERCE_STORAGE_ERROR = 0x2071,
		BD_COMMERCE_INTEGRITY_ERROR = 0x2072,
		BD_COMMERCE_MMP_SERVICE_ERROR = 0x2073,
		BD_COMMERCE_PERMISSION_DENIED = 0x2074,
		BD_COMMERCE_INSUFFICIENT_FUNDS_ERROR = 0x2075,
		BD_COMMERCE_UNKNOWN_CURRENCY = 0x2076,
		BD_COMMERCE_INVALID_RECEIPT = 0x2077,
		BD_COMMERCE_RECEIPT_USED = 0x2078,
		BD_COMMERCE_TRANSACTION_ALREADY_APPLIED = 0x2079,
		BD_COMMERCE_INVALID_CURRENCY_TYPE = 0x207A,
		BD_CONNECTION_COUNTER_ERROR = 0x20D0,
		BD_LINKED_ACCOUNTS_INVALID_CONTEXT = 0x2198,
		BD_LINKED_ACCOUNTS_INVALID_PLATFORM = 0x2199,
		BD_LINKED_ACCOUNTS_LINKED_ACCOUNTS_FETCH_ERROR = 0x219A,
		BD_LINKED_ACCOUNTS_INVALID_ACCOUNT = 0x219B,
		BD_GMSG_INVALID_CATEGORY_ID = 0x27D8,
		BD_GMSG_CATEGORY_MEMBERSHIPS_LIMIT = 0x27D9,
		BD_GMSG_NONMEMBER_POST_DISALLOWED = 0x27DA,
		BD_GMSG_CATEGORY_DISALLOWS_CLIENT_TYPE = 0x27DB,
		BD_GMSG_PAYLOAD_TOO_BIG = 0x27DC,
		BD_GMSG_MEMBER_POST_DISALLOWED = 0x27DD,
		BD_GMSG_OVERLOADED = 0x27DE,
		BD_GMSG_USER_PERCATEGORY_POST_RATE_EXCEEDED = 0x27DF,
		BD_GMSG_USER_GLOBAL_POST_RATE_EXCEEDED = 0x27E0,
		BD_GMSG_GROUP_POST_RATE_EXCEEDED = 0x27E1,
		BD_MAX_ERROR_CODE = 0x27E2,
	};

	enum bdNATType : uint8_t
	{
		BD_NAT_UNKNOWN = 0x0,
		BD_NAT_OPEN = 0x1,
		BD_NAT_MODERATE = 0x2,
		BD_NAT_STRICT = 0x3,
	};

	enum itemTextStyle
	{
		ITEM_TEXTSTYLE_NORMAL = 0,
		ITEM_TEXTSTYLE_SHADOWED = 3,
		ITEM_TEXTSTYLE_SHADOWEDMORE = 6,
		ITEM_TEXTSTYLE_BORDERED = 7,
		ITEM_TEXTSTYLE_BORDEREDMORE = 8,
		ITEM_TEXTSTYLE_MONOSPACE = 128,
		ITEM_TEXTSTYLE_MONOSPACESHADOWED = 132,
	};

	enum errorParm
	{
		ERR_FATAL = 0,
		ERR_DROP = 1,
		ERR_SERVERDISCONNECT = 2,
		ERR_DISCONNECT = 3,
		ERR_SCRIPT = 4,
		ERR_SCRIPT_DROP = 5,
		ERR_LOCALIZATION = 6,
		ERR_MAPLOADERRORSUMMARY = 7,
	};

	enum errorCode
	{
		ERROR_NONE = 0x0,
		ERROR_FATAL = 0x1,
		ERROR_DROP = 0x2,
		ERROR_FROM_STARTUP = 0x4,
		ERROR_SERVERDISCONNECT = 0x8,
		ERROR_DISCONNECT = 0x10,
		ERROR_SCRIPT = 0x20,
		ERROR_SCRIPT_DROP = 0x40,
		ERROR_LOCALIZATION = 0x80,
		ERROR_UI = 0x100,
		ERROR_LUA = 0x200,
		ERROR_SOFTRESTART = 0x400,
		ERROR_SOFTRESTART_KEEPDW = 0x800,
	};

	struct XZoneBuffer
	{
		const void* data;
		size_t dataSize;
	};

	struct XZoneInfo
	{
		const char* name;
		int allocFlags;
		int freeFlags;
		int allocSlot;
		int freeSlot;
		XZoneBuffer fileBuffer;
	};

	typedef void (*xcommand_t)();

	struct cmd_function_s
	{
		cmd_function_s* next;
		const char* name;
		const char* autoCompleteDir;
		const char* autoCompleteExt;
		xcommand_t function;
		int autoComplete;
	};

	struct CmdArgs
	{
		int nesting;
		int localClientNum[8];
		int controllerIndex[8];
		int argshift[8];
		int argc[8];
		const char** argv[8];
		char textPool[8192];
		const char* argvPool[512];
		int usedTextPool[8];
		int totalUsedArgvPool;
		int totalUsedTextPool;
	};

	struct va_info_t
	{
		char va_string[4][1024];
		int index;
	};

	struct TLSData
	{
		va_info_t* vaInfo;
		jmp_buf* errorJmpBuf;
		void* traceInfo;
		CmdArgs* cmdArgs;
		void* errorData;
	};

	typedef uint32_t dvarStrHash_t;

	enum dvarType_t
	{
		DVAR_TYPE_INVALID = 0x0,
		DVAR_TYPE_BOOL = 0x1,
		DVAR_TYPE_FLOAT = 0x2,
		DVAR_TYPE_FLOAT_2 = 0x3,
		DVAR_TYPE_FLOAT_3 = 0x4,
		DVAR_TYPE_FLOAT_4 = 0x5,
		DVAR_TYPE_INT = 0x6,
		DVAR_TYPE_ENUM = 0x7,
		DVAR_TYPE_STRING = 0x8,
		DVAR_TYPE_COLOR = 0x9,
		DVAR_TYPE_INT64 = 0xA,
		DVAR_TYPE_UINT64 = 0xB,
		DVAR_TYPE_LINEAR_COLOR_RGB = 0xC,
		DVAR_TYPE_COLOR_XYZ = 0xD,
		DVAR_TYPE_COLOR_LAB = 0xE,
		DVAR_TYPE_SESSIONMODE_BASE_DVAR = 0xF,
		DVAR_TYPE_COUNT = 0x10,
	};

	typedef float vec_t;

	union vec4_t
	{
		vec_t v[4];
		//vec4_t::$E8049E02A67BEF20C2B48C1E90A72E45 _anon_0;
		//vec4_t::$65A5F67E76558B5B186374890F5F7384 _anon_1;
		//vec3_t xyz;
	};

	struct dvar_t;

	union DvarValue
	{
		bool enabled;
		int integer;
		uint32_t unsignedInt;
		int64_t integer64;
		uint64_t unsignedInt64;
		float value;
		vec4_t vector;
		const char* string;
		byte color[4];
		const dvar_t* indirect[3];
	};

	struct $7034703ED3857507327AE195CCA24A71
	{
		int stringCount;
		const char** strings;
	};

	struct $5AC0CC375C7A91894540A0C75867866C
	{
		int min;
		int max;
	};

	struct $FCEE86E78F1A35297637B00F6DD148A3
	{
		int64_t min;
		int64_t max;
	};

	struct $28DE879AA85D5F4AA5DF9392CB197229
	{
		uint64_t min;
		uint64_t max;
	};

	struct $D2B45DCE3C73414E1DE8E10A2D52B392
	{
		float min;
		float max;
	};

	struct $97F25DA469865168FD08682F42882F2A
	{
		vec_t min;
		vec_t max;
	};

	union DvarLimits
	{
		$7034703ED3857507327AE195CCA24A71 enumeration;
		$5AC0CC375C7A91894540A0C75867866C integer;
		$FCEE86E78F1A35297637B00F6DD148A3 integer64;
		$28DE879AA85D5F4AA5DF9392CB197229 unsignedInt64;
		$D2B45DCE3C73414E1DE8E10A2D52B392 value;
		$97F25DA469865168FD08682F42882F2A vector;
	};


	struct dvar_t
	{
		dvarStrHash_t name;
		const char* debugName;
		const char* description;
		unsigned int flags;
		dvarType_t type;
		bool modified;
		DvarValue current;
		DvarValue latched;
		DvarValue reset;
		DvarLimits domain;
		dvar_t* hashNext;
	};

	struct netipv4_t
	{
		byte a;
		byte b;
		byte c;
		byte d;
	};

	enum netadrtype_t
	{
		NA_BOT = 0x0,
		NA_BAD = 0x1,
		NA_LOOPBACK = 0x2,
		NA_RAWIP = 0x3,
		NA_IP = 0x4,
	};

	enum netsrc_t
	{
		NS_NULL = 0xFFFFFFFF,
		NS_CLIENT1 = 0x0,
		NS_CLIENT2 = 0x1,
		NS_CLIENT3 = 0x2,
		NS_CLIENT4 = 0x3,
		NS_SERVER = 0x4,
		NS_MAXCLIENTS = 0x4,
		NS_PACKET = 0x5,
	};

	struct netadr_t
	{
		union
		{
			netipv4_t ipv4;
			uint32_t addr;
		};

		uint16_t port;
		netadrtype_t type;
		netsrc_t localNetID;
	};

	struct XNADDR
	{
		byte addrBuff[37];
	};

	struct bdSecurityID
	{
		byte ab[8];
	};

	typedef bdSecurityID XNKID;

	struct bdSecurityKey
	{
		byte ab[16];
	};

	typedef bdSecurityKey XNKEY;

	typedef uint64_t XUID;

	struct SerializedAdr
	{
		byte valid;
		byte addrBuff[37];
	};

	struct XSESSION_INFO
	{
		XNKID sessionID;
		XNADDR hostAddress;
		XNKEY keyExchangeKey;
	};

	typedef int qboolean;

	enum PacketModeList
	{
		PACKETDATA_FIRST = 0x0,
		PACKETDATA_UNDEFINED = 0x0,
		PACKETDATA_HEADER = 0x1,
		PACKETDATA_OVERHEAD = 0x2,
		PACKETDATA_DATA = 0x3,
		PACKETDATA_RELIABLEDATA = 0x4,
		PACKETDATA_ZEROFLOAT = 0x5,
		PACKETDATA_SMALLFLOAT = 0x6,
		PACKETDATA_LARGEFLOAT = 0x7,
		PACKETDATA_ZEROINT = 0x8,
		PACKETDATA_SMALLANGLE = 0x9,
		PACKETDATA_ZEROANGLE = 0xA,
		PACKETDATA_TIMEDELTA = 0xB,
		PACKETDATA_TIME = 0xC,
		PACKETDATA_24BITFLAGINDEX = 0xD,
		PACKETDATA_GROUNDENTITY = 0xE,
		PACKETDATA_ENTITYNUM = 0xF,
		PACKETDATA_LASTFIELDCHANGED = 0x10,
		PACKETDATA_NOTNETWORKDATA = 0x11,
		PACKETDATA_ORIGINDELTA = 0x12,
		PACKETDATA_ORIGIN = 0x13,
		NUM_PACKETDATA_MODES = 0x14,
	};

	struct PacketMode
	{
		unsigned int start;
		PacketModeList mode;
	};

	struct msg_t
	{
		qboolean overflowed;
		qboolean readOnly;
		byte* data;
		byte* splitData;
		int maxsize;
		int cursize;
		int splitSize;
		int readcount;
		int bit;
		int lastEntityRef;
		qboolean flush;
		netsrc_t targetLocalNetID;
		//PacketMode analysis;
	};

	typedef void* bdCommonAddrRef;

	struct HostInfo
	{
		uint64_t xuid;
		char name[32];
		netadr_t netAdr;
		SerializedAdr serializedAdr;
		bdSecurityID secId;
		bdSecurityKey secKey;
		uint32_t serverLocation;
	};

	enum LobbyType
	{
		LOBBY_TYPE_INVALID = 0xFFFFFFFF,
		LOBBY_TYPE_PRIVATE = 0x0,
		LOBBY_TYPE_GAME = 0x1,
		LOBBY_TYPE_TRANSITION = 0x2,
		LOBBY_TYPE_COUNT = 0x3,
		LOBBY_TYPE_FIRST = 0x0,
		LOBBY_TYPE_LAST = 0x2,
		LOBBY_TYPE_AUTO = 0x3,
	};

	enum LobbyNetworkMode
	{
		LOBBY_NETWORKMODE_INVALID = 0xFFFFFFFF,
		LOBBY_NETWORKMODE_LOCAL = 0x0,
		LOBBY_NETWORKMODE_LAN = 0x1,
		LOBBY_NETWORKMODE_LIVE = 0x2,
		LOBBY_NETWORKMODE_COUNT = 0x3,
	};

	enum LobbyMainMode
	{
		LOBBY_MAINMODE_INVALID = 0xFFFFFFFF,
		LOBBY_MAINMODE_CP = 0x0,
		LOBBY_MAINMODE_MP = 0x1,
		LOBBY_MAINMODE_ZM = 0x2,
		LOBBY_MAINMODE_COUNT = 0x3,
	};

	struct LobbyParams
	{
		LobbyNetworkMode networkMode;
		LobbyMainMode mainMode;
	};

	enum JoinType
	{
		JOIN_TYPE_NORMAL = 0x0,
		JOIN_TYPE_PLAYLIST = 0x1,
		JOIN_TYPE_FRIEND = 0x2,
		JOIN_TYPE_INVITE = 0x3,
		JOIN_TYPE_PARTY = 0x4,
		JOIN_TYPE_COUNT = 0x5,
	};

	struct JoinHost
	{
		HostInfo info;
		LobbyType lobbyType;
		LobbyParams lobbyParams;
		uint64_t reservationKey;
		int retryTime;
		int retryCount;
	};

	enum JoinSourceState
	{
		JOIN_SOURCE_STATE_IDLE = 0x0,
		JOIN_SOURCE_STATE_CONNECT_TO_NEXT_HOST = 0x1,
		JOIN_SOURCE_STATE_ASSOCIATING = 0x2,
		JOIN_SOURCE_STATE_HANDSHAKING = 0x3,
		JOIN_SOURCE_STATE_WAITING_FOR_AGREEMENT = 0x4,
		JOIN_SOURCE_STATE_CONNECTION_FAILED = 0x5,
		JOIN_SOURCE_STATE_CONNECTION_SUCCESS = 0x6,
		JOIN_SOURCE_STATE_ENDING_HOST = 0x7,
		JOIN_SOURCE_STATE_CLEANUP = 0x8,
		JOIN_SOURCE_STATE_COUNT = 0x9,
	};

	enum JoinResult
	{
		JOIN_RESULT_INVALID = 0x0,
		JOIN_RESULT_SUCCESS = 0x1,
		JOIN_RESULT_CONNECT_TO_HOST_FAILURE = 0x2,
		JOIN_RESULT_PROBE_SEND_FAILURE = 0x3,
		JOIN_RESULT_PROBE_TIMEOUT = 0x4,
		JOIN_RESULT_PROBE_INVALID_LOBBY = 0x5,
		JOIN_RESULT_PROBE_INVALID_INFO = 0x6,
		JOIN_RESULT_PROBE_RESULT_INVALID = 0x7,
		JOIN_RESULT_INVALID_LOBBY = 0x8,
		JOIN_RESULT_SEND_AGREEMENT_REQUEST_FAILED = 0x9,
		JOIN_RESULT_HANDSHAKE_WINDOW_EXPIRED = 0xA,
		JOIN_RESULT_AGREEMENT_WINDOW_EXPIRED = 0xB,
		JOIN_RESULT_JOIN_DISABLED = 0xC,
		JOIN_RESULT_JOIN_ALREADY_IN_PROGRESS = 0xD,
		JOIN_RESULT_NOT_JOINABLE_NOT_HOSTING = 0xE,
		JOIN_RESULT_NOT_JOINABLE_NOT_IDLE = 0xF,
		JOIN_RESULT_NOT_JOINABLE_CLOSED = 0x10,
		JOIN_RESULT_NOT_JOINABLE_INVITE_ONLY = 0x11,
		JOIN_RESULT_NOT_JOINABLE_FRIENDS_ONLY = 0x12,
		JOIN_RESULT_LOBBY_FULL = 0x13,
		JOIN_RESULT_NETWORK_MODE_MISMATCH = 0x14,
		JOIN_RESULT_MISMATCH_PLAYLISTID = 0x15,
		JOIN_RESULT_MISMATCH_PLAYLIST_VERSION_TO_NEW = 0x16,
		JOIN_RESULT_MISMATCH_PLAYLIST_VERSION_TO_OLD = 0x17,
		JOIN_RESULT_MISMATCH_PROTOCOL_VERSION = 0x18,
		JOIN_RESULT_MISMATCH_NETFIELD_CHECKSUM = 0x19,
		JOIN_RESULT_MISMATCH_FFOTD_VERSION_TO_NEW = 0x1A,
		JOIN_RESULT_MISMATCH_FFOTD_VERSION_TO_OLD = 0x1B,
		JOIN_RESULT_MIGRATE_IN_PROGRESS = 0x1C,
		JOIN_RESULT_COULD_NOT_RESERVE = 0x1D,
		JOIN_RESPONSE_COUNT = 0x1E,
	};

	typedef void (*joinCompleteCallback)(int, JoinResult);

	struct AgreementStatus
	{
		XUID xuid;
		char name[32];
		bool responded;
		bool agrees;
		int startTime;
		int responseTime;
	};

	struct Agreement
	{
		int nonce;
		AgreementStatus status[18];
		int requestCount;
		int responseCount;
		int agreeCount;
	};

	struct Join
	{
		JoinSourceState state;
		int actionId;
		int startTime;
		int duration;
		ControllerIndex_t controllerIndex;
		LobbyType sourceLobbyType;
		LobbyType targetLobbyType;
		joinCompleteCallback joinComplete;
		JoinHost hostList[50];
		int hostCount;
		int processedCount;
		bool isFinalized;
		JoinHost potentialHost;
		Agreement agreement;
		Agreement debugAgreement;
		JoinType joinType;
		JoinResult joinResult;
	};

	typedef uint32_t ScrVarCanonicalName_t;

	enum svscmd_type
	{
		SV_CMD_CAN_IGNORE_0 = 0x0,
		SV_CMD_RELIABLE_0 = 0x1,
	};

	struct client_s
	{
	};

	enum scriptInstance_t
	{
		SCRIPTINSTANCE_SERVER = 0x0,
		SCRIPTINSTANCE_CLIENT = 0x1,
		SCRIPT_INSTANCE_MAX = 0x2,
	};

	struct gclient_s
	{
		char __pad0[0x8C];
		float velocity[3];
		char __pad1[59504];
		char flags;
	};

	struct EntityState
	{
		int number;
	};

	struct gentity_s
	{
		EntityState s;
		unsigned char __pad0[0x24C];
		gclient_s* client;
		unsigned char __pad1[0x2A0];
	};

	static_assert(sizeof(gentity_s) == 0x4F8);

	union XAssetHeader
	{
		/*PhysPreset* physPreset;
		PhysConstraints* physConstraints;
		DestructibleDef* destructibleDef;
		XAnimParts* parts;
		XModel* model;
		XModelMesh* modelMesh;
		Material* material;
		MaterialComputeShaderSet* computeShaderSet;
		MaterialTechniqueSet* techniqueSet;
		GfxImage* image;
		SndBank* sound;
		SndPatch* soundPatch;
		clipMap_t* clipMap;
		ComWorld* comWorld;
		GameWorld* gameWorld;
		MapEnts* mapEnts;
		GfxWorld* gfxWorld;
		GfxLightDef* lightDef;
		GfxLensFlareDef* lensFlareDef;
		Font* font;
		FontIcon* fontIcon;
		LocalizeEntry* localize;
		WeaponVariantDef* weapon;
		WeaponAttachment* attachment;
		WeaponAttachmentUnique* attachmentUnique;
		WeaponCamo* weaponCamo;
		CustomizationTable* customizationTable;
		CustomizationColorInfo* customizationColorInfo;
		SndDriverGlobals* sndDriverGlobals;
		FxEffectDefHandleRaw fx;
		TagFxSet* tagFX;
		FxLensFlareDefPtr newLensFlareDef;
		FxImpactTable* impactFx;
		SoundsImpactTable* impactSounds;
		CgMediaTable* cgMedia;
		PlayerSoundsTable* playerSounds;
		PlayerFXTable* playerFX;
		SharedWeaponSounds* sharedWeaponSounds;
		RawFile* rawfile;
		StringTable* stringTable;
		StructuredTable* structuredTable;
		LeaderboardDef* leaderboardDef;
		DDLRoot* ddlRoot;
		Glasses* glasses;
		TextureList* textureList;
		ScriptParseTree* scriptParseTree;
		KeyValuePairs* keyValuePairs;
		VehicleDef* vehicleDef;
		AddonMapEnts* addonMapEnts;
		TracerDef* tracerDef;
		Qdb* qdb;
		Slug* slug;
		SurfaceFXTableDef* surfaceFXTableDef;
		SurfaceSoundDef* surfaceSoundDef;
		FootstepTableDef* footstepTableDef;
		EntitySoundImpacts* entitySoundImpacts;
		EntityFxImpacts* entityFxImpacts;
		ZBarrierDef* zbarrierDef;
		VehicleFxDef* vehicleFxDef;
		VehicleSoundDef* vehicleSoundDef;
		ArchiveTypeInfoArray* typeInfo;
		ScriptBundle* scriptBundle;
		ScriptBundleList* scriptBundleList;
		RumbleInfo* rumble;
		BulletPenetrationTable* bulletPenetration;
		LocDmgTable* locDmgTable;
		AimTable* aimTable;
		XModelAlias* xModelAlias;
		Character* character;
		AIType* aiType;
		PlayerCharacter* player_character;
		AnimSelectorTableSet* animSelectorTableSet;
		AnimMappingTable* animMappingTable;
		AnimStateMachine* animStateMachine;
		BehaviorTree* behaviorTree;
		BehaviorStateMachine* behaviorStateMachine;
		TTFDef* ttfDef;
		GfxSiegeAnim* sanim;
		GfxLightDescription* lightDescription;
		ShellshockParams* shellshock;
		XCam* xcam;
		BGCacheInfo* bgCache;
		TextureCombo* textureCombo;
		FlameTable* flameTable;
		Bitfield* bitfield;
		AttachmentCosmeticVariant* attachmentCosmeticVariant;
		MapTable* mapTable;
		Medal* medal;
		MedalTable* medalTable;
		Objective* objective;
		ObjectiveList* objectiveList;
		NavMeshData* navMesh;
		NavVolumeData* navVolume;
		BinaryHTML* binaryHTML;
		LaserDef* laserDef;
		BeamDef* beamDef;
		StreamerHint* streamerHint;*/
		void* data;
	};

	struct XAsset
	{
		XAssetType type;
		XAssetHeader header;
	};

	typedef void XAssetEnum(XAssetHeader, void*);

#ifdef __cplusplus
}
#endif

```

`src/client/game/symbols.cpp`:

```cpp
#include <std_include.hpp>

#include "game.hpp"

namespace game
{
	eModes Com_SessionMode_GetMode()
	{
		return eModes(*reinterpret_cast<uint32_t*>(game::select(0x1568EF7F4, 0x14948DB04)) << 28 >> 28);
	}

	bool I_islower(int c)
	{
		return c >= 'a' && c <= 'z';
	}

	bool I_isupper(int c)
	{
		return c >= 'A' && c <= 'Z';
	}

	unsigned int Scr_CanonHash(const char* str)
	{
#define FNV_OFFSET 0x4B9ACE2F
#define FNV_PRIME 16777619

		const auto* s = str;
		const int first_char = I_islower(*s) ? static_cast<unsigned char>(*s) : tolower(static_cast<unsigned char>(*str));

		unsigned int hash = FNV_PRIME * (first_char ^ FNV_OFFSET);
		while (*s)
		{
			int acc = I_islower(*++s)
				? static_cast<unsigned char>(*s)
				: std::tolower(static_cast<unsigned char>(*s));

			hash = FNV_PRIME * (acc ^ hash);
		}

		return hash;
	}
}

```

`src/client/game/symbols.hpp`:

```hpp
#pragma once

#include "structs.hpp"

#define WEAK __declspec(selectany)

namespace game
{
#define Com_Error(code, fmt, ...) Com_Error_(__FILE__, __LINE__, code, fmt, ##__VA_ARGS__)

	// CL
	WEAK symbol<void(int controllerIndex, XSESSION_INFO* hostInfo, const netadr_t* addr, int numPublicSlots,
	                 int numPrivateSlots, const char* mapname, const char* gametype)> CL_ConnectFromLobby
		{0x14134C570};

	// Game
	WEAK symbol<void(gentity_s* ent, gentity_s* target, int mode, const char* chatText)> G_Say{0x0, 0x140299170};
	WEAK symbol<void(const char* fmt, ...)> G_LogPrintf{0x0, 0x1402A7BB0};

	// Com
	WEAK symbol<void(int channel, unsigned int label, const char* fmt, ...)> Com_Printf{0x1421499C0, 0x140505630};
	WEAK symbol<void(const char* file, int line, int code, const char* fmt, ...)> Com_Error_{0x1420F8BD0};
	WEAK symbol<bool(eModes mode)> Com_SessionMode_IsMode{0x1420F7DD0};
	WEAK symbol<void(uint32_t localClientNum, eModes fromMode, eModes toMode, uint32_t flags)> Com_SwitchMode{
		0x14214AF30
	};

	WEAK symbol<void(uint32_t localClientNum, const char* text)> Cbuf_AddText{0x1420EC8B0, 0x1404F75B0};
	WEAK symbol<void(int localClientNum, ControllerIndex_t controllerIndex, const char* buffer)> Cbuf_ExecuteBuffer{
		0x0, 0x1404F78D0
	};
	WEAK symbol<void(const char* cmdName, xcommand_t function, cmd_function_s* allocedCmd)> Cmd_AddCommandInternal{
		0x1420ED530, 0x1404F8210
	};
	WEAK symbol<void()> Cbuf_AddServerText_f{0x0, 0x1407DB4C0};
	WEAK symbol<void(const char* cmdName, xcommand_t function, cmd_function_s* allocedCmd)> Cmd_AddServerCommandInternal
	{
		0x0, 0x1404F8280
	};
	WEAK symbol<void(uint32_t localClientNum, ControllerIndex_t controllerIndex, const char* text,
	                 bool fromRemoteConsol)> Cmd_ExecuteSingleCommand{
		0x1420EDC20
	};
	WEAK symbol<void(char* text, int maxSize)> Con_GetTextCopy{0x14133A7D0, 0x140182C40};

	// DB
	WEAK symbol<void(XZoneInfo* zoneInfo, uint32_t zoneCount, bool sync, bool suppressSync)> DB_LoadXAssets{
		0x1414236A0
	};
	WEAK symbol<void(XAssetType type, XAssetEnum* func, void* inData, bool includeOverride)> DB_EnumXAssets{
		0x141420970, 0x1401D5A50
	};
	WEAK symbol<XAssetHeader(XAssetType type, const char* name, bool errorIfMissing, int waitTime)> DB_FindXAssetHeader{
		0x141420ED0, 0x1401D5FB0
	};
	WEAK symbol<const char*(const XAsset* asset)> DB_GetXAssetName{0x1413E9DA0, 0x14019F080};

	// Live
	WEAK symbol<bool(uint64_t, int*, bool)> Live_GetConnectivityInformation{0x141E0C410};

	// MSG
	WEAK symbol<uint8_t(msg_t* msg)> MSG_ReadByte{0x142155EB0, 0x14050D1B0};

	// NET
	WEAK symbol<bool(netsrc_t sock, int length, const void* data, const netadr_t* to)> NET_SendPacket{
		0x142332F70, 0x140596E40
	};
	WEAK symbol<bool(char const*, netadr_t*)> NET_StringToAdr{0x1421731E0, 0x140515110};

	// Sys
	WEAK symbol<int()> Sys_Milliseconds{0x142333430};
	WEAK symbol<void()> Sys_ShowConsole{0x142333F80, 0x140597E40};
	WEAK symbol<TLSData*()> Sys_GetTLS{0x142184210, 0x140525EB0};
	WEAK symbol<TLSData*()> Sys_IsDatabaseReady{0x1421844C0};

	// Dvar
	WEAK symbol<const dvar_t*(const char* dvarName)> Dvar_FindVar{0x1422BD730, 0x140575540};
	WEAK symbol<unsigned int(const char* str)> Dvar_GenerateHash{0x14133DBF0};
	WEAK symbol<dvar_t*(unsigned int hash)> Dvar_FindMalleableVar{0x1422BD6A0};
	WEAK symbol<const char*(const dvar_t* dvar)> Dvar_GetDebugName{0x1422BDCB0};
	WEAK symbol<const char*(const dvar_t* dvar)> Dvar_GetString{0x1422BFFF0, 0x140575E30};
	WEAK symbol<int(const dvar_t* dvar)> Dvar_GetInt{0x1422BF2C0, 0x140575C20};
	WEAK symbol<void(const char* dvarName, const char* string, bool createIfMissing)> Dvar_SetFromStringByName{
		0x1422C7F60
	};

	// Scr
	WEAK symbol<void(scriptInstance_t inst, int value)> Scr_AddInt{0x0, 0x14016F160};
	WEAK symbol<void(scriptInstance_t inst, const char* value)> Scr_AddString{0x0, 0x14016F320};
	WEAK symbol<const char*(scriptInstance_t inst, unsigned int index)> Scr_GetString{0x0, 0x140171490};
	WEAK symbol<void(gentity_s* ent, ScrVarCanonicalName_t stringValue, unsigned int paramcount)> Scr_Notify_Canon{
		0x0, 0x1402F5FF0
	};
	WEAK symbol<unsigned int(scriptInstance_t inst)> Scr_GetNumParam{0x0, 0x140171320};

	WEAK symbol<void(const char* name, const char* key, unsigned int playbackFlags, float volume, void* callbackInfo, int id)> Cinematic_StartPlayback{0x1412BE3A0};
	WEAK symbol<void(uint64_t id, bool cancelAll)> Cinematic_StopPlayback{0x1412BEA70};

	WEAK symbol<bool(void* storageFileInfo)> ShouldTransfer{0x142276E10};

	// Rendering
	WEAK symbol<void(const char*, int, const void*, float, float, float, float, float, const float*, int)>
	R_AddCmdDrawText{
		0x141CD98D0
	};

	// SV
	WEAK symbol<void*()> SV_AddTestClient{0x1422499A0, 0x14052E3E0};
	WEAK symbol<void(client_s* cl_0, svscmd_type type, const char* fmt, ...)> SV_SendServerCommand{0x0, 0x140537F10};

	// Variables

	WEAK symbol<cmd_function_s> cmd_functions{0x15689FF58, 0x14946F860};
	WEAK symbol<CmdArgs> sv_cmd_args{0x15689CE30, 0x14944C740};

	WEAK symbol<gentity_s> g_entities{0x0, 0x1471031B0};

	WEAK symbol<int> level_time{0x0, 0x1474FDC94};

	WEAK symbol<SOCKET> ip_socket{0x157E77818, 0x14A640988};

	WEAK symbol<Join> s_join{0x15574C640};

	namespace s_wcd
	{
		WEAK symbol<HWND> codLogo{0x157E77A50, 0x14A640BC0};
		WEAK symbol<HFONT> hfBufferFont{0x157E77A58, 0x14A640BC8};
		WEAK symbol<HWND> hWnd{0x157E77A40, 0x14A640BB0};
		WEAK symbol<HWND> hwndBuffer{0x157E77A48, 0x14A640BB8};
		WEAK symbol<HWND> hwndInputLine{0x157E77A60, 0x14A640BD0};
		WEAK symbol<int> windowHeight{0x157E7806C, 0x14A6411DC};
		WEAK symbol<int> windowWidth{0x157E78068, 0x14A6411D8};
		WEAK symbol<WNDPROC> SysInputLineWndProc{0x157E78070, 0x14A6411E0};
	}

	// Global game definitions
	constexpr auto CMD_MAX_NESTING = 8;

	// Re-implementations
	eModes Com_SessionMode_GetMode();

	bool I_islower(int c);
	bool I_isupper(int c);

	unsigned int Scr_CanonHash(const char* str);
}

```

`src/client/launcher/html/dispatch.hpp`:

```hpp
#pragma once


class dispatch : public IDispatch
{
public:
	virtual ~dispatch() = default;

	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT* pctinfo) override
	{
		return S_FALSE;
	}

	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo) override
	{
		return S_FALSE;
	}

};

```

`src/client/launcher/html/doc_host_ui_handler.hpp`:

```hpp
#pragma once

class doc_host_ui_handler /*_boilerplate*/ : public IDocHostUIHandler
{
public:
	virtual ~doc_host_ui_handler() = default;

	HRESULT STDMETHODCALLTYPE ShowContextMenu(
		DWORD,
		POINT*,
		IUnknown*,
		IDispatch*) override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE ShowUI(
		DWORD,
		IOleInPlaceActiveObject*,
		IOleCommandTarget*,
		IOleInPlaceFrame*,
		IOleInPlaceUIWindow*) override
	{
		return S_OK;
	}
	
	HRESULT STDMETHODCALLTYPE HideUI() override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE UpdateUI() override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE EnableModeless(BOOL) override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL) override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL) override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE ResizeBorder(
		LPCRECT,
		IOleInPlaceUIWindow*,
		BOOL) override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE TranslateAccelerator(
		LPMSG,
		const GUID*,
		DWORD) override
	{
		return S_FALSE;
	}

	HRESULT STDMETHODCALLTYPE GetOptionKeyPath(LPOLESTR __RPC_FAR* pchKey, DWORD dw) override
	{
		return S_FALSE;
	}

	HRESULT STDMETHODCALLTYPE GetDropTarget(
		IDropTarget*,
		IDropTarget**) override
	{
		return S_FALSE;
	}


	HRESULT STDMETHODCALLTYPE TranslateUrl(DWORD, OLECHAR*, OLECHAR** ppchURLOut) override
	{
		*ppchURLOut = nullptr;
		return S_FALSE;
	}

	HRESULT STDMETHODCALLTYPE FilterDataObject(IDataObject*, IDataObject** ppDORet) override
	{
		*ppDORet = nullptr;
		return S_FALSE;
	}
};

```

`src/client/launcher/html/html_argument.cpp`:

```cpp
#include <std_include.hpp>
#include "html_argument.hpp"

html_argument::html_argument(VARIANT* val)
	: html_argument(*val)
{
}

html_argument::html_argument(CComVariant val)
	: value_(std::move(val))
{
}

bool html_argument::is_empty() const
{
	return this->value_.vt == VT_EMPTY;
}

bool html_argument::is_string() const
{
	if (this->is_empty()) return false;
	return this->value_.vt == VT_BSTR;
}

bool html_argument::is_number() const
{
	if (this->is_empty()) return false;
	return this->value_.vt == VT_I4;
}

bool html_argument::is_bool() const
{
	if (this->is_empty()) return false;
	return this->value_.vt == VT_BOOL;
}

std::string html_argument::get_string() const
{
	if (!this->is_string()) return {};
	std::wstring wide_string(this->value_.bstrVal);
	return std::string(wide_string.begin(), wide_string.end());
}

int html_argument::get_number() const
{
	if (!this->is_number()) return 0;
	return this->value_.intVal;
}

bool html_argument::get_bool() const
{
	if (!this->is_bool()) return false;
	return this->value_.boolVal != FALSE;
}

void html_argument::copy_to(VARIANT& var) const
{
	if (this->is_empty())
	{
		VariantInit(&var);
	}
	else
	{
		(void)VariantCopy(&var, &this->value_);
	}
}

void html_argument::move_to(VARIANT* var)
{
	if (!var)
	{
		return;
	}

	VARIANT& src_var = this->value_;
	memcpy(var, &src_var, sizeof(*var));

	VariantInit(&this->value_);
}

```

`src/client/launcher/html/html_argument.hpp`:

```hpp
#pragma once

#pragma once

class html_argument final
{
public:
	html_argument() = default;
	html_argument(VARIANT* val);
	html_argument(CComVariant val);

	bool is_empty() const;

	bool is_string() const;
	bool is_number() const;
	bool is_bool() const;

	std::string get_string() const;
	int get_number() const;
	bool get_bool() const;

	const CComVariant& get() const
	{
		return this->value_;
	}

	void copy_to(VARIANT& var) const;
	void move_to(VARIANT* var);

private:
	CComVariant value_{};
};

```

`src/client/launcher/html/html_frame.cpp`:

```cpp
#include <std_include.hpp>
#include "html_frame.hpp"
#include "utils/nt.hpp"
#include "utils/io.hpp"
#include "utils/hook.hpp"


namespace
{
	void* original_func{};
	GUID browser_emulation_guid{0xac969931, 0x3566, 0x4b50, {0xae, 0x48, 0x71, 0xb9, 0x6a, 0x75, 0xc8, 0x79}};

	int WINAPI co_internet_feature_value_internal_stub(const GUID* guid, uint32_t* result)
	{
		const auto res = static_cast<decltype(co_internet_feature_value_internal_stub)*>(original_func)(guid, result);

		if (IsEqualGUID(*guid, browser_emulation_guid))
		{
			*result = 11000;
			return 0;
		}

		return res;
	}

	void patch_cached_browser_emulator(const utils::nt::library& urlmon)
	{
		std::string data{};
		if(!utils::io::read_file(urlmon.get_path().generic_string(), &data))
		{
			return;
		}

		const utils::nt::library file_lib(reinterpret_cast<HMODULE>(data.data()));

		auto translate_file_offset_to_rva = [&](const size_t file_offset) -> size_t
		{
			const auto sections = file_lib.get_section_headers();
			for(const auto* section :  sections)
			{
				if(section->PointerToRawData <= file_offset && section->PointerToRawData + section->SizeOfRawData > file_offset)
				{
					const auto section_va = file_offset - section->PointerToRawData;
					return section_va + section->VirtualAddress;
				}
			}

			return 0;
		};

		const auto guid_pos = data.find(std::string(reinterpret_cast<const char*>(&browser_emulation_guid), sizeof(browser_emulation_guid)));
		if(guid_pos == std::string::npos)
		{
			return;
		}

		const auto guid_rva = translate_file_offset_to_rva(guid_pos);
		const auto guid_va = reinterpret_cast<GUID*>(urlmon.get_ptr() + guid_rva);

		if (!IsEqualGUID(*guid_va, browser_emulation_guid))
		{
			return;
		}

		const size_t unrelocated_guid_va = file_lib.get_optional_header()->ImageBase + guid_rva;
		const auto guid_ptr_pos = data.find(std::string(reinterpret_cast<const char*>(&unrelocated_guid_va), sizeof(unrelocated_guid_va)));
		if (guid_ptr_pos == std::string::npos)
		{
			return;
		}

		const auto guid_ptr_rva = translate_file_offset_to_rva(guid_ptr_pos);
		*reinterpret_cast<GUID**>(urlmon.get_ptr() + guid_ptr_rva) = guid_va;
	}

	void setup_ie_hooks()
	{
		static const auto _ = []
		{
			const auto urlmon = utils::nt::library::load("urlmon.dll"s);
			const auto target = urlmon.get_iat_entry("iertutil.dll", MAKEINTRESOURCEA(700));

			original_func = *target;
			utils::hook::set(target, co_internet_feature_value_internal_stub);

			patch_cached_browser_emulator(urlmon);

			return 0;
		}();
		(void)_;
	}

	void setup_ole()
	{
		static struct ole_initialzer
		{
			ole_initialzer()
			{
				if (OleInitialize(nullptr) != S_OK)
				{
					throw std::runtime_error("Unable to initialize the OLE library");
				}
			}

			~ole_initialzer()
			{
				OleUninitialize();
			}
		} init;
		(void)init;
	}
}

html_frame::html_frame()
{
	setup_ie_hooks();
	setup_ole();
}

HRESULT html_frame::GetHostInfo(DOCHOSTUIINFO* pInfo)
{
	pInfo->cbSize = sizeof(DOCHOSTUIINFO);
	pInfo->dwFlags = DOCHOSTUIFLAG_NO3DBORDER | DOCHOSTUIFLAG_DPI_AWARE | DOCHOSTUIFLAG_SCROLL_NO;
	pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

	return S_OK;
}

HRESULT html_frame::GetWindow(HWND* lphwnd)
{
	*lphwnd = this->window_;
	return S_OK;
}

HRESULT html_frame::QueryInterface(REFIID riid, void** ppvObject)
{
	if (IsEqualGUID(riid, IID_IDispatch))
	{
		*ppvObject = static_cast<IDispatch*>(this);
		return S_OK;
	}

	if (IsEqualGUID(riid, IID_IDispatch))
	{
		const auto d = get_dispatch();
		if (!d)
		{
			return E_NOINTERFACE;
		}

		(*d).AddRef();
		*ppvObject = &*d;
		return S_OK;
	}

	if (IsEqualGUID(riid, IID_IServiceProvider))
	{
		*ppvObject = static_cast<IServiceProvider*>(this);
		return S_OK;
	}

	if (IsEqualGUID(riid, IID_IInternetSecurityManager))
	{
		*ppvObject = static_cast<IInternetSecurityManager*>(this);
		 return S_OK;
	}

	if (IsEqualGUID(riid, IID_IUnknown))
	{
		*ppvObject = static_cast<IUnknown*>(static_cast<IOleClientSite*>(this));
		return S_OK;
	}

	if (IsEqualGUID(riid, IID_IOleClientSite))
	{
		*ppvObject = static_cast<IOleClientSite*>(this);
		return S_OK;
	}

	if (IsEqualGUID(riid, IID_IOleInPlaceSite))
	{
		*ppvObject = static_cast<IOleInPlaceSite*>(this);
		return S_OK;
	}

	if (IsEqualGUID(riid, IID_IOleInPlaceFrame))
	{
		*ppvObject = static_cast<IOleInPlaceFrame*>(this);
		return S_OK;
	}

	if (IsEqualGUID(riid, IID_IDocHostUIHandler))
	{
		*ppvObject = static_cast<IDocHostUIHandler*>(this);
		return S_OK;
	}

	if (IsEqualGUID(riid, IID_IOleInPlaceObject) && this->browser_object_)
	{
		return this->browser_object_->QueryInterface(riid, ppvObject);
	}

	*ppvObject = nullptr;
	return E_NOINTERFACE;
}

HWND html_frame::get_window() const
{
	return this->window_;
}

CComPtr<IOleObject> html_frame::get_browser_object() const
{
	return this->browser_object_;
}

CComPtr<IWebBrowser2> html_frame::get_web_browser() const
{
	CComPtr<IWebBrowser2> web_browser{};
	if (!this->browser_object_ || FAILED(this->browser_object_.QueryInterface(&web_browser)))
	{
		return {};
	}

	return web_browser;
}

CComPtr<IDispatch> html_frame::get_dispatch() const
{
	const auto web_browser = this->get_web_browser();

	CComPtr<IDispatch> dispatch{};
	if (!web_browser || FAILED(web_browser->get_Document(&dispatch)))
	{
		return {};
	}

	return dispatch;
}

CComPtr<IHTMLDocument2> html_frame::get_document() const
{
	const auto dispatch = this->get_dispatch();

	CComPtr<IHTMLDocument2> document{};
	if (!dispatch || FAILED(dispatch.QueryInterface(&document)))
	{
		return {};
	}

	return document;
}

void html_frame::initialize(const HWND window)
{
	if (this->window_) return;
	this->window_ = window;

	this->create_browser();
	this->initialize_browser();
}

void html_frame::create_browser()
{
	CComPtr<IClassFactory> class_factory{};
	if (FAILED(
		CoGetClassObject(CLSID_WebBrowser, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER, nullptr, IID_IClassFactory,
			reinterpret_cast<void **>(&class_factory))))
	{
		throw std::runtime_error("Unable to get the class factory");
	}

	class_factory->CreateInstance(nullptr, IID_IOleObject, reinterpret_cast<void**>(&this->browser_object_));

	if (!this->browser_object_)
	{
		throw std::runtime_error("Unable to create browser object");
	}
}

void html_frame::initialize_browser()
{
	this->browser_object_->SetClientSite(this);
	this->browser_object_->SetHostNames(L"Hostname", nullptr);

	RECT rect;
	GetClientRect(this->get_window(), &rect);
	OleSetContainedObject(this->browser_object_, TRUE);

	this->browser_object_->DoVerb(OLEIVERB_SHOW, nullptr, this, -1, this->get_window(), &rect);
	this->resize(rect.right, rect.bottom);
}

void html_frame::resize(const DWORD width, const DWORD height) const
{
	const auto web_browser = this->get_web_browser();
	if (web_browser)
	{
		web_browser->put_Left(0);
		web_browser->put_Top(0);
		web_browser->put_Width(width);
		web_browser->put_Height(height);
	}
}

bool html_frame::load_url(const std::string& url) const
{
	auto web_browser = this->get_web_browser();
	if (!web_browser) return false;

	CComVariant my_url(url.data());
	return SUCCEEDED(web_browser->Navigate2(&my_url, nullptr, nullptr, nullptr, nullptr));
}

bool html_frame::load_html(const std::string& html) const
{
	if (!this->load_url("about:blank")) return false;

	const auto document = this->get_document();
	if (!document) return false;

	CComSafeArrayBound bound{};
	bound.SetCount(1);
	bound.SetLowerBound(0);

	CComSafeArray<VARIANT> array(&bound, 1);
	array[0] = CComVariant(html.data());

	document->write(array);
	document->close();

	return true;
}

html_argument html_frame::evaluate(const std::string& javascript) const
{
	auto dispDoc = this->get_dispatch();
	
	CComPtr<IHTMLDocument2> htmlDoc;
	dispDoc->QueryInterface(&htmlDoc);

	CComPtr<IHTMLWindow2> htmlWindow;
	htmlDoc->get_parentWindow(&htmlWindow);

	CComDispatchDriver dispWindow;
	htmlWindow->QueryInterface(&dispWindow);

	CComPtr<IDispatchEx> dispexWindow;
	htmlWindow->QueryInterface(&dispexWindow);

	DISPID dispidEval = -1;
	dispexWindow->GetDispID(CComBSTR("eval"), fdexNameCaseSensitive, &dispidEval);

	CComVariant result{};
	CComVariant code(javascript.data());
	(void)dispWindow.Invoke1(dispidEval, &code, &result);

	return result;
}

int html_frame::get_callback_id(const std::string& name) const
{
	for (auto i = 0u; i < this->callbacks_.size(); ++i)
	{
		if (this->callbacks_[i].first == name)
		{
			return i;
		}
	}

	return -1;
}

html_argument html_frame::invoke_callback(const int id, const std::vector<html_argument>& params) const
{
	if (id >= 0 && static_cast<unsigned int>(id) < this->callbacks_.size())
	{
		return this->callbacks_[id].second(params);
	}

	return {};
}

void html_frame::register_callback(const std::string& name, const std::function<CComVariant(const std::vector<html_argument>&)>& callback)
{
	this->callbacks_.emplace_back(name, callback);
}

HRESULT html_frame::GetIDsOfNames(const IID& /*riid*/, LPOLESTR* rgszNames, UINT cNames, LCID /*lcid*/,
                                  DISPID* rgDispId)
{
	for (unsigned int i = 0; i < cNames; ++i)
	{
		std::wstring wide_name(rgszNames[i]);
		std::string name(wide_name.begin(), wide_name.end());

		rgDispId[i] = this->get_callback_id(name);
	}

	return S_OK;
}

HRESULT html_frame::Invoke(const DISPID dispIdMember, const IID& /*riid*/, LCID /*lcid*/, WORD /*wFlags*/,
                           DISPPARAMS* pDispParams,
                           VARIANT* pVarResult, EXCEPINFO* /*pExcepInfo*/, UINT* /*puArgErr*/)
{
	std::vector<html_argument> params{};
	for (auto i = pDispParams->cArgs; i > 0; --i)
	{
		auto& param = pDispParams->rgvarg[i - 1];
		params.emplace_back(param);
	}

	auto res = this->invoke_callback(dispIdMember, params);
	res.move_to(pVarResult);

	return S_OK;
}

HRESULT html_frame::GetExternal(IDispatch** ppDispatch)
{
	*ppDispatch = this;
	return *ppDispatch ? S_OK : S_FALSE;
}

```

`src/client/launcher/html/html_frame.hpp`:

```hpp
#pragma once
#include "ole_in_place_frame.hpp"
#include "ole_in_place_site.hpp"
#include "doc_host_ui_handler.hpp"
#include "ole_client_site.hpp"
#include "service_provider.hpp"
#include "internet_security_manager.hpp"
#include "dispatch.hpp"
#include "html_argument.hpp"

class html_frame
	: doc_host_ui_handler
	, service_provider
	, internet_security_manager
	, ole_client_site
	, ole_in_place_frame
	, ole_in_place_site
	, dispatch
{
public:
	html_frame();
	html_frame(const html_frame&) = delete;
	html_frame& operator=(const html_frame&) = delete;
	html_frame(html_frame&&) = delete;
	html_frame& operator=(html_frame&&) = delete;

	~html_frame() override = default;

	void initialize(HWND window);

	void resize(DWORD width, DWORD height) const;
	bool load_url(const std::string& url) const;
	bool load_html(const std::string& html) const;

	html_argument evaluate(const std::string& javascript) const;

	HWND get_window() const;

	CComPtr<IOleObject> get_browser_object() const;
	CComPtr<IWebBrowser2> get_web_browser() const;
	CComPtr<IDispatch> get_dispatch() const;
	CComPtr<IHTMLDocument2> get_document() const;

	int get_callback_id(const std::string& name) const;
	html_argument invoke_callback(int id, const std::vector<html_argument>& params) const;

	void register_callback(const std::string& name, const std::function<CComVariant(const std::vector<html_argument>&)>& callback);

	HRESULT STDMETHODCALLTYPE QueryInterface(
		REFIID riid,
		void** ppvObject) override;

private:
	HWND window_ = nullptr;
	CComPtr<IOleObject> browser_object_;

	std::vector<std::pair<std::string, std::function<html_argument(const std::vector<html_argument>&)>>> callbacks_;

	void create_browser();
	void initialize_browser();

	HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO* pInfo) override;
	HRESULT STDMETHODCALLTYPE GetWindow(HWND* lphwnd) override;

	ULONG STDMETHODCALLTYPE AddRef() override
	{
		return 1;
	}

	ULONG STDMETHODCALLTYPE Release() override
	{
		return 1;
	}

	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgDispId)
	override;
	HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pDispParams,
	                                 VARIANT* pVarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr) override;


	HRESULT STDMETHODCALLTYPE GetExternal(IDispatch** ppDispatch) override;
};

```

`src/client/launcher/html/html_window.cpp`:

```cpp
#include <std_include.hpp>
#include "html_window.hpp"

html_window::html_window(const std::string& title, int width, int height, long flags)
	: window_(title, width, height,
		[this](window*, const UINT message, const WPARAM w_param, const LPARAM l_param) -> std::optional<LRESULT> {
			return this->processor(message, w_param, l_param);
		}, flags)
{
}

window* html_window::get_window()
{
	return &this->window_;
}

html_frame* html_window::get_html_frame()
{
	return &this->frame_;
}

std::optional<LRESULT> html_window::processor(const UINT message, const WPARAM w_param, const LPARAM l_param)
{
	if (message == WM_SIZE)
	{
		this->frame_.resize(LOWORD(l_param), HIWORD(l_param));
		return 0;
	}

	if (message == WM_CREATE)
	{
		this->frame_.initialize(this->window_);
		return 0;
	}

	return {};
}

```

`src/client/launcher/html/html_window.hpp`:

```hpp
#pragma once
#include "../window.hpp"
#include "html_frame.hpp"

class html_window final
{
public:
	html_window(const std::string& title, int width, int height,
		long flags = (WS_OVERLAPPEDWINDOW & ~(WS_THICKFRAME | WS_MAXIMIZEBOX)));

	~html_window() = default;

	window* get_window();
	html_frame* get_html_frame();

private:
	html_frame frame_{};
	window window_;

	std::optional<LRESULT> processor(UINT message, WPARAM w_param, LPARAM l_param);
};

```

`src/client/launcher/html/internet_security_manager.hpp`:

```hpp
#pragma once

class internet_security_manager : public IInternetSecurityManager
{
public:
	HRESULT STDMETHODCALLTYPE SetSecuritySite(
		IInternetSecurityMgrSite*) override
	{
		return INET_E_DEFAULT_ACTION;
	}

	virtual HRESULT STDMETHODCALLTYPE GetSecuritySite(
		IInternetSecurityMgrSite**) override
	{
		return INET_E_DEFAULT_ACTION;
	}

	virtual HRESULT STDMETHODCALLTYPE MapUrlToZone(
		LPCWSTR,
		DWORD* pdwZone,
		DWORD) override
	{
		*pdwZone = URLZONE_TRUSTED;
		return S_OK;
	}

	virtual HRESULT STDMETHODCALLTYPE GetSecurityId(
		LPCWSTR,
		BYTE*,
		DWORD*,
		DWORD_PTR) override
	{
		return INET_E_DEFAULT_ACTION;
	}

	virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction(
		LPCWSTR, 
		DWORD,
		BYTE*,
		DWORD,
		BYTE*,
		DWORD,
		DWORD,
		DWORD) override
	{
		return INET_E_DEFAULT_ACTION;
	}

	virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy(
		LPCWSTR,
		REFGUID,
		BYTE**,
		DWORD*,
		BYTE*,
		DWORD,
		DWORD) override
	{
		return INET_E_DEFAULT_ACTION;
	}

	HRESULT STDMETHODCALLTYPE SetZoneMapping(
		DWORD,
		LPCWSTR,
		DWORD) override
	{
		return INET_E_DEFAULT_ACTION;
	}

	HRESULT STDMETHODCALLTYPE GetZoneMappings(
		DWORD,
		IEnumString**,
		DWORD) override
	{
		return INET_E_DEFAULT_ACTION;
	}
};

```

`src/client/launcher/html/ole_client_site.hpp`:

```hpp
#pragma once

class ole_client_site : public IOleClientSite
{
public:
	virtual ~ole_client_site() = default;

	HRESULT STDMETHODCALLTYPE SaveObject() override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, IMoniker**) override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER* ppContainer) override
	{
		*ppContainer = nullptr;
		return E_NOINTERFACE;
	}

	HRESULT STDMETHODCALLTYPE ShowObject() override
	{
		return NOERROR;
	}

	HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL) override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE RequestNewObjectLayout() override
	{
		return E_NOTIMPL;
	}
};

```

`src/client/launcher/html/ole_in_place_frame.hpp`:

```hpp
#pragma once

class ole_in_place_frame : public IOleInPlaceFrame
{
public:
	virtual ~ole_in_place_frame() = default;

	HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL) override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE GetBorder(LPRECT) override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS) override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS) override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE SetActiveObject(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR pszObjName) override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths) override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE SetMenu(HMENU, HOLEMENU, HWND) override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE RemoveMenus(HMENU hmenuShared) override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR) override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE EnableModeless(BOOL) override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpmsg, WORD wID) override
	{
		return E_NOTIMPL;
	}
};

```

`src/client/launcher/html/ole_in_place_site.hpp`:

```hpp
#pragma once

class ole_in_place_site : public IOleInPlaceSite
{
public:
	virtual ~ole_in_place_site() = default;

	HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL) override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE CanInPlaceActivate() override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE OnInPlaceActivate() override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE OnUIActivate() override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE GetWindowContext(LPOLEINPLACEFRAME* lplpFrame, LPOLEINPLACEUIWINDOW* lplpDoc,
	                                           const LPRECT lprcPosRect, const LPRECT lprcClipRect,
	                                           const LPOLEINPLACEFRAMEINFO lpFrameInfo) override
	{
		ZeroMemory(lprcPosRect, sizeof(*lprcPosRect));
		ZeroMemory(lprcClipRect, sizeof(*lprcClipRect));

		CComPtr<IOleInPlaceFrame> ole_in_place_frame{};
		if (FAILED(QueryInterface(IID_IOleInPlaceFrame, reinterpret_cast<void**>(&ole_in_place_frame))))
		{
			*lplpFrame = nullptr;
			*lplpDoc = nullptr;
			return E_FAIL;
		}

		*lplpFrame = ole_in_place_frame;
		*lplpDoc = nullptr;

		lpFrameInfo->fMDIApp = FALSE;
		lpFrameInfo->haccel = nullptr;
		lpFrameInfo->cAccelEntries = 0;
		GetWindow(&lpFrameInfo->hwndFrame);

		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE Scroll(SIZE) override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL) override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate() override
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE DiscardUndoState() override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE DeactivateAndUndo() override
	{
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE OnPosRectChange(const LPCRECT lprcPosRect) override
	{
		CComPtr<IOleInPlaceObject> in_place{};
		if (SUCCEEDED(QueryInterface(IID_IOleInPlaceObject, reinterpret_cast<void**>(&in_place))))
		{
			in_place->SetObjectRects(lprcPosRect, lprcPosRect);
		}

		return S_OK;
	}
};

```

`src/client/launcher/html/service_provider.hpp`:

```hpp
#pragma once

class service_provider : public IServiceProvider
{
public:
	virtual ~service_provider() = default;

	HRESULT STDMETHODCALLTYPE QueryService(
		REFGUID guidService,
		REFIID riid,
		void** ppvObject) override
	{
		if (IsEqualGUID(riid, IID_IInternetSecurityManager))
		{
			return QueryInterface(riid, ppvObject);
		}

		*ppvObject = nullptr;
		return E_NOINTERFACE;
	}
};


```

`src/client/launcher/launcher.cpp`:

```cpp
#include <std_include.hpp>
#include <utils/nt.hpp>

#include "launcher.hpp"
#include "html/html_window.hpp"

#include "resource.hpp"
#include "component/updater.hpp"

namespace launcher
{
	bool run()
	{
		updater::update();

		bool run_game = false;
		html_window window("BOIII", 550, 380);

		window.get_html_frame()->register_callback(
			"openUrl", [](const std::vector<html_argument>& params) -> CComVariant
			{
				if (params.empty()) return {};

				const auto& param = params[0];
				if (!param.is_string()) return {};

				const auto url = param.get_string();
				ShellExecuteA(nullptr, "open", url.data(), nullptr, nullptr, SW_SHOWNORMAL);

				return {};
			});

		window.get_html_frame()->register_callback(
			"runGame", [&](const std::vector<html_argument>& /*params*/) -> CComVariant
			{
				run_game = true;
				window.get_window()->close();
				return {};
			});

		window.get_html_frame()->load_html(utils::nt::load_resource(MENU_MAIN));

		window::run();
		return run_game;
	}
}

```

`src/client/launcher/launcher.hpp`:

```hpp
#pragma once

namespace launcher
{
	bool run();
}

```

`src/client/launcher/window.cpp`:

```cpp
#include <std_include.hpp>
#include "window.hpp"

namespace
{
	thread_local uint32_t window_count = 0;
}

window::window(const std::string& title, const int width, const int height,
	std::function<std::optional<LRESULT>(window*, UINT, WPARAM, LPARAM)> callback,
	const long flags)
	: callback_(std::move(callback))
{
	ZeroMemory(&this->wc_, sizeof(this->wc_));

	this->classname_ = "window-base-" + std::to_string(time(nullptr));

	this->wc_.cbSize = sizeof(this->wc_);
	this->wc_.style = CS_HREDRAW | CS_VREDRAW;
	this->wc_.lpfnWndProc = static_processor;
	this->wc_.hInstance = GetModuleHandle(nullptr);
	this->wc_.hCursor = LoadCursor(nullptr, IDC_ARROW);
	this->wc_.hIcon = LoadIcon(this->wc_.hInstance, MAKEINTRESOURCE(102));
	this->wc_.hIconSm = this->wc_.hIcon;
	this->wc_.hbrBackground = HBRUSH(COLOR_WINDOW);
	this->wc_.lpszClassName = this->classname_.data();
	RegisterClassEx(&this->wc_);

	const auto x = (GetSystemMetrics(SM_CXSCREEN) - width) / 2;
	const auto y = (GetSystemMetrics(SM_CYSCREEN) - height) / 2;

	++window_count;

	this->handle_ = CreateWindowExA(NULL, this->wc_.lpszClassName, title.data(), flags, x, y, width, height, nullptr,
		nullptr, this->wc_.hInstance, this);

	SendMessageA(this->handle_, WM_DPICHANGED, 0, 0);
	ShowWindow(this->handle_, SW_SHOW);
	SetForegroundWindow(this->handle_);
}

window::~window()
{
	this->close();
	UnregisterClass(this->wc_.lpszClassName, this->wc_.hInstance);
}

void window::close()
{
	if (!this->handle_) return;

	DestroyWindow(this->handle_);
	this->handle_ = nullptr;
}

void window::run()
{
	MSG msg{};
	while (GetMessage(&msg, nullptr, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
}

LRESULT window::processor(const UINT message, const WPARAM w_param, const LPARAM l_param)
{
	if (message == WM_DPICHANGED)
	{
		const auto dpi = GetDpiForWindow(*this);
		if (dpi != this->last_dpi_)
		{
			RECT rect;
			GetWindowRect(*this, &rect);

			const auto scale = dpi * 1.0 / this->last_dpi_;
			this->last_dpi_ = dpi;

			const auto width = rect.right - rect.left;
			const auto height = rect.bottom - rect.top;

			MoveWindow(*this, rect.left, rect.top, int(width * scale), int(height * scale), TRUE);
		}
	}

	if (message == WM_DESTROY)
	{
		if (--window_count == 0)
		{
			PostQuitMessage(0);
		}

		return TRUE;
	}

	if (this->callback_)
	{
		const auto res = this->callback_(this, message, w_param, l_param);
		if (res)
		{
			return *res;
		}
	}

	return DefWindowProc(*this, message, w_param, l_param);
}

LRESULT CALLBACK window::static_processor(HWND hwnd, UINT message, WPARAM w_param, LPARAM l_param)
{
	if (message == WM_CREATE)
	{
		auto data = reinterpret_cast<LPCREATESTRUCT>(l_param);
		SetWindowLongPtrA(hwnd, GWLP_USERDATA, LONG_PTR(data->lpCreateParams));

		reinterpret_cast<window*>(data->lpCreateParams)->handle_ = hwnd;
	}

	const auto self = reinterpret_cast<window*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
	if (self) return self->processor(message, w_param, l_param);

	return DefWindowProc(hwnd, message, w_param, l_param);
}


window::operator HWND() const
{
	return this->handle_;
}

```

`src/client/launcher/window.hpp`:

```hpp
#pragma once

class window
{
public:
	window(const std::string& title, int width, int height,
		std::function<std::optional<LRESULT>(window*, UINT, WPARAM, LPARAM)> callback,
		long flags = (WS_OVERLAPPEDWINDOW & ~(WS_THICKFRAME | WS_MAXIMIZEBOX)));

	virtual ~window();

	void close();

	operator HWND() const;

	static void run();

	LRESULT processor(UINT message, WPARAM w_param, LPARAM l_param);

private:
	uint32_t last_dpi_ = 96;

	WNDCLASSEX wc_{};
	HWND handle_ = nullptr;
	std::string classname_;
	std::function<std::optional<LRESULT>(window*, UINT, WPARAM, LPARAM)> callback_;

	static LRESULT CALLBACK static_processor(HWND hwnd, UINT message, WPARAM w_param, LPARAM l_param);
};

```

`src/client/loader/component_interface.hpp`:

```hpp
#pragma once

enum class component_priority
{
	min = 0,
	// must run after the updater
	steam_proxy,
	updater,
	// must have the highest priority
	arxan,
};

enum class component_type
{
	client,
	server,
	any,
};

struct generic_component
{
	static constexpr component_type type = component_type::any;

	virtual ~generic_component() = default;

	virtual void post_load()
	{
	}

	virtual void pre_destroy()
	{
	}

	virtual void post_unpack()
	{
	}

	virtual component_priority priority() const
	{
		return component_priority::min;
	}
};

struct client_component : generic_component
{
	static constexpr component_type type = component_type::client;
};

struct server_component : generic_component
{
	static constexpr component_type type = component_type::server;
};

```

`src/client/loader/component_loader.cpp`:

```cpp
#include <std_include.hpp>
#include "component_loader.hpp"

#include <utils/nt.hpp>

namespace component_loader
{
	namespace
	{
		std::vector<std::unique_ptr<generic_component>>& get_components()
		{
			using component_vector = std::vector<std::unique_ptr<generic_component>>;
			using component_vector_container = std::unique_ptr<component_vector, std::function<void(component_vector*)>>
				;

			static component_vector_container components(new component_vector,
			                                             [](const component_vector* component_vector)
			                                             {
				                                             pre_destroy();
				                                             delete component_vector;
			                                             });

			return *components;
		}

		std::vector<std::pair<registration_functor, component_type>>& get_registration_functors()
		{
			static std::vector<std::pair<registration_functor, component_type>> functors;
			return functors;
		}

		void activate_component(std::unique_ptr<generic_component> component)
		{
			auto& components = get_components();
			components.push_back(std::move(component));

			std::ranges::stable_sort(components, [](const std::unique_ptr<generic_component>& a,
			                                        const std::unique_ptr<generic_component>& b)
			{
				return a->priority() > b->priority();
			});
		}
	}

	void register_component(registration_functor functor, component_type type)
	{
		if (!get_components().empty())
		{
			throw std::runtime_error("Registration is too late");
		}

		get_registration_functors().emplace_back(std::move(functor), type);
	}

	bool activate(bool server)
	{
		static auto res = [server]
		{
			try
			{
				for (auto& functor : get_registration_functors())
				{
					if (functor.second == component_type::any || server == (functor.second == component_type::server))
					{
						activate_component(functor.first());
					}
				}
			}
			catch (premature_shutdown_trigger&)
			{
				return false;
			}
			catch (const std::exception& e)
			{
				MessageBoxA(nullptr, e.what(), "Error", MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);
				return false;
			}

			return true;
		}();

		return res;
	}

	bool post_load()
	{
		static auto res = []
		{
			try
			{
				for (const auto& component : get_components())
				{
					component->post_load();
				}
			}
			catch (premature_shutdown_trigger&)
			{
				return false;
			}
			catch (const std::exception& e)
			{
				MessageBoxA(nullptr, e.what(), "Error", MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);
				return false;
			}

			return true;
		}();

		return res;
	}

	void post_unpack()
	{
		static auto res = []
		{
			try
			{
				for (const auto& component : get_components())
				{
					component->post_unpack();
				}
			}
			catch (const std::exception& e)
			{
				MessageBoxA(nullptr, e.what(), "Error", MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);
				return false;
			}

			return true;
		}();

		if (!res)
		{
			TerminateProcess(GetCurrentProcess(), 1);
		}
	}

	void pre_destroy()
	{
		static auto res = []
		{
			try
			{
				for (const auto& component : get_components())
				{
					component->pre_destroy();
				}
			}
			catch (const std::exception& e)
			{
				MessageBoxA(nullptr, e.what(), "Error", MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);
				return false;
			}

			return true;
		}();

		if (!res)
		{
			TerminateProcess(GetCurrentProcess(), 1);
		}
	}

	void trigger_premature_shutdown()
	{
		throw premature_shutdown_trigger();
	}
}

```

`src/client/loader/component_loader.hpp`:

```hpp
#pragma once
#include "component_interface.hpp"

namespace component_loader
{
	using registration_functor = std::function<std::unique_ptr<generic_component>()>;

	void register_component(registration_functor functor, component_type type);

	bool activate(bool server);
	bool post_load();
	void post_unpack();
	void pre_destroy();

	[[noreturn]] void trigger_premature_shutdown();

	class premature_shutdown_trigger final : public std::exception
	{
		[[nodiscard]] const char* what() const noexcept override
		{
			return "Premature shutdown requested";
		}
	};

	template <typename T>
	class installer final
	{
		static_assert(std::is_base_of_v<generic_component, T>, "component has invalid base class");

	public:
		installer()
		{
			register_component([]
			{
				return std::make_unique<T>();
			}, T::type);
		}
	};
};

#define REGISTER_COMPONENT(name)                          \
namespace                                                 \
{                                                         \
	static component_loader::installer<name> __component; \
}

```

`src/client/loader/loader.cpp`:

```cpp
#include <std_include.hpp>
#include "loader.hpp"
#include "tls.hpp"

#include <utils/hook.hpp>
#include <utils/string.hpp>

namespace loader
{
	namespace
	{
		template <typename T>
		T offset_pointer(void* data, const ptrdiff_t offset)
		{
			return reinterpret_cast<T>(reinterpret_cast<uintptr_t>(data) + offset);
		}

		void load_imports(const utils::nt::library& target)
		{
			const auto* const import_directory = &target.get_optional_header()->DataDirectory[
				IMAGE_DIRECTORY_ENTRY_IMPORT];

			auto* descriptor = PIMAGE_IMPORT_DESCRIPTOR(target.get_ptr() + import_directory->VirtualAddress);

			while (descriptor->Name)
			{
				std::string name = LPSTR(target.get_ptr() + descriptor->Name);

				auto* name_table_entry = reinterpret_cast<uintptr_t*>(target.get_ptr() + descriptor->
					OriginalFirstThunk);
				auto* address_table_entry = reinterpret_cast<uintptr_t*>(target.get_ptr() + descriptor->FirstThunk);

				if (!descriptor->OriginalFirstThunk)
				{
					name_table_entry = reinterpret_cast<uintptr_t*>(target.get_ptr() + descriptor->FirstThunk);
				}

				while (*name_table_entry)
				{
					FARPROC function = nullptr;
					std::string function_name;
					const char* function_procname;

					if (IMAGE_SNAP_BY_ORDINAL(*name_table_entry))
					{
						function_name = "#" + std::to_string(IMAGE_ORDINAL(*name_table_entry));
						function_procname = MAKEINTRESOURCEA(IMAGE_ORDINAL(*name_table_entry));
					}
					else
					{
						const auto* import = PIMAGE_IMPORT_BY_NAME(target.get_ptr() + *name_table_entry);
						function_name = import->Name;
						function_procname = function_name.data();
					}

					auto library = utils::nt::library::load(name);
					if (library)
					{
						function = GetProcAddress(library, function_procname);
					}

					if (!function)
					{
						throw std::runtime_error(utils::string::va("Unable to load import '%s' from library '%s'",
						                                           function_name.data(), name.data()));
					}

					utils::hook::set(address_table_entry, reinterpret_cast<uintptr_t>(function));

					name_table_entry++;
					address_table_entry++;
				}

				descriptor++;
			}
		}

		void load_relocations(const utils::nt::library& target)
		{
			if (!utils::nt::is_wine())
			{
				return;
			}

			auto* current_base = target.get_ptr();
			const auto initial_base = target.get_optional_header()->ImageBase;
			const auto delta = reinterpret_cast<ptrdiff_t>(current_base) - initial_base;

			PIMAGE_DATA_DIRECTORY directory = &target.get_optional_header()->DataDirectory[
				IMAGE_DIRECTORY_ENTRY_BASERELOC];
			if (directory->Size == 0)
			{
				return;
			}

			auto* relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(current_base + directory->VirtualAddress);
			while (relocation->VirtualAddress > 0)
			{
				unsigned char* dest = current_base + relocation->VirtualAddress;

				auto* rel_info = offset_pointer<uint16_t*>(relocation, sizeof(IMAGE_BASE_RELOCATION));
				const auto* rel_info_end = offset_pointer<uint16_t*>(
					rel_info, relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION));

				for (; rel_info < rel_info_end; ++rel_info)
				{
					const int type = *rel_info >> 12;
					const int offset = *rel_info & 0xfff;

					switch (type)
					{
					case IMAGE_REL_BASED_ABSOLUTE:
						break;

					case IMAGE_REL_BASED_HIGHLOW:
					{
						auto* patch_address = reinterpret_cast<DWORD*>(dest + offset);
						utils::hook::set(patch_address, *patch_address + static_cast<DWORD>(delta));
						break;
					}

					case IMAGE_REL_BASED_DIR64:
					{
						auto* patch_address = reinterpret_cast<ULONGLONG*>(dest + offset);
						utils::hook::set(patch_address, *patch_address + static_cast<ULONGLONG>(delta));
						break;
					}

					default:
						throw std::runtime_error("Unknown relocation type: " + std::to_string(type));
					}
				}

				relocation = offset_pointer<PIMAGE_BASE_RELOCATION>(relocation, relocation->SizeOfBlock);
			}
		}

		void load_tls(const utils::nt::library& target)
		{
			if (target.get_optional_header()->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size)
			{
				auto* target_tls = tls::allocate_tls_index();
				const auto* const source_tls = reinterpret_cast<PIMAGE_TLS_DIRECTORY>(target.get_ptr() + target.
					get_optional_header()
					->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);

				auto* target_tls_start = PVOID(target_tls->StartAddressOfRawData);
				auto* tls_start = PVOID(source_tls->StartAddressOfRawData);
				const auto tls_size = source_tls->EndAddressOfRawData - source_tls->StartAddressOfRawData;
				const auto tls_index = *reinterpret_cast<DWORD*>(target_tls->AddressOfIndex);

				utils::hook::set<DWORD>(source_tls->AddressOfIndex, tls_index);

				if (target_tls->AddressOfCallBacks)
				{
					utils::hook::set<void*>(target_tls->AddressOfCallBacks, nullptr);
				}

				DWORD old_protect;
				VirtualProtect(target_tls_start, tls_size, PAGE_READWRITE, &old_protect);

				auto* const tls_base = *reinterpret_cast<LPVOID*>(__readgsqword(0x58) + 8ull * tls_index);
				std::memmove(tls_base, tls_start, tls_size);
				std::memmove(target_tls_start, tls_start, tls_size);

				VirtualProtect(target_tls, sizeof(*target_tls), PAGE_READWRITE, &old_protect);
				*target_tls = *source_tls;
			}
		}
	}

	utils::nt::library load_binary(const std::string& filename)
	{
		const auto target = utils::nt::library::load(filename);
		if (!target)
		{
			throw std::runtime_error{"Failed to map: " + filename};
		}

		load_relocations(target);
		load_imports(target);
		load_tls(target);

		return target;
	}
}

```

`src/client/loader/loader.hpp`:

```hpp
#pragma once
#include <utils/nt.hpp>

namespace loader
{
	utils::nt::library load_binary(const std::string& filename);
}

```

`src/client/loader/tls.cpp`:

```cpp
#include <std_include.hpp>
#include "tls.hpp"

#include <utils/nt.hpp>
#include <utils/binary_resource.hpp>

#include "resource.hpp"

namespace tls
{
	namespace
	{
		utils::binary_resource tls_dll_file(TLS_DLL, "boiii-tlsdll.dll");
	}

	PIMAGE_TLS_DIRECTORY allocate_tls_index()
	{
		static auto already_allocated = false;
		if (already_allocated)
		{
			throw std::runtime_error("Currently only a single allocation is supported!");
		}

		already_allocated = true;

		const auto dll_path = tls_dll_file.get_extracted_file();
		const auto tls_dll = utils::nt::library::load(dll_path);
		if (!tls_dll)
		{
			throw std::runtime_error("Failed to load TLS DLL");
		}

		const auto tls_dir_entry = tls_dll.get_optional_header()
		                                  ->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
		if (!tls_dir_entry)
		{
			throw std::runtime_error("TLS DLL is invalid");
		}

		return reinterpret_cast<PIMAGE_TLS_DIRECTORY>(tls_dll.get_ptr() + tls_dir_entry);
	}
}

```

`src/client/loader/tls.hpp`:

```hpp
#pragma once

namespace tls
{
	PIMAGE_TLS_DIRECTORY allocate_tls_index();
}

```

`src/client/main.cpp`:

```cpp
#include <std_include.hpp>

#include "loader/component_loader.hpp"
#include "loader/loader.hpp"

#include <utils/finally.hpp>
#include <utils/hook.hpp>
#include <utils/nt.hpp>
#include <utils/io.hpp>
#include <utils/flags.hpp>

#include <steam/steam.hpp>

#include "game/game.hpp"
#include "launcher/launcher.hpp"

namespace
{
	volatile bool g_call_tls_callbacks = false;
	std::pair<void**, void*> g_original_import{};

	DECLSPEC_NORETURN void WINAPI exit_hook(const uint32_t code)
	{
		component_loader::pre_destroy();
		ExitProcess(code);
	}

	std::pair<void**, void*> patch_steam_import(const std::string& func, void* function)
	{
		static const utils::nt::library game{};

		const auto game_entry = game.get_iat_entry("steam_api64.dll", func);
		if (!game_entry)
		{
			//throw std::runtime_error("Import '" + func + "' not found!");
			return {nullptr, nullptr};
		}

		const auto original_import = game_entry;
		utils::hook::set(game_entry, function);
		return {game_entry, original_import};
	}

	bool restart_app_if_necessary_stub()
	{
		const std::string steam_path = steam::SteamAPI_GetSteamInstallPath();
		if (steam_path.empty() || !::utils::io::file_exists(steam_path + "/steam.exe"))
		{
			MessageBoxA(nullptr, "Steam must be installed for the game to run. Please install Steam!", "Error",
			            MB_ICONERROR);
			ShellExecuteA(nullptr, "open", "https://store.steampowered.com/about/", nullptr, nullptr, SW_SHOWNORMAL);
			TerminateProcess(GetCurrentProcess(), 1);
		}

		utils::hook::set(g_original_import.first, g_original_import.second);
		patch_steam_import("SteamAPI_Shutdown", steam::SteamAPI_Shutdown);

		component_loader::post_unpack();
		return steam::SteamAPI_RestartAppIfNecessary();
	}

	BOOL set_process_dpi_aware_stub()
	{
		component_loader::post_unpack();
		return SetProcessDPIAware();
	}

	void patch_imports()
	{
		patch_steam_import("SteamAPI_RegisterCallback", steam::SteamAPI_RegisterCallback);
		patch_steam_import("SteamAPI_RegisterCallResult", steam::SteamAPI_RegisterCallResult);
		patch_steam_import("SteamGameServer_Shutdown", steam::SteamGameServer_Shutdown);
		patch_steam_import("SteamGameServer_RunCallbacks", steam::SteamGameServer_RunCallbacks);
		patch_steam_import("SteamGameServer_GetHSteamPipe", steam::SteamGameServer_GetHSteamPipe);
		patch_steam_import("SteamGameServer_GetHSteamUser", steam::SteamGameServer_GetHSteamUser);
		patch_steam_import("SteamInternal_GameServer_Init", steam::SteamInternal_GameServer_Init);
		patch_steam_import("SteamAPI_UnregisterCallResult", steam::SteamAPI_UnregisterCallResult);
		patch_steam_import("SteamAPI_UnregisterCallback", steam::SteamAPI_UnregisterCallback);
		patch_steam_import("SteamAPI_RunCallbacks", steam::SteamAPI_RunCallbacks);
		patch_steam_import("SteamInternal_CreateInterface", steam::SteamInternal_CreateInterface);
		patch_steam_import("SteamAPI_GetHSteamUser", steam::SteamAPI_GetHSteamUser);
		patch_steam_import("SteamAPI_GetHSteamPipe", steam::SteamAPI_GetHSteamPipe);
		patch_steam_import("SteamAPI_Init", steam::SteamAPI_Init);
		//patch_steam_import("SteamAPI_Shutdown", steam::SteamAPI_Shutdown);
		g_original_import = patch_steam_import("SteamAPI_RestartAppIfNecessary", restart_app_if_necessary_stub);

		const utils::nt::library game{};
		utils::hook::set(game.get_iat_entry("kernel32.dll", "ExitProcess"), exit_hook);
		utils::hook::set(game.get_iat_entry("user32.dll", "SetProcessDPIAware"), set_process_dpi_aware_stub);
	}

	void remove_crash_file()
	{
		const utils::nt::library game{};
		const auto game_file = game.get_path();
		auto game_path = std::filesystem::path(game_file);
		game_path.replace_extension(".start");

		utils::io::remove_file(game_path);
	}

	PIMAGE_TLS_CALLBACK* get_tls_callbacks()
	{
		const utils::nt::library game{};
		const auto& entry = game.get_optional_header()->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
		if (!entry.VirtualAddress || !entry.Size)
		{
			return nullptr;
		}

		const auto* tls_dir = reinterpret_cast<IMAGE_TLS_DIRECTORY*>(game.get_ptr() + entry.VirtualAddress);
		return reinterpret_cast<PIMAGE_TLS_CALLBACK*>(tls_dir->AddressOfCallBacks);
	}

	void run_tls_callbacks(const DWORD reason)
	{
		if (!g_call_tls_callbacks)
		{
			return;
		}

		auto* callback = get_tls_callbacks();
		while (callback && *callback)
		{
			(*callback)(GetModuleHandleA(nullptr), reason, nullptr);
			++callback;
		}
	}

	[[maybe_unused]] thread_local struct tls_runner
	{
		tls_runner()
		{
			run_tls_callbacks(DLL_THREAD_ATTACH);
		}

		~tls_runner()
		{
			run_tls_callbacks(DLL_THREAD_DETACH);
		}
	} tls_runner;

	FARPROC load_process(const std::string& procname)
	{
		const auto proc = loader::load_binary(procname);

		auto* const peb = reinterpret_cast<PPEB>(__readgsqword(0x60));
		peb->Reserved3[1] = proc.get_ptr();
		static_assert(offsetof(PEB, Reserved3[1]) == 0x10);

		return FARPROC(proc.get_ptr() + proc.get_relative_entry_point());
	}

	bool handle_process_runner()
	{
		const auto* const command = "-proc ";
		const char* parent_proc = strstr(GetCommandLineA(), command);

		if (!parent_proc)
		{
			return false;
		}

		const auto pid = DWORD(atoi(parent_proc + strlen(command)));
		const utils::nt::handle<> process_handle = OpenProcess(SYNCHRONIZE, FALSE, pid);
		if (process_handle)
		{
			WaitForSingleObject(process_handle, INFINITE);
		}

		return true;
	}

	void enable_dpi_awareness()
	{
		const utils::nt::library user32{"user32.dll"};

		{
			const auto set_dpi = user32
				                     ? user32.get_proc<BOOL(WINAPI*)(DPI_AWARENESS_CONTEXT)>(
					                     "SetProcessDpiAwarenessContext")
				                     : nullptr;
			if (set_dpi)
			{
				set_dpi(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
				return;
			}
		}

		{
			const utils::nt::library shcore{"shcore.dll"};
			const auto set_dpi = shcore
				                     ? shcore.get_proc<HRESULT(WINAPI*)(PROCESS_DPI_AWARENESS)>(
					                     "SetProcessDpiAwareness")
				                     : nullptr;
			if (set_dpi)
			{
				set_dpi(PROCESS_PER_MONITOR_DPI_AWARE);
				return;
			}
		}

		{
			const auto set_dpi = user32
				                     ? user32.get_proc<BOOL(WINAPI*)()>(
					                     "SetProcessDPIAware")
				                     : nullptr;
			if (set_dpi)
			{
				set_dpi();
			}
		}
	}

	int main()
	{
		if (handle_process_runner())
		{
			return 0;
		}

		FARPROC entry_point{};
		srand(uint32_t(time(nullptr)) ^ ~(GetTickCount() * GetCurrentProcessId()));

		enable_dpi_awareness();

		{
			auto premature_shutdown = true;
			const auto _ = utils::finally([&premature_shutdown]
			{
				if (premature_shutdown)
				{
					component_loader::pre_destroy();
				}
			});

			try
			{
				remove_crash_file();

				const auto client_binary = "BlackOps3.exe"s;
				const auto server_binary = "BlackOps3_UnrankedDedicatedServer.exe"s;

				const auto has_client = utils::io::file_exists(client_binary);
				const auto has_server = utils::io::file_exists(server_binary);

				const auto is_server = utils::flags::has_flag("dedicated") || (!has_client && has_server);

				if (!is_server && !launcher::run())
				{
					return 0;
				}

				if (!component_loader::activate(is_server))
				{
					return 1;
				}

				entry_point = load_process(is_server ? server_binary : client_binary);
				if (!entry_point)
				{
					throw std::runtime_error("Unable to load binary into memory");
				}

				if (is_server != game::is_server())
				{
					throw std::runtime_error("Bad binary loaded into memory");
				}

				patch_imports();

				if (!component_loader::post_load())
				{
					return 1;
				}

				premature_shutdown = false;
			}
			catch (std::exception& e)
			{
				MessageBoxA(nullptr, e.what(), "ERROR", MB_ICONERROR | MB_SETFOREGROUND | MB_TOPMOST);
				return 1;
			}
		}

		g_call_tls_callbacks = true;
		return static_cast<int>(entry_point());
	}
}

int __stdcall WinMain(HINSTANCE, HINSTANCE, PSTR, int)
{
	return main();
}

```

`src/client/resource.hpp`:

```hpp
#pragma once

#define ID_ICON               102
#define IMAGE_SPLASH          300

#define IMAGE_LOGO            301

#define DW_MOTD               302
#define DW_CARDS              303
#define DW_PLAYLISTS          304
#define DW_FASTFILE           305
#define DW_KEYS               306
#define DW_QOSCONFIG          307

#define TLS_DLL               308
#define MENU_MAIN             309

```

`src/client/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "windows.h"
#include "version.h"
#include "resource.hpp"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "#include ""windows.h""\r\n"
    "\0"
END

2 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_FILE_RC
 PRODUCTVERSION VERSION_PRODUCT_RC
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
#ifdef PRERELEASE
 FILEFLAGS VS_FF_PRERELEASE
#else
#ifndef CI
 FILEFLAGS VS_FF_PRIVATEBUILD
#else
 FILEFLAGS 0x0L
#endif
#endif
#endif
 FILEOS 0x40004L
 FILETYPE VFT_DLL
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "momo5502"
            VALUE "FileDescription", "BOIII"
            VALUE "FileVersion", VERSION_FILE
            VALUE "InternalName", "something"
            VALUE "LegalCopyright", "Copyright (C) 2022 momo5502. All rights reserved."
            VALUE "OriginalFilename", "boiii.exe"
            VALUE "ProductName", "BOIII"
            VALUE "ProductVersion", VERSION_PRODUCT
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

/////////////////////////////////////////////////////////////////////////////
//
// Binary Data
//

ID_ICON               ICON   "resources/icon.ico"
IMAGE_SPLASH          RCDATA "resources/splash.jpg"
IMAGE_LOGO            RCDATA "resources/logo.jpg"

DW_MOTD               RCDATA "resources/dw/experiments_tu32.gz"
DW_CARDS              RCDATA "resources/dw/featured_cards-english_tu32.gz"
DW_PLAYLISTS          RCDATA "resources/dw/playlists_tu32.gz"
DW_FASTFILE           RCDATA "resources/dw/core_ffotd_tu32_593.ff"
DW_KEYS               RCDATA "resources/dw/keys.txt"
DW_QOSCONFIG          RCDATA "resources/dw/qosconfig4.csv"

MENU_MAIN             RCDATA "resources/main.html"

#ifdef _DEBUG
TLS_DLL               RCDATA "../../build/bin/x64/Debug/tlsdll.dll"
#else
TLS_DLL               RCDATA "../../build/bin/x64/Release/tlsdll.dll"
#endif

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`src/client/resources/dw/experiments_tu32.gz`:

```gz
{
	"version": 1,
	"enabled": true,
	"usertype": 0,
	"experiment_data": 
	[
		{
			"enabled": false,
			"name": "sv_lootxp_rate",
			"variants": [
				{	
					"include_rate": 7000
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}
			]
		}, {
			"enabled": false,
			"name": "cl_playlist_order",
			"variants": [
				{
					"include_rate": 5000
				}, {
					"include_rate": 2500
				}
			]
		}, {
			"enabled": true,
			"name": "jul_2017_sales",
			"variants": [
				{
					"include_rate": 5000
				}, {
					"include_rate": 2000
				}, {
					"include_rate": 1000
				}, {
					"include_rate": 1000
				}, {
					"include_rate": 1000
				}
			]
		}, {
			"enabled": true,
			"name": "jul_2017_small",
			"variants": [
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				}
			]
		} , {
			"enabled": false,
			"name": "com_test_exp",
			"variants": [
				{
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}, {
					"include_rate": 500
				}
			]
		} , {
			"enabled": false,
			"name": "chris_exp",
			"variants": [
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				}
			]
		}, {
			"enabled": false,
			"name": "chris_variable_discount",
			"variants": [
				{
					"include_rate": 2500
				},
				{
					"include_rate": 2500
				},
				{
					"include_rate": 2500
				},
				{
					"include_rate": 2500
				}
			]
		}, {
			"enabled": false,
			"name": "no_dupe_preview",
			"variants": [
				{
					"include_rate": 5000
				},
				{
					"include_rate": 5000
				}
			]
		}, {
			"enabled": false,
			"name": "bonus_crypto",
			"variants": [
				{
					"include_rate": 2500
				},
				{
					"include_rate": 2500
				},
				{
					"include_rate": 2500
				},
				{
					"include_rate": 2500
				}
			]
		}, {
			"enabled": true,
			"name": "threepack_exp",
			"variants": [
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				}
			]
		},{
			"enabled": true,
			"name": "dec_2017_bribe",
			"variants": [
				{
					"include_rate": 2000
				},
				{
					"include_rate": 2000
				},
				{
					"include_rate": 2000
				},
				{
					"include_rate": 2000
				},
				{
					"include_rate": 2000
				}
			]
		},{
			"enabled": true,
			"name": "zm_PlayerMessage",
			"variants": [
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				}
			]
		}, {
			"enabled": true,
			"name": "ui_purchase_experiment",
			"variants": [
				{
					"include_rate": 5000
				},
				{
					"include_rate": 5000
				}
			]
		}, {
			"enabled": true,
			"name": "store_image_experiment",
			"variants": [
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				}
			]
		}, {
			"enabled": true,
			"name": "igs_bonus_image_experiment",
			"variants": [
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				}
			]
		},{
			"enabled": true,
			"name": "bundle_and_bribe_experiment",
			"variants": [
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				}
			]
		},{
			"enabled": true,
			"name": "most_popular_banner_experiment",
			"variants": [
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				},
				{
					"include_rate": 1000
				}
			]
		},{
			"enabled": true,
			"name": "outfit_purchase_experiment",
			"variants": [
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				},
				{
					"include_rate": 500
				}
			]
		}
	]
}

```

`src/client/resources/dw/featured_cards-english_tu32.gz`:

```gz
{
    "version": 1,
    "enabled": true,
    "cards_count": 5,
    "timer": 5000,
    "data": [
        {
            "priority": "1",
            "type": "crm",
            "title": "TEMP TITLE",
            "action_title": "Open",
            "action": "opencrm",
            "bg": "t7_store_featured_message"
		},
		{
            "priority": "2",
            "type": "crm",
            "title": "TEMP TITLE",
            "action_title": "Open",
            "action": "opencrm",
            "bg": "t7_store_featured_message"
		},
				{
            "priority": "3",
            "type": "crm",
            "title": "TEMP TITLE",
            "action_title": "Open",
            "action": "opencrm",
            "bg": "t7_store_featured_message"
		},
				{
            "priority": "4",
            "type": "crm",
            "title": "TEMP TITLE",
            "action_title": "Open",
            "action": "opencrm",
            "bg": "t7_store_featured_message"
		},
		{
            "priority": "5",
            "type": "motd",
            "title": "MESSAGE OF THE DAY",
            "action_title": "Open",
            "action": "openmotd",
            "bg": "t7_store_featured_message"
        }
    ]
}
```

`src/client/resources/dw/keys.txt`:

```txt
mp_common,2zHsXiiL7dpHe7pUOZqqxjtDtkfaoYgIFnc/fVz9Jfo=
cp_common,1GoG6tjnsFjTcHE3yWfJHn2zmSCmxc8AL2uQA1fAGTY=
zm_common,YGAA71wQIOGoyAjscRM4P1A7do+l84Ui8ED5GXJ+f0w=
mp_spire,OIT7ejI6w3koGyKkABwDXA1+8nzUaxeOmj8/vdkHoNU=
bp_core_ffotd_tu20_593,k1rErT45AcPsp/X2Fb3XyecqGzU+9rU8DZAc2ARYv6I=
bp_core_ffotd_tu21_593,idINeSf8HKgiPPrLHqQtl8yuh+zxzxekAeac7vXuljo=
bp_core_ffotd_tu22_593,t3XlDqMapx+xrakFcLiIjg1KGbZLTkw0o3KyaDjyM4Q=
bp_core_ffotd_tu23_593,MwXJ6KQq2r40Wsxqet1CrYrzJeRWZPMAP2zCwSSjI08=
bp_core_ffotd_tu24_593,t41jayGQ1cUgjWECx8l5f2euf2u2/HIZyGqQB2l40Ok=
bp_core_ffotd_tu25_593,m4ERIuZaHUmkfoXBkBjBVQ00AgOefAbuRunlVtBISUk=
bp_core_ffotd_tu26_593,A8JCiSVWyJc/35m6mcabprbuTdOOjtGvGxfJYFlkDHk=
bp_core_ffotd_tu27_593,iQzOzdKNw3IYtUKv3dXWkm33bVo5u7eCgnKW2Iy1iYo=
bp_core_ffotd_tu28_593,1v8sGl4FTfJx8EfeQt3iPCiCG+YeTcyxe8/WFKvvlD4=
bp_core_ffotd_tu29_593,ImR+5BsZe6zwNGqu8O8otwOo71Le+XhsB/fR9Xq5ue0=
bp_core_ffotd_tu30_593,mci7fn1K4Lg7QUdVOtfM6/rWLhhVdMdj7F/6cg+zasc=
bp_core_ffotd_tu31_593,kfbBj/WAe3YSAzvkJeiSh/pJ5Ay/ygCVeTNgqVC0O7w=
bp_core_ffotd_tu32_593,6auAetFAnMPVKzXZyipymA36rMzGBJhshyh0KPTlykQ=
bp_core_ffotd_tu33_593,gPy20XN1WDkcFPDkzS9iPxRokCOUWt1gAKbofJ9NPA0=
bp_core_ffotd_tu34_593,1xooskJgK309EQ+HHZXQ46mLQOOyzfBd2G6nfjURl3g=
bp_core_ffotd_tu35_593,jtPrpobPgu+z0mMedlP91sFuLThFGL7drHuDtZSo4eY=
bp_core_ffotd_tu36_593,H3elGM02IPkSk3F+zW85WZxPzJZcH/cEhVx4NNJ9080=
bp_core_ffotd_tu37_593,qDobDHPReElOJHz5N7iSZb1Qcw7oQKoSinTN12OoIs8=
bp_core_ffotd_tu38_593,5dZBP8uz/B1THb85Or66oiTE8YdvcQ6i2ZZNLY4opzA=
bp_core_ffotd_tu39_593,JlHlwpVd5Xb8P6Kbr0OB/Kwzkc7gaC8jdm+uTZdfVeo=
ea_core_ffotd_tu20_593,OauwPf5jGf2adD7FjlSiNBbCqoe2GokRQIewSPtfvHQ=
ea_core_ffotd_tu21_593,g+jENvR8UXCn8l0o3cDN2ks6PEFJ8LoHNXfo2aOZUgw=
ea_core_ffotd_tu22_593,e8wm/bCErZ/H1tQvPHnAMro0c2PBqLd3VqnVuIM0/8I=
ea_core_ffotd_tu23_593,BARKGY7hboMl6uUXFV00Mt8fGpwy0R5hHZ1HXOLe2LQ=
ea_core_ffotd_tu24_593,lWU2pm4OKN+CZr9yaDJJZaE27R/Dts4h1C4RWsFtr54=
ea_core_ffotd_tu25_593,yGxxDBBBGDL6ISUQZjddmBZ7DOsdyJjnY2LulqlZ2i8=
ea_core_ffotd_tu26_593,MZS49pCKVTJUOSuXPr/Y6UX3qNHySnqsc/ZE9MRAoFM=
ea_core_ffotd_tu27_593,fcnTNHhTfziRusF43zJshMeEJnzgFfrGXMUQ/Zpw6uc=
ea_core_ffotd_tu28_593,GZGwtAV3yoS/vhudNAlrxix3GHR2FLx+IxOr748E1CY=
ea_core_ffotd_tu29_593,OmIdDHxwK03VtphdS005ytRe3iQenloJk3Ge2zp3xX4=
ea_core_ffotd_tu30_593,LuZFoeCeZibZBefzOkQh57zww8nXXyjTgHGBh0K7hkw=
ea_core_ffotd_tu31_593,R/IxT5x7kIJ9wS6eIFv7SGr37kZ9ZbXryHuNC/eqqyA=
ea_core_ffotd_tu32_593,/s4S7XFZRmblvus0Gndrd1Z1QdPVNDPHj+lU1dVrqd0=
ea_core_ffotd_tu33_593,bdkrwbj+EwUIeynHu3YAOMlWMumU7Cdjw/0VRupzvOs=
ea_core_ffotd_tu34_593,6ykl5N85kBO7QpKdi3neM8njeNOrS0lFQLvv8EzDJfs=
ea_core_ffotd_tu35_593,mnDwB9ePCcPp1LFk3Kkt6BHi+x2r7uxPm8R/Pq+RhbI=
ea_core_ffotd_tu36_593,R0G4+ZgqWLRlTXSlQWXuOsbDoaa/bniGJThB3SLI3Ew=
ea_core_ffotd_tu37_593,d50uwoVXn+sUTSYSUdcUUTZVVGwqRW2JZvz18JuJ2/w=
ea_core_ffotd_tu38_593,32VHpaXCatX7EosdqkGGJ4ebrq/sRu/AuG/Mw0/8T3A=
ea_core_ffotd_tu39_593,8nnHjyYqEtNhfwIdL3gOycc+FTSyG3zKe3qbhzxOu+Q=
en_core_ffotd_tu20_593,0/UQSC2RiS5vW4vbTknH6ejn8/3W4ko/Et4kCygXxK0=
en_core_ffotd_tu21_593,eTdZS0NqA9P0fivfcjKFzMXSDaD6aahGe0BkldUw388=
en_core_ffotd_tu22_593,UJ3JISOsKIqEUWKdxqhiQarKUAxfWbOpJeA27ByM4I8=
en_core_ffotd_tu23_593,1okZhBx5GTz7QvEXpRTXt8Y0Gs4XtFkigW8QHAr6nuQ=
en_core_ffotd_tu24_593,1BwyBoWi04HPBISCnq7dgJ+t6qywmmbDGM4/9TPvtiw=
en_core_ffotd_tu25_593,Z75tTZqJ6wLGk8W/qbyD6dKdVLdmezNQUMwzdAYgEaM=
en_core_ffotd_tu26_593,ADPFNIFTfsB2/M0VK0vWHcGeoGGTORrkpBiF4XdLwz8=
en_core_ffotd_tu27_593,r6KNbvTQr6Y/joI5B1GsfscqRBYg4qIufkjCZxXFnwI=
en_core_ffotd_tu28_593,np7IHjP1ESFGHGRfRYMm0yaqy8eeSefIjXTIR5O7XC0=
en_core_ffotd_tu29_593,yqmx8+7IO7jz+RGp/ULP2ZxY5KUuZFQxCrqvwzPoeRw=
en_core_ffotd_tu30_593,uT2FBjk7fxNOoHMgZ92tOQX+NmcNsCBBihAMu4JL0Gs=
en_core_ffotd_tu31_593,MEsNq6yqDE2CIezdiknXOW51IqGtg1Ch3MdYCkOe74I=
en_core_ffotd_tu32_593,t3dNl9hqAT5gN4+6RzER7VCtTU8TceDVDa5rQdCp4/Y=
en_core_ffotd_tu33_593,HI8uXbfMuWf7sZy3F4GWGhVippSHvkBYGjCK3I3dhLA=
en_core_ffotd_tu34_593,jh3U6YxM2wmk25i8BLUjOE1h/5z0Kr9XiyDwsvJr8yM=
en_core_ffotd_tu35_593,6XkuU+G7Yj2M0r7tjvh1rUs5OngE6rDuUAuIaoYeAHs=
en_core_ffotd_tu36_593,+4SOfSlC+D+am2frJdN7zC5tdau5X3hoAMOU1H07y9c=
en_core_ffotd_tu37_593,Kb4pNY+OWxGlm7uZT8VZvqjxI6eoZ1D5FDlICfDEPNM=
en_core_ffotd_tu38_593,ljrgg54mGy/s8+2hozavMM4nQ/ndgZiIljvP4D2JdGw=
en_core_ffotd_tu39_593,axgejGkerjZBDPnB4vnsW+nslHy25LjHp+aCeZVK1c0=
es_core_ffotd_tu20_593,DQWEjTlhyaKpVLomO+c7ffK9XfEylM0FhQGzKKYOFs8=
es_core_ffotd_tu21_593,zEr3OFcWZxjACy5q7XOl0NryLsvkxUUh0BgoUQ2OKGE=
es_core_ffotd_tu22_593,JfQouJRXoc4uuclTVoZC2t0VOGkRA08as+ox6H5WJCA=
es_core_ffotd_tu23_593,S+h4iABr7iONWYYCsn49K9EQZDSklgxuRV0PHVlTniI=
es_core_ffotd_tu24_593,wpDFkAoDkCIXKZ1mr8owUcRGSSCsl1YahTh6Nfbkdf0=
es_core_ffotd_tu25_593,xpIj97bPY1Unmmi3W+mth8khSmq2uxu37wA5c7uneZ4=
es_core_ffotd_tu26_593,X91vfUF5yVowvrKAutBeeehh2yapPZ8ZgiXlW+i8MXc=
es_core_ffotd_tu27_593,+32vCXSY9Hi66+/Ksq5TXyqyHTYhgUpXbhejrGdTIM4=
es_core_ffotd_tu28_593,miYVjHtgHl3KuRCnW1D0Lyqdf4Q8AfseM7cE6ELWZ+A=
es_core_ffotd_tu29_593,JmjNC6pYQOjNY+yS3leGtdcaTa3y9fS/kMW/SsoXa5U=
es_core_ffotd_tu30_593,PC4Iion3OODhNyA7D2bRfJ/IOshE8kGF6U9Y9HWJin0=
es_core_ffotd_tu31_593,ieMrOzD1W5XoWWcSA+RmrUgrmGwetJtnUKc7nmtwKco=
es_core_ffotd_tu32_593,NQkV3yNWSvlDeuaJ1cRTK4BPSB4kvBAIY4nQf1ZQ5dk=
es_core_ffotd_tu33_593,lNkDeqa9BzQBQNMbEjKjEcrQ4FUOtO1uThIWpwkW5ao=
es_core_ffotd_tu34_593,YPdDKdhShR8pz9d7kpKfryDtiPIkHb25GV4YC5EXavs=
es_core_ffotd_tu35_593,3iE9H5FoNomnDGl5MYQJ31HPXyrSTU85c2/2uSd885I=
es_core_ffotd_tu36_593,jaywbb93sV9MaDCWnbG4vgYf+sXIkuniyWjO1qyDuQw=
es_core_ffotd_tu37_593,ntd56q70mvf4q5aT+eHwVVZ356vICFRiKshf3pMUS74=
es_core_ffotd_tu38_593,qNMdruzO5bcpKk0vrnkOpXZ69MpTdFaKR3b2+dlVUas=
es_core_ffotd_tu39_593,oPJm1DzbATn7jYP2osnpfVAsbMS/G1rpppmr/MyoyEA=
fr_core_ffotd_tu20_593,mC7xI/ZZ5puh4Mg/zXCpqcDjBLxUA8c6eHzV0Mu2jCM=
fr_core_ffotd_tu21_593,T7OPioxScCDUJj6BESI8wZFL5tFicWW0eiHrB8Bemwg=
fr_core_ffotd_tu22_593,BtbOrkEzTJx2Tt38XGDYt1vk5OKrLJNi+jNxndTa4JE=
fr_core_ffotd_tu23_593,DKwHvhe1wwKOQCSetnJbCUOBYQ0DtgV+WBKRsUYIge8=
fr_core_ffotd_tu24_593,s3+yY/QpXDiGtc7Vxj10Ow8o5gqBAyrYr/dR5+3lYr0=
fr_core_ffotd_tu25_593,HUUSsitDh67skv8AEhdmp6DmxUsGA3QG/5IYQ47mTnw=
fr_core_ffotd_tu26_593,4c5nSE41988i7M7O2aBVrOVKN0lQdpMhuLxKUKr8a3g=
fr_core_ffotd_tu27_593,ruMsUFejJQ6hYXD88E3s9l1kwiN2z4Uw5iwcpjyur5w=
fr_core_ffotd_tu28_593,Gs6JTY1qjkjnsTXKPqC5Vz2rYMBlzCawywe4RNFa/vQ=
fr_core_ffotd_tu29_593,OViRKkJ6qx0ByW65wc+ilQo7fSwDllicZ+XzA9XD1ZY=
fr_core_ffotd_tu30_593,TruZjK8D4ZGK9pz0nKYgX2vRnYY3+m7DWUErZCLmgbY=
fr_core_ffotd_tu31_593,ES96G3ptPUWH4FNKdpHz+gBvGZm9UOBgkrx+PdTtxuE=
fr_core_ffotd_tu32_593,9Gw3DlSQAKqBVkhGfVuclByq7Z+cO75Acj6aqNgKtoI=
fr_core_ffotd_tu33_593,k6EiO6KZNQJt3q9ul+4pUDkjYZF4L9kpK7rD8yJrQ3s=
fr_core_ffotd_tu34_593,J24sEpdS/kl9yyAVD9VkcmJ/4sfoEAWz/XB7AW+LMUc=
fr_core_ffotd_tu35_593,b4h14i78Aai1mWiCsh3H60szr4xdAnc7HyORXrSwGdU=
fr_core_ffotd_tu36_593,Zhk88QF8Dj9HeW3DVy94o/0bUlEJuWURdOjEwF9psIg=
fr_core_ffotd_tu37_593,BWxUMG5Bt/wmoMZBEsxWTi2j0cNchQWTWl8rgha/v8U=
fr_core_ffotd_tu38_593,IMzPvGM4/zS0RVElTDCvF9LZqvOljptck49mcEsVJa8=
fr_core_ffotd_tu39_593,/6iotcg5JeTL8oBY9UdP0FfY38LzY4nh0r0UMK51znE=
ge_core_ffotd_tu20_593,10ga3fW0Z3gzC2i8rq2tONBFMVyChiXfKIvH+GMKvGk=
ge_core_ffotd_tu21_593,RVtbI4tz63YtljRcxX38xCzEHa9awd8XG4jEgX+2vr8=
ge_core_ffotd_tu22_593,ZI7fxcuZ1dQLJgHcNi21mt0noBy1J/mn4SUt0rNOC5Y=
ge_core_ffotd_tu23_593,RUEs5Tcn57jlqqTuxE4wgA6IPG8A0MuRdNwHK00fopw=
ge_core_ffotd_tu24_593,GgM6u1uZAkm4oq6VyS6Mj5cbxuqCSOueTSKcOFCtE5I=
ge_core_ffotd_tu25_593,IHm/+QgR26/8qME9if7Q0YqQ1KKdeM/CffhK1GyOI8A=
ge_core_ffotd_tu26_593,9yfI4fazdLnsQb/Wg2pYkacJhPNe+TuEMVTOZrkxpJI=
ge_core_ffotd_tu27_593,fLX6HT1rRibA9L5/pZy3xIb69+9fwZ/TrrEwAGpKG4o=
ge_core_ffotd_tu28_593,hGi02v2zHUOiPeyMZ6sGkb0exmWwndpkiEVfXDpLTzw=
ge_core_ffotd_tu29_593,iSZsHOB8tID4PKrdQmU1+4GQ/kQzFEEM9mp9g7NKSRU=
ge_core_ffotd_tu30_593,DLZYyuULiHPEo0hjAj8mQuRF+4aG+PoJCY6w8Dtl/eg=
ge_core_ffotd_tu31_593,vr2qjS4u1MN+PHT28UVsP+9EQOh+CSOmIvrBS1Gjt2c=
ge_core_ffotd_tu32_593,B5qAXDSlMYMKuCMm+GNd3AJ8kI3GbuLl/ZM+HOj9iDI=
ge_core_ffotd_tu33_593,fPPEeMT0tzLLt/uC5WSJ6jLtY7TBRblfdOv/eDh5ztk=
ge_core_ffotd_tu34_593,FEWJJ/ikLA+05de2e8D+bwfpxLqbJB/ljEYauns+5pI=
ge_core_ffotd_tu35_593,7O3pCEOhSlGKF64ToZvfV0ksKPfNNkk9PWx7b+z6iNQ=
ge_core_ffotd_tu36_593,E7Ek22REoxWPAVTcOtHecBhmk3bx+NJEXeZEdXYiUA0=
ge_core_ffotd_tu37_593,qVUOr8sZ89+Rsg/D4y17M7LajPfTHzYkpyxC1atCvFY=
ge_core_ffotd_tu38_593,8DC81XOmsG6tnq+JcrRFUORuguroyLBEJVJMdg57tUI=
ge_core_ffotd_tu39_593,rSto/22REyFMF0PqWgL6W1EscvFeyJySeLsDXjshjUU=
it_core_ffotd_tu20_593,s8HtRgsyK+pm6uDSMkYvx3RMyXgCdiPQEIYLAj5RBqQ=
it_core_ffotd_tu21_593,hobQjDex8TMvGh0kB9MwP31CLTQCCpDYNXPhrqJH/1c=
it_core_ffotd_tu22_593,l/+hO+mEKAT99H3uvFRATo2iVZh35r44MJ38160pFEQ=
it_core_ffotd_tu23_593,2XdibvADY0q9iTPbHhee+fsaLjuuFIhxMdq+jWsikkg=
it_core_ffotd_tu24_593,KTvPbHUrXX+wENNclGk20VwOmMpvPoUfQ6iM1MAzoL0=
it_core_ffotd_tu25_593,yBmDQKz7ubTf+epefGSqdK/6/Gwdx0/bhZxk1iGl0jA=
it_core_ffotd_tu26_593,B8weoLRaqyuHmFsfN8poxNrAh4CPc+uRR/r1htyNxfE=
it_core_ffotd_tu27_593,fmaZTC2Q2M0Gs+72ZypknOELj/aegcYNuUgcDUk2kdQ=
it_core_ffotd_tu28_593,L2jBz7Bm3K/sQOMYgG/4tnxUikrgJmH+iDMZm8NKNHU=
it_core_ffotd_tu29_593,avCzYgHiRoKSa5oGXbidRFbYTMpyl+y7mvBTe1WTxNM=
it_core_ffotd_tu30_593,pYSSB+IPGKZ/EeIH0BqbCkvC9SibERuCW9C+SF6jdDo=
it_core_ffotd_tu31_593,S4uITgi8JeVxYRLcRIT5KVIcbN81S0JZ8mFiR4D6b+A=
it_core_ffotd_tu32_593,8c507AGKYtZYGncNyZswHyY29Lhv5NSRTRWtgaze6mo=
it_core_ffotd_tu33_593,QoEWoAbk/oXxl+gkGezNOk2QYqodejYjumjNpZN9oVQ=
it_core_ffotd_tu34_593,CrXS+2WaqHQZ0KQoZ8N925FYwZzxO0kb26RqDQFjlxc=
it_core_ffotd_tu35_593,fQ9PaGkmZHN1cKetqA1+Kq45wzLaTQxrYDj5MJZCAvc=
it_core_ffotd_tu36_593,UAgKnE/QbpfiBeILR6KwiAornH97914Ugq44kVw3HEI=
it_core_ffotd_tu37_593,bz14pCXF8SuuL99eXhNr6/xq0MipvBGaDnaKqAxOmrc=
it_core_ffotd_tu38_593,lb7kbHI+oIEe+r8kTs84visDeYtXmOVmA2O9SQZWSZk=
it_core_ffotd_tu39_593,OQeZIuKkAa5HldVU5ztgafiS/qdQlTYv1+Rg4NqpEEw=
ja_core_ffotd_tu20_593,/ZRlXEkEmWYydEaIghNJlk96u4b392PO4Eb3xyjRG3Q=
ja_core_ffotd_tu21_593,XhdECnhoNNPoPUpUqqFsI4oex0dEN8BoJmFlbIjsMGE=
ja_core_ffotd_tu22_593,7K5YUWRpKTLy03SyaLZ9HMvZZYnRw0NsrUILUiWcsRA=
ja_core_ffotd_tu23_593,Z1rCtmdUOw6D0vDV3GVTqbJekzojpfrktBn5qKFXmxA=
ja_core_ffotd_tu24_593,vu6UFlS1RsOfvC0LeZqlqK2Pr7shGFNUCr4jloasff0=
ja_core_ffotd_tu25_593,+AQgUJxD1meC32Bj0fEs+86/GG+7wCNSux6b303jM9g=
ja_core_ffotd_tu26_593,tXUyPatXYrosQ5eTdFDn9Ay5WBLsV7uCHjcWo7RtUro=
ja_core_ffotd_tu27_593,z5sfaZ0XMsLyUVzxZY1afl9ayInkhAo+ix7I8qY4sZI=
ja_core_ffotd_tu28_593,i+BSS9Q23p8zSvqdrg7rEO146ItW5kYRPqe5G5vCUm8=
ja_core_ffotd_tu29_593,piwy4mujXJ2ZLFZfKp5b9maT/wOyFa9Bm7DYv+Up/yM=
ja_core_ffotd_tu30_593,w7M27jET4lofgbK3tTPuw745eg9gCvjMskOIYOvQg8w=
ja_core_ffotd_tu31_593,4ivwUwojET1Xp25IuiHesJ1UF5giY20m4+VRCA8Cb3w=
ja_core_ffotd_tu32_593,nSLiBPgjYI1rcHzAeFgu0Fwohe1cszJSbnoMzgd12+w=
ja_core_ffotd_tu33_593,uxswsyVgE4hHf/FmqZef3BpHmEAibAClCms4h71w5MM=
ja_core_ffotd_tu34_593,iSeM+FkIUJU5lMs5MTWimBFpxbJ3Ctnat32LEx1PJyo=
ja_core_ffotd_tu35_593,spLzGConw5mhS33O4Ewvy0xdw+N6CoaAj+Wgscz7YWw=
ja_core_ffotd_tu36_593,Yb1uAMRHd5YxEnt5Y4xk+xr23xGNrdpa3Vi5srJAOvU=
ja_core_ffotd_tu37_593,Hro0qa0xjZchCQ1CB8ADSouK2rWDM3PkXTcFVA8YpMY=
ja_core_ffotd_tu38_593,DH4raExfEZQSXCZ+nA+Hw7qn0YQ/5D8PZamVkBu6cbI=
ja_core_ffotd_tu39_593,FiTVo5g+jeedEzZQj11VcedQ+E4xQFX0RhDLSgZq02g=
po_core_ffotd_tu20_593,6sf2RidHOnDWuVzG9O3e6uKOy3e4I4jeUhl5pIb6/AI=
po_core_ffotd_tu21_593,rdtNuZUl59vFxIiqd62x/kHNQsd5Otuhhcp+5euNjOM=
po_core_ffotd_tu22_593,53Hn3B7QwA40XFAnmQJBimm7zzxAt25cbuUvKnGo6/4=
po_core_ffotd_tu23_593,udouU+b432qRxY0ctXgaHNAGJbQiRR3jLr31Z01u3OE=
po_core_ffotd_tu24_593,tLGDSNOwpfYZGVBcnccOKhiUMIHNrdSktrwYQuoKGgs=
po_core_ffotd_tu25_593,4NiTUgaEW6a5HjV1MMItSlPWLN8CXEt/RUuG4osJRPs=
po_core_ffotd_tu26_593,Q5WMm4wLPDZX0P011KpOvOENVSWnwwJ5JNzZrKKXdUI=
po_core_ffotd_tu27_593,IkWJ+sp5sb9U1FHuJ1bnBupOIQZgFHIgaMlYOR1MRyk=
po_core_ffotd_tu28_593,uwpj9Bm1+2tN0LhYiFkaIwnV83NO5XfiqE1Utmjh2N4=
po_core_ffotd_tu29_593,Ejg7QfeDippiCpKzcpwDPb5CinRXdhj6tTo34sIfP2M=
po_core_ffotd_tu30_593,3WQgUrP1UHGbKNLjORaUwSmRoYVRggPArGPgjeAL0p8=
po_core_ffotd_tu31_593,BN7J0IvNNxf8A2AuG5v5jxbnR91scBrYlI1jtRhH3p8=
po_core_ffotd_tu32_593,X9pAJsIy3PFhQ1pZiWGET1bCU/tMmfcvdyW0MZ3nJ4M=
po_core_ffotd_tu33_593,H1hot1SwqTyQPxv9cVmFlVsGYCxS97B5eqkm3XrlWnA=
po_core_ffotd_tu34_593,MJtX6yvZxJk2BKZyRpTwY8N8msR1eGYJ4uIGk1SQviI=
po_core_ffotd_tu35_593,0tbpM3f/ff5ICaUdNBOj1Yy9WWIArUV8Y3FGAPL4TDw=
po_core_ffotd_tu36_593,TwBb3mfYrViRtnIM7B0U3sNFd7Cm+EDoxT5ZcmA99S0=
po_core_ffotd_tu37_593,uQuLq2m+DNDLcPSYLUpnickkT5nIpy6e2AhvsoioYvk=
po_core_ffotd_tu38_593,W6KUbmDYqSexcIjZQrxWWwtXpLEC8vI1ESeXQqp4zL0=
po_core_ffotd_tu39_593,ZLBbrxQmklWCZrjT8V0My5f8C9YfMckD57KtgN43AKg=
ru_core_ffotd_tu20_593,U2sSxT8kz4SWkhgFb0oCuShVA/+r8p5eeSKZ7anFXpY=
ru_core_ffotd_tu21_593,IgscKlKoU2wLy8XCR9QnDOaBzrwiW6v+GAbhnBlH7Wk=
ru_core_ffotd_tu22_593,e95AuALrlFZuwcdobOg7sANg0pCgj/ostfjM9fTq2Rw=
ru_core_ffotd_tu23_593,4gJOUeWbf3p/cBK4qtmijf/QVT8vU7Eflh3T92MRAmw=
ru_core_ffotd_tu24_593,dc3RpLTg8kZnuy3xH/V4UI/2Vdj9qFVHlNCVUyShjF8=
ru_core_ffotd_tu25_593,1C0EuzNcqG8Ymvb5louoJVMcUHup+OXxK74FU5wDsrk=
ru_core_ffotd_tu26_593,ludEPNyMlWvEY8m3qIDN29bJkL73oO85C2IwwZ9WBBA=
ru_core_ffotd_tu27_593,ghEhZmDBIaOM5rk3BhPq8JdbShHTYrKgxpoYnx7H1BU=
ru_core_ffotd_tu28_593,qsP3qJMusnD8IB1WqzKMdgZL58gF7VNzayBfO3KCrvk=
ru_core_ffotd_tu29_593,kLZldEaTEeailiSdxid4135JX6m7IROLZia6frbP4d8=
ru_core_ffotd_tu30_593,shl2o7sZDBghIdoYKFTmnWWI7KlisKgf7yQQyWRV5UI=
ru_core_ffotd_tu31_593,IJT9HrEzhcKG3pJocksvDYmAW+FtAkovFZdCEd1EzcY=
ru_core_ffotd_tu32_593,2sGrRk1M/oEyYTRNHewVo+rkVgd4FXxanJ47qp1gg7E=
ru_core_ffotd_tu33_593,a3n2A9GfVav2Myu29Kp/9g1vC//3uk2wjFwWH5dUaSo=
ru_core_ffotd_tu34_593,v7HKVFmjH76l27blKAFOIUY7fc6vm8L1GaEJDD0tZg4=
ru_core_ffotd_tu35_593,RxhsqdklW/qqPOCmb6fI5pinbQfeMbbKPT9I5sP2SMU=
ru_core_ffotd_tu36_593,g4CABCpmzy8zGG9/G/J3u1p+HdOM9QwvpVoAegU6GWg=
ru_core_ffotd_tu37_593,kSD5jxTFwynWzD7V/nJZQQHMSqol99lDI0eNLdQguoM=
ru_core_ffotd_tu38_593,zCyUNpShRc6Oo/wAgUwiM3+D7btsYxzTvHz/ZKc84co=
ru_core_ffotd_tu39_593,eBQbnBRnIQClnVcLifGkexrhW8Zu9vYSv8t1hVqNaSA=
sc_core_ffotd_tu20_593,HAZKZBRJwtLYX3XR5uCeJluBhn53+I/jnvEjPUKOk4Y=
sc_core_ffotd_tu21_593,/UIjx0uk+Kzbg81idjWC+S7NLKqjKj0+rA3S6xSR4uo=
sc_core_ffotd_tu22_593,hP2QAThRIFptn03mhiyvEDVpGYTGGoYyC4Ydki08ohc=
sc_core_ffotd_tu23_593,IDqVg38TCjuIrhAwtiKuMd6VSAsWk2ZMNtwRZJB8AXQ=
sc_core_ffotd_tu24_593,CQ5kTx/N27QVq7/MRx5oj4X+8/IX3C1nG4Cf+V4bNZM=
sc_core_ffotd_tu25_593,WxbCAeZGJT7LykxkzbhrPvKf/Zxqg59fiYm10qo1syY=
sc_core_ffotd_tu26_593,FJ9M6F2FBFOErVPwlpOGuc0W/wzf7pTyEJ2siJL8zo0=
sc_core_ffotd_tu27_593,aAqPczyXXf/ORCzPBDo7mgtZ/MQXySp+VKMNn0YYJDM=
sc_core_ffotd_tu28_593,Bdxj94ZKthFNjcugzDKfjPZB8jSZnz4ZUvHhlf8w0+A=
sc_core_ffotd_tu29_593,cv2BQsHdT/dvh1Nc7vvlXVVqoahOvTND/n3FArUuN88=
sc_core_ffotd_tu30_593,LceZLU2qDbnS4LyBGQXzTpOIUH82eDL6OVyfsODw9BI=
sc_core_ffotd_tu31_593,8xVIl+C+aevdYEvu7nrXUfeaVOGMtNZ2fYJHEdO7tkA=
sc_core_ffotd_tu32_593,3ih8fI7g8GLav48obrcygtuQVrAr6tUgUjCgxZDU2B0=
sc_core_ffotd_tu33_593,zC1xWas100tJyKzKU0+u5shCNv5wZW8VA5kY7czr2fI=
sc_core_ffotd_tu34_593,9s9ewzfJFDd3QKvhHyuxlDQmkerRqtC7BAZS/+Ryp4Q=
sc_core_ffotd_tu35_593,LnrSSV5bwfBTh4EEpUECqYH701hWovdhfrH7U/HDFrc=
sc_core_ffotd_tu36_593,jfYlm4tY55PZEaeaAMCLIYt/LUjFNE7gw9Z4QLqFE5c=
sc_core_ffotd_tu37_593,QxhGLT7ay/rXdEYryfN2ZlqKevnuKji65RuUJi3p38g=
sc_core_ffotd_tu38_593,eJgB8SSPVHVpzM/KcbJrWktpJTbPq6E3FGdKSEiGaLY=
sc_core_ffotd_tu39_593,DkL9KD8xjSeicOdgxAikP33foAlZIPs4TOLYYw+/uQo=
tc_core_ffotd_tu20_593,oc29eU+/Gl+WdG7vB6qc53Iow64vgdRXcg/Jpsm0RBE=
tc_core_ffotd_tu21_593,jqjPd1VqAWB0HMdds6Uai1i2cC9rQ9U53iflIzRtqD8=
tc_core_ffotd_tu22_593,YmH/Q3g8Wi+NFbxfMA8LDibgXaEJDRtCsIFEuHAfKug=
tc_core_ffotd_tu23_593,pcTM2bpDvYUCUJCMM8o/7xDKzGPLakF+l2pRjmTOUCo=
tc_core_ffotd_tu24_593,90p2X8q/GuQPKQ3J7PYGdjvdcF9Par8z/L+LXmFm8ok=
tc_core_ffotd_tu25_593,j+TJutz42oRAszS0XnkdRcb6Z1lBfOj9pe24QdwDP8M=
tc_core_ffotd_tu26_593,8xoGO9f9Ffd4cYHAHavCQtIhjTtZSfS2OaPIWVp+t38=
tc_core_ffotd_tu27_593,jCPwwYyvc43pYQcTTOSgBl+b+uR3ls9Sc3uR/pklTK4=
tc_core_ffotd_tu28_593,n3XMdB5Xbgrt8IMVuGwxY8xOQi6udbHF7gY401nzTfc=
tc_core_ffotd_tu29_593,xGjLKL8Ht0etxeL85eDzTfOWOHsyT8hnJSsExBqbtz4=
tc_core_ffotd_tu30_593,tQwVt5S0hd8tNqkM+1Q5NVYKmAlApp3aVFfeo0gxoO4=
tc_core_ffotd_tu31_593,VAyOkuH4/95XEDst8zT3q6om2SaSEgduvb+jb3oJoqc=
tc_core_ffotd_tu32_593,BvYIWECQhRrlxhhLqT5Th0TX6Auh2N0cwJIKSGKCbjM=
tc_core_ffotd_tu33_593,8GdUx4C/R7TzL23R3sIbBkl9MP2oihOtFQQBjv1Nz9M=
tc_core_ffotd_tu34_593,qEDM4W33GH7qw8JCz0WX5FfMxkk6xBMzwSbzwjJcR3c=
tc_core_ffotd_tu35_593,fYHmdOWLADFve8hzLAUCA+fkL7emBWkoMu8P4xlNdsM=
tc_core_ffotd_tu36_593,RfhVxwEd/LLrXmEuaIBszLvp60nRCpuQ4qYuAJSzNdM=
tc_core_ffotd_tu37_593,KSRPQq1QFtmH6yqc3wjX1dhG2iyjXwQz2RR/ZxEaSgU=
tc_core_ffotd_tu38_593,RpQsKvh1Ks7mTFglgf+qNvXxauKnXsWeLni4ydL30Wc=
tc_core_ffotd_tu39_593,3SFHtJKbepfLTQ292naO6/dIiFGfDtLe39A6oSQaR+Q=
core_ffotd_tu20_593,8zoIQVJlaLyhzcczlmYH6uSNzyS5oiHvY5lfCt3sazM=
core_ffotd_tu21_593,vdXTkAT6NEDY6Ox+6ECSNqxKt1cQXFJgJXvqDLPW3Ck=
core_ffotd_tu22_593,E+9uilnwPfB+K+l0H3z977+7knaMDFMLGhRh9xV/OuE=
core_ffotd_tu23_593,wRABYh1DM1Cnbo/P37ayrPAf6x3ryXw4AXK/bUT32vc=
core_ffotd_tu24_593,JMWZ2xCMkUwP/A7g6Qzw9F29Uj47LVidisziEiuwDOA=
core_ffotd_tu25_593,oIGfDPcT50JNet4gVFbZyujRwl/7PictcKnENz7WLMo=
core_ffotd_tu26_593,+WpfokkC/n8Eco9X6D0OliSOVpNQgMaopANsHs5NBpM=
core_ffotd_tu27_593,gA0BAZE2Y/LV+VOTAj38aOMqNqB1i1xnwm6q8JG5I4Q=
core_ffotd_tu28_593,A5hGojWrnFwADkifWwwQ+TxZmezjwKZASsX2LIrLV24=
core_ffotd_tu29_593,yypRt2jCcmvri+dL+eH9bdeOHs9lKvg72c8dcq6ii48=
core_ffotd_tu30_593,shzKK7TDRBBozDCE1gTdgxQerGIlwmF0gh3urD668mU=
core_ffotd_tu31_593,WY8qUt/0Hj8+uq3sMVKzAQ+CZzw+IGQkvlETF2/OlXk=
core_ffotd_tu32_593,/ZRBHG1gU6kNqtUS07+bcC16wRjMEnIvGFvchLmdbBM=
core_ffotd_tu33_593,QG6b39wHOxQFhKAF385sKCT0Dn/tBAUfblSdjHdk3wY=
core_ffotd_tu34_593,DcIavX5CEpDy4o+QImLNWpgPkO2URtPB1VmD1NK7XR0=
core_ffotd_tu35_593,yM1pSy9SYQHuK1zvWuGvZ7HdVuGMXdMF72jpaWuiKMQ=
core_ffotd_tu36_593,50UrJH6y2lCaaPRmSFTnYqhDOSD1ADsB6rGsNDHvRYU=
core_ffotd_tu37_593,Bb+MsJucI/BnrWHI1fLDZwZ5ktto2cSbgDMN/tqH7y8=
core_ffotd_tu38_593,2K5/RNYnD/SoilvqvfX/lXi8cb1dcBTBQUV+8+S1Xns=
core_ffotd_tu39_593,O5PkMb2iHNuPuck4LayPRaVdmi/AsGdVZHolqjvYhe4=

```

`src/client/resources/dw/playlists_tu32.gz`:

```gz
// PC Playlist
version 2

settings
// setdvar live_presence_min_ms_between_updates 10000
// setdvar live_presence_max_ms_between_updates 600000
// setdvar liveSessionTaskTimeoutUpdate 60000
// setdvar profileDirtyInterval 900000
// setdvar lobbySearchDatacenterType 2
// setdvar cl_thunderhead_prefix t7_tu1_

//Disable paintshop optimizations
setdvar cg_paintshopEnableCompression 0								// Assists with Paintshop streaming
setdvar cg_paintshopReadDiskCache 0									// Assists with Paintshop streaming
setdvar cg_paintshopWriteDiskCache 0								// Assists with Paintshop streaming

setdvar r_forcedModelLodsMP 4								// helps with offloading some memory from the streamer, per N. Nikaido.
setdvar r_streamWeaponsCache 1                              //Frees up memory on the streamer by changing how weapon textures load. Per N. Nikaido.

setdvar marketing_enabled 1									 // enables CRM marketing coms
setdvar arena_defaultPlaylist 40							 // sets the default Arena playlist
setdvar tu2_disableChallengesForLockedItemsInArena 1	     // disables challenges for locked items in arenas
setdvar groupCountsVisible 0 								 // replaced player count with percentages
setdvar tu2_catchMissingRbEndFrame 1						 // Enables changes from N Silvagni see DT 14111
setdvar fracture_enabled 1									 // Enables Fracture game mode for MP

setdvar totalSampleRateBlackBox 0

setdvar tu9_noClipsWarning 1                            // DT 163743

// DLC search tuning
setdvar lobbySearchSkipDLCProbability 0.5              // For users that are about to search for a session of ( DLC1 | OriginalMaps ), turn off the DLC1 bit 50% of the time and just search for original maps sessions instead. This should help skill discrepency between DLC1 sessions and original maps sessions

//Parking Tuning
//setdvar lobbySearchForceUnparkLobbySize 3
//setdvar lobbySearchSkipUnparkProbability 0.9
//setdvar lobbySearchBaseSkillRange 1.0
//setdvar lobbySearchSkillRangeMultiplier 1.0
setdvar tu16_lobbyMonitor 1                         // Prevents broken lobbies, per S.Eldredge and T. Keegan

//Theater Optimizations
setdvar demo_fileblockWriteRate 30

// hide unavailable DLC.
// For testing, set to highest DLC index + 2 (e.g. to show DLC2 but not DLC3, set this to 4). Set to 7 to test all DLCs for this season.
setdvar tu9_highestAvailableDLC 11

// Enables DLC5 pop-ups
setdvar zmhd_purchase_reward_popup_enabled 1
setdvar zmhd_gobblegum_popup_ps4_enabled 0
setdvar zmhd_gobblegum_popup_xb1_enabled 0

// Com_Error when we're out of UI models.  We tried to handle this gracefully, but it probably leads to possible exploits.
setdvar tu10_errorWhenOutOfModels 1

// Splits up large quadCache allocations into smaller ones, to fix a UI out of memory error with long strings.  Recommended 256.  Default value (4097) should never split anything
setdvar tu11_maxQuadCacheAlloc 256

// set to 0 when times should show as PST instead of PDT
setdvar ui_isDaylightSavingsTime 1

//Probation DVARS
setdvar probation_league_enabled 1
setdvar probation_version 1

//Loot
setdvar loot_enabled 1
setdvar tu4_burnDuplicates 1
setdvar loot_mpItemVersions "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18"                                          //Enables black market items for DEV
//setdvar loot_salePercentOff .5                                                    //Makes loot 50% off (UI Only - need FFOTD and Backend Update to actually get 50% off)
//setdvar lootxp_multiplier 2.0                                                     //Doubles Cryptokey earn rate - delete for playlists going LIVE, unless needed (requires backend update as well)
//setdvar scr_vialsAwardedScale 2.0                                                 //Double Liquid Divinium Earn Rate - delete for playlits giong LIVE, unless needed (requires backend update and FFOTD if before TU9)
setdvar tu4_enableCodPoints 1
setdvar loot_mpItemCurrentDropStringRef MENU_MONTHS_JUN                            //NEED TO UPDATE WITH EACH LOOT TU - sets a banner on the latest loot (as determined loot_mpItemVersions); banner's month is determined by this DVAR
setdvar loot_bundle_final_count 10                                                  //Fixes post-event supply drops remaining number
setdvar loot_trifecta_breadcrumb_index 2                                            //Increment this to allow for Breadrumbs on new Special Contracts.

setdvar black_market_gun_game 0
setdvar rotatingPlaylistStartTime 1526058000

setdvar rare_bundle_10for5_cpCost 500                                                   //Price for 10for5
setdvar rare__bundle_10for5_dwid 51                                                     //DW ID for 10for5

//These dvars will prevent noDupes and 100 Bundles from disappearing after the event ends. per V. Sharma
setdvar loot_noDupeRare20Bundle_dwid 15
setdvar loot_noDupeRare20Bundle_cpCost 2000
setdvar loot_noDupeRare20Bundle_drop_id 99062
setdvar loot_noDupeRare20Bundle_sku_id 99061
setdvar loot_rare100_dwid 13
setdvar loot_rare100_cpCost 5000
setdvar trifecta_cod_points_drop_id 99071
setdvar trifecta_cod_points_sku 99073

// Loot Unlock
setdvar loot_unlockUnreleasedLoot 1                                                 //When set to 1, this will display any loot we wish to hide from the public in mpUnreleasedLoot.csv; Setting to 0 will hide the Loot in the UI across the game

//Bribes                                                                        //Enables or Disables bribes
setdvar loot_bribeCrate_dwid 0
setdvar loot_bribeCrate_cpCost 300
setdvar loot_bribeCrate_cryptoCost 60
setdvar loot_bundleActive 0

// Liquid Divinium (UI Only - needs a backend update)
// setdvar loot_ld_salePercentOff .5  // This will set UI for original price (i.e., if a 50% off sale, then it will times the half-off CODPoint costs above by 2 and show that as the "original price") and controls whether or the promotional UI is visible or not
// setdvar loot_ld_x3_cpCost 100              // Original price 200
// setdvar loot_ld_x6_cpCost 200             // Original price 400
// setdvar loot_ld_x9_cpCost 300            // Original price 600
// setdvar loot_ld_saleEndDay 4        // int that represents which day of the week is displayed in the “sale ending” message in the popup; Sunday = 0; Thursday = 4, etc.
// setdvar loot_ld_discount 50        // the discount that is displayed in the "--% off!" strings
// setdvar zm_vials_20_id 99024         // Enables 20 pack of Liquid Divinium as a new purchasable

//V.Sharma - No Ghost Lobby
setdvar tu3_lobby_dropRejoiningClients 1                    // When a client leaves and re-joins the same game lobby, he will no longer be taken to a ghost lobby

//Dedicated Server
setdvar lobbySearchMinDediSearchTime 30                         // Minimum time players will wait for dedicated server
setdvar lobbySearchMinDediSearchClientAdd 5                     // Adds this amount of time per party member - i.e., 5 seconds per party member
setdvar qos_echo_chance 50                                       // Ping survey for Orbis Dev only, per E.Oughton and B.Stragnell

//Enables Full Feature Theater
setdvar demo_restrictedbasicmode 0
setdvar demo_enablehighlightreel 1

//Arenas
setdvar arena_enableArenaChallenges 1

//DLC1 Free Weekend UI
//setdvar ui_freeDLC1 1
//setdvar ui_freeDLCPC 1											// Enables FREE DLC for all pc players.

// Digital and Retail Incentive                                                         //This enables UI pop-up for when players purchase incentive
setdvar enable_digital_incentive 1
setdvar enable_retail_incentive 1

//Season Pass Incentive
setdvar enable_season_pass_incentive 1

//Contracts                                                                                             // Turns on UI for Contracts
setdvar show_contracts_button 1                                        // Turns on Contract Button
setdvar enable_weapon_contract 1                                     // Enable weapon contract
setdvar weapon_contract_target_value 75                         // Setting to 5 for QA, but will turn to 75 for when we ship
setdvar contracts_enabled_mp 1
setdvar contracts_start_time 1460998800
setdvar daily_contract_cryptokey_reward_count 10                            // Defines number of Cryptokeys to reward, default value for this dvar is 10

//GobbleGum Features
setdvar scr_firstGumFree 1											// Enables promotion where First GobbleGum in each round is Free
setdvar tu18_enable_newtons_cookbook 1									// Enables Newton's Cookbook in the ZM main menu
setdvar loot_forceEnableZCGumsInFactory 1							// enables the dlc5 gobblegums in dr monty's factory even if dlc5 is not enabled by tu9_highestAvailableDLC

//ZM Tracking Dvars
setdvar zm_dash_stats_enable_tracking 1
//setdvar zm_dash_stats_use_aggregated_comscore 1                    // Leave this out unless the comscore event is causing problems.

//Enable Music Tracks
setdvar ui_enableMusicTracks 1                                                      // Enables thea ability to change music tracks in-game; must turn off before we go LIVE if not working correctly

//Promotional Menu
setdvar ui_enablePromoMenu 0                                                            // Enables Promo Menu
//setdvar ui_promoThermometerPercent .25                                    // Sets percentage on "Thermometer"; .25 will make the themometer go up 25%
ssetdvar ui_enablePromoTracking 0													// Enables Headshot tracking for ZMHD Thermometer.
setdvar ui_enableZMHDFeaturedCard 0													// Enables Thermometer widget in ZM shell

//Survey
setdvar survey_count 1
setdvar survey_chance .005
setdvar live_enablePolls 0                                          // Disables the polling system, per Amit

//DW Live Experiments
setdvar live_experimentsEnabled 1                                                       // Leave on for LIVE per Martin

// Analytics
setdvar tu8_enableDurableProductsExchange 1                                 // Tracks Durable Products

// setdvar skuOnlineOverride 1

// setdvar skuOnlineSceaEnFr 1
// setdvar skuOnlineSceaMsEn 1
// setdvar skuOnlineSceaBpEn 1
// setdvar skuOnlineSceeEnFr 1
// setdvar skuOnlineSceeGeEn 1
// setdvar skuOnlineSceeSpIt 1
// setdvar skuOnlineSceeRuPo 1
// setdvar skuOnlineSceeArEa 1
// setdvar skuOnlineScejFjJa 1

//setdvar cpProcessingJoinCheck 1                               //Removed at T.Keegan's Request
//setdvar zmProcessingJoinCheck 1                               //Removed at T.Keegan's Request

setdvar sv_mapSwitchPreloadFrontend 0               //Turns on and off preloading for the frontend

setdvar lobbySearchSkipUnparkProbability 0          // Turn on for LIVE
setdvar lobbySearchBaseSkillRange 0               // Turn on for LIVE - Disabled for PC

setdvar com_script_recordeventprobability_client 0.0001
setdvar com_script_recordeventprobability_server 0.0001
setdvar lobby_MatchmakingLoggingChance 1

// PC Specific: Disables Matchmaking Skill Range Search
setdvar lobbySearchSkillRangeMultiplier 0

// PC Specific: Dedicated Server Lobby Merging
setdvar lobbyMergeDedicatedEnabled 1

//PC Specific: Dedicated Server Ping Allowance
setdvar lobbySearchDediUnparkPingLimit 250

//PC Specific: Profanity Filter
setdvar ui_badWordSeverity 2

//Infected Gametype
setdvar scr_infect_finaluav 0

//Prop Hunt Gametype
setdvar scr_prop_minigame 1

//CCPA Button
setdvar live_useRegulation 1

///////////////////////////////////////////////////////////////////////////
//     EVENTS
///////////////////////////////////////////////////////////////////////////

event default
rule xpGroups everyone
rule scr_xpscalemp 1
rule scr_xpscalezm 1
rule gunxpgroups everyone
rule scr_gunxpscalemp 1
rule scr_gunxpscalezm 1
rule cryptoKeyGroups everyone
rule lootxp_multiplier 1.0
rule zmVialGroups everyone

event double_xp_mp
rule xpGroups everyone
rule scr_xpscalemp 2

event double_xp_zm
rule xpGroups everyone
rule scr_xpscalezm 2

event enable_nuketown
rule playlist_show 34

event double_weapon_xp_mp
rule gunxpgroups everyone
rule scr_gunxpscalemp 2

event double_weapon_xp_zm
rule gunxpgroups everyone
rule scr_gunxpscalezm 2

event double_vials
rule scr_vialsAwardedScale 2.0

event double_crypto
rule lootxp_multiplier 2.0

event double_xp_mpzm_party_2
rule xpGroups group_party2
rule scr_xpscalemp 2
rule scr_xpscalezm 2

event double_vials_zm_party_6
rule zmVialGroups group_party6
rule scr_vialsAwardedScale 2.0

event gungame_featured
targetPlaylist 30
rule ui_showBonusIcon 1
rule xpGroups everyone
rule scr_xpscalemp 2
rule lootxp_multiplier 2.0

event gungame_display
rule playlist_show 30

event hardpoint_featured
targetPlaylist 90
rule ui_showBonusIcon 1
rule lootxp_multiplier 2.0
rule gunxpgroups everyone
rule scr_gunxpscalemp 2

event hardpoint_display
rule playlist_show 90
rule playlist_hide 6

event safeguard_featured
targetPlaylist 91
rule ui_showBonusIcon 1
rule xpGroups everyone
rule scr_xpscalemp 2
rule gunxpgroups everyone
rule scr_gunxpscalemp 2

event safeguard_display
rule playlist_show 91
rule playlist_hide 10

event killconfirmed_featured
targetPlaylist 92
rule ui_showBonusIcon 1
rule xpGroups everyone
rule scr_xpscalemp 2
rule gunxpgroups everyone
rule scr_gunxpscalemp 2

event killconfirmed_display
rule playlist_show 92
rule playlist_hide 5

event uplink_featured
targetPlaylist 93
rule ui_showBonusIcon 1
rule lootxp_multiplier 2.0

event uplink_display
rule playlist_show 93
rule playlist_hide 9

event fracture_featured
targetPlaylist 94
rule ui_showBonusIcon 1
rule xpGroups everyone
rule scr_xpscalemp 2
rule lootxp_multiplier 2.0

event fracture_display
rule playlist_show 94
rule playlist_hide 11

event snd_featured
targetPlaylist 95
rule ui_showBonusIcon 1
rule xpGroups everyone
rule scr_xpscalemp 2

event snd_display
rule playlist_show 95
rule playlist_hide 8

event ctf_featured
targetPlaylist 96
rule ui_showBonusIcon 1
rule xpGroups everyone
rule scr_xpscalemp 2
rule lootxp_multiplier 2.0

event ctf_display
rule playlist_show 96
rule playlist_hide 7

event demolition_featured
targetPlaylist 97
rule ui_showBonusIcon 1
rule lootxp_multiplier 2.0
rule gunxpgroups everyone
rule scr_gunxpscalemp 2

event demolition_display
rule playlist_show 97
rule playlist_hide 4

event ffa_featured
targetPlaylist 98
rule ui_showBonusIcon 1
rule lootxp_multiplier 2.0

event ffa_display
rule playlist_show 98
rule playlist_hide 2

event domination_featured
targetPlaylist 99
rule ui_showBonusIcon 1
rule gunxpgroups everyone
rule scr_gunxpscalemp 2

event domination_display
rule playlist_show 99
rule playlist_hide 3

event hctdm_featured
targetPlaylist 100
rule ui_showBonusIcon 1
rule lootxp_multiplier 2.0
rule gunxpgroups everyone
rule scr_gunxpscalemp 2

event hctdm_display
rule playlist_show 100
rule playlist_hide 20

event chaos_featured
targetPlaylist 101
rule ui_showBonusIcon 1
rule gunxpgroups everyone
rule scr_gunxpscalemp 2
rule lootxp_multiplier 2.0

event chaos_display
rule playlist_show 101

event gwar_featured
targetPlaylist 103
rule ui_showBonusIcon 1
rule lootxp_multiplier 2.0
rule xpGroups everyone
rule scr_xpscalemp 2

event gwar_display
rule playlist_show 103

event infected_featured
targetPlaylist 104
rule ui_showBonusIcon 1
rule xpGroups everyone
rule scr_xpscalemp 2
rule gunxpgroups everyone
rule scr_gunxpscalemp 2

event infected_display
rule playlist_show 104

event prophunt_featured
targetPlaylist 106
rule ui_showBonusIcon 1
rule xpGroups everyone
rule scr_xpscalemp 2
rule gunxpgroups everyone
rule scr_gunxpscalemp 2

event prophunt_display
rule playlist_show 106

event sas_featured
targetPlaylist 108
rule ui_showBonusIcon 1
rule lootxp_multiplier 2.0
rule gunxpgroups everyone
rule scr_gunxpscalemp 2

event sas_display
rule playlist_show 108

event sniperonly_featured
targetPlaylist 109
rule ui_showBonusIcon 1
rule gunxpgroups everyone
rule scr_gunxpscalemp 2

event sniperonly_display
rule playlist_show 109

///////////////////////////////////////////////////////////////////////////
//     MP GAME MODES
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
//     NORMAL GAME MODES (MP)
///////////////////////////////////////////////////////////////////////////

gametype hs_ctf
nameref PLAYLIST_GAMETYPE_HS_CTF
script ctf
rule gts inactivityKick 60

gametype hs_dem
nameref PLAYLIST_GAMETYPE_HS_DEM
script dem
rule gts inactivityKick 60

gametype hs_dom
nameref PLAYLIST_GAMETYPE_HS_DOM
script dom
rule gts inactivityKick 60

gametype hs_ffa
nameref PLAYLIST_GAMETYPE_HS_FFA
script dm
rule gts inactivityKick 60

gametype hs_koth
nameref PLAYLIST_GAMETYPE_HS_KOTH
script koth
rule gts inactivityKick 60

gametype hs_conf
nameref PLAYLIST_GAMETYPE_HS_CONF
script conf
rule gts inactivityKick 60

gametype hs_sd
nameref PLAYLIST_GAMETYPE_HS_SD
script sd
rule gts inactivityKick 60

gametype hs_tdm
nameref PLAYLIST_GAMETYPE_HS_TDM
script tdm
rule gts inactivityKick 60

gametype hs_ball
nameref PLAYLIST_GAMETYPE_HS_BALL
script ball
rule gts inactivityKick 60

gametype big_tdm
nameref PLAYLIST_GAMETYPE_BIG_TDM
script tdm
rule gts scorelimit 100
rule gts inactivityKick 60

gametype hs_escort
nameref PLAYLIST_GAMETYPE_HS_ESCORT
script escort
rule gts inactivityKick 60

gametype hs_clean
name english "Fracture"
name englisharabic "Fracture"
name french "Fracture"
name italian "Frattura"
name german "Fraktur"
name spanish "Fractura"
name polish "Szczelina"
name russian "Разлом"
name japanese "FRACTURE"
name mexicanspanish "Fractura"
name portuguese "Fratura"
name arabic "ﻉﺪﺼﻟا"
name traditionalchinese "裂縫"
name simplifiedchinese "裂缝"
script clean
rule gts scorelimit 75
rule gts inactivityKick 60

gametype hs_infect
nameref PLAYLIST_GAMETYPE_HS_INFECT
script infect
rule gts inactivityKick 120

gametype hs_prop
nameref PLAYLIST_GAMETYPE_HS_PROP
script prop
rule gts inactivityKick 180

gametype hs_sas
nameref PLAYLIST_GAMETYPE_HS_SAS
script sas
rule gts inactivityKick 60

gametype hs_sniperonly
nameref PLAYLIST_GAMETYPE_HS_SNIPERONLY
script sniperonly
rule gts inactivityKick 60

///////////////////////////////////////////////////////////////////////////
//     HARDCORE RULES (MP)
///////////////////////////////////////////////////////////////////////////

gametype hc_tdm
nameref PLAYLIST_GAMETYPE_HC_TDM
script tdm
rule gts hardcoreMode 1
rule gts friendlyfiretype 1
rule gts playerHealthRegenTime 0
rule gts playerMaxHealth 30
rule gts allowKillcam 0
rule gts allowbattlechatter 0
rule gts teamKillPunishCount 3
rule gts teamKillPointLoss 1
rule gts inactivityKick 60

gametype hc_sd
nameref PLAYLIST_GAMETYPE_HC_SD
script sd
rule gts hardcoremode 1
rule gts friendlyfiretype 1
rule gts playerMaxHealth 30
rule gts playerHealthRegenTime 0
rule gts allowKillcam 0
rule gts allowbattlechatter 0
rule gts teamKillPunishCount 3
rule gts teamKillPointLoss 1
rule gts inactivityKick 60

gametype hc_ffa
nameref PLAYLIST_GAMETYPE_HC_FFA
script dm
rule gts hardcoremode 1
rule gts playerHealthRegenTime 0
rule gts playerMaxHealth 30
rule gts allowKillcam 0
rule gts allowbattlechatter 0
rule gts inactivityKick 60

gametype hc_ctf
nameref PLAYLIST_GAMETYPE_HC_CTF
script ctf
rule gts hardcoremode 1
rule gts friendlyfiretype 1
rule gts playerMaxHealth 30
rule gts playerHealthRegenTime 0
rule gts allowKillcam 0
rule gts allowbattlechatter 0
rule gts teamKillPunishCount 3
rule gts teamKillPointLoss 1
rule gts inactivityKick 60

gametype hc_conf
nameref PLAYLIST_GAMETYPE_HS_CONF
script conf
rule gts hardcoremode 1
rule gts friendlyfiretype 1
rule gts playerMaxHealth 30
rule gts playerHealthRegenTime 0
rule gts allowKillcam 0
rule gts allowbattlechatter 0
rule gts teamKillPunishCount 3
rule gts teamKillPointLoss 1
rule gts inactivityKick 60

gametype hc_dom
nameref PLAYLIST_GAMETYPE_HS_DOM
script dom
rule gts hardcoremode 1
rule gts friendlyfiretype 1
rule gts playerMaxHealth 30
rule gts playerHealthRegenTime 0
rule gts allowKillcam 0
rule gts allowbattlechatter 0
rule gts teamKillPunishCount 3
rule gts teamKillPointLoss 1
rule gts inactivityKick 60

///////////////////////////////////////////////////////////////////////////
//     PARTY GAME MODES (MP)
///////////////////////////////////////////////////////////////////////////

gametype hs_gun
nameref PLAYLIST_GAMETYPE_HS_GUN
script gun
rule gts allowbattlechatter 1
rule gts inactivityKick 60


///////////////////////////////////////////////////////////////////////////
//     ARENA PLAY RULES (MP)
///////////////////////////////////////////////////////////////////////////

gametype arena_ctf_pro
nameref PLAYLIST_GAMETYPE_HS_CTF
script ctf
rule gts scorelimit 0										// Capture Limit: unlimited
rule gts playerRespawnDelay 7.5					// Respawn Delay: 7.5 Seconds
rule gts cumulativeRoundScores 1				// Win Condition
rule gts teamKillPunishCount 5					// Number of teamkills before kicking: 3
rule gts teamKillPointLoss 1			  		// Player will lose points for teamkills: true
rule gts inactivityKick 60

gametype arena_sd_pro
nameref PLAYLIST_GAMETYPE_ARENA_SD
script sd
rule gts timelimit 1.5							// Time Limit: 1.5 Minutes
rule gts defuseTime 7.5							// Defuse Time: 7.5 Seconds
rule gts silentPlant 1							// Silent Plant: True
rule gts scoreLimit 6							// Round Win Limit: 6 Rounds
rule gts teamKillPunishCount 3					// Number of teamkills before kicking: 3
rule gts teamKillPointLoss 1			  		// Player will lose points for teamkills: true
rule gts inactivityKick 60

gametype arena_sd
nameref PLAYLIST_GAMETYPE_ARENA_SD
script sd
rule gts inactivityKick 60

gametype arena_koth
nameref PLAYLIST_GAMETYPE_ARENA_KOTH
script koth
rule gts inactivityKick 60

gametype arena_koth_pro
nameref PLAYLIST_GAMETYPE_ARENA_KOTH
script koth
rule gts spawnsuicidepenalty 3 					// Suicide Penalty in KOTH : 3 seconds
rule gts teamKillPunishCount 5					// Number of teamkills before kicking: 3
rule gts teamKillPointLoss 1			  		// Player will lose points for teamkills: true
rule gts inactivityKick 60

gametype arena_ball_pro
nameref PLAYLIST_GAMETYPE_HS_BALL
script ball
rule gts playerRespawnDelay 5			  		// Respawn Delay: 5 Seconds
rule gts roundScoreLimit 0							// Round Score Limit: 0
rule gts teamKillPunishCount 5					// Number of teamkills before kicking: 3
rule gts teamKillPointLoss 1			  		// Player will lose points for teamkills: true
rule gts inactivityKick 60

gametype arena_dom
nameref PLAYLIST_GAMETYPE_HS_DOM
script dom
rule gts inactivityKick 60

gametype arena_escort
nameref PLAYLIST_GAMETYPE_HS_ESCORT
script escort
rule gts inactivityKick 60

gametype arena_conf
name englisharabic "KILL CONFIRMED"
name french "ÉLIMINATION CONFIRMÉE"
name italian "UCCISIONE CONFERMATA"
name german "ABSCHUSS BESTÄTIGT"
name spanish "BAJA CONFIRMADA"
name polish "LIKWIDACJA POTW."
name russian "ПОДТВЕРЖДЕНИЕ"
name japanese "K-CONFIRMED"
name mexicanspanish "BAJA CONFIRMADA"
name portuguese "BC"
name arabic "ﻞﺘﻘﻟا ﺪﻴﻛﺄﺗ"
name traditionalchinese "擊殺確認"
name simplifiedchinese "击杀确认"
name PLAYLIST_GAMETYPE_HS_CONF
script conf
rule gts inactivityKick 60

///////////////////////////////////////////////////////////////////////////
//     ZOMBIE GAME MODES
///////////////////////////////////////////////////////////////////////////
gametype zclassic
nameref PLAYLIST_GAMETYPE_ZCLASSIC
rule ui_zm_gamemodegroup zclassic
script zclassic

///////////////////////////////////////////////////////////////////////////
//     CAMPAIGN GAME MODES
///////////////////////////////////////////////////////////////////////////

gametype cp_coop
nameref PLAYLIST_GAMETYPE_CP_COOP
script coop

gametype doa
nameref PLAYLIST_GAMETYPE_CP_COOP
script doa

///////////////////////////////////////////////////////////////////////////
//    MP CATEGORIES
///////////////////////////////////////////////////////////////////////////

category featured
sessionmode mp
name english "Featured"
name englisharabic "Featured"
name french "À l'affiche"
name italian "In evidenza"
name german "Vorgestellt"
name spanish "destacados"
name polish "polecane"
name russian "избранное"
name japanese "注目"
name mexicanspanish "destacado"
name portuguese "destaque"
name arabic "ﺓﺰﻴﻤﺘﻣ"
name traditionalchinese "精選"
name simplifiedchinese "特色推荐"
description english "Featured game modes and time-limited playlist events."
description englisharabic "Featured game modes and time-limited playlist events."
description french "Modes de jeu à l'affiche et événements à durée limitée pour les sélections."
description italian "Modalità di gioco in evidenza ed eventi playlist a tempo limitato."
description german "Vorgestellte Spielmodi und zeitlich limitierte Listen-Events."
description spanish "Modos de juego y eventos destacados por tiempo limitado."
description polish "Polecane tryby gry oraz wydarzenia z ograniczonymi czasowo listami gier."
description russian "Избранные режимы и особые списки игр с ограниченным временем доступности."
description japanese "注目のゲームモードと期間限定のプレイリストイベント"
description mexicanspanish "Modos de juego y eventos destacados por tiempo limitado."
description portuguese "Modos de jogo em destaque e lista de jogos de tempo limitado."
description arabic ".ﺓﺰﻴﻤﺘﻤﻟا ﺐﻌﻠﻟا ﻁﺎﻤﻧﺃو ﺖﻴﻗﻮﺘﻟا ﺓﺩﺪﺤﻣ ﻞﻴﻐﺸﺘﻟا ﻢﺋﺍﻮﻘﻟ ﺕﺎﻴﻟﺎﻌﻓ"
description traditionalchinese "精選遊戲模式和限時遊戲清單活動。"
description simplifiedchinese "特色游戏模式以及限时游戏列表活动。"
icon playlist_core
filter playermatch
unlockxp 0

category core
sessionmode mp
nameref PLAYLIST_CATEGORY_CORE
description english "Base game modes and maps."
description englisharabic "Base game modes and maps."
description french "Modes de jeu et cartes de base."
description italian "Modalità di gioco e mappe di base."
description german "Standard-Spielmodi und -Karten."
description spanish "Modos de juego y mapas básicos."
description polish "Podstawowe tryby gry i mapy."
description russian "Стандартные режимы и карты."
description japanese "基本ゲームモードとマップ"
description mexicanspanish "Modos de juego y mapas básicos."
description portuguese "Modos e mapas do jogo base."
description arabic ".ﺔﻴﺳﺎﺳﻷا ﺐﻌﻠﻟا ﻂﺋﺍﺮﺧ و ﻁﺎﻤﻧأ"
description traditionalchinese "基本遊戲模式和地圖。"
description simplifiedchinese "基础游戏模式和地图。"
icon playlist_core
filter playermatch
unlockxp 0

category hardcore
sessionmode mp
nameref PLAYLIST_CATEGORY_HARDCORE
description english "Hardcore game mode variants. No HUD. Limited health."
description englisharabic "Hardcore game mode variants. No HUD. Limited health."
description french "Variantes de jeu Hardcore. Pas d'ATH. Santé limitée."
description italian "Varianti di modalità di gioco Veterano. Niente interfaccia. Salute limitata."
description german "Hardcore-Spielvarianten. Kein HUD. Begrenzte Gesundheit."
description spanish "Variantes de juegos de modo Extremo. Sin HUD. Salud limitada."
description polish "Tryby Hardcore. Bez HUD. Ogran. żywotność."
description russian "Режимы повышенной сложности. Минимальный интерфейс."
description japanese "HARDCOREゲームモード HUD表示なし 体力制限あり"
description mexicanspanish "Variantes de juegos de modo Extremo. Sin HUD. Salud limitada."
description portuguese "Variações de modo de jogo Extremo. Sem HUD e com saúde limitada."
description arabic ".ﺓﺩﻭﺪﺤﻣ ﺔﺤﺻ .ﺽﺮﻋ ﺔﺷﺎﺷ ﻥﻭﺪﺑ .ﺔﻔﻠﺘﺨﻤﻟا ﺪﻳﺪﺸﻟا ﺐﻌﻠﻟا ﻂﻤﻧ ﻝﺎﻜﺷأ"
description traditionalchinese "硬派特殊遊戲模式。 無抬頭顯示資訊。有限生命值。"
description simplifiedchinese "新版本精英模式。没有HUD，生命值有限。"
icon playlist_hardcore
filter playermatch
unlockxp 0

category arena
sessionmode mp
nameref PLAYLIST_CATEGORY_ARENA
description english "Competitive maps and game modes where players are ranked. Specialist draft and Bans and Protects are enabled. Friendly fire enabled."
description englisharabic "Competitive maps and game modes where players are ranked. Specialist draft and Bans and Protects are enabled. Friendly fire enabled."
description french "Cartes et modes de jeu compétitifs où les joueurs sont classés. Exclusions/Protections et Recrutement de spécialiste activés. Tir allié activé."
description italian "Mappe e modalità di gioco competitive in cui i giocatori sono classificati. Arruolamento specialisti e interdizioni/protezioni attivati. Fuoco amico attivato."
description german "Wettkampfkarten und -spielmodi mit Ranglisten. Mit Spezialisten-Einberufung und Schutz/Ausschluss. Teambeschuss aktiviert."
description spanish "Mapas y modos de juego competitivos en los que se clasifica a los jugadores. Reclutamiento de especialistas y exclusiones/protecciones activados. Fuego amigo activado."
description polish "Mapy i tryby w trybie rywalizacji. Ranking włączony. Włączony wybór specjalisty, blokady i ochrona. Włączony ostrzał sojuszniczy."
description russian "Состязательные карты и режимы рейтинговой игры. Включены: выбор специалистов, запреты и защиты, огонь по своим."
description japanese "ランクありの大会マップとゲームモード\nスペシャリスト採用、禁止/保護あり 味方への誤射あり"
description mexicanspanish "Mapas y modos de juego competitivos en los que se clasifica a los jugadores. Reclutamiento de especialistas y exclusiones/protecciones activados. Fuego amigo activado."
description portuguese "Mapas competitivos e modos de jogo com classificação de jogadores. Alistamento de especialistas e banir/proteger habilitados. Fogo amigo habilitado."
description arabic ".ﺔﻠﻌﻔﻣ ﺔﻘﻳﺪﺼﻟا ﻥﺍﺮﻴﻨﻟا .ﺔﻠﻌﻔﻣ ﻊﻨﻤﻟا و ﺔﻳﺎﻤﺤﻟا و ﻦﻴﺼﺼﺨﺘﻤﻟا ﺪﻴﻨﺠﺗ ﺭﺍﻮﻃأ.ﻦﻴﺒﻋﻼﻟا ﻒﻴﻨﺼﺗ ﺎﻬﻴﻓ ﻢﺘﻳ ﺔﻴﺴﻓﺎﻨﺗ ﺐﻌﻟ ﻁﺎﻤﻧﺃو ﻂﺋﺍﺮﺧ"
description traditionalchinese "對戰地圖和遊戲模式採用排名制度。啟用專家選拔和封鎖/保護設定。啟用友軍誤擊。"
description simplifiedchinese "玩家可以获得头衔的竞技地图和游戏模式。可以使用专家征召、禁用和保护功能。友军伤害开启。"
icon playlist_arena
filter arenamatch
unlockxp 0

///////////////////////////////////////////////////////////////////////////
//    ZM CATEGORIES
///////////////////////////////////////////////////////////////////////////

category zm_zod
sessionmode zm
name english "Shadows of Evil"
name englisharabic "Shadows of Evil"
name french "Shadows of Evil"
name italian "Shadows of Evil"
name german "Shadows of Evil"
name spanish "Shadows of Evil"
name polish "Shadows of Evil"
name russian "Shadows of Evil"
name japanese "SHADOWS OF EVIL"
name mexicanspanish "Shadows of Evil"
name portuguese "Shadows of Evil"
name arabic "Shadows of Evil"
name traditionalchinese "Shadows of Evil"
name simplifiedchinese "Shadows of Evil"
description english "Take to the streets of Morg city to combat the undead. Embrace the curse to uncover its mysteries."
description englisharabic "Take to the streets of Morg city to combat the undead. Embrace the curse to uncover its mysteries."
description french "Descendez dans les rues de Morg City pour combattre les morts-vivants. Affrontez la malédiction pour découvrir ses mystères."
description italian "Combatti i non morti per le vie di Morg City e cedi alla maledizione per scoprire i suoi segreti."
description german "Kämpfen Sie auf den Straßen von Morg City gegen die Untoten. Erleben Sie den Fluch und entdecken Sie seine Geheimnisse."
description spanish "Recorre las calles de Morg City para combatir a los no muertos. Abraza la maldición para descubrir sus misterios."
description polish "Walcz z nieumarłymi na ulicach miasta Morg. Opanuj klątwę, by poznać jej tajemnice."
description russian "Очистите улицы города Морг от заполонившей их нежити. Если хотите узнать секрет этого проклятия, встретьте его лицом к лицу."
description japanese "モーグシティの街に足を踏み入れ、アンデッドに立ち向かえ。呪いを受け入れ、その謎を解き明かせ"
description mexicanspanish "Recorre las calles de Morg City para combatir a los no muertos. Abraza la maldición para descubrir sus misterios."
description portuguese "Leve o combate aos mortos-vivos para as ruas de Morg City. Abrace a maldição para descobrir seus mistérios."
description arabic ".ﺔﻀﻣﺎﻐﻟا ﺎﻫﺭﺍﺮﺳأ ﻒﺸﺘﻜﺗ ﻲﻜﻟ ﺔﻨﻌﻠﻟا ﻞﺒﻘﺗ .ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﻞﺗﺎﻘﺘﻟ ﻍﺭﻮﻣ ﺔﻨﻳﺪﻣ ﻉﺭﺍﻮﺷ ﻲﻓ ﻖﻠﻄﻧا"
description traditionalchinese "踏上莫格市的街道對抗殭屍。面對詛咒並找出它的神秘。"
description simplifiedchinese "前往摩根城与不死僵尸战斗。拥抱诅咒才能查出最终的秘密。"
icon img_t7_menu_zm_preview_zod
filter playermatch
unlockxp 0

category zm_factory
sessionmode zm
name english "The Giant"
name englisharabic "The Giant"
name french "The Giant"
name italian "The Giant"
name german "The Giant"
name spanish "The Giant"
name polish "The Giant"
name russian "The Giant"
name japanese "THE GIANT"
name mexicanspanish "The Giant"
name portuguese "The Giant"
name arabic "The Giant"
name traditionalchinese "The Giant"
name simplifiedchinese "The Giant"
description english "Re-awaken The Giant. Return to the secret facility where it all began, and strike at the heart of the zombie scourge."
description englisharabic "Re-awaken The Giant. Return to the secret facility where it all began, and strike at the heart of the zombie scourge."
description french "Réveillez le géant. Retournez au complexe secret où tout a commencé et frappez au cœur du fléau zombie."
description italian "Risveglia il gigante. Torna nella struttura segreta dove tutto ha avuto inizio e colpisci al cuore il flagello degli zombi."
description german "Der Riese ist wieder erwacht. Kehren Sie in die geheime Einrichtung zurück, in der alles begann, und stoßen Sie in das Herz der Zombieepidemie vor."
description spanish "Despierta de nuevo al gigante. Vuelve a las instalaciones secretas en las que empezó todo y apunta al corazón de la plaga zombi."
description polish "Obudź Olbrzyma. Wróć do tajnego obiektu, w którym to wszystko się zaczęło i uderz w samo serce plagi zombie."
description russian "Разбудите Великана. Вернитесь в секретную лабораторию, в которой все началось, чтобы нанести ордам зомби смертельный удар."
description japanese "巨人が再び目覚める。全てが始まった秘密の施設に戻り、ゾンビどもの中枢を叩け"
description mexicanspanish "Despierta de nuevo al gigante. Vuelve a las instalaciones secretas en las que empezó todo y apunta al corazón de la plaga zombi."
description portuguese "Reviva o gigante. Retorne ao complexo secreto onde tudo começou, e ataque o coração da praga zumbi."
description arabic ".ﺎﻫﺭﺍد ﺮﻘﻋ ﻲﻓ ﻲﺒﻣﻭﺰﻟا ﺵﻮﺣو ﻰﻟإ ﻚﺘﺑﺮﺿ ﻪﺟﻭو ،ﻪﺘﻣﺮﺑ ﺮﻣﻷا ﺃﺪﺑ ﺚﻴﺣ ﻱﺮﺴﻟا ﻰﻨﺒﻤﻟا ﻰﻟإ ﺪﻋ .ﻕﻼﻤﻌﻟا ﻅﺎﻘﻳإ ﺪﻋأ"
description traditionalchinese "再度喚醒巨人。回到開始一切事件的秘密設施，並攻擊殭屍災禍的核心。"
description simplifiedchinese "重新唤醒巨人。回到这一切开始的那座秘密工厂，直捣僵尸天灾的核心。"
icon img_mapvote_zm_factory
filter playermatch
dlcname dlc0zm
unlockxp 0

category zm_castle
sessionmode zm
name english "Der Eisendrache"
name englisharabic "Der Eisendrache"
name french "Der Eisendrache"
name italian "Der Eisendrache"
name german "Der Eisendrache"
name spanish "Der Eisendrache"
name polish "Der Eisendrache"
name russian "Der Eisendrache"
name japanese "Der Eisendrache"
name mexicanspanish "Der Eisendrache"
name portuguese "Der Eisendrache"
name arabic "Der Eisendrache"
name traditionalchinese "Der Eisendrache"
name simplifiedchinese "Der Eisendrache"
description english "Bound together by a fragile alliance, our heroes pursue the scattered remnants of Group 935 to their mountain top fortress in the Austrian Alps..."
description englisharabic "Bound together by a fragile alliance, our heroes pursue the scattered remnants of Group 935 to their mountain top fortress in the Austrian Alps..."
description french "Liés par une fragile alliance, nos héros suivirent les restes du Groupe 935 jusqu'à leur forteresse au sommet d'une montagne des Alpes autrichiennes... "
description italian "Uniti da una fragile alleanza, i nostri eroi seguono le tracce del gruppo 935 fino alla loro fortezza sulle Alpi austriache..."
description german "Vereint durch eine brüchige Allianz verfolgen unsere Helden die verbliebenen Mitglieder von Gruppe 935 in ihre Festung mitten in den österreichischen Alpen ..."
description spanish "Unidos por una frágil alianza, nuestros héroes persiguen a los miembros dispersos del Grupo 935 hasta su fortaleza en lo alto de una montaña de los Alpes austríacos..."
description polish "Połączeni kruchym sojuszem, nasi bohaterowie ścigają ocalałych członków Grupy 935 w ich górskiej fortecy w Austriackich Alpach..."
description russian "Герои, заключившие между собой недолговечный союз, преследуют разбросанных членов группы 935, остатки которой направляются к крепости на вершине австрийских Альп..."
description japanese "危うい同盟関係のもと、あの男たちは935部隊の痕跡を追ってオーストリアアルプス山頂の要塞へと向かう..."
description mexicanspanish "Unidos por una frágil alianza, nuestros héroes persiguen a los miembros dispersos del Grupo 935 hasta su fortaleza en lo alto de una montaña de los Alpes austríacos..."
description portuguese "Unidos por uma frágil aliança, nossos heróis seguem os membros restantes do grupo 935 até sua fortaleza no topo de uma montanha nos Alpes Austríacos..."
description arabic "...ﺔﻳﻭﺎﺴﻤﻨﻟا ﺐﻟﻷا ﻝﺎﺒﺟ ﻰﻠﻋأ ﺓﺩﻮﺟﻮﻤﻟا ﻢﻬﺘﻌﻠﻗ ﻰﻟإ 935 ﺔﻋﻮﻤﺠﻣ ﻦﻣ ﺓﺮﺛﺎﻨﺘﻤﻟا ﺎﻳﺎﻘﺒﻟا ﺎﻨﻟﺎﻄﺑأ ﺩﺭﺎﻄﻳ ،ﺶﻫ ﻒﻟﺎﺤﺘﺑ ﺔﻳﻮﺳ ﻦﻴﻔﺗﺎﻜﺘﻣ"
description traditionalchinese "在薄弱的結盟關係之下，我們的英雄們一路追查935隊的碎裂殘骸，來到他們在奧地利阿爾卑斯山的山頂要塞…"
description simplifiedchinese "通过一个脆弱的盟约团结在一起，我们的英雄们追踪着935集团的残部，来到了奥地利阿尔卑斯山顶的森林中。"
icon img_mapvote_zm_castle
filter playermatch
dlcname dlc1
unlockxp 0

category zm_island
sessionmode zm
name english "Zetsubou no Shima"
name englisharabic "Zetsubou no Shima"
name french "Zetsubou no Shima"
name italian "Zetsubou No Shima"
name german "Zetsubou no Shima"
name spanish "Zetsubou no Shima"
name polish "Zetsubou no Shima"
name russian "Zetsubou no Shima"
name japanese "Zetsubou no Shima"
name mexicanspanish "Zetsubou no Shima"
name portuguese "Zetsubou no Shima"
name arabic "Zetsubou no Shima"
name traditionalchinese "Zetsubou no Shima"
name simplifiedchinese "Zetsubou no Shima"
description english "On a remote Island in the Pacific, a mysterious facility hides the secrets behind Division 9’s sinister experiments…"
description englisharabic "On a remote Island in the Pacific, a mysterious facility hides the secrets behind Division 9’s sinister experiments…"
description french "Sur une île lointaine du Pacifique, un mystérieux site abrite les secrets qui se cachent derrière les sinistres expérimentations de la Division 9... "
description italian "Su una remota isola del pacifico, una misteriosa struttura nasconde i segreti dei terribili esperimenti della divisione 9..."
description german "Auf einer abgelegenen Pazifikinsel sind in einer mysteriösen Einrichtung die Geheimnisse der finsteren Experimente von Abteilung 9 versteckt ..."
description spanish "En una remota isla del pacífico, una misteriosa instalación oculta los secretos de los siniestros experimentos de la división 9."
description polish "Na odległej wyspie na Oceanie Spokojnym, tajemniczy obiekt skrywa sekrety przerażających eksperymentów Oddziału 9..."
description russian "Секретный объект на далеком тихоокеанском острове, где хранятся тайны зловещих экспериментов Отдела 9..."
description japanese "太平洋に浮かぶ孤島の謎めいた施設に、第九師団の恐ろしい実験にまつわる秘密が隠されている..."
description mexicanspanish "En una remota isla del Pacífico, una misteriosa instalación oculta los secretos de los siniestros experimentos de la división 9."
description portuguese "Em uma ilha remota no Pacífico, um complexo misterioso oculta os segredos das experiências sinistras da Divisão 9..."
description arabic "...ﻪﻠﺧﺍﺪﺑ 9 ﺔﺒﻴﺘﻜﻟا ﺎﻬﺗﺮﺟأ ﻲﺘﻟا ﺔﻣﻭﺆﺸﻤﻟا ﺕﺍﺭﺎﺒﺘﺧﻻا ﺭﺍﺮﺳأ ﺾﻣﺎﻏ ﻰﻨﺒﻣ ﺊﺒﺨﻳ ،ﺉﺩﺎﻬﻟا ﻂﻴﺤﻤﻟا ﻲﻓ ﺔﻴﺋﺎﻧ ﺓﺮﻳﺰﺟ ﻰﻠﻋ"
description traditionalchinese "在太平洋一座偏遠島嶼上，一座神秘設施隱藏著第九師團邪惡實驗背後的秘密…"
description simplifiedchinese "太平洋中一个荒远的小岛上，一个神秘设施里，暗藏着第九师团罪恶实验背后的秘密……"
icon img_t7_menu_zm_preview_island
filter playermatch
dlcname dlc2
unlockxp 0

category zm_stalingrad
sessionmode zm
name english "Gorod Krovi"
name englisharabic "Gorod Krovi"
name french "Gorod Krovi"
name italian "Gorod Krovi"
name german "Gorod Krovi"
name spanish "Gorod Krovi"
name polish "Gorod Krovi"
name russian "Gorod Krovi"
name japanese "Gorod Krovi"
name mexicanspanish "Gorod Krovi"
name portuguese "Gorod Krovi"
name arabic "Gorod Krovi"
name traditionalchinese "Gorod Krovi"
name simplifiedchinese "Gorod Krovi"
description english "As their journey nears its end, our heroes must battle ancient beasts in the war torn ruins of Stalingrad..."
description englisharabic "As their journey nears its end, our heroes must battle ancient beasts in the war torn ruins of Stalingrad..."
description french "Alors que leur périple touche à sa fin, nos héros doivent affronter des bêtes ancestrales dans les ruines dévastées de Stalingrad..."
description italian "Ormai prossimi alla fine del loro viaggio, i nostri eroi devono affrontare antichi mostri in una Stalingrado martoriata dalla guerra..."
description german "Kurz vor Ende ihrer Reise müssen sich unsere Helden antiken Untieren in den vom Krieg gezeichneten Ruinen Stalingrads stellen."
description spanish "A punto de concluir su viaje, nuestros héroes deberán enfrentarse a bestias ancestrales en las ruinas asoladas por la guerra de Stalingrado..."
description polish "Ich podróż dobiega końca. W ruinach zniszczonego wojną Stalingradu, nasi bohaterowie walczyć będą z antyczną bestią..."
description russian "Путешествие наших героев приближается к концу. Теперь им предстоит дать бой древним чудовищам среди руин опустошенного войной Сталинграда…"
description japanese "旅の終わりが近づく中、あの男たちが戦争で廃墟と化したスターリングラードで古代のビーストに立ち向かう…"
description mexicanspanish "A punto de concluir su viaje, nuestros héroes deberán enfrentarse a bestias ancestrales en las ruinas asoladas por la guerra de Stalingrado..."
description portuguese "Com sua jornada chegando ao fim, nossos heróis devem enfrentar feras ancestrais nas ruínas destruídas de Stalingrado..."
description arabic "...ﺏﺮﺤﻟا ﺎﻬﺘﻗﺰﻣ ﻲﺘﻟا ﺩﺍﺮﻐﻨﻴﻟﺎﺘﺳ ﺽﺎﻘﻧأ ﻦﻴﺑ ﺔﻤﻳﺪﻗ ﺵﻮﺣو ﺔﻠﺗﺎﻘﻣ ﺎﻨﻟﺎﻄﺑأ ﻰﻠﻋ ﺐﺟﻮﺘﻳ ،ﺎﻬﺘﻳﺎﻬﻧ ﻦﻣ ﻢﻬﺘﻠﺣر ﺏﺍﺮﺘﻗا ﻊﻣ"
description traditionalchinese "在旅途即將抵達終點時，我們的英雄們得在史達林格勒飽受戰亂摧殘的廢墟中迎戰上古野獸…"
description simplifiedchinese "他们的旅程即将结束，在饱受战火摧残的斯大林格勒的废墟中，我们的英雄们将与远古巨兽殊死一战......"
icon img_t7_menu_zm_preview_dlc3
filter playermatch
dlcname dlc3
unlockxp 0

category zm_genesis
sessionmode zm
name english "Revelations"
name englisharabic "Revelations"
name french "Revelations"
name italian "Revelations"
name german "Revelations"
name spanish "Revelations"
name polish "Revelations"
name russian "Revelations"
name japanese "Revelations"
name mexicanspanish "Revelations"
name portuguese "Revelations"
name arabic "Revelations"
name traditionalchinese "Revelations"
name simplifiedchinese "Revelations"
description english "The time has come to join Doctor Monty in The House, where an ancient evil threatens the survival of our heroes' immortal souls..."
description englisharabic "The time has come to join Doctor Monty in The House, where an ancient evil threatens the survival of our heroes' immortal souls..."
description french "L'heure est venue de rejoindre le Docteur Monty dans la Maison, où un mal ancestral met en péril la survie des âmes immortelles de nos héros..."
description italian "È il momento di raggiungere il dottor Monty nella Casa, dove un'antica entità malvagia minaccia la sopravvivenza delle anime immortali dei nostri eroi..."
description german "Die Zeit ist gekommen, Doktor Monty im Haus zu besuchen, wo ein alter Feind die unsterblichen Seelen unserer Helden bedroht ..."
description spanish "Ha llegado la hora de unirse al doctor Monty en La casa, donde un antiguo mal amenaza la supervivencia de las almas inmortales de nuestros héroes..."
description polish "Nadszedł czas, by dołączyć do doktora Montiego w Domu, gdzie starożytne zło zagraża nieśmiertelnym duszom naszych bohaterów... "
description russian "Пришла пора присоединиться к доктору Монти в Доме и сразиться с древним злом, чтобы спасти бессмертные души наших героев."
description japanese "ついにドクター・モンティと対峙するときがやってきた。かの家で、古代の邪悪な存在があの男たちの不死の魂を脅かす..."
description mexicanspanish "Es hora de unirse al doctor Monty en La casa, donde un antiguo mal amenaza la supervivencia de las almas inmortales de nuestros héroes..."
description portuguese "Chegou a hora de se juntar ao Doutor Monty na Casa, onde um mal antigo ameaça a sobrevivência das almas imortais dos nossos heróis..."
description arabic "...ﺔﻴﻧﺎﻔﻟا ﺎﻨﻟﺎﻄﺑأ ﺡﺍﻭﺭأ ﺩﺪﻬﻳ ﻢﻳﺪﻗ ﺮﺷ ﻊﺒﻘﻳ ﺚﻴﺣ ،The House ﻲﻓ ﻲﺘﻧﻮﻣ ﺭﻮﺘﻛﺪﻟ ﻡﺎﻤﻀﻧﻼﻟ ﺖﻗﻮﻟا ﻥﺎﺣ"
description traditionalchinese "終於來到「屋子」會合蒙提博士這個重要時刻，古老惡靈在內蠢蠢欲動，威脅我們英雄的不朽靈魂…"
description simplifiedchinese "终于到时候与蒙蒂博士在“房子”里会合了。在这里，一个远古恶魔威胁着我们英雄们不朽灵魂的存亡……"
icon img_t7_menu_zm_preview_genesis
filter playermatch
dlcname dlc4
unlockxp 0

category zm_prototype
sessionmode zm
name english "Nacht Der Untoten"
name englisharabic "Nacht Der Untoten"
name french "Nacht Der Untoten"
name italian "Nacht Der Untoten"
name german "Nacht der Untoten"
name spanish "Nacht Der Untoten"
name polish "Nacht Der Untoten"
name russian "Nacht Der Untoten"
name japanese "NACHT DER UNTOTEN"
name mexicanspanish "Nacht Der Untoten"
name portuguese "Nacht Der Untoten"
name arabic "Nacht Der Untoten"
name traditionalchinese "Nacht Der Untoten"
name simplifiedchinese "Nacht Der Untoten"
description english "You drove them deep into the heart of the Reich. You thought they were dead. You were wrong."
description englisharabic "You drove them deep into the heart of the Reich. You thought they were dead. You were wrong."
description french "Vous les aviez affrontés au coeur du Reich. Vous croyiez qu'ils étaient morts. Vous aviez tort."
description italian "Li hai respinti fino al cuore del Reich. Pensavi che fossero morti. Ti sbagliavi."
description german "Das Grauen des Krieges ist noch nicht vorbei. Die besiegten Gegner sind nicht wirklich tot!"
description spanish "Los condujiste hasta el corazón del Reich. Creías que estaban muertos. Te equivocabas."
description polish "Zapędziłeś ich daleko w głąb Rzeszy. Myślałeś, że zginęli. Myliłeś się."
description russian "Вы проникли в самое сердце Рейха. Вы считали их мертвыми. Вы ошибались."
description japanese "帝国の軍勢をついにその中枢にまで追い詰めたとき、死んだはずの敵兵士がうごめき出した"
description mexicanspanish "Los condujiste hasta el corazón del Reich. Creías que estaban muertos. Te equivocabas."
description portuguese "Você os guiou exatamente para o coração do Reich. Você achou que eles estavam mortos. Foi um erro."
description arabic ".ًﺎﺌﻄﺨﻣ ﺖﻨﻛ ﻚﻨﻜﻟ .ﻰﺗﻮﻣ ﻢﻬﻨﻈﺗ ﺖﻨﻛ .ﺦﻳﺍﺮﻟا ﻕﺎﻤﻋأ ﻰﻟإ ﻢﻬﺘﻌﻓد ﺪﻘﻟ"
description traditionalchinese "你將他們驅逐至第三帝國的核心。你以為他們已經安息，你錯了。"
description simplifiedchinese "你追击敌人进入了帝国的深处。你以为它们已经死了……你错了。"
icon img_t7_menu_zm_preview_prototype
filter playermatch
dlcname dlc5
unlockxp 0

category zm_asylum
sessionmode zm
name english "Verrückt"
name englisharabic "Verrückt"
name french "Verrückt"
name italian "Verrückt"
name german "Verrückt"
name spanish "Verrückt"
name polish "Verrückt"
name russian "Verrückt"
name japanese "VERRÜCKT"
name mexicanspanish "Verrückt"
name portuguese "Verrückt"
name arabic "Verrückt"
name traditionalchinese "Verrückt"
name simplifiedchinese "Verrückt"
description english "Electroshock therapy. Chemically engineered beverages. Hordes of undead Nazis. Find the power to unite and send them back to their graves!"
description englisharabic "Electroshock therapy. Chemically engineered beverages. Hordes of undead Nazis. Find the power to unite and send them back to their graves!"
description french "Thérapie à base d'électrochocs. Boissons créées chimiquement. Des hordes de zombies nazis. Réussissez à unir vos forces pour les renvoyer dans leurs tombes !"
description italian "Elettroshock terapeutico, bevande chimicamente alterate, orde di nazisti non-morti... Trova la forza di fare squadra e rispediscili nelle loro tombe!"
description german "Elektroschock-Therapie. Chemisch hergestellte Getränke. Jede Menge Untote. Schicken Sie sie zurück in ihre Gräber!"
description spanish "Terapia de choque. Pociones diseñadas en laboratorio. Hordas de nazis no muertos. ¡Encuentra el poder para reunirlos y enviarlos a todos de vuelta a sus tumbas!"
description polish "Terapia szokowa. Chemicznie wzmocnione napoje. Setki nieumarłych nazistów. Połączcie swoje siły i odeślijcie ich do grobu!"
description russian "Электрошоковая терапия. Химические препараты. Орды нацистских зомби. Найдите способ объединить все это и отправьте мертвецов обратно в могилы!"
description japanese "電気ショック療法、化学的に作られた飲み物、そしてアンデッドナチスの大群。奴らをまとめて墓に送る力を探せ！"
description mexicanspanish "Terapia de choque. Pociones diseñadas en laboratorio. Hordas de nazis no muertos. ¡Encuentra el poder para reunirlos y enviarlos a todos de vuelta a sus tumbas!"
description portuguese "Terapia de eletrochoque. Bebidas quimicamente modificadas. Hordas de mortos-vivos nazistas. Encontre o poder para unir e enviar todos de volta para seus túmulos!"
description arabic "!ﻢﻫﺭﻮﺒﻗ ﻰﻟإ ﻢﻫﻭﺪﻴﻋﺃو ﺍﻭﺪﺤﺗﺍو ﻢﻜﺗﻮﻗ ﺍﻮﻌﻤﺠﺘﺳا .ﻦﻴﻳﺯﺎﻨﻟا ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﻦﻣ ﻞﻓﺎﺤﺟ .ﺔﻴﺋﺎﻴﻤﻴﻜﻟا ﺔﺳﺪﻨﻬﻟﺎﺑ ﺔﺠﻟﺎﻌﻣ ﺕﺎﺒﻃﺮﻣ .ﺔﻴﺋﺎﺑﺮﻬﻜﻟا ﺕﺎﻣﺪﺼﻟﺎﺑ ﺝﻼﻋ"
description traditionalchinese "電擊療法。化工飲料。大群不死納粹。協力將他們送回墳墓吧！"
description simplifiedchinese "电击疗法、化工饮料、纳粹僵尸。众志成城，将恶魔送回坟墓！"
icon img_t7_menu_zm_preview_asylum
filter playermatch
dlcname dlc5
unlockxp 0

category zm_cosmodrome
sessionmode zm
name english "Ascension"
name englisharabic "Ascension"
name french "Ascension"
name italian "Ascension"
name german "Ascension"
name spanish "Ascension"
name polish "Ascension"
name russian "Ascension"
name japanese "ASCENSION"
name mexicanspanish "Ascension"
name portuguese "Ascension"
name arabic "Ascension"
name traditionalchinese "Ascension"
name simplifiedchinese "Ascension"
description english "The risen dead have overtaken a Soviet cosmodrome and all Hell has broken loose. The countdown to the zombie apocalypse has begun."
description englisharabic "The risen dead have overtaken a Soviet cosmodrome and all Hell has broken loose. The countdown to the zombie apocalypse has begun."
description french "Les morts-vivants ont semé la panique en prenant le contrôle d'un cosmodrome soviétique. Le compte à rebours de l'apocalypse zombie a commencé."
description italian "I morti viventi hanno occupato un cosmodromo sovietico, scatenando l'inferno. Il conto alla rovescia per l'apocalisse zombi è iniziato."
description german "Die Untoten haben einen sowjetischen Weltraumbahnhof übernommen und die Hölle ist ausgebrochen. Der Countdown bis zur Zombie-Apokalypse hat begonnen."
description spanish "Los muertos vivientes han invadido un cosmódromo soviético y se ha desatado un infierno. La cuenta atrás para el apocalipsis zombi ha comenzado."
description polish "Nieumarli opanowali rosyjski kosmodrom i robią tam piekło. Rozpoczęło się odliczanie do apokalipsy zombie."
description russian "Восставшие мертвецы устроили ад на советском космодроме. Отсчет до старта зомби-апокалипсиса пошел."
description japanese "ソビエトの宇宙基地が蘇ったゾンビたちに乗っ取られ、混乱が生じている。今ゾンビ戦争へのカウントダウンが始まった"
description mexicanspanish "Los muertos vivientes invadieron un cosmódromo soviético y se desató un infierno. La cuenta atrás para el apocalipsis zombi empezó."
description portuguese "Os mortos-vivos tomaram conta de um cosmódromo soviético e o caos está por toda parte. A contagem regressiva para o apocalipse zumbi começou."
description arabic ".ﻢﻟﺎﻌﻠﻟ ﻲﺒﻣﻭﺰﻟا ﺵﻮﺣو ﻭﺰﻐﻟ ﻲﻟﺯﺎﻨﺘﻟا ﺪﻌﻟا ﺃﺪﺑ ﺪﻘﻟ .ﺔﻣﺭﺎﻌﻟا ﻰﺿﻮﻔﻠﻟ ﻥﺎﻨﻌﻟا ﺍﻮﻘﻠﻃﺃو ﺔﻴﺘﻴﻴﻓﻮﺳ ﺔﻴﺋﺎﻀﻓ ﻕﻼﻃإ ﺔﻄﺤﻣ ﻰﻠﻋ ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﻰﻟﻮﺘﺳا"
description traditionalchinese "死而復生的殭屍佔據了蘇聯航天發射場，一發不可收拾。殭屍末日喪鐘的倒數已經開始。"
description simplifiedchinese "复活的死尸已经占据苏联卫星发射基地，尸相环生。僵尸灭世的倒计时已经开始。"
icon img_t7_menu_zm_preview_cosmodrome
filter playermatch
dlcname dlc5
unlockxp 0

category zm_moon
sessionmode zm
name english "Moon"
name englisharabic "Moon"
name french "Moon"
name italian "Moon"
name german "Moon"
name spanish "Moon"
name polish "Moon"
name russian "Moon"
name japanese "MOON"
name mexicanspanish "Moon"
name portuguese "Moon"
name arabic "Moon"
name traditionalchinese "Moon"
name simplifiedchinese "Moon"
description english "I believe that this nation should commit itself to achieving the goal, before this decade is out, of landing a man on the moon and returning him safely to the Earth. (JFK, 1961)"
description englisharabic "I believe that this nation should commit itself to achieving the goal, before this decade is out, of landing a man on the moon and returning him safely to the Earth. (JFK, 1961)"
description french "Je pense que notre nation doit s'engager à atteindre l'objectif, avant la fin de cette décennie, d'envoyer un homme sur la Lune et le ramener sur Terre sain et sauf. (JFK, 1961)"
description italian "Credo che il paese debba impegnarsi per raggiungere l'obiettivo, prima della fine di questo decennio, di far scendere un uomo sulla Luna e di riportarlo a Terra sano e salvo. (JFK, 1961)"
description german "Ich glaube, dass diese Nation das Ziel haben sollte, noch vor Ende dieses Jahrzehnts einen Menschen auf den Mond zu schicken und ihn wieder sicher zur Erde zurückzubringen. (JFK, 1961)"
description spanish "Creo que esta nación debería comprometerse a alcanzar la meta de llevar un hombre a la Luna y traerlo de vuelta a salvo a la Tierra antes de que termine esta década. (JFK, 1961)"
description polish "Wierzę, że nasz naród powinien skupić się na celu, którym jest lądowanie człowieka na Księżycu i jego bezpieczny powrót na Ziemię jeszcze przed końcem tej dekady. (JFK, 1961)"
description russian "Я полагаю, что наша страна должна принять на себя обязательство в достижении следующей цели - до конца этого десятилетия доставить человека на Луну и безопасно вернуть его на Землю. (Дж. Ф. Кеннеди, 1961)"
description japanese "我が国は、人を月面に着陸させ、無事に帰還させるという目標を、今後10年以内に達成することを約束すべきであると、私は信じています(ジョン・F・ケネディ - 1961)"
description mexicanspanish "Creo que esta nación debería comprometerse a alcanzar la meta de llevar un hombre a la Luna y traerlo de vuelta a salvo a la Tierra antes de que termine esta década. (JFK, 1961)"
description portuguese "Creio que essa nação deveria se comprometer a alcançar a meta, antes que termine esta década, de aterrissar o homem na lua e trazê-lo de volta à Terra sem perigo. (JFK, 1961)"
description arabic "(1961 ،ﻱﺪﻴﻨﻴﻛ ﻥﻮﺟ) .ﺽﺭﻷا ﻰﻟإ ًﺎﻤﻟﺎﺳ ﻪﺗﺩﺎﻋﺇو ﺮﻤﻘﻟا ﻰﻠﻋ ﻞﺟر ﻝﺍﺰﻧﺈﺑ ﺪﻘﻌﻟا ﺍﺬﻫ ﺔﻳﺎﻬﻧ ﻞﺒﻗ ﻑﺪﻫ ﻖﻴﻘﺤﺘﺑ ﺎﻬﺴﻔﻧ ﻡﺰﻠﺗ ﻥأ ﺐﺠﻳ ﺔﻣﻷا هﺬﻫ ﻥأ ﺪﻘﺘﻋا ﻲﻨﻧإ"
description traditionalchinese "我相信這個國家應該致力達成目標，在本世紀末前將人類登陸月球並安全送返地球。（甘迺迪，1961年）"
description simplifiedchinese "我坚信这个国家应该集中力量实现这个目标，即在1970年以前，人类将乘坐宇宙飞船登陆月球并且安全返回地球。（肯尼迪，1961年）"
icon img_t7_menu_zm_preview_moon
filter playermatch
dlcname dlc5
unlockxp 0

category zm_sumpf
sessionmode zm
name english "Shi No Numa"
name englisharabic "Shi No Numa"
name french "Shi No Numa"
name italian "Shi No Numa"
name german "Shi No Numa"
name spanish "Shi No Numa"
name polish "Shi No Numa"
name russian "Shi No Numa"
name japanese "SHI NO NUMA"
name mexicanspanish "Shi No Numa"
name portuguese "Shi No Numa"
name arabic "Shi No Numa"
name traditionalchinese "Shi No Numa"
name simplifiedchinese "Shi No Numa"
description english "Maggot ridden corpses. Bug infested swamp. Hundreds of undead Imperial Army. Choose your tactic and defend for your lives!"
description englisharabic "Maggot ridden corpses. Bug infested swamp. Hundreds of undead Imperial Army. Choose your tactic and defend for your lives!"
description french "Des cadavres grouillants. Des marais infestés de bestioles. Des milliers de morts-vivants de l'armée impériale. Choisissez une tactique et sauvez votre peau !"
description italian "Cadaveri infestati dai vermi, paludi piene di insetti, centinaia di soldati dell'Esercito imperiale morti... Scegli una tattica e lotta per le tua vita!"
description german "Von Maden zerfressene Leichen. Ein mit Insekten verseuchter Sumpf. Jede Menge untoter Zombies. Wählen Sie Ihre Strategie und retten Sie Ihr Leben!"
description spanish "Cuerpos atestados de gusanos. Un pantano infestado de insectos. Centenares de no muertos del Ejército Imperial. ¡Elige tu táctica y defiende tu vida!"
description polish "Zwłoki pożerane przez robaki. Bagno pełne owadów. Setki nieumarłych z armii imperialnej. Wybierz taktykę i walcz o swe życie!"
description russian "Полуразложившиеся трупы. Болото, кишащее насекомыми. Сотни мертвых солдат Империи. Выбирайте тактику и защищайтесь!"
description japanese "広大な沼地の中の野戦拠点が帝国陸軍のゾンビに囲まれた。あらゆる仕掛けを駆使して生き残れ！"
description mexicanspanish "Cuerpos atestados de gusanos. Un pantano infestado de insectos. Centenares de no muertos del Ejército Imperial. ¡Elige tu táctica y defiende tu vida!"
description portuguese "Cadáveres cheios de vermes. Pântano infestado de insetos. Centenas de mortos-vivos do Exército Imperial. Escolham sua tática e defendam suas vidas!"
description arabic "!ﻢﻜﺗﺎﻴﺣ ﻦﻋ ﺍﻮﻌﻓﺍﺩو ﻢﻜﻴﺘﻜﺗ ﺍﻭﺭﺎﺘﺧا .ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﺕﺎﺌﻣ ﻦﻣ ﻥﻮﻜﻣ ﻱﺭﻮﻃﺍﺮﺒﻣإ ﺶﻴﺟ .ﺕﺍﺮﺸﺤﻟﺎﺑ ﺙﻮﻠﻣ ﻊﻘﻨﺘﺴﻣ .ﻥﺍﺪﻳﺪﻟﺎﺑ ﺔﺌﻠﺘﻤﻣ ﺚﺜﺟ"
description traditionalchinese "滿佈蛆蟲的屍體。害蟲橫生的沼澤。數以百計的不死帝國軍。制訂戰術，為保全生命而戰！"
description simplifiedchinese "腐烂的尸体、恶臭的沼泽、成群的帝国陆军僵尸。使用战术，为了保住性命而战！"
icon img_t7_menu_zm_preview_sumpf
filter playermatch
dlcname dlc5
unlockxp 0

category zm_temple
sessionmode zm
name english "Shangri-La"
name englisharabic "Shangri-La"
name french "Shangri-La"
name italian "Shangri-La"
name german "Shangri-La"
name spanish "Shangri-La"
name polish "Shangri-La"
name russian "Shangri-La"
name japanese "SHANGRI-LA"
name mexicanspanish "Shangri-La"
name portuguese "Shangri-La"
name arabic "Shangri-La"
name traditionalchinese "Shangri-La"
name simplifiedchinese "Shangri-La"
description english "A legendary shrine lost in an exotic jungle, where the undead lurk within a treacherous labyrinth of underground caverns, deadly traps and dark secrets."
description englisharabic "A legendary shrine lost in an exotic jungle, where the undead lurk within a treacherous labyrinth of underground caverns, deadly traps and dark secrets."
description french "Un temple légendaire perdu dans une jungle exotique. Aventurez-vous dans un labyrinthe de cavernes pleines de morts-vivants, de pièges mortels et de sombres secrets."
description italian "Un tempio leggendario perso nella giungla, dove i non morti si nascondono all'interno di un insidioso labirinto fatto di caverne sotterranee, trappole mortali e oscuri segreti."
description german "Ein legendärer Schrein, tief in einem exotischen Dschungel verborgen, wo die Untoten in einem tödlichen Labyrinth unterirdischer Höhlen lauern, voller gefährlicher Fallen und düsterer Geheimnisse."
description spanish "Un santuario legendario perdido en una selva exótica. Los no muertos acechan en el interior de un traicionero laberinto conformado por cavernas subterráneas, trampas mortales y oscuros secretos."
description polish "Legendarna świątynia zagubiona w egzotycznej dżungli, pełnej nieumarłych, zagmatwanych jaskiń, niebezpiecznych pułapek i mrocznych sekretów."
description russian "Легендарное святилище в джунглях, подземные лабиринты которого скрывают мрачные тайны, смертоносные ловушки и бесчисленных живых мертвецов. "
description japanese "異国のジャングルのなかにある、失われた伝説の社。そこはアンデッドが彷徨う入り組んだ洞窟の危険な迷宮となっており、 死のワナや秘密が隠されている"
description mexicanspanish "Un santuario legendario perdido en una selva exótica. Los no muertos acechan en el interior de un traicionero laberinto conformado por cavernas subterráneas, trampas mortales y oscuros secretos."
description portuguese "Um santuário lendário perdido em uma selva exótica onde os mortos-vivos espreitam no labirinto traiçoeiro de cavernas subterrâneas, armadilhas mortais e segredos sombrios."
description arabic ".ﺔﻤﻠﻈﻣ ﺭﺍﺮﺳﺃو ﺔﻠﺗﺎﻗ ﺥﺎﺨﻓأ ﺎﻬﻨﻜﺴﺗ ﻲﺘﻟﺍو ،ﺽﺭﻷا ﺖﺤﺗ ﻑﻮﻬﻜﻟا ﻦﻣ ﺓﺭﺍﺪﻏ ﺔﻫﺎﺘﻣ ﻞﺧﺍد ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﺺﺑﺮﺘﻳ ﺚﻴﺣ ،ﺔﺒﻳﺮﻏ ﺔﺑﺎﻏ ﻲﻓ ﺄﺒﺨﻣ ﻱﺭﻮﻄﺳأ ﺢﻳﺮﺿ"
description traditionalchinese "隱藏在奇異叢林的傳奇神殿，而不死殭屍在這個遍佈地下洞穴、死亡陷阱和暗黑秘密的凶險迷宮裡蠢蠢欲動。"
description simplifiedchinese "坐落于异国丛林中的遗失的神殿。僵尸暗藏在由地下洞穴、致命陷阱和黑暗秘密组成的迷宫之中。"
icon img_t7_menu_zm_preview_temple
filter playermatch
dlcname dlc5
unlockxp 0

category zm_theater
sessionmode zm
name english "Kino Der Toten"
name englisharabic "Kino Der Toten"
name french "Kino Der Toten"
name italian "Kino Der Toten"
name german "Kino der Toten"
name spanish "Kino Der Toten"
name polish "Kino Der Toten"
name russian "Kino Der Toten"
name japanese "KINO DER TOTEN"
name mexicanspanish "Kino Der Toten"
name portuguese "Kino Der Toten"
name arabic "Kino Der Toten"
name traditionalchinese "Kino Der Toten"
name simplifiedchinese "Kino Der Toten"
description english "Battle the undead in this theatrical installment of \"Zombies\". New twists and clues could uncover the final plan. It's show time!"
description englisharabic "Battle the undead in this theatrical installment of \"Zombies\". New twists and clues could uncover the final plan. It's show time!"
description french "Venez à bout de hordes de morts-vivants dans cette nouvelle aventure Zombies. Cherchez des indices, dénouez l'intrigue, et que le spectacle commence !"
description italian "Combatti i non morti in questa incredibile modalità Zombi. Nuovi indizi e sviluppi imprevisti potrebbero rivelare il piano finale. Si va in scena!"
description german "Kämpfen Sie gegen die Untoten in dieser kinoreifen Folge von \"Zombies\". Neue Wendungen und Hinweise könnten den finalen Plan offenbaren. Es ist Showtime!"
description spanish "Combate a los no muertos en esta entrega dramática de \"Zombis\". Nuevas pistas y enredos podrían desvelar el plan definitivo. ¡Es la hora del espectáculo!"
description polish "Walcz z nieumarłymi wśród teatralnej scenografii w nowej odsłonie \"Zombie\". Nowe zagrania i wskazówki mogą ujawnić ich plan. Kurtyna w górę!"
description russian "Бой с нежитью в декорациях театра зомби. Неожиданные повороты сюжета содержат намеки на финальный план. Шоу начинается!"
description japanese "謎めいた劇場を舞台にゾンビと対決。帝国の最終計画に君はどこまで迫れるか？"
description mexicanspanish "Combate a los no muertos en esta entrega dramática de \"Zombis\". Nuevas pistas y enredos podrían revelar el plan definitivo. ¡Es la hora del espectáculo!"
description portuguese "Lute contra mortos-vivos nesse episódio cinematográfico de \"Zumbis\". Novas reviravoltas e pistas podem revelar o plano final. É hora do show!"
description arabic "!ﺽﺮﻌﻟا ﺖﻗو ﻥﺎﺣ .ﺓﺮﻴﺧﻷا ﺔﻄﺨﻟا ﺕﺎﺌﺟﺎﻔﻤﻟﺍو ﺔﻟﺩﻷا ﻒﺸﻜﺗ ﺪﻗ ."\ﻲﺒﻣﻭﺰﻟا"\  ﻢﻠﻴﻔﻟ ﻲﺣﺮﺴﻤﻟا ﺽﺮﻌﻟا ﺍﺬﻫ ﻲﻓ ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﻞﺗﺎﻗ"
description traditionalchinese "在這部《殭屍》劇場中大戰不死軍團。新線索和變化會逐漸揭露最終計劃。好戲開場了！"
description simplifiedchinese "在这部僵尸大片中迎战僵尸。新的转折和线索将会揭示最终的计划。好戏开场了！"
icon img_t7_menu_zm_preview_theater
filter playermatch
dlcname dlc5
unlockxp 0

category zm_tomb
sessionmode zm
name english "Origins"
name englisharabic "Origins"
name french "Origins"
name italian "Origins"
name german "Origins"
name spanish "Origins"
name polish "Origins"
name russian "Origins"
name japanese "ORIGINS"
name mexicanspanish "Origins"
name portuguese "Origins"
name arabic "Origins"
name traditionalchinese "Origins"
name simplifiedchinese "Origins"
description english "Witness the origins of Group 935, as an ancient evil is unleashed upon the battlefields of World War I."
description englisharabic "Witness the origins of Group 935, as an ancient evil is unleashed upon the battlefields of World War I."
description french "Assistez à la formation du groupe 935, tandis qu'un être maléfique ancien fait des ravages sur les champs de bataille de la Première Guerre mondiale."
description italian "Scopri le origini del gruppo 935 mentre un'antica entità malvagia si abbatte sui campi di battaglia della Prima Guerra Mondiale."
description german "Erleben Sie die Anfänge der Gruppe 935, während eine uralte böse Macht auf die Schlachtfelder des ersten Weltkrieges losgelassen wird."
description spanish "Presencia los orígenes del Grupo 935 mientras un mal ancestral se desata sobre los campos de batalla de la Primera Guerra Mundial."
description polish "Zobacz jak powstała grupa 935, po pojawieniu się starożytnego zła na polach bitew I wojny światowej."
description russian "Узнайте про Группу 935 и древнее зло, выпущенное на поля сражений Первой мировой войны."
description japanese "935部隊の起源を目撃せよ。第一次世界大戦の戦場に悪が解き放たれる"
description mexicanspanish "Presencia los orígenes del Grupo 935 mientras un mal ancestral se desata sobre los campos de batalla de la Primera Guerra Mundial."
description portuguese "Testemunhe as origens do grupo 935 quando um mal antigo é lançado nos campos de batalha de Primeira Guerra Mundial."
description arabic ".ﻰﻟﻭﻷا ﺔﻴﻤﻟﺎﻌﻟا ﺏﺮﺤﻟا ﻝﺎﺘﻗ ﺕﺎﺣﺎﺳ ﻰﻠﻋ ﻢﻳﺪﻗ ﺮﺷ ﺮﻋﺬﻟا ﺮﺸﻨﻳ ﺎﻤﻨﻴﺑ ،935 ﺔﻋﻮﻤﺠﻤﻟا ﻝﻮﺻأ ﻰﻠﻋ ﻑّﺮﻌﺗ"
description traditionalchinese "在遠古邪靈於一戰戰場上肆虐的同時見證935小組的崛起。"
description simplifiedchinese "对抗肆虐于一战战场的远古恶魔，见证935部队的开端。"
icon img_t7_menu_zm_preview_tomb
filter playermatch
dlcname dlc5
unlockxp 0

///////////////////////////////////////////////////////////////////////////
//    CAMPAIGN CATEGORIES
///////////////////////////////////////////////////////////////////////////

category cp_public
sessionmode cp
name english "CP PLAYLIST" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "CP PLAYLIST"
name french "SÉLECTION CP"
name italian "PLAYLIST CP"
name german "KP-LISTE"
name spanish "LISTA DE PARTIDAS CP"
name polish "CP PUBLIC"
name russian "СПИСОК ИГР КАМПАНИИ"
name japanese "CPプレイリスト"
name mexicanspanish "LISTA DE PARTIDAS CP"
name portuguese "LISTA DE JOGOS CP"
name arabic "ﺔﺼﻘﻟا ﺭﻮﻃ ﺐﻌﻟ ﺔﻣﺎﻗ"
name traditionalchinese "戰役遊戲清單"
name simplifiedchinese "合作游戏列表"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
icon playlist_generic_01
filter playermatch
unlockxp 0

category cp_nightmares_public
sessionmode cp
name english "CP NIGHTMARES PUBLIC PLAYLIST" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "CP NIGHTMARES PUBLIC PLAYLIST"
name french "CP NIGHTMARES PUBLIC PLAYLIST"
name italian "PLAYLIST PUBBLICA INCUBI CP"
name german "KP-ALBTRAUM ÖFFENTLICHE LISTE"
name spanish "LISTA DE PARTIDAS PÚBLICAS PESADILLAS CP"
name polish "CP NIGHTMARES PUBLIC PLAYLIST"
name russian "ОТКРЫТЫЙ СПИСОК КАМПАНИИ КОШМАРЫ"
name japanese "CPナイトメア公開プレイリスト"
name mexicanspanish "LISTA DE PARTIDAS PÚBLICAS PESADILLAS CP"
name portuguese "LISTA DE JOGOS PÚBLICA PESADELOS CP"
name arabic "ﺔﻣﺎﻌﻟا ﺲﻴﺑﺍﻮﻜﻟا ﺭﻮﻃ ﺐﻌﻟ ﺔﻤﺋﺎﻗ"
name traditionalchinese "夢魘戰役公開遊戲清單"
name simplifiedchinese "合作噩梦公开游戏列表 "
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
icon playlist_generic_01
filter playermatch
unlockxp 0

///////////////////////////////////////////////////////////////////////////
//     MAPLISTS
///////////////////////////////////////////////////////////////////////////

maplist all
mp_apartments
mp_biodome
mp_chinatown
mp_ethiopia
mp_havoc
mp_infection
mp_metro
mp_redwood
mp_sector
mp_spire
mp_stronghold
mp_veiled
mp_nuketown_x
mp_redwood_ice
mp_veiled_heyday
// mp_crucible
// mp_skyjacked
// mp_waterpark
// mp_rise

maplist bigmaps
mp_apartments
mp_biodome
mp_chinatown
mp_ethiopia
mp_infection
mp_spire
mp_stronghold
// mp_waterpark
// mp_rise

maplist smallmaps
mp_nuketown_x
mp_biodome
mp_havoc
mp_sector
mp_spire
mp_stronghold
mp_veiled
// mp_skyjacked

maplist arena_ctf
mp_stronghold
mp_veiled
mp_apartments
mp_spire

maplist arena_sd
mp_veiled
mp_redwood
mp_spire
mp_ethiopia
mp_stronghold
mp_apartments
mp_infection

maplist arena_ball
mp_apartments
mp_spire
mp_infection
mp_veiled

maplist arena_koth
mp_spire
mp_stronghold
mp_veiled
mp_apartments

maplist dlc1
mp_crucible
mp_skyjacked
mp_waterpark
mp_rise

maplist dlc2
mp_aerospace
mp_banzai
mp_conduit
mp_kung_fu

maplist dlc3
mp_arena
mp_cryogen
mp_rome
mp_shrine

maplist dlc4
mp_city
mp_miniature
mp_ruins
mp_western

///////////////////////////////////////////////////////////////////////////
//    PLAYLISTS (Playlist# 1 - 128)
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
//      CORE (MP)
//      1-19 is reserved for playlists in the Core category
///////////////////////////////////////////////////////////////////////////

playlist 1
nameref PLAYLIST_PLAYLIST_TDM
descriptionref PLAYLIST_PLAYLIST_TDM_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories core
icon playlist_tdm
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
sortOrder 0
all,hs_tdm,1
dlc1,hs_tdm,1
dlc2,hs_tdm,1
dlc3,hs_tdm,1
dlc4,hs_tdm,2

playlist 2
nameref PLAYLIST_PLAYLIST_FFA
descriptionref PLAYLIST_PLAYLIST_FFA_DESC
unlockxp 0
maxparty 1
maxlocalplayers 1
categories core
icon playlist_ffa
parkingplaylist 9001
rule party_minplayers 4
rule party_maxplayers 8
// rule liveDedicatedOnly 1
sortOrder 0.1
all,hs_ffa,1
dlc1,hs_ffa,1
dlc2,hs_ffa,1
dlc3,hs_ffa,1
dlc4,hs_ffa,2

playlist 3
nameref PLAYLIST_PLAYLIST_DOM
descriptionref PLAYLIST_PLAYLIST_DOM_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories core
icon playlist_domination
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
// rule liveDedicatedOnly 1
sortOrder 0.3
all,hs_dom,1
dlc1,hs_dom,1
dlc2,hs_dom,1
dlc3,hs_dom,1
dlc4,hs_dom,2

playlist 4
nameref PLAYLIST_PLAYLIST_DEMO
descriptionref PLAYLIST_PLAYLIST_DEMO_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories core
icon playlist_demolition
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
sortOrder 0.4
all,hs_dem,1
dlc1,hs_dem,1
dlc2,hs_dem,1
dlc3,hs_dem,1
dlc4,hs_dem,2

playlist 5
nameref PLAYLIST_PLAYLIST_KC
descriptionref PLAYLIST_PLAYLIST_KC_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories core
icon playlist_kill_confirm
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
sortOrder 0.6
all,hs_conf,1
dlc1,hs_conf,1
dlc2,hs_conf,1
dlc3,hs_conf,1
dlc4,hs_conf,2

playlist 6
nameref PLAYLIST_PLAYLIST_KOTH
descriptionref PLAYLIST_PLAYLIST_KOTH_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories core
icon playlist_koth
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
sortOrder 0.7
all,hs_koth,1
dlc1,hs_koth,1
dlc2,hs_koth,1
dlc3,hs_koth,1
dlc4,hs_koth,2

playlist 7
nameref PLAYLIST_PLAYLIST_CTF
descriptionref PLAYLIST_PLAYLIST_CTF_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories core
icon playlist_ctf
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hs_ctf,1
dlc1,hs_ctf,1
dlc2,hs_ctf,1
dlc3,hs_ctf,1
dlc4,hs_ctf,2

playlist 8
nameref PLAYLIST_PLAYLIST_SD
descriptionref PLAYLIST_PLAYLIST_SD_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories core
icon playlist_search_destroy
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
// rule partyChatDisallowed 1               // rule partyChatDisallowed 1 - this will kick any player who is currently in or joined a platform party chat
sortOrder 0.2
all,hs_sd,1
dlc1,hs_sd,1
dlc2,hs_sd,1
dlc3,hs_sd,1
dlc4,hs_sd,2

playlist 9
nameref PLAYLIST_PLAYLIST_BALL
descriptionref PLAYLIST_PLAYLIST_BALL_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories core
icon playlist_ball
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hs_ball,1
dlc1,hs_ball,1
dlc2,hs_ball,1
dlc3,hs_ball,1
dlc4,hs_ball,2

playlist 10
nameref PLAYLIST_PLAYLIST_ESCORT
descriptionref PLAYLIST_PLAYLIST_ESCORT_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories core
icon playlist_escort
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
sortOrder 0.8
all,hs_escort,1
dlc1,hs_escort,1
dlc2,hs_escort,1
dlc3,hs_escort,1
dlc4,hs_escort,2

playlist 11
name english "Fracture"
name englisharabic "Fracture"
name french "Fracture"
name italian "Frattura"
name german "Fraktur"
name spanish "Fractura"
name polish "Szczelina"
name russian "Fracture"
name japanese "FRACTURE"
name mexicanspanish "Fractura"
name portuguese "Fratura"
name arabic "Fracture"
name traditionalchinese "裂縫"
name simplifiedchinese "裂缝"
description english "Collect core files dropped by killed enemies and deliver them to the Fracture Site. \n\nPlayers: 6-12"
description englisharabic "Collect core files dropped by killed enemies and deliver them to the Fracture Site. \n\nPlayers: 6-12"
description french "Récupérez les fichiers lâchés par les ennemis abattus et apportez-les au site de fracture.\n\nJoueurs : 6-12"
description italian "Ottieni i file lasciati a terra dai nemici uccisi e portali alla frattura.\n\nGiocatori: 6-12"
description german "Sammeln Sie die von Feinden fallen gelassenen Dateien und bringen Sie sie zur Fraktur.\n\nSpieler: 6-12"
description spanish "Recoge archivos de enemigos asesinados y entrégalos en la zona de fractura. \n\nJugadores: 6-12"
description polish "Zbieraj pliki, które upuścili zabici wrogowie i zanieś je do Szczeliny. \n\nGracze: 6-12"
description russian "Собирайте файлы, брошенные убитыми врагами, и доставляйте их к месту разлома. \n\nИгроки: 6-12"
description japanese "倒した敵のコアファイルを回収しフラクチャー地点へ届けろ\n\nプレイヤー数: 6-12"
description mexicanspanish "Recoge archivos de enemigos muertos y entrégalos en la zona de fractura.\n\nJugadores: 6-12"
description portuguese "Colete arquivos de sistema perdidos por inimigos mortos e entregue no local da fratura. \n\nJogadores: 6-12"
description arabic "nPlayers: 6-12\n\ .Collect core files dropped by killed enemies and deliver them to the Fracture Site"
description traditionalchinese "收集被擊殺敵人掉落的碎片並存入裂縫。\n\n玩家人數：6-12"
description simplifiedchinese "击杀敌人后捡起他们掉落的核心文件，并将它们送到裂缝点。\n\n玩家：6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories core
icon playlist_clean
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
sortOrder 0.5
// rule ui_showBonusIcon 1
all,hs_clean,1
dlc1,hs_clean,1
dlc2,hs_clean,1
dlc3,hs_clean,1
dlc4,hs_clean,2

///////////////////////////////////////////////////////////////////////////
//      HARDCORE (MP)
//      20-29 is reserved for playlists in the Hardcore category
///////////////////////////////////////////////////////////////////////////

playlist 20
nameref PLAYLIST_PLAYLIST_HC_TDM
descriptionref PLAYLIST_PLAYLIST_HC_TDM_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories hardcore
icon playlist_tdm
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hc_tdm,1
dlc1,hc_tdm,1
dlc2,hc_tdm,1
dlc3,hc_tdm,1
dlc4,hc_tdm,2

playlist 21
nameref PLAYLIST_PLAYLIST_HC_FFA
descriptionref PLAYLIST_PLAYLIST_HC_FFA_DESC
unlockxp 0
maxparty 1
maxlocalplayers 1
categories hardcore
icon playlist_ffa
parkingplaylist 9001
rule party_minplayers 4
rule party_maxplayers 8
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hc_ffa,1
dlc1,hc_ffa,1
dlc2,hc_ffa,1
dlc3,hc_ffa,1
dlc4,hc_ffa,2

playlist 22
name english "Domination"
name englisharabic "Domination"
name french "Domination"
name italian "Dominio"
name german "Herrschaft"
name spanish "Dominio"
name polish "Dominacja"
name russian "Превосходство"
name japanese "DOMINATION"
name mexicanspanish "Dominio"
name portuguese "Dominação"
name arabic "ﺓﺮﻄﻴﺴﻟا"
name traditionalchinese "占領"
name simplifiedchinese "征服"
description english "Hardcore Domination. Limited HUD, low health, friendly fire enabled, and much more.\n\nPlayers: 6-12"
description englisharabic "Hardcore Domination. Limited HUD, low health, friendly fire enabled, and much more.\n\nPlayers: 6-12"
description french "Domination Hardcore. ATH limité, santé faible, tir allié activé, etc.\n\nJoueurs : 6-12. "
description italian "Dominio Veterano. Interfaccia limitata, salute ridotta, fuoco amico attivato e molto altro.\n\nGiocatori: 6-12"
description german "Hardcore-Herrschaft. Eingeschränktes HUD, geringe Gesundheit, Teambeschuss aktiviert und noch viel mehr.\n\nSpieler: 6-12"
description spanish "Dominio por equipos extremo. HUD limitado, poca salud, fuego amigo activado y mucho más.\n\nJugadores: 6-12"
description polish "Dominacja hardcore. Ograniczony HUD, niski poziom życia, ostrzał sojuszniczy włączony i wiele więcej.\n\nGracze: 6-12"
description russian "Хардкор: Превосходство. Ограниченный интерфейс, пониженное здоровье, включен огонь по своим и многое другое.\n\n6-12 игроков"
description japanese "HUD制限ありのHC: DOMINATION\n体力減、味方への誤射あり等\n\nプレイヤー数: 6-12"
description mexicanspanish "Dominio por equipos extremo. HUD limitado, poca salud, fuego amigo activado y mucho más.\n\nJugadores: 6-12"
description portuguese "Dominação Extrema. HUD limitado, pouca saúde, fogo amigo e muito mais.\n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n\n.ﺪﻳﺰﻤﻟﺍو ،ﺔﻠﻌﻔﻣ ﺔﻘﻳﺪﺻ ﻥﺍﺮﻴﻨﻟا ،ﺔﻠﻴﻠﻗ ﺔﺤﺻ ،ﺓﺩﻭﺪﺤﻣ ﺽﺮﻋ ﺔﺷﺎﺷ .ﺓﺮﻄﻴﺴﻟا ﺪﻳﺪﺷ"
description traditionalchinese "硬派占領。HUD受限，低生命值、啟用友方誤傷及其他。\n\n玩家人數：6-12"
description simplifiedchinese "精英征服。HUD受限、低生命值、开启友军伤害以及更多挑战。\n\n玩家: 6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories hardcore
icon playlist_domination
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hc_dom,1
dlc1,hc_dom,1
dlc2,hc_dom,1
dlc3,hc_dom,1
dlc4,hc_dom,2

playlist 23
name english "Kill Confirmed"
name englisharabic "Kill Confirmed"
name french "Élimination confirmée"
name italian "Uccisione confermata"
name german "Abschuss bestätigt"
name spanish "Baja confirmada"
name polish "Likwidacja potw."
name russian "Подтверждение"
name japanese "K-CONFIRMED"
name mexicanspanish "Baja confirmada"
name portuguese "BC"
name arabic "ﻞﺘﻘﻟا ﺪﻴﻛﺄﺗ"
name traditionalchinese "擊殺確認"
name simplifiedchinese "击杀确认"
description english "Hardcore Kill Confirmed. Limited HUD, low health, friendly fire enabled, and much more.\n\nPlayers: 6-12"
description englisharabic "Hardcore Kill Confirmed. Limited HUD, low health, friendly fire enabled, and much more.\n\nPlayers: 6-12"
description french "Élimination confirmée Hardcore. ATH limité, santé faible, tir allié activé, etc.\n\nJoueurs : 6-12. "
description italian "Uccisione confermata Veterano. Interfaccia limitata, salute ridotta, fuoco amico attivato e molto altro.\n\nGiocatori: 6-12"
description german "Hardcore-Abschuss bestätigt. Eingeschränktes HUD, geringe Gesundheit, Teambeschuss aktiviert und noch viel mehr.\n\nSpieler: 6-12"
description spanish "Baja confirmada extremo. HUD limitado, poca salud, fuego amigo activado y mucho más.\n\nJugadores: 6-12"
description polish "Likwidacja potwierdzona hardcore. Ograniczony HUD, niski poziom życia, ostrzał sojuszniczy włączony i wiele więcej.\n\nGracze: 6-12"
description russian "Хардкор: Подтверждение. Ограниченный интерфейс, пониженное здоровье, включен огонь по своим и многое другое.\n\n6-12 игроков"
description japanese "HUD制限ありのHC: K-CONFIRMED\n体力減、味方への誤射あり等\n\nプレイヤー数: 6-12"
description mexicanspanish "Baja confirmada extremo. HUD limitado, poca salud, fuego amigo activado y mucho más.\n\nJugadores: 6-12"
description portuguese "BC Extrema. HUD limitado, pouca saúde, fogo amigo e muito mais.\n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n\n.ﺪﻳﺰﻤﻟﺍو ،ﺔﻠﻌﻔﻣ ﺔﻘﻳﺪﺻ ﻥﺍﺮﻴﻧ ،ﺔﻠﻴﻠﻗ ﺔﺤﺻ ،ﺓﺩﻭﺪﺤﻣ ﺽﺮﻋ ﺔﺷﺎﺷ .ﻞﺘﻘﻟا ﺪﻴﻛﺄﺗ ﺪﻳﺪﺷ"
description traditionalchinese "硬派擊殺確認。HUD受限，低生命值、啟用友方誤傷及其他。\n\n玩家人數：6-12"
description simplifiedchinese "精英击杀确认。HUD受限、低生命值、开启友军伤害以及更多挑战。\n\n玩家: 6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories hardcore
icon playlist_kill_confirm
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hc_conf,1
dlc1,hc_conf,1
dlc2,hc_conf,1
dlc3,hc_conf,1
dlc4,hc_conf,2

playlist 24
nameref PLAYLIST_PLAYLIST_HC_SD
descriptionref PLAYLIST_PLAYLIST_HC_SD_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories hardcore
icon playlist_search_destroy
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
// rule partyChatDisallowed 1               // rule partyChatDisallowed 1 - this will kick any player who is currently in or joined a platform party chat
all,hc_sd,1
dlc1,hc_sd,1
dlc2,hc_sd,1
dlc3,hc_sd,1
dlc4,hc_sd,2

playlist 25
nameref PLAYLIST_PLAYLIST_HC_CTF
descriptionref PLAYLIST_PLAYLIST_HC_CTF_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories hardcore
icon playlist_ctf
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hc_ctf,1
dlc1,hc_ctf,1
dlc2,hc_ctf,1
dlc3,hc_ctf,1
dlc4,hc_ctf,2

///////////////////////////////////////////////////////////////////////////
//      ARENAS
//      40-49 is reserved for playlists in Arenas
///////////////////////////////////////////////////////////////////////////

playlist 40
name english "Pro Series"
name englisharabic "Pro Series"
name french "Séries pro"
name italian "Serie Pro"
name german "Profi-Serie"
name spanish "Serie profesional"
name polish "Seria Pro"
name russian "Серия Профи"
name japanese "PRO SERIES"
name mexicanspanish "Serie profesional"
name portuguese "Série Profissional"
name arabic "ﻦﻴﻓﺮﺘﺤﻤﻟا ﺔﻠﺴﻠﺳ"
name traditionalchinese "專業系列"
name simplifiedchinese "职业系列"
description english "Mix of Search & Destroy, Hardpoint, Capture the Flag, and Uplink on select maps with official competitive rules and friendly fire enabled.  \n\nPlayers: 4v4 / Max Party Size: 4\nSplit-screen not permitted.\nProtects & Bans, Specialist Draft."
description englisharabic "Mix of Search & Destroy, Hardpoint, Capture the Flag, and Uplink on select maps with official competitive rules and friendly fire enabled.  \n\nPlayers: 4v4 / Max Party Size: 4\nSplit-screen not permitted.\nProtects & Bans, Specialist Draft."
description french "Mélange de Recherche et destruction, Point stratégique, Capture du drapeau et Liaison sur les cartes sélectionnées. Règles compétitives et Tir allié activés.\n\nJoueurs : 4 vs 4. - Membres de groupe max : 4\nÉcran scindé non autorisé.\nExclusions/Protections, Recrutement de spécialiste."
description italian "Un mix di Cerca e distruggi, Postazione, Cattura la bandiera e Uplink su mappe selezionate con regole competitive ufficiali e fuoco amico attivati.\n\nGiocatori: 4v4 / Dimensioni massime gruppo: 4\nSchermo condiviso non permesso.\nProtezioni e interdizioni, Arruolamento specialisti."
description german "Eine Kombination aus S&Z, Stellung, CTF und Uplink auf ausgewählten Karten mit offiziellen Wettkampfregeln und Teambeschuss aktiviert.\n\nSpieler: 4 gegen 4 / Maximale Partygröße: 4\nSplitscreen nicht erlaubt.\nSchutz/Ausschluss, Spezialisten-Einberufung"
description spanish "Mezcla de Buscar y destruir, Tomar la bandera, Enlace y Punto caliente en mapas seleccionados con reglas competitivas oficiales y fuego amigo activados.\n\nJugadores: 4c4 - Tamaño máximo del grupo: 4\nNo se permite la pantalla dividida.\nProtecciones/Exclusiones y reclutamiento de especialistas."
description polish "Miks trybów Znajdź i zniszcz, Umocniony punkt, Zdobądź flagę i Uplink na wszystkich mapach z zasadami rywalizacji i z ostrzałem sojuszniczym. \n\nGracze: 4na4 - Maks. grupa: 4\nPodzielony ekran nie dozwolony.\nOchrona/Blokada, wybór specjalisty."
description russian "Сочетание режимов ''Найти и уничтожить'', ''Опорный пункт'', ''Захват флага'' и ''Канал связи'' на отдельных картах с официальными соревновательными правилами и дружественным огнем. Разделение экрана недоступно.\n4 против 4 игроков\nВыбор специалистов, запрет-защита."
description japanese "S&D、HARDPOINT、CTF、UPLINKのミックス\n選択されたマップを使用\n味方への誤射あり、大会ルールあり\n\n禁止/保護、スペシャリスト採用\nプレイヤー数: 4v4 / 最大パーティー: 4\n画面分割禁止"
description mexicanspanish "Mezcla de Buscar y destruir, Capturar la bandera, Enlace y Punto caliente en mapas seleccionados con reglas competitivas oficiales y fuego amigo activados.\n\nJugadores: 4c4 - Tamaño máximo del grupo: 4\nNo se permite la pantalla dividida.\nProtecciones/Exclusiones y reclutamiento de especialistas."
description portuguese "Mistura de Localizar e Destruir, Zona de Conflito, Capture a Bandeira e Transmissão em mapas específicos com regras competitivas oficiais e fogo amigo.\n\nJogadores: 4v4 / Máximo: 4\nTela compartilhada não permitida.\nProteger/banir, alistamento de especialista."
description arabic ".ﻦﻴﺼﺼﺨﺘﻤﻟا ﺪﻴﻨﺠﺗو ،ﺓﺭﻮﻈﺤﻤﻟﺍو ﺔﻴﻤﺤﻤﻟا ﺮﺻﺎﻨﻌﻟا :\n.ﺔﺷﺎﺸﻟا ﻢﻴﺴﻘﺘﺑ ﺢﻤﺴﻳ ﻻ\n 4 :ﺔﻗﺮﻔﻠﻟ ﻰﺼﻗﻷا ﺪﺤﻟا / 4ﺪﺿ4 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n\n .ًﺎﻴﻤﺳر ﺔﻘﻳﺪﺼﻟا ﻥﺍﺮﻴﻨﻟﺍو ﺲﻓﺎﻨﺘﻟا ﺪﻋﺍﻮﻗ ﺎﻬﻴﻓ ﻞﻌﻔﺗ ﻲﺘﻟا ﺓﺭﺎﺘﺨﻤﻟا ﻂﺋﺍﺮﺨﻟا ﺾﻌﺑ ﻲﻓ ﻝﺎﺼﺗﻻا ﺓﺮﻛو ،ﺔﻳﺍﺮﻟا ﻰﻠﻋ ءﻼﻴﺘﺳﻻﺍو ،ﺔﻠﻘﻨﺘﻤﻟا ﺔﻄﻘﻨﻟﺍو ،ﺮﻴﻣﺪﺘﻟﺍو ﺚﺤﺒﻟا ﻦﻴﺑ ﺞﻳﺰﻣ"
description traditionalchinese "這種玩法結合搜索與摧毀、據點戰、搶旗戰和通訊連結，適用於指定地圖，並啟用官方競爭規則與友方誤傷。  \n\n玩家人數：4v4 / 隊伍人數上限：4\n不能用分割畫面進行。\n保護與封鎖，專家選拔。"
description simplifiedchinese "开启正式竞技规则和友军伤害，在选择的地图上进行搜索与摧毁、据点战、夺旗战和上行传输。\n\n玩家：4v4 / 队伍人数上限：4\n禁止分屏。\n保护和禁用、专家征召。"
unlockxp 0
maxparty 4
maxlocalplayers 1
categories arena
arenaSlot 0
icon playlist_arena_champions
parkingplaylist 9001
rule party_minplayers 8
rule party_maxplayers 8
rule party_matchedplayercount 0
rule gts pregamedraftenabled 1      // enable Specialist Selection
rule gts pregameitemvoteenabled 1   // enable pick/ban
rule gts pregamescorestreakmodifytime 20 // Scorestreak Selection Timer in seconds
rule gts pregamedraftroundtime 20   // Draft round timer in seconds
rule gts pregamecacmodifytime 90    // CAC Modify timer in seconds
rule gts pregameprestagetime 3      // Pre-game Stage Timer in seconds
rule gts pregameItemVoteRoundTime 30    // Protect/Ban timer in seconds
rule gts friendlyfiretype 1                         // Friendly Fire: Enabled
rule gts disableThirdPersonSpectating 1 // No 3rd person spectating
rule gts voipKillersHearVictim 0                // No VOIP to killer
rule gts allowBattleChatter 0                     // No Battlechatter
rule gts allowMapScripting 0                        // Map Interactivity set to No
rule gts roundStartExplosiveDelay 0     // Time to use grenades: 0
rule gts restricteditems 199 1  // Restrict UAV
rule gts restricteditems 202 1  // Restrict Care Package
rule gts restricteditems 213 1  // Restrict HATR
rule gts restricteditems 58 1  // Restrict XM-53
rule gts restricteditems 151 1  // Restrict Ghost
rule gts restricteditems 168 1  // Restrict Sixth Sense
rule gts restricteditems 161 1  // Restrict Tracker
rule gts restricteditems 65 1  // Restrict Trip Mine
rule gts restricteditems 75 1  // Restrict Shock Charge
rule gts restricteditems 64 1  // Restrict C4
rule gts restricteditems 203 1  // Restrict Guardian
rule gts restricteditems 207 1  // Restrict Sentry
rule gts restricteditems 54 1  // Restrict Crossbow
rule gts restricteditems 8 1    // Restrict Marshal
rule gts restricteditems 28 1   // Restrict Garand
rule gts restricteditems 17 1 // Restrict HG 40
rule gts restricteditems 45 1 // Restrict Interdiction
rule gts restricteditems 57 1 // Restrict Multi-Launcher
rule gts restricteditems 29 1 // Restrict Famas
rule gts restricteditems 56 1 // Restrict Banshii
rule gts restricteditems 47 1 // Restrict Rift E9
rule gts restricteditems 92 1 // Restrict Gambler Ability
rule gts restricteditems 93 1 // Restrict Rogue Ability
rule gts restricteditems 7 1 // Restrict ar_peacekeeper
rule gts restricteditems 35 1 // Restrict lmg_infinite
rule gts restricteditems 46 1 // Restrict sniper_double
rule gts restricteditems 123 1 // Restrict special_discgun
rule gts restricteditems 19 1 // Restrict smg_nailgun
rule gts restricteditems 36 1 // Restrict ar_pulse
rule gts restricteditems 18 1 // Restrict smg_rechamber
rule gts restricteditems 37 1 // Restrict ar_m16
rule gts restricteditems 38 1 // Restrict smg_ppsh
rule gts restricteditems 126 1 // Restrict ar_galil
rule gts restricteditems 127 1 // Restrict knife_ballistic
rule gts restricteditems 48 1 // Restrict pistol_m1911
rule gts restricteditems 16 1 // Restrict smg_ak74u
rule gts restricteditems 27 1 // Restrict ar_an94
rule gts restricteditems 39 1 // Restrict launcher_ex41
rule gts restricteditems 44 1 // Restrict shotgun_olympia
rule gts restricteditems 34 1 // Restrict smg_msmc
rule gts restricteditems 98 1 // Restrict sniper_xpr50
rule gts restricteditems 128 1 // Restrict lmg_rpk
rule gts restricteditems 110 1 // Restrict smg_sten
rule gts restricteditems 130 1 // Restrict sniper_mosin
rule gts restricteditems 129 1 // Restrict ar_m14
rule gts restrictedattachments 27 weaponindex 54 1  // Restrict LRx2
rule gts restrictedattachments 36 weaponindex 54 1  // Restrict Tri-Bolt
rule gts restrictedattachments 39 weaponindex 54 1  // Restrict Bayonet
rule gts loadoutKillstreaksEnabled 1        // Enable Scorestreaks
arena_koth,arena_koth_pro,2
arena_ball,arena_ball_pro,2
arena_sd,arena_sd_pro,2
arena_ctf,arena_ctf_pro,1

playlist 43
name english "Scrim Series"
name englisharabic "Scrim Series"
name french "Séries de scrim"
name italian "Serie Scrim"
name german "Scrim-Serie"
name spanish "Serie Scrim"
name polish "Seria przepychanka"
name russian "Товарищеская серия"
name japanese "SCRIM SERIES"
name mexicanspanish "Serie Scrim"
name portuguese "Série Scrim"
name arabic "ﺔﻳﺩﻮﻟا ﺕﺎﻳﺭﺎﺒﻤﻟا ﺔﻠﺴﻠﺳ"
name traditionalchinese "熱身系列"
name simplifiedchinese "热身赛"
description english "Pro Series ruleset without Protect & Ban or Specialist Draft. Set up Classes, Specialists, and Scorestreaks before the match starts. \n\nPlayers: 4v4 / Max Party Size: 4\nSplit-screen not permitted."
description englisharabic "Pro Series ruleset without Protect & Ban or Specialist Draft. Set up Classes, Specialists, and Scorestreaks before the match starts. \n\nPlayers: 4v4 / Max Party Size: 4\nSplit-screen not permitted."
description french "Règles pour les séries pro sans Exclusions/Protections ou Recrutement de spécialiste. Définissez des classes, des spécialistes et des séries de points avant le début de la partie.\n\nJoueurs : 4 vs 4. - Membres de groupe max : 4\nÉcran scindé non autorisé."
description italian "Regole Serie Pro senza protezione/interdizione o Arruolamento specialisti. Imposta classi, specialisti e serie di punti prima che la partita abbia inizio.\n\nGiocatori: 4v4 / Dimensioni massime gruppo: 4\nSchermo condiviso non permesso."
description german "Regeln der Profi-Serie ohne Schutz & Ausschluss oder Spezialisten-Einberufung. Klassen, Spezialisten und Punkteserien werden festgelegt, bevor das Spiel beginnt.\n\nSpieler: 4 gegen 4 / Maximale Partygröße: 4\nSplitscreen nicht erlaubt."
description spanish "Reglas de serie profesional sin protecciones/exclusiones o reclutamiento de especialistas. Elige clases, rachas de puntos y especialistas antes de empezar la partida.\n\nJugadores: 4c4 - Tamaño máximo del grupo: 4\nNo se permite la pantalla dividida."
description polish "Reguły z Serii Pro, bez opcji: Ochrona/Blokada i Wybór specjalistów. Wybierz klasę, specjalistę i serie punktów przed rozpoczęciem meczu. \n\nGracze: 4na4 /Maks. grupa: 4 \nPodzielony ekran nie dozwolony."
description russian "Правила серии Профи без запретов, защиты и выбора специалистов. Выбирайте классы, специалистов и серии очков до начала матча.\n\n4 против 4 игроков, максимальный размер команды - 4.\nРазделение экрана недоступно."
description japanese "PRO SERIESルール 保護/禁止やスペシャリスト採用なし マッチ開始前にクラス/スぺシャリスト/スコアストリーク設定\n\nプレイヤー数: 4v4 / 最大パーティー: 4\n画面分割禁止"
description mexicanspanish "Reglas de serie profesional sin protecciones/exclusiones o reclutamiento de especialistas. Elige clases, rachas de puntos y especialistas antes de empezar la partida.\n\nJugadores: 4c4 - Tamaño máximo del grupo: 4\nNo se permite la pantalla dividida."
description portuguese "Série profissional sem proteger/banir ou alistamento de especialista. Configure as classes, séries de pontuação e especialistas antes de começar o jogo. \n\nJogadores: 4v4 / Máximo: 4\nTela compartilhada não permitida."
description arabic ".ﺔﺷﺎﺸﻟا ﻢﻴﺴﻘﺘﺑ ﺢﻤﺴﻳ ﻻ \n 4 :ﺔﻗﺮﻔﻠﻟ ﻢﺠﺣ ﻰﺼﻗأ / 4 ﺪﺿ 4 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n\n .ﺓﺍﺭﺎﺒﻤﻟا ءﺪﺑ ﻞﺒﻗ ﺲﻜﻳﺮﺘﺳﺭﻮﻜﺴﻟﺍو ﻦﻴﺼﺼﺨﺘﻤﻟﺍو Classes ـﻝا ﻂﺒﻀﺑ ﻢﻗ .ﻦﻴﺼﺼﺨﺘﻤﻟا ﺪﻴﻨﺠﺗ ﻭأ ﺮﻈﺤﻟﺍو ﺔﻳﺎﻤﺤﻟا ﻥﻭد ﻦﻣ ﻦﻴﻓﺮﺘﺤﻤﻟا ﻱﺭﻭد ﺪﻋﺍﻮﻗ ﺔﻋﻮﻤﺠﻣ"
description traditionalchinese "專業系列規則但不包括保護和封鎖或是專家選拔。在對戰開始之前設定裝備配置、專家、積分獎勵。\n\n玩家：4v4 / 隊伍人數上限：4\n不能在分割畫面中進行。"
description simplifiedchinese "职业联赛规则，没有保护和禁用或专家征召。比赛开始前设置作战配置、专家和连续得分奖励。\n\n玩家：4v4 / 队伍人数上限：4\n禁止分屏。"
unlockxp 0
maxparty 4
maxlocalplayers 1
categories arena
arenaSlot 3
icon playlist_arena_moshpit
parkingplaylist 9001
rule party_minplayers 8
rule party_maxplayers 8
rule party_matchedplayercount 0
rule gts pregamedraftenabled 0      // Disable Specialist Selection
rule gts pregameitemvoteenabled 0   // disable pick/ban
rule gts friendlyfiretype 1                         // Friendly Fire: Enabled
rule gts disableThirdPersonSpectating 1 // No 3rd person spectating
rule gts voipKillersHearVictim 0                // No VOIP to killer
rule gts allowBattleChatter 0                     // No Battlechatter
rule gts allowMapScripting 0                        // Map Interactivity set to No
rule gts roundStartExplosiveDelay 0     // Time to use grenades: 0
rule gts restricteditems 199 1  // Restrict UAV
rule gts restricteditems 202 1  // Restrict Care Package
rule gts restricteditems 213 1  // Restrict HATR
rule gts restricteditems 58 1  // Restrict XM-53
rule gts restricteditems 151 1  // Restrict Ghost
rule gts restricteditems 168 1  // Restrict Sixth Sense
rule gts restricteditems 161 1  // Restrict Tracker
rule gts restricteditems 65 1  // Restrict Trip Mine
rule gts restricteditems 75 1  // Restrict Shock Charge
rule gts restricteditems 64 1  // Restrict C4
rule gts restricteditems 203 1  // Restrict Guardian
rule gts restricteditems 207 1  // Restrict Sentry
rule gts restricteditems 54 1  // Restrict Crossbow
rule gts restricteditems 8 1    // Restrict Marshal
rule gts restricteditems 28 1   // Restrict Garand
rule gts restricteditems 17 1 // Restrict HG 40
rule gts restricteditems 45 1 // Restrict Interdiction
rule gts restricteditems 57 1 // Restrict Multi-Launcher
rule gts restricteditems 29 1 // Restrict Famas
rule gts restricteditems 56 1 // Restrict Banshii
rule gts restricteditems 47 1 // Restrict Rift E9
rule gts restricteditems 92 1 // Restrict Gambler Ability
rule gts restricteditems 93 1 // Restrict Rogue Ability
rule gts restricteditems 7 1 // Restrict ar_peacekeeper
rule gts restricteditems 35 1 // Restrict lmg_infinite
rule gts restricteditems 46 1 // Restrict sniper_double
rule gts restricteditems 123 1 // Restrict special_discgun
rule gts restricteditems 19 1 // Restrict smg_nailgun
rule gts restricteditems 36 1 // Restrict ar_pulse
rule gts restricteditems 18 1 // Restrict smg_rechamber
rule gts restricteditems 37 1 // Restrict ar_m16
rule gts restricteditems 38 1 // Restrict smg_ppsh
rule gts restricteditems 126 1 // Restrict ar_galil
rule gts restricteditems 127 1 // Restrict knife_ballistic
rule gts restricteditems 48 1 // Restrict pistol_m1911
rule gts restricteditems 16 1 // Restrict smg_ak74u
rule gts restricteditems 27 1 // Restrict ar_an94
rule gts restricteditems 39 1 // Restrict launcher_ex41
rule gts restricteditems 44 1 // Restrict shotgun_olympia
rule gts restricteditems 34 1 // Restrict smg_msmc
rule gts restricteditems 98 1 // Restrict sniper_xpr50
rule gts restricteditems 128 1 // Restrict lmg_rpk
rule gts restricteditems 110 1 // Restrict smg_sten
rule gts restricteditems 130 1 // Restrict sniper_mosin
rule gts restricteditems 129 1 // Restrict ar_m14
rule gts restrictedattachments 27 weaponindex 54 1  // Restrict LRx2
rule gts restrictedattachments 36 weaponindex 54 1  // Restrict Tri-Bolt
rule gts restrictedattachments 39 weaponindex 54 1  // Restrict Bayonet
rule gts loadoutKillstreaksEnabled 1        // Enable Scorestreaks
arena_koth,arena_koth_pro,2
arena_ball,arena_ball_pro,2
arena_sd,arena_sd_pro,2
arena_ctf,arena_ctf_pro,1

///////////////////////////////////////////////////////////////////////////
//      FEATURED
//      90-119 is reserved for playlists in the Featured Category. Contains other playlists from the old BONUS category - Nuk3town, Nukejacked, Gun Game.
///////////////////////////////////////////////////////////////////////////

playlist 30
name english "Gun Game"
name englisharabic "Gun Game"
name french "Jeu d'armes"
name italian "Gioco delle armi"
name german "Waffenspiel"
name spanish "Juego de armas"
name polish "Zabawa bronią"
name russian "Оружие"
name japanese "GUN GAME"
name mexicanspanish "Juego de armas"
name portuguese "Jogo de Armas"
name arabic "ﺔﺤﻠﺳﻷا ﺔﺒﻌﻟ"
name traditionalchinese "軍火之王"
name simplifiedchinese "枪械游戏"
description english "Kill players with your weapon to advance to the next weapon. First to get a kill with each weapon wins. No parties.\n\nPlayers: 6-8"
description englisharabic "Kill players with your weapon to advance to the next weapon. First to get a kill with each weapon wins. No parties.\n\nPlayers: 6-8"
description french "Tuez des joueurs avec votre arme pour passer à l'arme suivante. Le premier à faire une élimination avec toutes les armes l'emporte.Pas de groupes.\n\nJoueurs : 6-8."
description italian "Uccidi gli altri giocatori usando la tua arma per ottenere quella successiva. Vince il primo a effettuare un'uccisione con ogni arma. Niente gruppi.\n\nGiocatori: 6-8"
description german "Erledigen Sie Spieler mit Ihrer Waffe, um die nächste Waffe zu erhalten. Der Spieler, dem ein Abschuss mit jeder Waffe gelingt, gewinnt. Keine Partys.\n\nSpieler: 6-8"
description spanish "Mata jugadores con tu arma para avanzar a la siguiente. Gana el primero en conseguir una baja con cada arma. Sin grupos.\n\nJugadores: 6-8"
description polish "Zabijaj wrogów, aby uzyskać kolejną broń. Wygrywa pierwszy, który zabije każdym rodzajem broni. Bez grup.\n\nGracze: 6-8"
description russian "Убивайте врага, чтобы получить новое оружие.Победит тот, кто уничтожил врагов со всего оружия. Без команд.\n\n6-8 игроков"
description japanese "他のプレイヤーを倒すと武器がグレードアップしていく 各武器で他のプレイヤーをいち早く倒せば勝利 パーティーなし\n\nプレイヤー数: 6-8"
description mexicanspanish "Mata jugadores con tu arma para avanzar a la siguiente. Gana el primero en conseguir una baja con cada arma. Sin grupos.\n\nJugadores: 6-8"
description portuguese "Mate jogadores com a sua arma para avançar para a próxima arma. O primeiro a obter uma baixa com cada arma vence. Sem grupos.\n\nJogadores: 6-8"
description arabic "8-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ \n\n.ﻕﺮﻓ ﻥﻭﺪﺑ .ﺰﺋﺎﻔﻟا ﻮﻫ ﻥﻮﻜﻳ ﺡﻼﺳ ﻞﻜﺑ ﻞﺘﻗ ﺔﻴﻠﻤﻋ ﻖﻘﺤﻳ ﺐﻋﻻ ﻝﻭأ .ﻲﻟﺎﺘﻟا ﺡﻼﺴﻟا ﻰﻟإ ﻡﺪﻘﺘﺘﻟ ﻚﺣﻼﺴﺑ ﻦﻴﺒﻋﻼﻟا ﻞﺘﻗا"
description traditionalchinese "用你手中的武器擊殺玩家就能進階為下一種武器。率先用每一種武器取得擊殺的玩家即可獲勝。無法組隊。\n\n玩家人數：6-8 "
description simplifiedchinese "用武器击杀玩家可以升级至下一把武器。第一位用所有武器击杀其他人的玩家获胜，不可组队。\n\n玩家：6-8"
unlockxp 0
icon playlist_gungame
parkingplaylist 9001
maxparty 1
maxlocalplayers 1
categories featured
rule party_minplayers 6
rule party_maxplayers 8
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
smallmaps,hs_gun,1
mp_skyjacked,hs_gun,1
mp_conduit,hs_gun,1
mp_cryogen,hs_gun,2
hidden

playlist 34
name english "Nuk3town"
name englisharabic "Nuk3town"
name french "Nuk3town"
name italian "Nuk3town"
name german "Nuk3town"
name spanish "Nuk3town"
name polish "Nuk3town"
name russian "Nuk3town"
name japanese "NUK3TOWN"
name mexicanspanish "Nuk3town"
name portuguese "Nuk3town"
name arabic "Nuk3town"
name traditionalchinese "Nuk3town"
name simplifiedchinese "Nuk3town"
description english "Nuk3town Only. \n\nPlayers: 6-12"
description englisharabic "Nuk3town Only. \n\nPlayers: 6-12"
description french "Nuk3town uniquement. \n\nJoueurs : 6-12"
description italian "Solo Nuk3town. \n\nGiocatori: 6-12"
description german "Nur Nuk3town. \n\nSpieler: 6-12"
description spanish "Solo Nuk3town. \n\nJugadores: 6-12"
description polish "Tylko Nuk3town. \n\nGraczy: 6-12"
description russian "Только Nuk3town. \n\nИгроков: 6-12"
description japanese "Nuk3townのみ。\n\nプレイヤー数: 6-12"
description mexicanspanish "Solo Nuk3town. \n\nJugadores: 6-12"
description portuguese "Somente Nuk3town. \n\nJogadores: 6-12"
description arabic " 12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n\n.ﻂﻘﻓ Nuk3town ﺔﻄﻳﺮﺧ"
description traditionalchinese "只有Nuk3town。\n\n玩家人數：6-12"
description simplifiedchinese "只有Nuk3town。\n\n玩家: 6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_generic_02
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
mp_nuketown_x,hs_dom,2
mp_nuketown_x,hs_koth,2
mp_nuketown_x,hs_conf,2
mp_nuketown_x,hs_tdm,2
mp_nuketown_x,hs_ball,2
mp_nuketown_x,hs_escort,2
mp_nuketown_x,hs_clean,2
hidden

playlist 36
name english "Nuk3Jacked"
name englisharabic "Nuk3Jacked"
name french "Nuk3Jacked"
name italian "Nuk3Jacked"
name german "Nuk3Jacked"
name spanish "Nuk3Jacked"
name polish "Nuk3Jacked"
name russian "Nuk3Jacked"
name japanese "NUK3JACKED"
name mexicanspanish "Nuk3Jacked"
name portuguese "Nuk3Jacked"
name arabic "Nuk3Jacked"
name traditionalchinese "Nuk3Jacked"
name simplifiedchinese "Nuk3Jacked"
description english "Nuk3town and Skyjacked Only. \n\nPlayers: 6-12"
description englisharabic "Nuk3town and Skyjacked Only. \n\nPlayers: 6-12"
description french "Nuk3town et Skyjacked uniquement.\n\nJoueurs : 6-12 "
description italian "Solo Nuk3town e Skyjacked. \n\nGiocatori: 6-12"
description german "Nur Nuk3town und Skyjacked.\n\nSpieler: 6-12"
description spanish "Solo Nuk3town y Skyjacked. \n\nJugadores: 6-12"
description polish "Tylko Nuk3town i Skyjacked.\n\nGracze: 6-12 "
description russian "Только карты Nuk3town и Skyjacked. \n\nИгроки: 6-12"
description japanese "NUK3TOWNとSKYJACKEDのみ。\n\nプレイヤー数: 6-12"
description mexicanspanish "Solo Nuk3town y Skyjacked. \n\nJugadores: 6-12"
description portuguese "Somente Nuk3town e Skyjacked. \n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n\n .Skyjackedو Nuk3town ﻲﺘﻄﻳﺮﺧ ﻲﻓ ﻂﻘﻓ"
description traditionalchinese "只有Nuk3town及Skyjacked。\n\n玩家人數: 6-12"
description simplifiedchinese "只有Nuk3town和Skyjacked。\n\n玩家：6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_generic_02
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
mp_nuketown_x,hs_dom,1
mp_nuketown_x,hs_koth,1
mp_nuketown_x,hs_conf,1
mp_nuketown_x,hs_tdm,1
mp_nuketown_x,hs_ball,1
mp_nuketown_x,hs_escort,1
mp_nuketown_x,hs_clean,1
mp_skyjacked,hs_dom,1
mp_skyjacked,hs_koth,1
mp_skyjacked,hs_conf,1
mp_skyjacked,hs_tdm,1
mp_skyjacked,hs_ball,1
mp_skyjacked,hs_escort,1
mp_skyjacked,hs_clean,1
hidden

playlist 90
name english "Hardpoint"
name englisharabic "Hardpoint"
name french "Point stratégique"
name italian "Postazione"
name german "Stellung"
name spanish "Punto caliente"
name polish "Umocniony punkt"
name russian "Опорный пункт"
name japanese "HARDPOINT"
name mexicanspanish "Punto caliente"
name portuguese "Zona de Conflito"
name arabic "ﺔﻠﻘﻨﺘﻤﻟا ﺔﻄﻘﻨﻟا"
name traditionalchinese "據點戰"
name simplifiedchinese "据点战"
description english "Capture and hold the Hardpoint to earn points.\n\nPlayers: 6-12"
description englisharabic "Capture and hold the Hardpoint to earn points.\n\nPlayers: 6-12"
description french "Capturez le point stratégique et tenez-le pour marquer des points.\n\nJoueurs : 6-12."
description italian "Conquista e difendi la postazione per ottenere punti.\n\nGiocatori: 6-12"
description german "Erobern und halten Sie die Stellung zum Punkten.\n\nSpieler: 6-12"
description spanish "Toma el punto caliente y defiéndelo para obtener puntos.\n\nJugadores: 6-12"
description polish "Przejmij i utrzymuj wyznaczone pozycje, żeby zdobywać punkty.\n\nGracze: 6-12"
description russian "Для получения очков захватите и удерживайте опорный пункт.\n\n6-12 игроков"
description japanese "ハードポイントを奪取/防衛しポイントを獲得せよ\n\nプレイヤー数: 6-12"
description mexicanspanish "Toma el punto caliente y defiéndelo para obtener puntos.\n\nJugadores: 6-12"
description portuguese "Capture e defenda a Zona de Conflito para ganhar pontos.\n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n\n.ﻁﺎﻘﻨﻟا ﻞﻴﺠﺴﺘﻟ ﺎﻬﻴﻠﻋ ﻚﺗﺮﻄﻴﺳ ﻰﻠﻋ ﻆﻓﺎﺣو ﺔﻠﻘﻨﺘﻤﻟا ﺔﻄﻘﻨﻟا ﻰﻠﻋ ﺮﻄﻴﺳ"
description traditionalchinese "占領並固守據點，以獲得積分。\n\n玩家人數：6-12"
description simplifiedchinese "占领并防守据点即可得分。\n\n玩家：6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_koth
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hs_koth,1
dlc1,hs_koth,1
dlc2,hs_koth,1
dlc3,hs_koth,1
dlc4,hs_koth,2
hidden

playlist 91
name english "Safeguard"
name englisharabic "Safeguard"
name french "Dernier rempart"
name italian "Salvaguardia"
name german "Geleitschutz"
name spanish "Salvaguarda"
name polish "Ochrona"
name russian "Охрана"
name japanese "SAFEGUARD"
name mexicanspanish "Salvaguarda"
name portuguese "Proteção"
name arabic "ﺕﻮﺑﻭﺮﻟا ﺔﻘﻓﺍﺮﻣ"
name traditionalchinese "保衛"
name simplifiedchinese "护送"
description english "Teams alternate in escorting a non-combative robot into enemy territory. Deliver the robot to win.\n\nPlayers: 6-12"
description englisharabic "Teams alternate in escorting a non-combative robot into enemy territory. Deliver the robot to win.\n\nPlayers: 6-12"
description french "Les équipes escortent chacune leur tour un robot non combattant en territoire ennemi. Livrez le robot pour gagner.\n\nJoueurs : 6-12."
description italian "Le squadre si alternano nella scorta di un robot non combattivo in territorio nemico. Consegna il robot per vincere.\n\nGiocatori: 6-12"
description german "Die Teams eskortieren abwechselnd einen Roboter in feindliches Gebiet. Liefern Sie den Roboter zum Gewinnen ab.\n\nSpieler: 6-12"
description spanish "Los equipos se alternan escoltando a un robot no combativo en territorio enemigo. Entrega el robot para ganar.\n\nJugadores: 6-12"
description polish "Drużyny na zmianę eskortują nieuzbrojonego robota przez terytorium przeciwnika. Wygrywacie, gdy robot dotrze do celu.\n\nGracze: 6-12"
description russian "Команды поочередно сопровождают небоевой робот на вражескую территорию. Чтобы победить, необходимо успешно доставить робота.\n\n6-12 игроков"
description japanese "非戦闘ロボットを護衛/阻止せよ\nロボットを敵の目標地点まで到達させれば勝利\n\nプレイヤー数: 6-12"
description mexicanspanish "Los equipos se alternan escoltando a un robot no combativo en territorio enemigo. Entrega el robot para ganar.\n\nJugadores: 6-12"
description portuguese "Equipes alternam escoltando um robô não combatente até território inimigo. Entregue o robô para vencer.\n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ \n\n.ﺯﻮﻔﻟا ﻖﻴﻘﺤﺘﻟ ﺕﻮﺑﻭﺮﻟا ﻝﺎﺼﻳﺈﺑ ﻢﻗ .ﻭﺪﻌﻟا ﺔﻘﻄﻨﻣ ﻰﻟإ ﻲﻟﺎﺘﻗ ﺮﻴﻏ ﺕﻮﺑﻭر ﺔﻘﻓﺍﺮﻣ ﻰﻠﻋ ﻥﺎﻘﻳﺮﻔﻟا ﺏﻭﺎﻨﺘﻳ"
description traditionalchinese "雙方隊伍輪流護送非戰鬥型機器人至敵人的領地。送達機器人以獲勝。\n\n玩家人數: 6-12"
description simplifiedchinese "双方轮流护送一个非战斗机器人进入敌人控制区。送达机器人后获胜。\n\n玩家：6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_escort
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hs_escort,1
dlc1,hs_escort,1
dlc2,hs_escort,1
dlc3,hs_escort,1
dlc4,hs_escort,2
hidden

playlist 92
name english "Kill Confirmed"
name englisharabic "Kill Confirmed"
name french "Élimination confirmée"
name italian "Uccisione confermata"
name german "Abschuss bestätigt"
name spanish "Baja confirmada"
name polish "Likwidacja potw."
name russian "Подтверждение"
name japanese "K-CONFIRMED"
name mexicanspanish "Baja confirmada"
name portuguese "Baixa Confirmada"
name arabic "ﻞﺘﻘﻟا ﺪﻴﻛﺄﺗ"
name traditionalchinese "擊殺確認"
name simplifiedchinese "击杀确认"
description english "Collect enemy Dog Tags to score for your team.\n\nPlayers: 6-12"
description englisharabic "Collect enemy Dog Tags to score for your team.\n\nPlayers: 6-12"
description french "Récupérez les plaques ennemies pour marquer des points pour votre équipe.\n\nJoueurs : 6-12."
description italian "Raccogli le piastrine nemiche per ottenere punti per la tua squadra.\n\nGiocatori: 6-12"
description german "Sammeln Sie feindliche Marken, um für das eigene Team zu punkten.\n\nSpieler: 6-12"
description spanish "Recoge chapas de identificación enemigas para proporcionar puntos a tu equipo.\n\nJugadores: 6-12"
description polish "Zbierajcie wrogie nieśmiertelniki, aby zdobywać punkty dla swojej drużyny.\n\nGracze: 6-12"
description russian "Чтобы набирать очки, собирайте жетоны врагов.\n\n6-12 игроков"
description japanese "敵のドッグタグを集めてチームのポイントを獲得せよ\n\nプレイヤー数: 6-12"
description mexicanspanish "Recoge placas de identificación enemigas para proporcionar puntos a tu equipo.\n\nJugadores: 6-12"
description portuguese "Colete plaquetas de identificação inimigas para marcar pontos pela sua equipe.\n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ \n\n.ﻚﻘﻳﺮﻔﻟ ﻁﺎﻘﻨﻟا ﺪﺼﺤﺘﻟ ءﺍﺪﻋﻷا ﺩﻮﻨﺟ ﺔﻳﻮﻫ ﺢﺋﺎﻔﺻ ﻊﻤﺟا"
description traditionalchinese "收集敵方的兵籍牌，為你的隊伍取得積分。\n\n玩家人數：6-12"
description simplifiedchinese "收集敌人狗牌可以为你的队伍得分。\n\n玩家：6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_kill_confirm
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hs_conf,1
dlc1,hs_conf,1
dlc2,hs_conf,1
dlc3,hs_conf,1
dlc4,hs_conf,2
hidden

playlist 93
name english "Uplink"
name englisharabic "Uplink"
name french "Liaison"
name italian "Uplink"
name german "#same"
name spanish "Enlace"
name polish "Uplink"
name russian "Канал связи"
name japanese "UPLINK"
name mexicanspanish "Enlace"
name portuguese "Transmissão"
name arabic "ﻝﺎﺼﺗﻻا ﺓﺮﻛ"
name traditionalchinese "通訊戰"
name simplifiedchinese "上行传输"
description english "Upload the satellite drone into the enemy Uplink Station.\n\nPlayers: 6-12"
description englisharabic "Upload the satellite drone into the enemy Uplink Station.\n\nPlayers: 6-12"
description french "Envoyez le drone satellite au poste de liaison ennemi.\n\nJoueurs : 6-12."
description italian "Invia il drone satellite nella stazione uplink nemica.\n\nGiocatori: 6-12"
description german "Laden Sie die Satellitendrohne auf die feindliche Uplink-Station.\n\nSpieler: 6-12"
description spanish "Carga el dron satélite en el puesto de enlace enemigo.\n\nJugadores: 6-12"
description polish "Wgrywajcie dane do satelity poprzez łącze w bazie wroga.\n\nGracze: 6-12"
description russian "Загрузите дрон-спутник на вражескую станцию связи.\n\n6-12 игроков"
description japanese "敵のアップリンク・ステーションに\nサテライトドローンをアップロードせよ\n\nプレイヤー数: 6-12"
description mexicanspanish "Carga el dron satélite en el puesto de enlace enemigo.\n\nJugadores: 6-12"
description portuguese "Envie o VANT satélite para a estação de transmissão inimiga.\n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ \n\n.ﻭﺪﻌﻟا ﻝﺎﺼﺗا ﺔﻄﺤﻣ ﻰﻟإ ﻝﺎﺳﺭﻹا ﺓﺮﻛ ﻞﻴﻤﺤﺘﺑ ﻢﻗ"
description traditionalchinese "將衛星無人機上傳至敵方通訊站。\n\n玩家人數：6-12"
description simplifiedchinese "将卫星无人机上传至敌人的上行传输站。\n\n玩家：6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_ball
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hs_ball,1
dlc1,hs_ball,1
dlc2,hs_ball,1
dlc3,hs_ball,1
dlc4,hs_ball,2
hidden

playlist 94
name english "Fracture"
name englisharabic "Fracture"
name french "Fracture"
name italian "Frattura"
name german "Fraktur"
name spanish "Fractura"
name polish "Szczelina"
name russian "Разлом"
name japanese "FRACTURE"
name mexicanspanish "Fractura"
name portuguese "Fratura"
name arabic "ﻉﺪﺼﻟا"
name traditionalchinese "裂縫"
name simplifiedchinese "裂缝"
description english "Collect core files dropped by killed enemies and deliver them to the Fracture Site. \n\nPlayers: 6-12"
description englisharabic "Collect core files dropped by killed enemies and deliver them to the Fracture Site. \n\nPlayers: 6-12"
description french "Récupérez les fichiers lâchés par les ennemis abattus et apportez-les au site de fracture.\n\nJoueurs : 6-12"
description italian "Ottieni i file lasciati a terra dai nemici uccisi e portali alla frattura.\n\nGiocatori: 6-12"
description german "Sammeln Sie die von Feinden fallen gelassenen Dateien und bringen Sie sie zur Fraktur.\n\nSpieler: 6-12"
description spanish "Recoge archivos de enemigos asesinados y entrégalos en la zona de fractura. \n\nJugadores: 6-12"
description polish "Zbierajcie rdzenie upuszczane przez zabitych przeciwników i dostarczajcie je do szczeliny. \n\nGracze: 6-12"
description russian "Заберите файлы у убитых врагов и доставьте их к месту разлома. \n\n6-12 игроков"
description japanese "倒した敵のコアファイルを回収しフラクチャー地点へ届けろ\n\nプレイヤー数: 6-12"
description mexicanspanish "Recoge archivos de enemigos muertos y entrégalos en la zona de fractura.\n\nJugadores: 6-12"
description portuguese "Colete arquivos de sistema perdidos por inimigos mortos e entregue no local da fratura. \n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n\n .ﻉﺪﺼﻟا ﻊﻗﻮﻣ ﻰﻟإ ﺎﻬﻠﺻﻭﺃو ﻦﻴﻟﻮﺘﻘﻤﻟا ءﺍﺪﻋﻷا ﻦﻣ ﺔﻄﻗﺎﺴﻟا ﺔﻴﺴﻴﺋﺮﻟا ﺕﺎﻔﻠﻤﻟا ﻊﻤﺟا"
description traditionalchinese "收集被擊殺敵人掉落的碎片並存入裂縫。\n\n玩家人數：6-12"
description simplifiedchinese "击杀敌人后捡起他们掉落的核心文件，并将它们送到裂缝点。\n\n玩家：6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_clean
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
all,hs_clean,1
dlc1,hs_clean,1
dlc2,hs_clean,1
dlc3,hs_clean,1
dlc4,hs_clean,2
hidden

playlist 95
name english "Search & Destroy"
name englisharabic "Search & Destroy"
name french "Recherche et destruction"
name italian "Cerca e distruggi"
name german "Suchen & Zerstören"
name spanish "Buscar y destruir"
name polish "Znajdź i zniszcz"
name russian "Найти и уничтожить"
name japanese "SEARCH & DESTROY"
name mexicanspanish "Buscar y destruir"
name portuguese "L&D"
name arabic "ﺮﻴﻣﺪﺘﻟا و ﺚﺤﺒﻟا"
name traditionalchinese "搜索與摧毀"
name simplifiedchinese "搜索与摧毁"
description english "Defend and destroy the objective. No respawning.\n\nPlayers: 6-12\n"
description englisharabic "Defend and destroy the objective. No respawning.\n\nPlayers: 6-12\n"
description french "Défendez et détruisez l'objectif. Pas de réapparition.\n\nJoueurs : 6-12."
description italian "Difendi e distruggi l'obiettivo. Rientro non consentito.\n\nGiocatori: 6-12\n"
description german "Verteidigen oder zerstören Sie das Ziel. Kein Wiedereinstieg.\n\nSpieler: 6-12\n"
description spanish "Defiende y destruye el objetivo. Sin reapariciones.\n\nJugadores: 6-12\n"
description polish "Broń i niszcz cel. Bez odrodzenia.\n\nGracze: 6-12\n"
description russian "Защитите и уничтожьте цель. Возрождений нет.\n\n6-12 игроков\n"
description japanese "目標を防衛/破壊しろ。リスポーンなし\n\nプレイヤー数: 6-12\n"
description mexicanspanish "Defiende y destruye el objetivo. Sin reapariciones.\n\nJugadores: 6-12\n"
description portuguese "Defenda e destrua o objetivo. Sem reaparecimento.\n\nJogadores: 6-12\n"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n\n.ﺓﺎﻴﺤﻠﻟ ﺓﺩﻮﻋ ﺪﺟﻮﺗ ﻻ .هﺮﻣد ﻭأ ﻑﺪﻬﻟا ﻦﻋ ﻊﻓﺍد"
description traditionalchinese "防衛和摧毀目標。無重生機制。\n\n玩家人數：6-12\n"
description simplifiedchinese "保护/摧毁目标。没有重生。\n\n玩家：6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_search_destroy
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
// rule partyChatDisallowed 1 				// rule partyChatDisallowed 1 - this will kick any player who is currently in or joined a platform party chat
all,hs_sd,1
dlc1,hs_sd,1
dlc2,hs_sd,1
dlc3,hs_sd,1
dlc4,hs_sd,2
hidden

playlist 96
name english "Capture The Flag"
name englisharabic "Capture The Flag"
name french "Capture du drapeau"
name italian "Cattura la bandiera"
name german "Capture the Flag"
name spanish "Tomar la bandera"
name polish "Zdobądź flagę"
name russian "Захват флага"
name japanese "CAPTURE THE FLAG"
name mexicanspanish "Capturar la bandera"
name portuguese "Capture a Bandeira"
name arabic "ﺔﻳﺍﺮﻟا ﻰﻠﻋ ءﻼﻴﺘﺳﻻا"
name traditionalchinese "搶旗"
name simplifiedchinese "夺旗战"
description english "Get the enemy flag and return it to your base.\n\nPlayers: 6-12"
description englisharabic "Get the enemy flag and return it to your base.\n\nPlayers: 6-12"
description french "Prenez le drapeau ennemi et rapportez-le à votre base.\n\nJoueurs : 6-12."
description italian "Prendi la bandiera nemica e portala alla tua base.\n\nGiocatori: 6-12 "
description german "Holen Sie sich die feindliche Flagge und bringen Sie sie in Ihre Basis.\n\nSpieler: 6-12"
description spanish "Coge la bandera enemiga y llévala a tu base.\n\nJugadores: 6-12"
description polish "Zdobądź flagę przeciwnika i zanieś ją do swojej bazy.\n\nGracze: 6-12"
description russian "Захватите вражеский флаг и доставьте его на свою базу.\n\n6-12 игроков"
description japanese "敵のフラッグを奪い、味方の基地に持ち帰れ\n\nプレイヤー数: 6-12"
description mexicanspanish "Captura la bandera enemiga y llévala a tu base.\n\nJugadores: 6-12"
description portuguese "Obtenha a bandeira inimiga e retorne com ela à sua base.\n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ \n\n.ﻚﺗﺪﻋﺎﻗ ﻰﻟإ ﺎﻫﺪﻋﺃو ﻭﺪﻌﻟا ﺔﻳﺍر ﻰﻠﻋ ﺫﻮﺤﺘﺳا"
description traditionalchinese "取得敵方旗幟並送回己方基地。\n\n玩家人數：6-12"
description simplifiedchinese "夺取敌人旗帜并将其带回己方基地。\n\n玩家：6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_ctf
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hs_ctf,1
dlc1,hs_ctf,1
dlc2,hs_ctf,1
dlc3,hs_ctf,1
dlc4,hs_ctf,2
hidden

playlist 97
name english "Demolition"
name englisharabic "Demolition"
name french "Démolition"
name italian "Demolizione"
name german "Sprengkommando"
name spanish "Demolición"
name polish "Demolka"
name russian "Уничтожение"
name japanese "DEMOLITION"
name mexicanspanish "Demolición"
name portuguese "Demolição"
name arabic "ﺮﻴﺠﻔﺘﻟا"
name traditionalchinese "爆破"
name simplifiedchinese "爆破"
description english "Teams alternate in attacking and defending two bomb sites, both of which must be destroyed by the attacking team equipped with bombs.\n\nPlayers: 6-12"
description englisharabic "Teams alternate in attacking and defending two bomb sites, both of which must be destroyed by the attacking team equipped with bombs.\n\nPlayers: 6-12"
description french "Les équipes défendent et attaquent deux sites à tour de rôle, chaque site de bombe devant être détruit par l'équipe offensive possédant les bombes. \n\nJoueurs : 6-12"
description italian "Le squadre si alternano nell'attacco e nella difesa di due zone da far esplodere. Entrambe devono essere distrutte dalla squadra armata di bombe.\n\nGiocatori: 6-12"
description german "Die Teams attackieren und verteidigen abwechselnd zwei Bombenplätze. Beide müssen von den mit Bomben ausgerüsteten Angreifern zerstört werden.\n\nSpieler: 6-12"
description spanish "Los equipos se alternan atacando y defendiendo dos zonas de bombas, que deben ser destruidas con bombas por el equipo atacante.\n\nJugadores: 6-12"
description polish "Drużyny na zmianę atakują i bronią dwóch celów, które muszą zostać zniszczone bombami przez atakujących.\n\nGracze: 6-12"
description russian "Команды поочередно пытаются взорвать и защитить две цели. Для победы атакующей команде нужно взорвать обе.\n\nИгроки: 6-12"
description japanese "2つの爆破ポイントをめぐる攻防戦 攻撃チームは両ポイントを爆弾で破壊せよ\n\nプレイヤー数: 6-12"
description mexicanspanish "Los equipos se alternan atacando y defendiendo dos zonas de bombas, que deben ser destruidas con bombas por el equipo atacante.\n\nJugadores: 6-12"
description portuguese "As equipes se alternam entre ataque e defesa de dois locais de bomba, ambos os quais devem ser destruídos pela equipe atacante com bombas.\n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ \n\n.ﺯﻮﻔﻟا ﻖﻴﻘﺤﺘﻟ ﻦﻴﻌﻗﻮﻤﻟا ﺮﻴﻣﺪﺗ ﻢﺟﺎﻬﻤﻟا ﻖﻳﺮﻔﻟا ﻰﻠﻋ .ﺮﻴﺠﻔﺗ ﻦﻴﻌﻗﻮﻣ ﻦﻋ ﻉﺎﻓﺪﻟﺍو ﻡﻮﺠﻬﻟا ﻰﻠﻋ ﻥﺎﻘﻳﺮﻔﻟا ﺏﻭﺎﻨﺘﻳ"
description traditionalchinese "隊伍要輪流攻擊與防禦兩個爆破點，擁有炸彈的攻擊方必須要摧毀兩個爆破點才算勝利。\n\n玩家人數：6-12"
description simplifiedchinese "两支队伍分别攻击和防守两处爆炸点，进攻方必须摧毁两处爆炸点才能获胜。\n\n玩家：6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_demolition
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hs_dem,1
dlc1,hs_dem,1
dlc2,hs_dem,1
dlc3,hs_dem,1
dlc4,hs_dem,2
hidden

playlist 98
name english "Free-For-All"
name englisharabic "Free-For-All"
name french "Mêlée générale"
name italian "Tutti contro tutti"
name german "Frei für alle"
name spanish "Contra todos"
name polish "Deathmatch"
name russian "Свободная игра"
name japanese "FREE-FOR-ALL"
name mexicanspanish "Contra todos"
name portuguese "Contra Todos"
name arabic "ﻪﺴﻔﻨﻟ ﺐﻋﻻ ﻞﻛ"
name traditionalchinese "自由混戰"
name simplifiedchinese "混战"
description english "Straight up Deathmatch. Every man and woman for his or herself.\n\nPlayers: 4-8"
description englisharabic "Straight up Deathmatch. Every man and woman for his or herself.\n\nPlayers: 4-8"
description french "Match à mort classique. C'est chacun pour soi.\n\nJoueurs : 4-8"
description italian "Deathmatch, nudo e crudo. Ognuno per sé.\n\nGiocatori: 4-8"
description german "Ganz normales Deathmatch. Jeder kämpft hier für sich allein und gegen jeden.\n\nSpieler: 4-8"
description spanish "Duelo clásico. Sálvese quien pueda.\n\nJugadores: 4-8"
description polish "Zwykły deathmatch. Każdy jest zdany na siebie.\n\nGracze: 4-8"
description russian "Обычный командный бой. Каждый сам по себе.\n\nИгроки: 4-8"
description japanese "これぞデスマッチ。自分以外は全員敵の個人戦\n\nプレイヤー数: 4-8"
description mexicanspanish "Duelo clásico. Sálvese quien pueda.\n\nJugadores: 4-8"
description portuguese "Mata-Mata puro. É cada um por si.\n\nJogadores: 4-8"
description arabic "8-4 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n\n.ﻪﺴﻔﻨﻟ ﺐﻋﻻ ﻞﻛ .ﺔﻴﻟﺎﺘﻗ ﺓﺍﺭﺎﺒﻣ"
description traditionalchinese "痛快的死鬥模式。每個人都為了自己而戰。 \n\n玩家人數 :4-8"
description simplifiedchinese "简单直接的死亡竞赛。每个人为自己而战。\n\n玩家：4-8"
unlockxp 0
maxparty 1
maxlocalplayers 1
categories featured
icon playlist_ffa
parkingplaylist 9001
rule party_minplayers 4
rule party_maxplayers 8
// rule liveDedicatedOnly 1
all,hs_ffa,1
dlc1,hs_ffa,1
dlc2,hs_ffa,1
dlc3,hs_ffa,1
dlc4,hs_ffa,2
hidden

playlist 99
name english "Domination"
name englisharabic "Domination"
name french "Domination"
name italian "Dominio"
name german "Herrschaft"
name spanish "Dominio"
name polish "Dominacja"
name russian "Превосходство"
name japanese "DOMINATION"
name mexicanspanish "Dominio"
name portuguese "Dominação"
name arabic "ﺓﺮﻄﻴﺴﻟا"
name traditionalchinese "占領"
name simplifiedchinese "征服"
description english "Three areas in the level must be captured. Your team gets points for having control of an area. The more areas your team holds, the more points you gain.\n\nPlayers: 6-12"
description englisharabic "Three areas in the level must be captured. Your team gets points for having control of an area. The more areas your team holds, the more points you gain.\n\nPlayers: 6-12"
description french "Il y a 3 zones à capturer dans le niveau. Votre équipe marque des points dès qu'elle contrôle une zone. Plus votre équipe contrôle de zones, plus elle remporte de points.\n\nJoueurs : 6-12"
description italian "Devi catturare 3 aree. La tua squadra ottiene punti quando ha il controllo di un'area. Più aree controlla, più punti guadagna.\n\nGiocatori: 6-12"
description german "Drei Bereiche müssen eingenommen werden. Ihr Team punktet für die Kontrolle über einen Bereich. Je mehr Bereiche Ihr Team hält, desto mehr Punkte sammelt es.\n\nSpieler: 6-12"
description spanish "Hay que controlar 3 zonas en el nivel. Tu equipo recibirá puntos cada vez que tome el control de una zona. Cuantas más zonas controléis, más puntos obtendréis.\n\nJugadores: 6-12"
description polish "Trzeba zdobyć trzy obszary na poziomie. Drużyna zdobywa punkty za kontrolowanie jednego z nich. Im więcej przejętych obszarów, tym szybciej otrzymujesz punkty.\n\nGracze: 6-12"
description russian "Нужно захватить три района на карте эпизода. Ваша команда получает очки за контроль над районом. Чем больше районов удерживает ваша команда, тем больше очков вы получаете.\n\nИгроки: 6-12"
description japanese "3ヶ所のエリアを奪取してポイントを獲得せよ\n奪取したエリアが多いと獲得ポイントも増加\n\nプレイヤー数: 6-12"
description mexicanspanish "Hay que controlar 3 zonas en el nivel. Tu equipo recibirá puntos cada vez que tome el control de una zona. Mientras más zonas controlen, más puntos obtendrán.\n\nJugadores: 6-12"
description portuguese "Três áreas devem ser capturadas no nível. A sua equipe ganha pontos ao controlar uma área. Quanto mais áreas a sua equipe tomar, mais pontos você ganhará.\n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ \n\n.ﺔﻘﻄﻨﻤﻟا ﻰﻠﻋ ﻪﺗﺮﻄﻴﺳ ﺪﻨﻋ ﻁﺎﻘﻨﻟﺎﺑ ﻚﻘﻳﺮﻓ ﺯﻮﻔﻳ .ﺔﻠﺣﺮﻣ ﻞﻛ ﻲﻓ ﻖﻃﺎﻨﻣ 3 ﻰﻠﻋ ﺫﺍﻮﺤﺘﺳﻻا ﺐﺠﻳ"
description traditionalchinese "需要佔領關卡中的三個區域。控制一個區域後，團隊就能得分。控制越多區域，得分越高。\n\n玩家人數：6-12"
description simplifiedchinese "必须占领该关卡中的三个区域。你的队伍会在控制一个区域后获得得分。控制的区域越多，获得的分数也越多。\n\n玩家：6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_domination
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
// rule liveDedicatedOnly 1
all,hs_dom,1
dlc1,hs_dom,1
dlc2,hs_dom,1
dlc3,hs_dom,1
dlc4,hs_dom,2
hidden

playlist 100
name english "Hardcore - TDM"
name englisharabic "Hardcore - TDM"
name french "MME - Hardcore"
name italian "DMS Veterano"
name german "Hardcore - TDM"
name spanish "DPE extremo"
name polish "DDM – hardcore"
name russian "Хардкор - КБ"
name japanese "HARDCORE - TDM"
name mexicanspanish "DPE extremo"
name portuguese "MME - Extremo"
name arabic "ﺪﻳﺪﺷ - ﺔﻴﻋﺎﻤﺟ ﺓﺍﺭﺎﺒﻣ"
name traditionalchinese "硬派－團隊死鬥"
name simplifiedchinese "精英模式 - 团队死斗"
description english "Hardcore Team Deathmatch. Limited HUD, low health, friendly fire enabled, and much more.\n\nPlayers: 6-12"
description englisharabic "Hardcore Team Deathmatch. Limited HUD, low health, friendly fire enabled, and much more.\n\nPlayers: 6-12"
description french "Match à mort par équipe Hardcore. ATH limité, santé faible, tir allié activé et plus encore.\n\nJoueurs : 6-12"
description italian "Deathmatch a squadre Veterano. Interfaccia limitata, salute ridotta, fuoco amico attivato e molto altro.\n\nGiocatori: 6-12"
description german "Hardcore-Team-Deathmatch. Eingeschränktes HUD, geringe Gesundheit, Teambeschuss aktiviert und noch viel mehr.\n\nSpieler: 6-12"
description spanish "Duelo por equipos extremo. HUD limitado, poca salud, fuego amigo activado y mucho más.\n\nJugadores: 6-12"
description polish "Drużynowy deathmatch hardcore. Ograniczony HUD, mniej życia, włączony ostrzał sojuszniczy i inne elementy.\n\nGracze: 6-12"
description russian "Командный бой, хардкор. Ограниченный интерфейс, меньший запас здоровья, урон своим и другие особенности.\n\nИгроки: 6-12"
description japanese "HUD制限ありのHC: TEAM DEATHMATCH\n体力減、味方への誤射あり等\n\nプレイヤー数: 6-12"
description mexicanspanish "Duelo por equipos extremo. HUD limitado, poca salud, fuego amigo activado y mucho más.\n\nJugadores: 6-12"
description portuguese "Mata-mata em Equipe Extremo. HUD limitado, pouca saúde, fogo amigo e muito mais.\n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ \n\n.ﺪﻳﺰﻤﻟﺍو .ﺔﻠﻌﻔﻣ ﺔﻘﻳﺪﺻ ﻥﺍﺮﻴﻧ .ﺔﻠﻴﻠﻗ ﺔﺤﺻ .ﺓﺩﻭﺪﺤﻣ ﺽﺮﻋ ﺔﺷﺎﺷ .ﺓﺪﻳﺪﺷ ﺔﻴﻋﺎﻤﺟ ﺓﺍﺭﺎﺒﻣ"
description traditionalchinese "硬派團隊死鬥。有限HUD資訊，低生命值，友軍誤傷功能開啟，及其他。\n\n玩家人數: 6-12"
description simplifiedchinese "精英团队死斗。HUD受限、低生命值、开启友军伤害以及更多挑战。\n\n玩家: 6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_tdm
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
all,hc_tdm,1
dlc1,hc_tdm,1
dlc2,hc_tdm,1
dlc3,hc_tdm,1
dlc4,hc_tdm,2
hidden

playlist 101
name english "Chaos Moshpit"
name englisharabic "Chaos Moshpit"
name french "Moshpit chaos"
name italian "Moshpit Caos"
name german "Chaos-Mosh-Pit"
name spanish "Foso Caos"
name polish "Chaotyczny Młyn "
name russian "Мясорубка (хаос)"
name japanese "CHAOS MOSHPIT"
name mexicanspanish "Foso del caos"
name portuguese "Moshpit Caótico"
name arabic "ﺏﺎﻌﻟﻷا ﻂﻴﻠﺧ ﻰﺿﻮﻓ"
name traditionalchinese "無序大混戰"
name simplifiedchinese "混沌乱斗"
description english "A collection of smaller maps (including Nuk3town!)  and frenetic, fast-paced game modes.\n\nPlayers: 6-12"
description englisharabic "A collection of smaller maps (including Nuk3town!)  and frenetic, fast-paced game modes.\n\nPlayers: 6-12"
description french "Une collection de cartes plus petites (dont Nuk3town !) et des modes de jeu frénétiques.\n\nJoueurs : 6-12"
description italian "Una raccolta di mappe di dimensioni ridotte (incusa Nuk3town!) e modalità di gioco frenetiche.\n\nGiocatori: 6-12"
description german "Eine Sammlung kleinerer Karten (inkl. Nuk3town!) und wilden, schnellen Spielmodi.\n\nSpieler: 6-12"
description spanish "Una colección de mapas más pequeños (¡Nuk3town incluido!) y modos de juego ágiles y frenéticos.\n\nJugadores: 6-12"
description polish "Zbiór mniejszych map (w tym Nuk3town!) i szybkich, chaotycznych trybów.\n\nGracze: 6-12"
description russian "Набор карт меньшего размера (включая Nuk3town!) и безбашенные стремительные игровые режимы.\n\nИгроки: 6-12"
description japanese "小さいマップ(NUK3TOWNを含む)と\nファストペースのゲームモード\n\nプレイヤー数: 6-12"
description mexicanspanish "Una colección de mapas más pequeños (incluido Nuk3town) y modos de juego rápidos y frenéticos.\n\nJugadores: 6-12"
description portuguese "Uma coleção de mapas menores (incluindo Nuk3town!) e modos de jogo rápidos e frenéticos.\n\nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n\n.ﺔﻋﺮﺴﻟا ﺓﺪﻳﺪﺷ ﺓﺮﻴﺜﻤﻟا ﺐﻌﻠﻟا ﻁﺎﻤﻧﺃو (!Nuk3town ﺎﻬﻴﻓ ﺎﻤﺑ) ﺓﺮﻴﻐﺼﻟا ﻂﺋﺍﺮﺨﻟا ﻦﻣ ﺔﻋﻮﻤﺠﻣ"
description traditionalchinese "小地圖合集（包含Nuk3town!）及激烈、快節奏的遊戲模式\n\n玩家人數：6-12"
description simplifiedchinese "小地图合集(包括Nuk3town！)，以及更刺激，快节奏的游戏模式。\n\n玩家: 6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_generic_02
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
rule scr_xpscalemp 1
// rule xpGroups everyone
// rule lobbySearchDatacenterType 2
dlcname dlc0mp
hideifmissingdlc
mp_nuketown_x,hs_dom,2
mp_nuketown_x,hs_koth,2
mp_nuketown_x,hs_conf,2
mp_nuketown_x,hs_tdm,2
mp_nuketown_x,hs_ball,2
mp_nuketown_x,hs_escort,2
smallmaps,hs_dom,1
smallmaps,hs_koth,1
smallmaps,hs_conf,1
smallmaps,hs_ball,1
smallmaps,hs_escort,1
mp_skyjacked,hs_dom,1
mp_skyjacked,hs_koth,1
mp_skyjacked,hs_conf,1
mp_skyjacked,hs_tdm,1
mp_skyjacked,hs_ball,1
mp_skyjacked,hs_escort,1
mp_conduit,hs_dom,1
mp_conduit,hs_koth,1
mp_conduit,hs_conf,1
mp_conduit,hs_tdm,1
mp_conduit,hs_ball,1
mp_conduit,hs_escort,1
mp_cryogen,hs_dom,1
mp_cryogen,hs_koth,1
mp_cryogen,hs_conf,1
mp_cryogen,hs_tdm,1
mp_cryogen,hs_ball,1
mp_cryogen,hs_escort,1
hidden

playlist 102
name english "Blackjack’s Gun Game"
name englisharabic "Blackjack’s Gun Game"
name french "Jeu d'armes de Blackjack"
name italian "Gioco delle armi di Blackjack"
name german "Blackjacks Waffenspiel"
name spanish "Juego de armas de Blackjack"
name polish "Zabawa z bronią Blackjacka"
name russian "Перестрелка Блэкджека"
name japanese "Blackjack GUN GAME"
name mexicanspanish "Juego de armas de Blackjack"
name portuguese "Jogo de Armas de Blackjack"
name arabic "ﻙﺎﺟ ﻙﻼﺑ ﺔﺤﻠﺳأ ﺔﺒﻌﻟ"
name traditionalchinese "Blackjack軍火之王"
name simplifiedchinese "Blackjack的枪械游戏"
description english "Blackjack: “You ready for something a little more...Extreme?  I got clients who’ll double down to see you duke it out using my state-of-the-art Black Market weapons. To the death, of course...\n\nPlayers: 6-8"
description englisharabic "Blackjack: “You ready for something a little more...Extreme?  I got clients who’ll double down to see you duke it out using my state-of-the-art Black Market weapons. To the death, of course...\n\nPlayers: 6-8"
description french "Blackjack : \"Ça vous dit, quelque chose d'un peu plus... extrême ? J'ai des clients prêts à miser gros pour vous voir combattre avec mes armes les plus high-tech du Marché Noir. Jusqu'à la mort, bien sûr...\"\n\nJoueurs: 6-8"
description italian "Blackjack: \"Cosa ne dici di qualcosa di più... estremo? Ho alcuni clienti disposti a pagare doppio pur di vederti combattere con le mie spettacolari armi del mercato nero. Fino alla morte, ovviamente…\"\n\nGiocatori: 6-8"
description german "Blackjack: “Bereit für was ... Extremeres? Ich hab Klienten, die dafür zahlen würden, einen Kampf mit meinen modernen Schwarzmarktwaffen zu sehen. Bis aufs Blut, versteht sich ...”\n\nSpieler: 6-8"
description spanish "Blackjack: \"¿Estás listo para algo más... extremo? Tengo clientes que doblarían su apuesta por verte luchar utilizando mis armas de última generación del mercado negro. Hasta la muerte, por supuesto...\"\n\nJugadores: 6-8"
description polish "Blackjack: Chcesz czegoś ciut bardziej... ekstremalnego? Mam klientów, którzy dobrze zapłacą za oglądanie waszych starć z moją czarnorynkową bronią. Do śmierci, oczywiście...\n\nGracze: 6-8"
description russian "Блэкджек: ''Хотите чего-то более... экстремального?  У меня есть клиенты, которые хотели бы посмотреть, как вы используйте новейшие образцы оружия с черного рынка. В боевых условиях, разумеется…''\n\nИгроки: 6-8"
description japanese "Blackjack「まだまだ刺激が足りないって？それなら、俺のブラックマーケットの一級品の武器でお前が戦うことに、倍賭けてもいいって客がいるんだ。もちろん、死ぬほうにな…。」\n\nプレイヤー数: 6-8"
description mexicanspanish "Blackjack: \"¿Estás listo para algo más... extremo? Tengo clientes que doblarían su apuesta por verte luchar utilizando mis armas de última generación del mercado negro. Hasta la muerte, por supuesto...\"\n\nJugadores: 6-8"
description portuguese "Blackjack: \"Tá pronto para uma coisa mais... Extrema? Tenho clientes que dariam o dobro pra ver você acabar com tudo com minhas armas de alta tecnologia do Mercado Negro. Até à morte, claro...\"\n\nJogadores: 6-8"
description arabic "8-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋn\n\...ﻊﺒﻄﻟﺎﺑ ،ﺕﻮﻤﻟا ﻰﺘﺣ ﻝﺎﺘﻗ ﺮﺒﻋ .ﺓﺩﻮﺠﻟا ﺔﻘﺋﺎﻔﻟا ءﺍﺩﻮﺴﻟا ﻲﻗﻮﺳ ﺔﺤﻠﺳأ ﻡﺪﺨﺘﺴﺗ ﺖﻧﺃو ﻝﺎﺘﻘﻟا ﺕﺎﺣﺎﺳ ﻰﻠﻋ ﻚﺗﺪﻫﺎﺸﻤﻟ ﺔﻠﺋﺎﻃ ﻎﻟﺎﺒﻣ ﻊﻓﺪﻟ ﻥﻭﺪﻌﺘﺴﻣ ءﻼﻤﻋ ﻱﺪﻟ ؟ﺓﺭﺎﺛإ ...ﺮﺜﻛأ ﺓﺮﻣﺎﻐﻤﻟ ﺪﻌﺘﺴﻣ ﺖﻧأ ﻞﻫ :Blackjack"
description traditionalchinese "Blackjack：準備好來點…刺激的玩意嗎？有大老闆出雙倍價錢，要你們使用我這裡最新的黑市武器廝殺…至死方休。\n\n玩家人數：6-8"
description simplifiedchinese "Blackjack：“想不想来点刺激的……极其刺激的？一个客户支付了双倍的钱，来欣赏你们用最尖端的黑市武器对决。当然，战斗要至死方休……”\n\n玩家：6-8"
unlockxp 0
icon playlist_gungame_promo
parkingplaylist 9001
maxparty 1
maxlocalplayers 1
categories featured
rule party_minplayers 6
rule party_maxplayers 8
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
smallmaps,hs_gun,1
mp_skyjacked,hs_gun,1
mp_conduit,hs_gun,1
mp_cryogen,hs_gun,1
hidden

playlist 103
name english "Ground War"
name englisharabic "Ground War"
name french "Guerre terrestre"
name italian "Guerra terrestre"
name german "Bodenkrieg"
name spanish "Guerra terrestre"
name polish "Wojna lądowa"
name russian "Наземная война"
name japanese "GROUND WAR"
name mexicanspanish "Guerra terrestre"
name portuguese "Guerra Terrestre"
name arabic "ﺔﻴﻧﺍﺪﻴﻤﻟا ﺏﺮﺤﻟا"
name traditionalchinese "全面開戰"
name simplifiedchinese "地面战争"
description english "Big team games of Team Deathmatch, Domination, and Safeguard.\n\nPlayers: 12-18"
description englisharabic "Big team games of Team Deathmatch, Domination, and Safeguard.\n\nPlayers: 12-18"
description french "Grandes équipes en Match à mort par équipe, Domination et Dernier rempart.\n\nJoueurs : 12-18. "
description italian "Grandi partite di Deathmatch a squadre, Dominio e Salvaguardia.\n\nGiocatori: 12-18"
description german "Große Teamspiele mit Team-Deathmatch, Herrschaft und Geleitschutz.\n\nSpieler: 12-18"
description spanish "Partidas con equipos numerosos de Duelo por equipos, Dominio y Salvaguarda.\n\nJugadores: 12-18"
description polish "Gry dla większych drużyn w DM Drużynowy, Dominacja i Ochrona.\n\nGracze: 12-18 "
description russian "Большие сражения в режимах Командный бой, Превосходство и Охрана.\n\n12-18 игроков"
description japanese "大人数のTDM、DOMINATION、SAFEGUARD\n\nプレイヤー数: 12-18"
description mexicanspanish "Partidas con equipos numerosos de Duelo por equipos, Dominio y Salvaguarda.\n\nJugadores: 12-18"
description portuguese "Jogos de grandes equipes de Dominação, Proteção e Mata-Mata em Equipe.\n\nJogadores: 12-18"
description arabic "18-12 ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n\n.ﺕﻮﺑﻭﺮﻟا ﺔﻘﻓﺍﺮﻣ و ﺓﺮﻄﻴﺴﻟﺍو ﺔﻴﻋﺎﻤﺟ ﺓﺍﺭﺎﺒﻣ ﻁﺎﻤﻧأ ﻦﻣ ﺓﺮﻴﺒﻛ ﻙﺭﺎﻌﻣ"
description traditionalchinese "團隊死鬥、占領及保衛等大型團隊遊戲。\n\n玩家人數: 12-18"
description simplifiedchinese "团队死斗、征服和护送相结合的大型团队竞赛。\n\n玩家：12-18"
unlockxp 0
maxparty 9
maxlocalplayers 2
categories featured
icon playlist_war
parkingplaylist 9001
rule party_minplayers 12
rule party_maxplayers 18
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
// rule lobbySearchDatacenterType 2
bigmaps,hs_dom,1
bigmaps,big_tdm,1
bigmaps,hs_escort,1
mp_waterpark,hs_dom,1
mp_waterpark,big_tdm,1
mp_waterpark,hs_escort,1
mp_rise,hs_dom,1
mp_rise,big_tdm,1
mp_rise,hs_escort,1
mp_aerospace,hs_dom,1
mp_aerospace,big_tdm,1
mp_aerospace,hs_escort,1
mp_banzai,hs_dom,1
mp_banzai,big_tdm,1
mp_banzai,hs_escort,1
mp_city,hs_dom,1
mp_city,big_tdm,1
mp_city,hs_escort,1
hidden

playlist 104
nameref PLAYLIST_PLAYLIST_INFECT
descriptionref PLAYLIST_PLAYLIST_INFECT_DESC
unlockxp 0
maxparty 1
maxlocalplayers 2
categories featured
icon playlist_infect
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
rule gts restricteditems 92 1 // Restrict Gambler Ability
rule gts restricteditems 93 1 // Restrict Rogue Ability
rule gts prematchrequirement 6
rule gts prematchrequirementtime 30
// rule liveDedicatedOnly 1
all,hs_infect,1
dlc1,hs_infect,1
dlc2,hs_infect,1
mp_arena,hs_infect,1
mp_cryogen,hs_infect,1
mp_rome,hs_infect,1
mp_city,hs_infect,1
mp_miniature,hs_infect,1
mp_western,hs_infect,1
hidden

playlist 105
nameref PLAYLIST_PLAYLIST_REDWOOD
descriptionref PLAYLIST_PLAYLIST_REDWOOD_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_generic_02
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
mp_redwood_ice,hs_dom,1
mp_redwood_ice,hs_koth,1
mp_redwood_ice,hs_conf,1
mp_redwood_ice,hs_tdm,1
mp_redwood_ice,hs_ball,1
mp_redwood_ice,hs_escort,1
mp_redwood_ice,hs_clean,1
hidden

playlist 106
nameref PLAYLIST_PLAYLIST_PROP
descriptionref PLAYLIST_PLAYLIST_PROP_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_prop_hunt
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
rule gts prematchrequirement 3
rule gts prematchrequirementtime 30
// rule liveDedicatedOnly 1
mp_biodome,hs_prop,1
mp_spire,hs_prop,1
mp_sector,hs_prop,1
mp_apartments,hs_prop,1
mp_chinatown,hs_prop,1
mp_veiled,hs_prop,1
mp_ethiopia,hs_prop,1
mp_infection,hs_prop,1
mp_redwood,hs_prop,1
mp_nuketown_x,hs_prop,1
hidden

playlist 107
nameref PLAYLIST_PLAYLIST_VEILED_HEYDAY
descriptionref PLAYLIST_PLAYLIST_VEILED_HEYDAY_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_generic_02
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
mp_veiled_heyday,hs_dom,1
mp_veiled_heyday,hs_koth,1
mp_veiled_heyday,hs_conf,1
mp_veiled_heyday,hs_tdm,1
mp_veiled_heyday,hs_ball,1
mp_veiled_heyday,hs_escort,1
mp_veiled_heyday,hs_clean,1
hidden

playlist 108
nameref PLAYLIST_PLAYLIST_SAS
descriptionref PLAYLIST_PLAYLIST_SAS_DESC
unlockxp 0
maxparty 1
maxlocalplayers 1
categories featured
icon playlist_sticksnstones
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
sortOrder 0
all,hs_sas,1
dlc1,hs_sas,1
dlc2,hs_sas,1
dlc3,hs_sas,1
dlc4,hs_sas,1
hidden

playlist 109
nameref PLAYLIST_PLAYLIST_SNIPERONLY
descriptionref PLAYLIST_PLAYLIST_SNIPERONLY_DESC
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_sniper_only
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
// rule liveDedicatedOnly 1
rule gts restricteditems 93 1 // Restrict Rogue Ability
sortOrder 0
all,hs_sniperonly,1
dlc1,hs_sniperonly,1
dlc2,hs_sniperonly,1
dlc3,hs_sniperonly,1
dlc4,hs_sniperonly,1
hidden

playlist 112
name english "Flags and Bombs"
name englisharabic "Flags and Bombs"
name french "Drapeaux et bombes"
name italian "Bombe e bandiere"
name german "Flaggen und Bomben"
name spanish "Banderas y bombas"
name polish "Flagi i bomby"
name russian "Флаги и бомбы"
name japanese "FLAGS & BOMBS"
name mexicanspanish "Banderas y bombas"
name portuguese "Bandeiras e Bombas"
name arabic "ﻞﺑﺎﻨﻘﻟﺍو ﺕﺎﻳﺍﺮﻟا"
name traditionalchinese "旗幟與炸彈"
name simplifiedchinese "夺旗和炸弹"
description english "This weekend only, play in a moshpit of objective game modes based around capturing flags and planting bombs. Capture the Flag, Demolition, and Search and Destroy. \nPlayers: 6-12"
description englisharabic "This weekend only, play in a moshpit of objective game modes based around capturing flags and planting bombs. Capture the Flag, Demolition, and Search and Destroy. \nPlayers: 6-12"
description french "Uniquement ce week-end, vous pouvez jouer à un mélange de différents modes objectifs, basés principalement sur la capture de drapeau et la pose de bombe. Capture du drapeau, Démolition et Recherche et destruction. \nJoueurs : 6-12"
description italian "Solo per questo weekend, gioca un moshpit di modalità a obiettivo basate su bandiere da catturare e bombe da piazzare. Cattura la bandiera, Demolizione e Cerca e distruggi.\nGiocatori: 6-12"
description german "Nur an diesem Wochenende: Spielen Sie ein Mosh-Pit zielbasierter Spielmodi mit Flaggeneinnahme und Bombenplatzieren. Capture the Flag, Sprengkommando und Suchen & Zerstören.\nSpieler: 6-12"
description spanish "Solo este fin de semana, juega a modos por objetivos relacionados con tomas de banderas y colocación de bombas. Tomar la bandera, Demolición, y Buscar y destruir.\nJugadores: 6-12"
description polish "Tylko w ten weekend, graj w różne tryby gry z celami, zdobywając flagi i podkładając bomby na: Zdobądź flagę, Demolka oraz Znajdź i Zniszcz. \nGracze: 6-12"
description russian "Играйте на этих выходных в мусорубке режимов игры с целями, в которых нужно захватить флаг или установить бомбы: ''Захват флага'', ''Уничтожение'' и ''Найти и уничтожить''.\n6-12 игроков"
description japanese "今週末に限り、フラッグ奪取や爆弾設置をベースとする様々な目標ゲームモードをプレイ可能。CTF、DEMOLITION、SEARCH & DESTROY\nプレイヤー数: 6-12"
description mexicanspanish "Solo este fin de semana, juega a modos por objetivos relacionados con capturas de banderas y colocación de bombas. Capturar la bandera, Demolición, y Buscar y destruir.\nJugadores: 6-12"
description portuguese "Somente nesta semana, jogue em um recorte de objetivos de modos de jogo que gira em torno de capturar a bandeira e plantar bombas. Capture a Bandeira, Demolição e Localizar e Destruir. \nJogadores: 6-12"
description arabic "12-6 :ﻦﻴﺒﻋﻼﻟا ﺩﺪﻋ\n .ﺮﻴﻣﺪﺘﻟﺍو ﺚﺤﺒﻟﺍو ،ﺮﻴﺠﻔﺘﻟا ،ﺔﻳﺍﺮﻟا ﻰﻠﻋ ءﻼﻴﺘﺳﻻا .ﻞﺑﺎﻨﻘﻟا ﺔﻋﺍﺭﺯو ﺕﺎﻳﺍﺮﻟا ﻰﻠﻋ ءﻼﻴﺘﺳﻻا ﻞﺜﻣ ﻑﺍﺪﻫأ ﻖﻴﻘﺤﺗ ﻰﻠﻋ ﺓﺪﻤﺘﻌﻤﻟا ﺐﻌﻠﻟا ﻁﺎﻤﻧأ ﻦﻣ ﻂﻴﻠﺧ ﻲﻓ ﺐﻌﻟا ،ﻉﻮﺒﺳﻷا ﺍﺬﻫ ﺔﻳﺎﻬﻧ ﺔﻠﻄﻋ ﻝﻼﺧ ﻂﻘﻓ"
description traditionalchinese "只限本週，在以爭奪旗幟和放置炸彈為目標的多種遊戲模式中恣意酣戰，包括搶旗、爆破、以及搜索與摧毀。\n玩家人數：6-12"
description simplifiedchinese "本周末限时活动，围绕夺旗和安装炸弹的模式进行乱斗游戏。夺旗战，爆破和搜索与摧毁。\n玩家：6-12"
unlockxp 0
maxparty 6
maxlocalplayers 2
categories featured
icon playlist_flagsbombs
parkingplaylist 9001
rule party_minplayers 6
rule party_maxplayers 12
rule party_matchedplayercount 0
all,hs_ctf,1
all,hs_dom,1
all,hs_sd,1
hidden

///////////////////////////////////////////////////////////////////////////
//      ZOMBIES
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
//    ZOMBIES PLAYLISTS (Playlist# 150 - 200)
///////////////////////////////////////////////////////////////////////////

playlist 150
name english "Shadows of Evil"
name englisharabic "Shadows of Evil"
name french "Shadows of Evil"
name italian "Shadows of Evil"
name german "Shadows of Evil"
name spanish "Shadows of Evil"
name polish "Shadows of Evil"
name russian "Shadows of Evil"
name japanese "SHADOWS OF EVIL"
name mexicanspanish "Shadows of Evil"
name portuguese "Shadows of Evil"
name arabic "Shadows of Evil"
name traditionalchinese "Shadows of Evil"
name simplifiedchinese "Shadows of Evil"
description english "Continue the fight against the undead and search for clues to the truth of what lies ahead..."
description englisharabic "Continue the fight against the undead and search for clues to the truth of what lies ahead..."
description french "Continuez le combat contre des hordes de morts-vivants et réunissez des indices sur ce qui vous attend."
description italian "Continua a combattere contro i non morti e cerca di scoprire la verità su quello che ti attende..."
description german "Setzen Sie den Kampf gegen die Untoten fort und suchen Sie nach Hinweisen auf die Wahrheit dessen, was vor Ihnen liegt ..."
description spanish "Sigue luchando contra los zombis y busca pistas sobre lo que te espera..."
description polish "Kontynuuj walkę z hordami nieumarłych i poszukaj śladów tego, co się ma zdarzyć..."
description russian "Продолжайте войну против нежити и ищите подсказки о том, что ждет вас впереди..."
description japanese "ゾンビの大群と戦い続けながら\nその先にある真実の糸口を探求せよ"
description mexicanspanish "Sigue luchando contra los zombis y busca pistas sobre lo que te espera..."
description portuguese "Continue na luta contra os mortos-vivos e procure pistas sobre a verdade oculta..."
description arabic "...ﻙﺮﻈﺘﻨﺗ ﻲﺘﻟا ﺔﻘﻴﻘﺤﻟا ﻰﻠﻋ ﻞﺋﻻد ﻦﻋ ﺚﺤﺑﺍو ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﻝﺎﺘﻗ ﻊﺑﺎﺗ"
description traditionalchinese "一面繼續和殭屍奮鬥，一面尋找前方的真相..."
description simplifiedchinese "与不死僵尸继续战斗，搜寻线索查出最终的真相..."
unlockxp 0
maxparty 4
maxlocalplayers 2
categories zm_zod
icon img_t7_menu_zm_preview_zod
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_zod,zclassic,1

playlist 151 // t7
name english "The Giant"
name englisharabic "The Giant"
name french "The Giant"
name italian "The Giant"
name german "The Giant"
name spanish "The Giant"
name polish "The Giant"
name russian "The Giant"
name japanese "THE GIANT"
name mexicanspanish "The Giant"
name portuguese "The Giant"
name arabic "The Giant"
name traditionalchinese "The Giant"
name simplifiedchinese "The Giant"
description english "Continue the fight against the undead and search for clues to the truth of what lies ahead..."
description englisharabic "Continue the fight against the undead and search for clues to the truth of what lies ahead..."
description french "Continuez le combat contre des hordes de mort-vivants et réunissez des indices sur ce qui vous attend."
description italian "Continua a combattere contro i non morti e cerca di scoprire la verità su quello che ti attende..."
description german "Setzen Sie den Kampf gegen die Untoten fort und suchen Sie nach Hinweisen auf die Wahrheit dessen, was vor Ihnen liegt ..."
description spanish "Sigue luchando contra los zombis y busca pistas sobre lo que te espera..."
description polish "Kontynuuj walkę z hordami nieumarłych i poszukaj śladów tego, co się ma zdarzyć..."
description russian "Продолжайте войну против нежити и ищите подсказки о том, что ждет вас впереди..."
description japanese "ゾンビの大群と戦い続けながら\nその先にある真実の糸口を探求せよ"
description mexicanspanish "Sigue luchando contra los zombis y busca pistas sobre lo que te espera..."
description portuguese "Continue na luta contra os mortos-vivos e procure pistas sobre a verdade oculta..."
description arabic "...ﻙﺮﻈﺘﻨﺗ ﻲﺘﻟا ﺔﻘﻴﻘﺤﻟا ﻰﻠﻋ ﻞﺋﻻد ﻦﻋ ﺚﺤﺑﺍو ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﻝﺎﺘﻗ ﻊﺑﺎﺗ"
description traditionalchinese "一面繼續和殭屍奮鬥，一面尋找前方的真相..."
description simplifiedchinese "与不死僵尸继续战斗，搜寻线索查出最终的真相..."
unlockxp 0
dlcname dlc0zm
maxparty 4
maxlocalplayers 2
categories zm_factory
icon img_mapvote_zm_factory
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_factory,zclassic,1

playlist 152
name english "Der Eisendrache"
name englisharabic "Der Eisendrache"
name french "Der Eisendrache"
name italian "Der Eisendrache"
name german "Der Eisendrache"
name spanish "Der Eisendrache"
name polish "Der Eisendrache"
name russian "Der Eisendrache"
name japanese "Der Eisendrache"
name mexicanspanish "Der Eisendrache"
name portuguese "Der Eisendrache"
name arabic "Der Eisendrache"
name traditionalchinese "Der Eisendrache"
name simplifiedchinese "Der Eisendrache"
description english "Bound together by a fragile alliance, our heroes pursue the scattered remnants of Group 935 to their mountain top fortress in the Austrian Alps..."
description englisharabic "Bound together by a fragile alliance, our heroes pursue the scattered remnants of Group 935 to their mountain top fortress in the Austrian Alps..."
description french "Liés par une fragile alliance, nos héros suivirent les restes du Groupe 935 jusqu'à leur forteresse au sommet d'une montagne des Alpes autrichiennes... "
description italian "Uniti da una fragile alleanza, i nostri eroi seguono le tracce del gruppo 935 fino alla loro fortezza sulle Alpi austriache..."
description german "Vereint durch eine brüchige Allianz verfolgen unsere Helden die verbliebenen Mitglieder von Gruppe 935 in ihre Festung mitten in den österreichischen Alpen ..."
description spanish "Unidos por una frágil alianza, nuestros héroes persiguen a los miembros dispersos del Grupo 935 hasta su fortaleza en lo alto de una montaña de los Alpes austríacos..."
description polish "Połączeni kruchym sojuszem, nasi bohaterowie ścigają ocalałych członków Grupy 935 w ich górskiej fortecy w Austriackich Alpach..."
description russian "Герои, заключившие между собой недолговечный союз, преследуют разбросанных членов группы 935, остатки которой направляются к крепости на вершине австрийских Альп..."
description japanese "危うい同盟関係のもと、あの男たちは935部隊の痕跡を追ってオーストリアアルプス山頂の要塞へと向かう..."
description mexicanspanish "Unidos por una frágil alianza, nuestros héroes persiguen a los miembros dispersos del Grupo 935 hasta su fortaleza en lo alto de una montaña de los Alpes austríacos..."
description portuguese "Unidos por uma frágil aliança, nossos heróis seguem os membros restantes do grupo 935 até sua fortaleza no topo de uma montanha nos Alpes Austríacos..."
description arabic "...ﺔﻳﻭﺎﺴﻤﻨﻟا ﺐﻟﻷا ﻝﺎﺒﺟ ﻰﻠﻋأ ﺓﺩﻮﺟﻮﻤﻟا ﻢﻬﺘﻌﻠﻗ ﻰﻟإ 935 ﺔﻋﻮﻤﺠﻣ ﻦﻣ ﺓﺮﺛﺎﻨﺘﻤﻟا ﺎﻳﺎﻘﺒﻟا ﺎﻨﻟﺎﻄﺑأ ﺩﺭﺎﻄﻳ ،ﺶﻫ ﻒﻟﺎﺤﺘﺑ ﺔﻳﻮﺳ ﻦﻴﻔﺗﺎﻜﺘﻣ"
description traditionalchinese "在薄弱的結盟關係之下，我們的英雄們一路追查935隊的碎裂殘骸，來到他們在奧地利阿爾卑斯山的山頂要塞…"
description simplifiedchinese "通过一个脆弱的盟约团结在一起，我们的英雄们追踪着935集团的残部，来到了奥地利阿尔卑斯山顶的森林中。"
unlockxp 0
dlcname dlc1
maxparty 4
maxlocalplayers 2
categories zm_castle
icon img_mapvote_zm_castle
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_castle,zclassic,1

playlist 153
name english "Zetsubou no Shima"
name englisharabic "Zetsubou no Shima"
name french "Zetsubou no Shima"
name italian "Zetsubou No Shima"
name german "Zetsubou no Shima"
name spanish "Zetsubou no Shima"
name polish "Zetsubou no Shima"
name russian "Zetsubou no Shima"
name japanese "Zetsubou no Shima"
name mexicanspanish "Zetsubou no Shima"
name portuguese "Zetsubou no Shima"
name arabic "Zetsubou no Shima"
name traditionalchinese "Zetsubou no Shima"
name simplifiedchinese "Zetsubou no Shima"
description english "On a remote Island in the Pacific, a mysterious facility hides the secrets behind Division 9’s sinister experiments…"
description englisharabic "On a remote Island in the Pacific, a mysterious facility hides the secrets behind Division 9’s sinister experiments…"
description french "Sur une île lointaine du Pacifique, un mystérieux site abrite les secrets qui se cachent derrière les sinistres expérimentations de la Division 9..."
description italian "Su una remota isola del pacifico, una misteriosa struttura nasconde i segreti dei terribili esperimenti della divisione 9..."
description german "Auf einer abgelegenen Pazifikinsel sind in einer mysteriösen Einrichtung die Geheimnisse der finsteren Experimente von Abteilung 9 versteckt ..."
description spanish "En una remota isla del pacífico, una misteriosa instalación oculta los secretos de los siniestros experimentos de la división 9..."
description polish "Na odległej wyspie na Oceanie Spokojnym, tajemniczy obiekt skrywa sekrety przerażających eksperymentów Oddziału 9..."
description russian "Секретный объект на далеком тихоокеанском острове, где хранятся тайны зловещих экспериментов Отдела 9..."
description japanese "太平洋に浮かぶ孤島の謎めいた施設に、第九師団の恐ろしい実験にまつわる秘密が隠されている..."
description mexicanspanish "En una remota isla del Pacífico, una misteriosa instalación oculta los secretos de los siniestros experimentos de la división 9..."
description portuguese "Em uma ilha remota no Pacífico, um complexo misterioso oculta os segredos das experiências sinistras da Divisão 9..."
description arabic "...ﻪﻠﺧﺍﺪﺑ 9 ﺔﺒﻴﺘﻜﻟا ﺎﻬﺗﺮﺟأ ﻲﺘﻟا ﺔﻣﻭﺆﺸﻤﻟا ﺕﺍﺭﺎﺒﺘﺧﻻا ﺭﺍﺮﺳأ ﺾﻣﺎﻏ ﻰﻨﺒﻣ ﺊﺒﺨﻳ ،ﺉﺩﺎﻬﻟا ﻂﻴﺤﻤﻟا ﻲﻓ ﺔﻴﺋﺎﻧ ﺓﺮﻳﺰﺟ ﻰﻠﻋ"
description traditionalchinese "在太平洋一座偏遠島嶼上，一座神秘設施隱藏著第九師團邪惡實驗背後的秘密…"
description simplifiedchinese "太平洋中一个荒远的小岛上，一个神秘设施里，暗藏着第九师团罪恶实验背后的秘密……"
unlockxp 0
dlcname dlc2
maxparty 4
maxlocalplayers 2
categories zm_island
icon img_t7_menu_zm_preview_island
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_island,zclassic,1

playlist 154
name english "Gorod Krovi"
name englisharabic "Gorod Krovi"
name french "Gorod Krovi"
name italian "Gorod Krovi"
name german "Gorod Krovi"
name spanish "Gorod Krovi"
name polish "Gorod Krovi"
name russian "Gorod Krovi"
name japanese "Gorod Krovi"
name mexicanspanish "Gorod Krovi"
name portuguese "Gorod Krovi"
name arabic "Gorod Krovi"
name traditionalchinese "Gorod Krovi"
name simplifiedchinese "Gorod Krovi"
description english "As their journey nears its end, our heroes must battle ancient beasts in the war torn ruins of Stalingrad..."
description englisharabic "As their journey nears its end, our heroes must battle ancient beasts in the war torn ruins of Stalingrad..."
description french "Alors que leur périple touche à sa fin, nos héros doivent affronter des bêtes ancestrales dans les ruines dévastées de Stalingrad..."
description italian "Ormai prossimi alla fine del loro viaggio, i nostri eroi devono affrontare antichi mostri in una Stalingrado martoriata dalla guerra..."
description german "Kurz vor Ende ihrer Reise müssen sich unsere Helden antiken Untieren in den vom Krieg gezeichneten Ruinen Stalingrads stellen."
description spanish "A punto de concluir su viaje, nuestros héroes deberán enfrentarse a bestias ancestrales en las ruinas asoladas por la guerra de Stalingrado..."
description polish "Ich podróż dobiega końca. W ruinach zniszczonego wojną Stalingradu, nasi bohaterowie walczyć będą z antyczną bestią..."
description russian "Путешествие наших героев приближается к концу. Теперь им предстоит дать бой древним чудовищам среди руин опустошенного войной Сталинграда…"
description japanese "旅の終わりが近づく中、あの男たちが戦争で廃墟と化したスターリングラードで古代のビーストに立ち向かう…"
description mexicanspanish "A punto de concluir su viaje, nuestros héroes deberán enfrentarse a bestias ancestrales en las ruinas asoladas por la guerra de Stalingrado..."
description portuguese "Com sua jornada chegando ao fim, nossos heróis devem enfrentar feras ancestrais nas ruínas destruídas de Stalingrado..."
description arabic "...ﺏﺮﺤﻟا ﺎﻬﺘﻗﺰﻣ ﻲﺘﻟا ﺩﺍﺮﻐﻨﻴﻟﺎﺘﺳ ﺽﺎﻘﻧأ ﻦﻴﺑ ﺔﻤﻳﺪﻗ ﺵﻮﺣو ﺔﻠﺗﺎﻘﻣ ﺎﻨﻟﺎﻄﺑأ ﻰﻠﻋ ﺐﺟﻮﺘﻳ ،ﺎﻬﺘﻳﺎﻬﻧ ﻦﻣ ﻢﻬﺘﻠﺣر ﺏﺍﺮﺘﻗا ﻊﻣ"
description traditionalchinese "在旅途即將抵達終點時，我們的英雄們得在史達林格勒飽受戰亂摧殘的廢墟中迎戰上古野獸…"
description simplifiedchinese "他们的旅程即将结束，在饱受战火摧残的斯大林格勒的废墟中，我们的英雄们将与远古巨兽殊死一战......"
unlockxp 0
dlcname dlc3
maxparty 4
maxlocalplayers 2
categories zm_stalingrad
icon img_t7_menu_zm_preview_dlc3
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_stalingrad,zclassic,1

playlist 155
name english "Revelations"
name englisharabic "Revelations"
name french "Revelations"
name italian "Revelations"
name german "Revelations"
name spanish "Revelations"
name polish "Revelations"
name russian "Revelations"
name japanese "Revelations"
name mexicanspanish "Revelations"
name portuguese "Revelations"
name arabic "Revelations"
name traditionalchinese "Revelations"
name simplifiedchinese "Revelations"
description english "The time has come to join Doctor Monty in The House, where an ancient evil threatens the survival of our heroes' immortal souls..."
description englisharabic "The time has come to join Doctor Monty in The House, where an ancient evil threatens the survival of our heroes' immortal souls..."
description french "L'heure est venue de rejoindre le Docteur Monty dans la Maison, où un mal ancestral met en péril la survie des âmes immortelles de nos héros..."
description italian "È il momento di raggiungere il dottor Monty nella Casa, dove un'antica entità malvagia minaccia la sopravvivenza delle anime immortali dei nostri eroi..."
description german "Die Zeit ist gekommen, Doktor Monty im Haus zu besuchen, wo ein alter Feind die unsterblichen Seelen unserer Helden bedroht ..."
description spanish "Ha llegado la hora de unirse al doctor Monty en La casa, donde un antiguo mal amenaza la supervivencia de las almas inmortales de nuestros héroes..."
description polish "Nadszedł czas, by dołączyć do doktora Montiego w Domu, gdzie starożytne zło zagraża nieśmiertelnym duszom naszych bohaterów... "
description russian "Пришла пора присоединиться к доктору Монти в Доме и сразиться с древним злом, чтобы спасти бессмертные души наших героев."
description japanese "ついにドクター・モンティと対峙するときがやってきた。かの家で、古代の邪悪な存在があの男たちの不死の魂を脅かす..."
description mexicanspanish "Es hora de unirse al doctor Monty en La casa, donde un antiguo mal amenaza la supervivencia de las almas inmortales de nuestros héroes..."
description portuguese "Chegou a hora de se juntar ao Doutor Monty na Casa, onde um mal antigo ameaça a sobrevivência das almas imortais dos nossos heróis..."
description arabic "...ﺔﻴﻧﺎﻔﻟا ﺎﻨﻟﺎﻄﺑأ ﺡﺍﻭﺭأ ﺩﺪﻬﻳ ﻢﻳﺪﻗ ﺮﺷ ﻊﺒﻘﻳ ﺚﻴﺣ ،The House ﻲﻓ ﻲﺘﻧﻮﻣ ﺭﻮﺘﻛﺪﻟ ﻡﺎﻤﻀﻧﻼﻟ ﺖﻗﻮﻟا ﻥﺎﺣ"
description traditionalchinese "終於來到「屋子」會合蒙提博士這個重要時刻，古老惡靈在內蠢蠢欲動，威脅我們英雄的不朽靈魂…"
description simplifiedchinese "终于到时候与蒙蒂博士在“房子”里会合了。在这里，一个远古恶魔威胁着我们英雄们不朽灵魂的存亡……"
unlockxp 0
dlcname dlc4
maxparty 4
maxlocalplayers 2
categories zm_genesis
icon img_t7_menu_zm_preview_genesis
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_genesis,zclassic,1

playlist 156
name english "Nacht Der Untoten"
name englisharabic "Nacht Der Untoten"
name french "Nacht Der Untoten"
name italian "Nacht Der Untoten"
name german "Nacht der Untoten"
name spanish "Nacht Der Untoten"
name polish "Nacht Der Untoten"
name russian "Nacht Der Untoten"
name japanese "NACHT DER UNTOTEN"
name mexicanspanish "Nacht Der Untoten"
name portuguese "Nacht Der Untoten"
name arabic "Nacht Der Untoten"
name traditionalchinese "Nacht Der Untoten"
name simplifiedchinese "Nacht Der Untoten"
description english "You drove them deep into the heart of the Reich. You thought they were dead. You were wrong."
description englisharabic "You drove them deep into the heart of the Reich. You thought they were dead. You were wrong."
description french "Vous les aviez affrontés au coeur du Reich. Vous croyiez qu'ils étaient morts. Vous aviez tort."
description italian "Li hai respinti fino al cuore del Reich. Pensavi che fossero morti. Ti sbagliavi."
description german "Das Grauen des Krieges ist noch nicht vorbei. Die besiegten Gegner sind nicht wirklich tot!"
description spanish "Los condujiste hasta el corazón del Reich. Creías que estaban muertos. Te equivocabas."
description polish "Zapędziłeś ich daleko w głąb Rzeszy. Myślałeś, że zginęli. Myliłeś się."
description russian "Вы проникли в самое сердце Рейха. Вы считали их мертвыми. Вы ошибались."
description japanese "帝国の軍勢をついにその中枢にまで追い詰めたとき、死んだはずの敵兵士がうごめき出した"
description mexicanspanish "Los condujiste hasta el corazón del Reich. Creías que estaban muertos. Te equivocabas."
description portuguese "Você os guiou exatamente para o coração do Reich. Você achou que eles estavam mortos. Foi um erro."
description arabic ".ًﺎﺌﻄﺨﻣ ﺖﻨﻛ ﻚﻨﻜﻟ .ﻰﺗﻮﻣ ﻢﻬﻨﻈﺗ ﺖﻨﻛ .ﺦﻳﺍﺮﻟا ﻕﺎﻤﻋأ ﻰﻟإ ﻢﻬﺘﻌﻓد ﺪﻘﻟ"
description traditionalchinese "你將他們驅逐至第三帝國的核心。你以為他們已經安息，你錯了。"
description simplifiedchinese "你追击敌人进入了帝国的深处。你以为它们已经死了……你错了。"
unlockxp 0
dlcname dlc5
maxparty 4
maxlocalplayers 2
categories zm_prototype
icon img_t7_menu_zm_preview_prototype
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_prototype,zclassic,1

playlist 157
name english "Verrückt"
name englisharabic "Verrückt"
name french "Verrückt"
name italian "Verrückt"
name german "Verrückt"
name spanish "Verrückt"
name polish "Verrückt"
name russian "Verrückt"
name japanese "VERRÜCKT"
name mexicanspanish "Verrückt"
name portuguese "Verrückt"
name arabic "Verrückt"
name traditionalchinese "Verrückt"
name simplifiedchinese "Verrückt"
description english "Electroshock therapy. Chemically engineered beverages. Hordes of undead Nazis. Find the power to unite and send them back to their graves!"
description englisharabic "Electroshock therapy. Chemically engineered beverages. Hordes of undead Nazis. Find the power to unite and send them back to their graves!"
description french "Thérapie à base d'électrochocs. Boissons créées chimiquement. Des hordes de zombies nazis. Réussissez à unir vos forces pour les renvoyer dans leurs tombes !"
description italian "Elettroshock terapeutico, bevande chimicamente alterate, orde di nazisti non-morti... Trova la forza di fare squadra e rispediscili nelle loro tombe!"
description german "Elektroschock-Therapie. Chemisch hergestellte Getränke. Jede Menge Untote. Schicken Sie sie zurück in ihre Gräber!"
description spanish "Terapia de choque. Pociones diseñadas en laboratorio. Hordas de nazis no muertos. ¡Encuentra el poder para reunirlos y enviarlos a todos de vuelta a sus tumbas!"
description polish "Terapia szokowa. Chemicznie wzmocnione napoje. Setki nieumarłych nazistów. Połączcie swoje siły i odeślijcie ich do grobu!"
description russian "Электрошоковая терапия. Химические препараты. Орды нацистских зомби. Найдите способ объединить все это и отправьте мертвецов обратно в могилы!"
description japanese "電気ショック療法、化学的に作られた飲み物、そしてアンデッドナチスの大群。奴らをまとめて墓に送る力を探せ！"
description mexicanspanish "Terapia de choque. Pociones diseñadas en laboratorio. Hordas de nazis no muertos. ¡Encuentra el poder para reunirlos y enviarlos a todos de vuelta a sus tumbas!"
description portuguese "Terapia de eletrochoque. Bebidas quimicamente modificadas. Hordas de mortos-vivos nazistas. Encontre o poder para unir e enviar todos de volta para seus túmulos!"
description arabic "!ﻢﻫﺭﻮﺒﻗ ﻰﻟإ ﻢﻫﻭﺪﻴﻋﺃو ﺍﻭﺪﺤﺗﺍو ﻢﻜﺗﻮﻗ ﺍﻮﻌﻤﺠﺘﺳا .ﻦﻴﻳﺯﺎﻨﻟا ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﻦﻣ ﻞﻓﺎﺤﺟ .ﺔﻴﺋﺎﻴﻤﻴﻜﻟا ﺔﺳﺪﻨﻬﻟﺎﺑ ﺔﺠﻟﺎﻌﻣ ﺕﺎﺒﻃﺮﻣ .ﺔﻴﺋﺎﺑﺮﻬﻜﻟا ﺕﺎﻣﺪﺼﻟﺎﺑ ﺝﻼﻋ"
description traditionalchinese "電擊療法。化工飲料。大群不死納粹。協力將他們送回墳墓吧！"
description simplifiedchinese "电击疗法、化工饮料、纳粹僵尸。众志成城，将恶魔送回坟墓！"
unlockxp 0
dlcname dlc5
maxparty 4
maxlocalplayers 2
categories zm_asylum
icon img_t7_menu_zm_preview_asylum
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_asylum,zclassic,1

playlist 158
name english "Ascension"
name englisharabic "Ascension"
name french "Ascension"
name italian "Ascension"
name german "Ascension"
name spanish "Ascension"
name polish "Ascension"
name russian "Ascension"
name japanese "ASCENSION"
name mexicanspanish "Ascension"
name portuguese "Ascension"
name arabic "Ascension"
name traditionalchinese "Ascension"
name simplifiedchinese "Ascension"
description english "The risen dead have overtaken a Soviet cosmodrome and all Hell has broken loose. The countdown to the zombie apocalypse has begun."
description englisharabic "The risen dead have overtaken a Soviet cosmodrome and all Hell has broken loose. The countdown to the zombie apocalypse has begun."
description french "Les morts-vivants ont semé la panique en prenant le contrôle d'un cosmodrome soviétique. Le compte à rebours de l'apocalypse zombie a commencé."
description italian "I morti viventi hanno occupato un cosmodromo sovietico, scatenando l'inferno. Il conto alla rovescia per l'apocalisse zombi è iniziato."
description german "Die Untoten haben einen sowjetischen Weltraumbahnhof übernommen und die Hölle ist ausgebrochen. Der Countdown bis zur Zombie-Apokalypse hat begonnen."
description spanish "Los muertos vivientes han invadido un cosmódromo soviético y se ha desatado un infierno. La cuenta atrás para el apocalipsis zombi ha comenzado."
description polish "Nieumarli opanowali rosyjski kosmodrom i robią tam piekło. Rozpoczęło się odliczanie do apokalipsy zombie."
description russian "Восставшие мертвецы устроили ад на советском космодроме. Отсчет до старта зомби-апокалипсиса пошел."
description japanese "ソビエトの宇宙基地が蘇ったゾンビたちに乗っ取られ、混乱が生じている。今ゾンビ戦争へのカウントダウンが始まった"
description mexicanspanish "Los muertos vivientes invadieron un cosmódromo soviético y se desató un infierno. La cuenta atrás para el apocalipsis zombi empezó."
description portuguese "Os mortos-vivos tomaram conta de um cosmódromo soviético e o caos está por toda parte. A contagem regressiva para o apocalipse zumbi começou."
description arabic ".ﻢﻟﺎﻌﻠﻟ ﻲﺒﻣﻭﺰﻟا ﺵﻮﺣو ﻭﺰﻐﻟ ﻲﻟﺯﺎﻨﺘﻟا ﺪﻌﻟا ﺃﺪﺑ ﺪﻘﻟ .ﺔﻣﺭﺎﻌﻟا ﻰﺿﻮﻔﻠﻟ ﻥﺎﻨﻌﻟا ﺍﻮﻘﻠﻃﺃو ﺔﻴﺘﻴﻴﻓﻮﺳ ﺔﻴﺋﺎﻀﻓ ﻕﻼﻃإ ﺔﻄﺤﻣ ﻰﻠﻋ ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﻰﻟﻮﺘﺳا"
description traditionalchinese "死而復生的殭屍佔據了蘇聯航天發射場，一發不可收拾。殭屍末日喪鐘的倒數已經開始。"
description simplifiedchinese "复活的死尸已经占据苏联卫星发射基地，尸相环生。僵尸灭世的倒计时已经开始。"
unlockxp 0
dlcname dlc5
maxparty 4
maxlocalplayers 2
categories zm_cosmodrome
icon img_t7_menu_zm_preview_cosmodrome
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_cosmodrome,zclassic,1

playlist 159
name english "Moon"
name englisharabic "Moon"
name french "Moon"
name italian "Moon"
name german "Moon"
name spanish "Moon"
name polish "Moon"
name russian "Moon"
name japanese "MOON"
name mexicanspanish "Moon"
name portuguese "Moon"
name arabic "Moon"
name traditionalchinese "Moon"
name simplifiedchinese "Moon"
description english "I believe that this nation should commit itself to achieving the goal, before this decade is out, of landing a man on the moon and returning him safely to the Earth. (JFK, 1961)"
description englisharabic "I believe that this nation should commit itself to achieving the goal, before this decade is out, of landing a man on the moon and returning him safely to the Earth. (JFK, 1961)"
description french "Je pense que notre nation doit s'engager à atteindre l'objectif, avant la fin de cette décennie, d'envoyer un homme sur la Lune et le ramener sur Terre sain et sauf. (JFK, 1961)"
description italian "Credo che il paese debba impegnarsi per raggiungere l'obiettivo, prima della fine di questo decennio, di far scendere un uomo sulla Luna e di riportarlo a Terra sano e salvo. (JFK, 1961)"
description german "Ich glaube, dass diese Nation das Ziel haben sollte, noch vor Ende dieses Jahrzehnts einen Menschen auf den Mond zu schicken und ihn wieder sicher zur Erde zurückzubringen. (JFK, 1961)"
description spanish "Creo que esta nación debería comprometerse a alcanzar la meta de llevar un hombre a la Luna y traerlo de vuelta a salvo a la Tierra antes de que termine esta década. (JFK, 1961)"
description polish "Wierzę, że nasz naród powinien skupić się na celu, którym jest lądowanie człowieka na Księżycu i jego bezpieczny powrót na Ziemię jeszcze przed końcem tej dekady. (JFK, 1961)"
description russian "Я полагаю, что наша страна должна принять на себя обязательство в достижении следующей цели - до конца этого десятилетия доставить человека на Луну и безопасно вернуть его на Землю. (Дж. Ф. Кеннеди, 1961)"
description japanese "我が国は、人を月面に着陸させ、無事に帰還させるという目標を、今後10年以内に達成することを約束すべきであると、私は信じています(ジョン・F・ケネディ - 1961)"
description mexicanspanish "Creo que esta nación debería comprometerse a alcanzar la meta de llevar un hombre a la Luna y traerlo de vuelta a salvo a la Tierra antes de que termine esta década. (JFK, 1961)"
description portuguese "Creio que essa nação deveria se comprometer a alcançar a meta, antes que termine esta década, de aterrissar o homem na lua e trazê-lo de volta à Terra sem perigo. (JFK, 1961)"
description arabic "(1961 ،ﻱﺪﻴﻨﻴﻛ ﻥﻮﺟ) .ﺽﺭﻷا ﻰﻟإ ًﺎﻤﻟﺎﺳ ﻪﺗﺩﺎﻋﺇو ﺮﻤﻘﻟا ﻰﻠﻋ ﻞﺟر ﻝﺍﺰﻧﺈﺑ ﺪﻘﻌﻟا ﺍﺬﻫ ﺔﻳﺎﻬﻧ ﻞﺒﻗ ﻑﺪﻫ ﻖﻴﻘﺤﺘﺑ ﺎﻬﺴﻔﻧ ﻡﺰﻠﺗ ﻥأ ﺐﺠﻳ ﺔﻣﻷا هﺬﻫ ﻥأ ﺪﻘﺘﻋا ﻲﻨﻧإ"
description traditionalchinese "我相信這個國家應該致力達成目標，在本世紀末前將人類登陸月球並安全送返地球。（甘迺迪，1961年）"
description simplifiedchinese "我坚信这个国家应该集中力量实现这个目标，即在1970年以前，人类将乘坐宇宙飞船登陆月球并且安全返回地球。（肯尼迪，1961年）"
unlockxp 0
dlcname dlc5
maxparty 4
maxlocalplayers 2
categories zm_moon
icon img_t7_menu_zm_preview_moon
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_moon,zclassic,1

playlist 160
name english "Shi No Numa"
name englisharabic "Shi No Numa"
name french "Shi No Numa"
name italian "Shi No Numa"
name german "Shi No Numa"
name spanish "Shi No Numa"
name polish "Shi No Numa"
name russian "Shi No Numa"
name japanese "SHI NO NUMA"
name mexicanspanish "Shi No Numa"
name portuguese "Shi No Numa"
name arabic "Shi No Numa"
name traditionalchinese "Shi No Numa"
name simplifiedchinese "Shi No Numa"
description english "Maggot ridden corpses. Bug infested swamp. Hundreds of undead Imperial Army. Choose your tactic and defend for your lives!"
description englisharabic "Maggot ridden corpses. Bug infested swamp. Hundreds of undead Imperial Army. Choose your tactic and defend for your lives!"
description french "Des cadavres grouillants. Des marais infestés de bestioles. Des milliers de morts-vivants de l'armée impériale. Choisissez une tactique et sauvez votre peau !"
description italian "Cadaveri infestati dai vermi, paludi piene di insetti, centinaia di soldati dell'Esercito imperiale morti... Scegli una tattica e lotta per le tua vita!"
description german "Von Maden zerfressene Leichen. Ein mit Insekten verseuchter Sumpf. Jede Menge untoter Zombies. Wählen Sie Ihre Strategie und retten Sie Ihr Leben!"
description spanish "Cuerpos atestados de gusanos. Un pantano infestado de insectos. Centenares de no muertos del Ejército Imperial. ¡Elige tu táctica y defiende tu vida!"
description polish "Zwłoki pożerane przez robaki. Bagno pełne owadów. Setki nieumarłych z armii imperialnej. Wybierz taktykę i walcz o swe życie!"
description russian "Полуразложившиеся трупы. Болото, кишащее насекомыми. Сотни мертвых солдат Империи. Выбирайте тактику и защищайтесь!"
description japanese "広大な沼地の中の野戦拠点が帝国陸軍のゾンビに囲まれた。あらゆる仕掛けを駆使して生き残れ！"
description mexicanspanish "Cuerpos atestados de gusanos. Un pantano infestado de insectos. Centenares de no muertos del Ejército Imperial. ¡Elige tu táctica y defiende tu vida!"
description portuguese "Cadáveres cheios de vermes. Pântano infestado de insetos. Centenas de mortos-vivos do Exército Imperial. Escolham sua tática e defendam suas vidas!"
description arabic "!ﻢﻜﺗﺎﻴﺣ ﻦﻋ ﺍﻮﻌﻓﺍﺩو ﻢﻜﻴﺘﻜﺗ ﺍﻭﺭﺎﺘﺧا .ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﺕﺎﺌﻣ ﻦﻣ ﻥﻮﻜﻣ ﻱﺭﻮﻃﺍﺮﺒﻣإ ﺶﻴﺟ .ﺕﺍﺮﺸﺤﻟﺎﺑ ﺙﻮﻠﻣ ﻊﻘﻨﺘﺴﻣ .ﻥﺍﺪﻳﺪﻟﺎﺑ ﺔﺌﻠﺘﻤﻣ ﺚﺜﺟ"
description traditionalchinese "滿佈蛆蟲的屍體。害蟲橫生的沼澤。數以百計的不死帝國軍。制訂戰術，為保全生命而戰！"
description simplifiedchinese "腐烂的尸体、恶臭的沼泽、成群的帝国陆军僵尸。使用战术，为了保住性命而战！"
unlockxp 0
dlcname dlc5
maxparty 4
maxlocalplayers 2
categories zm_sumpf
icon img_t7_menu_zm_preview_sumpf
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_sumpf,zclassic,1

playlist 161
name english "Shangri-La"
name englisharabic "Shangri-La"
name french "Shangri-La"
name italian "Shangri-La"
name german "Shangri-La"
name spanish "Shangri-La"
name polish "Shangri-La"
name russian "Shangri-La"
name japanese "SHANGRI-LA"
name mexicanspanish "Shangri-La"
name portuguese "Shangri-La"
name arabic "Shangri-La"
name traditionalchinese "Shangri-La"
name simplifiedchinese "Shangri-La"
description english "A legendary shrine lost in an exotic jungle, where the undead lurk within a treacherous labyrinth of underground caverns, deadly traps and dark secrets."
description englisharabic "A legendary shrine lost in an exotic jungle, where the undead lurk within a treacherous labyrinth of underground caverns, deadly traps and dark secrets."
description french "Un temple légendaire perdu dans une jungle exotique. Aventurez-vous dans un labyrinthe de cavernes pleines de morts-vivants, de pièges mortels et de sombres secrets."
description italian "Un tempio leggendario perso nella giungla, dove i non morti si nascondono all'interno di un insidioso labirinto fatto di caverne sotterranee, trappole mortali e oscuri segreti."
description german "Ein legendärer Schrein, tief in einem exotischen Dschungel verborgen, wo die Untoten in einem tödlichen Labyrinth unterirdischer Höhlen lauern, voller gefährlicher Fallen und düsterer Geheimnisse."
description spanish "Un santuario legendario perdido en una selva exótica. Los no muertos acechan en el interior de un traicionero laberinto conformado por cavernas subterráneas, trampas mortales y oscuros secretos."
description polish "Legendarna świątynia zagubiona w egzotycznej dżungli, pełnej nieumarłych, zagmatwanych jaskiń, niebezpiecznych pułapek i mrocznych sekretów."
description russian "Легендарное святилище в джунглях, подземные лабиринты которого скрывают мрачные тайны, смертоносные ловушки и бесчисленных живых мертвецов. "
description japanese "異国のジャングルのなかにある、失われた伝説の社。そこはアンデッドが彷徨う入り組んだ洞窟の危険な迷宮となっており、 死のワナや秘密が隠されている"
description mexicanspanish "Un santuario legendario perdido en una selva exótica. Los no muertos acechan en el interior de un traicionero laberinto conformado por cavernas subterráneas, trampas mortales y oscuros secretos."
description portuguese "Um santuário lendário perdido em uma selva exótica onde os mortos-vivos espreitam no labirinto traiçoeiro de cavernas subterrâneas, armadilhas mortais e segredos sombrios."
description arabic ".ﺔﻤﻠﻈﻣ ﺭﺍﺮﺳﺃو ﺔﻠﺗﺎﻗ ﺥﺎﺨﻓأ ﺎﻬﻨﻜﺴﺗ ﻲﺘﻟﺍو ،ﺽﺭﻷا ﺖﺤﺗ ﻑﻮﻬﻜﻟا ﻦﻣ ﺓﺭﺍﺪﻏ ﺔﻫﺎﺘﻣ ﻞﺧﺍد ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﺺﺑﺮﺘﻳ ﺚﻴﺣ ،ﺔﺒﻳﺮﻏ ﺔﺑﺎﻏ ﻲﻓ ﺄﺒﺨﻣ ﻱﺭﻮﻄﺳأ ﺢﻳﺮﺿ"
description traditionalchinese "隱藏在奇異叢林的傳奇神殿，而不死殭屍在這個遍佈地下洞穴、死亡陷阱和暗黑秘密的凶險迷宮裡蠢蠢欲動。"
description simplifiedchinese "坐落于异国丛林中的遗失的神殿。僵尸暗藏在由地下洞穴、致命陷阱和黑暗秘密组成的迷宫之中。"
unlockxp 0
dlcname dlc5
maxparty 4
maxlocalplayers 2
categories zm_temple
icon img_t7_menu_zm_preview_temple
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_temple,zclassic,1

playlist 162
name english "Kino Der Toten"
name englisharabic "Kino Der Toten"
name french "Kino Der Toten"
name italian "Kino Der Toten"
name german "Kino der Toten"
name spanish "Kino Der Toten"
name polish "Kino Der Toten"
name russian "Kino Der Toten"
name japanese "KINO DER TOTEN"
name mexicanspanish "Kino Der Toten"
name portuguese "Kino Der Toten"
name arabic "Kino Der Toten"
name traditionalchinese "Kino Der Toten"
name simplifiedchinese "Kino Der Toten"
description english "Battle the undead in this theatrical installment of \"Zombies\". New twists and clues could uncover the final plan. It's show time!"
description englisharabic "Battle the undead in this theatrical installment of \"Zombies\". New twists and clues could uncover the final plan. It's show time!"
description french "Venez à bout de hordes de morts-vivants dans cette nouvelle aventure Zombies. Cherchez des indices, dénouez l'intrigue, et que le spectacle commence !"
description italian "Combatti i non morti in questa incredibile modalità Zombi. Nuovi indizi e sviluppi imprevisti potrebbero rivelare il piano finale. Si va in scena!"
description german "Kämpfen Sie gegen die Untoten in dieser kinoreifen Folge von \"Zombies\". Neue Wendungen und Hinweise könnten den finalen Plan offenbaren. Es ist Showtime!"
description spanish "Combate a los no muertos en esta entrega dramática de \"Zombis\". Nuevas pistas y enredos podrían desvelar el plan definitivo. ¡Es la hora del espectáculo!"
description polish "Walcz z nieumarłymi wśród teatralnej scenografii w nowej odsłonie \"Zombie\". Nowe zagrania i wskazówki mogą ujawnić ich plan. Kurtyna w górę!"
description russian "Бой с нежитью в декорациях театра зомби. Неожиданные повороты сюжета содержат намеки на финальный план. Шоу начинается!"
description japanese "謎めいた劇場を舞台にゾンビと対決。帝国の最終計画に君はどこまで迫れるか？"
description mexicanspanish "Combate a los no muertos en esta entrega dramática de \"Zombis\". Nuevas pistas y enredos podrían revelar el plan definitivo. ¡Es la hora del espectáculo!"
description portuguese "Lute contra mortos-vivos nesse episódio cinematográfico de \"Zumbis\". Novas reviravoltas e pistas podem revelar o plano final. É hora do show!"
description arabic "!ﺽﺮﻌﻟا ﺖﻗو ﻥﺎﺣ .ﺓﺮﻴﺧﻷا ﺔﻄﺨﻟا ﺕﺎﺌﺟﺎﻔﻤﻟﺍو ﺔﻟﺩﻷا ﻒﺸﻜﺗ ﺪﻗ ."\ﻲﺒﻣﻭﺰﻟا"\  ﻢﻠﻴﻔﻟ ﻲﺣﺮﺴﻤﻟا ﺽﺮﻌﻟا ﺍﺬﻫ ﻲﻓ ءﺎﻴﺣﻷا ﻰﺗﻮﻤﻟا ﻞﺗﺎﻗ"
description traditionalchinese "在這部《殭屍》劇場中大戰不死軍團。新線索和變化會逐漸揭露最終計劃。好戲開場了！"
description simplifiedchinese "在这部僵尸大片中迎战僵尸。新的转折和线索将会揭示最终的计划。好戏开场了！"
unlockxp 0
dlcname dlc5
maxparty 4
maxlocalplayers 2
categories zm_theater
icon img_t7_menu_zm_preview_theater
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_theater,zclassic,1

playlist 163
name english "Origins"
name englisharabic "Origins"
name french "Origins"
name italian "Origins"
name german "Origins"
name spanish "Origins"
name polish "Origins"
name russian "Origins"
name japanese "ORIGINS"
name mexicanspanish "Origins"
name portuguese "Origins"
name arabic "Origins"
name traditionalchinese "Origins"
name simplifiedchinese "Origins"
description english "Witness the origins of Group 935, as an ancient evil is unleashed upon the battlefields of World War I."
description englisharabic "Witness the origins of Group 935, as an ancient evil is unleashed upon the battlefields of World War I."
description french "Assistez à la formation du groupe 935, tandis qu'un être maléfique ancien fait des ravages sur les champs de bataille de la Première Guerre mondiale."
description italian "Scopri le origini del gruppo 935 mentre un'antica entità malvagia si abbatte sui campi di battaglia della Prima Guerra Mondiale."
description german "Erleben Sie die Anfänge der Gruppe 935, während eine uralte böse Macht auf die Schlachtfelder des ersten Weltkrieges losgelassen wird."
description spanish "Presencia los orígenes del Grupo 935 mientras un mal ancestral se desata sobre los campos de batalla de la Primera Guerra Mundial."
description polish "Zobacz jak powstała grupa 935, po pojawieniu się starożytnego zła na polach bitew I wojny światowej."
description russian "Узнайте про Группу 935 и древнее зло, выпущенное на поля сражений Первой мировой войны."
description japanese "935部隊の起源を目撃せよ。第一次世界大戦の戦場に悪が解き放たれる"
description mexicanspanish "Presencia los orígenes del Grupo 935 mientras un mal ancestral se desata sobre los campos de batalla de la Primera Guerra Mundial."
description portuguese "Testemunhe as origens do grupo 935 quando um mal antigo é lançado nos campos de batalha de Primeira Guerra Mundial."
description arabic ".ﻰﻟﻭﻷا ﺔﻴﻤﻟﺎﻌﻟا ﺏﺮﺤﻟا ﻝﺎﺘﻗ ﺕﺎﺣﺎﺳ ﻰﻠﻋ ﻢﻳﺪﻗ ﺮﺷ ﺮﻋﺬﻟا ﺮﺸﻨﻳ ﺎﻤﻨﻴﺑ ،935 ﺔﻋﻮﻤﺠﻤﻟا ﻝﻮﺻأ ﻰﻠﻋ ﻑّﺮﻌﺗ"
description traditionalchinese "在遠古邪靈於一戰戰場上肆虐的同時見證935小組的崛起。"
description simplifiedchinese "对抗肆虐于一战战场的远古恶魔，见证935部队的开端。"
unlockxp 0
dlcname dlc5
maxparty 4
maxlocalplayers 2
categories zm_tomb
icon img_t7_menu_zm_preview_tomb
rule party_minplayers 2
rule party_maxplayers 4
rule party_matchedplayercount 0
rule lobby_readyUpPercentRequired 0.7
zm_tomb,zclassic,1

///////////////////////////////////////////////////////////////////////////
//    CAMPAIGN PLAYLISTS (Playlist # 200 - 250)
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
//    CAMPAIGN PUBLIC PLAYLISTS (Playlist # 200-219)
///////////////////////////////////////////////////////////////////////////

playlist 200
name english "cp_mi_eth_prologue" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_eth_prologue"
name french "cp_mi_eth_prologue"
name italian "cp_mi_eth_prologue"
name german "cp_mi_eth_prologue"
name spanish "cp_mi_eth_prologue"
name polish "cp_mi_eth_prologue"
name russian "cp_mi_eth_prologue"
name japanese "cp_mi_eth_prologue"
name mexicanspanish "cp_mi_eth_prologue"
name portuguese "cp_mi_eth_prologue"
name arabic "cp_mi_eth_prologue"
name traditionalchinese "cp_mi_eth_prologue"
name simplifiedchinese "cp_mi_eth_prologue"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_eth_prologue,cp_coop,2

playlist 201
name english "cp_mi_zurich_newworld" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_zurich_newworld"
name french "cp_mi_zurich_newworld"
name italian "cp_mi_zurich_newworld"
name german "cp_mi_zurich_newworld"
name spanish "cp_mi_zurich_newworld"
name polish "cp_mi_zurich_newworld"
name russian "cp_mi_zurich_newworld"
name japanese "cp_mi_zurich_newworld"
name mexicanspanish "cp_mi_zurich_newworld"
name portuguese "cp_mi_zurich_newworld"
name arabic "cp_mi_zurich_newworld"
name traditionalchinese "cp_mi_zurich_newworld"
name simplifiedchinese "cp_mi_zurich_newworld"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
description italian "BIOCUPOLE 2+ giocatori"
description russian "БИОКУПОЛА 2+ игрока"
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_zurich_newworld,cp_coop,2

playlist 202
name english "cp_mi_sing_blackstation" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_sing_blackstation"
name french "cp_mi_sing_blackstation"
name italian "cp_mi_sing_blackstation"
name german "cp_mi_sing_blackstation"
name spanish "cp_mi_sing_blackstation"
name polish "cp_mi_sing_blackstation"
name russian "cp_mi_sing_blackstation"
name japanese "cp_mi_sing_blackstation"
name mexicanspanish "cp_mi_sing_blackstation"
name portuguese "cp_mi_sing_blackstation"
name arabic "cp_mi_sing_blackstation"
name traditionalchinese "cp_mi_sing_blackstation"
name simplifiedchinese "cp_mi_sing_blackstation"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
description italian "INFEZIONE 2+ giocatori"
description spanish "INFECCIÓN 2+ jugadores"
description russian "ЗАРАЖЕНИЕ 2+ игрока"
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_sing_blackstation,cp_coop,2

playlist 203
name english "cp_mi_sing_biodomes" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_sing_biodomes"
name french "cp_mi_sing_biodomes"
name italian "cp_mi_sing_biodomes"
name german "cp_mi_sing_biodomes"
name spanish "cp_mi_sing_biodomes"
name polish "cp_mi_sing_biodomes"
name russian "cp_mi_sing_biodomes"
name japanese "cp_mi_sing_biodomes"
name mexicanspanish "cp_mi_sing_biodomes"
name portuguese "cp_mi_sing_biodomes"
name arabic "cp_mi_sing_biodomes"
name traditionalchinese "cp_mi_sing_biodomes"
name simplifiedchinese "cp_mi_sing_biodomes"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_sing_biodomes,cp_coop,2

playlist 204
name english "cp_mi_sing_sgen" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_sing_sgen"
name french "cp_mi_sing_sgen"
name italian "cp_mi_sing_sgen"
name german "cp_mi_sing_sgen"
name spanish "cp_mi_sing_sgen"
name polish "cp_mi_sing_sgen"
name russian "cp_mi_sing_sgen"
name japanese "cp_mi_sing_sgen"
name mexicanspanish "cp_mi_sing_sgen"
name portuguese "cp_mi_sing_sgen"
name arabic "cp_mi_sing_sgen"
name traditionalchinese "cp_mi_sing_sgen"
name simplifiedchinese "cp_mi_sing_sgen"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_sing_sgen,cp_coop,2

playlist 205
name english "cp_mi_sing_vengeance" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_sing_vengeance"
name french "cp_mi_sing_vengeance"
name italian "cp_mi_sing_vengeance"
name german "cp_mi_sing_vengeance"
name spanish "cp_mi_sing_vengeance"
name polish "cp_mi_sing_vengeance"
name russian "cp_mi_sing_vengeance"
name japanese "cp_mi_sing_vengeance"
name mexicanspanish "cp_mi_sing_vengeance"
name portuguese "cp_mi_sing_vengeance"
name arabic "cp_mi_sing_vengeance"
name traditionalchinese "cp_mi_sing_vengeance"
name simplifiedchinese "cp_mi_sing_vengeance"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_sing_vengeance,cp_coop,2

playlist 206
name english "cp_mi_cairo_ramses" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_cairo_ramses"
name french "cp_mi_cairo_ramses"
name italian "cp_mi_cairo_ramses"
name german "cp_mi_cairo_ramses"
name spanish "cp_mi_cairo_ramses"
name polish "cp_mi_cairo_ramses"
name russian "cp_mi_cairo_ramses"
name japanese "cp_mi_cairo_ramses"
name mexicanspanish "cp_mi_cairo_ramses"
name portuguese "cp_mi_cairo_ramses"
name arabic "cp_mi_cairo_ramses"
name traditionalchinese "cp_mi_cairo_ramses"
name simplifiedchinese "cp_mi_cairo_ramses"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_cairo_ramses,cp_coop,2

playlist 207
name english "cp_mi_cairo_infection" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_cairo_infection"
name french "cp_mi_cairo_infection"
name italian "cp_mi_cairo_infection"
name german "cp_mi_cairo_infection"
name spanish "cp_mi_cairo_infection"
name polish "cp_mi_cairo_infection"
name russian "cp_mi_cairo_infection"
name japanese "cp_mi_cairo_infection"
name mexicanspanish "cp_mi_cairo_infection"
name portuguese "cp_mi_cairo_infection"
name arabic "cp_mi_cairo_infection"
name traditionalchinese "cp_mi_cairo_infection"
name simplifiedchinese "cp_mi_cairo_infection"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_cairo_infection,cp_coop,2

playlist 208
name english "cp_mi_cairo_aquifer" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_cairo_aquifer"
name french "cp_mi_cairo_aquifer"
name italian "cp_mi_cairo_aquifer"
name german "cp_mi_cairo_aquifer"
name spanish "cp_mi_cairo_aquifer"
name polish "cp_mi_cairo_aquifer"
name russian "cp_mi_cairo_aquifer"
name japanese "cp_mi_cairo_aquifer"
name mexicanspanish "cp_mi_cairo_aquifer"
name portuguese "cp_mi_cairo_aquifer"
name arabic "cp_mi_cairo_aquifer"
name traditionalchinese "cp_mi_cairo_aquifer"
name simplifiedchinese "cp_mi_cairo_aquifer"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_cairo_aquifer,cp_coop,2

playlist 209
name english "cp_mi_cairo_lotus" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_cairo_lotus"
name french "cp_mi_cairo_lotus"
name italian "cp_mi_cairo_lotus"
name german "cp_mi_cairo_lotus"
name spanish "cp_mi_cairo_lotus"
name polish "cp_mi_cairo_lotus"
name russian "cp_mi_cairo_lotus"
name japanese "cp_mi_cairo_lotus"
name mexicanspanish "cp_mi_cairo_lotus"
name portuguese "cp_mi_cairo_lotus"
name arabic "cp_mi_cairo_lotus"
name traditionalchinese "cp_mi_cairo_lotus"
name simplifiedchinese "cp_mi_cairo_lotus"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_cairo_lotus,cp_coop,2

playlist 210
name english "cp_mi_zurich_coalescence" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_zurich_coalescence"
name french "cp_mi_zurich_coalescence"
name italian "cp_mi_zurich_coalescence"
name german "cp_mi_zurich_coalescence"
name spanish "cp_mi_zurich_coalescence"
name polish "cp_mi_zurich_coalescence"
name russian "cp_mi_zurich_coalescence"
name japanese "cp_mi_zurich_coalescence"
name mexicanspanish "cp_mi_zurich_coalescence"
name portuguese "cp_mi_zurich_coalescence"
name arabic "cp_mi_zurich_coalescence"
name traditionalchinese "cp_mi_zurich_coalescence"
name simplifiedchinese "cp_mi_zurich_coalescence"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_zurich_coalescence,cp_coop,2

playlist 211
name english "cp_doa_bo3" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_doa_bo3"
name french "cp_doa_bo3"
name italian "cp_doa_bo3"
name german "cp_doa_bo3"
name spanish "cp_doa_bo3"
name polish "cp_doa_bo3"
name russian "cp_doa_bo3"
name japanese "cp_doa_bo3"
name mexicanspanish "cp_doa_bo3"
name portuguese "cp_doa_bo3"
name arabic "cp_doa_bo3"
name traditionalchinese "cp_doa_bo3"
name simplifiedchinese "cp_doa_bo3"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 0
rule scr_gunxpscalecp 0
rule lobby_readyUpPercentRequired 0.7
cp_doa_bo3,doa,2

///////////////////////////////////////////////////////////////////////////
//    CAMPAIGN NIGHTMARES PUBLIC PLAYLISTS (Playlist # 220-239)
///////////////////////////////////////////////////////////////////////////

playlist 220
name english "cp_mi_sing_sgen_nightmares" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_sing_sgen_nightmares"
name french "cp_mi_sing_sgen_nightmares"
name italian "cp_mi_sing_sgen_nightmares"
name german "cp_mi_sing_sgen_nightmares"
name spanish "cp_mi_sing_sgen_nightmares"
name polish "cp_mi_sing_sgen_nightmares"
name russian "cp_mi_sing_sgen_nightmares"
name japanese "cp_mi_sing_sgen_nightmares"
name mexicanspanish "cp_mi_sing_sgen_nightmares"
name portuguese "cp_mi_sing_sgen_nightmares"
name arabic "cp_mi_sing_sgen_nightmares"
name traditionalchinese "cp_mi_sing_sgen_nightmares"
name simplifiedchinese "cp_mi_sing_sgen_nightmares"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_nightmares_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_sing_sgen,cp_coop,2

playlist 221
name english "cp_mi_zurich_newworld_nightmares" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_zurich_newworld_nightmares"
name french "cp_mi_zurich_newworld_nightmares"
name italian "cp_mi_zurich_newworld_nightmares"
name german "cp_mi_zurich_newworld_nightmares"
name spanish "cp_mi_zurich_newworld_nightmares"
name polish "cp_mi_zurich_newworld_nightmares"
name russian "cp_mi_zurich_newworld_nightmares"
name japanese "cp_mi_zurich_newworld_nightmares"
name mexicanspanish "cp_mi_zurich_newworld_nightmares"
name portuguese "cp_mi_zurich_newworld_nightmares"
name arabic "cp_mi_zurich_newworld_nightmares"
name traditionalchinese "cp_mi_zurich_newworld_nightmares"
name simplifiedchinese "cp_mi_zurich_newworld_nightmares"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_nightmares_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_zurich_newworld,cp_coop,2

playlist 222
name english "cp_mi_sing_biodomes_nightmares" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_sing_biodomes_nightmares"
name french "cp_mi_sing_biodomes_nightmares"
name italian "cp_mi_sing_biodomes_nightmares"
name german "cp_mi_sing_biodomes_nightmares"
name spanish "cp_mi_sing_biodomes_nightmares"
name polish "cp_mi_sing_biodomes_nightmares"
name russian "cp_mi_sing_biodomes_nightmares"
name japanese "cp_mi_sing_biodomes_nightmares"
name mexicanspanish "cp_mi_sing_biodomes_nightmares"
name portuguese "cp_mi_sing_biodomes_nightmares"
name arabic "cp_mi_sing_biodomes_nightmares"
name traditionalchinese "cp_mi_sing_biodomes_nightmares"
name simplifiedchinese "cp_mi_sing_biodomes_nightmares"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_nightmares_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_sing_biodomes,cp_coop,2

playlist 223
name english "cp_mi_cairo_aquifer_nightmares" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_cairo_aquifer_nightmares"
name french "cp_mi_cairo_aquifer_nightmares"
name italian "cp_mi_cairo_aquifer_nightmares"
name german "cp_mi_cairo_aquifer_nightmares"
name spanish "cp_mi_cairo_aquifer_nightmares"
name polish "cp_mi_cairo_aquifer_nightmares"
name russian "cp_mi_cairo_aquifer_nightmares"
name japanese "cp_mi_cairo_aquifer_nightmares"
name mexicanspanish "cp_mi_cairo_aquifer_nightmares"
name portuguese "cp_mi_cairo_aquifer_nightmares"
name arabic "cp_mi_cairo_aquifer_nightmares"
name traditionalchinese "cp_mi_cairo_aquifer_nightmares"
name simplifiedchinese "cp_mi_cairo_aquifer_nightmares"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_nightmares_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_cairo_aquifer,cp_coop,2

playlist 224
name english "cp_mi_eth_prologue_nightmares" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_eth_prologue_nightmares"
name french "cp_mi_eth_prologue_nightmares"
name italian "cp_mi_eth_prologue_nightmares"
name german "cp_mi_eth_prologue_nightmares"
name spanish "cp_mi_eth_prologue_nightmares"
name polish "cp_mi_eth_prologue_nightmares"
name russian "cp_mi_eth_prologue_nightmares"
name japanese "cp_mi_eth_prologue_nightmares"
name mexicanspanish "cp_mi_eth_prologue_nightmares"
name portuguese "cp_mi_eth_prologue_nightmares"
name arabic "cp_mi_eth_prologue_nightmares"
name traditionalchinese "cp_mi_eth_prologue_nightmares"
name simplifiedchinese "cp_mi_eth_prologue_nightmares"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_nightmares_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_eth_prologue,cp_coop,2

playlist 225
name english "cp_mi_sing_vengeance_nightmares" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_sing_vengeance_nightmares"
name french "cp_mi_sing_vengeance_nightmares"
name italian "cp_mi_sing_vengeance_nightmares"
name german "cp_mi_sing_vengeance_nightmares"
name spanish "cp_mi_sing_vengeance_nightmares"
name polish "cp_mi_sing_vengeance_nightmares"
name russian "cp_mi_sing_vengeance_nightmares"
name japanese "cp_mi_sing_vengeance_nightmares"
name mexicanspanish "cp_mi_sing_vengeance_nightmares"
name portuguese "cp_mi_sing_vengeance_nightmares"
name arabic "cp_mi_sing_vengeance_nightmares"
name traditionalchinese "cp_mi_sing_vengeance_nightmares"
name simplifiedchinese "cp_mi_sing_vengeance_nightmares"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_nightmares_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_sing_vengeance,cp_coop,2

playlist 226
name english "cp_mi_sing_blackstation_nightmares" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_sing_blackstation_nightmares"
name french "cp_mi_sing_blackstation_nightmares"
name italian "cp_mi_sing_blackstation_nightmares"
name german "cp_mi_sing_blackstation_nightmares"
name spanish "cp_mi_sing_blackstation_nightmares"
name polish "cp_mi_sing_blackstation_nightmares"
name russian "cp_mi_sing_blackstation_nightmares"
name japanese "cp_mi_sing_blackstation_nightmares"
name mexicanspanish "cp_mi_sing_blackstation_nightmares"
name portuguese "cp_mi_sing_blackstation_nightmares"
name arabic "cp_mi_sing_blackstation_nightmares"
name traditionalchinese "cp_mi_sing_blackstation_nightmares"
name simplifiedchinese "cp_mi_sing_blackstation_nightmares"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_nightmares_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_sing_blackstation,cp_coop,2

playlist 227
name english "cp_mi_cairo_ramses_nightmares" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_cairo_ramses_nightmares"
name french "cp_mi_cairo_ramses_nightmares"
name italian "cp_mi_cairo_ramses_nightmares"
name german "cp_mi_cairo_ramses_nightmares"
name spanish "cp_mi_cairo_ramses_nightmares"
name polish "cp_mi_cairo_ramses_nightmares"
name russian "cp_mi_cairo_ramses_nightmares"
name japanese "cp_mi_cairo_ramses_nightmares"
name mexicanspanish "cp_mi_cairo_ramses_nightmares"
name portuguese "cp_mi_cairo_ramses_nightmares"
name arabic "cp_mi_cairo_ramses_nightmares"
name traditionalchinese "cp_mi_cairo_ramses_nightmares"
name simplifiedchinese "cp_mi_cairo_ramses_nightmares"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_nightmares_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_cairo_ramses,cp_coop,2

playlist 228
name english "cp_mi_cairo_infection_nightmares" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_cairo_infection_nightmares"
name french "cp_mi_cairo_infection_nightmares"
name italian "cp_mi_cairo_infection_nightmares"
name german "cp_mi_cairo_infection_nightmares"
name spanish "cp_mi_cairo_infection_nightmares"
name polish "cp_mi_cairo_infection_nightmares"
name russian "cp_mi_cairo_infection_nightmares"
name japanese "cp_mi_cairo_infection_nightmares"
name mexicanspanish "cp_mi_cairo_infection_nightmares"
name portuguese "cp_mi_cairo_infection_nightmares"
name arabic "cp_mi_cairo_infection_nightmares"
name traditionalchinese "cp_mi_cairo_infection_nightmares"
name simplifiedchinese "cp_mi_cairo_infection_nightmares"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_nightmares_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_cairo_infection,cp_coop,2

playlist 229
name english "cp_mi_cairo_lotus_nightmares" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_cairo_lotus_nightmares"
name french "cp_mi_cairo_lotus_nightmares"
name italian "cp_mi_cairo_lotus_nightmares"
name german "cp_mi_cairo_lotus_nightmares"
name spanish "cp_mi_cairo_lotus_nightmares"
name polish "cp_mi_cairo_lotus_nightmares"
name russian "cp_mi_cairo_lotus_nightmares"
name japanese "cp_mi_cairo_lotus_nightmares"
name mexicanspanish "cp_mi_cairo_lotus_nightmares"
name portuguese "cp_mi_cairo_lotus_nightmares"
name arabic "cp_mi_cairo_lotus_nightmares"
name traditionalchinese "cp_mi_cairo_lotus_nightmares"
name simplifiedchinese "cp_mi_cairo_lotus_nightmares"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_nightmares_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_cairo_lotus,cp_coop,2

playlist 230
name english "cp_mi_zurich_coalescence_nightmares" // DO NOT TRANSLATE - NOT SEEN IN UI
name englisharabic "cp_mi_zurich_coalescence_nightmares"
name french "cp_mi_zurich_coalescence_nightmares"
name italian "cp_mi_zurich_coalescence_nightmares"
name german "cp_mi_zurich_coalescence_nightmares"
name spanish "cp_mi_zurich_coalescence_nightmares"
name polish "cp_mi_zurich_coalescence_nightmares"
name russian "cp_mi_zurich_coalescence_nightmares"
name japanese "cp_mi_zurich_coalescence_nightmares"
name mexicanspanish "cp_mi_zurich_coalescence_nightmares"
name portuguese "cp_mi_zurich_coalescence_nightmares"
name arabic "cp_mi_zurich_coalescence_nightmares"
name traditionalchinese "cp_mi_zurich_coalescence_nightmares"
name simplifiedchinese "cp_mi_zurich_coalescence_nightmares"
description english "" // DO NOT TRANSLATE - NOT SEEN IN UI
unlockxp 0
maxparty 4
maxlocalplayers 2
categories cp_nightmares_public
icon playlist_generic_02
rule party_minplayers 1
rule party_maxplayers 4
rule party_matchedplayercount 0
rule scr_xpscalecp 1
rule scr_gunxpscalecp 1
cp_mi_zurich_coalescence,cp_coop,2

// must have a hard return after this line

```

`src/client/resources/dw/qosconfig4.csv`:

```csv
CSV Schema (1 sample row):
Headers: New, 1, , , 104.156.248.87:40000, 104.156.248.95:40000, 104.156.248.99:40000
Sample: "Chi", "2", "", "", "108.61.238.217:40000", "108.61.238.138:40000", "108.61.238.130:40000"
... [32 more rows omitted]

```

`src/client/resources/main.html`:

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />

    <title>Open-IW5</title>

    <style>
      * {
        user-select: none;
        -ms-user-select: none;
        cursor: default;
        box-sizing: border-box;
      }

      html,
      body {
        -ms-overflow-style: none;

        margin: 0;
        background: url(data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAoHBwkHBgoJCAkLCwoMDxkQDw4ODx4WFxIZJCAmJSMgIyIoLTkwKCo2KyIjMkQyNjs9QEBAJjBGS0U+Sjk/QD3/2wBDAQsLCw8NDx0QEB09KSMpPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT3/wgARCAGZAtgDAREAAhEBAxEB/8QAGQAAAwEBAQAAAAAAAAAAAAAAAQIDAAQH/8QAGAEBAQEBAQAAAAAAAAAAAAAAAQACAwT/2gAMAwEAAhADEAAAAPJcbxahWk1q1ajWo0S1atQrVq1atWo1qNGWI01NJolqLatJo0xPLy9NLU1ZNGQpoLGmFqajRo1kNMzU8sTSaFLSVMptKJpOJokJCsKBatWrSK1CtAoVxZ1h1CtRrVq1GtRrEa1ahWrVqFGjWo1qYTTU1NJEwZNatWppanlxeXpqas2jIEMZGkk0tRo0ayGmZqamoySFLSxOptKJpKJokJC0KFatWrUJ1CtGoVw53iNatWrVqJatRrVqNatWoVq1GsWoyaNNLE1NTSaNGdWo0ZcWmlPLyxM2jIEyaNRppYmkkazGMzQaairVqFCEqcTSVTScThESlha1CtWrUJ1ahGoVxY3q1GsWo1q1ajWrUaxatOrVq1ajWokZNNTU0tTS1GjWnUaYWlxpNJemkxkCBMgg0wsLCZatRrJkMFjRg1qFBkhKkk4lE0nCQjLAoVqFatWkRqFatXHz6atGrUa1atJrBpNatWo1q1asWoqS1GWI0zNLE1MrUS06jTC00mgvLy1FAgQOdGoywvlaWEzqyZNGYxkNaMwgUjJEonEkmk4SFZaFCBWoVq1CtWoVq5OfTVi1GtWo1q1ajOI1q1GtWrVqNaSRoySaizS1NTS1GtJok0vLjQXl5LZA5CZyYMkXyubfKTRrNqCDWdGTIINBBColJE0nEoRpokLC0KWtQjUG1CtWoVq5efTEa1atRHUa1GtWozq1ajWLVqNaiJphNGWos1NTUWatJJpYXl5cXppyZM5GjISanzqmdUzt87YcJoMusq5DkaBA1nQKVFhamiRNJwkTRKWBSsIWtQrUG0CtQrVzcuuolqNajWrSa1GsRnUa1asRrUZImiRlqMmCzUaZjTUZNNTCwvLizGs2cjQHJRiea43TOq46UxtjZLSETeU1lXCoushyIVhCQrJE4RJwlKiQtLAZYFChQTUG1AMwrn5dcRnUaNYjWo1pNYjRnVqI6jRIyaItRE0WNFjBYsaNNRphaWFyaTWYINGc5yWeqZ1XOrY3Xn1rnb52R1LoTWU1hNZRyrlXKorLColJCIkJC0sIi0sBlpYDCBWoIKzCtXPx66jRLUaM4jRo1pJaTRk1iMkjLERamE0ZyGsmQtkLNRoi1NLCxaSgoINAc5GSk1y2zu2N359a42+dsa0hJ6ymsT1lNZnrK2VREWERaSERaWFhaVFhaVFoUqChAYRkFCs3Pw6mjOokaM6iRoya1ETRkkZYiLCwsLUwms2bIEybRoKFTRpiYTOo0KCKgTJkZKVYbZ3fnu+OtsdK42+dE0qT0T1hNZlrKawmhIRykKyQsLSotKAZYWFZYVFpUFCAwgMK0BocepLUZJGtRoiaMmjRE00kSLC4tlcXFhajOQMNZGgINZCFMxo0SacWrUGVFoazkyNFKqavnV8b6OfW+OlcbpnbZ0GXRJzPWZ7zLWERERykJSwiLQgUsBlgUsIi0qLAZYCCggrQGhx64jRk1iMmjRoiaNNJpjTExpsrjTLTOnNOLVqzLrI0LrK6BrKucmTVmJGtIhaDKiwEyFGR6qNs7vnfRz6dGOl+fSuNua0rSaJazPWZazPWUczhERFhaWBWpYFBFpYWFZIVBCsEWBWQUIhy64tRk0SMmjRppNGmEywsL5040xqudUzqg0E0aGpdZTQusrrK6yushA5CCs2oUIWlZYCBMhQ09Umw3zvo59OjHTo59L46UzsmhStNJ6zLWZ6xNJuZokLCwKFCggoQsLSotIghUVlgQEDCA3Px3pJGTRokZajRoy0knlhYaZ3TLTGq51bOqGnFhLKi6F1hNiaymsLrKuV0K5VAgpaVlhWEBAmgsUenmo3zvoxvpx06efS/PpXPR87JpaTVJzPWZaxPWZQjlERFgUIFaFoQGWEpYVFpUVBCwGCCA3Px3pNGiJoi1GjLUaaSL0wvnVDVM6tjVc6tnVc6oLSaVF0Iiaym8prKawmsT0JrCImgQiIwhWEBMmgsUanmg3zrox06MdOrHTo59L8+tM7JsEqzSesy1iTmWszcoiQqCBQgQGBKiwtIiwKRAiwEWgggNz8dmjJoySaSRppajLUwvLC5p8tc6tnVs7tjVstRcdQZUXUjmesz3lNYlvMtYlvE9Zm5RkcqywqBMmTUUKGXKhq2ddGd9OOnTz69OOl+fW2NtnetAUSWsz1mWsycycIiOUhUEChARaFLColBEgIsKgYQsBgnPx6GjRFpJNJJpamFqaWlhcXl86qarnV86tjV8tRoJrUKWkSeiesy3iW8Q3zj0xHWZaxPRNyjLATIEyFDRQyw0NWzq+d9GN9WOnTz6dGOtufSmdk1jSNNJuZazJzLWJuUcoiIHK0IWFYQsIi0qLARYCKwhYDBIcehE0RamFpYjLyxNLS4tLiwuaqNs6tlvnVxtlqLFh1LKQiS0S3iO+cN45+vOG8Q1mW8y1lIVgmchCmQ0WJOLmrG7530Y3043046dHPrbnuuejZ3jQpEmkknrMnE3M9Zm5RFcoiwqK5WlRUWEgIsKwsqwQQGER4diRlqIvLEwtLC0uLS4vLC0uNRqavltl6BvlqL5mzrSpLU6nrMtZj058/TnzdOfP0xz7xHeZaJorkag5EZCmRpJONDdTVs6vjfRnp04308+lsdLY2+OhNCVpInom5k5m4nrMkTWZuU1lEVyjlaTWVhIVFRYCLAYQEFCJ+fuZNMLUwsLS4sLy4uLGnlhaXGk1Gw3y9BXy2y0ysJygVFInonrMN45+nPm68+bfPn6YhvMd5noRAi6yEznMYNMLGqGq51U1fO753043fG+jn0tjpTG2N4QK0iTco5m4k5lrMtZnolrM9ZRyiI5VyiKiuVhECLAYQtZBCeb0mmoi4sLywuLC4uLmntOLCae05Vmo3G5dGW2WmV8zZ1soFaSJ6zHeIdOfN0583THN0xDpmG8y3lETWVQayEyaDTC5qhuudUNVzq5roxq+OnRjdufSuNvno2dYRSwtlHM3MnMtZjvMN5lrMtZnrKayjlHKIrlEVyiCFQMsChAQeX0mWphYXFpcXyuacXNPLmmFxMsTzSaTYb5r5bZq5XyvlI7KJAJrM9YhvHP058/TPP0583TMOmY7J6ymhNZVyushNRphcXNUzupqg2zq+dXzu/Pp0c+lsbfHRzRykhABbKOZazDRDeYbzDeI7zLWZ6ymsIiOUcq5RFRUWAgRaEah5fSZaiLi4sLi5qguacXNOLGmFqIvLzSqjbLYrZ1TNTK+VhOUlgCK5lrEemIbxz9Mc3TPP1zHeZbJbzPWU1lUVzmNEWFzVDTmqZbGrZb530c+l+fS+N159HNPhJEAQso5m559nPvPP0zz9Mw3iO8z1iblHKayrlHKOVRUVFgMKCCt5fSRNMLywvlcXNUyvafOmGhphaWE00uLzQqjUajTLTM4vlbK2ZgIZEcT3iW8w6Y5+mefrmG8x6Edkt5nrM9ZVAmgiwsac1QXGpq2dXzrox06OXS/PdcbpjdMr5iGAQtmWsw2cvTPNvPP0zzdMx3mWsJrCOU1lHKuUREVyqLAZayCh5fSaYmlhcXzpxoafK9p86cWNOJlhNNLC1OLjSaFTK40yuNMr5qZHzNZELrCazLpjn6EOmYdMw6EOmY7zLRPWZ6FTRqIsLmmmg1NVy3xvoxvp59L89257rjdMr5mDBjKpLWefZzdDl3nm6Z5umYbxLWU1hNYTWUhNZRyqIiwqBFoIK3m9BEk0sLi4vnVDVMrmnNMLmmFpJNJk0SaWFxaqC4vloNMtc1cVcjk1k2V1lN5hsj1zz9Mx6HPvMOhHeZaJojkNo0kWpxpapnVs6vnXRz308+nRz3bnquN0yvkYMGhbMtHPs5tnL0OXpnm6Yh0zLWJ6wjlNYVEcoiIrlUSgioGEDzeg0RYml86caGnzqmVzTmnFhaWEySMmtRliMtLC5OapmrlrltltgrmoDWTC6zPeY9Mw6Eehz9Dn6ENktZkk9Cpo1GjTjQ1U1bOr410Y30ct9GNW57pjVcLEQ0CFcz0c+rm2c3TPL0zz7zz9My1iesJrKOE0I5RFcoiosKisIEL5+5oyRYXGmdOaploafOnNOLC0sRk1p1GtJokZMuLDTLQbYb5bYrZrZKA0Fym8z3mOyHU593P0IbI6p6zLQiBNGp6caDXOrZb410Y3089X57rjVM6fCxYAywqTTn0c/Q5tnPvPPvMN5lvEt4RzPWEcoiOVREVERUEKgocO2okZYXzqgvnVDVM6oaY04sLURNajOrVq0mjRFpYaDTOrZbYbYb5rZrZKWWsjRPeZbI7IdLn6UN0dEknonoDkQYaqjUbZbZb41fGujnu3PVc6bOmyklpWWFSWiDQ2c+yGsw3mG8y3iesT1mesI5noRyiK5RFhUVBAZePXUSMsafK5p86pnVDVDTi2dPJI0aM6tWrVl1EjLCwuNM6rltlvjVs181slQaydZTRPZLZDdDdHdLVLRLQiK5yGHCpWy3y2w3zq+NWxquNNjTGsaFKyVNEZEjojqg5jsjsjrEtZlvE9YnrM3E9COUcpoRFhXKoKCLy6aiJEy+VzT51TO6GqC5p8rSSNGjOrUa1adWoi0sLjTOqDbGrZ1bNfNbJQKWcg3lNEtUd0dUtU9U9UtE9ZCayYpFs3Ri6MtsN8Ns6rjTZ0TWNrKzOp6pwjTSWqaR0TSW8x1mesy3iWsz1iWsz1iblETWURYVyqCgi8umrURYWNOL51Q3TOnFzTiwmmI0Z1GjOLUZ0miLi4vnVDVctc6tlsVgoFLOQOU0T2T1SZNSNNp6p6yqZy0VC+DqxdGK+W2NVzp8pNA2lpLU6lpk09E4Rp6pwiT0TSesz1mW8S1mWsS1mWsT1lHKayiLZVFQUEXnvVqIsJNOL505qhp86cXFhMtTEZNGSRHUZMmiLi4vnVDVM6rlqNSqTw9kuV0JoRE0IystK09U9Cucj2aZOnJ187p518Nc6plY0tpLc1k6ksmk0tU4RposKyoiT1lHMt5lrEt5lrEtYlrM3KayiJZCKgoImN4jRoiTTixp86cXNOLC4tLC1MLSwsRnEZMkWFxcXNUzqhpxoNSpTAznOV0JrKIqKwo0GRp6Fc5GCodODr5nVzb4q50xrGkdSdSWLqOqSx0TaaJCstCAywjlNE9YjvEtZlrEt5lrE3M9ZRFsqipqETNYjWE0xoiwuaYXFzTC4tLixOaeWFxIkjJFpYXzqkvnVDT508uNCeChjOU1mehHIQUWasStPQqBGM1LpwdfO6udbDTOiIdSdRdR0xWOqWiTSRGWFgVqCClRHM9YlvMtZlrEt5lrEnKayiJZCLQTVItRnEZIkWFhYWtOLC4sLi4uNLT5XFjRJpIsL2ny0NUzqhpzTkw0poKByuhNZki6Fs6mZwJKyalQQwULowdeLp5Nsr51rSLFY6Y6Y6Y6JJJJojLAjVqFZFhUnrM9ZnrMtYlrEtE9Zm5RyiBBAoRKtWrSSImSLCZYXFpbK0uNBcaGnNPlc00sLC5pxpnVM6qaploLi8tDVnKomiWsy0T0CzqaqAxBkZUENVCvi6ubfm1ysaEzdS1Q1R1R1S0SSeszRaVAGrVq0BFhNE3M9ZTWZaxLRNymso5RlgQG0QjVq0kjRE0RNpiMsLC4uLy+WhpzVBY04uacXzqpqmdVzq2dVGuVxeHowETRJI7IaJ6Fc6nByoWZGVBRqma2bo5t8apnRFZnpjqjqjololok5TQiJCpiEatWjUqK5RE1mbmesz1maI5RFRYDCNXNrGrCa1ETOIy1YWkk0sLi4vafLQXNOLmnNUzqudVzqud3zq2dWy2KualNDQqT0Q0c+zm3R0LGhqoVANKqpqJOVcavhtjTGsKrJo7paI6JazPWZomsoiwsCtGrVoFBysJoVEcok9ZRERUVFgQKEcu86iWo1pJGSWoyaItJFqcWFzTjQ04uapnVDVsbtnVs76MavnV8t818lApBZXMdXPs5d3LshqmmZioVCMCgwok5Vxq2NUxpjQtK0dUtEdk9ZlrM3KayiK5WlQQKwCtAQUqKiorlERFRUVFhWECNXHvmaxGdRoiaM6iWk0ZJNLC0sLC4uaoNDVc7tjd87vz30Z10410YenJcLBQCiaIauXdydDj3c+qaBmKpUJqFKmI0w1xquNUxtrQmcz0S2R1mesz1mblXKMrlUWBC0EEBBApUEKioESFQMqLAYVoEce+ZrUaxGTWEya1aSRrS1ETTSwuLmnGmd2zq2d3xvp59OjOurnrpy9ODpCwUMlJ6oaOTdxdLj6XNokwpqrmoLRmVNRJhpjVcbpnZzoSmqaS0S1me8zRXKIrlUVFgQqLARYCLQRUEKgpUCCAi0KCChHJ05GsRoziM6jOEtqI6jWE0aMtTC4uarndc6vjpfG+jG+nGurnrpzrqwdGS4Uslp6IauPZxdLi6HNqmys5UKgtAjIK1MNMbrjdM7OdaUZElonrM9COVRUVytBFRYVEcrCuVRYVAwhU1KgjItCggoUI5enI1qNEtJklp1GdRHVq1GdRJqMuLjTO7Z1bPS+N9HPfTjfTjXTh6c3RkuFALT0Q0cm7j6HF0ObRPUtONBoTQECLRo5qZ3TO6c9ub0rSNPWZomsogcrQQMIVFRHKQmsrZTQsKioIEBhGQUKEBhAoRzdOZo1qJaTRnEZ0mtOLTq0GtRlqYXGhuudWxu2N3xvoxvpxrozroxXC5ULQmiOrl2cfQ5N559km1MVBcXgIqKgok+d1xumd0zsmhSsjmaI5VAgoNoDLCOURHKazNyjlUVFgIIzCBQrItaBSpqhvnqNGsOo1pJaTOklp1atRjUaaSLjQ1TOq53bG7Y3fOr41fOrZr5alSjSJLRz7OXpnk1mGybamqg0I1oTQrlaIsapjdcbpnbZ1pDK5REQIIzahQgIiTcprM3M3KaysI5CLGYQK1CA2haCChUtY1GtRrUa04jJnCZ04NRXRqNEnlic1TOqZ3XOq53XOrZ1XLbOqjQaUaWJ6IaObeefeI6JpqcXmhNQhNZRFbExqmdVx0pjbmiIpUVFQJq1CtQgIiI5nrM3M3KayjlUEBBAoVkFCBQQUqCkc6jWo1q06jOEyRNaSWrUY1Gmoi8sLmnzqmdUzqhqudUNUGmWgvJIMiS0c+8Q1mWsompioaoLUERymsoglhfO7Y3TO3zojqFKioIzasWYUERyiI5nrM3KOERUWMggUIDaBQQUsBhCtq1GtWrUR1GTJEzqJajRjU1EWphY00sL505pxfOnNOLjQXtEhSpPRHWI6zLWVTU41yuLUGRzPWUQITT51XO6425psuoUqKgrNqNBhAhERyiT1lLKayqK5ELArIKECsgpUBBBS0aFGtRrVpMmcJoySNGjRog0mmEi0sJlhbK1phYXtMacXFpFCJ6JaxHWZuVQlQaZ05PIZNZm5nrIoy2dVzuudPnTDhDLCoG1atQQUEWzPQjlEVyllUCLATAGFCAmpYDCBWhZ1atRrVqMmdJE0ZJGjRo0xNRFqItJEi0kWEi0vaYXNMaatKwmsycx1lNZEYqDTOqE05k1mTmesijTZ3XO650+dEtIpUCLWbVmECFRURysIiuUhUCLGQQKFaAgpYzCBQj//xAAfEAEBAQEAAwEBAQEBAAAAAAABAgARAxASIDBAUBP/2gAIAQEAAQIA/wBRjGAA5znOcAAACSfnnOc5wDAHOcxjGMfhznOc51Zz/wAcxgAAAOc5wAAAJJJ+fnnOc4AAAc5wAMB+HOdWrOdWc/8AB5z8BjAAAHOc5wAJAkkn5+ec5zgAABznOAYx+HOrOrOc5z/w+c5wAAwAABznAACZAJDnOc5zgEkkhznOcAx+HOc6tWc5z/fn8uc9c575znAAAAAAOc4AAEgAHOc5zgEkkk/Pz885zn5c51as5znP+Dn8ec5znvm5zgAAAYwBucAACQA/IABJJPz8/Pz885z8Oc5znOc5z/l5znPzznOc5znAAAAAxg5wAAAP0YwEzMwQR8fHwz885+XOc5znOc+uc/x83Oc5zm5znPkkkkn5AAAADgAAAY/HcYxpJJkkn5+WWUTj+HOc5znOfSc/HP785znOc5znOE/JJJJJJPzznAAAAAAx673vemnTp0kgE/PyyyyiOfTnOc5zn0iJxOc98/hz1znOc5znOc58kkkkEEEfPz88+ecAAADH5XvejOjRo0aQA+WalERHOc5znOciIiIic5z3znrnP3znOBzgfJJJBBBBHx8fHz885zgc4B771V73ppZY0aNOAOMs1KIiOc5znJznERERE5znOc/PNznOeuc4AASSSSQQQQR8fHwwz8/PzznP11e96IywwwwxpxuIiUUIiOc5yJznE4iIiJznOc5zm5z8cDnAAAAkkkgggggj4+Phhj5+fnnPz3ver3ojLLFRUVDDL6REoRERyInOc5ziIiInOc5znOe+c5zAAAAABJMzMzEwQQR8MMMMMM/Pzzn471V76ERlioqKhhnHpESpoShEROc5znOcREROc5znOc3Oeg5wAAAAAJJmZmZmJggj4YYYYYYZZTPtVXv5EZZYYYYYZxuIlFSiIiJznOc5kRHIicTc5657AAAAAAAACZmZmZmZggj4YYYYYYYZZRznKvV/JjSyw+N8b42GceuIlTU0JQiJuflznPp/megAAAAAAAJJJImJmZgj4YYYYYYYqKmhznOVf0YxpYYfG+NhnT7RKmiiihET8PpznOfT6fT+T2BgAAAAJAkAkggiZmZJI+PhhhhioqLmpoc5z/Exp0aN494949GnHpEZqampZZRE9PtznOfT6fT+T0YwAAAAAAAEkkEEETMzJPx8MMMMVFxcXNzRQ5/gYxp0aNG8e8ejTp9cRGWalmpZZRHOc+nOc5/iejGMYwAAAAAABJJBBBJMk/PwwxUVFRcXFxc3NTQnOc5+DGnTo0aNDDGnHpEZZZYZZZZRHOc5znOc/wAjGMYxgAAAAAJJJ0aNGjTgD5+WWWKi4uLi4uLmpZZ5znMYxjTp06NGhhhnHvjLLDFRUVFSyjnOfTnOc/yMYxjGMYAAAADGnTo0aGcYx64jNRcXFxcXFxUMMs85zmMY06dOjRo0MMacY3PllhhioqKmpoRzn05zn0/s/BjGMYxjGMYxjGNOhhhllEfaM1NxcXF+O/HUVDDDLPOcAxp0406NGhhjTpxuc+WWGKi4ubmihznOc5znOf4GMYxjGMYxjHoxjGnSyxU1NTRRXR3Gai4vx3478d+OoqGGGWec4AGMadGjRo0acYwc+fn5Yqbm5ssorOc5znOc/wADGMYxjGMYxjHoxjGllmpqbm5sssoodxmoqLi/Hfjrx146ioYZZ5wDGMadOjRo0aNOnAHOMs1NzZZZerOc5znOc5/gYxjGNOMYxjGMYxhEooubLmy5ubKKHcZYqLi/HcXFxUVDLPOcMYxjTo0aNGjTp0gc5xLLPIeQsvVnOc5znOc5z+jGMadOnGMYxjH4ERKKLLLm5ubm5qaH0zUVFxcXFxUVDLLPOcMY06dGgjQQSSSB7dWveTeTXr1ZznOc5znOf4GMacacYxjGMe+96JRRRZZc3NxcXFTQnpKmouLi4uKioZZ+ecAJJJIIIIIJJDH4W29evXr1as5znOc5znOfyYxjGnTpxjGMeh73d70ooooubm4uLioqUfSVNTc3NzU1NSz884ATMzMxETExMTJIe16tNtt69erVnOc5znOc5/ZjGMadOnGMYw+u973velCUVNTUVFRU1KOc6iyy5qampqWfn5JJiZiYiIiIiZkAPXVaaqrbb169WRznOc5znOfT+TGMYZZRET0Yfz3dERGWWKioqKipR6tateoooqaln5+SSYiIiIiIiJgkPSq001VU01q1ahyVnVnOc5z++4wjLLKIiI973+BjTp0sssMVNTRXVpprVkSipT5JJmYiIiIiIiJgnnpWmmm26pVrVq1FatWdWc5zn+BjCIiIiIiPf4mMadOnTpYZZorrTS0uciUJzgTPjnxxERExME8zlaqqpttuqaVaznVq1atWc5zn+JhEREoRERETH7MYAnTp06dKJX0000q+kROcCDxHjmJiZkOOdTVVVXVttNNKuc51atWrVqznOf4mERESiiiihExj9GAAAANOnTh79NNNNd9onOBB4jxnjIDGdTVVVXV1dW22019d65zq1atWrVqznP8AIRERKKKERETGPR6MYAAAADGPXeq019dMenPs0bx7x6NOHrVVV1dXV1dW2039d+u9V1atWrVnOc5/mYRERKEoRETGMejGMASSAABz05VXvRPTn2aN4942GaK+qurq6urq6uraa+vr679dVVc6tWrOc5/mehERESpShERETGnTp0kkhJJJJPEdWpXojKZz7NO8b42KK+26urq6urq2qppr6+vr6+vr6VVc6s5znOf6iIiIiUUUUUUIjOnTp0kkySSR8spRerL0RlFz7NOhhmivturq6urq2mmmmvr679d79NKqudWc5z/gERESipoooooZZZ0aNGkkmZgj4ZqbL16t0RlHq+jTo0M0V9t1dXV1dU000019d+vr6+vr6aaVVc5z/cx7EREoooooqampYYY0aNBEzJHxU3Nnk16lRKlHu7jDDKV9NVVVVVVU0qqq9736+vr6+mmlVVc5/wAJ7EREoooqampqKhhhjRoIJCeUWeTeXeRpX6Kll73vRGWUrrTVVVUqqq5zn13vfpr6aa6q9f8AOIiJRRU1NTUVDD43xvj3j0aceq17y7yvkaV7LKV3veiVNTRX00tNNKq5zn0+nO73ve973vfT/mHCIiMssMPjfHXjfHXjqKmimqryV5Xy15G1ooqaK+vr6+voqbmivr6apVVfT+HOc5y9Ve973v8ArMIjLDDDFeOvHXjrx3FzZf3V3flvy15KumvoZSvr6+vr7Lm5ssv6aVVV/TnOc5zl73ve7v67/kMY0ssMMVFRcXFx5J8h5P8A0fJd+S/Lfkqqa+hmivrrX19llzc2X9fSqrn9Oc5znOcu767+e/5D2Y06dLDFRUXFxceSfKeX/wBXyX5PJfku6ql7LNFdaaa+iy5ubK+vppVXv5c5znOc5/r3/GYxjGnTpZqam5ufJPlnynl/9XyV5Lu7uqrojKPVVr6+ipubKK+uqve/lznOc5zn/gmMYxjGllmpubm58k+Q8n/o+Ruru7qq6Iyj3Kq9KmpqaK71V73ve96qqquc5/0ns9noxgMYxjCJRRc2WX9tt1VVSvRNKe3OXoyyyj3vV73ve9+laVVVX/UfowAAABjGMIiUUUV9fTTVNK9NLOMenOfQyyyj3vV73ve/X0000qqr/wAA9GPR6PR7MYxjHtzq1Z9GnTj25z6NOnT+HP8AFznOc+n+3//EABQQAQAAAAAAAAAAAAAAAAAAAMD/2gAIAQEAAz8AE+f/xAAdEQEBAAIDAQEBAAAAAAAAAAABABEwECBQQGCA/9oACAECAQECAP6aPzZ+ZNmcj+MNDPOc/lGZ7EfkmZ6nJ6ec5z9bMzydT0c5zmz9LMzydT0c5znIiRHzMzM9COD0VznORI5PlZmZ7nrDZGEfjZmZ7HrnA5HInyMzM9j2BERERPjZme56+ciIiJEfCzMz72RyIiIkRvZmZ0ZyOc+jnIiIiJwb2ZmZ75znOfTyIiIiI/AzM9s5znIj6WciIiIj8DMzPXOc5EREiPRERERERN7Mz2zkRERIj0ciIiIiJ8DMz0znORESIj0iERERETg2szOgiIiI4Ij0BERERGHYzM6CIiIiOCPQIRERERHOpmZmZ7ERERHnp1IRERERE1szMz2IiIiODzU6kREQiRGpWVmdJERERHnJ1IiIiI1qqqzpIiIiIjy3QREREalVVVdRwRERHJ52OCICIiIjuqqqruIiOD1TYzKvwkRERwejiNjMq5+IiIj0TezOrGo4IiI95mexvOCIiPQNJ1ZnqRHAbTg9s6sz1Ij4SPRIjazPUiPwRERtZnqRwew6SIjaz2I9THLMz3IiI2vU4I4PWZme5ERG10EeuzM9yIiNydT2WZnhOhERG1ETHuPDPciIjbhEx7jMyYxjGMYAiI2omPgI87GMYxjAYIiNqJ8JHo4xjGIjg/JYxjkODc/g8diNREfjiNREeR//xAAUEQEAAAAAAAAAAAAAAAAAAADA/9oACAECAQM/ABPn/8QAHhEBAQEAAwEBAQEBAAAAAAAAAQAREEBQMCBgcID/2gAIAQMBAQIA/wCR8sznP5TMzMz+SIgzMzM/kiLMzMzP5AiIizMzM9rOsRERHr5ZmWdY4IiI9nMzMzOsREREetlmZmZmdUiIiI9bMzMzMzMzpkREREfjMzzgwMzMzMzOqRERH4zMzPMPzmZmZmZ0yIiIjnMzMzPII4PhmZmPTIiIiPxmZmZ5RyfvMzEzoEREREfnMzMzyTk/eZiIj9zgiIiI/WZmZ6uIiPQIiIiIj4ZZnpZIiPROCIiI/eWZ6rMiPGfMjkiIiIj+AREsz5ERHJEREfwDJlmc58yIiIiPfeczLMz6ERERH2fRfxmcZmZmfAiIiPu+k85zmZmZn7IiIj7s+zmZmZn6IiIiPs+1mZmZmfkiIiI+z1jg8XMz4kREfZ6pyeJmZ8iIiPDOD0jgjoPVOD0Tgj+aODxSOod04ODyN9Aj/L8szrPiHJ3Mz2yO2dbfGOCP5TbYiI7REe2RER2iI9oiIiOyRER7JERERHXIiI9kiIiOyREe0RERER1yIj3CIiOyQnuERHaIhPbOTtkfzRH8W/cj67vuP2IiI8L/xAAUEQEAAAAAAAAAAAAAAAAAAADA/9oACAEDAQM/ABPn/9k=)
          no-repeat center center fixed;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        color: white;

        font-family: "Segoe UI Light", "Segoe UI", "Lucida Sans", Arial,
          sans-serif;
        font-style: normal;
        font-weight: lighter;

        display: flex;
        min-height: 100vh;
        flex-direction: column;

        margin: 0;
        padding: 0;
      }

      main {
        flex: 1 0 auto;
        display: flex;
      }

      p {
        font-weight: 200;
      }

      a {
        color: inherit;
        text-decoration: none;
      }

      a:visited {
        color: inherit;
      }

      p a {
        text-decoration: underline;
      }

      p a:hover {
        color: #b86b3f;
      }

      nav {
        padding: 0px;
        margin-left: 15px;
        margin-right: 15px;
        border-bottom: 1px solid;
        border-color: rgba(255, 255, 255, 0.25);
      }

      #brand {
        display: none;
      }

      #brand i {
        font-size: 40px;
        width: 64px;
        vertical-align: top;
        text-align: center;
        cursor: pointer;
      }

      #brand span {
        font-size: 27px;
        margin-left: 10px;
      }

      nav ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      nav ul li {
        display: inline-block;
      }

      nav .nav-link {
        display: inline-block;
        font-size: 1.3em;
        color: white;
        text-transform: uppercase;
        padding: 0 10px;
        letter-spacing: 1px;
        padding: 10px 0px;
        margin-right: 15px;
        margin-bottom: -1px;
      }

      nav .nav-link.active {
        border-bottom: 1px solid white;
      }

      nav .nav-link:hover,
      nav .nav-link.active {
        text-shadow: 0px 0px 8px rgba(255, 255, 255, 0.5);
      }

      nav .nav-link:first-child {
        padding-left: 0;
      }

      nav .nav-link.not-active {
        color: rgba(255, 255, 255, 0.25);
        pointer-events: none;
      }

      .side-nav-container {
        min-width: 64px;
        border-right: 1px solid;
        border-color: rgba(255, 255, 255, 0.25);
      }

      .side-nav {
        color: rgba(255, 255, 255, 0.7);
        display: flex;
        flex-direction: column;
        padding: 20px;
        padding-top: 78px;
        box-sizing: border-box;
        height: 100%;
        max-height: 100vh;
        position: fixed;
        left: 0;
      }

      .side-nav i {
        padding: 10px 0;
        transition: all 0.1s ease;
        cursor: pointer;
      }

      .side-nav i:hover {
        color: rgba(255, 255, 255, 1);
      }

      .side-nav-bottom {
        position: absolute;
        bottom: 0;
      }

      .main-container {
        padding: 10px;
        width: 100%;
      }

      .container {
        width: 80%;
        padding: 0 10px;
        margin-top: 25px;
        display: flex;
        justify-content: flex-start;
        flex-wrap: wrap;
      }

      .container.full {
        width: 100%;
      }

      .container h1,
      .container h2,
      .container h3 {
        width: 100%;
        margin-bottom: 10px;
        margin-left: 5px;
        margin-top: 0;
        letter-spacing: 1px;
        font-weight: 200;
      }

      .container h3 {
        margin-bottom: 0px;
        font-weight: 500;
      }

      .full-row .card {
        flex: 2;
      }

      .full-row .card.small {
        flex: 1;
      }

      .card {
        display: flex;
        width: 25%;
        box-sizing: border-box;
      }

      .card.small {
        width: 12.5%;
      }

      .card.full {
        width: 100%;
      }

      @media (max-width: 1341px) {
        .card {
          width: 50%;
        }

        .card.small {
          width: 25%;
        }
      }

      .card .card-container {
        width: 100%;
        margin: 5px 15px;
        border-color: rgba(255, 255, 255, 0);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        border-radius: 15px;
      }

      .card .card-img {
        overflow: hidden;
        height: 135px;
      }

      .card img {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: 1;
        transition: all 0.5s ease;
      }

      .card.full .card-img {
        height: 300px;
      }

      .card .card-content {
        flex: 1;
        position: relative;
        min-height: 88px;
        padding: 10px 20px;
        padding-bottom: 42px;
        background-color: rgba(0, 0, 0, 0.2);
        color: white;
        z-index: 5;
        transition: all 0.5s ease;
      }

      .card:hover .card-content {
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
      }

      /*.card:hover img {
            transform: scale(1.1);
        }*/

      .card .card-content span {
        font-size: 1.7em;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .card .card-content p {
        margin-top: 10px;
      }

      .card:hover .card-action {
        opacity: 1;
        bottom: 0;
        border-color: rgba(0, 0, 0, 0.25);
      }

      .card .card-action {
        /*opacity: 0;*/
        position: absolute;
        bottom: 0;
        right: 0;
        width: 100%;
        text-align: center;
        border-top: 1px solid;
        border-color: rgba(255, 255, 255, 0.25);
        text-transform: uppercase;
        padding: 7px;
        box-sizing: border-box;
        font-weight: 500;
        transition: opacity bottom 0.5s;
      }

      .card .card-action.hidden-action {
        bottom: -43px;
        transition: bottom 0.5s ease;
        border-color: rgba(255, 255, 255, 0);
      }

      .card:hover .card-action.hidden-action {
        bottom: 0;
        border-color: rgba(255, 255, 255, 0.25);
      }

      a.btn {
        display: inline-block;
        background-color: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.42);
        color: white;
        font-weight: 600;
        padding: 10px 100px;
        border-radius: 1px;
        transition: all 0.5s ease;
        cursor: pointer;
      }

      a.btn i {
        vertical-align: middle;
      }

      a.btn.highlight {
        background: white;
        color: black;
      }

      a.btn:hover {
        background: white;
        color: black;
        box-shadow: 0px 0px 10px rgba(255, 255, 255, 0.42);
      }

      a.btn.small {
        padding: 10px 50px;
      }

      div.menus > div {
        display: none;
      }

      div.menus > div.active {
        display: block !important;
      }
    </style>
  </head>

  <body>
    <main>
      <div class="main-container">
        <nav class="sticky">
          <ul>
            <li>
              <a class="nav-link _play" onClick="showMenu('play')">Play</a>
            </li>
            <li>
              <a class="nav-link _sponsors" onClick="showMenu('sponsors')">
                Sponsors
              </a>
            </li>
            <li>
              <a
                onClick="window.external.openUrl('https://boiii.re');"
                class="nav-link"
              >
                About
              </a>
            </li>
          </ul>
        </nav>

        <div class="menus">
          <div class="_play">
            <div class="container full full-row">
              <div class="card" onClick="window.external.runGame()">
                <div class="card-container">
                  <div class="card-img">
                    <img
                      src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4gHYSUNDX1BST0ZJTEUAAQEAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADb/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8lJCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozv/wAARCADeAyADASIAAhEBAxEB/8QAHAAAAQUBAQEAAAAAAAAAAAAAAQACAwQFBgcI/8QASBAAAgEDAwEFBAUJBQcEAwEAAQIDAAQRBRIhMQYTQVFhInGBkRQyQqGxBxUjUlRiksHRM3KCsvAWJCU0RHPhJkNT8RdjosL/xAAbAQEAAwEBAQEAAAAAAAAAAAAAAQIDBAUGB//EADARAAICAQMCBAUEAgMBAAAAAAABAhEDBCExEpETQVJxBRQyUWEiIzOBNLEkQsHw/9oADAMBAAIRAxEAPwDyPFHFGlQCxSpUqAVKjSoBUsUqVAKlSo4oAUqOKWKAFKnUqAGKWKdiligG4pYp1KgG4o4o0qAWKVKjQApUaVAKlijilQCoUaNADFKjSoAUKJFECgG05I2mkWJBl5CFUeZPSliuk7B6KNW7Qd7Im6GyjM7Z+ruH1QfTPPwqsnSstFW6LUuybtPDbNLCIdGto7QXCk+xIRzIBjLbWLYA8hXR3dvc3SQHupoobWFE725cK8yqODs52Zbk5Oelct2f7RaZolg180YvdcvpXcsV/sRnA58M8njnmp9T0/tDq1uLrtBq1rpFo/tLBIxDMPPuxlj/AIsVzSjb32o64SS3W7F2+tmksIdQt7mO5iO1Lhh0MmMbk/d4xnzFef5ruu0Gt3naG2TTNF0gzWVtCsXfxwEs+AOcDheR0GawrHspqGoxd/DbNDHHkSm5YRICOuGPX+VbY30xpswyLqlaRjIyAe0zAjwAq5DLc3EZitkmLHhVhUk89cnqc1oKdD0h2xD+d7wZwASLeM/i+PgKba3eoa5qEFlNd/RbaRvaWJQiooGT7I6nANaWU6aM4WUqkh/0ZHBEkgB+WaZJDJF1bjzDA/hW3rem6NBo8F/Yd/E885WKKdgzSRgcucdOePj6VjxSJDEZETdN9jjIXzNE7KtUXbWzuIrG4m3JGFT22wSwJBKoT0XcA3HU4wagKW+oRlrZjDLCmWjfo48WBH4YozQ3elMk0oVlduVcEpLxk+jDBHI86u2ENgbuHU7O4S0jgbfKsrAtCR0wp/tFz5c+B86EkWn6bc22orNcqIYrZUnlcsOFIyvTxI8Kp6nqK3bvFbRiK3aQyEAYLsfE+7JAHgPecz6yViQx984eVhIYC+4jj60h6bj+qOlZcEUk8iRxIXd22qq8kn3VJUAUngCpbRzBeRnjDHa2Txg8Uo1DOqLkyNkEAcelOm2KzoXLlgOQehHnx76A0NRaz0TXLu302dL+BRsSYrgbsDJA9DkCsdQzYQE4znFWRaokYeZ9mei4yx+FS26JuLIpUdBuPNAU5IthHrTWVo22sMGtFkSaZYoojLKx2qqjcWPkB4112ifkxur54TrE5t0kQhIYMPKjEgKG8AOT5kY8KA4SN8Hgke6rZlwmWWKTy3IMmuk7afk11PsdbxXpf6VZNhXlVcGNvIjyPgfwrlgqsgIfPoRzUog1LO6glPdz3DwRkH6y98gJA6K3IPAGQfCtSxtYXJewvbeOcnJW1naIn07uQYbHo1c4tvMYTMsTtGpwzKuQvv8AKrFoyyIRwcdRUg9S7MWIuI4JLyzjvEVmSeKaDYX3DAIzwH/HzFebdptHXQO0d5psbl4YmDQsQQTGwyuQecgHB9RW9oPaHV7Bhb2k4ktz9e3mOYyPxHwq1+U0R3kGg6winddQzRM5bLHYwwD6jcwz4gCjCOExxQo0qqSACjilSoBYpYpUqAGKWKNKgBSAo0qAWKWKVKgFihijSoAYoYp1DFADFLFOxQxQAxQp2KVANpUcUKAVKlSoBUKNKgBilijQoBYoUaRFANpUaFAClRoUAqFGligBSo0MUAKVGlQApUaFAS0qOKVAKlSpUAqVHFLFACjijijigGgUcUaVALFLFGligBSo4pUAKVGlQCpUaVADFLFGlQAo4pUaAFKlRFALFLFOpUAMUqNKgBRpUaAGKWKNKgBXR9lNVtNMs9WFxeyW0k8AWJIlLNM3OF+ZFc7XRdmJtKs7K5u72ya9lldrYop9uGLuyzzRjH1lx1Pp0qklaploOpIytBvbvsn2hnE1ttue6e32SHGxmwOSORj05rtOzmi2V28mr6rAlw3LGW6QmJf7qcA+9j8KMWowacqm30e1sVlbZBdalG1xdXJJHMcfA8Rz9X1Jp2uRRt2jl0y/mk1V7CAT391fSMttbDAOEhj2jPIwMnJOKxknN7bG6agqe4Nc7V6UJRBp/f6jOFChIWwvoPZwoHuFcjfJql/Ztd6xP3FrG/6G3zhpCTjbGPED5fGt5ry3+hNI0C2qT4NvaxIquI/15CB1bwA8PfmsW61D6GryQqIZpF2tdzHfKF/UiHRBjx6+o6VGNJM0nfQnZU+lW9tCndKihgGEEXJP99v5VlORyWIUk544qOS4+zCu1fM8k1La6Vd3rHu1BOM+02M/OulROaUytsZjlnyPPrTkZ4idrkZBGQcZB4IrWj7MXTxuysY3j+vG64IrNmglgcxzJtOcHyNWozuyWylVJ0EvKYZAGb+zyMbhnjI60dWW1nu5LmyhNvasQsMbH2nAGNx+WaqYI4xketSieUPvz7WQckeXh7vSgIZkhUosTFyFG9j03enpQQlCSoXJBHIB6ip7qJVdZolxFKMqP1T4ijLJFLHFshEbquHYNw588eFARmeQQ91GBGrAB9o+tjPP30UUR/2S5b9dx09w/rTok9oOeg++pH2ZG1jk+GOc+lKBERhizsWY8lj1q3Y2xvWVWmjs4M+1PJk5/uqOWPu+6o4rCa5mEESCSUqWCFwAAPEk9fdWzpulm+hvxNc2kt9DbiWBIpCWVEI3gBfZ+qST4+yfWgLGlzQafdTWmlh1MinE8mBLIo6jP2R44HxzivVewd4qXWy9dYp0tizI5wQBj2vcQc15Hb6T9IljEkkiyEZUxqDtA53kkgAepIrYu+1QxLdWwF/f2tuEecLtt4xkDOPtnJ8ePeBQk9X7U9p+zVx2UvU1K5X6Nc23sDqZdwO3Z5nofSvmyMEcipLue5v5zcXVw0sp8W8B5DyHpUa94v2M+6oILdreXNlcJcWs7wTIeHjbBFbcWsx6i041WyguZZ8EXSKIZYyBjIK8H3EVhW1xZhgt1AzjxwxRh7jyPmDWzHo9lc2z3GmasjNGhc2l3GY5CPJGGVc+7FWsgkW0NtK0lvMkiMm58KQIwPP1PpWz2ximh/J92VS4t3gl725O1/EEggj0IIq92W07UrfVraK+050iePchlX2XXGcqRw1Wfy2Swx3ehadCgjWC3ll2AYADFQP8pqre9Erg8xpUqVALFKjSoBtGjihQCpUqVALFLFKlQCxSo0qAFCnYoUAKNKlQCoUaWKAFKjilQAoYo0qAGKGKdQxQAxQp1KgG0qOKFAKhRpUAKBFGlQDaVHFECgG0qJFCgBSo0KAVCjQxQCpUqVAS0qVHFACiBRxRAoAYo4pUaAFKjilQCpUqNACjilSoBUqNKgBRpYo4oAUqNKgBijilRoAYpUaWKAGKQFOpUAKNGligBSxRxSoAYo4o0cUA3FLFOxSoBjBiuFBLHhQOpNdglmG7XXljBHa26DTRbrCr8qHRVdhgYLDJY/iawdIVLaR9YnYiHTWSRUVtrTTE+wg+RJ9BXatex6tdy2faCSy0rV5ou8Wcju4pY2HTdjKsOnris5t1sawSfJN2wS4XtBq0Mc0kk1jf2M+nb3JKNKNrxj904Bx6VmXtlc60YGRJAuvalNd3j7T7MCOVjVvLoxA91PvPyg6RZXdxcWlnLqd/N3Jku7gCOMvEpVWReSOCfXmsHUO2nanWAyxKYEn4xbQ4L/4up+dQ3J8ExgvMsdq9T0zTp/omnobi7UnvpnOVB8senkOlcZNJLcSGWVy7HxPhVi4029gUtNF3eG2kMw3Z91WE05jCrEgDHI86mKjFGjU8jd+RQREyDgsfFcVu6TOc4mckKVCgD6oHhWdDDsxgY49o+VHvXtmV42w3pWiZzyjR6ncm21XSRd28CxTFCjKpyeOo/mK4HUXt7oRxyIsLTFlLOeMKeDnzpaZr95G5DOXRyN6jr76n1QxTgvG4McgPOMbc/Wz5VpyjKqZzMkXdkjcGwcEio6nuoFt22BicHIdgR3iHowB934VAeDg+FULE9u6sj28p/RvyD+qfOqvjt6nOOKmCoqgu2dw+qmC3x8vxqTT4In1OOGcyRB8qAByGI9kH0Jxn0oCOOC4fOxcAdSSBirNpZPK7rDMrzhSVQc78ckA+eOnnQh7sPdRzQxiZvZQnhU9w+XNRq81nMMBoZ4GBAxgqwoSJkWVAT49DVrQfpMXaCyl08pHNFIHLP9RVH1i37uM59M1JPaG6uJ7m02JZBFmdy2EhLDJT37sgDqapzST2sDQbkG9QzrkA7SeFPn5492enEA2dTkW8M4sdRthpMVywgtZZCkk6hiQWA56cDJGPStjTrWzvry3gu7qzsrKeBbWUG8RpGGDhyRxkHb8hWBpmrxaaIYdV0WMRuMi5WLbKVPj7XDDnp94q7daZaW960dmyPblFkjkHO4EA5H+uKkkwdQ0270y7ntrmLDwSNGxBzypwaEGJAD863+3TxalNZa5alzLPbrHenGP0yDBPHmMGuWhkdH35xgjd7vOoFNHQW1jBcpsmRWHrT4ba90O7Nzo79+qjdJbON2R/P4c1Daz7DuY+yOcitDQb2K61cRNJh7gFI1B5XAyM+tVbJo9Z7E6ppnarRUk0udrKaBwbixkxIgP90+B6grjnrXm35W7r6T+UC4j3E/RreKLGcgEruOPL61Ylt2iu9D7ctqGikZEgjKLws3QEEDzNU9Ymu7nW76e/BF3JcOZwfsvuOR8OnwokQ0U6FHFKrEApUsUaAFKjSoAUqNLFAClRxSxQApU7AoGgBSojmligBSo4pYoAUqNKgBilijSoBtKjQoBUKNKgBSxRpUA3FDFOpUA3FCnYpUA2hTsUsUA2lRxSoSgGmkU6lioDG0qOKWKkgFA0cUqgDPGjSxRxUgmxRxSFKgFijSpUAqVKjQCpUqNAKlRpUAsUsUqNAClRpUAKNGlQApUaVACjSo0AKWKOKOKAAFHFKlQCpUaOKAGKWKdSwagDcUqdto4oSNpYp+KOKWKFIrzWEYRWC2UrTysvXaxRc49CB8xW7+UWDSpbbS9S0ia7uIpUZHnuZS7OeCOD08eKyLadraRmAyskbRSLn66MMEfzHkQK07DTr287LmBb0TadbXgmNkyYkYAe0yt7vDNUbS3ZrBOSpFtI7fTdCEz6fa3F2kYCTzLuKgY8DwfTIpWWrQQaa9zJHLcX17Lgs3VIh5fj8q1msk1ezYTsYkNuZSFHifqr/ryrnZVisrqXaMqF2gs3Hl7PnXLfVsei108EF+0NxGJ4pC8SnEgce0hPPP8AWqzXhitQsW1lwSHP3VVYy3Fy/cBliC4fHivlUdw8fdbULYx4jGD4VvGO1HNOb3aHWrG4ZLcuwIyQp6A+lT3OmNDt34O4cEVnqwXDZIYfdWs+px3kSITiRBg+tbJHK3ZlRsyShem0nmtOG5DkxyMVR19or1yOhH4fGs2Q7HbjOajM7Ajby2PDwq6Zm0bxtoJdDnvp41ZFVo7Yt9YDPUn38D41zspBSMAYYLg4/wBeVWLm8uruKOGWQLDEAI4k4VcfifU1AIw3Q/dRkFizkAjlKna6lZVI9OtQ3HeMyzoVAH1dp5GPH5mo4ZSgwpw4OVJ6c9QaZH3rkwpk56hec1BJui2g1KRrqGRe/Yqy2/8A8gJw4Hqp5/unPhVDXJJfzgEkv0vZI4kjaWMeyMDG0H7WBgZ8ajsl3Si0zGpuWVGkI3GJcgkj5fd61P2nigtteuLS2SMR22Ig6f8AuYH1z6n04qAT6fJLPb2FpIf92jl7wRgYDMTyT5nAx7hVS2EU0l1dDczCQbN5yQCTyfXj76lsJylpGwJL278qfAZyPvzUGfoF5Jhd8EgyPVc8fEdKEmzb6hd3MEejXl01xp8uVWBjv7hj9Vkz9Ug+A6gkeNRaJci40xbE7UZLjiXbzsI5HuBGfjVMXsUERu7feXB2RllAAYg5PXnA+8g+ht6eg023jkbBlJ7yQHoB4D5fjUok20soXgu9PedXSZGMbgfaVcgVzd9p7WeiaTqzEMt730LIR/8AGQPwZflXSSSfQI4tSuFAnMTPFADyGl+qD7kwfjVDtwPzZpXZ/s65zPZWrXFx5rJOQ+w+oUL86r5ms/oVmVpdzFHCXuHwsJwfEnyqzrOtW0et2t5pexmtoQO8243OQefXGfurne8cxCLjaGLdPH3/AAqW3t2nfAOAAST5AcmlGNnTfkztbW97eaal4HZFk3hVTduccrnyGeSfSs7Ubk3uq3t2es9zLJ83JrW7GXDIL4WEhtu7VHlnH9rKu9RsBB9gHOTjk4xWJIqrPMqY2iVwAP7xp5hjKVHFDFCAUsUaVADFDFOpVJIKOKVHFQQChRNN3CpAaVOjR5XVI0Z3Y4VVGSfcK1rTsnrd6+yK0RWzgCWZEycZxyevvoSY9KtLVuz2s6FtOqaZcWqt0kZdyH/EuR99ZtCBUqNKhIKGKdSxQDcUsU6hQDaVOpUA2lTsUMUIBQp2KVANpUaGKAFKjilioACKFOoGpJG0qNCgBSpUcVABihTsU3xoSkLFAinkUMUFDMUSKcFpEUsUPo0qWKkqKjSo0AKOKOKVALFKlRoBUqVGgBSBBJHiKNLFAKlSo0AKVGiBQApUaVADFGlSoBUqNLFAKlijRAoBAUcUaWKgAxRxRxRAqCyG4ogU4LRAoAAVGzHvlRfeanAoCId5vNVsmgHgZ8q7m30w6f2TWAORc3SqGXxBc8ge5awuyuipruuxWTuAoUybScb8Y4/mfQGvStT09rKXTu6czynIUiP2YwPtY6k85rnyy4OrAknb8zNsdNJszuBG91ReccjoPnXDdqYZDcyCdu7KZysS+yHzgIPKvRmns3UaXqUslvtcyKm0m4kBJIIQc9cnOPCsOPR9B1m+huZ9aguo4AzC1ifDSepzyDWULTtnTKado86u7lrcd0uN4UNKRxuOP6VKbu3a0IhVSrjl5EBKr5e/1qTX9LlF0JI4DEApVlJ5PJxjz4qlFbwizEsiukSeyP1pG8h/M12xpo4ptxbRRcs7eJ8B548KQtmU7pH7vHRRyx/p8asbmXOxRGD4Dr86h2ke0RkHPQ81skczY2RmdseH301eOKIkAyB4+NIxuBuxgVLIA+Qfa+AHU/0p0QlkOIWCtg9DjjyFBQBksMkjjPhTo0Kx94W2DqHPAPu8/hVQRSWdxHH3hjO3OM1Zuw1lZRozp31wu4pGBiNegyR1Y46eA9TxZvNTlgtVjgYwFuVA/tNpHUnwz4AeHwzDdQxMsYIBK2an/Fy1QSQaG7LrNqFAJeQLj3mpO0GT2gvtybCJiCvljih2ftHvNWjSMAsgMnJx9UZqtcSyXd1LPId0kjFmNANhmMMm4cgjDDzFba2VjNpguE1AMWbBgeP2o/U8/eP/ABWMIkMY4beemPGr9haIsoE6K4YZHp6Us0jBtjI0RXEajeUY7QDuGfMD5Vt6dZrFJ9J1NcqpyloeXmbw3fqr555PT1qrLNBBIqr+hVT1Qc0P9oLO0U/Rbdpp/BpeFHrjqarbNIxinuzpLZLbTUk7S6/KszxkvbWrdbiXwGP1QcEn0xXFXRv+0GqTX95Lme7l3M7eJJ8B5D8BUF3f3F/dG5upTLIfFugHkB4Cr1hKLiZDnDoOF/nUpGeSXUyLW7SOykihhUCJQQGxyx8SffUOkvtvc+UUh/8A4atTtZcwTzJ3RGEVVAAx06//AHWJYXEVvdiSeJpY9rKyK+0nKkdfjUmZ035PkE1xqcWQP91EjMeiqjqzE/AVc7bWNlZX2m/Q4IYnmsVkuBB9Uybjx5FgMAkdTXOafrCaZZvBZh0ku1Md3KwBzHkHYo8BwMnqenHj3+s2D9ofyaaTrFpbAtpdsu90+3GMJKCPAqyBv7re+oom9jz/ABQxT8ZFLbiosDMUsU/HpQxQUMxSp+2ltqRQylTttLFCBpGaMcBlkCJgE9SegHmaOKt27R21m1xKud7bVHniobotGNkYnEKmOBmROjOo9t//AB6UrXWZ7aRMH9EoK92OOD1+PrVJ5jKzHack5yo6VWeQ8qMZ8xVkQzv4/wAoF9p1r3NjO1wwj5tzD3kTr494M8ceI586wY7MazcTTbooL67Ie2tLWACFieqcHKE+HBGepFZVheCyYrgFGxuGM5+HQn38CtsLBqRjm7te9+sGUnfx1ORycfrEqvl0oQY8sMtvM8FxE8M0Zw8cilWU+RBph4Ga7ru7TtZZC3vpxHf26YttSkkB3AfYlIzlfJuSPdXH6jp15pd7JY6hbtb3Ef1kbxHgQehB8xQFRCSMmnUVXAxRxQDcUMU7FLFQSN+FKjSxQAxSxRxSxUkDaBFOxSxQDaFOpUA2hjnOacaFCRU0jIp1KoAwLikRTqWKAZSp+KW2hNDacFoqtOwMVVs0URuKBWkWwaWc1CTJdAIppp56Uw1KKMkpUaWKuZio0sUaAFGlRoAUaWKNADFGlRoAYpYo0qAGKOKVKgFSpUqAVKjijigBSxQdxGuT4+Ap4FADFHFHFKgEBRpUagAxRAogU7FQWBinAUQKIFQ2SACnAUQtEEZxnnyqpNCC07bRApwWqtkpHWfkxtop+1Uve/8At2bsBnAPtKOfTmu77P6rLrc+o3qbWskuPotkwHLqv1yPe3j5CvNNOuDpPZm9volUXN47W8bE+0VUDCr73YZ8whr1TTdOTQezdtpMLDdawBXI6ljyx+JJrPJUY39yy3exwfaqdpfy0WUYGZYI4gSPcW4+BrkGnj07treyNbRXEdveSkQyD2WGTgH511Mdq9x201rtZJL3lpomyKWJWxI+Y9ns5GOOTz1xiuPuoJpe0uqw79xFw7PMRgAbjyR4e6tYL/RDqkvyT3t+dXeYmMWljHJ3jFSTs/dUnqaoSsZh9IZO6t4xshj8h/M+Z86soq3zrBGe6sLYbyx+9z6nwpl2O9eFkjO1sLa26gljngEjzPgK3ikkZzk5My5SWJ3ZHpUbgqo/XP1VFOkkO7cR7ROAB+FTJCEUOctIfrHwHoKsZorBDG3tYDEeXSpFR5SSpLYHJJwB7z4UpNvLsMKOnmxoSQT/AEaKeYqIpAzRoCOcHGce/wA/KoZIUkgi5VRcS+BYfo0+H2j7+PfTy2HF3cN307f2SScjj7RHTaPAePuqCMrEvfSKHHREP2j6+g/8eeITPJLM8kjbnZceWPcPDiqkhVJLq4XcWeSZwCTySSa6S8itVv8AUniYdwsbxxk+IVNo+8Vg2RVbtZX3YhBcY8x0+/FCQS90QXOCOc+dCSfQbp7fVxKhiVjHIPb4XlD5f6zVWFSoYnjjGD15qOOJiDIVOxPrGrsEZlikKbcsPac8kDyoSkRRorEFj7O7A58ffTjde0wBIzwPSoZJDEDGfeB5ZqrzUUWcmuC5PdFuF69M1XBC5V1PJyT40xTg808tvZm2nFSUGg1NFFPt7+PK4PsnzqxDZiN1a5ADEZ2eC+/+lWwhSJtwBBOQR0qLNIwvkxXZ3cs5JbxJptSzLiRvfUVSZMVek/kw7UrYQR6RclhbvqCtlm/RsJI3Qo3ocKR4ZFebVr6FJatBfWM0LyXN0iLaENhVkDg8+9cge/41DJXJvdoNAfRrx5IIpDpksjfRpmU+zhiDG3kykFSPSskrXXdjO2Ez31xoetolxaXZy0My53vgAqc+JxnP6w9a6a5/JDaX8aXeh6vJBDKNyw3UXebfQEEEY9c++ser9Ti+TVxpX5HlWz0pba7DVPyfXmmd4Dqli7RkbkkDxN7wMHIrAvNIurP2pFSWPwlgcOv3cj41WOWEnSZPhyq6M0pQ24qxtBpju1shnQRlkGQJI1kX4qwIPxFaKRWiKKJ7iZIYEaaWRgqJGNzMT4ACtK97P3GmAJqN3Z21wf8Ape97yVf7wUEL8TQtPygdpbTb3U9mY1GBH9CiVceXsqKuL2rs9SLpqvZjTZgfrdzF3LsTzhZF5B9DmrhRsoWejnUty2SXN0U4Z1URxqfVmq7N2XurlorRtQs0niT2LWFXlcA8lmIGB7yQKhOo2E9k9rp0t/ph71WgD3rtHEv2htA6nrmrd2NT7P2pMljPDayEZnzu+kHqC7+JPl0FQ2i6wyvfgZ/+Orh4e9n1y0ihHG9lYLnyHn8Krx9glLtnXbUIOjCJ8n4ECpPzjJIVluXcylQyLKCMKemAfD1otqc7N3cDDvGGWkYZ2jzA6e4VXqZ1x0+Mim7E2lmoe87S2sCEZRTC7O48wg5qCHTrW1cmDV3mXOcPp7FWPgSCeceGeKcQWkaQMxZzlpXO539cmnhRxy5/xGo62XWhi+Sck3OHkZZWAy26Rs5PA3EjcxP6qAAVrBoe0GmR6JqsiQXUB/3G52HNv/8ArfknYf8A+fd0xVLI25HbKngg8j3GtCJO/wBO722eRGhIWaOMnBBBKuFGODg5LN1HkRRTdmWfS+GrXBzl7Y3Wm3stlfQmG4hOHQ/iPMHwNQV3VvDbdsLGPS7mVF1K3G2xvBgj0ikIJyp8D4GuIu4J7G8ls7qFobiFykkbdVIrRSTOBxaGYpGnYoEVJA2lijilihAMUMU6lQkbihTsUMVJA2linYpYoTQzFLFOxSxUAZilin7c0dhqLJ6WRYoVLsoiOo6kWUGNUUStO24o4qjZso7EeMU1jUhHNMcVZFXwQnrRpEUQKuYpiph607pQog2TYpUaVSVFSo4oqjO6og3MxAA8zQAo1oN2e1dUDmxbaftBlP8AOmfmbUv2RvmP61ks2J/9l3N1psz4g+zKVHFXPzNqX7I/8S/1ojRtS/ZH/iX+tT42P1LuT8rn9D7MpYpVd/M2pfsb/wAS/wBacNE1Q/8ARv8AxL/Wo8bH6l3Hyuf0PsyhSrQGh6rgt9CfHnuX+tL8xar+xP8AxL/WnjYvUu5Hy2f0PszPpVofmPVf2J/4l/rS/MWqfsT/AMS/1p42L1LuPls/ofZlClgHg1f/ADHqnT6G/wDEv9aP5j1X9if+Jf608bF6l3Hy2f0PsyhijV78x6oP+jf5j+tH8xar+xP/ABL/AFp4+L1LuPls3ofZlDFGr40LVf2J/wCJf60vzHqv7E/8S/1p4+L1LuPls3ofZlHFLFX/AMxar+xP/Ev9aI0PVP2J/wCJf61Hj4vUu4+Wzeh9mUMU3uSZN5bpWl+Y9U/Yn/iX+tOGh6r+xP8AxL/Wo8fF6l3J+Wzeh9mUcUQKvDQtU/Ym/iX+tOXQ9Uxj6G38S/1qHnxepdyfl83ofZlICiBUklvLbTtDMhR16qfCgBV7T3RnTWzABUc0ZLKwqwFqza6dd3yMbeAyBDg4IGPnVJSUVbdFoxcnSVsrR5KjI5p+3jNaK9n9WC8WL/xr/Wnf7P6uRzYuB4+2v9aw+YxetdzXwsnnF9joNN0gT6ZpNw7YhsczmFkz3spBKYPmGOcV2enWV9DY99cP3TMdzd43tN6mud7Nzx6bcsbjMshT6qnIiHgB6+ddML2a6076UQO6GcDaM/fVJtSe5o4yiqRz3aPTWW0v5PzYrzXSYkuABjaB1OOpHhnp8K4DtBdw3GuX9nYQnY1y3fSE5aZ88j+6DwPQe+vTNT7VabbWoja6WSRxhkeLIX34rzO4gsY7eQRqrIZGYMuQ75PTPgtb4djPIm0QxQxtaO7EfQbdsyP4XEnl6qvHvNZt1MX724mILSqQBjmMeh8z4+nFbGprey6dZxyPGlnZDbFEqYAyc5Pi2PM1iNIEXvB7cwY4I6KPP312o4mQx24iiMkozMeNv6g8vf8Ah+CEqohLjgedMWTBJJwo5Jqsz985I4UdM0ApZWlfcfgPKpvp119B+hmdjag57sgHByDgHqMkDOKhCj7Rwo60x3yemAOg8qhkikkLncx8MAeAHkKiiOWJoSPuPHSnRqducVAJmbuogvRpOvuFXdLubKKQfTgxiwcADOT6+lZk7vJJlvs+yPhQVyD5k0ZaMnF2izeSwrczrZsfo8h4GMcdfuqNZ544RGpKKQeP1s0O7VkBBPekncCBtA8MHz603umBy5NA3bsHv5PmaGKdtx41Lbxo8ihzgDJY+QoQlYbazedgxU7BycdSPSukh0uGXuwI1Tu+VUchT5+p99VLWVSSqLgMvAI5ArZsWVHGByB1qjZ144IoXdksZwc46kHxNUZtgU8gYHStnUpssxPWuc1CQYCDGWPJ9KItOoooP7RZvM1XPWrBHFQvVzifIyiOOaWM1Nbom7vJgTGvUDqx8qEE73E0qpNMzd6PqyeLj/XjXrn5OPyi3VzDLY6nLC7QgOC7CNmToSPBmzjjjOSc54PjsrSyOZpFIycDjAHoKltLl7S5juIwrMhztcZVh4gjxBqkoJ7+ZdS8me23PaB9OWS2u4vpTd42yRA47pSc+Iyw9PCuPv4bKO9W90rUY5UaUbXMTd4h6sdo8B1zWC+sXVrE8mnajd25lcbIe83RhT4AHpg8VBa6nefnJ4pHDSbT+ki9n39K5o6fouSOxZ7/AEnUyXGmJA/fGfVUlPPd6YI3U+YkyD+NYdzJHDFHs0pkViFeW4kzgHg+wDUsE91eTNaIZRsxueRjgDzpakUtFRYlDkHq/j6mkW7JnCKi2YFzCIFaAW7d6smyF1HEoJOM+vlU1rcJbaXf2d/ZmRzGdm8lWt5g49rHnjIOfOukgCSaNefSbZWVIGLuABhzyvxBxWF2qmd9VEmd8tzZoZz++OGJ9fYz8a6kzgKcUsVxaiSYMJem5fte+nxS3KwbY55BGjhwgc7dw6HHTNQ2qbrBB47ifhVmDEasrDhqq2j1McXJKxXmq3t0rJekTSSyq4nkGXjAz7KnwU56dOBVq0XFmpP1pSSfd/r8ay76QNsUeBNa1sQ+n27D9Xaffmqvgvp4rxGhGT2qkRqhc7QaiEzDpVaOxzcWXlOD7hV3QcS67HYEKUvo5LYqwBBZlJTIPHDqprEecshTdjNaPZqQN2psZmI2Wpa5ck44iRn/AJY+NWS3OXUZF0NE6Xt5Hic3NxH3TexyzBGHgWJVcg+CitXW4l7ZaK2uQRD87afGBdbOt1EPt4H2l/CuW028W5LuwUzMzPwnJJOepDHx6ACtfS9QuNF162v8ODuwS+duD1BB8xSX6XaPMhUl0s53ggEcg0MV1XavsvLaayZ9Lty2nXy9/b4IHdn7ac+TfcRWIdF1I/8ASN/EP60eWCdNruTHBlkrUW/6KGKWKv8A5l1P9jf+Jf60PzNqX7G/8S/1qPGx+pdyfls/ofZmfilir/5l1E/9K3zH9aX5m1H9lb5j+tT4+L1LuPlc/ofZmfilir/5m1D9lb+If1pfmfUP2VvmP608bH6l3J+Vz+h9mUQtHbV4aRfj/pm+Y/rTvzVffszfMVV5sfqXc0Wlzeh9mZpFICtBtJvj/wBM3zFAaTfD/pm+Yp40PUh8pmv6H2ZUVM1IIxVsaZej/p2+YpHTr39nb5is3lj9zojpsqW8H2ZUKAUwjFXTp17+zt8xTG0y9P8A07fMUWSH3Qeny+UH2ZSLCmk1bOk337O3zFMOlah+zN8xV1PH90ZPBn9D7Mqk0hhutWvzVf8A7M3zFSR6Re9Tbn5ijywS5Ijpc7f0PszPaMimMuKvXcUlv+jkXaw8KpMxPWtIS6tzDLDofS+SI0Keaaa1OYsUqNKgFiprX/nIP+4v41FiprX/AJyH/uL+NVl9LL43+tHd21w1vIrbQy+KHo1RuxJJAxnwoU4V8r5n6Wkk7QcMAAwwaXNHrQxQlDgacppgFPWoaIZas078y2/GZEO3J+0ORUSBkGx/rLwaaBTgOc1nRl0tSbH0DSpYzUAaykkEeBp4oimSuUAx405J5JKNVe/erETh1HnRpohxaH4o7acBSxzVDPqG4IpbakwduKISg6iPFOAp23FECq2RYMUQtPVc08Jz0qrkUcjhteX/AI5cD+7/AJRVICtHX1xr1z/h/wAoqiBX1eB/sw9kfF6j+afuwAV1PY5SYbz++v4GuaArqOxgzFeY/XX8DXJ8Rf8Axpf1/s30O2df2dIvUChdlksp2TduEbEbeuceFSqvOTWR2o1oaLph2L3l1P7EMfqeMn0r5rDjlkyxjFW7PazZIxi22YFv2ksLSJ1aC5vb+UgiJJAioDj2nfzPkK2NG7baxqN09iyWNpaQxM5ZI2lCkDxYnn4VxnZHRLnW9XaBJzsJLOxyUO3q5HiBnAHiSPWuxXs3qmnQTafZX1tNbyvvaKQFPa8wOa+0kscX0+Z86nKe7OJ1Oe4a5YSoI5SeAOFJPjWaJZInP0yCUKD7MkRyFPn61397o+oq7G6i/wB3CjZshSZAfHK/W+VcfqNxaW1yO7la3mx7YSM92D5FTyB/rFbQp8GeS0T6rqqX9qksbiQDAZVOD7yPKsba7EZQKDyKZqE8Urq0UCJ19qPo39KgivjEQHTIHiK2WxytkkqZIj4HiB/M0xkRBuJ2j0qWWVJCZAQEqoHeeUbEZiPqKBnmjJW4pdxxyF8kHUe+m4j6NKQfRauz6HqttZtd3Fo8UYwSZCFbn90nP3VQDCIEFAX82HT4VW7NGmuRskZTkEMp8RUsbrsUfqDJphlQxMvdjex+t5D0FMU+wVHjQoE9Rnk4zSPn5GnpEzIZOWGcHHhQmYu5yoBPgBj7qEkh5mkHqaOeKBypMo4PkRTMuw9nx8AOlLJoePXxqa0wLjJ5ABJHnTEQkBpGJ6cY493pVtolUhlf2sYIHl6VDZaK3NC27yRUkwgUAj2fH3mtG3dEP1tzkceQrIhlZUAjG0H4Yq3A7B955A6k/wAqrR1RdDryTcrZOSa52c7pT5DitPUJyMhTnPiKyWODUoxyytgJwKi6miWLHApyJkjI3LnGP1jVjBsUcXeEDB2k8AdWNacVlHDGJbhgNo4UdF/80+0NtDFJNId0vQBBx8PIVRvJ5LlsggJ6HrVuCtk99qCXqC2iiWOFDkEDn3mqJwpBQEr0586cUAVUjyWbrnxNNjnkhDrG2N3BqCSzCXnlRY0LlAzkeigk/cKjt7pre5S5TG5DnB8fMUxLjCuXkfeV2jHgD1p1usQYzTMDHHztwfbbwX3efpmqslfc6O5vna2PcSxRRztvLI26TnoCo6Hw5qrvbb30sVxLDC4SdZnVSz+AB6486yEuhBI9yriSdydpK42n9b3+VXrm4s/zJBarbzi5RhKZnGA+4c8eI6YPpVFBI1lkckT6hrs7kY02KBAT3eSzAEHkjPB99O1IGa1Se5ZJru9IbvVUj2cDj/XlVeC2fUbcXUt6pkVwhWRS5UeB91StaEyB57iaaQDH1SqqPIeQ92Km0UX5Iw0NpB3YPvJqJLqCaVY++WMN1dwcD5VPLGNm1VHmeKzbmApPINgwGI4FQlZ1S1UuI8DJJO8kzWpo90p3WcjYDnMZ/e8vj/KsbpSDEHrUtbFMedwn1HSTxkEhuG9ehqmxqGHWZVTZcKJlHQnr86a97bMchXHoeaqkztlnxy3THu3rVqa4XStEnTI+m6koTHjFACCSfIuQP8IP6wqgL1UO6KIM/g0gyF/w+J9/HpVKV3lmaSR2kdjlmY5JPmTVkcWWd7I0NBnaKd48+yw+rnAJ9eR+NbVzEvdKQR1GRuz/AK+dYWjLm+BH2Qc84rZutgtjtRYyOQyiMt8gR+FS1aOdOnsejafK2p9jTG7bpbFhLGT1ZOjfcc/Cs7FH8mdzE8jwAS9xJmNhI27ORyCcfEDAPvFPlhMEskLHLRsUJ9QcV4PxHGlKMv6Pq/g+VuMsb9yEg02pSKYy4rzUe8mRkGmnNSY4ppFXTJGHNNOafimkVaybGnNDmnEUDUk2NIptOIoEVKLAoGjSxUkjCKFOIppFWAKBGaOKWMVJIMetIdaWKQ60slHOa6c3zj0H4VkspFbWrpu1ByfIfhWdIigV7mCSWNI+B18HLPNv7sqEU3FPYU2us8omJwCT4U4dKVKgFU1p/wA3D/3F/GoVz41Paf8AOQ/9wfjUS+ll8f1r3R24pwGKjzTga+VP0wdRqzaJayRyC4l7th9XjrUMixrJiNiy+ZFVszU020NAp4FNHWpAKhssxAU/woAU6qMowYpwFN3qOpp4IK7h0qpVixQkj7xMePhUgGRmjUWVsqpZsfrEYq0kYQYFORS5woyaEhKgUcmyHNt0OAxTgKbEWcZxgVKEOao3Rm3QNtECpNvFM3pnG4ZqidlbsaVpoJMm0DgdTUwFHbg9KWLEq1NimqPGnZJ6Dis2zKTs4btAP+P3X+D/ACiqIFaGvj/j1z/h/wAoqiBX12B/sw9kfJZv5pe7CBmur7FqO5vD++v4GuVdreONu9lb2UZ5NjAd2B0BJH1mIwB65qjpnbS80y4uLiKNUWY7hByUGBgDnn76rqtPPPgcI8k4sqw5FJnq9/fWulWUt9eybIIRk46sfBR5k14/ea1JrGrXepXbbGdSIlXJEY6AD3DjPrmr2vdrpu09tbW72DK+DtVGJBkyPaA8eARg9Mmq6WAOhQyWEzvPcRMZkR9p2hjuXbj28YB659Kz+HaP5aF5PqZpqMzzS2+lE2n6y9rbMljcTW8xjCB7Z+MA5wR1Iq5adq9WWRQ+rSs3QR3Vurxk+RPWuW+jRr3eJ1JYZyjcj0Pkatx3jIsFld3076cs2+SOMgsB4lc8Zr0nGNnIpSSOsuO288QUalp72/gZbSXKn/C3T51Wn1DTdfhNu8kczuP0e8bJF9x/lXO6m15YyPbXQUyFQGAcOCCARgjg8Y5FZICk+zlT5Gp6F5FfEd7mvqOhXGnqZoSZIxncGHtJ7x/Os1pFT2I8EnguR+HkKvW2o311A2nSzloSpYswywVRnAPlxWp+T/Q7bX+0HcXDACKMygN9U48/nU24RfUVajJqjPudFh065SO8nN1IY+8aO36c8Llj5kjw6V1XZ3SBb3ktvHcSIY123LQHAyf/AG193i3WmdkLO1vdXkE8SXc11qQgtZZnYRxbFdtxA5bjAAyBWna2K6rYGa8vbWygErbLe0UQd6wOM8ZdzWORvg6cPSraRh6q0l5O8GnRCG373u47eFf0l0RyWY+Q45J8RWXfafcRRFrqGOSL7TRuH2e/xFWrm7ni0m6eBhEWi2ZAwVUye0AfHIAHwrLt1jsiZIpNzEgPHv4dCOR6noa1jHYpLI73KF/ZrbsrRg9268EnPtDrj7j8arxx+yWY4rZnCSdmpgR/y92O7f8AWBGMfLFYhYseenlVkZSST2JFlCcRkr5nPWhvwc9TTGK9FXAHnQBqSlk8atMeTtXNWP0cTERc+GTVVZCBgcVIgz41BdMnBLfaPuHSnx+yCABQRQBSLqDx1oTZYtpQFIcgsTipgTnIBz6eNVYQXPkBVpWCKcce80JTZSnPVfI1QmbBwKvXLKAWrO3EvkdfCiKSY5QMc9PHHj6CnK2G3MqkgcA9BUftZAB8KLZH2jVihK8skgw78eXQVGzrxjkimbSeSaO2lgdvYknOMjHHgKciFuFFMAqQUBIiSKctEzDzQ4I+Iq5ELd+6lmgWWRWUtBHGyGZAeQ2OnHiKoq7KfZJHuqwjMWR7lZO7bPduvGCPFfdUA6W+0TszaOjCO8kguU761dZQGZDzhh4MucHzx8KkfRo7yC0hcsqOuEDHLKqjA5x6iso3DS2IhuJAWjbvI5D0BP2v7rdG8iAfGuj1K6hhmsRIxjDQMF2jJLZWsp2iUYtlo76dqMsUwJRkJVseR61caaOOI4GVf2Tg8++lNqRtpS133ssXdssbQbSVJx9YHw4qqt1psyfo72DJ6h8p+NQrZYjd1bIxjcw/GqV4kRllKtyXY+/mrqiMToFuYG9ocpKpqpLGWbcF3buc5zmrIgzJo7JbEnvp/pve47rugIwmOu7dknPhj41UAzV2WFmJJUg5qLuiOoxVgQbasQxQmMTSJI6RsBMqHB2noQfu5Hl50DtUY8ams544Z23qxikQxyKOpUjqPUHBHuqQXbbs7HqQc6Zq9tIcfo4ZgY5W9CORn4kVl3lhd6bdNa31vJBMvVHGD/5qKJzE4Izu8Mda1tU1a/u7OLT76ZpTbSHaJAC0fGCu7rj09KgA0SMPdqojZj1ypII+NbeqDZZN3rTFTwdxbHzbI/Csrs/AZZ3IRmVRzgZxV/UpFysKKO8yc4+soAznAAYDHjgiiIOk/JpDLHPPcrGsiooByOQM8Y8uR6g+GD13dYj7vWr1f/3s3zOf51S/J7bMlk+WIMpAj7sj2snr5EHBG4cHBBAYDOnq7JNrl45PsmUjj04/lXkfEqWJP8/+H0HwiT8Z+3/pmEU1hUrABuOlNYcV4iZ9MmQlabipSKYRVky6ZGRTalIphBq6LWMppFPoYzViUMxQNSFcUwipLDcClijSqbJGkU0inHihViRuKBFOxQNANxQxzTqA61JJhargXr5OPZFY8rbjWnrORfufAgfhWS3Wvd08f0I+D+IzfjzX5ZGaFOxQrrPJJhwKVHFHFAAVNacXkP8A3FH31GBVjT1D6rZI3RrmIH+MVWX0stB1JP8AJ2K9acSSc1JcW7W13LA3WNyvyNNAr5U/S4yUkmhCnUKQqCRw4p69aYBUqiqso2PApHgUVGaeFyKoyjZNFpE9yiyQssiN4qenvpXFp9EdrdmDcA5FMiUxEmNmUnrtOKcBk9ao3K+TnvJ1bvYYBgYpGpNpI4phXmll0ySOZ402r4HIPiDT1H0qX28AsfcM0xOEZSOtSRrg1mzKVbtckmzaSoHSiF5xUgFEKBz5Vm2ZdQzbUElirPvBxnrVzHjSqOpohTaZEkW0AeVPIqRVyMmjtqre5XqsznuHjlwy8Zq6uCAaFzbd4qkDJU/dUyR4GKs5JotKcWjhNfH/AB2596/5RVFVzWj2gXGv3Q/u/wCUVSAr6vA/2YeyPlsv8svdmTq8FxJYJc3ZRQkhUqiFVZv12J+sx8h4eVc/KyOQRn1J6mujn0K+1DVikMNxdfSlIhCIZDu8s/Zwccnwpl3pFh2VJTU5or7VAAVtbdw0UBz0lYdT+6Pia9CL2OSa3MqW5uEt4bU3Bkjgz3O1shd3J2+Wav2F7Z2Bc3F9Puhk2xw2ij2/N95+r8Bms+e8e7Cl4okQSM6LGuAmeSo/dz0Hqaia1me1e7EYMMbhGYMMqSMjjrjjr0qavklSaWxpxXlu0pSxs0tFk4MjuZHx5FjwB54FVZlX6QYGidJd20xgc58qVsbO3jVp71mZhnurePLD0LNgD4ZrTh0zUtXAvrLT2toYiD9PurgqBjod7ELxjwFRwy/KMGWIo3GWHuwR7xUJrtL2ysb2MkW/fTRqFaWCfhzjlkJAyPQ/Oufm0+KEtMe8uYUOHjH6OVD4bgQePUZqylZSeNxZNYLY3lpfXEmbR7Ox2xLGpYTyE4JdvD6x8ugFVtD1680C5mmtCuJ4WhkVh1Vh9x8avXd1qk+gC3FrFYaVHJv7qNcCR+mSxyznr1OBzjFYDDxFNmVacaN3SrubT+6uInO0TJcqAed0eQy+/a2flXSaTcR215PaW84Cy/pY5ASN6nw9kbmPpkV5+k0keNrEAHI58a2Yu0epCMRWdyliMYCQRiP/APocn4ms5w6jowZVFUa17bvYarNBGpmhkUgQsu3KnlgoPKMCeM1kpp9nDMTEt3Ow9oQPER8z0xVb6TPE24yqJWJLyMdzNnzzV+31+RLWS1kQSRd021YsgBuoJGcYz1FWVoTUZOyO/ZbHSkWXZLdXhaQqRlUQ/aHqSOD5CsAGpriae7maaZ2kkbqTUJBHWro5W7YqVKlmhAQamSQr1FRFWADFSA3Q460VbwNCS2soNAvjnxqIdKa5IoTZat53WTnkHwq60qmMHaMePPNY4mKkY4NTRz7UZm5Y9KgWC8m3tsHQVFECCWGzKjcd56+nrTQNzZJ+dSFMEg8EVJVsBYsSxOSxyTQC7ufChyOM9PCpUGSFHxJ6CpIGEYorGWGRUhhHLAlhjOc09CwTapO3rjFAQiMhgDxTkiZm2jxqzHbmQ5Mm0eJ7vOPvrStNLUupjvLWQtwBMGQZ8vEZqaBkPbOi5OOR4HpRkc7Y49zNHGPYVj0zyfvrqZrW6sYFd9Bhu0IwJIWLDPkQOao/T7KF1N/2fZgxOUMTRADyBHJoDAlL44Y8L06YFdOZNmk215Jcd0pADTXA7yRiR7XdDyqjqlxpN+I103s81oVTDuJJG3nzweBWRKsuxS0pkSPhQSSB6CqtWSW7m8sMkRGeb96U4z8BVMzwn/2Ux5Yq7HptvParNE5c49odPl6iqgs8MRuyPsnHWooWQ95EDlY8HzBo99xwKelo8zlIkLsBnHpTTBIhwyEUJAJ2HQn50hJkNuBJI9k56HNEQsT0xQVeKgkA3FWYDhevHSrL2caXMiXF2IFRioBQl+PNR0+JqV7RLjSmvoh+ntZFE6eDIfqv8+D8POqksrzzyTyHMkrFmPmTQBEiQSxSWneJJEQwlJ9rcOQR5YphJZizEknkk+NO2EEgggjqKntrZriXaqnavLNtYhR67QSPlUXZNGzpEP0TTzPPFIokPsuw2qR7ypX5kVSeY3F9tJCqT0IIC+uATj3qalupI7eIRWzja/AcOvy3pgZPk61JoFpJc6hGqBwyPhQnstv64UfZfg4H1WxirIhnpfZSCazsxEIw5ztYdApOMFiOORtORw4KnqDQvIpYruVJxiXe27jGTmrWjww2piM5QQW6id0j4RtvtoB+7lu8A+ySV6Csm015tU1+RL+No7e/lOxSfat3Jwpz5HgHz4ry9dh8aox5W56vw/UeA3JrYkK00ir+p6ZPpV4bafnIyjgcOPMVSIrwJRlF9Mj6nHljkipRdpkRFMIqZhTCKJm6YwYFRt1zUpFMIq6ZZERFFR404LSIxU2XTGN1qM9alYZNLuzjJq6ZayLbQxxUhppqSRqgE8nAppAp9NqQNxTSKeabVkywzFCnmhsNCTnNZI+nMP3RWU4wa0dZONTkHoPwrOavoNOv24+x+fa+V6ifuyOm0800iuk84nxRApYo0Aj1qa0z9NtyDgiVWBHgQQaixUtp/wA5D/3B+NRLgvj+tHcySvNIZJXLu3VieTTaQo4r5M/R0qVIQo4p00MkEccjrhZOhpAVFhNMQFSCmgU8CqMhkiVIKjXinjzqrM2SAU4DmjGUMbbiQwxt9aRPgOtZ2ZdVjwvFAx5p8eSdpHh1qQIQcgZqlmblRWm3QW7yrGZGQZCDxqnFrtk2owWaLcPNd8xxJHu7vzBOenXnHSteeWO0tRcy57rdtdgMiPyLeQPnUemWWnra3evaarSNIjZug+1WIGFjQ/3sE4645r09FhjkhJZI7NbM8fWalqScJbp8Fi3aGaLerB1ZfZZTkGiqDmsDXLm47K65+cHi/wCF3hUXUUY/sZSPrqPI/fz44rfgliuIEngkWSKRdyOpyGFcOr0ktM75i+Ga6fVRzJ+T+wcAVHLkLxU+KG0MOeRXHZ1KVDYvbQGpQtPQRiHZswwOQw8qIFVbM+qyMRfpC5JOfCpAtOC0sNnpxVGyrkcD2iH/AKhuvev+RaogVo9oh/6hu/8AB/kWqCivsNP/AAw9keDk+t+42WTUVt2SwvpLYsrKyqxCuGGDnFcncaLdW1nNdSxyFI5Am5UynPmfD0867JRXUdkreG6sNQt7iNZIZGVXRuhBBq+TU+BDqq+CPD69jxZWZmVVBPPCjzrWsEnsr6azubcxzuvEcq9f3SPIj+VT3nZtrHVp7Sa5jtpIZCSpbcETqp3Dg5BHTmqtzBDbYc3DzTt7SPkjHPDedeh1XsYRi47s2LPV5LR4bfTbHTrBiQv0hoQ7jPizyZx8MUNR1K6vdQmi1u7kubiP2VuFcSqnHAGONp9P/FZ9lfRzuY7l+6mII3jpL6HyJq3d/T7m2hSa2jtEixsWGHac+bN1JqGt9zWO+8R9nZ3E1oFtoI0mUmT6b9J2pt/VZTnd6YwefGhdXMKzRT3O1ZIUZl2qSXPTHz5yagtbr9O0L71O8gSKvsuB4kVox2z3HeRrgRyJgyMQq4Pqaq9jRRuOzOfutYkmi7iBO4h2hCN25mA6Ak+HoMCs84NXL3ThaTlEnjnQdXjyQD5Z8aqTLsbaByBgnPWtI0uDkmpX+oado68mpAI+COeOlQUUOGqxmmPI3thQBT3t2iCknO4dPSi6GGTDEZHlTt+csTuY9M1KDtclmCza+lihhUx4QbiW3HPhjpjPl4VXvLd4Q4YbHRtsqevmKtWFz9HbbnGTnd61qS2ialb3Fw0qrKW2Bdud5IyST4Y4+JoQcsuKRFST281rN3UyFGwCM+I8CKAUEHOagFqL6LcwQ2+JIpwSO8L7kbJ6Y+z99U3Qo5VuoOKOMVfguUe6QXaqtu7ZfK7ivmRUPYsqZSibPsmpHXdH09ofeKZPLAzMYYTH7eV9rOF8vf60+GUAEnnjGKkgrGnLnGAac/tEnFNAoQOU+GAffTsgDnpQA8RTj9YL4Dk1IAiySSexHkt0GKnktmhj3GRWGcDb0NEv3cWFPtNyxHl5USHJIZg+AMEHjp0qSCFFdumflU0atuwZGUEeAoq0i9Nop4Ervnci8eNATpAzY/35tuQOUyKuwaeJAf8Ai8SKp6PGeT8PCqK57oAyKCOAMj41cismdgn0tUTGWLDIWpILK6PcxMEtdStW3jcwDsnOeBnxq9JY6ykJf6bPOF9ljErMgby3VQGj3Yb/AHa9sbrzC3AUj51ftRr9mwbu7uHzaBgwPyODUElRNT1K3Y2z30Z3D2+9kOEHx5FVLmB3naK7jyuNyPbsHXnoeOoran1XXIe8FxHNciThlubYPx8jVP6Tp88LCbRrWPdyZYlKEeeMEUBk6TKNP1eJJiyRSttfHn4H51v6roUUYSRd/dTNsW4mmBzPzlQo6KcEehArNbTtAuISgu7m3Y/VkZt6k+q9R8K2NI1BNQ0iS1vJLRTbjuZZbiPekSYPtqARy2Bz1JqrBhXFlM6idFCzRdFChc48OKhuYU3B48mGRd6H0Ph8OnwrXa7UM/fSo0qyNG7bSm9h9rB5GRg4qp3aSrPbJjcM3EPqPtr+DD41UkyHTZyORVZ07t8eHUe6rzrx6eFV5V9gZ6qePdUMsXuzsiDV4reY/oLwG2m/uvxn4HB+FZrQyW07wyArJC5Rh4gg4pIxRww6g5rU1CFtR16+ng/SxSSmZpEVmVA3POATxnHTwqCTPjjluG2IrufrHAJPvOK11jh0yy74iCRmOFcNuAPo6YeNvRhipUSDTYFkdYJA3KORuQnyE0ZDI3oR76zru6ku7hriWRy6gBmlAZ0HhvIHtr0Gf/GbJBleZ5J5WlmZiftuwDMB5tj64/e6/dXcdmNOEMIaTdjbhx1YADcUz9oFR3kbdQUIrntB0qW9v0MYEIR1QFhuWGRv7PcPGNz7OentfPrbu+t7GCCGNO5BCmNQeY1Y7gn+BxKnuNG6VkJW6RsXt7ZPpV1ly10/sxLGSpbBJZ/VS5PHpXJm7jlvYUc4e4I4DdCfw5pz3DQXXfzOsj2zGBY1cZAC56eXJyfOs69hjlGmyQPvuLl2Vogp3E54I9PCsOm7b8zpUkpKK8j3TTI4O0XZe3GoJvcAozdGV1JUsD4HiuS1rQrnRpvbJlt2P6OYD7j5H8a1+zmqWugaXoGkTzpJJqAd1ZTkDPI595Arrb2ziv7OS1mUFJBj3eRrDNpo6iFP6l5m2n1mTS5L/wCr8jyYim4q3e2U2n3stpOMPGcZ8GHgR6GoNvNfNyTjJxkfYY8kZxUo8MiIppFTEU1/abJA+AomapkW2isW489Kd0ppdvOpLbj+6GOBUD8VIzuqjJ61AzEmrJEx/IwjmltzTs0s5q9mqGbcUw9anqNhUpkjDSQqrgsu5fEZpYoYqwe4Ujyc0/aKS0aiyTj+0Axq8mPFQfurMNafaHnWHH7i/wA6zcV9Ng/ij7H51rv8nJ7sZSxTsUCK2OQmo0qVAKprT/m4f+4v41FU1p/zkH/cX8arL6WXx/Wvc7XFPA4ooqkElsEeFHJzmvk2z9Gvcv3MU91okTIgZIMkkdR51nxHevurS0zUFtN8UyloJR7QHgfOs+OLuywzkZ4PpVI7WjDE3Hqi1tyv7HCnAUKeoqDVscq5qTaRxSUVKBVGzJyGovHTwqaJDtGRzTo1GKkUc1lKRjKQ5VwKlUcUAtSAVk3ZzuRHKkjW8kcchjLqVzjPz864DRb2TTtZvtNmhZFMhkt7N2PdLKDhwB4HHQ+VeiYrmu2mgS3Fomo2ns30CidSg9pkHAb3jHPpj9WvZ+FZm1LDLhnka6FSjlXKOu1LTbbX9Gm0+XLEoYyR1PiB/eHUeo9a8u0XU77sdqc2n36PJZ7gHwOgP1ZE9CPn7xWz2f7T3V7Z2t1bwSTT28ixXMaHlnYnawHrg8+fFZt403ahNSDR5vbK7b6HIvSUHJkhyODkgsv7xIH1hXsxxqcHiyLY8yUnGXXje538EsVzAk8EiyRSDcjqeCKfGgUYHSvNuy/aV9GcQzbpLCRvbTHtQnxYD8RXpcbJJGssTq8bgMrKchgehFfLa3Rz0s6e6fDPa02qjnj+R4FHbzQGaeBXntnQEDijjikKIqrKnA9oh/6guven+QVQUVo9ohntDd/4P8gqgK+xwP8AZh7I8af1v3HCt3RblrTSLsBMtcyLHGfgcn4VY0LswtxCl5qGdr8xQZwXHm3jj0FXZrdfzrHAsm0SFUIVAFA8gPAAVaWNSVS4Ji6dnDa3ZWFsXS1i7sggNMXIUk+GPEYrnL3TrruPpkykwNuWOc8ZK8bD64xXY3VoW1Ca7uDuzKVgz4LnAbHhxipJru1i0/VtOjjiu4rG/guV3DvE9uPa7P5AMBkeZxXbjdLYyyq+TzfuzKMH2VHVyDhffWhpuuywRi3mmJjH1Sw3bfhViG701gYZrC7echlkNtKI1K+BwVPy4FV7zSo725m/MVheiG1g72cXDqzgDq2ABx86255ME3D9UWasb2s08KtMlnAdxluY0712XHIGftHoBx1qV7/SbcMLHs+0/s7BNqU5lOPMKMBT+FcpBJJCrGOaRG/VXoffV+GwurzD3F4ip+82QP5VWqNFLr8iNmt4rcx96zAn2iOce6qlw8UmHQkMxO5MdPLn1q5qccNqscEV+LrcCZFjXCJ5YPQmsxlA6GrL7mc5Pgt6jbWltIgtLwXKOgbOzaVz4H1qmRtcjIOD1ByKFLxqxiWZ5xMysIwhCgHB6nzqNWwQajzRGWOFBJ8hQtJ9TLBlBOcY9Kt2k9wdQRoJEC4we8HsKo6lvxqisTA+2MH9XxHv8qtRFFXBUNu+yeA/v8lH3/gKlvWlW5f6QpJLgMgYYIjHsoSPAscnHurGIYOVPVetaTTFsOX3Mx3BiMAnpvI8AOij/wCqrzwKMGPOCMqMc7f1m8s+H/1kCsKTcrz4UqPB4NSCOipxQpUA/NKhgjHqM0agBGc8U8DknzoJnrV62tCV7xlJZuEGM49TVkiCKOMbgdysB+t+FXbaB7jJRY41z1I6/CnRWcMgkWImQpzJOw9lfd5k+A86UOI1OR7G7qeQD5Z8T51JFlkWMKKN0aSyHqociozDbRsWmsNg/vmrVrHG8ZdUAOPaJ4z7qralKhgQoWyzYIbrgeVAU5NRAdWhtoYl8AgOfcSaH5yQqqtaoQoxjJFR/RDMf0ZGTRXTJWYKzqjHoGOM+6osktWmq2dtMrtpUEqgjcHYtx44HTNbzatZNbMtpZfRZOkRjfCMP316HiudTSjtZnZsL1II/Cr1otrDGYrlFLAYWXk5HkR4e+lg2NK1u1sN0V5c3a5wE7oKFj8zzk1pHtDpFxIXvLaC6QkpvePnb4ceZ6mucn0dzGrBZF3ruiEg4cehrOntp7ctHtA/unoaA6O90DR7+dm090t2Iz9HMo5PgBnoa55Df9ltW76e0YxN7J7xMqwyCCPDIIB+FRW9lqF7Niys7mZx1KqcA+p6CugXs/2mutPED3EMkUuQ0XeFse49Cev9aqyR+rahp09oJ+7N9OSGv44o9kU6/wDyA9VkHTcBz4+Nc9clrGaC6spjNAG722kcckDqrDzHQj3Hoa7nQfydXMccV7JqcojX6jw7YyPAqc5OeoIIqr2k0XTtNeLSLuSK2Ekgmt9SgiwJE+q6PGpChxkZK4yMGoJOanW3uI1urcFY5Ru2H7J8RWfLH7OMZ8q7DV+xlvp7Je6bcvLpQI+kRiJ5Gtjj6xCsGMZ65B49apC00zSXiaV0u52yYm+kE2tyOoMUq4aKQccPnB69aqtybMKx0l7mFrmVu7t0ODJtLID+q5XJT3kVpTTWmnQrbw28ZYe0jMQJPfFcJjcPRhVa+125ub4yCWaGVMolwwCzgfqSlcCQeGSM/hWczd4uGBiDP7Ua8KknmB4A/wCuKngErySzzCdZQzzAgZABmx1RwOp9fGrOnW91qT29pYqHYd41oHHLEDLwE+ORkgev71VrKxkv5Y49pSO5nW3ZiMCCc/VJPgD+AbyFdHazfQrZrra0d5JGbgIDtMV7av7fwaMkn1Y+QoDZtYrLS9PCQyZjli7uJyfb+jzglM/vRTLWJdX8txEZ3bErTkvxydx3nA9Dn50zUNUS61C3cD/dVuJY+7I6o0plHwz4U2GNpx+c5HRxJOxKn7BJ44H4VWW5aO25a0lfpWuPG+0C+hkAyMZAIY9OmcVT0+R4dVmuJI2jbTbCSdVbqCygJ97qa19Ctfp2qPtmkjjttOnmSVo8YbI3YHu/GshRuTtTIsm4yW8MSZHLZkT5dKUSdj2SurTUu0HZKylgEj2dnIr7/Bh7SMPX2a9Zu9QtbFo1uJQjSZ2DxOBk1412MhUai12LaSe5hHdWYVyuGRSSTjrycYq72v1qS+7R2wimcy2cI71sGMxt1bH3VV2lsTXU0md9rOnQ9pLIXNk6fS4OBz9Yfqn+XkfjXEMjI7I6FHU4ZWGCD5Gum7Di5huWEoUrdQ98G3kkjIwSPiam7bWNvH3F6i7ZpH2Pjo4x1PqMf6xXkavAsuN5fNc/k9fQaqWPIsD3T4/ByBFNNPNNIrxkfTpkZFRkVMRTGFXRdMjfLdajK1KRQ21ZMsQFSDSAqVlphq9l0xYpr07NMY5oi1jKVOAycAZJp7wOihiOtWshyojU806mL9fFPC+VGWs5DtCP+Lv/AHF/nWZWp2hH/Fn/ALq1mYr6bT/xR9j8713+Vk92CkaVKtjkJaNKiBQAqa0/5yH/ALi/jUdS2o/3uH/uL+NVlwXh9S9zt1HNEBw3OGX7xRXinZAHNfJWfojHAcU7FMRwzYFSAVVlG7Btp69aOOKIFVFk8UZAErLuQHkCimCabG7L9U4zUqjNZMwdpsmQcVYAUgYXBHX1quinjFWUGKxkznnyECngUgKeBWbZi2MI9kn0rW7U6fs0uB4WaKWBNgdDhl461Tt41kuYIyeXlUY8xmt7tHNFFbKJfqv7PSvS0n6ME8n5R5uom3mhH3PA9Vh1LssZL/Srt4La/Bgu4om5Q9Sp8g3JUj1HhXQdnr2xn0RIIYQLeQZZEba6uvO3d4HPIPng1f1CytDcj6bEZYGzHNEPtofLyI6g+YFcxpkX+xvauSxuLndY6hbstnejhQW4jlwehU8N4jnyr6THLxofk4Jx8Gf4ZFrFtKJXvWiKyBsXYAwCTwsoHhu6MPBvfV7sz2nfSZFtrnc9ix6dTEfMenmP9F/aW9bSrixue9eS7mjaK9t7qQPvdcBt37jr/I1kXFnYrAb+2vHSxkz3SPGXaKQdYXIPB8m6Ec8YIraWKGfH0ZFscvU8eTqhsz1yJ0miWWF1kjcZV1OQRUgFea9lu0p0a6+j3Tk2Ep9rx7k/rD08x8ff6YMEBlIZWGQQcgivi9do56TJ0vh8M9zT6mOaP5BiiBTgKdjiuBs3bOA7R8doLvP7n+QVoaNobBIbi6jAeY5hjc49kYyfefD5+6prF5ZWvay7kuo2n7po9sS4wW2qefcPvxVrV+0+najcCaGV4o2i2lZVyEP8zX2mnhLwIOvJHkNpze52VxLDFcq0TnEY4GOQT0FcbqmodzI5JImYnDseCffWwlzHd2D3kMLMrRgf2g9nw6dea5q4tTNdSd9FsjhJ3lm9kn0rSO8qZeMaRVmutlhAJArsdxcpyWY9MfdXOy291ZQOINTYC+Km5ixncVORu8yCa3bq7i3rtVFVBhSp4A8ePP1qvdtLdIkUkwWDgFFGDt8fia6lsjGVSZQ0vTppIp7p0DS3R2qEGBsByTj1P4VfHZ0OpSSKZiQQHU+0oPkfEehqePVxAqpDGgRE/RDyx1WqR1a/uX2wzMUcjarHAHmuao+pvYhOKMjtRaW2ikWFsT3twBLPyMKOdqjy8Sfh5VgCRyAMk46VPfTm91Ca5YllZ/Z8eBwPuqPYZJAke5nc4VFXnNdKVLc5m7exbFkWgCtcB7hmXbCg3cHPUjoenHrUF1YTW+dwBI+uFO7Z78dK37PT7uwtkgknR3LFjAmSYyR445JIzwPmBmqF4d0S273EcQGWKtMWXJPgkYIX3HNVT3LyjsYmKWKmKDnbtb1Rv5Hmlb28lzMY41LEDPlVzEhxU9rKEYqxOD++VHxxyasfm2YH2kx4fHyqtPA0L7WGD5U2ZPBakhOVCLkPjaCmBn91ep95qMbUfMiNIgPtqHwW97fyoWt1tbu3BYMeSp2s/wC6W8BUsh705XaMHGY19lT+qo8T6/8A3UEunwOEALvGsyzEYIK5IlOOnI6LzTGkyrAkNzk7uhPm3n6D/RARo16kYOOOcHyHmafITIQ2zYc44HAP6qjz8zVipBImWzyW689T8PAVAefCrTZVcBcrknjkZ8ceZ9elNaNZOVYE/jQFQ9aeigsAaUkbRvhhigv1WPiOaAeVyQF5NKOMyPtA9T7qeVDSOUO39HketS2jpFFJu/tHACDHrQEy2i953aPlGYYY+A9R51obykQJiO1uMbtuB51RXlBJjkk5yetWVCGBiVZwy49xq6KMDXpe2CDKx7iAI12qvoPMkeJyaa8JMVurMVQDAHlVbbM5SBVJ2HJx0+NXHk/32JOSYxzkcZ91QKLhfubB1aTf7OBnwHhVV0kunM0SNt24QHyHiB6nJqG/lIgwerPnaOmB51uaYdLms0lutdVLmSaPvYVgOI4yQCwbwKjny4qGSjBEUoBYyhDnotX4FZUQzRb4zzkHnHgeeh9avaxZ2UE2La+t7jfKVZ4sEjHRhjwOf5VgXOoTWupRXEG1lg9kZG5H8wR4g9MVUk6Fcrcd4xRzIQA5A9nAyOPhVy2uH1Nfo6XNvdvHlmgkjDbRjGQVxxzTdP1bszKjBtOTc4EqKSW2eDrz5HJHoRS7Salp95aWq6Xp8VhqNmebhZBEZIznKkeJ5FCS7Y2U2k27Mb9pUVgUBTPdN6c+zVmyuOzAvI1vXlQOp7yUor7X9Mg+yfdkfHjhnup9uXLANzg+NQvdSMm3gL1OPGgOv1DtGSIhFMw7py21SAhx9XAHGB5Vk/7VX8JnEd45E5y3+vD4VzzM5OCTzSwfGlEm9L2r1Kf2PpEmxhl8Hgt5n3jHyrLurq4vAA5LYO5QecGoB+jUOSQoYFvUV0tjaWCxlj3kjxn2giZ4PTOPOlEXRn/7Q6p9Fiie9mFsUCgIdpAXHGRyccGqIyHubRnG2XJZSoI3r4jy8/iR0p8kYaLULeMZS2lEq5HIQnaf8y0blES0tdVLDdmMGPGe8IyGJ+WKpSXBZblUd5fTxpnMlwu1WP2nHGD6ngfKrdlYretAJX2x3yNFuP2JkHHz9n+I0ppoLT6XFbjP0O/WaBj128gj7loXV7m6njiASEai00aDw65/lUli1NfW40yZ1G57/T0MgHGy4jlADj12g/xGmanfNfaldXGfrSNIBjrIyqJD8dtPs9JP5te/uiqW0WV7snDSOeQo+7PpWfGBvCsepPPvH9aq2Ei5Zq1/qmnW6+1LPdIu1mxuJIHUDgfOuh7RW40YLJGyww3Il228WCVKNsyXxk5bPwrM7EJG/bzSe/IEVszTyFug2KWz8wKb2nuDK9vD7Td0GUux5b2skAeQLH308ifM6DsrJElhf6rPNKO506Rpl3EB0yBtB8CxwPiayNKMmpyX8qQrBNd3CALzsjB3SEDzKhVAHrTbKaT/AGJ1eZuB3cFhFz1LTGVj8AoFTafLLadkRIg3XOoXxNuvGDtwCfQeycmnkPM0rLVPzdoM08bjcEBBZQcK56j1zVPQY5tQuFmk2FrqTaVc8d2OSPeawZrlL2Tu4u9WzRsohPCZ5IPpnODXYaHHOslvbWi7ZCmDJtz3ZJ5Hy8RUN7FonpPYmY3S3soVVigZbaIA5wqjPX41a7Wx/Sez7TKP7GQP8M4/nTNCihtdMurSM47mdS4Q+GFJP3GtaeCK8gu7IsCHTkfq7hgfhmuVrrxvH90WhPw8yn9meYEUMVIyNGzRuPaQlT7xTa+X4Z9vGVq0NIpjLipcUGw3B61KZbqIdtAripioAqNpCsbxgDD4z6Yqxa35ELmoiKkNNIrRGqGU3HNSYoYq5ZCtyFuoixwA4JPpmtPXbcW98Il6Bc++sk8Guk7QLBcGO+gmV1ChGXxBrGbqcTlzScc0Ps7OZIw5NIuQcVLKBv8ASmTYkcFVxxitk+DsTOR7Qc6q390VmGtXX1K6s4P6q/hWYRX0+n/ij7H55rf8rJ7sYRSp1A1scpLijSo0AKntP+ch/wC4v41DU1r/AM5Cf/2L+NRLhl8f1L3O4AokZoinAV8gfoUhRoAM1IOtNFEdaqyg+kKVIdRUAkUVYjqAVYjFZyM5liOpkIbOPDrUaLxUygCuZnHJjgKlUcUxRUwHFZmEmTaXbd/rlm3hEWc/L/zWp2juI4ovb6Ac1X0JcakX/Vib8RS1xVmLKwyCuK9KMq0kY/eX+jzpPq1SvyRyF0UmdG2qCSQAfAedYt5olprltNp1zcBJMtJbXAHsQv4/4Tj2vLAPga25LEG6MxfcuAuwjIqpdpsaO5id45LckR7DgZPHI8RXtYX0U0RlSnaPP7LRrVtfGl9pLiSw7gsksgXcxbjauemD4NW9eaPc6R2dE+pfoUml7lrBl9p05O5D47Rzz0+Nbna3Q7fWOz7alEFjvLCJm3kYEkaAFkPoM5U+HTpiuNs549RLtqc15c3CW2bFnm3pHgZKsrZ9kjy6V60H1q0eRkXS6ZQn3W8phZxJgAq69JFPRh6Gun7G9sl0vbpmpufoLH9DMee4Pkf3fw91c/d7bnTBIkap3QLxgcbPFlH7p648COOprIDbwD4HwqmfBj1OPw8nAhKWKVx5PoMdAQQQRkEcgiqOu6oNF0O61AlN8UZ7sOcAueg+dcP+TvtTOt7D2eug00Uufoz55iIBJU+a8fCrf5S9QIurDStuUYGVj4E9F+XNfIw+GyjrY4J8c3+P/tj1JapSwua5OGj1CWW4d5XZpJQS7sckseST8aksrlI2Uz4eKcHC7se0Mgc/KsiQlGYZ9KlhmZ4xblVKqS4YjkZ6ivszytzq9J1aa1lW3lDLHjAZDlvd7qm1PU2utyLLuVTyZeQ3kMVz25YYIkGS7DdnwAppkaQomAcHjPnWXhq7OhZZdPSbs2paZYvDENM+mzyRhk7x2VGySDgDnqPjQubqZ7JFntLezlclV2DbkDk5P3U/StJim77WL4m5MLLEFJxljgDHkBx7vKoNaumbUDCpCqsIhYBeMZycD5etV2cqRLuMLZUij72LIYDJ9oE9PIijd3EaW08kgCusRXCDA3YwpHzqBJSmc88cVQ1B2MLAsSG5564HhV+ncxUtjKJOAvgPvrY0GZ43aOzilaeQHc8cYMkSjqVJ6fdWTjIFdn2SsWh7OXuqzSA2olVO4VeZWGMbz+qM5wOtTkdRsnErkRJp/wBDxbmRrh51EgJU5dT0GxTk9CccDxJ6VjXdzLEGSOWaMeKiRIh/Ctb97NLquoTjiSa4jEm12McYjAwA2z2m6Z25AHrXN6g0ULNAZF3rxhLOMD+LOaiHBebe5TdyR7Yznxdf/wDQq3orAaltYElkIU7un9apOvdgEgDd4qfxFK3k7m8jcqDtbkedaPgwXJtasWt3R1flhxg8f/R+/wB1Z10pmt1uRtHO0jgH5eVbOoRrNaAkAMFMnpgDr7/uPwrHhy8VzEWKqqbzgnHHp4nJHXpzxVIl5FEipre4MbbWYgY27xyUXxx61GOaDDIrQzNaJ4ZU3qdiImW289ymcADzdj4+vysC03Ps7kFwyxd0rdXb6sQP3sfhx44duxVidzDaCw2nxA4rVtrqZbiOwQgSOogifwQy43v7yPZ93uFVJ5J5LSBsNG4cODtYjAcL9aQj7MYwQB4kfAUpbUYZ13BQocsw5Cnox9T4CtXdBNGkoiIt7iST9ETyLe3UMI8/vHk+oBqBpX7hrqTDSJF9Lb96R22p8FBGB5++lk0Z7Qyle7ki7zDBducMG8vf5+VRLbwsMoZFJDYBAIwOpz5VpSW/d95EhGUkWzViOjNy7/Hke73VVuWxFNs9lXlFugH2UXk/M7T78+dLHSNgiFtNHMXDIiFm3xn6nAB+JOBUYi/3hFU5Lc7XbAQdQCfdV2eF7s3xhIVZbxYUDn6qqGIHyA+VNSyeHUZTIyyRxyOpQ8gkDrj41NkUV3nC+y8sIA8I+fwpC8QKAszkDnaiYA+dOEU5jQh40AHBVOah2qiqrzyEICoAUDAJyfxqbILMN5gLthkJJDZJCjOeDVqS8sheS3VwZZJJWLzRxgL3bljwCeoxWYjRAoP0zBcYBk4HPupsyATuc8OxOPLmgLy6jGl07CEkFHAU84BBo/ToyEMcO3MTAc/Z8R8ao5XvuBz3bfhQjfa1uf3WH40Bca8Z0jKoFWVyy/uDJ9kenNU553mEuTw8hcqOmfPHzoIxFvGvgjkj7qCgb8HoTUAbHI0DRyx/WikBH41pCC4mae5gjlmhibc8u0nAJ6say8kwuvmob5VZEk7IY4pNquqllPQnNCUWIu7QvHs3BXI5PgeRVgW0MikiTBx9ULVbUBJZatPazBDKoVHMf1dwHUUFlaQhQAfDk8VNitySREEP74bAqGUjeQDxRmLRkAhR5bagLZNVsv0j3cmFk8xV20vdVspWn0q5KPPEFlSIhzgDxH+sVmk03A8qiyGdV2gQ3oOtNJIBPaWseRhRI23D5HiMoflXPSmSeytbeMFj3kgCjnPI/rXSXdoh0PSbzIOLeGEq6bgBulYnrz/4rD0a4267poiBRBIsXXltxwxPvyfhUMLgsJoV1KJ7m6P0eNnyVxl2GfAeXvrQ0+2FjczNbtE8TgBppQC3mfdz5VoXvs24gXjcWYn3HFZkGnTahqc8MMiRKmwkEegziqXZYt6rf3Gp3kQuisndIwjSRdgYE4LAeLf0FYCRvIYR3ZPXjPUg8j0r1Psj2Nt720XUJ2QzT3YXlCVdEJOwjPs8rnI9OorzO7VFgWTvHaY3coYFQBjg5znzJ8KmgmaXYiQr2tS7aPfjKd2uPaLnaAPn8hTe2SyR9pprWUgtbqFYhduS2W6e4gfCrH5P7b6T2tsI920fSlZvUKC2PmBUfbqV5u3msvIqhhOFAXpgKAPjjrTyHmU2l7vsZcAscHUYto8MhHJ/l86M12Y7O0tUOfotuYF/deQ75SPcCF+NV5XWPSdMUruHf3Fyw/WPsIo+Gz76qd4zNljk8n4k5P3mnBJYRCjB4jslX6pHQ+hHlXd9gbotdncgjkjIR0Y8wk9CP3D93TyrjdHiN1qMEGQC7gAmus0+RN8urwL3awzNZRrnllH1mbzJYqQPDFQ+CT0TQbmK31fVry5mjjtrh0SFicCUoCGI9MnFPvNTk0fX7G4acLpOpIsYkKfVlH1FJ8AwP3VHEv06102aSGJYbcLIkSZ4BHT18Kv6rpL63ZGxu5UFvcDGAmShzuVgc8EVyudSSX9FlTd9zktVTZq94pGP0zH5nNU8Vo60hj1m6Rjkh+vnxVDHNfN5tskl+T67TyvFF/hAxxTGFTY4pjCqJnSmRE8VEwqVhTCKujRMiIppFSEUCKui5EaFPYUyrIumNIq3JN3tlGpGGVsE+Y8KrYo7iF2+FGkyJRTp/YJUs3TrUi2zAhsVYWIR28c3XeOnlUsftqSOMDNZuTMnl+xwHaYEa3ICMewtYzlhIoGceNbfak516X+4v4VkV9Xpv4Y+yPhNXvqJv8sbihinUK6DmP/Z"
                    />
                  </div>
                  <div class="card-content">
                    <span>Black Ops 3</span>
                    <a>
                      <div class="card-action hidden-action">Launch</div>
                    </a>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="_sponsors">
            <div class="container full full-row">
              <h2>Coming soon&trade;!</h2>
            </div>
          </div>
        </div>
      </div>
    </main>

    <script>
      function activateElement(name, elements) {
        for (var i = 0; i < elements.length; ++i) {
          var element = elements[i];
          var classList = element.classList;
          var show = false;

          for (var j = 0; j < classList.length; ++j) {
            if (classList[j] == "_" + name) {
              show = true;
              break;
            }
          }

          if (show) {
            classList.add("active");
          } else {
            classList.remove("active");
          }
        }
      }

      function showMenu(menu) {
        var menus = document.querySelectorAll("div.menus>div");
        var buttons = document.querySelectorAll("nav a.nav-link");

        activateElement(menu, menus);
        activateElement(menu, buttons);
      }

      window.onload = function () {
        showMenu("play");
      };
    </script>
  </body>
</html>

```

`src/client/std_include.cpp`:

```cpp
#include <std_include.hpp>

#pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language=''\"")

extern "C"
{
	int s_read_arc4random(void*, size_t)
	{
		return -1;
	}

	int s_read_getrandom(void*, size_t)
	{
		return -1;
	}

	int s_read_urandom(void*, size_t)
	{
		return -1;
	}

	int s_read_ltm_rng(void*, size_t)
	{
		return -1;
	}
}

```

`src/client/std_include.hpp`:

```hpp
#pragma once

#define BINARY_PAYLOAD_SIZE 0x14000000

// Decide whether to load the game as lib or to inject it
#define INJECT_HOST_AS_LIB

#pragma warning(push)
#pragma warning(disable: 4100)
#pragma warning(disable: 4127)
#pragma warning(disable: 4244)
#pragma warning(disable: 4458)
#pragma warning(disable: 4702)
#pragma warning(disable: 4996)
#pragma warning(disable: 5054)
#pragma warning(disable: 5056)
#pragma warning(disable: 6011)
#pragma warning(disable: 6297)
#pragma warning(disable: 6385)
#pragma warning(disable: 6386)
#pragma warning(disable: 6387)
#pragma warning(disable: 26110)
#pragma warning(disable: 26451)
#pragma warning(disable: 26444)
#pragma warning(disable: 26451)
#pragma warning(disable: 26489)
#pragma warning(disable: 26495)
#pragma warning(disable: 26498)
#pragma warning(disable: 26812)
#pragma warning(disable: 28020)

#define WIN32_LEAN_AND_MEAN

#include <Windows.h>
#include <MsHTML.h>
#include <MsHtmHst.h>
#include <ExDisp.h>
#include <WinSock2.h>
#include <WS2tcpip.h>
#include <corecrt_io.h>
#include <fcntl.h>
#include <shellapi.h>
#include <csetjmp>
#include <ShlObj.h>
#include <winternl.h>
#include <VersionHelpers.h>
#include <Psapi.h>
#include <urlmon.h>
#include <atlbase.h>
#include <atlsafe.h>
#include <iphlpapi.h>
#include <wincrypt.h>
#include <shellscalingapi.h>

// min and max is required by gdi, therefore NOMINMAX won't work
#ifdef max
#undef max
#endif

#ifdef min
#undef min
#endif

#include <map>
#include <atomic>
#include <vector>
#include <mutex>
#include <queue>
#include <regex>
#include <chrono>
#include <thread>
#include <fstream>
#include <iostream>
#include <utility>
#include <filesystem>
#include <functional>
#include <random>
#include <sstream>
#include <optional>
#include <unordered_set>
#include <variant>
#include <cassert>

#include <udis86.h>
#include <MinHook.h>
#include <asmjit/core/jitruntime.h>
#include <asmjit/x86/x86assembler.h>

#define RAPIDJSON_NOEXCEPT
#define RAPIDJSON_ASSERT(cond) if (cond); else throw std::runtime_error("rapidjson assert fail");

#include <rapidjson/document.h>
#include <rapidjson/prettywriter.h>
#include <rapidjson/stringbuffer.h>

#pragma warning(pop)
#pragma warning(disable: 4100)

#pragma comment(lib, "ntdll.lib")
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "urlmon.lib" )
#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "Crypt32.lib")

using namespace std::literals;

```

`src/client/steam/interface.cpp`:

```cpp
#include <std_include.hpp>
#include "interface.hpp"

#include <utils/memory.hpp>
#include <utils/nt.hpp>

namespace steam
{
	interface::interface() : interface(nullptr)
	{
	}

	interface::interface(void* interface_ptr) : interface_ptr_(static_cast<void***>(interface_ptr))
	{
	}

	interface::operator bool() const
	{
		return this->interface_ptr_ != nullptr;
	}

	void* interface::find_method(const std::string& name)
	{
		const auto method_entry = this->methods_.find(name);
		if (method_entry != this->methods_.end())
		{
			return method_entry->second;
		}

		return this->search_method(name);
	}

	void* interface::search_method(const std::string& name)
	{
		if (!utils::memory::is_bad_read_ptr(this->interface_ptr_))
		{
			auto vftbl = *this->interface_ptr_;

			while (!utils::memory::is_bad_read_ptr(vftbl) && !utils::memory::is_bad_code_ptr(*vftbl))
			{
				const auto ptr = *vftbl;
				const auto result = this->analyze_method(ptr);
				if (!result.empty())
				{
					this->methods_[result] = ptr;

					if (result == name)
					{
						return ptr;
					}
				}

				++vftbl;
			}
		}

		return {};
	}

	std::string interface::analyze_method(const void* method_ptr)
	{
		if (utils::memory::is_bad_code_ptr(method_ptr)) return {};

		ud_t ud;
		ud_init(&ud);
		ud_set_mode(&ud, 64);
		ud_set_pc(&ud, uint64_t(method_ptr));
		ud_set_input_buffer(&ud, static_cast<const uint8_t*>(method_ptr), INT32_MAX);

		while (true)
		{
			ud_disassemble(&ud);

			if (ud_insn_mnemonic(&ud) == UD_Iret)
			{
				break;
			}

			if (ud_insn_mnemonic(&ud) == UD_Ilea)
			{
				const auto* operand = ud_insn_opr(&ud, 1);
				if (operand && operand->type == UD_OP_MEM && operand->base == UD_R_RIP)
				{
					auto* operand_ptr = reinterpret_cast<char*>(ud_insn_len(&ud) + ud_insn_off(&ud) + operand->lval.
						sdword);
					if (!utils::memory::is_bad_read_ptr(operand_ptr) && utils::memory::is_rdata_ptr(operand_ptr))
					{
						return operand_ptr;
					}
				}
			}

			if (*reinterpret_cast<unsigned char*>(ud.pc) == 0xCC) break; // int 3
		}

		return {};
	}
}

```

`src/client/steam/interface.hpp`:

```hpp
#pragma once

#ifdef interface
#undef interface
#endif

namespace steam
{
	struct raw_steam_id final
	{
		unsigned int account_id : 32;
		unsigned int account_instance : 20;
		unsigned int account_type : 4;
		int universe : 8;
	};

	typedef union
	{
		raw_steam_id raw;
		unsigned long long bits;
	} steam_id;

#pragma pack( push, 1 )
	struct raw_game_id final
	{
		unsigned int app_id : 24;
		unsigned int type : 8;
		unsigned int mod_id : 32;
	};

	typedef union
	{
		raw_game_id raw;
		unsigned long long bits;
	} game_id;
#pragma pack( pop )

	class interface final
	{
	public:

		interface();
		interface(void* interface_ptr);

		operator bool() const;

		template <typename T, typename... Args>
		T invoke(const std::string& method_name, Args ... args)
		{
			if (!this->interface_ptr_)
			{
				throw std::runtime_error("Invalid interface pointer");
			}

			const auto method = this->find_method(method_name);
			if (!method)
			{
				throw std::runtime_error("Unable to find method: " + method_name);
			}

			return static_cast<T(__thiscall*)(void*, Args ...)>(method)(this->interface_ptr_, args...);
		}

		template <typename T, typename... Args>
		T invoke(const size_t table_entry, Args ... args)
		{
			if (!this->interface_ptr_)
			{
				throw std::runtime_error("Invalid interface pointer");
			}

			return static_cast<T(__thiscall*)(void*, Args ...)>((*this->interface_ptr_)[table_entry])(
				this->interface_ptr_, args...);
		}

	private:
		void*** interface_ptr_;
		std::unordered_map<std::string, void*> methods_;

		void* find_method(const std::string& name);
		void* search_method(const std::string& name);

		std::string analyze_method(const void* method_ptr);
	};
}

```

`src/client/steam/interfaces/apps.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

namespace steam
{
	bool apps::BIsSubscribed()
	{
		return true;
	}

	bool apps::BIsLowViolence()
	{
		return false;
	}

	bool apps::BIsCybercafe()
	{
		return false;
	}

	bool apps::BIsVACBanned()
	{
		return false;
	}

	const char* apps::GetCurrentGameLanguage()
	{
		return "english";
	}

	const char* apps::GetAvailableGameLanguages()
	{
		return "english";
	}

	bool apps::BIsSubscribedApp(unsigned int appID)
	{
		return true;
	}

	bool apps::BIsDlcInstalled(unsigned int appID)
	{
		return true;
	}

	unsigned int apps::GetEarliestPurchaseUnixTime(unsigned int nAppID)
	{
		return 0;
	}

	bool apps::BIsSubscribedFromFreeWeekend()
	{
		return false;
	}

	int apps::GetDLCCount()
	{
		return 0;
	}

	bool apps::BGetDLCDataByIndex(int iDLC, unsigned int* pAppID, bool* pbAvailable, char* pchName,
	                              int cchNameBufferSize)
	{
		return false;
	}

	void apps::InstallDLC(unsigned int nAppID)
	{
	}

	void apps::UninstallDLC(unsigned int nAppID)
	{
	}

	void apps::RequestAppProofOfPurchaseKey(unsigned int nAppID)
	{
	}

	bool apps::GetCurrentBetaName(char* pchName, int cchNameBufferSize)
	{
		strncpy_s(pchName, cchNameBufferSize, "public", cchNameBufferSize);
		return true;
	}

	bool apps::MarkContentCorrupt(bool bMissingFilesOnly)
	{
		return false;
	}

	unsigned int apps::GetInstalledDepots(int* pvecDepots, unsigned int cMaxDepots)
	{
		return 0;
	}

	unsigned int apps::GetAppInstallDir(unsigned int appID, char* pchFolder, unsigned int cchFolderBufferSize)
	{
		return 0;
	}

	bool apps::BIsAppInstalled(unsigned int appID)
	{
		return false;
	}

	steam_id apps::GetAppOwner()
	{
		return SteamUser()->GetSteamID();
	}

	const char* apps::GetLaunchQueryParam(const char* pchKey)
	{
		return "";
	}

	bool apps::GetDlcDownloadProgress(uint32_t nAppID, uint64_t* punBytesDownloaded, uint64_t* punBytesTotal)
	{
		*punBytesTotal = 0;
		*punBytesDownloaded = 0;
		return false;
	}

	int apps::GetAppBuildId()
	{
		return 0;
	}

	void apps::RequestAllProofOfPurchaseKeys()
	{
	}

	uint64_t apps::GetFileDetails(const char* pszFileName)
	{
		return 0;
	}

	int apps::GetLaunchCommandLine(char* pszCommandLine, int cubCommandLine)
	{
		return 0;
	}

	bool apps::BIsSubscribedFromFamilySharing()
	{
		return false;
	}
}

```

`src/client/steam/interfaces/apps.hpp`:

```hpp
#pragma once

namespace steam
{
	class apps
	{
	public:
		~apps() = default;

		virtual bool BIsSubscribed();
		virtual bool BIsLowViolence();
		virtual bool BIsCybercafe();
		virtual bool BIsVACBanned();
		virtual const char* GetCurrentGameLanguage();
		virtual const char* GetAvailableGameLanguages();
		virtual bool BIsSubscribedApp(unsigned int appID);
		virtual bool BIsDlcInstalled(unsigned int appID);
		virtual unsigned int GetEarliestPurchaseUnixTime(unsigned int nAppID);
		virtual bool BIsSubscribedFromFreeWeekend();
		virtual int GetDLCCount();
		virtual bool BGetDLCDataByIndex(int iDLC, unsigned int* pAppID, bool* pbAvailable, char* pchName,
		                                int cchNameBufferSize);
		virtual void InstallDLC(unsigned int nAppID);
		virtual void UninstallDLC(unsigned int nAppID);
		virtual void RequestAppProofOfPurchaseKey(unsigned int nAppID);
		virtual bool GetCurrentBetaName(char* pchName, int cchNameBufferSize);
		virtual bool MarkContentCorrupt(bool bMissingFilesOnly);
		virtual unsigned int GetInstalledDepots(int* pvecDepots, unsigned int cMaxDepots);
		virtual unsigned int GetAppInstallDir(unsigned int appID, char* pchFolder, unsigned int cchFolderBufferSize);
		virtual bool BIsAppInstalled(unsigned int appID);

		virtual steam_id GetAppOwner();
		virtual const char* GetLaunchQueryParam(const char* pchKey);
		virtual bool GetDlcDownloadProgress(uint32_t nAppID, uint64_t* punBytesDownloaded, uint64_t* punBytesTotal);
		virtual int GetAppBuildId();
		virtual void RequestAllProofOfPurchaseKeys();
		virtual uint64_t GetFileDetails(const char* pszFileName);
		virtual int GetLaunchCommandLine(char* pszCommandLine, int cubCommandLine);
		virtual bool BIsSubscribedFromFamilySharing();
	};
}

```

`src/client/steam/interfaces/client.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

namespace steam
{
	namespace
	{
		void* get_dummy()
		{
			static class blub
			{
			public:
				virtual uint64_t m0() { return 0; }
				virtual uint64_t m1() { return 0; }
				virtual uint64_t m2() { return 0; }
				virtual uint64_t m3() { return 0; }
				virtual uint64_t m4() { return 0; }
				virtual uint64_t m5() { return 0; }
				virtual uint64_t m6() { return 0; }
				virtual uint64_t m7() { return 0; }
				virtual uint64_t m8() { return 0; }
				virtual uint64_t m9() { return 0; }

				virtual uint64_t m10() { return 0; }
				virtual uint64_t m11() { return 0; }
				virtual uint64_t m12() { return 0; }
				virtual uint64_t m13() { return 0; }
				virtual uint64_t m14() { return 0; }
				virtual uint64_t m15() { return 0; }
				virtual uint64_t m16() { return 0; }
				virtual uint64_t m17() { return 0; }
				virtual uint64_t m18() { return 0; }
				virtual uint64_t m19() { return 0; }

				virtual uint64_t m20() { return 0; }
				virtual uint64_t m21() { return 0; }
				virtual uint64_t m22() { return 0; }
				virtual uint64_t m23() { return 0; }
				virtual uint64_t m24() { return 0; }
				virtual uint64_t m25() { return 0; }
				virtual uint64_t m26() { return 0; }
				virtual uint64_t m27() { return 0; }
				virtual uint64_t m28() { return 0; }
				virtual uint64_t m29() { return 0; }

				virtual uint64_t m30() { return 0; }
				virtual uint64_t m31() { return 0; }
				virtual uint64_t m32() { return 0; }
				virtual uint64_t m33() { return 0; }
				virtual uint64_t m34() { return 0; }
				virtual uint64_t m35() { return 0; }
				virtual uint64_t m36() { return 0; }
				virtual uint64_t m37() { return 0; }
				virtual uint64_t m38() { return 0; }
				virtual uint64_t m39() { return 0; }

				virtual uint64_t m40() { return 0; }
				virtual uint64_t m41() { return 0; }
				virtual uint64_t m42() { return 0; }
				virtual uint64_t m43() { return 0; }
				virtual uint64_t m44() { return 0; }
				virtual uint64_t m45() { return 0; }
				virtual uint64_t m46() { return 0; }
				virtual uint64_t m47() { return 0; }
				virtual uint64_t m48() { return 0; }
				virtual uint64_t m49() { return 0; }

				virtual uint64_t m50() { return 0; }
				virtual uint64_t m51() { return 0; }
				virtual uint64_t m52() { return 0; }
				virtual uint64_t m53() { return 0; }
				virtual uint64_t m54() { return 0; }
				virtual uint64_t m55() { return 0; }
				virtual uint64_t m56() { return 0; }
				virtual uint64_t m57() { return 0; }
				virtual uint64_t m58() { return 0; }
				virtual uint64_t m59() { return 0; }

				virtual uint64_t m60() { return 0; }
				virtual uint64_t m61() { return 0; }
				virtual uint64_t m62() { return 0; }
				virtual uint64_t m63() { return 0; }
				virtual uint64_t m64() { return 0; }
				virtual uint64_t m65() { return 0; }
				virtual uint64_t m66() { return 0; }
				virtual uint64_t m67() { return 0; }
				virtual uint64_t m68() { return 0; }
				virtual uint64_t m69() { return 0; }
			} x;
			return &x;
		}
	}

	HSteamPipe client::CreateSteamPipe()
	{
		return 1;
	}

	bool client::BReleaseSteamPipe(HSteamPipe hSteamPipe)
	{
		return true;
	}

	HSteamUser client::ConnectToGlobalUser(HSteamPipe hSteamPipe)
	{
		return 1;
	}

	HSteamUser client::CreateLocalUser(HSteamPipe* phSteamPipe, uint32_t eAccountType)
	{
		return 1;
	}

	void client::ReleaseUser(HSteamPipe hSteamPipe, HSteamUser hUser)
	{
	}

	void* client::GetISteamUser(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return SteamUser();
	}

	void* client::GetISteamGameServer(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return SteamGameServer();
	}

	void client::SetLocalIPBinding(uint32_t unIP, uint16_t usPort)
	{
	}

	void* client::GetISteamFriends(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return SteamFriends();
	}

	void* client::GetISteamUtils(HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return SteamUtils();
	}

	void* client::GetISteamMatchmaking(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return SteamMatchmaking();
	}

	void* client::GetISteamMatchmakingServers(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		static matchmaking_servers u;
		return &u;
	}

	void* client::GetISteamGenericInterface(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return nullptr;
	}

	void* client::GetISteamUserStats(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return SteamUserStats();
	}

	void* client::GetISteamGameServerStats(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		static game_server_stats u;
		return &u;
	}

	void* client::GetISteamApps(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return SteamApps();
	}

	void* client::GetISteamNetworking(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return SteamNetworking();
	}

	void* client::GetISteamRemoteStorage(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return SteamRemoteStorage();
	}

	void* client::GetISteamScreenshots(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		static screenshots s;
		return &s;
	}

	void client::RunFrame()
	{
	}

	uint32_t client::GetIPCCallCount()
	{
		return 0;
	}

	void client::SetWarningMessageHook(void* pFunction)
	{
	}

	bool client::BShutdownIfAllPipesClosed()
	{
		return true;
	}

	void* client::GetISteamHTTP(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		static http h;
		return &h;
	}

	void* client::GetISteamUnifiedMessages(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		static unified_messages u;
		return &u;
	}

	void* client::GetISteamController(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		static controller c;
		return &c;
	}

	void* client::GetISteamUGC(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		static ugc u;
		return &u;
	}

	void* client::GetISteamAppList(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return get_dummy();
	}

	void* client::GetISteamMusic(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return get_dummy();
	}

	void* client::GetISteamMusicRemote(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return get_dummy();
	}

	void* client::GetISteamHTMLSurface(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return get_dummy();
	}

	void client::Set_SteamAPI_CPostAPIResultInProcess(void* func)
	{
	}

	void client::Remove_SteamAPI_CPostAPIResultInProcess(void* func)
	{
	}

	void client::Set_SteamAPI_CCheckCallbackRegisteredInProcess(void* func)
	{
	}

	void* client::GetISteamInventory(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return get_dummy();
	}

	void* client::GetISteamVideo(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return get_dummy();
	}

	void* client::GetISteamParentalSettings(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		return get_dummy();
	}
}

```

`src/client/steam/interfaces/client.hpp`:

```hpp
#pragma once
#include <cstdint>

namespace steam
{
	using HSteamPipe = uint64_t;
	using HSteamUser = uint64_t;

	class client
	{
	public:
		~client() = default;

		virtual HSteamPipe CreateSteamPipe();
		virtual bool BReleaseSteamPipe(HSteamPipe hSteamPipe);
		virtual HSteamUser ConnectToGlobalUser(HSteamPipe hSteamPipe);
		virtual HSteamUser CreateLocalUser(HSteamPipe* phSteamPipe, uint32_t eAccountType);
		virtual void ReleaseUser(HSteamPipe hSteamPipe, HSteamUser hUser);
		virtual void* GetISteamUser(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamGameServer(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void SetLocalIPBinding(uint32_t unIP, uint16_t usPort);
		virtual void* GetISteamFriends(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamUtils(HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamMatchmaking(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamMatchmakingServers(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamGenericInterface(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamUserStats(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamGameServerStats(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamApps(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamNetworking(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamRemoteStorage(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamScreenshots(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void RunFrame();
		virtual uint32_t GetIPCCallCount();
		virtual void SetWarningMessageHook(void* pFunction);
		virtual bool BShutdownIfAllPipesClosed();
		virtual void* GetISteamHTTP(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamUnifiedMessages(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamController(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamUGC(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamAppList(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamMusic(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamMusicRemote(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamHTMLSurface(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void Set_SteamAPI_CPostAPIResultInProcess(void* func);
		virtual void Remove_SteamAPI_CPostAPIResultInProcess(void* func);
		virtual void Set_SteamAPI_CCheckCallbackRegisteredInProcess(void* func);
		virtual void* GetISteamInventory(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamVideo(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion);
		virtual void* GetISteamParentalSettings(HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char* pchVersion);
	};
}

```

`src/client/steam/interfaces/controller.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

namespace steam
{
	bool controller::Init()
	{
		return true;
	}

	bool controller::Shutdown()
	{
		return true;
	}

	void controller::RunFrame()
	{
	}

	int controller::GetConnectedControllers(ControllerHandle_t* handlesOut)
	{
		return 0;
	}

	bool controller::ShowBindingPanel(ControllerHandle_t controllerHandle)
	{
		return false;
	}

	uint64_t controller::GetActionSetHandle(const char* pszActionSetName)
	{
		return 0;
	}

	void controller::ActivateActionSet(ControllerHandle_t controllerHandle, uint64_t actionSetHandle)
	{
	}

	uint64_t controller::GetCurrentActionSet(ControllerHandle_t controllerHandle)
	{
		return 0;
	}

	uint64_t controller::GetDigitalActionHandle(const char* pszActionName)
	{
		return 0;
	}

	uint64_t controller::GetDigitalActionData(ControllerHandle_t controllerHandle, uint64_t digitalActionHandle)
	{
		return 0;
	}

	int controller::GetDigitalActionOrigins(ControllerHandle_t controllerHandle, uint64_t actionSetHandle,
	                                        uint64_t digitalActionHandle, uint64_t* originsOut)
	{
		return 0;
	}

	uint64_t controller::GetAnalogActionHandle(const char* pszActionName)
	{
		return 0;
	}

	uint64_t controller::GetAnalogActionData(ControllerHandle_t controllerHandle, uint64_t analogActionHandle)
	{
		return 0;
	}

	int controller::GetAnalogActionOrigins(ControllerHandle_t controllerHandle, uint64_t actionSetHandle,
	                                       uint64_t analogActionHandle, uint64_t* originsOut)
	{
		return 0;
	}

	void controller::StopAnalogActionMomentum(ControllerHandle_t controllerHandle, uint64_t eAction)
	{
	}

	void controller::TriggerHapticPulse(ControllerHandle_t controllerHandle, uint64_t eTargetPad,
	                                    unsigned short usDurationMicroSec)
	{
	}
}

```

`src/client/steam/interfaces/controller.hpp`:

```hpp
#pragma once

namespace steam
{
	using ControllerHandle_t = uint64_t;

	class controller
	{
	public:
		~controller() = default;

		virtual bool Init();
		virtual bool Shutdown();
		virtual void RunFrame();
		virtual int GetConnectedControllers(ControllerHandle_t* handlesOut);
		virtual bool ShowBindingPanel(ControllerHandle_t controllerHandle);
		virtual uint64_t GetActionSetHandle(const char* pszActionSetName);
		virtual void ActivateActionSet(ControllerHandle_t controllerHandle, uint64_t actionSetHandle);
		virtual uint64_t GetCurrentActionSet(ControllerHandle_t controllerHandle);
		virtual uint64_t GetDigitalActionHandle(const char* pszActionName);
		virtual uint64_t GetDigitalActionData(ControllerHandle_t controllerHandle, uint64_t digitalActionHandle);
		virtual int GetDigitalActionOrigins(ControllerHandle_t controllerHandle, uint64_t actionSetHandle,
		                                    uint64_t digitalActionHandle, uint64_t* originsOut);
		virtual uint64_t GetAnalogActionHandle(const char* pszActionName);
		virtual uint64_t GetAnalogActionData(ControllerHandle_t controllerHandle, uint64_t analogActionHandle);
		virtual int GetAnalogActionOrigins(ControllerHandle_t controllerHandle, uint64_t actionSetHandle,
		                                   uint64_t analogActionHandle, uint64_t* originsOut);
		virtual void StopAnalogActionMomentum(ControllerHandle_t controllerHandle, uint64_t eAction);
		virtual void TriggerHapticPulse(ControllerHandle_t controllerHandle, uint64_t eTargetPad,
		                                unsigned short usDurationMicroSec);
	};
}

```

`src/client/steam/interfaces/friends.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

#include <utils/nt.hpp>

#include "component/steam_proxy.hpp"

namespace steam
{
	const char* friends::GetPersonaName()
	{
		return steam_proxy::get_player_name();
	}

	unsigned long long friends::SetPersonaName(const char* pchPersonaName)
	{
		return 0;
	}

	int friends::GetPersonaState()
	{
		return 1;
	}

	int friends::GetFriendCount(int eFriendFlags)
	{
		return 0;
	}

	steam_id friends::GetFriendByIndex(int iFriend, int iFriendFlags)
	{
		return steam_id();
	}

	int friends::GetFriendRelationship(steam_id steamIDFriend)
	{
		return 0;
	}

	int friends::GetFriendPersonaState(steam_id steamIDFriend)
	{
		return 0;
	}

	const char* friends::GetFriendPersonaName(steam_id steamIDFriend)
	{
		return "";
	}

	bool friends::GetFriendGamePlayed(steam_id steamIDFriend, void* pFriendGameInfo)
	{
		return false;
	}

	const char* friends::GetFriendPersonaNameHistory(steam_id steamIDFriend, int iPersonaName)
	{
		return "";
	}

	bool friends::HasFriend(steam_id steamIDFriend, int eFriendFlags)
	{
		return false;
	}

	int friends::GetClanCount()
	{
		return 0;
	}

	steam_id friends::GetClanByIndex(int iClan)
	{
		return steam_id();
	}

	const char* friends::GetClanName(steam_id steamIDClan)
	{
		return "3arc";
	}

	const char* friends::GetClanTag(steam_id steamIDClan)
	{
		return this->GetClanName(steamIDClan);
	}

	bool friends::GetClanActivityCounts(steam_id steamID, int* pnOnline, int* pnInGame, int* pnChatting)
	{
		return false;
	}

	unsigned long long friends::DownloadClanActivityCounts(steam_id groupIDs[], int nIds)
	{
		return 0;
	}

	int friends::GetFriendCountFromSource(steam_id steamIDSource)
	{
		return 0;
	}

	steam_id friends::GetFriendFromSourceByIndex(steam_id steamIDSource, int iFriend)
	{
		return steam_id();
	}

	bool friends::IsUserInSource(steam_id steamIDUser, steam_id steamIDSource)
	{
		return false;
	}

	void friends::SetInGameVoiceSpeaking(steam_id steamIDUser, bool bSpeaking)
	{
	}

	void friends::ActivateGameOverlay(const char* pchDialog)
	{
	}

	void friends::ActivateGameOverlayToUser(const char* pchDialog, steam_id steamID)
	{
	}

	void friends::ActivateGameOverlayToWebPage(const char* pchURL)
	{
	}

	void friends::ActivateGameOverlayToStore(unsigned int nAppID, unsigned int eFlag)
	{
	}

	void friends::SetPlayedWith(steam_id steamIDUserPlayedWith)
	{
	}

	void friends::ActivateGameOverlayInviteDialog(steam_id steamIDLobby)
	{
	}

	int friends::GetSmallFriendAvatar(steam_id steamIDFriend)
	{
		return 0;
	}

	int friends::GetMediumFriendAvatar(steam_id steamIDFriend)
	{
		return 0;
	}

	int friends::GetLargeFriendAvatar(steam_id steamIDFriend)
	{
		return 0;
	}

	bool friends::RequestUserInformation(steam_id steamIDUser, bool bRequireNameOnly)
	{
		return false;
	}

	unsigned long long friends::RequestClanOfficerList(steam_id steamIDClan)
	{
		return 0;
	}

	steam_id friends::GetClanOwner(steam_id steamIDClan)
	{
		return steam_id();
	}

	int friends::GetClanOfficerCount(steam_id steamIDClan)
	{
		return 0;
	}

	steam_id friends::GetClanOfficerByIndex(steam_id steamIDClan, int iOfficer)
	{
		return steam_id();
	}

	int friends::GetUserRestrictions()
	{
		return 0;
	}

	bool friends::SetRichPresence(const char* pchKey, const char* pchValue)
	{
		return true;
	}

	void friends::ClearRichPresence()
	{
	}

	const char* friends::GetFriendRichPresence(steam_id steamIDFriend, const char* pchKey)
	{
		return "";
	}

	int friends::GetFriendRichPresenceKeyCount(steam_id steamIDFriend)
	{
		return 0;
	}

	const char* friends::GetFriendRichPresenceKeyByIndex(steam_id steamIDFriend, int iKey)
	{
		return "a";
	}

	void friends::RequestFriendRichPresence(steam_id steamIDFriend)
	{
	}

	bool friends::InviteUserToGame(steam_id steamIDFriend, const char* pchConnectString)
	{
		return false;
	}

	int friends::GetCoplayFriendCount()
	{
		return 0;
	}

	steam_id friends::GetCoplayFriend(int iCoplayFriend)
	{
		return steam_id();
	}

	int friends::GetFriendCoplayTime(steam_id steamIDFriend)
	{
		return 0;
	}

	unsigned int friends::GetFriendCoplayGame(steam_id steamIDFriend)
	{
		return 0;
	}

	unsigned long long friends::JoinClanChatRoom(steam_id steamIDClan)
	{
		return 0;
	}

	bool friends::LeaveClanChatRoom(steam_id steamIDClan)
	{
		return false;
	}

	int friends::GetClanChatMemberCount(steam_id steamIDClan)
	{
		return 0;
	}

	steam_id friends::GetChatMemberByIndex(steam_id steamIDClan, int iUser)
	{
		return steam_id();
	}

	bool friends::SendClanChatMessage(steam_id steamIDClanChat, const char* pchText)
	{
		return false;
	}

	int friends::GetClanChatMessage(steam_id steamIDClanChat, int iMessage, void* prgchText, int cchTextMax,
	                                unsigned int* peChatEntryType, steam_id* pSteamIDChatter)
	{
		return 0;
	}

	bool friends::IsClanChatAdmin(steam_id steamIDClanChat, steam_id steamIDUser)
	{
		return false;
	}

	bool friends::IsClanChatWindowOpenInSteam(steam_id steamIDClanChat)
	{
		return false;
	}

	bool friends::OpenClanChatWindowInSteam(steam_id steamIDClanChat)
	{
		return false;
	}

	bool friends::CloseClanChatWindowInSteam(steam_id steamIDClanChat)
	{
		return false;
	}

	bool friends::SetListenForFriendsMessages(bool bInterceptEnabled)
	{
		return false;
	}

	bool friends::ReplyToFriendMessage(steam_id steamIDFriend, const char* pchMsgToSend)
	{
		return false;
	}

	int friends::GetFriendMessage(steam_id steamIDFriend, int iMessageID, void* pvData, int cubData,
	                              unsigned int* peChatEntryType)
	{
		return 0;
	}

	unsigned long long friends::GetFollowerCount(steam_id steamID)
	{
		return 0;
	}

	unsigned long long friends::IsFollowing(steam_id steamID)
	{
		return 0;
	}

	unsigned long long friends::EnumerateFollowingList(unsigned int unStartIndex)
	{
		return 0;
	}
}

```

`src/client/steam/interfaces/friends.hpp`:

```hpp
#pragma once

namespace steam
{
	class friends
	{
	public:
		~friends() = default;

		virtual const char* GetPersonaName();
		virtual unsigned long long SetPersonaName(const char* pchPersonaName);
		virtual int GetPersonaState();
		virtual int GetFriendCount(int eFriendFlags);
		virtual steam_id GetFriendByIndex(int iFriend, int iFriendFlags);
		virtual int GetFriendRelationship(steam_id steamIDFriend);
		virtual int GetFriendPersonaState(steam_id steamIDFriend);
		virtual const char* GetFriendPersonaName(steam_id steamIDFriend);
		virtual bool GetFriendGamePlayed(steam_id steamIDFriend, void* pFriendGameInfo);
		virtual const char* GetFriendPersonaNameHistory(steam_id steamIDFriend, int iPersonaName);
		virtual bool HasFriend(steam_id steamIDFriend, int eFriendFlags);
		virtual int GetClanCount();
		virtual steam_id GetClanByIndex(int iClan);
		virtual const char* GetClanName(steam_id steamIDClan);
		virtual const char* GetClanTag(steam_id steamIDClan);
		virtual bool GetClanActivityCounts(steam_id steamID, int* pnOnline, int* pnInGame, int* pnChatting);
		virtual unsigned long long DownloadClanActivityCounts(steam_id groupIDs[], int nIds);
		virtual int GetFriendCountFromSource(steam_id steamIDSource);
		virtual steam_id GetFriendFromSourceByIndex(steam_id steamIDSource, int iFriend);
		virtual bool IsUserInSource(steam_id steamIDUser, steam_id steamIDSource);
		virtual void SetInGameVoiceSpeaking(steam_id steamIDUser, bool bSpeaking);
		virtual void ActivateGameOverlay(const char* pchDialog);
		virtual void ActivateGameOverlayToUser(const char* pchDialog, steam_id steamID);
		virtual void ActivateGameOverlayToWebPage(const char* pchURL);
		virtual void ActivateGameOverlayToStore(unsigned int nAppID, unsigned int eFlag);
		virtual void SetPlayedWith(steam_id steamIDUserPlayedWith);
		virtual void ActivateGameOverlayInviteDialog(steam_id steamIDLobby);
		virtual int GetSmallFriendAvatar(steam_id steamIDFriend);
		virtual int GetMediumFriendAvatar(steam_id steamIDFriend);
		virtual int GetLargeFriendAvatar(steam_id steamIDFriend);
		virtual bool RequestUserInformation(steam_id steamIDUser, bool bRequireNameOnly);
		virtual unsigned long long RequestClanOfficerList(steam_id steamIDClan);
		virtual steam_id GetClanOwner(steam_id steamIDClan);
		virtual int GetClanOfficerCount(steam_id steamIDClan);
		virtual steam_id GetClanOfficerByIndex(steam_id steamIDClan, int iOfficer);
		virtual int GetUserRestrictions();
		virtual bool SetRichPresence(const char* pchKey, const char* pchValue);
		virtual void ClearRichPresence();
		virtual const char* GetFriendRichPresence(steam_id steamIDFriend, const char* pchKey);
		virtual int GetFriendRichPresenceKeyCount(steam_id steamIDFriend);
		virtual const char* GetFriendRichPresenceKeyByIndex(steam_id steamIDFriend, int iKey);
		virtual void RequestFriendRichPresence(steam_id steamIDFriend);
		virtual bool InviteUserToGame(steam_id steamIDFriend, const char* pchConnectString);
		virtual int GetCoplayFriendCount();
		virtual steam_id GetCoplayFriend(int iCoplayFriend);
		virtual int GetFriendCoplayTime(steam_id steamIDFriend);
		virtual unsigned int GetFriendCoplayGame(steam_id steamIDFriend);
		virtual unsigned long long JoinClanChatRoom(steam_id steamIDClan);
		virtual bool LeaveClanChatRoom(steam_id steamIDClan);
		virtual int GetClanChatMemberCount(steam_id steamIDClan);
		virtual steam_id GetChatMemberByIndex(steam_id steamIDClan, int iUser);
		virtual bool SendClanChatMessage(steam_id steamIDClanChat, const char* pchText);
		virtual int GetClanChatMessage(steam_id steamIDClanChat, int iMessage, void* prgchText, int cchTextMax,
		                               unsigned int* peChatEntryType, steam_id* pSteamIDChatter);
		virtual bool IsClanChatAdmin(steam_id steamIDClanChat, steam_id steamIDUser);
		virtual bool IsClanChatWindowOpenInSteam(steam_id steamIDClanChat);
		virtual bool OpenClanChatWindowInSteam(steam_id steamIDClanChat);
		virtual bool CloseClanChatWindowInSteam(steam_id steamIDClanChat);
		virtual bool SetListenForFriendsMessages(bool bInterceptEnabled);
		virtual bool ReplyToFriendMessage(steam_id steamIDFriend, const char* pchMsgToSend);
		virtual int GetFriendMessage(steam_id steamIDFriend, int iMessageID, void* pvData, int cubData,
		                             unsigned int* peChatEntryType);
		virtual unsigned long long GetFollowerCount(steam_id steamID);
		virtual unsigned long long IsFollowing(steam_id steamID);
		virtual unsigned long long EnumerateFollowingList(unsigned int unStartIndex);
	};
}

```

`src/client/steam/interfaces/game_server.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"
#include "../../component/dedicated.hpp"

namespace steam
{
	bool game_server::InitGameServer(unsigned int unGameIP, unsigned short unGamePort, unsigned short usQueryPort,
	                                 unsigned int unServerFlags, unsigned int nAppID, const char* pchVersion)
	{
		return true;
	}

	void game_server::SetProduct(const char* pchProductName)
	{
	}

	void game_server::SetGameDescription(const char* pchGameDescription)
	{
	}

	void game_server::SetModDir(const char* pchModDir)
	{
	}

	void game_server::SetDedicatedServer(bool bDedicatedServer)
	{
	}

	void game_server::LogOn(const char* pszAccountName, const char* pszPassword)
	{
	}

	void game_server::LogOnAnonymous()
	{
		auto* const retvals = calloc(1, 1);
		const auto result = callbacks::register_call();
		callbacks::return_call(retvals, 0, 101, result);
	}

	void game_server::LogOff()
	{
	}

	bool game_server::BLoggedOn()
	{
		return true;
	}

	bool game_server::BSecure()
	{
		return false;
	}

	steam_id game_server::GetSteamID()
	{
		return SteamUser()->GetSteamID();
	}

	bool game_server::WasRestartRequested()
	{
		return false;
	}

	void game_server::SetMaxPlayerCount(int cPlayersMax)
	{
	}

	void game_server::SetBotPlayerCount(int cBotPlayers)
	{
	}

	void game_server::SetServerName(const char* pszServerName)
	{
	}

	void game_server::SetMapName(const char* pszMapName)
	{
	}

	void game_server::SetPasswordProtected(bool bPasswordProtected)
	{
	}

	void game_server::SetSpectatorPort(unsigned short unSpectatorPort)
	{
	}

	void game_server::SetSpectatorServerName(const char* pszSpectatorServerName)
	{
	}

	void game_server::ClearAllKeyValues()
	{
	}

	void game_server::SetKeyValue(const char* pKey, const char* pValue)
	{
	}

	void game_server::SetGameTags(const char* pchGameTags)
	{
	}

	void game_server::SetGameData(const char* pchGameData)
	{
	}

	void game_server::SetRegion(const char* pchRegionName)
	{
	}

	int game_server::SendUserConnectAndAuthenticate(unsigned int unIPClient, const void* pvAuthBlob,
	                                                unsigned int cubAuthBlobSize, steam_id* pSteamIDUser)
	{
		return 0;
	}

	steam_id game_server::CreateUnauthenticatedUserConnection()
	{
		return SteamUser()->GetSteamID();
	}

	void game_server::SendUserDisconnect(steam_id steamIDUser)
	{
	}

	bool game_server::BUpdateUserData(steam_id steamIDUser, const char* pchPlayerName, unsigned int uScore)
	{
		return false;
	}

	int game_server::GetAuthSessionTicket(void* pTicket, int cbMaxTicket, unsigned int* pcbTicket)
	{
		return 0;
	}

	int game_server::BeginAuthSession(const void* pAuthTicket, int cbAuthTicket, steam_id steamID)
	{
		return 0;
	}

	void game_server::EndAuthSession(steam_id steamID)
	{
	}

	void game_server::CancelAuthTicket(int hAuthTicket)
	{
	}

	int game_server::UserHasLicenseForApp(steam_id steamID, unsigned int appID)
	{
		return 0;
	}

	bool game_server::RequestUserGroupStatus(steam_id steamIDUser, steam_id steamIDGroup)
	{
		return false;
	}

	void game_server::GetGameplayStats()
	{
	}

	unsigned long long game_server::GetServerReputation()
	{
		return 0;
	}

	unsigned int game_server::GetPublicIP()
	{
		return 0;
	}

	bool game_server::HandleIncomingPacket(const void* pData, int cbData, unsigned int srcIP, unsigned short srcPort)
	{
		return false;
	}

	int game_server::GetNextOutgoingPacket(void* pOut, int cbMaxOut, unsigned int* pNetAdr, unsigned short* pPort)
	{
		return 0;
	}

	void game_server::EnableHeartbeats(bool bActive)
	{
		dedicated::send_heartbeat();
	}

	void game_server::SetHeartbeatInterval(int iHeartbeatInterval)
	{
	}

	void game_server::ForceHeartbeat()
	{
	}

	unsigned long long game_server::AssociateWithClan(steam_id clanID)
	{
		return 0;
	}

	unsigned long long game_server::ComputeNewPlayerCompatibility(steam_id steamID)
	{
		return 0;
	}
}

```

`src/client/steam/interfaces/game_server.hpp`:

```hpp
#pragma once

namespace steam
{
	class game_server
	{
	public:
		~game_server() = default;

		virtual bool InitGameServer(unsigned int unGameIP, unsigned short unGamePort, unsigned short usQueryPort,
		                            unsigned int unServerFlags, unsigned int nAppID, const char* pchVersion);
		virtual void SetProduct(const char* pchProductName);
		virtual void SetGameDescription(const char* pchGameDescription);
		virtual void SetModDir(const char* pchModDir);
		virtual void SetDedicatedServer(bool bDedicatedServer);
		virtual void LogOn(const char* pszAccountName, const char* pszPassword);
		virtual void LogOnAnonymous();
		virtual void LogOff();
		virtual bool BLoggedOn();
		virtual bool BSecure();
		virtual steam_id GetSteamID();
		virtual bool WasRestartRequested();
		virtual void SetMaxPlayerCount(int cPlayersMax);
		virtual void SetBotPlayerCount(int cBotPlayers);
		virtual void SetServerName(const char* pszServerName);
		virtual void SetMapName(const char* pszMapName);
		virtual void SetPasswordProtected(bool bPasswordProtected);
		virtual void SetSpectatorPort(unsigned short unSpectatorPort);
		virtual void SetSpectatorServerName(const char* pszSpectatorServerName);
		virtual void ClearAllKeyValues();
		virtual void SetKeyValue(const char* pKey, const char* pValue);
		virtual void SetGameTags(const char* pchGameTags);
		virtual void SetGameData(const char* pchGameData);
		virtual void SetRegion(const char* pchRegionName);
		virtual int SendUserConnectAndAuthenticate(unsigned int unIPClient, const void* pvAuthBlob,
		                                           unsigned int cubAuthBlobSize, steam_id* pSteamIDUser);
		virtual steam_id CreateUnauthenticatedUserConnection();
		virtual void SendUserDisconnect(steam_id steamIDUser);
		virtual bool BUpdateUserData(steam_id steamIDUser, const char* pchPlayerName, unsigned int uScore);
		virtual int GetAuthSessionTicket(void* pTicket, int cbMaxTicket, unsigned int* pcbTicket);
		virtual int BeginAuthSession(const void* pAuthTicket, int cbAuthTicket, steam_id steamID);
		virtual void EndAuthSession(steam_id steamID);
		virtual void CancelAuthTicket(int hAuthTicket);
		virtual int UserHasLicenseForApp(steam_id steamID, unsigned int appID);
		virtual bool RequestUserGroupStatus(steam_id steamIDUser, steam_id steamIDGroup);
		virtual void GetGameplayStats();
		virtual unsigned long long GetServerReputation();
		virtual unsigned int GetPublicIP();
		virtual bool HandleIncomingPacket(const void* pData, int cbData, unsigned int srcIP, unsigned short srcPort);
		virtual int GetNextOutgoingPacket(void* pOut, int cbMaxOut, unsigned int* pNetAdr, unsigned short* pPort);
		virtual void EnableHeartbeats(bool bActive);
		virtual void SetHeartbeatInterval(int iHeartbeatInterval);
		virtual void ForceHeartbeat();
		virtual unsigned long long AssociateWithClan(steam_id clanID);
		virtual unsigned long long ComputeNewPlayerCompatibility(steam_id steamID);
	};
}

```

`src/client/steam/interfaces/game_server_stats.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

namespace steam
{
	uint64_t game_server_stats::RequestUserStats(steam_id steamIDUser)
	{
		return 0;
	}

	bool game_server_stats::GetUserStat(steam_id steamIDUser, const char* pchName, int32_t* pData)
	{
		return false;
	}

	bool game_server_stats::GetUserStat(steam_id steamIDUser, const char* pchName, float* pData)
	{
		return false;
	}

	bool game_server_stats::GetUserAchievement(steam_id steamIDUser, const char* pchName, bool* pbAchieved)
	{
		return false;
	}

	bool game_server_stats::SetUserStat(steam_id steamIDUser, const char* pchName, int32_t nData)
	{
		return false;
	}

	bool game_server_stats::SetUserStat(steam_id steamIDUser, const char* pchName, float fData)
	{
		return false;
	}

	bool game_server_stats::UpdateUserAvgRateStat(steam_id steamIDUser, const char* pchName, float flCountThisSession,
	                                              double dSessionLength)
	{
		return false;
	}

	bool game_server_stats::SetUserAchievement(steam_id steamIDUser, const char* pchName)
	{
		return false;
	}

	bool game_server_stats::ClearUserAchievement(steam_id steamIDUser, const char* pchName)
	{
		return false;
	}

	uint64_t game_server_stats::StoreUserStats(steam_id steamIDUser)
	{
		return 0;
	}
}

```

`src/client/steam/interfaces/game_server_stats.hpp`:

```hpp
#pragma once

namespace steam
{
	class game_server_stats
	{
	public:
		~game_server_stats() = default;

		virtual uint64_t RequestUserStats(steam_id steamIDUser);
		virtual bool GetUserStat(steam_id steamIDUser, const char* pchName, int32_t* pData);
		virtual bool GetUserStat(steam_id steamIDUser, const char* pchName, float* pData);
		virtual bool GetUserAchievement(steam_id steamIDUser, const char* pchName, bool* pbAchieved);
		virtual bool SetUserStat(steam_id steamIDUser, const char* pchName, int32_t nData);
		virtual bool SetUserStat(steam_id steamIDUser, const char* pchName, float fData);
		virtual bool UpdateUserAvgRateStat(steam_id steamIDUser, const char* pchName, float flCountThisSession,
		                                   double dSessionLength);
		virtual bool SetUserAchievement(steam_id steamIDUser, const char* pchName);
		virtual bool ClearUserAchievement(steam_id steamIDUser, const char* pchName);
		virtual uint64_t StoreUserStats(steam_id steamIDUser);
	};
}

```

`src/client/steam/interfaces/http.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

namespace steam
{
	HTTPRequestHandle http::http::CreateHTTPRequest(uint32_t eHTTPRequestMethod, const char* pchAbsoluteURL)
	{
		return 0;
	}

	bool http::SetHTTPRequestContextValue(HTTPRequestHandle hRequest, uint64_t ulContextValue)
	{
		return false;
	}

	bool http::SetHTTPRequestNetworkActivityTimeout(HTTPRequestHandle hRequest, uint32_t unTimeoutSeconds)
	{
		return false;
	}

	bool http::SetHTTPRequestHeaderValue(HTTPRequestHandle hRequest, const char* pchHeaderName,
	                                     const char* pchHeaderValue)
	{
		return false;
	}

	bool http::SetHTTPRequestGetOrPostParameter(HTTPRequestHandle hRequest, const char* pchParamName,
	                                            const char* pchParamValue)
	{
		return false;
	}

	bool http::SendHTTPRequest(HTTPRequestHandle hRequest, uint64_t* pCallHandle)
	{
		return false;
	}

	bool http::SendHTTPRequestAndStreamResponse(HTTPRequestHandle hRequest, uint64_t* pCallHandle)
	{
		return false;
	}

	bool http::DeferHTTPRequest(HTTPRequestHandle hRequest)
	{
		return false;
	}

	bool http::PrioritizeHTTPRequest(HTTPRequestHandle hRequest)
	{
		return false;
	}

	bool http::GetHTTPResponseHeaderSize(HTTPRequestHandle hRequest, const char* pchHeaderName,
	                                     uint32_t* unResponseHeaderSize)
	{
		return false;
	}

	bool http::GetHTTPResponseHeaderValue(HTTPRequestHandle hRequest, const char* pchHeaderName,
	                                      uint8_t* pHeaderValueBuffer, uint32_t unBufferSize)
	{
		return false;
	}

	bool http::GetHTTPResponseBodySize(HTTPRequestHandle hRequest, uint32_t* unBodySize)
	{
		return false;
	}

	bool http::GetHTTPResponseBodyData(HTTPRequestHandle hRequest, uint8_t* pBodyDataBuffer, uint32_t unBufferSize)
	{
		return false;
	}

	bool http::GetHTTPStreamingResponseBodyData(HTTPRequestHandle hRequest, uint32_t cOffset, uint8_t* pBodyDataBuffer,
	                                            uint32_t unBufferSize)
	{
		return false;
	}

	bool http::ReleaseHTTPRequest(HTTPRequestHandle hRequest)
	{
		return false;
	}

	bool http::GetHTTPDownloadProgressPct(HTTPRequestHandle hRequest, float* pflPercentOut)
	{
		return false;
	}

	bool http::SetHTTPRequestRawPostBody(HTTPRequestHandle hRequest, const char* pchContentType, uint8_t* pubBody,
	                                     uint32_t unBodyLen)
	{
		return false;
	}

	HTTPCookieContainerHandle http::CreateCookieContainer(bool bAllowResponsesToModify)
	{
		return 0;
	}

	bool http::ReleaseCookieContainer(HTTPCookieContainerHandle hCookieContainer)
	{
		return false;
	}

	bool http::SetCookie(HTTPCookieContainerHandle hCookieContainer, const char* pchHost, const char* pchUrl,
	                     const char* pchCookie)
	{
		return false;
	}

	bool http::SetHTTPRequestCookieContainer(HTTPRequestHandle hRequest, HTTPCookieContainerHandle hCookieContainer)
	{
		return false;
	}

	bool http::SetHTTPRequestUserAgentInfo(HTTPRequestHandle hRequest, const char* pchUserAgentInfo)
	{
		return false;
	}

	bool http::SetHTTPRequestRequiresVerifiedCertificate(HTTPRequestHandle hRequest, bool bRequireVerifiedCertificate)
	{
		return false;
	}

	bool http::SetHTTPRequestAbsoluteTimeoutMS(HTTPRequestHandle hRequest, uint32_t unMilliseconds)
	{
		return false;
	}

	bool http::GetHTTPRequestWasTimedOut(HTTPRequestHandle hRequest, bool* pbWasTimedOut)
	{
		return false;
	}
}

```

`src/client/steam/interfaces/http.hpp`:

```hpp
#pragma once

namespace steam
{
	using HTTPRequestHandle = uint64_t;
	using HTTPCookieContainerHandle = uint64_t;

	class http
	{
	public:
		~http() = default;

		virtual HTTPRequestHandle CreateHTTPRequest(uint32_t eHTTPRequestMethod, const char* pchAbsoluteURL);
		virtual bool SetHTTPRequestContextValue(HTTPRequestHandle hRequest, uint64_t ulContextValue);
		virtual bool SetHTTPRequestNetworkActivityTimeout(HTTPRequestHandle hRequest, uint32_t unTimeoutSeconds);
		virtual bool SetHTTPRequestHeaderValue(HTTPRequestHandle hRequest, const char* pchHeaderName,
		                                       const char* pchHeaderValue);
		virtual bool SetHTTPRequestGetOrPostParameter(HTTPRequestHandle hRequest, const char* pchParamName,
		                                              const char* pchParamValue);
		virtual bool SendHTTPRequest(HTTPRequestHandle hRequest, uint64_t* pCallHandle);
		virtual bool SendHTTPRequestAndStreamResponse(HTTPRequestHandle hRequest, uint64_t* pCallHandle);
		virtual bool DeferHTTPRequest(HTTPRequestHandle hRequest);
		virtual bool PrioritizeHTTPRequest(HTTPRequestHandle hRequest);
		virtual bool GetHTTPResponseHeaderSize(HTTPRequestHandle hRequest, const char* pchHeaderName,
		                                       uint32_t* unResponseHeaderSize);
		virtual bool GetHTTPResponseHeaderValue(HTTPRequestHandle hRequest, const char* pchHeaderName,
		                                        uint8_t* pHeaderValueBuffer, uint32_t unBufferSize);
		virtual bool GetHTTPResponseBodySize(HTTPRequestHandle hRequest, uint32_t* unBodySize);
		virtual bool GetHTTPResponseBodyData(HTTPRequestHandle hRequest, uint8_t* pBodyDataBuffer,
		                                     uint32_t unBufferSize);
		virtual bool GetHTTPStreamingResponseBodyData(HTTPRequestHandle hRequest, uint32_t cOffset,
		                                              uint8_t* pBodyDataBuffer, uint32_t unBufferSize);
		virtual bool ReleaseHTTPRequest(HTTPRequestHandle hRequest);
		virtual bool GetHTTPDownloadProgressPct(HTTPRequestHandle hRequest, float* pflPercentOut);
		virtual bool SetHTTPRequestRawPostBody(HTTPRequestHandle hRequest, const char* pchContentType, uint8_t* pubBody,
		                                       uint32_t unBodyLen);
		virtual HTTPCookieContainerHandle CreateCookieContainer(bool bAllowResponsesToModify);
		virtual bool ReleaseCookieContainer(HTTPCookieContainerHandle hCookieContainer);
		virtual bool SetCookie(HTTPCookieContainerHandle hCookieContainer, const char* pchHost, const char* pchUrl,
		                       const char* pchCookie);
		virtual bool SetHTTPRequestCookieContainer(HTTPRequestHandle hRequest,
		                                           HTTPCookieContainerHandle hCookieContainer);
		virtual bool SetHTTPRequestUserAgentInfo(HTTPRequestHandle hRequest, const char* pchUserAgentInfo);
		virtual bool SetHTTPRequestRequiresVerifiedCertificate(HTTPRequestHandle hRequest,
		                                                       bool bRequireVerifiedCertificate);
		virtual bool SetHTTPRequestAbsoluteTimeoutMS(HTTPRequestHandle hRequest, uint32_t unMilliseconds);
		virtual bool GetHTTPRequestWasTimedOut(HTTPRequestHandle hRequest, bool* pbWasTimedOut);
	};
}

```

`src/client/steam/interfaces/matchmaking.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

namespace steam
{
	int matchmaking::GetFavoriteGameCount()
	{
		return 0;
	}

	bool matchmaking::GetFavoriteGame(int iGame, unsigned int* pnAppID, unsigned int* pnIP, unsigned short* pnConnPort,
	                                  unsigned short* pnQueryPort, unsigned int* punFlags,
	                                  unsigned int* pRTime32LastPlayedOnServer)
	{
		return false;
	}

	int matchmaking::AddFavoriteGame(unsigned int nAppID, unsigned int nIP, unsigned short nConnPort,
	                                 unsigned short nQueryPort, unsigned int unFlags,
	                                 unsigned int rTime32LastPlayedOnServer)
	{
		return 0;
	}

	bool matchmaking::RemoveFavoriteGame(unsigned int nAppID, unsigned int nIP, unsigned short nConnPort,
	                                     unsigned short nQueryPort, unsigned int unFlags)
	{
		return false;
	}

	unsigned long long matchmaking::RequestLobbyList()
	{
		return 0;
	}

	void matchmaking::AddRequestLobbyListStringFilter(const char* pchKeyToMatch, const char* pchValueToMatch,
	                                                  int eComparisonType)
	{
	}

	void matchmaking::AddRequestLobbyListNumericalFilter(const char* pchKeyToMatch, int nValueToMatch,
	                                                     int eComparisonType)
	{
	}

	void matchmaking::AddRequestLobbyListNearValueFilter(const char* pchKeyToMatch, int nValueToBeCloseTo)
	{
	}

	void matchmaking::AddRequestLobbyListFilterSlotsAvailable(int nSlotsAvailable)
	{
	}

	void matchmaking::AddRequestLobbyListDistanceFilter(int eLobbyDistanceFilter)
	{
	}

	void matchmaking::AddRequestLobbyListResultCountFilter(int cMaxResults)
	{
	}

	void matchmaking::AddRequestLobbyListCompatibleMembersFilter(steam_id steamID)
	{
	}

	steam_id matchmaking::GetLobbyByIndex(int iLobby)
	{
		steam_id id;

		id.raw.account_id = SteamUser()->GetSteamID().raw.account_id;
		id.raw.universe = 1;
		id.raw.account_type = 8;
		id.raw.account_instance = 0x40000;

		return id;
	}

	unsigned long long matchmaking::CreateLobby(int eLobbyType, int cMaxMembers)
	{
		const auto result = callbacks::register_call();
		auto retvals = static_cast<lobby_created*>(calloc(1, sizeof(lobby_created)));
		//::Utils::Memory::AllocateArray<LobbyCreated>();
		steam_id id;

		id.raw.account_id = SteamUser()->GetSteamID().raw.account_id;
		id.raw.universe = 1;
		id.raw.account_type = 8;
		id.raw.account_instance = 0x40000;

		retvals->m_e_result = 1;
		retvals->m_ul_steam_id_lobby = id;

		callbacks::return_call(retvals, sizeof(lobby_created), lobby_created::callback_id, result);

		matchmaking::JoinLobby(id);

		return result;
	}

	unsigned long long matchmaking::JoinLobby(steam_id steamIDLobby)
	{
		const auto result = callbacks::register_call();
		auto* retvals = static_cast<lobby_enter*>(calloc(1, sizeof(lobby_enter)));
		//::Utils::Memory::AllocateArray<LobbyEnter>();
		retvals->m_b_locked = false;
		retvals->m_e_chat_room_enter_response = 1;
		retvals->m_rgf_chat_permissions = 0xFFFFFFFF;
		retvals->m_ul_steam_id_lobby = steamIDLobby;

		callbacks::return_call(retvals, sizeof(lobby_enter), lobby_enter::callback_id, result);

		return result;
	}

	void matchmaking::LeaveLobby(steam_id steamIDLobby)
	{
	}

	bool matchmaking::InviteUserToLobby(steam_id steamIDLobby, steam_id steamIDInvitee)
	{
		return true;
	}

	int matchmaking::GetNumLobbyMembers(steam_id steamIDLobby)
	{
		return 1;
	}

	steam_id matchmaking::GetLobbyMemberByIndex(steam_id steamIDLobby, int iMember)
	{
		return SteamUser()->GetSteamID();
	}

	const char* matchmaking::GetLobbyData(steam_id steamIDLobby, const char* pchKey)
	{
		return "";
	}

	bool matchmaking::SetLobbyData(steam_id steamIDLobby, const char* pchKey, const char* pchValue)
	{
		return true;
	}

	int matchmaking::GetLobbyDataCount(steam_id steamIDLobby)
	{
		return 0;
	}

	bool matchmaking::GetLobbyDataByIndex(steam_id steamIDLobby, int iLobbyData, char* pchKey, int cchKeyBufferSize,
	                                      char* pchValue, int cchValueBufferSize)
	{
		return true;
	}

	bool matchmaking::DeleteLobbyData(steam_id steamIDLobby, const char* pchKey)
	{
		return true;
	}

	const char* matchmaking::GetLobbyMemberData(steam_id steamIDLobby, steam_id steamIDUser, const char* pchKey)
	{
		return "";
	}

	void matchmaking::SetLobbyMemberData(steam_id steamIDLobby, const char* pchKey, const char* pchValue)
	{
	}

	bool matchmaking::SendLobbyChatMsg(steam_id steamIDLobby, const void* pvMsgBody, int cubMsgBody)
	{
		return true;
	}

	int matchmaking::GetLobbyChatEntry(steam_id steamIDLobby, int iChatID, steam_id* pSteamIDUser, void* pvData,
	                                   int cubData, int* peChatEntryType)
	{
		return 0;
	}

	bool matchmaking::RequestLobbyData(steam_id steamIDLobby)
	{
		return true;
	}

	void matchmaking::SetLobbyGameServer(steam_id steamIDLobby, unsigned int unGameServerIP,
	                                     unsigned short unGameServerPort, steam_id steamIDGameServer)
	{
	}

	bool matchmaking::GetLobbyGameServer(steam_id steamIDLobby, unsigned int* punGameServerIP,
	                                     unsigned short* punGameServerPort, steam_id* psteamIDGameServer)
	{
		return true;
	}

	bool matchmaking::SetLobbyMemberLimit(steam_id steamIDLobby, int cMaxMembers)
	{
		return true;
	}

	int matchmaking::GetLobbyMemberLimit(steam_id steamIDLobby)
	{
		return 0;
	}

	bool matchmaking::SetLobbyType(steam_id steamIDLobby, int eLobbyType)
	{
		return true;
	}

	bool matchmaking::SetLobbyJoinable(steam_id steamIDLobby, bool bLobbyJoinable)
	{
		return true;
	}

	steam_id matchmaking::GetLobbyOwner(steam_id steamIDLobby)
	{
		return SteamUser()->GetSteamID();
	}

	bool matchmaking::SetLobbyOwner(steam_id steamIDLobby, steam_id steamIDNewOwner)
	{
		return true;
	}

	bool matchmaking::SetLinkedLobby(steam_id steamIDLobby, steam_id steamIDLobby2)
	{
		return true;
	}
}

```

`src/client/steam/interfaces/matchmaking.hpp`:

```hpp
#pragma once

namespace steam
{
	struct lobby_created final
	{
		enum { callback_id = 513 };

		int m_e_result;
		int m_pad;
		steam_id m_ul_steam_id_lobby;
	};

	struct lobby_enter final
	{
		enum { callback_id = 504 };

		steam_id m_ul_steam_id_lobby;
		int m_rgf_chat_permissions;
		bool m_b_locked;
		int m_e_chat_room_enter_response;
	};

	class matchmaking
	{
	public:
		~matchmaking() = default;

		virtual int GetFavoriteGameCount();
		virtual bool GetFavoriteGame(int iGame, unsigned int* pnAppID, unsigned int* pnIP, unsigned short* pnConnPort,
		                             unsigned short* pnQueryPort, unsigned int* punFlags,
		                             unsigned int* pRTime32LastPlayedOnServer);
		virtual int AddFavoriteGame(unsigned int nAppID, unsigned int nIP, unsigned short nConnPort,
		                            unsigned short nQueryPort, unsigned int unFlags,
		                            unsigned int rTime32LastPlayedOnServer);
		virtual bool RemoveFavoriteGame(unsigned int nAppID, unsigned int nIP, unsigned short nConnPort,
		                                unsigned short nQueryPort, unsigned int unFlags);
		virtual unsigned long long RequestLobbyList();
		virtual void AddRequestLobbyListStringFilter(const char* pchKeyToMatch, const char* pchValueToMatch,
		                                             int eComparisonType);
		virtual void AddRequestLobbyListNumericalFilter(const char* pchKeyToMatch, int nValueToMatch,
		                                                int eComparisonType);
		virtual void AddRequestLobbyListNearValueFilter(const char* pchKeyToMatch, int nValueToBeCloseTo);
		virtual void AddRequestLobbyListFilterSlotsAvailable(int nSlotsAvailable);
		virtual void AddRequestLobbyListDistanceFilter(int eLobbyDistanceFilter);
		virtual void AddRequestLobbyListResultCountFilter(int cMaxResults);
		virtual void AddRequestLobbyListCompatibleMembersFilter(steam_id steamID);
		virtual steam_id GetLobbyByIndex(int iLobby);
		virtual unsigned long long CreateLobby(int eLobbyType, int cMaxMembers);
		virtual unsigned long long JoinLobby(steam_id steamIDLobby);
		virtual void LeaveLobby(steam_id steamIDLobby);
		virtual bool InviteUserToLobby(steam_id steamIDLobby, steam_id steamIDInvitee);
		virtual int GetNumLobbyMembers(steam_id steamIDLobby);
		virtual steam_id GetLobbyMemberByIndex(steam_id steamIDLobby, int iMember);
		virtual const char* GetLobbyData(steam_id steamIDLobby, const char* pchKey);
		virtual bool SetLobbyData(steam_id steamIDLobby, const char* pchKey, const char* pchValue);
		virtual int GetLobbyDataCount(steam_id steamIDLobby);
		virtual bool GetLobbyDataByIndex(steam_id steamIDLobby, int iLobbyData, char* pchKey, int cchKeyBufferSize,
		                                 char* pchValue, int cchValueBufferSize);
		virtual bool DeleteLobbyData(steam_id steamIDLobby, const char* pchKey);
		virtual const char* GetLobbyMemberData(steam_id steamIDLobby, steam_id steamIDUser, const char* pchKey);
		virtual void SetLobbyMemberData(steam_id steamIDLobby, const char* pchKey, const char* pchValue);
		virtual bool SendLobbyChatMsg(steam_id steamIDLobby, const void* pvMsgBody, int cubMsgBody);
		virtual int GetLobbyChatEntry(steam_id steamIDLobby, int iChatID, steam_id* pSteamIDUser, void* pvData,
		                              int cubData, int* peChatEntryType);
		virtual bool RequestLobbyData(steam_id steamIDLobby);
		virtual void SetLobbyGameServer(steam_id steamIDLobby, unsigned int unGameServerIP,
		                                unsigned short unGameServerPort, steam_id steamIDGameServer);
		virtual bool GetLobbyGameServer(steam_id steamIDLobby, unsigned int* punGameServerIP,
		                                unsigned short* punGameServerPort, steam_id* psteamIDGameServer);
		virtual bool SetLobbyMemberLimit(steam_id steamIDLobby, int cMaxMembers);
		virtual int GetLobbyMemberLimit(steam_id steamIDLobby);
		virtual bool SetLobbyType(steam_id steamIDLobby, int eLobbyType);
		virtual bool SetLobbyJoinable(steam_id steamIDLobby, bool bLobbyJoinable);
		virtual steam_id GetLobbyOwner(steam_id steamIDLobby);
		virtual bool SetLobbyOwner(steam_id steamIDLobby, steam_id steamIDNewOwner);
		virtual bool SetLinkedLobby(steam_id steamIDLobby, steam_id steamIDLobby2);
	};
}

```

`src/client/steam/interfaces/matchmaking_servers.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

#include "game/game.hpp"

#include "component/party.hpp"
#include "component/network.hpp"
#include "component/server_list.hpp"

#include <utils/string.hpp>
#include <utils/concurrency.hpp>

namespace steam
{
	namespace
	{
		struct server
		{
			bool handled{false};
			game::netadr_t address{};
			gameserveritem_t server_item{};
		};

		auto* const internet_request = reinterpret_cast<void*>(1);

		using servers = std::vector<server>;

		::utils::concurrency::container<servers> queried_servers{};
		std::atomic<matchmaking_server_list_response*> current_response{};

		gameserveritem_t create_server_item(const game::netadr_t& address, const ::utils::info_string& info,
		                                    const uint32_t ping, const bool success)
		{
			gameserveritem_t server{};
			server.m_NetAdr.m_usConnectionPort = address.port;
			server.m_NetAdr.m_usQueryPort = address.port;
			server.m_NetAdr.m_unIP = ntohl(address.addr);
			server.m_nPing = static_cast<int>(ping);
			server.m_bHadSuccessfulResponse = success;
			server.m_bDoNotRefresh = false;
			strcpy_s(server.m_szGameDir, "");
			strcpy_s(server.m_szMap, info.get("mapname").data());
			strcpy_s(server.m_szGameDescription, info.get("description").data());
			server.m_nAppID = 311210;
			server.m_nPlayers = atoi(info.get("clients").data());
			server.m_nMaxPlayers = atoi(info.get("sv_maxclients").data());
			server.m_nBotPlayers = atoi(info.get("bots").data());
			server.m_bPassword = info.get("isPrivate") == "1";
			server.m_bSecure = true;
			server.m_ulTimeLastPlayed = 0;
			server.m_nServerVersion = 1000;
			strcpy_s(server.m_szServerName, info.get("hostname").data());

			const auto playmode = info.get("playmode");
			const auto mode = game::eModes(std::atoi(playmode.data()));

			const auto* tags = ::utils::string::va(
				R"(\gametype\%s\dedicated\%s\ranked\false\hardcore\false\zombies\%s\modName\\playerCount\%d)",
				info.get("gametype").data(),
				info.get("dedicated") == "1" ? "true" : "false",
				mode == game::MODE_ZOMBIES ? "true" : "false", server.m_nPlayers);

			strcpy_s(server.m_szGameTags, tags);
			server.m_steamID.bits = strtoull(info.get("xuid").data(), nullptr, 16);

			return server;
		}

		void handle_server_respone(const bool success, const game::netadr_t& host, const ::utils::info_string& info,
		                           const uint32_t ping)
		{
			bool all_handled = false;
			std::optional<int> index{};
			queried_servers.access([&](servers& srvs)
			{
				size_t i = 0;
				for (; i < srvs.size(); ++i)
				{
					if (srvs[i].address == host)
					{
						break;
					}
				}

				if (i >= srvs.size())
				{
					return;
				}

				index = static_cast<int>(i);

				auto& srv = srvs[i];
				srv.handled = true;
				srv.server_item = create_server_item(host, info, ping, success);


				for (const auto& entry : srvs)
				{
					if (!entry.handled)
					{
						return;
					}
				}

				all_handled = true;
			});

			const auto res = current_response.load();
			if (!index || !res)
			{
				return;
			}

			if (success)
			{
				res->ServerResponded(internet_request, *index);
			}
			else
			{
				res->ServerFailedToRespond(internet_request, *index);
			}

			if (all_handled)
			{
				res->RefreshComplete(internet_request, eServerResponded);
			}
		}

		void ping_server(const game::netadr_t& server)
		{
			party::query_server(server, handle_server_respone);
		}
	}

	void* matchmaking_servers::RequestInternetServerList(unsigned int iApp, void** ppchFilters, unsigned int nFilters,
	                                                     matchmaking_server_list_response* pRequestServersResponse)
	{
		current_response = pRequestServersResponse;

		server_list::request_servers([](const bool success, const std::unordered_set<game::netadr_t>& s)
		{
			const auto res = current_response.load();
			if (!res)
			{
				return;
			}

			if (!success)
			{
				res->RefreshComplete(internet_request, eServerFailedToRespond);
				return;
			}

			if (s.empty())
			{
				res->RefreshComplete(internet_request, eNoServersListedOnMasterServer);
				return;
			}

			queried_servers.access([&s](servers& srvs)
			{
				srvs = {};
				srvs.reserve(s.size());

				for (auto& address : s)
				{
					server new_server{};
					new_server.address = address;
					new_server.server_item = create_server_item(address, {}, 0, false);

					srvs.push_back(new_server);
				}
			});

			for (auto& srv : s)
			{
				ping_server(srv);
			}
		});

		return internet_request;
	}

	void* matchmaking_servers::RequestLANServerList(unsigned int iApp,
	                                                matchmaking_server_list_response* pRequestServersResponse)
	{
		return reinterpret_cast<void*>(2);
	}

	void* matchmaking_servers::RequestFriendsServerList(unsigned int iApp, void** ppchFilters, unsigned int nFilters,
	                                                    matchmaking_server_list_response* pRequestServersResponse)
	{
		return reinterpret_cast<void*>(3);
	}

	void* matchmaking_servers::RequestFavoritesServerList(unsigned int iApp, void** ppchFilters, unsigned int nFilters,
	                                                      matchmaking_server_list_response* pRequestServersResponse)
	{
		return reinterpret_cast<void*>(4);
	}

	void* matchmaking_servers::RequestHistoryServerList(unsigned int iApp, void** ppchFilters, unsigned int nFilters,
	                                                    matchmaking_server_list_response* pRequestServersResponse)
	{
		return reinterpret_cast<void*>(5);
	}

	void* matchmaking_servers::RequestSpectatorServerList(unsigned int iApp, void** ppchFilters, unsigned int nFilters,
	                                                      matchmaking_server_list_response* pRequestServersResponse)
	{
		return reinterpret_cast<void*>(6);
	}

	void matchmaking_servers::ReleaseRequest(void* hServerListRequest)
	{
		if (internet_request == hServerListRequest)
		{
			current_response = nullptr;
		}
	}

	gameserveritem_t* matchmaking_servers::GetServerDetails(void* hRequest, int iServer)
	{
		if (internet_request != hRequest)
		{
			return nullptr;
		}

		static thread_local gameserveritem_t server_item{};
		return queried_servers.access<gameserveritem_t*>([iServer](const servers& s) -> gameserveritem_t*
		{
			if (iServer < 0 || static_cast<size_t>(iServer) >= s.size())
			{
				return nullptr;
			}

			server_item = s[iServer].server_item;
			return &server_item;
		});
	}

	void matchmaking_servers::CancelQuery(void* hRequest)
	{
	}

	void matchmaking_servers::RefreshQuery(void* hRequest)
	{
	}

	bool matchmaking_servers::IsRefreshing(void* hRequest)
	{
		return false;
	}

	int matchmaking_servers::GetServerCount(void* hRequest)
	{
		if (internet_request != hRequest)
		{
			return 0;
		}

		return queried_servers.access<int>([](const servers& s)
		{
			return static_cast<int>(s.size());
		});
	}

	void matchmaking_servers::RefreshServer(void* hRequest, const int iServer)
	{
		if (internet_request != hRequest)
		{
			return;
		}

		std::optional<game::netadr_t> address{};
		queried_servers.access([&](const servers& s)
		{
			if (iServer < 0 || static_cast<size_t>(iServer) >= s.size())
			{
				return;
			}

			address = s[iServer].address;
		});

		if (address)
		{
			ping_server(*address);
		}
	}

	void* matchmaking_servers::PingServer(const unsigned int unIP, const unsigned short usPort,
	                                      matchmaking_ping_response* pRequestServersResponse)
	{
		auto response = pRequestServersResponse;
		const auto addr = network::address_from_ip(htonl(unIP), usPort);

		party::query_server(
			addr, [response](const bool success, const game::netadr_t& host, const ::utils::info_string& info,
			                 const uint32_t ping)
			{
				if (success)
				{
					auto server_item = create_server_item(host, info, ping, success);
					response->ServerResponded(server_item);
				}
				else
				{
					response->ServerFailedToRespond();
				}
			});

		return reinterpret_cast<void*>(static_cast<uint64_t>(7 + rand()));
	}

	int matchmaking_servers::PlayerDetails(unsigned int unIP, unsigned short usPort, void* pRequestServersResponse)
	{
		return 0;
	}

	int matchmaking_servers::ServerRules(unsigned int unIP, unsigned short usPort, void* pRequestServersResponse)
	{
		return 0;
	}

	void matchmaking_servers::CancelServerQuery(int hServerQuery)
	{
	}
}

```

`src/client/steam/interfaces/matchmaking_servers.hpp`:

```hpp
#pragma once

namespace steam
{
	typedef enum EMatchMakingServerResponse
	{
		eServerResponded = 0,
		eServerFailedToRespond,
		eNoServersListedOnMasterServer
	} matchmaking_server_response;

	class servernetadr_t
	{
	public:
		uint16_t m_usConnectionPort;
		uint16_t m_usQueryPort;
		uint32_t m_unIP;
	};

	class gameserveritem_t
	{
	public:
		servernetadr_t m_NetAdr;
		int m_nPing;
		bool m_bHadSuccessfulResponse;
		bool m_bDoNotRefresh;
		char m_szGameDir[32];
		char m_szMap[32];
		char m_szGameDescription[64];
		uint32_t m_nAppID;
		int m_nPlayers;
		int m_nMaxPlayers;
		int m_nBotPlayers;
		bool m_bPassword;
		bool m_bSecure;
		uint32_t m_ulTimeLastPlayed;
		int m_nServerVersion;
		char m_szServerName[64];
		char m_szGameTags[128];
		steam_id m_steamID;
	};

	class matchmaking_ping_response
	{
	public:
		virtual void ServerResponded(gameserveritem_t& server) = 0;
		virtual void ServerFailedToRespond() = 0;
	};

	class matchmaking_server_list_response
	{
	public:
		virtual void ServerResponded(void* hRequest, int iServer) = 0;
		virtual void ServerFailedToRespond(void* hRequest, int iServer) = 0;
		virtual void RefreshComplete(void* hRequest, matchmaking_server_response response) = 0;
	};

	class matchmaking_servers
	{
	public:
		~matchmaking_servers() = default;

		virtual void* RequestInternetServerList(unsigned int iApp, void** ppchFilters, unsigned int nFilters,
		                                        matchmaking_server_list_response* pRequestServersResponse);
		virtual void* RequestLANServerList(unsigned int iApp,
		                                   matchmaking_server_list_response* pRequestServersResponse);
		virtual void* RequestFriendsServerList(unsigned int iApp, void** ppchFilters, unsigned int nFilters,
		                                       matchmaking_server_list_response* pRequestServersResponse);
		virtual void* RequestFavoritesServerList(unsigned int iApp, void** ppchFilters, unsigned int nFilters,
		                                         matchmaking_server_list_response* pRequestServersResponse);
		virtual void* RequestHistoryServerList(unsigned int iApp, void** ppchFilters, unsigned int nFilters,
		                                       matchmaking_server_list_response* pRequestServersResponse);
		virtual void* RequestSpectatorServerList(unsigned int iApp, void** ppchFilters, unsigned int nFilters,
		                                         matchmaking_server_list_response* pRequestServersResponse);
		virtual void ReleaseRequest(void* hServerListRequest);
		virtual gameserveritem_t* GetServerDetails(void* hRequest, int iServer);
		virtual void CancelQuery(void* hRequest);
		virtual void RefreshQuery(void* hRequest);
		virtual bool IsRefreshing(void* hRequest);
		virtual int GetServerCount(void* hRequest);
		virtual void RefreshServer(void* hRequest, int iServer);
		virtual void* PingServer(unsigned int unIP, unsigned short usPort, matchmaking_ping_response* pRequestServersResponse);
		virtual int PlayerDetails(unsigned int unIP, unsigned short usPort, void* pRequestServersResponse);
		virtual int ServerRules(unsigned int unIP, unsigned short usPort, void* pRequestServersResponse);
		virtual void CancelServerQuery(int hServerQuery);
	};
}

```

`src/client/steam/interfaces/networking.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

namespace steam
{
	bool networking::SendP2PPacket(steam_id steamIDRemote, const void* pubData, unsigned int cubData, int eP2PSendType)
	{
		return false;
	}

	bool networking::IsP2PPacketAvailable(unsigned int* pcubMsgSize, int idk)
	{
		return false;
	}

	bool networking::ReadP2PPacket(void* pubDest, unsigned int cubDest, unsigned int* pcubMsgSize,
	                               steam_id* psteamIDRemote)
	{
		return false;
	}

	bool networking::AcceptP2PSessionWithUser(steam_id steamIDRemote)
	{
		return false;
	}

	bool networking::CloseP2PSessionWithUser(steam_id steamIDRemote)
	{
		return false;
	}

	bool networking::CloseP2PChannelWithUser(steam_id steamIDRemote, int iVirtualPort)
	{
		return false;
	}

	bool networking::GetP2PSessionState(steam_id steamIDRemote, void* pConnectionState)
	{
		return false;
	}

	bool networking::AllowP2PPacketRelay(bool bAllow)
	{
		return false;
	}

	unsigned int networking::CreateListenSocket(int nVirtualP2PPort, unsigned int nIP, unsigned short nPort,
	                                            bool bAllowUseOfPacketRelay)
	{
		return NULL;
	}

	unsigned int networking::CreateP2PConnectionSocket(steam_id steamIDTarget, int nVirtualPort, int nTimeoutSec,
	                                                   bool bAllowUseOfPacketRelay)
	{
		return NULL;
	}

	unsigned int networking::CreateConnectionSocket(unsigned int nIP, unsigned short nPort, int nTimeoutSec)
	{
		return NULL;
	}

	bool networking::DestroySocket(unsigned int hSocket, bool bNotifyRemoteEnd)
	{
		return false;
	}

	bool networking::DestroyListenSocket(unsigned int hSocket, bool bNotifyRemoteEnd)
	{
		return false;
	}

	bool networking::SendDataOnSocket(unsigned int hSocket, void* pubData, unsigned int cubData, bool bReliable)
	{
		return false;
	}

	bool networking::IsDataAvailableOnSocket(unsigned int hSocket, unsigned int* pcubMsgSize)
	{
		return false;
	}

	bool networking::RetrieveDataFromSocket(unsigned int hSocket, void* pubDest, unsigned int cubDest,
	                                        unsigned int* pcubMsgSize)
	{
		return false;
	}

	bool networking::IsDataAvailable(unsigned int hListenSocket, unsigned int* pcubMsgSize, unsigned int* phSocket)
	{
		return false;
	}

	bool networking::RetrieveData(unsigned int hListenSocket, void* pubDest, unsigned int cubDest,
	                              unsigned int* pcubMsgSize, unsigned int* phSocket)
	{
		return false;
	}

	bool networking::GetSocketInfo(unsigned int hSocket, steam_id* pSteamIDRemote, int* peSocketStatus,
	                               unsigned int* punIPRemote, unsigned short* punPortRemote)
	{
		return false;
	}

	bool networking::GetListenSocketInfo(unsigned int hListenSocket, unsigned int* pnIP, unsigned short* pnPort)
	{
		return false;
	}

	int networking::GetSocketConnectionType(unsigned int hSocket)
	{
		return 0;
	}

	int networking::GetMaxPacketSize(unsigned int hSocket)
	{
		return 0;
	}
}

```

`src/client/steam/interfaces/networking.hpp`:

```hpp
#pragma once

namespace steam
{
	class networking
	{
	public:
		~networking() = default;

		virtual bool SendP2PPacket(steam_id steamIDRemote, const void* pubData, unsigned int cubData, int eP2PSendType);
		virtual bool IsP2PPacketAvailable(unsigned int* pcubMsgSize, int idk);
		virtual bool ReadP2PPacket(void* pubDest, unsigned int cubDest, unsigned int* pcubMsgSize,
		                           steam_id* psteamIDRemote);
		virtual bool AcceptP2PSessionWithUser(steam_id steamIDRemote);
		virtual bool CloseP2PSessionWithUser(steam_id steamIDRemote);
		virtual bool CloseP2PChannelWithUser(steam_id steamIDRemote, int iVirtualPort);
		virtual bool GetP2PSessionState(steam_id steamIDRemote, void* pConnectionState);
		virtual bool AllowP2PPacketRelay(bool bAllow);
		virtual unsigned int CreateListenSocket(int nVirtualP2PPort, unsigned int nIP, unsigned short nPort,
		                                        bool bAllowUseOfPacketRelay);
		virtual unsigned int CreateP2PConnectionSocket(steam_id steamIDTarget, int nVirtualPort, int nTimeoutSec,
		                                               bool bAllowUseOfPacketRelay);
		virtual unsigned int CreateConnectionSocket(unsigned int nIP, unsigned short nPort, int nTimeoutSec);
		virtual bool DestroySocket(unsigned int hSocket, bool bNotifyRemoteEnd);
		virtual bool DestroyListenSocket(unsigned int hSocket, bool bNotifyRemoteEnd);
		virtual bool SendDataOnSocket(unsigned int hSocket, void* pubData, unsigned int cubData, bool bReliable);
		virtual bool IsDataAvailableOnSocket(unsigned int hSocket, unsigned int* pcubMsgSize);
		virtual bool RetrieveDataFromSocket(unsigned int hSocket, void* pubDest, unsigned int cubDest,
		                                    unsigned int* pcubMsgSize);
		virtual bool IsDataAvailable(unsigned int hListenSocket, unsigned int* pcubMsgSize, unsigned int* phSocket);
		virtual bool RetrieveData(unsigned int hListenSocket, void* pubDest, unsigned int cubDest,
		                          unsigned int* pcubMsgSize, unsigned int* phSocket);
		virtual bool GetSocketInfo(unsigned int hSocket, steam_id* pSteamIDRemote, int* peSocketStatus,
		                           unsigned int* punIPRemote, unsigned short* punPortRemote);
		virtual bool GetListenSocketInfo(unsigned int hListenSocket, unsigned int* pnIP, unsigned short* pnPort);
		virtual int GetSocketConnectionType(unsigned int hSocket);
		virtual int GetMaxPacketSize(unsigned int hSocket);
	};
}

```

`src/client/steam/interfaces/remote_storage.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

namespace steam
{
	bool remote_storage::FileWrite(const char* pchFile, const void* pvData, int cubData)
	{
		return true;
	}

	int remote_storage::FileRead(const char* pchFile, void* pvData, int cubDataToRead)
	{
		return 0;
	}

	bool remote_storage::FileForget(const char* pchFile)
	{
		return true;
	}

	bool remote_storage::FileDelete(const char* pchFile)
	{
		return true;
	}

	unsigned long long remote_storage::FileShare(const char* pchFile)
	{
		return 0;
	}

	bool remote_storage::SetSyncPlatforms(const char* pchFile, unsigned int eRemoteStoragePlatform)
	{
		return true;
	}

	unsigned long long remote_storage::FileWriteStreamOpen(const char* pchFile)
	{
		return 0;
	}

	int remote_storage::FileWriteStreamWriteChunk(unsigned long long hStream, const void* pvData, int cubData)
	{
		return 1;
	}

	int remote_storage::FileWriteStreamClose(unsigned long long hStream)
	{
		return 1;
	}

	int remote_storage::FileWriteStreamCancel(unsigned long long hStream)
	{
		return 1;
	}

	bool remote_storage::FileExists(const char* pchFile)
	{
		return true;
	}

	bool remote_storage::FilePersisted(const char* pchFile)
	{
		return true;
	}

	int remote_storage::GetFileSize(const char* pchFile)
	{
		return 0;
	}

	long long remote_storage::GetFileTimestamp(const char* pchFile)
	{
		return 0;
	}

	unsigned remote_storage::GetSyncPlatforms(const char* pchFile)
	{
		return 0;
	}

	int remote_storage::GetFileCount()
	{
		return 0;
	}

	const char* remote_storage::GetFileNameAndSize(int iFile, int* pnFileSizeInBytes)
	{
		*pnFileSizeInBytes = 0;
		return "";
	}

	bool remote_storage::GetQuota(int* pnTotalBytes, int* puAvailableBytes)
	{
		*pnTotalBytes = 0x10000000;
		*puAvailableBytes = 0x10000000;
		return false;
	}

	bool remote_storage::IsCloudEnabledForAccount()
	{
		return false;
	}

	bool remote_storage::IsCloudEnabledForApp()
	{
		return false;
	}

	void remote_storage::SetCloudEnabledForApp(bool bEnabled)
	{
	}

	unsigned long long remote_storage::UGCDownload(unsigned long long hContent, unsigned int uUnk)
	{
		return 0;
	}

	bool remote_storage::GetUGCDownloadProgress(unsigned long long hContent, unsigned int* puDownloadedBytes,
	                                            unsigned int* puTotalBytes)
	{
		return false;
	}

	bool remote_storage::GetUGCDetails(unsigned long long hContent, unsigned int* pnAppID, char** ppchName,
	                                   int* pnFileSizeInBytes, steam_id* pSteamIDOwner)
	{
		return false;
	}

	int remote_storage::UGCRead(unsigned long long hContent, void* pvData, int cubDataToRead, unsigned int uOffset)
	{
		return 0;
	}

	int remote_storage::GetCachedUGCCount()
	{
		return 0;
	}

	unsigned long long remote_storage::GetCachedUGCHandle(int iCachedContent)
	{
		return 0;
	}

	unsigned long long remote_storage::PublishWorkshopFile(const char* pchFile, const char* pchPreviewFile,
	                                                       unsigned int nConsumerAppId, const char* pchTitle,
	                                                       const char* pchDescription, unsigned int eVisibility,
	                                                       int* pTags, unsigned int eWorkshopFileType)
	{
		return 0;
	}

	unsigned long long remote_storage::CreatePublishedFileUpdateRequest(unsigned long long unPublishedFileId)
	{
		return 0;
	}

	bool remote_storage::UpdatePublishedFileFile(unsigned long long hUpdateRequest, const char* pchFile)
	{
		return false;
	}

	bool remote_storage::UpdatePublishedFilePreviewFile(unsigned long long hUpdateRequest, const char* pchPreviewFile)
	{
		return false;
	}

	bool remote_storage::UpdatePublishedFileTitle(unsigned long long hUpdateRequest, const char* pchTitle)
	{
		return false;
	}

	bool remote_storage::UpdatePublishedFileDescription(unsigned long long hUpdateRequest, const char* pchDescription)
	{
		return false;
	}

	bool remote_storage::UpdatePublishedFileVisibility(unsigned long long hUpdateRequest, unsigned int eVisibility)
	{
		return false;
	}

	bool remote_storage::UpdatePublishedFileTags(unsigned long long hUpdateRequest, int* pTags)
	{
		return false;
	}

	unsigned long long remote_storage::CommitPublishedFileUpdate(unsigned long long hUpdateRequest)
	{
		return 0;
	}

	unsigned long long remote_storage::GetPublishedFileDetails(unsigned long long unPublishedFileId)
	{
		return 0;
	}

	unsigned long long remote_storage::DeletePublishedFile(unsigned long long unPublishedFileId)
	{
		return 0;
	}

	unsigned long long remote_storage::EnumerateUserPublishedFiles(unsigned int uStartIndex)
	{
		return 0;
	}

	unsigned long long remote_storage::SubscribePublishedFile(unsigned long long unPublishedFileId)
	{
		return 0;
	}

	unsigned long long remote_storage::EnumerateUserSubscribedFiles(unsigned int uStartIndex)
	{
		return 0;
	}

	unsigned long long remote_storage::UnsubscribePublishedFile(unsigned long long unPublishedFileId)
	{
		return 0;
	}

	bool remote_storage::UpdatePublishedFileSetChangeDescription(unsigned long long hUpdateRequest,
	                                                             const char* cszDescription)
	{
		return false;
	}

	unsigned long long remote_storage::GetPublishedItemVoteDetails(unsigned long long unPublishedFileId)
	{
		return 0;
	}

	unsigned long long remote_storage::UpdateUserPublishedItemVote(unsigned long long unPublishedFileId, bool bVoteUp)
	{
		return 0;
	}

	unsigned long long remote_storage::GetUserPublishedItemVoteDetails(unsigned long long unPublishedFileId)
	{
		return 0;
	}

	unsigned long long remote_storage::EnumerateUserSharedWorkshopFiles(unsigned int nAppId, steam_id creatorSteamID,
	                                                                    unsigned int uStartIndex, int* pRequiredTags,
	                                                                    int* pExcludedTags)
	{
		return 0;
	}

	unsigned long long remote_storage::PublishVideo(unsigned int eVideoProvider, const char* cszVideoAccountName,
	                                                const char* cszVideoIdentifier, const char* cszFileName,
	                                                unsigned int nConsumerAppId, const char* cszTitle,
	                                                const char* cszDescription, unsigned int eVisibility, int* pTags)
	{
		return 0;
	}

	unsigned long long remote_storage::SetUserPublishedFileAction(unsigned long long unPublishedFileId,
	                                                              unsigned int eAction)
	{
		return 0;
	}

	unsigned long long remote_storage::EnumeratePublishedFilesByUserAction(
		unsigned int eAction, unsigned int uStartIndex)
	{
		return 0;
	}

	unsigned long long remote_storage::EnumeratePublishedWorkshopFiles(unsigned int eType, unsigned int uStartIndex,
	                                                                   unsigned int cDays, unsigned int cCount,
	                                                                   int* pTags, int* pUserTags)
	{
		return 0;
	}

	unsigned long long remote_storage::UGCDownloadToLocation(unsigned long long hContent, const char* cszLocation,
	                                                         unsigned int uUnk)
	{
		return 0;
	}
}

```

`src/client/steam/interfaces/remote_storage.hpp`:

```hpp
#pragma once

namespace steam
{
	class remote_storage
	{
	public:
		~remote_storage() = default;

		virtual bool FileWrite(const char* pchFile, const void* pvData, int cubData);
		virtual int FileRead(const char* pchFile, void* pvData, int cubDataToRead);
		virtual bool FileForget(const char* pchFile);
		virtual bool FileDelete(const char* pchFile);
		virtual unsigned long long FileShare(const char* pchFile);
		virtual bool SetSyncPlatforms(const char* pchFile, unsigned int eRemoteStoragePlatform);
		virtual unsigned long long FileWriteStreamOpen(const char* pchFile);
		virtual int FileWriteStreamWriteChunk(unsigned long long hStream, const void* pvData, int cubData);
		virtual int FileWriteStreamClose(unsigned long long hStream);
		virtual int FileWriteStreamCancel(unsigned long long hStream);
		virtual bool FileExists(const char* pchFile);
		virtual bool FilePersisted(const char* pchFile);
		virtual int GetFileSize(const char* pchFile);
		virtual long long GetFileTimestamp(const char* pchFile);
		virtual unsigned int GetSyncPlatforms(const char* pchFile);
		virtual int GetFileCount();
		virtual const char* GetFileNameAndSize(int iFile, int* pnFileSizeInBytes);
		virtual bool GetQuota(int* pnTotalBytes, int* puAvailableBytes);
		virtual bool IsCloudEnabledForAccount();
		virtual bool IsCloudEnabledForApp();
		virtual void SetCloudEnabledForApp(bool bEnabled);
		virtual unsigned long long UGCDownload(unsigned long long hContent, unsigned int uUnk);
		virtual bool GetUGCDownloadProgress(unsigned long long hContent, unsigned int* puDownloadedBytes,
		                                    unsigned int* puTotalBytes);
		virtual bool GetUGCDetails(unsigned long long hContent, unsigned int* pnAppID, char** ppchName,
		                           int* pnFileSizeInBytes, steam_id* pSteamIDOwner);
		virtual int UGCRead(unsigned long long hContent, void* pvData, int cubDataToRead, unsigned int uOffset);
		virtual int GetCachedUGCCount();
		virtual unsigned long long GetCachedUGCHandle(int iCachedContent);
		virtual unsigned long long PublishWorkshopFile(const char* pchFile, const char* pchPreviewFile,
		                                               unsigned int nConsumerAppId, const char* pchTitle,
		                                               const char* pchDescription, unsigned int eVisibility, int* pTags,
		                                               unsigned int eWorkshopFileType);
		virtual unsigned long long CreatePublishedFileUpdateRequest(unsigned long long unPublishedFileId);
		virtual bool UpdatePublishedFileFile(unsigned long long hUpdateRequest, const char* pchFile);
		virtual bool UpdatePublishedFilePreviewFile(unsigned long long hUpdateRequest, const char* pchPreviewFile);
		virtual bool UpdatePublishedFileTitle(unsigned long long hUpdateRequest, const char* pchTitle);
		virtual bool UpdatePublishedFileDescription(unsigned long long hUpdateRequest, const char* pchDescription);
		virtual bool UpdatePublishedFileVisibility(unsigned long long hUpdateRequest, unsigned int eVisibility);
		virtual bool UpdatePublishedFileTags(unsigned long long hUpdateRequest, int* pTags);
		virtual unsigned long long CommitPublishedFileUpdate(unsigned long long hUpdateRequest);
		virtual unsigned long long GetPublishedFileDetails(unsigned long long unPublishedFileId);
		virtual unsigned long long DeletePublishedFile(unsigned long long unPublishedFileId);
		virtual unsigned long long EnumerateUserPublishedFiles(unsigned int uStartIndex);
		virtual unsigned long long SubscribePublishedFile(unsigned long long unPublishedFileId);
		virtual unsigned long long EnumerateUserSubscribedFiles(unsigned int uStartIndex);
		virtual unsigned long long UnsubscribePublishedFile(unsigned long long unPublishedFileId);
		virtual bool UpdatePublishedFileSetChangeDescription(unsigned long long hUpdateRequest,
		                                                     const char* cszDescription);
		virtual unsigned long long GetPublishedItemVoteDetails(unsigned long long unPublishedFileId);
		virtual unsigned long long UpdateUserPublishedItemVote(unsigned long long unPublishedFileId, bool bVoteUp);
		virtual unsigned long long GetUserPublishedItemVoteDetails(unsigned long long unPublishedFileId);
		virtual unsigned long long EnumerateUserSharedWorkshopFiles(unsigned int nAppId, steam_id creatorSteamID,
		                                                            unsigned int uStartIndex, int* pRequiredTags,
		                                                            int* pExcludedTags);
		virtual unsigned long long PublishVideo(unsigned int eVideoProvider, const char* cszVideoAccountName,
		                                        const char* cszVideoIdentifier, const char* cszFileName,
		                                        unsigned int nConsumerAppId, const char* cszTitle,
		                                        const char* cszDescription, unsigned int eVisibility, int* pTags);
		virtual unsigned long long SetUserPublishedFileAction(unsigned long long unPublishedFileId,
		                                                      unsigned int eAction);
		virtual unsigned long long EnumeratePublishedFilesByUserAction(unsigned int eAction, unsigned int uStartIndex);
		virtual unsigned long long EnumeratePublishedWorkshopFiles(unsigned int eType, unsigned int uStartIndex,
		                                                           unsigned int cDays, unsigned int cCount, int* pTags,
		                                                           int* pUserTags);
		virtual unsigned long long UGCDownloadToLocation(unsigned long long hContent, const char* cszLocation,
		                                                 unsigned int uUnk);
	};
}

```

`src/client/steam/interfaces/screenshots.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

namespace steam
{
	uint64_t screenshots::WriteScreenshot(void* pubRGB, uint32_t cubRGB, int nWidth, int nHeight)
	{
		return 0;
	}

	uint64_t screenshots::AddScreenshotToLibrary(const char* pchFilename, const char* pchThumbnailFilename, int nWidth,
	                                             int nHeight)
	{
		return 0;
	}

	void screenshots::TriggerScreenshot()
	{
	}

	void screenshots::HookScreenshots(bool bHook)
	{
	}

	bool screenshots::SetLocation(uint64_t hScreenshot, const char* pchLocation)
	{
		return false;
	}

	bool screenshots::TagUser(uint64_t hScreenshot, steam_id steamID)
	{
		return false;
	}

	bool screenshots::TagPublishedFile(uint64_t hScreenshot, uint64_t unPublishedFileID)
	{
		return false;
	}
}

```

`src/client/steam/interfaces/screenshots.hpp`:

```hpp
#pragma once

namespace steam
{
	class screenshots
	{
	public:
		~screenshots() = default;

		virtual uint64_t WriteScreenshot(void* pubRGB, uint32_t cubRGB, int nWidth, int nHeight);
		virtual uint64_t AddScreenshotToLibrary(const char* pchFilename, const char* pchThumbnailFilename, int nWidth,
		                                        int nHeight);
		virtual void TriggerScreenshot();
		virtual void HookScreenshots(bool bHook);
		virtual bool SetLocation(uint64_t hScreenshot, const char* pchLocation);
		virtual bool TagUser(uint64_t hScreenshot, steam_id steamID);
		virtual bool TagPublishedFile(uint64_t hScreenshot, uint64_t unPublishedFileID);
	};
}

```

`src/client/steam/interfaces/ugc.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

#include <utils/nt.hpp>

#include "component/steam_proxy.hpp"

namespace steam
{
	uint64_t ugc::CreateQueryUserUGCRequest(uint_least32_t unAccountID, uint32_t eListType,
	                                        uint32_t eMatchingUGCType,
	                                        uint32_t eSortOrder, uint32_t nCreatorAppID,
	                                        uint32_t nConsumerAppID, uint32_t unPage)
	{
		return 0;
	}

	uint64_t ugc::CreateQueryAllUGCRequest(uint32_t eQueryType,
	                                       uint32_t eMatchingeMatchingUGCTypeFileType,
	                                       uint32_t nCreatorAppID, uint32_t nConsumerAppID,
	                                       uint32_t unPage)
	{
		return 0;
	}

	uint64_t ugc::CreateQueryUGCDetailsRequest(uint64_t* pvecPublishedFileID,
	                                           uint32_t unNumPublishedFileIDs)
	{
		return 0;
	}

	uint64_t ugc::SendQueryUGCRequest(uint64_t handle)
	{
		return 0;
	}

	bool ugc::GetQueryUGCResult(uint64_t handle, uint32_t index, void* pDetails)
	{
		return false;
	}

	bool ugc::GetQueryUGCPreviewURL(uint64_t handle, uint32_t index, char* pchURL, uint32_t cchURLSize)
	{
		return false;
	}

	bool ugc::GetQueryUGCMetadata(uint64_t handle, uint32_t index, char* pchMetadata,
	                              uint32_t cchMetadatasize)
	{
		return false;
	}

	bool ugc::GetQueryUGCChildren(uint64_t handle, uint32_t index, uint64_t* pvecPublishedFileID,
	                              uint32_t cMaxEntries)
	{
		return false;
	}

	bool ugc::GetQueryUGCStatistic(uint64_t handle, uint32_t index, uint32_t eStatType,
	                               uint32_t* pStatValue)
	{
		return false;
	}

	uint32_t ugc::GetQueryUGCNumAdditionalPreviews(uint64_t handle, uint32_t index)
	{
		return 0;
	}

	bool ugc::GetQueryUGCAdditionalPreview(uint64_t handle, uint32_t index, uint32_t previewIndex,
	                                       char* pchURLOrVideoID, uint32_t cchURLSize, char* pchOriginalFileName,
	                                       uint32_t cchOriginalFileNameSize, void* pPreviewType)
	{
		return false;
	}

	uint32_t ugc::GetQueryUGCNumKeyValueTags(uint64_t handle, uint32_t index)
	{
		return 0;
	}

	bool ugc::GetQueryUGCKeyValueTag(uint64_t handle, uint32_t index, uint32_t keyValueTagIndex,
	                                 char* pchKey, uint32_t cchKeySize, char* pchValue, uint32_t cchValueSize)
	{
		return false;
	}

	bool ugc::ReleaseQueryUGCRequest(uint64_t handle)
	{
		return false;
	}

	bool ugc::AddRequiredTag(uint64_t handle, const char* pTagName)
	{
		return false;
	}

	bool ugc::AddExcludedTag(uint64_t handle, const char* pTagName)
	{
		return false;
	}

	bool ugc::SetReturnKeyValueTags(uint64_t handle, bool bReturnKeyValueTags)
	{
		return false;
	}

	bool ugc::SetReturnLongDescription(uint64_t handle, bool bReturnLongDescription)
	{
		return false;
	}

	bool ugc::SetReturnMetadata(uint64_t handle, bool bReturnMetadata)
	{
		return false;
	}

	bool ugc::SetReturnChildren(uint64_t handle, bool bReturnChildren)
	{
		return false;
	}

	bool ugc::SetReturnAdditionalPreviews(uint64_t handle, bool bReturnAdditionalPreviews)
	{
		return false;
	}

	bool ugc::SetReturnTotalOnly(uint64_t handle, bool bReturnTotalOnly)
	{
		return false;
	}

	bool ugc::SetLanguage(uint64_t handle, const char* pchLanguage)
	{
		return false;
	}

	bool ugc::SetAllowCachedResponse(uint64_t handle, uint32_t unMaxAgeSeconds)
	{
		return false;
	}

	bool ugc::SetCloudFileNameFilter(uint64_t handle, const char* pMatchCloudFileName)
	{
		return false;
	}

	bool ugc::SetMatchAnyTag(uint64_t handle, bool bMatchAnyTag)
	{
		return false;
	}

	bool ugc::SetSearchText(uint64_t handle, const char* pSearchText)
	{
		return false;
	}

	bool ugc::SetRankedByTrendDays(uint64_t handle, uint32_t unDays)
	{
		return false;
	}

	bool ugc::AddRequiredKeyValueTag(uint64_t handle, const char* pKey, const char* pValue)
	{
		return false;
	}

	uint64_t ugc::RequestUGCDetails(uint64_t nPublishedFileID, uint32_t unMaxAgeSeconds)
	{
		return 0;
	}

	uint64_t ugc::CreateItem(uint32_t nConsumerAppId, uint32_t eFileType)
	{
		return 0;
	}

	uint64_t ugc::StartItemUpdate(uint32_t nConsumerAppId, uint64_t nPublishedFileID)
	{
		return 0;
	}

	bool ugc::SetItemTitle(uint64_t handle, const char* pchTitle)
	{
		return false;
	}

	bool ugc::SetItemDescription(uint64_t handle, const char* pchDescription)
	{
		return false;
	}

	bool ugc::SetItemUpdateLanguage(uint64_t handle, const char* pchUpdateLanguage)
	{
		return false;
	}

	bool ugc::SetItemMetadata(uint64_t handle, const char* pchMetadata)
	{
		return false;
	}

	bool ugc::SetItemVisibility(uint64_t handle, uint32_t eVisibility)
	{
		return false;
	}

	bool ugc::SetItemTags(uint64_t updateHandle, const void* pTags)
	{
		return false;
	}

	bool ugc::SetItemContent(uint64_t handle, const char* pszContentFolder)
	{
		return false;
	}

	bool ugc::SetItemPreview(uint64_t handle, const char* pszPreviewFile)
	{
		return false;
	}

	bool ugc::RemoveItemKeyValueTags(uint64_t handle, const char* pchKey)
	{
		return false;
	}

	bool ugc::AddItemKeyValueTag(uint64_t handle, const char* pchKey, const char* pchValue)
	{
		return false;
	}

	bool ugc::AddItemPreviewFile(uint64_t handle, const char* pszPreviewFile, uint32_t type)
	{
		return false;
	}

	bool ugc::AddItemPreviewVideo(uint64_t handle, const char* pszVideoID)
	{
		return false;
	}

	bool ugc::UpdateItemPreviewFile(uint64_t handle, uint32_t index, const char* pszPreviewFile)
	{
		return false;
	}

	bool ugc::UpdateItemPreviewVideo(uint64_t handle, uint32_t index, const char* pszVideoID)
	{
		return false;
	}

	bool ugc::RemoveItemPreview(uint64_t handle, uint32_t index)
	{
		return false;
	}


	uint64_t ugc::SubmitItemUpdate(uint64_t handle, const char* pchChangeNote)
	{
		return 0;
	}

	uint32_t ugc::GetItemUpdateProgress(uint64_t handle, uint64_t* punBytesProcessed,
	                                    uint64_t* punBytesTotal)
	{
		return 0;
	}

	uint64_t ugc::SetUserItemVote(uint64_t nPublishedFileID, bool bVoteUp)
	{
		return 0;
	}

	uint64_t ugc::GetUserItemVote(uint64_t nPublishedFileID)
	{
		return 0;
	}

	uint64_t ugc::AddItemToFavorites(uint32_t nAppId, uint64_t nPublishedFileID)
	{
		return 0;
	}

	uint64_t ugc::RemoveItemFromFavorites(uint32_t nAppId, uint64_t nPublishedFileID)
	{
		return 0;
	}

	uint64_t ugc::SubscribeItem(uint64_t nPublishedFileID)
	{
		return 0;
	}

	uint64_t ugc::UnsubscribeItem(uint64_t nPublishedFileID)
	{
		return 0;
	}

	uint32_t ugc::GetNumSubscribedItems()
	{
		::steam_proxy::update_subscribed_items();

		uint32_t count = 0;
		::steam_proxy::access_subscribed_items([&](const steam_proxy::subscribed_item_map& items)
		{
			count = static_cast<uint32_t>(items.size());
		});

		return count;
	}

	uint32_t ugc::GetSubscribedItems(uint64_t* pvecPublishedFileID, uint32_t cMaxEntries)
	{
		uint32_t count = 0;
		::steam_proxy::access_subscribed_items([&](const steam_proxy::subscribed_item_map& items)
		{
			for (const auto& item : items)
			{
				if (count < cMaxEntries)
				{
					pvecPublishedFileID[count] = item.first;
					++count;
				}
			}
		});

		return count;
	}

	uint32_t ugc::GetItemState(uint64_t nPublishedFileID)
	{
		uint32_t state = 0;
		::steam_proxy::access_subscribed_items([&](const steam_proxy::subscribed_item_map& items)
		{
			const auto entry = items.find(nPublishedFileID);
			if (entry != items.end())
			{
				state = entry->second.state;
			}
		});

		return state;
	}

	bool ugc::GetItemInstallInfo(uint64_t nPublishedFileID, uint64_t* punSizeOnDisk, char* pchFolder,
	                             uint32_t cchFolderSize, uint32_t* punTimeStamp)
	{
		bool found = false;
		::steam_proxy::access_subscribed_items([&](const steam_proxy::subscribed_item_map& items)
		{
			const auto entry = items.find(nPublishedFileID);
			if (entry != items.end())
			{
				const auto& item = entry->second;
				found = item.available;
				memcpy(pchFolder, item.path.data(),
				       std::min(item.path.size() + 1, static_cast<size_t>(cchFolderSize)));
				pchFolder[cchFolderSize - 1] = 0;

				*punSizeOnDisk = item.size_on_disk;
				*punTimeStamp = item.time_stamp;
			}
		});

		return found;
	}

	bool ugc::GetItemDownloadInfo(uint64_t nPublishedFileID, uint64_t* punBytesDownloaded,
	                              uint64_t* punBytesTotal)
	{
		return false;
	}

	bool ugc::DownloadItem(uint64_t nPublishedFileID, bool bHighPriority)
	{
		return false;
	}

	bool ugc::BInitWorkshopForGameServer(uint64_t unWorkshopDepotID, const char* pszFolder)
	{
		return false;
	}

	void ugc::SuspendDownloads(bool bSuspend)
	{
	}

	uint64_t ugc::StartPlaytimeTracking(uint64_t* pvecPublishedFileID,
	                                    uint32_t unNumPublishedFileIDs)
	{
		return 0;
	}

	uint64_t ugc::StopPlaytimeTracking(uint64_t* pvecPublishedFileID,
	                                   uint32_t unNumPublishedFileIDs)
	{
		return 0;
	}

	uint64_t ugc::StopPlaytimeTrackingForAllItems()
	{
		return 0;
	}
}

```

`src/client/steam/interfaces/ugc.hpp`:

```hpp
#pragma once

namespace steam
{
	class ugc
	{
	public:
		~ugc() = default;

		virtual uint64_t CreateQueryUserUGCRequest(uint_least32_t unAccountID, uint32_t eListType,
		                                           uint32_t eMatchingUGCType,
		                                           uint32_t eSortOrder, uint32_t nCreatorAppID,
		                                           uint32_t nConsumerAppID, uint32_t unPage);
		virtual uint64_t CreateQueryAllUGCRequest(uint32_t eQueryType,
		                                          uint32_t eMatchingeMatchingUGCTypeFileType,
		                                          uint32_t nCreatorAppID, uint32_t nConsumerAppID,
		                                          uint32_t unPage);

		virtual uint64_t CreateQueryUGCDetailsRequest(uint64_t* pvecPublishedFileID,
		                                              uint32_t unNumPublishedFileIDs);
		virtual uint64_t SendQueryUGCRequest(uint64_t handle);

		virtual bool GetQueryUGCResult(uint64_t handle, uint32_t index, void* pDetails);

		virtual bool GetQueryUGCPreviewURL(uint64_t handle, uint32_t index, char* pchURL, uint32_t cchURLSize);
		virtual bool GetQueryUGCMetadata(uint64_t handle, uint32_t index, char* pchMetadata,
		                                 uint32_t cchMetadatasize);
		virtual bool GetQueryUGCChildren(uint64_t handle, uint32_t index, uint64_t* pvecPublishedFileID,
		                                 uint32_t cMaxEntries);
		virtual bool GetQueryUGCStatistic(uint64_t handle, uint32_t index, uint32_t eStatType,
		                                  uint32_t* pStatValue);

		virtual uint32_t GetQueryUGCNumAdditionalPreviews(uint64_t handle, uint32_t index);
		virtual bool GetQueryUGCAdditionalPreview(uint64_t handle, uint32_t index, uint32_t previewIndex,
		                                          char* pchURLOrVideoID, uint32_t cchURLSize, char* pchOriginalFileName,
		                                          uint32_t cchOriginalFileNameSize, void* pPreviewType);
		virtual uint32_t GetQueryUGCNumKeyValueTags(uint64_t handle, uint32_t index);
		virtual bool GetQueryUGCKeyValueTag(uint64_t handle, uint32_t index, uint32_t keyValueTagIndex,
		                                    char* pchKey, uint32_t cchKeySize, char* pchValue, uint32_t cchValueSize);

		virtual bool ReleaseQueryUGCRequest(uint64_t handle);

		virtual bool AddRequiredTag(uint64_t handle, const char* pTagName);
		virtual bool AddExcludedTag(uint64_t handle, const char* pTagName);
		virtual bool SetReturnKeyValueTags(uint64_t handle, bool bReturnKeyValueTags);
		virtual bool SetReturnLongDescription(uint64_t handle, bool bReturnLongDescription);
		virtual bool SetReturnMetadata(uint64_t handle, bool bReturnMetadata);
		virtual bool SetReturnChildren(uint64_t handle, bool bReturnChildren);
		virtual bool SetReturnAdditionalPreviews(uint64_t handle, bool bReturnAdditionalPreviews);
		virtual bool SetReturnTotalOnly(uint64_t handle, bool bReturnTotalOnly);
		virtual bool SetLanguage(uint64_t handle, const char* pchLanguage);
		virtual bool SetAllowCachedResponse(uint64_t handle, uint32_t unMaxAgeSeconds);

		virtual bool SetCloudFileNameFilter(uint64_t handle, const char* pMatchCloudFileName);

		virtual bool SetMatchAnyTag(uint64_t handle, bool bMatchAnyTag);
		virtual bool SetSearchText(uint64_t handle, const char* pSearchText);
		virtual bool SetRankedByTrendDays(uint64_t handle, uint32_t unDays);

		virtual bool AddRequiredKeyValueTag(uint64_t handle, const char* pKey, const char* pValue);

		virtual uint64_t RequestUGCDetails(uint64_t nPublishedFileID, uint32_t unMaxAgeSeconds);

		virtual uint64_t CreateItem(uint32_t nConsumerAppId, uint32_t eFileType);

		virtual uint64_t StartItemUpdate(uint32_t nConsumerAppId, uint64_t nPublishedFileID);

		virtual bool SetItemTitle(uint64_t handle, const char* pchTitle);
		virtual bool SetItemDescription(uint64_t handle, const char* pchDescription);
		virtual bool SetItemUpdateLanguage(uint64_t handle, const char* pchUpdateLanguage);
		virtual bool SetItemMetadata(uint64_t handle, const char* pchMetadata);
		virtual bool SetItemVisibility(uint64_t handle, uint32_t eVisibility);
		virtual bool SetItemTags(uint64_t updateHandle, const void* pTags);
		virtual bool SetItemContent(uint64_t handle, const char* pszContentFolder);
		virtual bool SetItemPreview(uint64_t handle, const char* pszPreviewFile);
		virtual bool RemoveItemKeyValueTags(uint64_t handle, const char* pchKey);
		virtual bool AddItemKeyValueTag(uint64_t handle, const char* pchKey, const char* pchValue);

		virtual bool AddItemPreviewFile(uint64_t handle, const char* pszPreviewFile, uint32_t type);
		virtual bool AddItemPreviewVideo(uint64_t handle, const char* pszVideoID);
		virtual bool UpdateItemPreviewFile(uint64_t handle, uint32_t index, const char* pszPreviewFile);
		virtual bool UpdateItemPreviewVideo(uint64_t handle, uint32_t index, const char* pszVideoID);
		virtual bool RemoveItemPreview(uint64_t handle, uint32_t index);


		virtual uint64_t SubmitItemUpdate(uint64_t handle, const char* pchChangeNote);
		virtual uint32_t GetItemUpdateProgress(uint64_t handle, uint64_t* punBytesProcessed,
		                                       uint64_t* punBytesTotal);

		virtual uint64_t SetUserItemVote(uint64_t nPublishedFileID, bool bVoteUp);
		virtual uint64_t GetUserItemVote(uint64_t nPublishedFileID);

		virtual uint64_t AddItemToFavorites(uint32_t nAppId, uint64_t nPublishedFileID);
		virtual uint64_t RemoveItemFromFavorites(uint32_t nAppId, uint64_t nPublishedFileID);

		virtual uint64_t SubscribeItem(uint64_t nPublishedFileID);
		virtual uint64_t UnsubscribeItem(uint64_t nPublishedFileID);
		virtual uint32_t GetNumSubscribedItems();
		virtual uint32_t GetSubscribedItems(uint64_t* pvecPublishedFileID, uint32_t cMaxEntries);

		virtual uint32_t GetItemState(uint64_t nPublishedFileID);
		virtual bool GetItemInstallInfo(uint64_t nPublishedFileID, uint64_t* punSizeOnDisk, char* pchFolder,
		                                uint32_t cchFolderSize, uint32_t* punTimeStamp);
		virtual bool GetItemDownloadInfo(uint64_t nPublishedFileID, uint64_t* punBytesDownloaded,
		                                 uint64_t* punBytesTotal);
		virtual bool DownloadItem(uint64_t nPublishedFileID, bool bHighPriority);
		virtual bool BInitWorkshopForGameServer(uint64_t unWorkshopDepotID, const char* pszFolder);
		virtual void SuspendDownloads(bool bSuspend);

		virtual uint64_t StartPlaytimeTracking(uint64_t* pvecPublishedFileID,
		                                       uint32_t unNumPublishedFileIDs);
		virtual uint64_t StopPlaytimeTracking(uint64_t* pvecPublishedFileID,
		                                      uint32_t unNumPublishedFileIDs);
		virtual uint64_t StopPlaytimeTrackingForAllItems();
	};
}

```

`src/client/steam/interfaces/unified_messages.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

namespace steam
{
	ClientUnifiedMessageHandle unified_messages::SendMethod(const char* pchServiceMethod, const void* pRequestBuffer,
	                                                        uint32_t unRequestBufferSize, uint64_t unContext)
	{
		return 0;
	}

	bool unified_messages::GetMethodResponseInfo(ClientUnifiedMessageHandle hHandle, uint32_t* punResponseSize,
	                                             uint32_t* peResult)
	{
		return false;
	}

	bool unified_messages::GetMethodResponseData(ClientUnifiedMessageHandle hHandle, void* pResponseBuffer,
	                                             uint32_t unResponseBufferSize, bool bAutoRelease)
	{
		return false;
	}

	bool unified_messages::ReleaseMethod(ClientUnifiedMessageHandle hHandle)
	{
		return false;
	}

	bool unified_messages::SendNotification(const char* pchServiceNotification, const void* pNotificationBuffer,
	                                        uint32_t unNotificationBufferSize)
	{
		return false;
	}
}

```

`src/client/steam/interfaces/unified_messages.hpp`:

```hpp
#pragma once

namespace steam
{
	using ClientUnifiedMessageHandle = uint64_t;

	class unified_messages
	{
	public:
		~unified_messages() = default;

		virtual ClientUnifiedMessageHandle SendMethod(const char* pchServiceMethod, const void* pRequestBuffer,
		                                              uint32_t unRequestBufferSize, uint64_t unContext);
		virtual bool GetMethodResponseInfo(ClientUnifiedMessageHandle hHandle, uint32_t* punResponseSize,
		                                   uint32_t* peResult);
		virtual bool GetMethodResponseData(ClientUnifiedMessageHandle hHandle, void* pResponseBuffer,
		                                   uint32_t unResponseBufferSize, bool bAutoRelease);
		virtual bool ReleaseMethod(ClientUnifiedMessageHandle hHandle);
		virtual bool SendNotification(const char* pchServiceNotification, const void* pNotificationBuffer,
		                              uint32_t unNotificationBufferSize);
	};
}

```

`src/client/steam/interfaces/user.cpp`:

```cpp
#include <std_include.hpp>

#include "../steam.hpp"
#include "../../component/auth.hpp"


namespace steam
{
	namespace
	{
		std::string auth_ticket;

		steam_id generate_steam_id()
		{
			steam_id id{};
			id.bits = auth::get_guid();
			return id;
		}
	}

	int user::GetHSteamUser()
	{
		return 1;
	}

	bool user::LoggedOn()
	{
		return true;
	}

	steam_id user::GetSteamID()
	{
		static auto id = generate_steam_id();
		return id;
	}

	int user::InitiateGameConnection(void* pAuthBlob, int cbMaxAuthBlob, steam_id steamIDGameServer,
	                                 unsigned int unIPServer, unsigned short usPortServer, bool bSecure)
	{
		return 0;
	}

	void user::TerminateGameConnection(unsigned int unIPServer, unsigned short usPortServer)
	{
	}

	void user::TrackAppUsageEvent(steam_id gameID, int eAppUsageEvent, const char* pchExtraInfo)
	{
	}

	bool user::GetUserDataFolder(char* pchBuffer, int cubBuffer)
	{
		return false;
	}

	void user::StartVoiceRecording()
	{
	}

	void user::StopVoiceRecording()
	{
	}

	int user::GetAvailableVoice(unsigned int* pcbCompressed, unsigned int* pcbUncompressed,
	                            unsigned int nUncompressedVoiceDesiredSampleRate)
	{
		return 0;
	}

	int user::GetVoice(bool bWantCompressed, void* pDestBuffer, unsigned int cbDestBufferSize,
	                   unsigned int* nBytesWritten, bool bWantUncompressed, void* pUncompressedDestBuffer,
	                   unsigned int cbUncompressedDestBufferSize, unsigned int* nUncompressBytesWritten,
	                   unsigned int nUncompressedVoiceDesiredSampleRate)
	{
		return 2;
	}

	int user::DecompressVoice(void* pCompressed, unsigned int cbCompressed, void* pDestBuffer,
	                          unsigned int cbDestBufferSize, unsigned int* nBytesWritten)
	{
		return 0;
	}

	unsigned int user::GetVoiceOptimalSampleRate()
	{
		return 0;
	}

	unsigned int user::GetAuthSessionTicket(void* pTicket, int cbMaxTicket, unsigned int* pcbTicket)
	{
		static uint32_t ticket = 0;
		*pcbTicket = 1;

		const auto result = callbacks::register_call();
		auto* response = static_cast<get_auth_session_ticket_response*>(calloc(
			1, sizeof(get_auth_session_ticket_response)));
		response->m_h_auth_ticket = ++ticket;
		response->m_e_result = 1; // k_EResultOK;

		callbacks::return_call(response, sizeof(get_auth_session_ticket_response),
		                       get_auth_session_ticket_response::callback_id, result);
		return response->m_h_auth_ticket;
	}

	int user::BeginAuthSession(const void* pAuthTicket, int cbAuthTicket, steam_id steamID)
	{
		return 0;
	}

	void user::EndAuthSession(steam_id steamID)
	{
	}

	void user::CancelAuthTicket(unsigned int hAuthTicket)
	{
	}

	unsigned int user::UserHasLicenseForApp(steam_id steamID, unsigned int appID)
	{
		return 1;
	}

	bool user::BIsBehindNAT()
	{
		return false;
	}

	void user::AdvertiseGame(steam_id steamIDGameServer, unsigned int unIPServer, unsigned short usPortServer)
	{
	}

	unsigned long long user::RequestEncryptedAppTicket(void* pUserData, int cbUserData)
	{
		const auto id = this->GetSteamID();

		auth_ticket = "BOIII";
		auth_ticket.resize(32);
		auth_ticket.append(static_cast<char*>(pUserData), 24); // key
		auth_ticket.append(reinterpret_cast<const char*>(&id.bits), sizeof(id.bits)); // user id
		auth_ticket.append(&static_cast<char*>(pUserData)[24], 64); // user name

		// Create the call response
		const auto result = callbacks::register_call();
		const auto retvals = static_cast<encrypted_app_ticket_response*>(calloc(
			1, sizeof(encrypted_app_ticket_response)));
		//::Utils::Memory::AllocateArray<EncryptedAppTicketResponse>();
		retvals->m_e_result = 1;

		// Return the call response
		callbacks::return_call(retvals, sizeof(encrypted_app_ticket_response),
		                       encrypted_app_ticket_response::callback_id, result);

		return result;
	}

	bool user::GetEncryptedAppTicket(void* pTicket, int cbMaxTicket, unsigned int* pcbTicket)
	{
		if (cbMaxTicket < 0 || auth_ticket.empty()) return false;

		const auto size = auth_ticket.size();
		if (size_t(cbMaxTicket) < size)
		{
			*pcbTicket = static_cast<unsigned>(size);
			return false;
		}

		std::memcpy(pTicket, auth_ticket.data(), size);
		*pcbTicket = static_cast<unsigned>(size);

		return true;
	}

	int user::GetGameBadgeLevel(int nSeries, bool bFoil)
	{
		return 1;
	}

	int user::GetPlayerSteamLevel()
	{
		return 0;
	}

	uint64_t user::RequestStoreAuthURL(const char* pchRedirectURL)
	{
		return 0;
	}

	bool user::BIsPhoneVerified()
	{
		return true;
	}

	bool user::BIsTwoFactorEnabled()
	{
		return true;
	}

	bool user::BIsPhoneIdentifying()
	{
		return false;
	}

	bool user::BIsPhoneRequiringVerification()
	{
		return false;
	}
}

```

`src/client/steam/interfaces/user.hpp`:

```hpp
#pragma once

namespace steam
{
	struct encrypted_app_ticket_response final
	{
		enum { callback_id = 154 };

		int m_e_result;
	};

	struct get_auth_session_ticket_response
	{
		enum { callback_id = 163 };

		unsigned int m_h_auth_ticket;
		int m_e_result;
	};

	class user
	{
	public:
		~user() = default;

		virtual int GetHSteamUser();
		virtual bool LoggedOn();
		virtual steam_id GetSteamID();

		virtual int InitiateGameConnection(void* pAuthBlob, int cbMaxAuthBlob, steam_id steamIDGameServer,
		                                   unsigned int unIPServer, unsigned short usPortServer, bool bSecure);
		virtual void TerminateGameConnection(unsigned int unIPServer, unsigned short usPortServer);
		virtual void TrackAppUsageEvent(steam_id gameID, int eAppUsageEvent, const char* pchExtraInfo = "");
		virtual bool GetUserDataFolder(char* pchBuffer, int cubBuffer);
		virtual void StartVoiceRecording();
		virtual void StopVoiceRecording();
		virtual int GetAvailableVoice(unsigned int* pcbCompressed, unsigned int* pcbUncompressed,
		                              unsigned int nUncompressedVoiceDesiredSampleRate);
		virtual int GetVoice(bool bWantCompressed, void* pDestBuffer, unsigned int cbDestBufferSize,
		                     unsigned int* nBytesWritten, bool bWantUncompressed, void* pUncompressedDestBuffer,
		                     unsigned int cbUncompressedDestBufferSize, unsigned int* nUncompressBytesWritten,
		                     unsigned int nUncompressedVoiceDesiredSampleRate);
		virtual int DecompressVoice(void* pCompressed, unsigned int cbCompressed, void* pDestBuffer,
		                            unsigned int cbDestBufferSize, unsigned int* nBytesWritten);
		virtual unsigned int GetVoiceOptimalSampleRate();
		virtual unsigned int GetAuthSessionTicket(void* pTicket, int cbMaxTicket, unsigned int* pcbTicket);
		virtual int BeginAuthSession(const void* pAuthTicket, int cbAuthTicket, steam_id steamID);
		virtual void EndAuthSession(steam_id steamID);
		virtual void CancelAuthTicket(unsigned int hAuthTicket);
		virtual unsigned int UserHasLicenseForApp(steam_id steamID, unsigned int appID);
		virtual bool BIsBehindNAT();
		virtual void AdvertiseGame(steam_id steamIDGameServer, unsigned int unIPServer, unsigned short usPortServer);
		virtual unsigned long long RequestEncryptedAppTicket(void* pUserData, int cbUserData);
		virtual bool GetEncryptedAppTicket(void* pTicket, int cbMaxTicket, unsigned int* pcbTicket);

		virtual int GetGameBadgeLevel(int nSeries, bool bFoil);
		virtual int GetPlayerSteamLevel();
		virtual uint64_t RequestStoreAuthURL(const char* pchRedirectURL);
		virtual bool BIsPhoneVerified();
		virtual bool BIsTwoFactorEnabled();
		virtual bool BIsPhoneIdentifying();
		virtual bool BIsPhoneRequiringVerification();
	};
}

```

`src/client/steam/interfaces/user_stats.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

namespace steam
{
	namespace
	{
		struct user_stats_received
		{
			enum { callback_id = 1101 };

			uint64_t m_n_game_id;
			int m_e_result;
			steam_id m_steam_id_user;
		};
	}

	bool user_stats::RequestCurrentStats()
	{

		static uint32_t ticket = 0;

		game_id game{};
		game.raw.mod_id = 0;
		game.raw.type = 0;
		game.raw.app_id = SteamUtils()->GetAppID();

		const auto result = callbacks::register_call();
		auto* response = static_cast<user_stats_received*>(calloc(
			1, sizeof(user_stats_received)));
		response->m_steam_id_user = SteamUser()->GetSteamID();
		response->m_e_result = 1; // k_EResultOK;
		response->m_n_game_id = game.bits;

		callbacks::return_call(response, sizeof(user_stats_received),
		                       user_stats_received::callback_id, result);
		return true;
	}

	bool user_stats::GetStat(const char* pchName, int* pData)
	{
		return false;
	}

	bool user_stats::GetStat(const char* pchName, float* pData)
	{
		return false;
	}

	bool user_stats::SetStat(const char* pchName, int nData)
	{
		return true;
	}

	bool user_stats::SetStat(const char* pchName, float fData)
	{
		return true;
	}

	bool user_stats::UpdateAvgRateStat(const char* pchName, float flCountThisSession, double dSessionLength)
	{
		return false;
	}

	bool user_stats::GetAchievement(const char* pchName, bool* pbAchieved)
	{
		return true;
	}

	bool user_stats::SetAchievement(const char* pchName)
	{
		return true;
	}

	bool user_stats::ClearAchievement(const char* pchName)
	{
		return true;
	}

	bool user_stats::GetAchievementAndUnlockTime(const char* pchName, bool* pbAchieved, unsigned int* punUnlockTime)
	{
		return true;
	}

	bool user_stats::StoreStats()
	{
		return true;
	}

	int user_stats::GetAchievementIcon(const char* pchName)
	{
		return 0;
	}

	const char* user_stats::GetAchievementDisplayAttribute(const char* pchName, const char* pchKey)
	{
		return "";
	}

	bool user_stats::IndicateAchievementProgress(const char* pchName, unsigned int nCurProgress,
	                                             unsigned int nMaxProgress)
	{
		return true;
	}

	unsigned int user_stats::GetNumAchievements()
	{
		return 0;
	}

	const char* user_stats::GetAchievementName(unsigned int iAchievement)
	{
		return "";
	}

	unsigned long long user_stats::RequestUserStats(steam_id steamIDUser)
	{
		return 0;
	}

	bool user_stats::GetUserStat(steam_id steamIDUser, const char* pchName, int* pData)
	{
		return false;
	}

	bool user_stats::GetUserStat(steam_id steamIDUser, const char* pchName, float* pData)
	{
		return false;
	}

	bool user_stats::GetUserAchievement(steam_id steamIDUser, const char* pchName, bool* pbAchieved)
	{
		return true;
	}

	bool user_stats::GetUserAchievementAndUnlockTime(steam_id steamIDUser, const char* pchName, bool* pbAchieved,
	                                                 unsigned int* punUnlockTime)
	{
		return true;
	}

	bool user_stats::ResetAllStats(bool bAchievementsToo)
	{
		return false;
	}

	unsigned long long user_stats::FindOrCreateLeaderboard(const char* pchLeaderboardName, int eLeaderboardSortMethod,
	                                                       int eLeaderboardDisplayType)
	{
		return 0;
	}

	unsigned long long user_stats::FindLeaderboard(const char* pchLeaderboardName)
	{
		return 0;
	}

	const char* user_stats::GetLeaderboardName(unsigned long long hSteamLeaderboard)
	{
		return "";
	}

	int user_stats::GetLeaderboardEntryCount(unsigned long long hSteamLeaderboard)
	{
		return 0;
	}

	int user_stats::GetLeaderboardSortMethod(unsigned long long hSteamLeaderboard)
	{
		return 0;
	}

	int user_stats::GetLeaderboardDisplayType(unsigned long long hSteamLeaderboard)
	{
		return 0;
	}

	unsigned long long user_stats::DownloadLeaderboardEntries(unsigned long long hSteamLeaderboard,
	                                                          int eLeaderboardDataRequest, int nRangeStart,
	                                                          int nRangeEnd)
	{
		return 0;
	}

	unsigned long long user_stats::DownloadLeaderboardEntriesForUsers(unsigned long long hSteamLeaderboard,
	                                                                  steam_id* prgUsers, int cUsers)
	{
		return 0;
	}

	bool user_stats::GetDownloadedLeaderboardEntry(unsigned long long hSteamLeaderboardEntries, int index,
	                                               int* pLeaderboardEntry, int* pDetails, int cDetailsMax)
	{
		return false;
	}

	unsigned long long user_stats::UploadLeaderboardScore(unsigned long long hSteamLeaderboard,
	                                                      int eLeaderboardUploadScoreMethod, int nScore,
	                                                      const int* pScoreDetails, int cScoreDetailsCount)
	{
		return 0;
	}

	unsigned long long user_stats::AttachLeaderboardUGC(unsigned long long hSteamLeaderboard, unsigned long long hUGC)
	{
		return 0;
	}

	unsigned long long user_stats::GetNumberOfCurrentPlayers()
	{
		return 0;
	}

	unsigned long long user_stats::RequestGlobalAchievementPercentages()
	{
		return 0;
	}

	int user_stats::GetMostAchievedAchievementInfo(char* pchName, unsigned int unNameBufLen, float* pflPercent,
	                                               bool* pbAchieved)
	{
		return 0;
	}

	int user_stats::GetNextMostAchievedAchievementInfo(int iIteratorPrevious, char* pchName, unsigned int unNameBufLen,
	                                                   float* pflPercent, bool* pbAchieved)
	{
		return 0;
	}

	bool user_stats::GetAchievementAchievedPercent(const char* pchName, float* pflPercent)
	{
		return true;
	}

	unsigned long long user_stats::RequestGlobalStats(int nHistoryDays)
	{
		return 0;
	}

	bool user_stats::GetGlobalStat(const char* pchStatName, long long* pData)
	{
		return false;
	}

	bool user_stats::GetGlobalStat(const char* pchStatName, double* pData)
	{
		return false;
	}

	int user_stats::GetGlobalStatHistory(const char* pchStatName, long long* pData, unsigned int cubData)
	{
		return 0;
	}

	int user_stats::GetGlobalStatHistory(const char* pchStatName, double* pData, unsigned int cubData)
	{
		return 0;
	}
}

```

`src/client/steam/interfaces/user_stats.hpp`:

```hpp
#pragma once

namespace steam
{
	class user_stats
	{
	public:
		~user_stats() = default;

		virtual bool RequestCurrentStats();
		virtual bool GetStat(const char* pchName, int* pData);
		virtual bool GetStat(const char* pchName, float* pData);
		virtual bool SetStat(const char* pchName, int nData);
		virtual bool SetStat(const char* pchName, float fData);
		virtual bool UpdateAvgRateStat(const char* pchName, float flCountThisSession, double dSessionLength);
		virtual bool GetAchievement(const char* pchName, bool* pbAchieved);
		virtual bool SetAchievement(const char* pchName);
		virtual bool ClearAchievement(const char* pchName);
		virtual bool GetAchievementAndUnlockTime(const char* pchName, bool* pbAchieved, unsigned int* punUnlockTime);
		virtual bool StoreStats();
		virtual int GetAchievementIcon(const char* pchName);
		virtual const char* GetAchievementDisplayAttribute(const char* pchName, const char* pchKey);
		virtual bool IndicateAchievementProgress(const char* pchName, unsigned int nCurProgress,
		                                         unsigned int nMaxProgress);
		virtual unsigned int GetNumAchievements();
		virtual const char* GetAchievementName(unsigned int iAchievement);
		virtual unsigned long long RequestUserStats(steam_id steamIDUser);
		virtual bool GetUserStat(steam_id steamIDUser, const char* pchName, int* pData);
		virtual bool GetUserStat(steam_id steamIDUser, const char* pchName, float* pData);
		virtual bool GetUserAchievement(steam_id steamIDUser, const char* pchName, bool* pbAchieved);
		virtual bool GetUserAchievementAndUnlockTime(steam_id steamIDUser, const char* pchName, bool* pbAchieved,
		                                             unsigned int* punUnlockTime);
		virtual bool ResetAllStats(bool bAchievementsToo);
		virtual unsigned long long FindOrCreateLeaderboard(const char* pchLeaderboardName, int eLeaderboardSortMethod,
		                                                   int eLeaderboardDisplayType);
		virtual unsigned long long FindLeaderboard(const char* pchLeaderboardName);
		virtual const char* GetLeaderboardName(unsigned long long hSteamLeaderboard);
		virtual int GetLeaderboardEntryCount(unsigned long long hSteamLeaderboard);
		virtual int GetLeaderboardSortMethod(unsigned long long hSteamLeaderboard);
		virtual int GetLeaderboardDisplayType(unsigned long long hSteamLeaderboard);
		virtual unsigned long long DownloadLeaderboardEntries(unsigned long long hSteamLeaderboard,
		                                                      int eLeaderboardDataRequest, int nRangeStart,
		                                                      int nRangeEnd);
		virtual unsigned long long DownloadLeaderboardEntriesForUsers(unsigned long long hSteamLeaderboard,
		                                                              steam_id* prgUsers, int cUsers);
		virtual bool GetDownloadedLeaderboardEntry(unsigned long long hSteamLeaderboardEntries, int index,
		                                           int* pLeaderboardEntry, int* pDetails, int cDetailsMax);
		virtual unsigned long long UploadLeaderboardScore(unsigned long long hSteamLeaderboard,
		                                                  int eLeaderboardUploadScoreMethod, int nScore,
		                                                  const int* pScoreDetails, int cScoreDetailsCount);
		virtual unsigned long long AttachLeaderboardUGC(unsigned long long hSteamLeaderboard, unsigned long long hUGC);
		virtual unsigned long long GetNumberOfCurrentPlayers();
		virtual unsigned long long RequestGlobalAchievementPercentages();
		virtual int GetMostAchievedAchievementInfo(char* pchName, unsigned int unNameBufLen, float* pflPercent,
		                                           bool* pbAchieved);
		virtual int GetNextMostAchievedAchievementInfo(int iIteratorPrevious, char* pchName, unsigned int unNameBufLen,
		                                               float* pflPercent, bool* pbAchieved);
		virtual bool GetAchievementAchievedPercent(const char* pchName, float* pflPercent);
		virtual unsigned long long RequestGlobalStats(int nHistoryDays);
		virtual bool GetGlobalStat(const char* pchStatName, long long* pData);
		virtual bool GetGlobalStat(const char* pchStatName, double* pData);
		virtual int GetGlobalStatHistory(const char* pchStatName, long long* pData, unsigned int cubData);
		virtual int GetGlobalStatHistory(const char* pchStatName, double* pData, unsigned int cubData);
	};
}

```

`src/client/steam/interfaces/utils.cpp`:

```cpp
#include <std_include.hpp>
#include "../steam.hpp"

namespace steam
{
	unsigned int utils::GetSecondsSinceAppActive()
	{
		return 0;
	}

	unsigned int utils::GetSecondsSinceComputerActive()
	{
		return (uint32_t)GetTickCount64() / 1000;
	}

	int utils::GetConnectedUniverse()
	{
		return 1;
	}

	unsigned int utils::GetServerRealTime()
	{
		return (uint32_t)time(NULL);
	}

	const char* utils::GetIPCountry()
	{
		return "US";
	}

	bool utils::GetImageSize(int iImage, unsigned int* pnWidth, unsigned int* pnHeight)
	{
		return false;
	}

	bool utils::GetImageRGBA(int iImage, unsigned char* pubDest, int nDestBufferSize)
	{
		return false;
	}

	bool utils::GetCSERIPPort(unsigned int* unIP, unsigned short* usPort)
	{
		return false;
	}

	unsigned char utils::GetCurrentBatteryPower()
	{
		return 255;
	}

	unsigned int utils::GetAppID()
	{
		return 311210;
	}

	void utils::SetOverlayNotificationPosition(int eNotificationPosition)
	{
		//const auto& overlay = steam_proxy::get_overlay_module();
		//if (overlay)
		//{
		//	overlay.invoke<void>("SetNotificationPosition", eNotificationPosition);
		//}
	}

	bool utils::IsAPICallCompleted(unsigned long long hSteamAPICall, bool* pbFailed)
	{
		return false;
	}

	int utils::GetAPICallFailureReason(unsigned long long hSteamAPICall)
	{
		return -1;
	}

	bool utils::GetAPICallResult(unsigned long long hSteamAPICall, void* pCallback, int cubCallback,
	                             int iCallbackExpected, bool* pbFailed)
	{
		return false;
	}

	void utils::RunFrame()
	{
	}

	unsigned int utils::GetIPCCallCount()
	{
		return 0;
	}

	void utils::SetWarningMessageHook(void (*pFunction)(int hpipe, const char* message))
	{
	}

	bool utils::IsOverlayEnabled()
	{
		return false;
	}

	bool utils::BOverlayNeedsPresent()
	{
		return false;
	}

	unsigned long long utils::CheckFileSignature(const char* szFileName)
	{
		return 0;
	}

	bool utils::ShowGamepadTextInput(int eInputMode, int eInputLineMode, const char* szText, unsigned int uMaxLength)
	{
		return false;
	}

	unsigned int utils::GetEnteredGamepadTextLength()
	{
		return 0;
	}

	bool utils::GetEnteredGamepadTextInput(char* pchValue, unsigned int cchValueMax)
	{
		return false;
	}

	 const char* utils::GetSteamUILanguage()
	{
	   return "english";
	}
	 bool utils::IsSteamRunningInVR()
	 {
	   return false;
	 }

	 void utils::SetOverlayNotificationInset(int nHorizontalInset, int nVerticalInset)
	 {
	   
	 }
	 bool utils::IsSteamInBigPictureMode()
	 {
	   return false;
	 }

	 void utils::StartVRDashboard()
	 {
	   
	 }
}

```

`src/client/steam/interfaces/utils.hpp`:

```hpp
#pragma once

namespace steam
{
	class utils
	{
	public:
		~utils() = default;

		virtual unsigned int GetSecondsSinceAppActive();
		virtual unsigned int GetSecondsSinceComputerActive();
		virtual int GetConnectedUniverse();
		virtual unsigned int GetServerRealTime();
		virtual const char* GetIPCountry();
		virtual bool GetImageSize(int iImage, unsigned int* pnWidth, unsigned int* pnHeight);
		virtual bool GetImageRGBA(int iImage, unsigned char* pubDest, int nDestBufferSize);
		virtual bool GetCSERIPPort(unsigned int* unIP, unsigned short* usPort);
		virtual unsigned char GetCurrentBatteryPower();
		virtual unsigned int GetAppID();
		virtual void SetOverlayNotificationPosition(int eNotificationPosition);
		virtual bool IsAPICallCompleted(unsigned long long hSteamAPICall, bool* pbFailed);
		virtual int GetAPICallFailureReason(unsigned long long hSteamAPICall);
		virtual bool GetAPICallResult(unsigned long long hSteamAPICall, void* pCallback, int cubCallback,
		                              int iCallbackExpected, bool* pbFailed);
		virtual void RunFrame();
		virtual unsigned int GetIPCCallCount();
		virtual void SetWarningMessageHook(void (*pFunction)(int hpipe, const char* message));
		virtual bool IsOverlayEnabled();
		virtual bool BOverlayNeedsPresent();
		virtual unsigned long long CheckFileSignature(const char* szFileName);

		virtual bool ShowGamepadTextInput(int eInputMode, int eInputLineMode, const char* szText,
		                                  unsigned int uMaxLength);
		virtual unsigned int GetEnteredGamepadTextLength();
		virtual bool GetEnteredGamepadTextInput(char* pchValue, unsigned int cchValueMax);

		virtual const char* GetSteamUILanguage();
		virtual bool IsSteamRunningInVR();
		virtual void SetOverlayNotificationInset(int nHorizontalInset, int nVerticalInset);
		virtual bool IsSteamInBigPictureMode();
		virtual void StartVRDashboard();
	};
}

```

`src/client/steam/steam.cpp`:

```cpp
#include <std_include.hpp>
#include "steam.hpp"

#include <utils/nt.hpp>
#include <utils/io.hpp>

#include "loader/component_loader.hpp"

namespace steam
{
	uint64_t callbacks::call_id_ = 0;
	std::recursive_mutex callbacks::mutex_;
	std::map<uint64_t, bool> callbacks::calls_;
	std::map<uint64_t, callbacks::base*> callbacks::result_handlers_;
	std::vector<callbacks::result> callbacks::results_;
	std::vector<callbacks::base*> callbacks::callback_list_;

	uint64_t callbacks::register_call()
	{
		std::lock_guard<std::recursive_mutex> _(mutex_);
		calls_[++call_id_] = false;
		return call_id_;
	}

	void callbacks::register_callback(base* handler, const int callback)
	{
		std::lock_guard<std::recursive_mutex> _(mutex_);
		handler->set_i_callback(callback);
		callback_list_.push_back(handler);
	}

	void callbacks::unregister_callback(base* handler)
	{
		std::lock_guard<std::recursive_mutex> _(mutex_);
		for (auto i = callback_list_.begin(); i != callback_list_.end();)
		{
			if (*i == handler)
			{
				i = callback_list_.erase(i);
			}
			else
			{
				++i;
			}
		}
	}

	void callbacks::register_call_result(const uint64_t call, base* result)
	{
		std::lock_guard<std::recursive_mutex> _(mutex_);
		result_handlers_[call] = result;
	}

	void callbacks::unregister_call_result(const uint64_t call, base* /*result*/)
	{
		std::lock_guard<std::recursive_mutex> _(mutex_);
		const auto i = result_handlers_.find(call);
		if (i != result_handlers_.end())
		{
			result_handlers_.erase(i);
		}
	}

	void callbacks::return_call(void* data, const int size, const int type, const uint64_t call)
	{
		std::lock_guard<std::recursive_mutex> _(mutex_);

		result result{};
		result.call = call;
		result.data = data;
		result.size = size;
		result.type = type;

		calls_[call] = true;

		results_.emplace_back(result);
	}

	void callbacks::run_callbacks()
	{
		std::lock_guard<std::recursive_mutex> _(mutex_);

		for (const auto& result : results_)
		{
			if (result_handlers_.find(result.call) != result_handlers_.end())
			{
				result_handlers_[result.call]->run(result.data, false, result.call);
			}

			for (const auto& callback : callback_list_)
			{
				if (callback && callback->get_i_callback() == result.type)
				{
					callback->run(result.data, false, 0);
				}
			}

			if (result.data)
			{
				free(result.data);
			}
		}

		results_.clear();
	}

	bool SteamAPI_RestartAppIfNecessary()
	{
		return false;
	}

	bool SteamAPI_Init()
	{
		const std::filesystem::path steam_path = SteamAPI_GetSteamInstallPath();
		if (steam_path.empty()) return true;

		::utils::nt::library::load(steam_path / "tier0_s64.dll");
		::utils::nt::library::load(steam_path / "vstdlib_s64.dll");
		::utils::nt::library::load(steam_path / "gameoverlayrenderer64.dll");
		::utils::nt::library::load(steam_path / "steamclient64.dll");
		return true;
	}

	void SteamAPI_RegisterCallResult(callbacks::base* result, const uint64_t call)
	{
		callbacks::register_call_result(call, result);
	}

	void SteamAPI_RegisterCallback(callbacks::base* handler, const int callback)
	{
		callbacks::register_callback(handler, callback);
	}

	void SteamAPI_RunCallbacks()
	{
		callbacks::run_callbacks();
	}

	void SteamAPI_Shutdown()
	{
	}

	void SteamAPI_UnregisterCallResult(callbacks::base* result, const uint64_t call)
	{
		callbacks::unregister_call_result(call, result);
	}

	void SteamAPI_UnregisterCallback(callbacks::base* handler)
	{
		callbacks::unregister_callback(handler);
	}

	const char* SteamAPI_GetSteamInstallPath()
	{
		static std::string install_path{};
		if (!install_path.empty())
		{
			return install_path.data();
		}

		HKEY reg_key;
		if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\WOW6432Node\\Valve\\Steam", 0, KEY_QUERY_VALUE,
		                  &reg_key) ==
			ERROR_SUCCESS)
		{
			char path[MAX_PATH] = {0};
			DWORD length = sizeof(path);
			RegQueryValueExA(reg_key, "InstallPath", nullptr, nullptr, reinterpret_cast<BYTE*>(path),
			                 &length);
			RegCloseKey(reg_key);

			install_path = path;
		}

		return install_path.data();
	}

	void* SteamGameServer_GetHSteamPipe()
	{
		return reinterpret_cast<void*>(1);
	}

	void* SteamGameServer_GetHSteamUser()
	{
		return reinterpret_cast<void*>(1);
	}

	void* SteamAPI_GetHSteamUser()
	{
		return reinterpret_cast<void*>(1);
	}

	void* SteamAPI_GetHSteamPipe()
	{
		return reinterpret_cast<void*>(1);
	}

	void* SteamInternal_CreateInterface(const char* interfacename)
	{
		if (std::string(interfacename) == "SteamClient017")
		{
			static client c;
			return &c;
		}


		MessageBoxA(0, interfacename, __FUNCTION__, 0);
		return nullptr;
	}

	bool SteamInternal_GameServer_Init()
	{
		return true;
	}

	bool SteamGameServer_Init()
	{
		return true;
	}

	void SteamGameServer_RunCallbacks()
	{
	}

	void SteamGameServer_Shutdown()
	{
	}


	friends* SteamFriends()
	{
		static friends friends;
		return &friends;
	}

	matchmaking* SteamMatchmaking()
	{
		static matchmaking matchmaking;
		return &matchmaking;
	}

	game_server* SteamGameServer()
	{
		static game_server game_server;
		return &game_server;
	}

	networking* SteamNetworking()
	{
		static networking networking;
		return &networking;
	}

	remote_storage* SteamRemoteStorage()
	{
		static remote_storage remote_storage;
		return &remote_storage;
	}

	user* SteamUser()
	{
		static user user;
		return &user;
	}

	utils* SteamUtils()
	{
		static utils utils;
		return &utils;
	}

	apps* SteamApps()
	{
		static apps apps;
		return &apps;
	}

	user_stats* SteamUserStats()
	{
		static user_stats user_stats;
		return &user_stats;
	}
}

```

`src/client/steam/steam.hpp`:

```hpp
#pragma once

//#define STEAM_EXPORT extern "C" __declspec(dllexport)
#define STEAM_EXPORT

struct raw_steam_id final
{
	unsigned int account_id : 32;
	unsigned int account_instance : 20;
	unsigned int account_type : 4;
	int universe : 8;
};

typedef union
{
	raw_steam_id raw;
	unsigned long long bits;
} steam_id;

#pragma pack( push, 1 )
struct raw_game_id final
{
	unsigned int app_id : 24;
	unsigned int type : 8;
	unsigned int mod_id : 32;
};

typedef union
{
	raw_game_id raw;
	unsigned long long bits;
} game_id;
#pragma pack( pop )

#include "interfaces/apps.hpp"
#include "interfaces/user.hpp"
#include "interfaces/utils.hpp"
#include "interfaces/friends.hpp"
#include "interfaces/user_stats.hpp"
#include "interfaces/game_server.hpp"
#include "interfaces/networking.hpp"
#include "interfaces/matchmaking.hpp"
#include "interfaces/matchmaking_servers.hpp"
#include "interfaces/remote_storage.hpp"
#include "interfaces/screenshots.hpp"
#include "interfaces/game_server_stats.hpp"
#include "interfaces/http.hpp"
#include "interfaces/unified_messages.hpp"
#include "interfaces/controller.hpp"
#include "interfaces/client.hpp"
#include "interfaces/ugc.hpp"

namespace steam
{
	class callbacks
	{
	public:
		class base
		{
		public:
			base() : flags_(0), callback_(0)
			{
			}

			virtual void run(void* pv_param) = 0;
			virtual void run(void* pv_param, bool failure, uint64_t handle) = 0;
			virtual int get_callback_size_bytes() = 0;

			int get_i_callback() const { return callback_; }
			void set_i_callback(const int i_callback) { callback_ = i_callback; }

		protected:
			~base() = default;

			unsigned char flags_;
			int callback_;
		};

		struct result final
		{
			void* data{};
			int size{};
			int type{};
			uint64_t call{};
		};

		static uint64_t register_call();

		static void register_callback(base* handler, int callback);
		static void unregister_callback(base* handler);

		static void register_call_result(uint64_t call, base* result);
		static void unregister_call_result(uint64_t call, base* result);

		static void return_call(void* data, int size, int type, uint64_t call);
		static void run_callbacks();

	private:
		static uint64_t call_id_;
		static std::recursive_mutex mutex_;
		static std::map<uint64_t, bool> calls_;
		static std::map<uint64_t, base*> result_handlers_;
		static std::vector<result> results_;
		static std::vector<base*> callback_list_;
	};

	STEAM_EXPORT bool SteamAPI_RestartAppIfNecessary();
	STEAM_EXPORT bool SteamAPI_Init();
	STEAM_EXPORT void SteamAPI_RegisterCallResult(callbacks::base* result, uint64_t call);
	STEAM_EXPORT void SteamAPI_RegisterCallback(callbacks::base* handler, int callback);
	STEAM_EXPORT void SteamAPI_RunCallbacks();
	STEAM_EXPORT void SteamAPI_Shutdown();
	STEAM_EXPORT void SteamAPI_UnregisterCallResult(callbacks::base* result, const uint64_t call);
	STEAM_EXPORT void SteamAPI_UnregisterCallback(callbacks::base* handler);
	STEAM_EXPORT const char* SteamAPI_GetSteamInstallPath();

	STEAM_EXPORT void* SteamGameServer_GetHSteamPipe();
	STEAM_EXPORT void* SteamGameServer_GetHSteamUser();

	STEAM_EXPORT void* SteamAPI_GetHSteamUser();
	STEAM_EXPORT void* SteamAPI_GetHSteamPipe();

	STEAM_EXPORT void* SteamInternal_CreateInterface(const char* interfacename);

	STEAM_EXPORT bool SteamInternal_GameServer_Init();
	STEAM_EXPORT bool SteamGameServer_Init();
	STEAM_EXPORT void SteamGameServer_RunCallbacks();
	STEAM_EXPORT void SteamGameServer_Shutdown();

	STEAM_EXPORT friends* SteamFriends();
	STEAM_EXPORT matchmaking* SteamMatchmaking();
	STEAM_EXPORT game_server* SteamGameServer();
	STEAM_EXPORT networking* SteamNetworking();
	STEAM_EXPORT remote_storage* SteamRemoteStorage();
	STEAM_EXPORT user* SteamUser();
	STEAM_EXPORT utils* SteamUtils();
	STEAM_EXPORT apps* SteamApps();
	STEAM_EXPORT user_stats* SteamUserStats();
}

```

`src/common/exception/minidump.cpp`:

```cpp
#include "minidump.hpp"

#include <DbgHelp.h>
#pragma comment(lib, "dbghelp.lib")

namespace exception
{
	namespace
	{
		constexpr MINIDUMP_TYPE get_minidump_type()
		{
			constexpr auto type = MiniDumpIgnoreInaccessibleMemory //
				| MiniDumpWithHandleData //
				| MiniDumpScanMemory //
				| MiniDumpWithProcessThreadData //
				| MiniDumpWithFullMemoryInfo //
				| MiniDumpWithThreadInfo //
				| MiniDumpWithUnloadedModules;

			return static_cast<MINIDUMP_TYPE>(type);
		}

		std::string get_temp_filename()
		{
			char filename[MAX_PATH] = {0};
			char pathname[MAX_PATH] = {0};

			GetTempPathA(sizeof(pathname), pathname);
			GetTempFileNameA(pathname, "boiii-", 0, filename);
			return filename;
		}

		HANDLE write_dump_to_temp_file(const LPEXCEPTION_POINTERS exceptioninfo)
		{
			MINIDUMP_EXCEPTION_INFORMATION minidump_exception_info = {GetCurrentThreadId(), exceptioninfo, FALSE};

			auto* const file_handle = CreateFileA(get_temp_filename().data(), GENERIC_WRITE | GENERIC_READ,
			                                      FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_ALWAYS,
			                                      FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
			                                      nullptr);

			if (!MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), file_handle, get_minidump_type(),
			                       &minidump_exception_info,
			                       nullptr,
			                       nullptr))
			{
				MessageBoxA(nullptr, "There was an error creating the minidump! Hit OK to close the program.",
				            "Minidump Error", MB_OK | MB_ICONERROR);
				TerminateProcess(GetCurrentProcess(), 123);
			}

			return file_handle;
		}

		std::string read_file(const HANDLE file_handle)
		{
			FlushFileBuffers(file_handle);
			SetFilePointer(file_handle, 0, nullptr, FILE_BEGIN);

			std::string buffer{};

			DWORD bytes_read = 0;
			char temp_bytes[0x2000];

			do
			{
				if (!ReadFile(file_handle, temp_bytes, sizeof(temp_bytes), &bytes_read, nullptr))
				{
					return {};
				}

				buffer.append(temp_bytes, bytes_read);
			}
			while (bytes_read == sizeof(temp_bytes));

			return buffer;
		}
	}

	std::string create_minidump(const LPEXCEPTION_POINTERS exceptioninfo)
	{
		const utils::nt::handle file_handle = write_dump_to_temp_file(exceptioninfo);
		return read_file(file_handle);
	}
}

```

`src/common/exception/minidump.hpp`:

```hpp
#pragma once

#include "../utils/nt.hpp"

namespace exception
{
	std::string create_minidump(LPEXCEPTION_POINTERS exceptioninfo);
}

```

`src/common/utils/binary_resource.cpp`:

```cpp
#include "binary_resource.hpp"

#include <utility>
#include "nt.hpp"
#include "io.hpp"

namespace utils
{
	namespace
	{
		std::string get_temp_folder()
		{
			char path[MAX_PATH] = {0};
			if (!GetTempPathA(sizeof(path), path))
			{
				throw std::runtime_error("Unable to get temp path");
			}

			return path;
		}

		std::string write_existing_temp_file(const std::string& file, const std::string& data,
		                                       const bool fatal_if_overwrite_fails)
		{
			const auto temp = get_temp_folder();
			auto file_path = temp + file;

			std::string current_data;
			if (!io::read_file(file_path, &current_data))
			{
				if (!io::write_file(file_path, data))
				{
					throw std::runtime_error("Failed to write file: " + file_path);
				}

				return file_path;
			}

			if (current_data == data || io::write_file(file_path, data) || !fatal_if_overwrite_fails)
			{
				return file_path;
			}

			throw std::runtime_error(
				"Temporary file was already written, but differs. It can't be overwritten as it's still in use: " +
				file_path);
		}
	}

	binary_resource::binary_resource(const int id, std::string file)
		: filename_(std::move(file))
	{
		this->resource_ = nt::load_resource(id);

		if (this->resource_.empty())
		{
			throw std::runtime_error("Unable to load resource: " + std::to_string(id));
		}
	}

	std::string binary_resource::get_extracted_file(const bool fatal_if_overwrite_fails)
	{
		if (this->path_.empty())
		{
			this->path_ = write_existing_temp_file(this->filename_, this->resource_, fatal_if_overwrite_fails);
		}

		return this->path_;
	}

	const std::string& binary_resource::get_data() const
	{
		return this->resource_;
	}
}

```

`src/common/utils/binary_resource.hpp`:

```hpp
#pragma once

#include <string>

namespace utils
{
	class binary_resource
	{
	public:
		binary_resource(int id, std::string file);

		std::string get_extracted_file(bool fatal_if_overwrite_fails = false);
		const std::string& get_data() const;

	private:
		std::string resource_;
		std::string filename_;
		std::string path_;
	};
}

```

`src/common/utils/com.cpp`:

```cpp
#include "com.hpp"
#include "nt.hpp"
#include "string.hpp"
#include "finally.hpp"

#include <stdexcept>

#include <ShlObj.h>


namespace utils::com
{
	namespace
	{
		void initialize_com()
		{
			static struct x
			{
				x()
				{
					if (FAILED(CoInitialize(nullptr)))
					{
						throw std::runtime_error("Failed to initialize the component object model");
					}
				}

				~x()
				{
					CoUninitialize();
				}
			} xx;
		}
	}

	bool select_folder(std::string& out_folder, const std::string& title, const std::string& selected_folder)
	{
		initialize_com();

		CComPtr<IFileOpenDialog> file_dialog{};
		if (FAILED(CoCreateInstance(CLSID_FileOpenDialog, nullptr, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&file_dialog))))
		{
			throw std::runtime_error("Failed to create co instance");
		}

		DWORD dw_options;
		if (FAILED(file_dialog->GetOptions(&dw_options)))
		{
			throw std::runtime_error("Failed to get options");
		}

		if (FAILED(file_dialog->SetOptions(dw_options | FOS_PICKFOLDERS)))
		{
			throw std::runtime_error("Failed to set options");
		}

		const std::wstring wide_title(title.begin(), title.end());
		if (FAILED(file_dialog->SetTitle(wide_title.data())))
		{
			throw std::runtime_error("Failed to set title");
		}

		if (!selected_folder.empty())
		{
			file_dialog->ClearClientData();

			std::wstring wide_selected_folder(selected_folder.begin(), selected_folder.end());
			for (auto& chr : wide_selected_folder)
			{
				if (chr == L'/')
				{
					chr = L'\\';
				}
			}

			IShellItem* shell_item = nullptr;
			if (FAILED(SHCreateItemFromParsingName(wide_selected_folder.data(), NULL, IID_PPV_ARGS(&shell_item))))
			{
				throw std::runtime_error("Failed to create item from parsing name");
			}

			if (FAILED(file_dialog->SetDefaultFolder(shell_item)))
			{
				throw std::runtime_error("Failed to set default folder");
			}
		}

		const auto result = file_dialog->Show(nullptr);
		if (result == HRESULT_FROM_WIN32(ERROR_CANCELLED))
		{
			return false;
		}

		if (FAILED(result))
		{
			throw std::runtime_error("Failed to show dialog");
		}

		CComPtr<IShellItem> result_item{};
		if (FAILED(file_dialog->GetResult(&result_item)))
		{
			throw std::runtime_error("Failed to get result");
		}

		PWSTR raw_path = nullptr;
		if (FAILED(result_item->GetDisplayName(SIGDN_FILESYSPATH, &raw_path)))
		{
			throw std::runtime_error("Failed to get path display name");
		}

		const auto _ = finally([raw_path]()
		{
			CoTaskMemFree(raw_path);
		});

		const std::wstring result_path = raw_path;
		out_folder = string::convert(result_path);

		return true;
	}

	CComPtr<IProgressDialog> create_progress_dialog()
	{
		initialize_com();

		CComPtr<IProgressDialog> progress_dialog{};
		if (FAILED(
			CoCreateInstance(CLSID_ProgressDialog, nullptr, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&progress_dialog))))
		{
			throw std::runtime_error("Failed to create co instance");
		}

		return progress_dialog;
	}
}

```

`src/common/utils/com.hpp`:

```hpp
#pragma once

#include "nt.hpp"
#include <ShlObj.h>
#include <atlbase.h>

namespace utils::com
{
	bool select_folder(std::string& out_folder, const std::string& title = "Select a Folder", const std::string& selected_folder = {});
	CComPtr<IProgressDialog> create_progress_dialog();
}

```

`src/common/utils/compression.cpp`:

```cpp
#include "memory.hpp"
#include "compression.hpp"

#include <zlib.h>
#include <zip.h>
#include <unzip.h>

#include "io.hpp"
#include "finally.hpp"

namespace utils::compression
{
	namespace zlib
	{
		namespace
		{
			class zlib_stream
			{
			public:
				zlib_stream()
				{
					memset(&stream_, 0, sizeof(stream_));
					valid_ = inflateInit(&stream_) == Z_OK;
				}

				zlib_stream(zlib_stream&&) = delete;
				zlib_stream(const zlib_stream&) = delete;
				zlib_stream& operator=(zlib_stream&&) = delete;
				zlib_stream& operator=(const zlib_stream&) = delete;

				~zlib_stream()
				{
					if (valid_)
					{
						inflateEnd(&stream_);
					}
				}

				z_stream& get()
				{
					return stream_; //
				}

				bool is_valid() const
				{
					return valid_;
				}

			private:
				bool valid_{false};
				z_stream stream_{};
			};
		}

		std::string decompress(const std::string& data)
		{
			std::string buffer{};
			zlib_stream stream_container{};
			if (!stream_container.is_valid())
			{
				return {};
			}

			int ret{};
			size_t offset = 0;
			static thread_local uint8_t dest[CHUNK] = {0};
			auto& stream = stream_container.get();

			do
			{
				const auto input_size = std::min(sizeof(dest), data.size() - offset);
				stream.avail_in = static_cast<uInt>(input_size);
				stream.next_in = reinterpret_cast<const Bytef*>(data.data()) + offset;
				offset += stream.avail_in;

				do
				{
					stream.avail_out = sizeof(dest);
					stream.next_out = dest;

					ret = inflate(&stream, Z_NO_FLUSH);
					if (ret != Z_OK && ret != Z_STREAM_END)
					{
						return {};
					}

					buffer.insert(buffer.end(), dest, dest + sizeof(dest) - stream.avail_out);
				}
				while (stream.avail_out == 0);
			}
			while (ret != Z_STREAM_END);

			return buffer;
		}

		std::string compress(const std::string& data)
		{
			std::string result{};
			auto length = compressBound(static_cast<uLong>(data.size()));
			result.resize(length);

			if (compress2(reinterpret_cast<Bytef*>(result.data()), &length,
			              reinterpret_cast<const Bytef*>(data.data()), static_cast<uLong>(data.size()),
			              Z_BEST_COMPRESSION) != Z_OK)
			{
				return {};
			}

			result.resize(length);
			return result;
		}
	}

	namespace zip
	{
		namespace
		{
			bool add_file(zipFile& zip_file, const std::string& filename, const std::string& data)
			{
				const auto zip_64 = data.size() > 0xffffffff ? 1 : 0;
				if (ZIP_OK != zipOpenNewFileInZip64(zip_file, filename.data(), nullptr, nullptr, 0, nullptr, 0, nullptr,
				                                    Z_DEFLATED, Z_BEST_COMPRESSION, zip_64))
				{
					return false;
				}

				const auto _ = finally([&zip_file]()
				{
					zipCloseFileInZip(zip_file);
				});

				return ZIP_OK == zipWriteInFileInZip(zip_file, data.data(), static_cast<unsigned>(data.size()));
			}
		}

		void archive::add(std::string filename, std::string data)
		{
			this->files_[std::move(filename)] = std::move(data);
		}

		bool archive::write(const std::string& filename, const std::string& comment)
		{
			// Hack to create the directory :3
			io::write_file(filename, {});
			io::remove_file(filename);

			auto* zip_file = zipOpen64(filename.data(), 0);
			if (!zip_file)
			{
				return false;
			}

			const auto _ = finally([&zip_file, &comment]()
			{
				zipClose(zip_file, comment.empty() ? nullptr : comment.data());
			});

			for (const auto& file : this->files_)
			{
				if (!add_file(zip_file, file.first, file.second))
				{
					return false;
				}
			}

			return true;
		}

		namespace
		{
			std::optional<std::pair<std::string, std::string>> read_zip_file_entry(unzFile& zip_file)
			{
				char filename[1024]{};
				unz_file_info file_info{};
				if (unzGetCurrentFileInfo(zip_file, &file_info, filename, sizeof(filename), nullptr, 0, nullptr, 0) !=
					UNZ_OK)
				{
					return {};
				}

				if (unzOpenCurrentFile(zip_file) != UNZ_OK)
				{
					return {};
				}

				auto _ = finally([&zip_file]
				{
					unzCloseCurrentFile(zip_file);
				});

				int error = UNZ_OK;
				std::string out_buffer{};
				static thread_local char buffer[0x2000];

				do
				{
					error = unzReadCurrentFile(zip_file, buffer, sizeof(buffer));
					if (error < 0)
					{
						return {};
					}

					// Write data to file.
					if (error > 0)
					{
						out_buffer.append(buffer, error);
					}
				}
				while (error > 0);

				return std::pair<std::string, std::string>{filename, out_buffer};
			}

			class memory_file
			{
			public:
				memory_file(const std::string& data)
					: data_(data)
				{
					func_def_.opaque = this;
					func_def_.zopen64_file = open_file_static;
					func_def_.zseek64_file = seek_file_static;
					func_def_.ztell64_file = tell_file_static;
					func_def_.zread_file = read_file_static;
					func_def_.zwrite_file = write_file_static;
					func_def_.zclose_file = close_file_static;
					func_def_.zerror_file = testerror_file_static;
				}

				const char* get_name() const
				{
					return "blub";
				}

				zlib_filefunc64_def* get_func_def()
				{
					return &this->func_def_;
				}

			private:
				const std::string& data_;
				size_t offset_{0};
				zlib_filefunc64_def func_def_{};

				voidpf open_file(const void* filename, const int mode) const
				{
					if (mode != (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_EXISTING))
					{
						return nullptr;
					}

					if (strcmp(static_cast<const char*>(filename), get_name()) != 0)
					{
						return nullptr;
					}

					return reinterpret_cast<voidpf>(1);
				}

				long seek_file(const voidpf stream, const ZPOS64_T offset, const int origin)
				{
					if (stream != reinterpret_cast<voidpf>(1))
					{
						return -1;
					}

					size_t target_base = this->data_.size();
					if (origin == ZLIB_FILEFUNC_SEEK_CUR)
					{
						target_base = this->offset_;
					}
					else if (origin == ZLIB_FILEFUNC_SEEK_SET)
					{
						target_base = 0;
					}

					const auto target_offset = target_base + offset;
					if (target_offset > this->data_.size())
					{
						return -1;
					}

					this->offset_ = target_offset;
					return 0;
				}

				ZPOS64_T tell_file(const voidpf stream) const
				{
					if (stream != reinterpret_cast<voidpf>(1))
					{
						return static_cast<ZPOS64_T>(-1);
					}

					return this->offset_;
				}

				uLong read_file(const voidpf stream, void* buf, const uLong size)
				{
					if (stream != reinterpret_cast<voidpf>(1))
					{
						return 0;
					}

					const auto file_end = this->data_.size();
					const auto start = this->offset_;
					const auto end = std::min(this->offset_ + size, file_end);
					const auto length = end - start;

					memcpy(buf, this->data_.data() + start, length);
					this->offset_ = end;

					return static_cast<uLong>(length);
				}

				static voidpf open_file_static(const voidpf opaque, const void* filename, const int mode)
				{
					return static_cast<memory_file*>(opaque)->open_file(filename, mode);
				}

				static long seek_file_static(const voidpf opaque, const voidpf stream, const ZPOS64_T offset,
				                             const int origin)
				{
					return static_cast<memory_file*>(opaque)->seek_file(stream, offset, origin);
				}

				static ZPOS64_T tell_file_static(const voidpf opaque, const voidpf stream)
				{
					return static_cast<memory_file*>(opaque)->tell_file(stream);
				}

				static uLong read_file_static(const voidpf opaque, const voidpf stream, void* buf, const uLong size)
				{
					return static_cast<memory_file*>(opaque)->read_file(stream, buf, size);
				}

				static uLong write_file_static(voidpf, voidpf, const void*, uLong)
				{
					return 0;
				}

				static int close_file_static(voidpf, voidpf)
				{
					return 0;
				}

				static int testerror_file_static(voidpf, voidpf)
				{
					return 0;
				}
			};
		}

		std::unordered_map<std::string, std::string> extract(const std::string& data)
		{
			memory_file mem_file(data);

			auto zip_file = unzOpen2_64(mem_file.get_name(), mem_file.get_func_def());
			auto _ = finally([&zip_file]
			{
				if (zip_file)
				{
					unzClose(zip_file);
				}
			});

			if (!zip_file)
			{
				return {};
			}

			unz_global_info global_info{};
			if (unzGetGlobalInfo(zip_file, &global_info) != UNZ_OK)
			{
				return {};
			}

			std::unordered_map<std::string, std::string> files{};
			files.reserve(global_info.number_entry);

			for (auto i = 0ul; i < global_info.number_entry; ++i)
			{
				if (i > 0 && unzGoToNextFile(zip_file) != UNZ_OK)
				{
					break;
				}

				auto file = read_zip_file_entry(zip_file);
				if (!file)
				{
					continue;
				}

				files[std::move(file->first)] = std::move(file->second);
			}

			return files;
		}
	}
}

```

`src/common/utils/compression.hpp`:

```hpp
#pragma once

#include <string>
#include <unordered_map>

#define CHUNK 16384u

namespace utils::compression
{
	namespace zlib
	{
		std::string compress(const std::string& data);
		std::string decompress(const std::string& data);
	}

	namespace zip
	{
		class archive
		{
		public:
			void add(std::string filename, std::string data);
			bool write(const std::string& filename, const std::string& comment = {});

		private:
			std::unordered_map<std::string, std::string> files_;
		};

		std::unordered_map<std::string, std::string> extract(const std::string& data);
	}
};

```

`src/common/utils/concurrency.hpp`:

```hpp
#pragma once

#include <mutex>

namespace utils::concurrency
{
	template <typename T, typename MutexType = std::mutex>
	class container
	{
	public:
		template <typename R = void, typename F>
		R access(F&& accessor) const
		{
			std::lock_guard<MutexType> _{mutex_};
			return accessor(object_);
		}

		template <typename R = void, typename F>
		R access(F&& accessor)
		{
			std::lock_guard<MutexType> _{mutex_};
			return accessor(object_);
		}

		template <typename R = void, typename F>
		R access_with_lock(F&& accessor) const
		{
			std::unique_lock<MutexType> lock{mutex_};
			return accessor(object_, lock);
		}

		template <typename R = void, typename F>
		R access_with_lock(F&& accessor)
		{
			std::unique_lock<MutexType> lock{mutex_};
			return accessor(object_, lock);
		}

		T& get_raw() { return object_; }
		const T& get_raw() const { return object_; }

	private:
		mutable MutexType mutex_{};
		T object_{};
	};
}

```

`src/common/utils/cryptography.cpp`:

```cpp
#include "string.hpp"
#include "cryptography.hpp"
#include "nt.hpp"
#include "finally.hpp"

#undef max
using namespace std::string_literals;

/// http://www.opensource.apple.com/source/CommonCrypto/CommonCrypto-55010/Source/libtomcrypt/doc/libTomCryptDoc.pdf

namespace utils::cryptography
{
	namespace
	{
		struct __
		{
			__()
			{
				ltc_mp = ltm_desc;

				register_cipher(&aes_desc);
				register_cipher(&des3_desc);

				register_prng(&sprng_desc);
				register_prng(&fortuna_desc);
				register_prng(&yarrow_desc);

				register_hash(&sha1_desc);
				register_hash(&sha256_desc);
				register_hash(&sha512_desc);
			}
		} ___;

		[[maybe_unused]] const char* cs(const uint8_t* data)
		{
			return reinterpret_cast<const char*>(data);
		}

		[[maybe_unused]] char* cs(uint8_t* data)
		{
			return reinterpret_cast<char*>(data);
		}

		[[maybe_unused]] const uint8_t* cs(const char* data)
		{
			return reinterpret_cast<const uint8_t*>(data);
		}

		[[maybe_unused]] uint8_t* cs(char* data)
		{
			return reinterpret_cast<uint8_t*>(data);
		}

		[[maybe_unused]] unsigned long ul(const size_t value)
		{
			return static_cast<unsigned long>(value);
		}

		class prng
		{
		public:
			prng(const ltc_prng_descriptor& descriptor, const bool autoseed = true)
				: state_(std::make_unique<prng_state>())
				  , descriptor_(descriptor)
			{
				this->id_ = register_prng(&descriptor);
				if (this->id_ == -1)
				{
					throw std::runtime_error("PRNG "s + this->descriptor_.name + " could not be registered!");
				}

				if (autoseed)
				{
					this->auto_seed();
				}
				else
				{
					this->descriptor_.start(this->state_.get());
				}
			}

			~prng()
			{
				this->descriptor_.done(this->state_.get());
			}

			prng_state* get_state() const
			{
				this->descriptor_.ready(this->state_.get());
				return this->state_.get();
			}

			int get_id() const
			{
				return this->id_;
			}

			void add_entropy(const void* data, const size_t length) const
			{
				this->descriptor_.add_entropy(static_cast<const uint8_t*>(data), ul(length), this->state_.get());
			}

			void read(void* data, const size_t length) const
			{
				this->descriptor_.read(static_cast<unsigned char*>(data), ul(length), this->get_state());
			}

		private:
			int id_;
			std::unique_ptr<prng_state> state_;
			const ltc_prng_descriptor& descriptor_;

			void auto_seed() const
			{
				rng_make_prng(128, this->id_, this->state_.get(), nullptr);

				int i[4]; // uninitialized data
				auto* i_ptr = &i;
				this->add_entropy(reinterpret_cast<uint8_t*>(&i), sizeof(i));
				this->add_entropy(reinterpret_cast<uint8_t*>(&i_ptr), sizeof(i_ptr));

				auto t = time(nullptr);
				this->add_entropy(reinterpret_cast<uint8_t*>(&t), sizeof(t));
			}
		};

		const prng prng_(fortuna_desc);
	}

	ecc::key::key()
	{
		ZeroMemory(&this->key_storage_, sizeof(this->key_storage_));
	}

	ecc::key::~key()
	{
		this->free();
	}

	ecc::key::key(key&& obj) noexcept
		: key()
	{
		this->operator=(std::move(obj));
	}

	ecc::key::key(const key& obj)
		: key()
	{
		this->operator=(obj);
	}

	ecc::key& ecc::key::operator=(key&& obj) noexcept
	{
		if (this != &obj)
		{
			std::memmove(&this->key_storage_, &obj.key_storage_, sizeof(this->key_storage_));
			ZeroMemory(&obj.key_storage_, sizeof(obj.key_storage_));
		}

		return *this;
	}

	ecc::key& ecc::key::operator=(const key& obj)
	{
		if (this != &obj && obj.is_valid())
		{
			this->deserialize(obj.serialize(obj.key_storage_.type));
		}

		return *this;
	}

	bool ecc::key::is_valid() const
	{
		return (!memory::is_set(&this->key_storage_, 0, sizeof(this->key_storage_)));
	}

	ecc_key& ecc::key::get()
	{
		return this->key_storage_;
	}

	const ecc_key& ecc::key::get() const
	{
		return this->key_storage_;
	}

	std::string ecc::key::get_public_key() const
	{
		uint8_t buffer[512] = {0};
		unsigned long length = sizeof(buffer);

		if (ecc_ansi_x963_export(&this->key_storage_, buffer, &length) == CRYPT_OK)
		{
			return std::string(cs(buffer), length);
		}

		return {};
	}

	void ecc::key::set(const std::string& pub_key_buffer)
	{
		this->free();

		if (ecc_ansi_x963_import(cs(pub_key_buffer.data()),
		                         ul(pub_key_buffer.size()),
		                         &this->key_storage_) != CRYPT_OK)
		{
			ZeroMemory(&this->key_storage_, sizeof(this->key_storage_));
		}
	}

	void ecc::key::deserialize(const std::string& key)
	{
		this->free();

		if (ecc_import(cs(key.data()), ul(key.size()),
		               &this->key_storage_) != CRYPT_OK
		)
		{
			ZeroMemory(&this->key_storage_, sizeof(this->key_storage_));
		}
	}

	std::string ecc::key::serialize(const int type) const
	{
		uint8_t buffer[4096] = {0};
		unsigned long length = sizeof(buffer);

		if (ecc_export(buffer, &length, type, &this->key_storage_) == CRYPT_OK)
		{
			return std::string(cs(buffer), length);
		}

		return "";
	}

	void ecc::key::free()
	{
		if (this->is_valid())
		{
			ecc_free(&this->key_storage_);
		}

		ZeroMemory(&this->key_storage_, sizeof(this->key_storage_));
	}

	bool ecc::key::operator==(key& key) const
	{
		return (this->is_valid() && key.is_valid() && this->serialize(PK_PUBLIC) == key.serialize(PK_PUBLIC));
	}

	uint64_t ecc::key::get_hash() const
	{
		const auto hash = sha1::compute(this->get_public_key());
		if (hash.size() >= 8)
		{
			return *reinterpret_cast<const uint64_t*>(hash.data());
		}

		return 0;
	}

	ecc::key ecc::generate_key(const int bits)
	{
		key key;
		ecc_make_key(prng_.get_state(), prng_.get_id(), bits / 8, &key.get());

		return key;
	}

	ecc::key ecc::generate_key(const int bits, const std::string& entropy)
	{
		key key{};
		const prng yarrow(yarrow_desc, false);
		yarrow.add_entropy(entropy.data(), entropy.size());

		ecc_make_key(yarrow.get_state(), yarrow.get_id(), bits / 8, &key.get());

		return key;
	}

	std::string ecc::sign_message(const key& key, const std::string& message)
	{
		if (!key.is_valid()) return "";

		uint8_t buffer[512];
		unsigned long length = sizeof(buffer);

		ecc_sign_hash(cs(message.data()), ul(message.size()), buffer, &length, prng_.get_state(), prng_.get_id(),
		              &key.get());

		return std::string(cs(buffer), length);
	}

	bool ecc::verify_message(const key& key, const std::string& message, const std::string& signature)
	{
		if (!key.is_valid()) return false;

		auto result = 0;
		return (ecc_verify_hash(cs(signature.data()),
		                        ul(signature.size()),
		                        cs(message.data()),
		                        ul(message.size()), &result,
		                        &key.get()) == CRYPT_OK && result != 0);
	}

	bool ecc::encrypt(const key& key, std::string& data)
	{
		std::string out_data{};
		out_data.resize(std::max(ul(data.size() * 3), ul(0x100)));

		auto out_len = ul(out_data.size());
		auto crypt = [&]()
		{
			return ecc_encrypt_key(cs(data.data()), ul(data.size()), cs(out_data.data()), &out_len,
			                       prng_.get_state(), prng_.get_id(), find_hash("sha512"), &key.get());
		};

		auto res = crypt();

		if (res == CRYPT_BUFFER_OVERFLOW)
		{
			out_data.resize(out_len);
			res = crypt();
		}

		if (res != CRYPT_OK)
		{
			return false;
		}

		out_data.resize(out_len);
		data = std::move(out_data);
		return true;
	}

	bool ecc::decrypt(const key& key, std::string& data)
	{
		std::string out_data{};
		out_data.resize(std::max(ul(data.size() * 3), ul(0x100)));

		auto out_len = ul(out_data.size());
		auto crypt = [&]()
		{
			return ecc_decrypt_key(cs(data.data()), ul(data.size()), cs(out_data.data()), &out_len, &key.get());
		};

		auto res = crypt();

		if (res == CRYPT_BUFFER_OVERFLOW)
		{
			out_data.resize(out_len);
			res = crypt();
		}

		if (res != CRYPT_OK)
		{
			return false;
		}

		out_data.resize(out_len);
		data = std::move(out_data);
		return true;
	}

	std::string rsa::encrypt(const std::string& data, const std::string& hash, const std::string& key)
	{
		rsa_key new_key;
		rsa_import(cs(key.data()), ul(key.size()), &new_key);
		const auto _ = finally([&]()
		{
			rsa_free(&new_key);
		});


		std::string out_data{};
		out_data.resize(std::max(ul(data.size() * 3), ul(0x100)));

		auto out_len = ul(out_data.size());
		auto crypt = [&]()
		{
			return rsa_encrypt_key(cs(data.data()), ul(data.size()), cs(out_data.data()), &out_len, cs(hash.data()),
			                       ul(hash.size()), prng_.get_state(), prng_.get_id(), find_hash("sha512"), &new_key);
		};

		auto res = crypt();

		if (res == CRYPT_BUFFER_OVERFLOW)
		{
			out_data.resize(out_len);
			res = crypt();
		}

		if (res == CRYPT_OK)
		{
			out_data.resize(out_len);
			return out_data;
		}

		return {};
	}

	std::string des3::encrypt(const std::string& data, const std::string& iv, const std::string& key)
	{
		std::string enc_data;
		enc_data.resize(data.size());

		symmetric_CBC cbc;
		const auto des3 = find_cipher("3des");

		cbc_start(des3, cs(iv.data()), cs(key.data()), static_cast<int>(key.size()), 0, &cbc);
		cbc_encrypt(cs(data.data()), cs(enc_data.data()), ul(data.size()), &cbc);
		cbc_done(&cbc);

		return enc_data;
	}

	std::string des3::decrypt(const std::string& data, const std::string& iv, const std::string& key)
	{
		std::string dec_data;
		dec_data.resize(data.size());

		symmetric_CBC cbc;
		const auto des3 = find_cipher("3des");

		cbc_start(des3, cs(iv.data()), cs(key.data()), static_cast<int>(key.size()), 0, &cbc);
		cbc_decrypt(cs(data.data()), cs(dec_data.data()), ul(data.size()), &cbc);
		cbc_done(&cbc);

		return dec_data;
	}

	std::string tiger::compute(const std::string& data, const bool hex)
	{
		return compute(cs(data.data()), data.size(), hex);
	}

	std::string tiger::compute(const uint8_t* data, const size_t length, const bool hex)
	{
		uint8_t buffer[24] = {0};

		hash_state state;
		tiger_init(&state);
		tiger_process(&state, data, ul(length));
		tiger_done(&state, buffer);

		std::string hash(cs(buffer), sizeof(buffer));
		if (!hex) return hash;

		return string::dump_hex(hash, "");
	}

	std::string aes::encrypt(const std::string& data, const std::string& iv, const std::string& key)
	{
		std::string enc_data;
		enc_data.resize(data.size());

		symmetric_CBC cbc;
		const auto aes = find_cipher("aes");

		cbc_start(aes, cs(iv.data()), cs(key.data()),
		          static_cast<int>(key.size()), 0, &cbc);
		cbc_encrypt(cs(data.data()),
		            cs(enc_data.data()),
		            ul(data.size()), &cbc);
		cbc_done(&cbc);

		return enc_data;
	}

	std::string aes::decrypt(const std::string& data, const std::string& iv, const std::string& key)
	{
		std::string dec_data;
		dec_data.resize(data.size());

		symmetric_CBC cbc;
		const auto aes = find_cipher("aes");

		cbc_start(aes, cs(iv.data()), cs(key.data()),
		          static_cast<int>(key.size()), 0, &cbc);
		cbc_decrypt(cs(data.data()),
		            cs(dec_data.data()),
		            ul(data.size()), &cbc);
		cbc_done(&cbc);

		return dec_data;
	}

	std::string hmac_sha1::compute(const std::string& data, const std::string& key)
	{
		std::string buffer;
		buffer.resize(20);

		hmac_state state;
		hmac_init(&state, find_hash("sha1"), cs(key.data()), ul(key.size()));
		hmac_process(&state, cs(data.data()), static_cast<int>(data.size()));

		auto out_len = ul(buffer.size());
		hmac_done(&state, cs(buffer.data()), &out_len);

		buffer.resize(out_len);
		return buffer;
	}

	std::string sha1::compute(const std::string& data, const bool hex)
	{
		return compute(cs(data.data()), data.size(), hex);
	}

	std::string sha1::compute(const uint8_t* data, const size_t length, const bool hex)
	{
		uint8_t buffer[20] = {0};

		hash_state state;
		sha1_init(&state);
		sha1_process(&state, data, ul(length));
		sha1_done(&state, buffer);

		std::string hash(cs(buffer), sizeof(buffer));
		if (!hex) return hash;

		return string::dump_hex(hash, "");
	}

	std::string sha256::compute(const std::string& data, const bool hex)
	{
		return compute(cs(data.data()), data.size(), hex);
	}

	std::string sha256::compute(const uint8_t* data, const size_t length, const bool hex)
	{
		uint8_t buffer[32] = {0};

		hash_state state;
		sha256_init(&state);
		sha256_process(&state, data, ul(length));
		sha256_done(&state, buffer);

		std::string hash(cs(buffer), sizeof(buffer));
		if (!hex) return hash;

		return string::dump_hex(hash, "");
	}

	std::string sha512::compute(const std::string& data, const bool hex)
	{
		return compute(cs(data.data()), data.size(), hex);
	}

	std::string sha512::compute(const uint8_t* data, const size_t length, const bool hex)
	{
		uint8_t buffer[64] = {0};

		hash_state state;
		sha512_init(&state);
		sha512_process(&state, data, ul(length));
		sha512_done(&state, buffer);

		std::string hash(cs(buffer), sizeof(buffer));
		if (!hex) return hash;

		return string::dump_hex(hash, "");
	}

	std::string base64::encode(const uint8_t* data, const size_t len)
	{
		std::string result;
		result.resize((len + 2) * 2);

		auto out_len = ul(result.size());
		if (base64_encode(data, ul(len), result.data(), &out_len) != CRYPT_OK)
		{
			return {};
		}

		result.resize(out_len);
		return result;
	}

	std::string base64::encode(const std::string& data)
	{
		return base64::encode(cs(data.data()), static_cast<unsigned>(data.size()));
	}

	std::string base64::decode(const std::string& data)
	{
		std::string result;
		result.resize((data.size() + 2) * 2);

		auto out_len = ul(result.size());
		if (base64_decode(data.data(), ul(data.size()), cs(result.data()), &out_len) != CRYPT_OK)
		{
			return {};
		}

		result.resize(out_len);
		return result;
	}

	unsigned int jenkins_one_at_a_time::compute(const std::string& data)
	{
		return compute(data.data(), data.size());
	}

	unsigned int jenkins_one_at_a_time::compute(const char* key, const size_t len)
	{
		unsigned int hash, i;
		for (hash = i = 0; i < len; ++i)
		{
			hash += key[i];
			hash += (hash << 10);
			hash ^= (hash >> 6);
		}
		hash += (hash << 3);
		hash ^= (hash >> 11);
		hash += (hash << 15);
		return hash;
	}

	uint32_t random::get_integer()
	{
		uint32_t result;
		random::get_data(&result, sizeof(result));
		return result;
	}

	std::string random::get_challenge()
	{
		std::string result;
		result.resize(sizeof(uint64_t));
		random::get_data(result.data(), result.size());
		return string::dump_hex(result, "");
	}

	void random::get_data(void* data, const size_t size)
	{
		prng_.read(data, size);
	}
}

```

`src/common/utils/cryptography.hpp`:

```hpp
#pragma once

#include <string>
#include <tomcrypt.h>

namespace utils::cryptography
{
	namespace ecc
	{
		class key final
		{
		public:
			key();
			~key();

			key(key&& obj) noexcept;
			key(const key& obj);
			key& operator=(key&& obj) noexcept;
			key& operator=(const key& obj);

			bool is_valid() const;

			ecc_key& get();
			const ecc_key& get() const;

			std::string get_public_key() const;

			void set(const std::string& pub_key_buffer);

			void deserialize(const std::string& key);

			std::string serialize(int type = PK_PRIVATE) const;

			void free();

			bool operator==(key& key) const;

			uint64_t get_hash() const;

		private:
			ecc_key key_storage_{};
		};

		key generate_key(int bits);
		key generate_key(int bits, const std::string& entropy);
		std::string sign_message(const key& key, const std::string& message);
		bool verify_message(const key& key, const std::string& message, const std::string& signature);

		bool encrypt(const key& key, std::string& data);
		bool decrypt(const key& key, std::string& data);
	}

	namespace rsa
	{
		std::string encrypt(const std::string& data, const std::string& hash, const std::string& key);
	}

	namespace des3
	{
		std::string encrypt(const std::string& data, const std::string& iv, const std::string& key);
		std::string decrypt(const std::string& data, const std::string& iv, const std::string& key);
	}

	namespace tiger
	{
		std::string compute(const std::string& data, bool hex = false);
		std::string compute(const uint8_t* data, size_t length, bool hex = false);
	}

	namespace aes
	{
		std::string encrypt(const std::string& data, const std::string& iv, const std::string& key);
		std::string decrypt(const std::string& data, const std::string& iv, const std::string& key);
	}

	namespace hmac_sha1
	{
		std::string compute(const std::string& data, const std::string& key);
	}

	namespace sha1
	{
		std::string compute(const std::string& data, bool hex = false);
		std::string compute(const uint8_t* data, size_t length, bool hex = false);
	}

	namespace sha256
	{
		std::string compute(const std::string& data, bool hex = false);
		std::string compute(const uint8_t* data, size_t length, bool hex = false);
	}

	namespace sha512
	{
		std::string compute(const std::string& data, bool hex = false);
		std::string compute(const uint8_t* data, size_t length, bool hex = false);
	}

	namespace base64
	{
		std::string encode(const uint8_t* data, size_t len);
		std::string encode(const std::string& data);
		std::string decode(const std::string& data);
	}

	namespace jenkins_one_at_a_time
	{
		unsigned int compute(const std::string& data);
		unsigned int compute(const char* key, size_t len);
	};

	namespace random
	{
		uint32_t get_integer();
		std::string get_challenge();
		void get_data(void* data, size_t size);
	}
}

```

`src/common/utils/finally.hpp`:

```hpp
#pragma once
#include <type_traits>

namespace utils
{
	/*
	 * Copied from here: https://github.com/microsoft/GSL/blob/e0880931ae5885eb988d1a8a57acf8bc2b8dacda/include/gsl/util#L57
	 */

	template <class F>
	class final_action
	{
	public:
		static_assert(!std::is_reference<F>::value && !std::is_const<F>::value &&
			!std::is_volatile<F>::value,
			"Final_action should store its callable by value");

		explicit final_action(F f) noexcept : f_(std::move(f))
		{
		}

		final_action(final_action&& other) noexcept
			: f_(std::move(other.f_)), invoke_(std::exchange(other.invoke_, false))
		{
		}

		final_action(const final_action&) = delete;
		final_action& operator=(const final_action&) = delete;
		final_action& operator=(final_action&&) = delete;

		~final_action() noexcept
		{
			if (invoke_) f_();
		}

		// Added by momo5502
		void cancel()
		{
			invoke_ = false;
		}

	private:
		F f_;
		bool invoke_{true};
	};

	template <class F>
	final_action<typename std::remove_cv<typename std::remove_reference<F>::type>::type>
	finally(F&& f) noexcept
	{
		return final_action<typename std::remove_cv<typename std::remove_reference<F>::type>::type>(
			std::forward<F>(f));
	}
}
```

`src/common/utils/flags.cpp`:

```cpp
#include "flags.hpp"
#include "string.hpp"
#include "nt.hpp"

#include <shellapi.h>
#include <unordered_set>

#include "finally.hpp"

namespace utils::flags
{
	std::unordered_set<std::string> parse_flags()
	{
		int num_args{};
		auto* const argv = CommandLineToArgvW(GetCommandLineW(), &num_args);
		const auto _ = finally([&argv]
		{
			if (argv)
			{
				LocalFree(argv);
			}
		});

		std::unordered_set<std::string> flags{};

		for (auto i = 0; i < num_args && argv; ++i)
		{
			std::wstring wide_flag(argv[i]);
			if (wide_flag[0] == L'-')
			{
				wide_flag.erase(wide_flag.begin());
				flags.emplace(string::to_lower(string::convert(wide_flag)));
			}
		}

		return flags;
	}

	bool has_flag(const std::string& flag)
	{
		static const auto enabled_flags = parse_flags();
		return enabled_flags.contains(string::to_lower(flag));
	}
}

```

`src/common/utils/flags.hpp`:

```hpp
#pragma once

#include <string>

namespace utils::flags
{
	bool has_flag(const std::string& flag);
}

```

`src/common/utils/hardware_breakpoint.cpp`:

```cpp
#include "hardware_breakpoint.hpp"
#include "thread.hpp"

namespace utils::hardware_breakpoint
{
	namespace
	{
		void set_bits(uint64_t& value, const uint32_t bit_index, const uint32_t bits, const uint64_t new_value)
		{
			const uint64_t range_mask = (1ull << bits) - 1ull;
			const uint64_t full_mask = ~(range_mask << bit_index);
			value = (value & full_mask) | (new_value << bit_index);
		}

		void validate_index(const uint32_t index)
		{
			if (index >= 4)
			{
				throw std::runtime_error("Invalid index");
			}
		}

		uint32_t translate_length(const uint32_t length)
		{
			if (length != 1 && length != 2 && length != 4)
			{
				throw std::runtime_error("Invalid length");
			}

			return length - 1;
		}

		class debug_context
		{
		public:
			debug_context(uint32_t thread_id)
				: handle_(thread_id, THREAD_SET_CONTEXT | THREAD_GET_CONTEXT)
			{
				if (!this->handle_)
				{
					throw std::runtime_error("Unable to access thread");
				}

				this->context_.ContextFlags = CONTEXT_DEBUG_REGISTERS;

				if (!GetThreadContext(this->handle_, &this->context_))
				{
					throw std::runtime_error("Unable to get thread context");
				}
			}

			~debug_context()
			{
				SetThreadContext(this->handle_, &this->context_);
			}

			debug_context(const debug_context&) = delete;
			debug_context& operator=(const debug_context&) = delete;

			debug_context(debug_context&& obj) noexcept = delete;
			debug_context& operator=(debug_context&& obj) noexcept = delete;

			CONTEXT* operator->()
			{
				return &this->context_;
			}

			operator CONTEXT&()
			{
				return this->context_;
			}

		private:
			thread::handle handle_;
			CONTEXT context_{};
		};

		uint32_t find_free_index(const CONTEXT& context)
		{
			for (uint32_t i = 0; i < 4; ++i)
			{
				if ((context.Dr7 & (1ull << (i << 1ull))) == 0)
				{
					return i;
				}
			}

			throw std::runtime_error("No free index");
		}
	}

	void set_branch_tracing(const bool enabled, CONTEXT& context)
	{
		set_bits(context.Dr7, 8, 1, enabled ? 1 : 0);
	}

	void set_branch_tracing(const bool enabled, const uint32_t thread_id)
	{
		debug_context context(thread_id);
		set_branch_tracing(enabled, context);
	}

	uint32_t activate(const uint64_t address, uint32_t length, const condition cond, CONTEXT& context)
	{
		const auto index = find_free_index(context);
		length = translate_length(length);

		(&context.Dr0)[index] = address;

		set_bits(context.Dr7, 16 + (index << 2ull), 2, cond);
		set_bits(context.Dr7, 18 + (index << 2ull), 2, length);
		set_bits(context.Dr7, index << 1ull, 1, 1);

		return index;
	}

	uint32_t activate(void* address, const uint32_t length, const condition cond, const uint32_t thread_id)
	{
		return activate(reinterpret_cast<uint64_t>(address), length, cond, thread_id);
	}

	uint32_t activate(const uint64_t address, const uint32_t length, const condition cond, const uint32_t thread_id)
	{
		debug_context context(thread_id);
		return activate(address, length, cond, context);
	}

	void deactivate_address(const uint64_t address, CONTEXT& context)
	{
		for (auto i = 0; i < 4; ++i)
		{
			if ((&context.Dr0)[i] == address)
			{
				deactivate(i, context);
			}
		}
	}

	void deactivate_address(void* address, const uint32_t thread_id)
	{
		return deactivate_address(reinterpret_cast<uint64_t>(address), thread_id);
	}

	void deactivate_address(const uint64_t address, const uint32_t thread_id)
	{
		debug_context context(thread_id);
		deactivate_address(address, context);
	}

	void deactivate(const uint32_t index, CONTEXT& context)
	{
		validate_index(index);
		set_bits(context.Dr7, index << 1ull, 1, 0);
	}

	void deactivate(const uint32_t index, const uint32_t thread_id)
	{
		debug_context context(thread_id);
		deactivate(index, context);
	}

	void deactivate_all(CONTEXT& context)
	{
		context.Dr7 = 0;
	}

	void deactivate_all(const uint32_t thread_id)
	{
		debug_context context(thread_id);
		deactivate_all(context);
	}
}

```

`src/common/utils/hardware_breakpoint.hpp`:

```hpp
#pragma once
#include <thread>
#include "nt.hpp"

namespace utils::hardware_breakpoint
{
	enum condition
	{
		execute = 0,
		write = 1,
		read_write = 3
	};


	void set_branch_tracing(bool enabled, CONTEXT& context);
	void set_branch_tracing(bool enabled, uint32_t thread_id = GetCurrentThreadId());

	uint32_t activate(uint64_t address, uint32_t length, condition cond, CONTEXT& context);
	uint32_t activate(void* address, uint32_t length, condition cond, uint32_t thread_id = GetCurrentThreadId());
	uint32_t activate(uint64_t address, uint32_t length, condition cond, uint32_t thread_id = GetCurrentThreadId());

	void deactivate_address(uint64_t address, CONTEXT& context);
	void deactivate_address(void* address, uint32_t thread_id = GetCurrentThreadId());
	void deactivate_address(uint64_t address, uint32_t thread_id = GetCurrentThreadId());

	void deactivate(uint32_t index, CONTEXT& context);
	void deactivate(uint32_t index, uint32_t thread_id = GetCurrentThreadId());

	void deactivate_all(CONTEXT& context);
	void deactivate_all(uint32_t thread_id = GetCurrentThreadId());
}

```

`src/common/utils/hook.cpp`:

```cpp
#include "hook.hpp"

#include <map>
#include <MinHook.h>

#include "concurrency.hpp"
#include "string.hpp"
#include "nt.hpp"

#ifdef max
#undef max
#endif

#ifdef min
#undef min
#endif

namespace utils::hook
{
	namespace
	{
		uint8_t* allocate_somewhere_near(const void* base_address, const size_t size)
		{
			size_t offset = 0;
			while (true)
			{
				offset += size;
				auto* target_address = static_cast<const uint8_t*>(base_address) - offset;
				if (is_relatively_far(base_address, target_address))
				{
					return nullptr;
				}

				const auto res = VirtualAlloc(const_cast<uint8_t*>(target_address), size, MEM_RESERVE | MEM_COMMIT,
				                              PAGE_EXECUTE_READWRITE);
				if (res)
				{
					if (is_relatively_far(base_address, target_address))
					{
						VirtualFree(res, 0, MEM_RELEASE);
						return nullptr;
					}

					return static_cast<uint8_t*>(res);
				}
			}
		}

		class memory
		{
		public:
			memory() = default;

			memory(const void* ptr)
				: memory()
			{
				this->length_ = 0x1000;
				this->buffer_ = allocate_somewhere_near(ptr, this->length_);
				if (!this->buffer_)
				{
					throw std::runtime_error("Failed to allocate");
				}
			}

			~memory()
			{
				if (this->buffer_)
				{
					VirtualFree(this->buffer_, 0, MEM_RELEASE);
				}
			}

			memory(memory&& obj) noexcept
				: memory()
			{
				this->operator=(std::move(obj));
			}

			memory& operator=(memory&& obj) noexcept
			{
				if (this != &obj)
				{
					this->~memory();
					this->buffer_ = obj.buffer_;
					this->length_ = obj.length_;
					this->offset_ = obj.offset_;

					obj.buffer_ = nullptr;
					obj.length_ = 0;
					obj.offset_ = 0;
				}

				return *this;
			}

			void* allocate(const size_t length)
			{
				if (!this->buffer_)
				{
					return nullptr;
				}

				if (this->offset_ + length > this->length_)
				{
					return nullptr;
				}

				const auto ptr = this->get_ptr();
				this->offset_ += length;
				return ptr;
			}

			void* get_ptr() const
			{
				return this->buffer_ + this->offset_;
			}

		private:
			uint8_t* buffer_{};
			size_t length_{};
			size_t offset_{};
		};

		void* get_memory_near(const void* address, const size_t size)
		{
			static concurrency::container<std::vector<memory>> memory_container{};

			return memory_container.access<void*>([&](std::vector<memory>& memories)
			{
				for (auto& memory : memories)
				{
					if (!is_relatively_far(address, memory.get_ptr()))
					{
						const auto buffer = memory.allocate(size);
						if (buffer)
						{
							return buffer;
						}
					}
				}

				memories.emplace_back(address);
				return memories.back().allocate(size);
			});
		}

		void* initialize_min_hook()
		{
			static class min_hook_init
			{
			public:
				min_hook_init()
				{
					if (MH_Initialize() != MH_OK)
					{
						throw std::runtime_error("Failed to initialize MinHook");
					}
				}

				~min_hook_init()
				{
					MH_Uninitialize();
				}
			} min_hook_init;
			return &min_hook_init;
		}
	}

	void assembler::pushad64()
	{
		this->push(rax);
		this->push(rcx);
		this->push(rdx);
		this->push(rbx);
		this->push(rsp);
		this->push(rbp);
		this->push(rsi);
		this->push(rdi);

		this->sub(rsp, 0x40);
	}

	void assembler::popad64()
	{
		this->add(rsp, 0x40);

		this->pop(rdi);
		this->pop(rsi);
		this->pop(rbp);
		this->pop(rsp);
		this->pop(rbx);
		this->pop(rdx);
		this->pop(rcx);
		this->pop(rax);
	}

	void assembler::prepare_stack_for_call()
	{
		const auto reserve_callee_space = this->newLabel();
		const auto stack_unaligned = this->newLabel();

		this->test(rsp, 0xF);
		this->jnz(stack_unaligned);

		this->sub(rsp, 0x8);
		this->push(rsp);

		this->push(rax);
		this->mov(rax, ptr(rsp, 8, 8));
		this->add(rax, 0x8);
		this->mov(ptr(rsp, 8, 8), rax);
		this->pop(rax);

		this->jmp(reserve_callee_space);

		this->bind(stack_unaligned);
		this->push(rsp);

		this->bind(reserve_callee_space);
		this->sub(rsp, 0x40);
	}

	void assembler::restore_stack_after_call()
	{
		this->lea(rsp, ptr(rsp, 0x40));
		this->pop(rsp);
	}

	asmjit::Error assembler::call(void* target)
	{
		return Assembler::call(size_t(target));
	}

	asmjit::Error assembler::jmp(void* target)
	{
		return Assembler::jmp(size_t(target));
	}

	detour::detour()
	{
		(void)initialize_min_hook();
	}

	detour::detour(const size_t place, void* target)
		: detour(reinterpret_cast<void*>(place), target)
	{
	}

	detour::detour(void* place, void* target)
		: detour()
	{
		this->create(place, target);
	}

	detour::~detour()
	{
		this->clear();
	}

	void detour::enable()
	{
		MH_EnableHook(this->place_);

		if (!this->moved_data_.empty())
		{
			this->move();
		}
	}

	void detour::disable()
	{
		this->un_move();
		MH_DisableHook(this->place_);
	}

	void detour::create(void* place, void* target)
	{
		this->clear();
		this->place_ = place;

		if (MH_CreateHook(this->place_, target, &this->original_) != MH_OK)
		{
			throw std::runtime_error(string::va("Unable to create hook at location: %p", this->place_));
		}

		this->enable();
	}

	void detour::create(const size_t place, void* target)
	{
		this->create(reinterpret_cast<void*>(place), target);
	}

	void detour::clear()
	{
		if (this->place_)
		{
			this->un_move();
			MH_RemoveHook(this->place_);
		}

		this->place_ = nullptr;
		this->original_ = nullptr;
		this->moved_data_ = {};
	}

	void detour::move()
	{
		this->moved_data_ = move_hook(this->place_);
	}

	void* detour::get_place() const
	{
		return this->place_;
	}

	void* detour::get_original() const
	{
		return this->original_;
	}

	void detour::un_move()
	{
		if (!this->moved_data_.empty())
		{
			copy(this->place_, this->moved_data_.data(), this->moved_data_.size());
		}
	}

	std::optional<std::pair<void*, void*>> iat(const nt::library& library, const std::string& target_library, const std::string& process, void* stub)
	{
		if (!library.is_valid()) return {};

		auto* const ptr = library.get_iat_entry(target_library, process);
		if (!ptr) return {};

		DWORD protect;
		VirtualProtect(ptr, sizeof(*ptr), PAGE_EXECUTE_READWRITE, &protect);

		std::swap(*ptr, stub);

		VirtualProtect(ptr, sizeof(*ptr), protect, &protect);
		return {{ptr, stub}};
	}

	void nop(void* place, const size_t length)
	{
		DWORD old_protect{};
		VirtualProtect(place, length, PAGE_EXECUTE_READWRITE, &old_protect);

		std::memset(place, 0x90, length);

		VirtualProtect(place, length, old_protect, &old_protect);
		FlushInstructionCache(GetCurrentProcess(), place, length);
	}

	void nop(const size_t place, const size_t length)
	{
		nop(reinterpret_cast<void*>(place), length);
	}

	void copy(void* place, const void* data, const size_t length)
	{
		DWORD old_protect{};
		VirtualProtect(place, length, PAGE_EXECUTE_READWRITE, &old_protect);

		std::memmove(place, data, length);

		VirtualProtect(place, length, old_protect, &old_protect);
		FlushInstructionCache(GetCurrentProcess(), place, length);
	}

	void copy(const size_t place, const void* data, const size_t length)
	{
		copy(reinterpret_cast<void*>(place), data, length);
	}

	void copy_string(void* place, const char* str)
	{
		copy(reinterpret_cast<void*>(place), str, strlen(str) + 1);
	}

	void copy_string(const size_t place, const char* str)
	{
		copy_string(reinterpret_cast<void*>(place), str);
	}

	bool is_relatively_far(const void* pointer, const void* data, const int offset)
	{
		const int64_t diff = size_t(data) - (size_t(pointer) + offset);
		const auto small_diff = int32_t(diff);
		return diff != int64_t(small_diff);
	}

	void call(void* pointer, void* data)
	{
		if (is_relatively_far(pointer, data))
		{
			auto* trampoline = get_memory_near(pointer, 14);
			if (!trampoline)
			{
				throw std::runtime_error("Too far away to create 32bit relative branch");
			}

			call(pointer, trampoline);
			jump(trampoline, data, true, true);
			return;
		}

		uint8_t copy_data[5];
		copy_data[0] = 0xE8;
		*reinterpret_cast<int32_t*>(&copy_data[1]) = int32_t(size_t(data) - (size_t(pointer) + 5));

		auto* patch_pointer = PBYTE(pointer);
		copy(patch_pointer, copy_data, sizeof(copy_data));
	}

	void call(const size_t pointer, void* data)
	{
		return call(reinterpret_cast<void*>(pointer), data);
	}

	void call(const size_t pointer, const size_t data)
	{
		return call(pointer, reinterpret_cast<void*>(data));
	}

	void jump(void* pointer, void* data, const bool use_far, const bool use_safe)
	{
		static const unsigned char jump_data[] = {
			0x48, 0xb8, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0xff, 0xe0
		};

		static const unsigned char jump_data_safe[] = {
			0xFF, 0x25, 0x00, 0x00, 0x00, 0x00
		};

		if (!use_far && is_relatively_far(pointer, data))
		{
			auto* trampoline = get_memory_near(pointer, 14);
			if (!trampoline)
			{
				throw std::runtime_error("Too far away to create 32bit relative branch");
			}
			jump(pointer, trampoline, false, false);
			jump(trampoline, data, true, true);
			return;
		}

		auto* patch_pointer = PBYTE(pointer);

		if (use_far)
		{
			if (use_safe)
			{
				uint8_t copy_data[sizeof(jump_data_safe) + sizeof(data)];
				memcpy(copy_data, jump_data_safe, sizeof(jump_data_safe));
				memcpy(copy_data + sizeof(jump_data_safe), &data, sizeof(data));

				copy(patch_pointer, copy_data, sizeof(copy_data));
			}
			else
			{
				uint8_t copy_data[sizeof(jump_data)];
				memcpy(copy_data, jump_data, sizeof(jump_data));
				memcpy(copy_data + 2, &data, sizeof(data));

				copy(patch_pointer, copy_data, sizeof(copy_data));
			}
		}
		else
		{
			uint8_t copy_data[5];
			copy_data[0] = 0xE9;
			*reinterpret_cast<int32_t*>(&copy_data[1]) = int32_t(size_t(data) - (size_t(pointer) + 5));

			copy(patch_pointer, copy_data, sizeof(copy_data));
		}
	}

	void jump(const size_t pointer, void* data, const bool use_far, const bool use_safe)
	{
		return jump(reinterpret_cast<void*>(pointer), data, use_far, use_safe);
	}

	void jump(const size_t pointer, const size_t data, const bool use_far, const bool use_safe)
	{
		return jump(pointer, reinterpret_cast<void*>(data), use_far, use_safe);
	}

	void* assemble(const std::function<void(assembler&)>& asm_function)
	{
		static asmjit::JitRuntime runtime;

		asmjit::CodeHolder code;
		code.init(runtime.environment());

		assembler a(&code);

		asm_function(a);

		void* result = nullptr;
		runtime.add(&result, &code);

		return result;
	}

	void inject(void* pointer, const void* data)
	{
		if (is_relatively_far(pointer, data, 4))
		{
			throw std::runtime_error("Too far away to create 32bit relative branch");
		}

		set<int32_t>(pointer, int32_t(size_t(data) - (size_t(pointer) + 4)));
	}

	void inject(const size_t pointer, const void* data)
	{
		return inject(reinterpret_cast<void*>(pointer), data);
	}

	std::vector<uint8_t> move_hook(void* pointer)
	{
		std::vector<uint8_t> original_data{};

		auto* data_ptr = static_cast<uint8_t*>(pointer);
		if (data_ptr[0] == 0xE9)
		{
			original_data.resize(6);
			memmove(original_data.data(), pointer, original_data.size());

			auto* target = follow_branch(data_ptr);
			nop(data_ptr, 1);
			jump(data_ptr + 1, target);
		}
		else if (data_ptr[0] == 0xFF && data_ptr[1] == 0x25)
		{
			original_data.resize(15);
			memmove(original_data.data(), pointer, original_data.size());

			copy(data_ptr + 1, data_ptr, 14);
			nop(data_ptr, 1);
		}
		else
		{
			throw std::runtime_error("No branch instruction found");
		}

		return original_data;
	}

	std::vector<uint8_t> move_hook(const size_t pointer)
	{
		return move_hook(reinterpret_cast<void*>(pointer));
	}

	void* follow_branch(void* address)
	{
		auto* const data = static_cast<uint8_t*>(address);
		if (*data != 0xE8 && *data != 0xE9)
		{
			throw std::runtime_error("No branch instruction found");
		}

		return extract<void*>(data + 1);
	}
}

```

`src/common/utils/hook.hpp`:

```hpp
#pragma once
#include "signature.hpp"

#include <asmjit/core/jitruntime.h>
#include <asmjit/x86/x86assembler.h>

using namespace asmjit::x86;

namespace utils::hook
{
	namespace detail
	{
		template <size_t Entries>
		std::vector<size_t(*)()> get_iota_functions()
		{
			if constexpr (Entries == 0)
			{
				std::vector<size_t(*)()> functions;
				return functions;
			}
			else
			{
				auto functions = get_iota_functions<Entries - 1>();
				functions.emplace_back([]()
				{
					return Entries - 1;
				});
				return functions;
			}
		}
	}

	// Gets the pointer to the entry in the v-table.
	// It seems otherwise impossible to get this.
	// This is ugly as fuck and only safely works on x64
	// Example:
	//   ID3D11Device* device = ...
	//   auto entry = get_vtable_entry(device, &ID3D11Device::CreateTexture2D);
	template <size_t Entries = 100, typename Class, typename T, typename... Args>
	void** get_vtable_entry(Class* obj, T (Class::* entry)(Args ...))
	{
		union
		{
			decltype(entry) func;
			void* pointer;
		};

		func = entry;

		auto iota_functions = detail::get_iota_functions<Entries>();
		auto* object = iota_functions.data();

		using fake_func = size_t(__thiscall*)(void* self);
		auto index = static_cast<fake_func>(pointer)(&object);

		void** obj_v_table = *reinterpret_cast<void***>(obj);
		return &obj_v_table[index];
	}

	class assembler : public Assembler
	{
	public:
		using Assembler::Assembler;
		using Assembler::call;
		using Assembler::jmp;

		void pushad64();
		void popad64();

		void prepare_stack_for_call();
		void restore_stack_after_call();

		template <typename T>
		void call_aligned(T&& target)
		{
			this->prepare_stack_for_call();
			this->call(std::forward<T>(target));
			this->restore_stack_after_call();
		}

		asmjit::Error call(void* target);
		asmjit::Error jmp(void* target);
	};

	class detour
	{
	public:
		detour();
		detour(void* place, void* target);
		detour(size_t place, void* target);
		~detour();

		detour(detour&& other) noexcept
		{
			this->operator=(std::move(other));
		}

		detour& operator=(detour&& other) noexcept
		{
			if (this != &other)
			{
				this->clear();

				this->place_ = other.place_;
				this->original_ = other.original_;
				this->moved_data_ = other.moved_data_;

				other.place_ = nullptr;
				other.original_ = nullptr;
				other.moved_data_ = {};
			}

			return *this;
		}

		detour(const detour&) = delete;
		detour& operator=(const detour&) = delete;

		void enable();
		void disable();

		void create(void* place, void* target);
		void create(size_t place, void* target);
		void clear();

		void move();

		void* get_place() const;

		template <typename T>
		T* get() const
		{
			return static_cast<T*>(this->get_original());
		}

		template <typename T = void, typename... Args>
		T invoke(Args ... args)
		{
			return static_cast<T(*)(Args ...)>(this->get_original())(args...);
		}

		[[nodiscard]] void* get_original() const;

	private:
		std::vector<uint8_t> moved_data_{};
		void* place_{};
		void* original_{};

		void un_move();
	};

	std::optional<std::pair<void*, void*>> iat(const nt::library& library, const std::string& target_library,
	                                           const std::string& process, void* stub);

	void nop(void* place, size_t length);
	void nop(size_t place, size_t length);

	void copy(void* place, const void* data, size_t length);
	void copy(size_t place, const void* data, size_t length);

	void copy_string(void* place, const char* str);
	void copy_string(size_t place, const char* str);

	bool is_relatively_far(const void* pointer, const void* data, int offset = 5);

	void call(void* pointer, void* data);
	void call(size_t pointer, void* data);
	void call(size_t pointer, size_t data);

	void jump(void* pointer, void* data, bool use_far = false, bool use_safe = false);
	void jump(size_t pointer, void* data, bool use_far = false, bool use_safe = false);
	void jump(size_t pointer, size_t data, bool use_far = false, bool use_safe = false);

	void* assemble(const std::function<void(assembler&)>& asm_function);

	void inject(void* pointer, const void* data);
	void inject(size_t pointer, const void* data);

	std::vector<uint8_t> move_hook(void* pointer);
	std::vector<uint8_t> move_hook(size_t pointer);

	template <typename T>
	T extract(void* address)
	{
		auto* const data = static_cast<uint8_t*>(address);
		const auto offset = *reinterpret_cast<int32_t*>(data);
		return reinterpret_cast<T>(data + offset + 4);
	}

	void* follow_branch(void* address);

	template <typename T>
	static void set(void* place, T value = false)
	{
		copy(place, &value, sizeof(value));
	}

	template <typename T>
	static void set(const size_t place, T value = false)
	{
		return set<T>(reinterpret_cast<void*>(place), value);
	}

	template <typename T, typename... Args>
	static T invoke(size_t func, Args ... args)
	{
		return reinterpret_cast<T(*)(Args ...)>(func)(args...);
	}

	template <typename T, typename... Args>
	static T invoke(void* func, Args ... args)
	{
		return static_cast<T(*)(Args ...)>(func)(args...);
	}
}

```

`src/common/utils/http.cpp`:

```cpp
#include "http.hpp"
#include "nt.hpp"
#include <atlcomcli.h>

namespace utils::http
{
	std::optional<std::string> get_data(const std::string& url)
	{
		CComPtr<IStream> stream;

		if (FAILED(URLOpenBlockingStreamA(nullptr, url.data(), &stream, 0, nullptr)))
		{
			return {};
		}

		char buffer[0x1000];
		std::string result;

		HRESULT status{};

		do
		{
			DWORD bytes_read = 0;
			status = stream->Read(buffer, sizeof(buffer), &bytes_read);

			if (bytes_read > 0)
			{
				result.append(buffer, bytes_read);
			}
		}
		while (SUCCEEDED(status) && status != S_FALSE);

		if (FAILED(status))
		{
			return {};
		}

		return {result};
	}

	std::future<std::optional<std::string>> get_data_async(const std::string& url)
	{
		return std::async(std::launch::async, [url]()
		{
			return get_data(url);
		});
	}
}

```

`src/common/utils/http.hpp`:

```hpp
#pragma once

#include <string>
#include <optional>
#include <future>

namespace utils::http
{
	std::optional<std::string> get_data(const std::string& url);
	std::future<std::optional<std::string>> get_data_async(const std::string& url);
}

```

`src/common/utils/image.cpp`:

```cpp
#include "image.hpp"
#include <stdexcept>

#pragma warning(push)
#pragma warning(disable: 4100)
#pragma warning(disable: 4244)
#define STBI_ONLY_JPEG
#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>
#pragma warning(pop)

#include "finally.hpp"

namespace utils::image
{
	image load_image(const std::string& data)
	{
		stbi_uc* buffer{};
		const auto _ = finally([&]
		{
			if (buffer)
			{
				stbi_image_free(buffer);
			}
		});

		constexpr int channels = 4;
		int x, y, channels_in_file;
		buffer = stbi_load_from_memory(reinterpret_cast<const uint8_t*>(data.data()),
		                               static_cast<int>(data.size()), &x, &y, &channels_in_file, channels);
		if (!buffer)
		{
			throw std::runtime_error("Failed to load image");
		}

		image res{};
		res.width = static_cast<size_t>(x);
		res.height = static_cast<size_t>(y);
		res.data.assign(reinterpret_cast<const char*>(buffer), res.width * res.height * channels);

		return res;
	}

	object create_bitmap(const image& img)
	{
		auto copy = img.data;

		for (size_t i = 0; i < (img.width * img.height); ++i)
		{
			auto& r = copy[i * 4 + 0];
			auto& b = copy[i * 4 + 2];
			std::swap(r, b);
		}

		return CreateBitmap(static_cast<int>(img.width), static_cast<int>(img.height), 4, 8, copy.data());
	}
}

```

`src/common/utils/image.hpp`:

```hpp
#pragma once

#include <string>
#include "nt.hpp"

namespace utils::image
{
	struct image
	{
		size_t width;
		size_t height;
		std::string data;
	};

	class object
	{
	public:
		object() = default;

		object(const HGDIOBJ h)
			: handle_(h)
		{
		}

		~object()
		{
			if (*this)
			{
				DeleteObject(this->handle_);
				this->handle_ = nullptr;
			}
		}

		object(const object&) = delete;
		object& operator=(const object&) = delete;

		object(object&& obj) noexcept
			: object()
		{
			this->operator=(std::move(obj));
		}

		object& operator=(object&& obj) noexcept
		{
			if (this != &obj)
			{
				this->~object();
				this->handle_ = obj.handle_;
				obj.handle_ = nullptr;
			}

			return *this;
		}

		object& operator=(HANDLE h) noexcept
		{
			this->~object();
			this->handle_ = h;

			return *this;
		}

		HGDIOBJ get() const
		{
			return this->handle_;
		}

		operator bool() const
		{
			return this->handle_ != nullptr;
		}

		operator HGDIOBJ() const
		{
			return this->handle_;
		}

		operator LPARAM() const
		{
			return reinterpret_cast<LPARAM>(this->handle_);
		}

	private:
		HGDIOBJ handle_{nullptr};
	};

	image load_image(const std::string& data);
	object create_bitmap(const image& img);
}

```

`src/common/utils/info_string.cpp`:

```cpp
#include "info_string.hpp"
#include "string.hpp"

namespace utils
{
	info_string::info_string(const std::string& buffer)
	{
		this->parse(buffer);
	}

	info_string::info_string(const std::string_view& buffer)
		: info_string(std::string{buffer})
	{
	}


	info_string::info_string(const std::basic_string_view<uint8_t>& buffer)
		: info_string(std::string_view(reinterpret_cast<const char*>(buffer.data()), buffer.size()))
	{
	}

	void info_string::set(const std::string& key, const std::string& value)
	{
		this->key_value_pairs_[key] = value;
	}

	std::string info_string::get(const std::string& key) const
	{
		const auto value = this->key_value_pairs_.find(key);
		if (value != this->key_value_pairs_.end())
		{
			return value->second;
		}

		return {};
	}

	void info_string::parse(std::string buffer)
	{
		if (buffer[0] == '\\')
		{
			buffer = buffer.substr(1);
		}

		auto key_values = string::split(buffer, '\\');
		for (size_t i = 0; !key_values.empty() && i < (key_values.size() - 1); i += 2)
		{
			const auto& key = key_values[i];
			const auto& value = key_values[i + 1];
			this->key_value_pairs_[key] = value;
		}
	}

	std::string info_string::build() const
	{
		//auto first = true;
		std::string info_string;
		for (auto i = this->key_value_pairs_.begin(); i != this->key_value_pairs_.end(); ++i)
		{
			//if (first) first = false;
			/*else*/
			info_string.append("\\");

			info_string.append(i->first); // Key
			info_string.append("\\");
			info_string.append(i->second); // Value
		}

		return info_string;
	}
}

```

`src/common/utils/info_string.hpp`:

```hpp
#pragma once

#include <string>
#include <unordered_map>

namespace utils
{
	class info_string
	{
	public:
		info_string() = default;
		info_string(const std::string& buffer);
		info_string(const std::string_view& buffer);
		info_string(const std::basic_string_view<uint8_t>& buffer);

		void set(const std::string& key, const std::string& value);
		std::string get(const std::string& key) const;
		std::string build() const;

	private:
		std::unordered_map<std::string, std::string> key_value_pairs_{};

		void parse(std::string buffer);
	};
}

```

`src/common/utils/io.cpp`:

```cpp
#include "io.hpp"
#include "nt.hpp"
#include <fstream>

namespace utils::io
{
	bool remove_file(const std::filesystem::path& file)
	{
		if(DeleteFileW(file.wstring().data()) != FALSE)
		{
			return true;
		}

		return GetLastError() == ERROR_FILE_NOT_FOUND;
	}

	bool move_file(const std::filesystem::path& src, const std::filesystem::path& target)
	{
		return MoveFileW(src.wstring().data(), target.wstring().data()) == TRUE;
	}

	bool file_exists(const std::string& file)
	{
		return std::ifstream(file).good();
	}

	bool write_file(const std::string& file, const std::string& data, const bool append)
	{
		const auto pos = file.find_last_of("/\\");
		if (pos != std::string::npos)
		{
			create_directory(file.substr(0, pos));
		}

		std::ofstream stream(
			file, std::ios::binary | std::ofstream::out | (append ? std::ofstream::app : 0));

		if (stream.is_open())
		{
			stream.write(data.data(), static_cast<std::streamsize>(data.size()));
			stream.close();
			return true;
		}

		return false;
	}

	std::string read_file(const std::string& file)
	{
		std::string data;
		read_file(file, &data);
		return data;
	}

	bool read_file(const std::string& file, std::string* data)
	{
		if (!data) return false;
		data->clear();

		if (file_exists(file))
		{
			std::ifstream stream(file, std::ios::binary);
			if (!stream.is_open()) return false;

			stream.seekg(0, std::ios::end);
			const std::streamsize size = stream.tellg();
			stream.seekg(0, std::ios::beg);

			if (size > -1)
			{
				data->resize(static_cast<std::uint32_t>(size));
				stream.read(data->data(), size);
				stream.close();
				return true;
			}
		}

		return false;
	}

	std::size_t file_size(const std::string& file)
	{
		if (file_exists(file))
		{
			std::ifstream stream(file, std::ios::binary);

			if (stream.good())
			{
				stream.seekg(0, std::ios::end);
				return static_cast<std::size_t>(stream.tellg());
			}
		}

		return 0;
	}

	bool create_directory(const std::filesystem::path& directory)
	{
		return std::filesystem::create_directories(directory);
	}

	bool directory_exists(const std::filesystem::path& directory)
	{
		return std::filesystem::is_directory(directory);
	}

	bool directory_is_empty(const std::filesystem::path& directory)
	{
		return std::filesystem::is_empty(directory);
	}

	std::vector<std::string> list_files(const std::filesystem::path& directory)
	{
		std::vector<std::string> files;

		for (auto& file : std::filesystem::directory_iterator(directory))
		{
			files.push_back(file.path().generic_string());
		}

		return files;
	}

	void copy_folder(const std::filesystem::path& src, const std::filesystem::path& target)
	{
		std::filesystem::copy(src, target,
		                      std::filesystem::copy_options::overwrite_existing |
		                      std::filesystem::copy_options::recursive);
	}
}

```

`src/common/utils/io.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <filesystem>

namespace utils::io
{
	bool remove_file(const std::filesystem::path& file);
	bool move_file(const std::filesystem::path& src, const std::filesystem::path& target);
	bool file_exists(const std::string& file);
	bool write_file(const std::string& file, const std::string& data, bool append = false);
	bool read_file(const std::string& file, std::string* data);
	std::string read_file(const std::string& file);
	size_t file_size(const std::string& file);
	bool create_directory(const std::filesystem::path& directory);
	bool directory_exists(const std::filesystem::path& directory);
	bool directory_is_empty(const std::filesystem::path& directory);
	std::vector<std::string> list_files(const std::filesystem::path& directory);
	void copy_folder(const std::filesystem::path& src, const std::filesystem::path& target);
}

```

`src/common/utils/memory.cpp`:

```cpp
#include "memory.hpp"
#include "nt.hpp"

namespace utils
{
	memory::allocator memory::mem_allocator_;

	memory::allocator::~allocator()
	{
		this->clear();
	}

	void memory::allocator::clear()
	{
		std::lock_guard _(this->mutex_);

		for (auto& data : this->pool_)
		{
			memory::free(data);
		}

		this->pool_.clear();
	}

	void memory::allocator::free(void* data)
	{
		std::lock_guard _(this->mutex_);

		const auto j = std::find(this->pool_.begin(), this->pool_.end(), data);
		if (j != this->pool_.end())
		{
			memory::free(data);
			this->pool_.erase(j);
		}
	}

	void memory::allocator::free(const void* data)
	{
		this->free(const_cast<void*>(data));
	}

	void* memory::allocator::allocate(const size_t length)
	{
		std::lock_guard _(this->mutex_);

		const auto data = memory::allocate(length);
		this->pool_.push_back(data);
		return data;
	}

	bool memory::allocator::empty() const
	{
		return this->pool_.empty();
	}

	char* memory::allocator::duplicate_string(const std::string& string)
	{
		std::lock_guard _(this->mutex_);

		const auto data = memory::duplicate_string(string);
		this->pool_.push_back(data);
		return data;
	}

	bool memory::allocator::find(const void* data)
	{
		std::lock_guard _(this->mutex_);

		const auto j = std::find(this->pool_.begin(), this->pool_.end(), data);
		return j != this->pool_.end();
	}

	void* memory::allocate(const size_t length)
	{
		return std::calloc(length, 1);
	}

	char* memory::duplicate_string(const std::string& string)
	{
		const auto new_string = allocate_array<char>(string.size() + 1);
		std::memcpy(new_string, string.data(), string.size());
		return new_string;
	}

	void memory::free(void* data)
	{
		std::free(data);
	}

	void memory::free(const void* data)
	{
		free(const_cast<void*>(data));
	}

	bool memory::is_set(const void* mem, const char chr, const size_t length)
	{
		const auto mem_arr = static_cast<const char*>(mem);

		for (size_t i = 0; i < length; ++i)
		{
			if (mem_arr[i] != chr)
			{
				return false;
			}
		}

		return true;
	}

	bool memory::is_bad_read_ptr(const void* ptr)
	{
		MEMORY_BASIC_INFORMATION mbi = {};
		if (VirtualQuery(ptr, &mbi, sizeof(mbi)))
		{
			const DWORD mask = (PAGE_READONLY | PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READ |
				PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY);
			auto b = !(mbi.Protect & mask);
			// check the page is not a guard page
			if (mbi.Protect & (PAGE_GUARD | PAGE_NOACCESS)) b = true;

			return b;
		}
		return true;
	}

	bool memory::is_bad_code_ptr(const void* ptr)
	{
		MEMORY_BASIC_INFORMATION mbi = {};
		if (VirtualQuery(ptr, &mbi, sizeof(mbi)))
		{
			const DWORD mask = (PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY);
			auto b = !(mbi.Protect & mask);
			// check the page is not a guard page
			if (mbi.Protect & (PAGE_GUARD | PAGE_NOACCESS)) b = true;

			return b;
		}
		return true;
	}

	bool memory::is_rdata_ptr(void* pointer)
	{
		const std::string rdata = ".rdata";
		const auto pointer_lib = utils::nt::library::get_by_address(pointer);

		for (const auto& section : pointer_lib.get_section_headers())
		{
			const auto size = sizeof(section->Name);
			char name[size + 1];
			name[size] = 0;
			std::memcpy(name, section->Name, size);

			if (name == rdata)
			{
				const auto target = size_t(pointer);
				const size_t source_start = size_t(pointer_lib.get_ptr()) + section->PointerToRawData;
				const size_t source_end = source_start + section->SizeOfRawData;

				return target >= source_start && target <= source_end;
			}
		}

		return false;
	}

	memory::allocator* memory::get_allocator()
	{
		return &memory::mem_allocator_;
	}
}

```

`src/common/utils/memory.hpp`:

```hpp
#pragma once

#include <mutex>
#include <vector>

namespace utils
{
	class memory final
	{
	public:
		class allocator final
		{
		public:
			~allocator();

			void clear();

			void free(void* data);

			void free(const void* data);

			void* allocate(size_t length);

			template <typename T>
			T* allocate()
			{
				return this->allocate_array<T>(1);
			}

			template <typename T>
			T* allocate_array(const size_t count = 1)
			{
				return static_cast<T*>(this->allocate(count * sizeof(T)));
			}

			bool empty() const;

			char* duplicate_string(const std::string& string);

			bool find(const void* data);

		private:
			std::mutex mutex_;
			std::vector<void*> pool_;
		};

		static void* allocate(size_t length);

		template <typename T>
		static T* allocate()
		{
			return allocate_array<T>(1);
		}

		template <typename T>
		static T* allocate_array(const size_t count = 1)
		{
			return static_cast<T*>(allocate(count * sizeof(T)));
		}

		static char* duplicate_string(const std::string& string);

		static void free(void* data);
		static void free(const void* data);

		static bool is_set(const void* mem, char chr, size_t length);

		static bool is_bad_read_ptr(const void* ptr);
		static bool is_bad_code_ptr(const void* ptr);
		static bool is_rdata_ptr(void* ptr);

		static allocator* get_allocator();

	private:
		static allocator mem_allocator_;
	};
}

```

`src/common/utils/nt.cpp`:

```cpp
#include "nt.hpp"

namespace utils::nt
{
	library library::load(const char* name)
	{
		return library(LoadLibraryA(name));
	}

	library library::load(const std::string& name)
	{
		return library::load(name.data());
	}

	library library::load(const std::filesystem::path& path)
	{
		return library::load(path.generic_string());
	}

	library library::get_by_address(const void* address)
	{
		HMODULE handle = nullptr;
		GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
		                   static_cast<LPCSTR>(address), &handle);
		return library(handle);
	}

	library::library()
		: module_(GetModuleHandleA(nullptr))
	{
	}

	library::library(const std::string& name)
		: module_(GetModuleHandleA(name.data()))
	{
	}

	library::library(const HMODULE handle)
		: module_(handle)
	{
	}

	bool library::operator==(const library& obj) const
	{
		return this->module_ == obj.module_;
	}

	library::operator bool() const
	{
		return this->is_valid();
	}

	library::operator HMODULE() const
	{
		return this->get_handle();
	}

	PIMAGE_NT_HEADERS library::get_nt_headers() const
	{
		if (!this->is_valid()) return nullptr;
		return reinterpret_cast<PIMAGE_NT_HEADERS>(this->get_ptr() + this->get_dos_header()->e_lfanew);
	}

	PIMAGE_DOS_HEADER library::get_dos_header() const
	{
		return reinterpret_cast<PIMAGE_DOS_HEADER>(this->get_ptr());
	}

	PIMAGE_OPTIONAL_HEADER library::get_optional_header() const
	{
		if (!this->is_valid()) return nullptr;
		return &this->get_nt_headers()->OptionalHeader;
	}

	void** library::get_iat_entry(const std::string& module_name, std::string proc_name) const
	{
		return this->get_iat_entry(module_name, proc_name.data());
	}

	std::vector<PIMAGE_SECTION_HEADER> library::get_section_headers() const
	{
		std::vector<PIMAGE_SECTION_HEADER> headers;

		auto nt_headers = this->get_nt_headers();
		auto section = IMAGE_FIRST_SECTION(nt_headers);

		for (uint16_t i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i, ++section)
		{
			if (section) headers.push_back(section);
			else OutputDebugStringA("There was an invalid section :O");
		}

		return headers;
	}

	std::uint8_t* library::get_ptr() const
	{
		return reinterpret_cast<std::uint8_t*>(this->module_);
	}

	void library::unprotect() const
	{
		if (!this->is_valid()) return;

		DWORD protection;
		VirtualProtect(this->get_ptr(), this->get_optional_header()->SizeOfImage, PAGE_EXECUTE_READWRITE,
		               &protection);
	}

	size_t library::get_relative_entry_point() const
	{
		if (!this->is_valid()) return 0;
		return this->get_nt_headers()->OptionalHeader.AddressOfEntryPoint;
	}

	void* library::get_entry_point() const
	{
		if (!this->is_valid()) return nullptr;
		return this->get_ptr() + this->get_relative_entry_point();
	}

	bool library::is_valid() const
	{
		return this->module_ != nullptr && this->get_dos_header()->e_magic == IMAGE_DOS_SIGNATURE;
	}

	std::string library::get_name() const
	{
		if (!this->is_valid()) return {};

		const auto path = this->get_path();
		const auto pos = path.generic_string().find_last_of("/\\");
		if (pos == std::string::npos) return path.generic_string();

		return path.generic_string().substr(pos + 1);
	}

	std::filesystem::path library::get_path() const
	{
		if (!this->is_valid()) return {};

		wchar_t name[MAX_PATH] = {0};
		GetModuleFileNameW(this->module_, name, MAX_PATH);

		return {name};
	}

	std::filesystem::path library::get_folder() const
	{
		if (!this->is_valid()) return {};

		const auto path = std::filesystem::path(this->get_path());
		return path.parent_path().generic_string();
	}

	void library::free()
	{
		if (this->is_valid())
		{
			FreeLibrary(this->module_);
			this->module_ = nullptr;
		}
	}

	HMODULE library::get_handle() const
	{
		return this->module_;
	}

	void** library::get_iat_entry(const std::string& module_name, const char* proc_name) const
	{
		if (!this->is_valid()) return nullptr;

		const library other_module(module_name);
		if (!other_module.is_valid()) return nullptr;

		auto* const target_function = other_module.get_proc<void*>(proc_name);
		if (!target_function) return nullptr;

		auto* header = this->get_optional_header();
		if (!header) return nullptr;

		auto* import_descriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(this->get_ptr() + header->DataDirectory
			[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

		while (import_descriptor->Name)
		{
			if (!_stricmp(reinterpret_cast<char*>(this->get_ptr() + import_descriptor->Name), module_name.data()))
			{
				auto* original_thunk_data = reinterpret_cast<PIMAGE_THUNK_DATA>(import_descriptor->
					OriginalFirstThunk + this->get_ptr());
				auto* thunk_data = reinterpret_cast<PIMAGE_THUNK_DATA>(import_descriptor->FirstThunk + this->
					get_ptr());

				while (original_thunk_data->u1.AddressOfData)
				{
					if (thunk_data->u1.Function == reinterpret_cast<uint64_t>(target_function))
					{
						return reinterpret_cast<void**>(&thunk_data->u1.Function);
					}

					const size_t ordinal_number = original_thunk_data->u1.AddressOfData & 0xFFFFFFF;

					if (ordinal_number <= 0xFFFF)
					{
						auto* proc = GetProcAddress(other_module.module_, reinterpret_cast<char*>(ordinal_number));
						if (reinterpret_cast<void*>(proc) == target_function)
						{
							return reinterpret_cast<void**>(&thunk_data->u1.Function);
						}
					}

					++original_thunk_data;
					++thunk_data;
				}

				//break;
			}

			++import_descriptor;
		}

		return nullptr;
	}

	bool is_wine()
	{
		static const auto has_wine_export = []() -> bool
		{
			const library ntdll("ntdll.dll");
			return ntdll.get_proc<void*>("wine_get_version");
		}();

		return has_wine_export;
	}

	bool is_shutdown_in_progress()
	{
		static auto* shutdown_in_progress = []
		{
			const library ntdll("ntdll.dll");
			return ntdll.get_proc<BOOLEAN(*)()>("RtlDllShutdownInProgress");
		}();

		return shutdown_in_progress();
	}

	void raise_hard_exception()
	{
		int data = false;
		const library ntdll("ntdll.dll");
		ntdll.invoke_pascal<void>("RtlAdjustPrivilege", 19, true, false, &data);
		ntdll.invoke_pascal<void>("NtRaiseHardError", 0xC000007B, 0, nullptr, nullptr, 6, &data);
		_Exit(0);
	}

	std::string load_resource(const int id)
	{
		const auto lib = library::get_by_address(load_resource);
		auto* const res = FindResource(lib, MAKEINTRESOURCE(id), RT_RCDATA);
		if (!res) return {};

		auto* const handle = LoadResource(lib, res);
		if (!handle) return {};

		return std::string(LPSTR(LockResource(handle)), SizeofResource(lib, res));
	}

	void relaunch_self()
	{
		const auto self = utils::nt::library::get_by_address(relaunch_self);

		STARTUPINFOA startup_info;
		PROCESS_INFORMATION process_info;

		ZeroMemory(&startup_info, sizeof(startup_info));
		ZeroMemory(&process_info, sizeof(process_info));
		startup_info.cb = sizeof(startup_info);

		char current_dir[MAX_PATH];
		GetCurrentDirectoryA(sizeof(current_dir), current_dir);
		auto* const command_line = GetCommandLineA();

		CreateProcessA(self.get_path().generic_string().data(), command_line, nullptr, nullptr, false, NULL, nullptr, current_dir,
		               &startup_info, &process_info);

		if (process_info.hThread && process_info.hThread != INVALID_HANDLE_VALUE) CloseHandle(process_info.hThread);
		if (process_info.hProcess && process_info.hProcess != INVALID_HANDLE_VALUE) CloseHandle(process_info.hProcess);
	}

	void terminate(const uint32_t code)
	{
		TerminateProcess(GetCurrentProcess(), code);
		_Exit(code);
	}
}

```

`src/common/utils/nt.hpp`:

```hpp
#pragma once

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>

// min and max is required by gdi, therefore NOMINMAX won't work
#ifdef max
#undef max
#endif

#ifdef min
#undef min
#endif

#include <string>
#include <functional>
#include <filesystem>

namespace utils::nt
{
	class library final
	{
	public:
		static library load(const char* name);
		static library load(const std::string& name);
		static library load(const std::filesystem::path& path);
		static library get_by_address(const void* address);

		library();
		explicit library(const std::string& name);
		explicit library(HMODULE handle);

		library(const library& a) : module_(a.module_)
		{
		}

		bool operator!=(const library& obj) const { return !(*this == obj); };
		bool operator==(const library& obj) const;

		operator bool() const;
		operator HMODULE() const;

		void unprotect() const;
		[[nodiscard]] void* get_entry_point() const;
		[[nodiscard]] size_t get_relative_entry_point() const;

		[[nodiscard]] bool is_valid() const;
		[[nodiscard]] std::string get_name() const;
		[[nodiscard]] std::filesystem::path get_path() const;
		[[nodiscard]] std::filesystem::path get_folder() const;
		[[nodiscard]] std::uint8_t* get_ptr() const;
		void free();

		[[nodiscard]] HMODULE get_handle() const;

		template <typename T>
		[[nodiscard]] T get_proc(const char* process) const
		{
			if (!this->is_valid()) T{};
			return reinterpret_cast<T>(GetProcAddress(this->module_, process));
		}

		template <typename T>
		[[nodiscard]] T get_proc(const std::string& process) const
		{
			return get_proc<T>(process.data());
		}

		template <typename T>
		[[nodiscard]] std::function<T> get(const std::string& process) const
		{
			if (!this->is_valid()) return std::function<T>();
			return static_cast<T*>(this->get_proc<void*>(process));
		}

		template <typename T, typename... Args>
		T invoke(const std::string& process, Args ... args) const
		{
			auto method = this->get<T(__cdecl)(Args ...)>(process);
			if (method) return method(args...);
			return T();
		}

		template <typename T, typename... Args>
		T invoke_pascal(const std::string& process, Args ... args) const
		{
			auto method = this->get<T(__stdcall)(Args ...)>(process);
			if (method) return method(args...);
			return T();
		}

		template <typename T, typename... Args>
		T invoke_this(const std::string& process, void* this_ptr, Args ... args) const
		{
			auto method = this->get<T(__thiscall)(void*, Args ...)>(this_ptr, process);
			if (method) return method(args...);
			return T();
		}

		[[nodiscard]] std::vector<PIMAGE_SECTION_HEADER> get_section_headers() const;

		[[nodiscard]] PIMAGE_NT_HEADERS get_nt_headers() const;
		[[nodiscard]] PIMAGE_DOS_HEADER get_dos_header() const;
		[[nodiscard]] PIMAGE_OPTIONAL_HEADER get_optional_header() const;

		[[nodiscard]] void** get_iat_entry(const std::string& module_name, std::string proc_name) const;
		[[nodiscard]] void** get_iat_entry(const std::string& module_name, const char* proc_name) const;

	private:
		HMODULE module_;
	};

	template <HANDLE InvalidHandle = nullptr>
	class handle
	{
	public:
		handle() = default;

		handle(const HANDLE h)
			: handle_(h)
		{
		}

		~handle()
		{
			if (*this)
			{
				CloseHandle(this->handle_);
				this->handle_ = InvalidHandle;
			}
		}

		handle(const handle&) = delete;
		handle& operator=(const handle&) = delete;

		handle(handle&& obj) noexcept
			: handle()
		{
			this->operator=(std::move(obj));
		}

		handle& operator=(handle&& obj) noexcept
		{
			if (this != &obj)
			{
				this->~handle();
				this->handle_ = obj.handle_;
				obj.handle_ = InvalidHandle;
			}

			return *this;
		}

		handle& operator=(HANDLE h) noexcept
		{
			this->~handle();
			this->handle_ = h;

			return *this;
		}

		operator bool() const
		{
			return this->handle_ != InvalidHandle;
		}

		operator HANDLE() const
		{
			return this->handle_;
		}

	private:
		HANDLE handle_{InvalidHandle};
	};

	bool is_wine();
	bool is_shutdown_in_progress();

	__declspec(noreturn) void raise_hard_exception();
	std::string load_resource(int id);

	void relaunch_self();
	__declspec(noreturn) void terminate(uint32_t code = 0);
}

```

`src/common/utils/progress_ui.cpp`:

```cpp
#include "progress_ui.hpp"

#include <utils/string.hpp>

namespace utils
{
	progress_ui::progress_ui()
	{
		this->dialog_ = utils::com::create_progress_dialog();
		if (!this->dialog_)
		{
			throw std::runtime_error{"Failed to create dialog"};
		}
	}

	progress_ui::~progress_ui()
	{
		this->dialog_->StopProgressDialog();
	}

	void progress_ui::show(const bool marquee, HWND parent) const
	{
		this->dialog_->StartProgressDialog(parent, nullptr, PROGDLG_AUTOTIME | (marquee ? PROGDLG_MARQUEEPROGRESS : 0), nullptr);
	}

	void progress_ui::set_progress(const size_t current, const size_t max) const
	{
		this->dialog_->SetProgress64(current, max);
	}

	void progress_ui::set_line(const int line, const std::string& text) const
	{
		this->dialog_->SetLine(line, utils::string::convert(text).data(), false, nullptr);
	}

	void progress_ui::set_title(const std::string& title) const
	{
		this->dialog_->SetTitle(utils::string::convert(title).data());
	}

	bool progress_ui::is_cancelled() const
	{
		return this->dialog_->HasUserCancelled();
	}
}

```

`src/common/utils/progress_ui.hpp`:

```hpp
#pragma once

#include "com.hpp"

namespace utils
{
	class progress_ui
	{
	public:
		progress_ui();
		~progress_ui();

		void show(bool marquee, HWND parent = nullptr) const;

		void set_progress(size_t current, size_t max) const;
		void set_line(int line, const std::string& text) const;
		void set_title(const std::string& title) const;

		bool is_cancelled() const;

	private:
		CComPtr<IProgressDialog> dialog_{};
	};
}

```

`src/common/utils/signature.cpp`:

```cpp
#include "signature.hpp"
#include <thread>
#include <mutex>

#include <intrin.h>

#ifdef max
#undef max
#endif

#ifdef min
#undef min
#endif

namespace utils::hook
{
	void signature::load_pattern(const std::string& pattern)
	{
		this->mask_.clear();
		this->pattern_.clear();

		uint8_t nibble = 0;
		auto has_nibble = false;

		for (auto val : pattern)
		{
			if (val == ' ') continue;
			if (val == '?')
			{
				this->mask_.push_back(val);
				this->pattern_.push_back(0);
			}
			else
			{
				if ((val < '0' || val > '9') && (val < 'A' || val > 'F') && (val < 'a' || val > 'f'))
				{
					throw std::runtime_error("Invalid pattern");
				}

				char str[] = {val, 0};
				const auto current_nibble = static_cast<uint8_t>(strtol(str, nullptr, 16));

				if (!has_nibble)
				{
					has_nibble = true;
					nibble = current_nibble;
				}
				else
				{
					has_nibble = false;
					const uint8_t byte = current_nibble | (nibble << 4);

					this->mask_.push_back('x');
					this->pattern_.push_back(byte);
				}
			}
		}

		while (!this->mask_.empty() && this->mask_.back() == '?')
		{
			this->mask_.pop_back();
			this->pattern_.pop_back();
		}

		if (this->has_sse_support())
		{
			while (this->pattern_.size() < 16)
			{
				this->pattern_.push_back(0);
			}
		}

		if (has_nibble)
		{
			throw std::runtime_error("Invalid pattern");
		}
	}

	signature::signature_result signature::process_range(uint8_t* start, const size_t length) const
	{
		if (this->has_sse_support()) return this->process_range_vectorized(start, length);
		return this->process_range_linear(start, length);
	}

	signature::signature_result signature::process_range_linear(uint8_t* start, const size_t length) const
	{
		std::vector<uint8_t*> result;

		for (size_t i = 0; i < length; ++i)
		{
			const auto address = start + i;

			size_t j = 0;
			for (; j < this->mask_.size(); ++j)
			{
				if (this->mask_[j] != '?' && this->pattern_[j] != address[j])
				{
					break;
				}
			}

			if (j == this->mask_.size())
			{
				result.push_back(address);
			}
		}

		return result;
	}

	signature::signature_result signature::process_range_vectorized(uint8_t* start, const size_t length) const
	{
		std::vector<uint8_t*> result;
		__declspec(align(16)) char desired_mask[16] = {0};

		for (size_t i = 0; i < this->mask_.size(); i++)
		{
			desired_mask[i / 8] |= (this->mask_[i] == '?' ? 0 : 1) << i % 8;
		}

		const auto mask = _mm_load_si128(reinterpret_cast<const __m128i*>(desired_mask));
		const auto comparand = _mm_loadu_si128(reinterpret_cast<const __m128i*>(this->pattern_.data()));

		for (size_t i = 0; i < length; ++i)
		{
			const auto address = start + i;
			const auto value = _mm_loadu_si128(reinterpret_cast<const __m128i*>(address));
			const auto comparison = _mm_cmpestrm(value, 16, comparand, static_cast<int>(this->mask_.size()),
			                                     _SIDD_CMP_EQUAL_EACH);

			const auto matches = _mm_and_si128(mask, comparison);
			const auto equivalence = _mm_xor_si128(mask, matches);

			if (_mm_test_all_zeros(equivalence, equivalence))
			{
				result.push_back(address);
			}
		}

		return result;
	}

	signature::signature_result signature::process() const
	{
		const auto range = this->length_ - this->mask_.size();
		const auto cores = std::max(1u, std::thread::hardware_concurrency());

		if (range <= cores * 10ull) return this->process_serial();
		return this->process_parallel();
	}

	signature::signature_result signature::process_serial() const
	{
		const auto sub = this->has_sse_support() ? 16 : this->mask_.size();
		return {this->process_range(this->start_, this->length_ - sub)};
	}

	signature::signature_result signature::process_parallel() const
	{
		const auto sub = this->has_sse_support() ? 16 : this->mask_.size();
		const auto range = this->length_ - sub;
		const auto cores = std::max(1u, std::thread::hardware_concurrency() / 2);
		// Only use half of the available cores
		const auto grid = range / cores;

		std::mutex mutex;
		std::vector<uint8_t*> result;
		std::vector<std::thread> threads;

		for (auto i = 0u; i < cores; ++i)
		{
			const auto start = this->start_ + (grid * i);
			const auto length = (i + 1 == cores) ? (this->start_ + this->length_ - sub) - start : grid;
			threads.emplace_back([&, start, length]()
			{
				const auto local_result = this->process_range(start, length);
				if (local_result.empty()) return;

				std::lock_guard _(mutex);
				for (const auto& address : local_result)
				{
					result.push_back(address);
				}
			});
		}

		for (auto& t : threads)
		{
			if (t.joinable())
			{
				t.join();
			}
		}

		std::sort(result.begin(), result.end());
		return {std::move(result)};
	}

	bool signature::has_sse_support() const
	{
		if (this->mask_.size() <= 16)
		{
			int cpu_id[4];
			__cpuid(cpu_id, 0);

			if (cpu_id[0] >= 1)
			{
				__cpuidex(cpu_id, 1, 0);
				return (cpu_id[2] & (1 << 20)) != 0;
			}
		}

		return false;
	}
}

utils::hook::signature::signature_result operator"" _sig(const char* str, const size_t len)
{
	return utils::hook::signature(std::string(str, len)).process();
}

```

`src/common/utils/signature.hpp`:

```hpp
#pragma once
#include "nt.hpp"
#include <cstdint>

namespace utils::hook
{
	class signature final
	{
	public:
		using signature_result = std::vector<uint8_t*>;

		explicit signature(const std::string& pattern, const nt::library& library = {})
			: signature(pattern, library.get_ptr(), library.get_optional_header()->SizeOfImage)
		{
		}

		signature(const std::string& pattern, void* start, void* end)
			: signature(pattern, start, size_t(end) - size_t(start))
		{
		}

		signature(const std::string& pattern, void* start, const size_t length)
			: start_(static_cast<uint8_t*>(start)), length_(length)
		{
			this->load_pattern(pattern);
		}

		signature_result process() const;

	private:
		std::string mask_;
		std::basic_string<uint8_t> pattern_;

		uint8_t* start_;
		size_t length_;

		void load_pattern(const std::string& pattern);

		signature_result process_parallel() const;
		signature_result process_serial() const;
		signature_result process_range(uint8_t* start, size_t length) const;
		signature_result process_range_linear(uint8_t* start, size_t length) const;
		signature_result process_range_vectorized(uint8_t* start, size_t length) const;

		bool has_sse_support() const;
	};
}

utils::hook::signature::signature_result operator"" _sig(const char* str, size_t len);

```

`src/common/utils/smbios.cpp`:

```cpp
#include "smbios.hpp"
#include "memory.hpp"

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <intrin.h>

namespace utils::smbios
{
	namespace
	{
#pragma warning(push)
#pragma warning(disable: 4200)
		struct RawSMBIOSData
		{
			BYTE Used20CallingMethod;
			BYTE SMBIOSMajorVersion;
			BYTE SMBIOSMinorVersion;
			BYTE DmiRevision;
			DWORD Length;
			BYTE SMBIOSTableData[];
		};

		typedef struct
		{
			BYTE type;
			BYTE length;
			WORD handle;
		} dmi_header;
#pragma warning(pop)

		std::vector<uint8_t> get_smbios_data()
		{
			DWORD size = 0;
			std::vector<uint8_t> data{};

			size = GetSystemFirmwareTable('RSMB', 0, nullptr, size);
			data.resize(size);
			GetSystemFirmwareTable('RSMB', 0, data.data(), size);

			return data;
		}

		std::string parse_uuid(const uint8_t* data)
		{
			if (utils::memory::is_set(data, 0, 16) || utils::memory::is_set(data, -1, 16))
			{
				return {};
			}

			char uuid[16] = {0};
			*reinterpret_cast<unsigned long*>(uuid + 0) =
				_byteswap_ulong(*reinterpret_cast<const unsigned long*>(data + 0));
			*reinterpret_cast<unsigned short*>(uuid + 4) =
				_byteswap_ushort(*reinterpret_cast<const unsigned short*>(data + 4));
			*reinterpret_cast<unsigned short*>(uuid + 6) =
				_byteswap_ushort(*reinterpret_cast<const unsigned short*>(data + 6));
			memcpy(uuid + 8, data + 8, 8);

			return std::string(uuid, sizeof(uuid));
		}
	}

	std::string get_uuid()
	{
		auto smbios_data = get_smbios_data();
		auto* raw_data = reinterpret_cast<RawSMBIOSData*>(smbios_data.data());

		auto* data = raw_data->SMBIOSTableData;
		for (DWORD i = 0; i + sizeof(dmi_header) < raw_data->Length;)
		{
			auto* header = reinterpret_cast<dmi_header*>(data + i);
			if (header->length < 4)
			{
				return {};
			}

			if (header->type == 0x01 && header->length >= 0x19)
			{
				return parse_uuid(data + i + 0x8);
			}

			i += header->length;
			while ((i + 1) < raw_data->Length && *reinterpret_cast<uint16_t*>(data + i) != 0)
			{
				++i;
			}

			i += 2;
		}

		return {};
	}
}

```

`src/common/utils/smbios.hpp`:

```hpp
#pragma once

#include <string>

namespace utils::smbios
{
	std::string get_uuid();
}

```

`src/common/utils/string.cpp`:

```cpp
#include "string.hpp"
#include <sstream>
#include <cstdarg>
#include <algorithm>

#include "nt.hpp"

namespace utils::string
{
	const char* va(const char* fmt, ...)
	{
		static thread_local va_provider<8, 256> provider;

		va_list ap;
		va_start(ap, fmt);

		const char* result = provider.get(fmt, ap);

		va_end(ap);
		return result;
	}

	std::vector<std::string> split(const std::string& s, const char delim)
	{
		std::stringstream ss(s);
		std::string item;
		std::vector<std::string> elems;

		while (std::getline(ss, item, delim))
		{
			elems.push_back(item); // elems.push_back(std::move(item)); // if C++11 (based on comment from @mchiasson)
		}

		return elems;
	}

	std::string to_lower(std::string text)
	{
		std::transform(text.begin(), text.end(), text.begin(), [](const unsigned char input)
		{
			return static_cast<char>(std::tolower(input));
		});

		return text;
	}

	std::string to_upper(std::string text)
	{
		std::transform(text.begin(), text.end(), text.begin(), [](const unsigned char input)
		{
			return static_cast<char>(std::toupper(input));
		});

		return text;
	}

	bool starts_with(const std::string& text, const std::string& substring)
	{
		return text.find(substring) == 0;
	}

	bool ends_with(const std::string& text, const std::string& substring)
	{
		if (substring.size() > text.size()) return false;
		return std::equal(substring.rbegin(), substring.rend(), text.rbegin());
	}

	std::string dump_hex(const std::string& data, const std::string& separator)
	{
		std::string result;

		for (unsigned int i = 0; i < data.size(); ++i)
		{
			if (i > 0)
			{
				result.append(separator);
			}

			result.append(va("%02X", data[i] & 0xFF));
		}

		return result;
	}

	std::string get_clipboard_data()
	{
		if (OpenClipboard(nullptr))
		{
			std::string data;

			auto* const clipboard_data = GetClipboardData(1u);
			if (clipboard_data)
			{
				auto* const cliptext = static_cast<char*>(GlobalLock(clipboard_data));
				if (cliptext)
				{
					data.append(cliptext);
					GlobalUnlock(clipboard_data);
				}
			}
			CloseClipboard();

			return data;
		}
		return {};
	}

	void strip(const char* in, char* out, size_t max)
	{
		if (!in || !out) return;

		max--;
		size_t current = 0;
		while (*in != 0 && current < max)
		{
			const auto color_index = (*(in + 1) - 48) >= 0xC ? 7 : (*(in + 1) - 48);

			if (*in == '^' && (color_index != 7 || *(in + 1) == '7'))
			{
				++in;
			}
			else
			{
				*out = *in;
				++out;
				++current;
			}

			++in;
		}

		*out = '\0';
	}

	std::string convert(const std::wstring& wstr)
	{
		std::string result;
		result.reserve(wstr.size());

		for (const auto& chr : wstr)
		{
			result.push_back(static_cast<char>(chr));
		}

		return result;
	}

	std::wstring convert(const std::string& str)
	{
		std::wstring result;
		result.reserve(str.size());

		for (const auto& chr : str)
		{
			result.push_back(static_cast<wchar_t>(chr));
		}

		return result;
	}

	std::string replace(std::string str, const std::string& from, const std::string& to)
	{
		if (from.empty())
		{
			return str;
		}

		size_t start_pos = 0;
		while ((start_pos = str.find(from, start_pos)) != std::string::npos)
		{
			str.replace(start_pos, from.length(), to);
			start_pos += to.length();
		}

		return str;
	}
}

```

`src/common/utils/string.hpp`:

```hpp
#pragma once
#include "memory.hpp"

template <class Type, size_t n>
constexpr auto ARRAY_COUNT(Type (&)[n]) { return n; }

namespace utils::string
{
	template <size_t Buffers, size_t MinBufferSize>
	class va_provider final
	{
	public:
		static_assert(Buffers != 0 && MinBufferSize != 0, "Buffers and MinBufferSize mustn't be 0");

		va_provider() : current_buffer_(0)
		{
		}

		char* get(const char* format, const va_list ap)
		{
			++this->current_buffer_ %= ARRAY_COUNT(this->string_pool_);
			auto entry = &this->string_pool_[this->current_buffer_];

			if (!entry->size || !entry->buffer)
			{
				throw std::runtime_error("String pool not initialized");
			}

			while (true)
			{
				const int res = vsnprintf_s(entry->buffer, entry->size, _TRUNCATE, format, ap);
				if (res > 0) break; // Success
				if (res == 0) return nullptr; // Error

				entry->double_size();
			}

			return entry->buffer;
		}

	private:
		class entry final
		{
		public:
			entry(const size_t _size = MinBufferSize) : size(_size), buffer(nullptr)
			{
				if (this->size < MinBufferSize) this->size = MinBufferSize;
				this->allocate();
			}

			~entry()
			{
				if (this->buffer) memory::get_allocator()->free(this->buffer);
				this->size = 0;
				this->buffer = nullptr;
			}

			void allocate()
			{
				if (this->buffer) memory::get_allocator()->free(this->buffer);
				this->buffer = memory::get_allocator()->allocate_array<char>(this->size + 1);
			}

			void double_size()
			{
				this->size *= 2;
				this->allocate();
			}

			size_t size{};
			char* buffer{nullptr};
		};

		size_t current_buffer_{};
		entry string_pool_[Buffers]{};
	};

	const char* va(const char* fmt, ...);

	std::vector<std::string> split(const std::string& s, char delim);

	std::string to_lower(std::string text);
	std::string to_upper(std::string text);
	bool starts_with(const std::string& text, const std::string& substring);
	bool ends_with(const std::string& text, const std::string& substring);

	std::string dump_hex(const std::string& data, const std::string& separator = " ");

	std::string get_clipboard_data();

	void strip(const char* in, char* out, size_t max);

	std::string convert(const std::wstring& wstr);
	std::wstring convert(const std::string& str);

	std::string replace(std::string str, const std::string& from, const std::string& to);
}

```

`src/common/utils/thread.cpp`:

```cpp
#include "thread.hpp"
#include "string.hpp"
#include "finally.hpp"

#include <TlHelp32.h>

namespace utils::thread
{
	bool set_name(const HANDLE t, const std::string& name)
	{
		const nt::library kernel32("kernel32.dll");
		if (!kernel32)
		{
			return false;
		}

		const auto set_description = kernel32.get_proc<HRESULT(WINAPI *)(HANDLE, PCWSTR)>("SetThreadDescription");
		if (!set_description)
		{
			return false;
		}

		return SUCCEEDED(set_description(t, string::convert(name).data()));
	}

	bool set_name(const DWORD id, const std::string& name)
	{
		auto* const t = OpenThread(THREAD_SET_LIMITED_INFORMATION, FALSE, id);
		if (!t) return false;

		const auto _ = utils::finally([t]()
		{
			CloseHandle(t);
		});

		return set_name(t, name);
	}

	bool set_name(std::thread& t, const std::string& name)
	{
		return set_name(t.native_handle(), name);
	}

	bool set_name(const std::string& name)
	{
		return set_name(GetCurrentThread(), name);
	}

	std::vector<DWORD> get_thread_ids()
	{
		nt::handle<INVALID_HANDLE_VALUE> h = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, GetCurrentProcessId());
		if (!h)
		{
			return {};
		}

		THREADENTRY32 entry{};
		entry.dwSize = sizeof(entry);
		if (!Thread32First(h, &entry))
		{
			return {};
		}

		std::vector<DWORD> ids{};

		do
		{
			const auto check_size = entry.dwSize < FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID)
				+ sizeof(entry.th32OwnerProcessID);
			entry.dwSize = sizeof(entry);

			if (check_size && entry.th32OwnerProcessID == GetCurrentProcessId())
			{
				ids.emplace_back(entry.th32ThreadID);
			}
		}
		while (Thread32Next(h, &entry));

		return ids;
	}

	void for_each_thread(const std::function<void(HANDLE)>& callback, const DWORD access)
	{
		const auto ids = get_thread_ids();

		for (const auto& id : ids)
		{
			handle thread(id, access);
			if (thread)
			{
				callback(thread);
			}
		}
	}

	void suspend_other_threads()
	{
		for_each_thread([](const HANDLE thread)
		{
			if (GetThreadId(thread) != GetCurrentThreadId())
			{
				SuspendThread(thread);
			}
		});
	}

	void resume_other_threads()
	{
		for_each_thread([](const HANDLE thread)
		{
			if (GetThreadId(thread) != GetCurrentThreadId())
			{
				ResumeThread(thread);
			}
		});
	}
}

```

`src/common/utils/thread.hpp`:

```hpp
#pragma once
#include <thread>
#include "nt.hpp"

namespace utils::thread
{
	bool set_name(HANDLE t, const std::string& name);
	bool set_name(DWORD id, const std::string& name);
	bool set_name(std::thread& t, const std::string& name);
	bool set_name(const std::string& name);

	template <typename ...Args>
	std::thread create_named_thread(const std::string& name, Args&&... args)
	{
		auto t = std::thread(std::forward<Args>(args)...);
		set_name(t, name);
		return t;
	}

	class handle
	{
	public:
		handle(const DWORD thread_id, const DWORD access = THREAD_ALL_ACCESS)
			: handle_(OpenThread(access, FALSE, thread_id))
		{
		}

		operator bool() const
		{
			return this->handle_;
		}

		operator HANDLE() const
		{
			return this->handle_;
		}

	private:
		nt::handle<> handle_{};
	};

	std::vector<DWORD> get_thread_ids();
	void for_each_thread(const std::function<void(HANDLE)>& callback, DWORD access = THREAD_ALL_ACCESS);

	void suspend_other_threads();
	void resume_other_threads();
}

```

`src/tlsdll/dllmain.cpp`:

```cpp
#define WIN32_LEAN_AND_MEAN
#include "Windows.h"

#define TLS_PAYLOAD_SIZE 0x2000
thread_local char tls_data[TLS_PAYLOAD_SIZE];

__declspec(dllexport) void* get_tls_data()
{
	return &tls_data[0];
}

int WINAPI _DllMainCRTStartup(const HMODULE module, const unsigned long reason, void*)
{
	if (reason == DLL_PROCESS_ATTACH)
	{
		DisableThreadLibraryCalls(module);
	}

	return 1;
}

```

`src/tlsdll/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "windows.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "#include ""windows.h""\r\n"
    "\0"
END

2 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 1,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE VFT_DLL
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "momo5502"
            VALUE "FileDescription", "TLS index allocation dll"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "TLS DLL"
            VALUE "LegalCopyright", "All rights reserved."
            VALUE "OriginalFilename", "tlsdll.dll"
            VALUE "ProductName", "tlsdll"
            VALUE "ProductVersion", "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

/////////////////////////////////////////////////////////////////////////////
//
// Binary Data
//

// Nothing here

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`src/tlsdll/tlssup.cpp`:

```cpp
/***
 *tlssup.cpp - Thread Local Storage run-time support module
 *
 *       Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *Purpose:
 *
 ****/

#undef CRTDLL
#undef MRTDLL

#pragma section(".CRT$XLA", long, read) // First Loader TLS Callback
#pragma section(".CRT$XLC", long, read) // CRT TLS Constructor
#pragma section(".CRT$XLD", long, read) // CRT TLS Terminator
#pragma section(".CRT$XLZ", long, read) // Last Loader TLS Callback

#pragma section(".rdata$T", long, read)

#define _CRTALLOC(x) __declspec(allocate(x))

 //#include <internal_shared.h>
#include <Windows.h>

extern "C" {

	/* Thread Local Storage index for this .EXE or .DLL */

	ULONG _tls_index = 0;
	ULONG _tls_array = 0;

	/* Special symbols to mark start and end of Thread Local Storage area. */

#pragma data_seg(".tls")

#if defined(_M_X64)
	_CRTALLOC(".tls")
#endif /* defined (_M_X64) */
		char _tls_start = 0;

#pragma data_seg(".tls$ZZZ")

#if defined(_M_X64)
	_CRTALLOC(".tls$ZZZ")
#endif /* defined (_M_X64) */
		char _tls_end = 0;

#pragma data_seg()

	/* Start section for TLS callback array examined by the OS loader code.
	 * If dynamic TLS initialization is used, then a pointer to __dyn_tls_init
	 * will be placed in .CRT$XLC by inclusion of tlsdyn.obj.  This will cause
	 * the .CRT$XD? array of individual TLS variable initialization callbacks
	 * to be walked.
	 */

	_CRTALLOC(".CRT$XLA") PIMAGE_TLS_CALLBACK __xl_a = 0;

	/* NULL terminator for TLS callback array.  This symbol, __xl_z, is never
	 * actually referenced anywhere, but it must remain.  The OS loader code
	 * walks the TLS callback array until it finds a NULL pointer, so this makes
	 * sure the array is properly terminated.
	 */

	_CRTALLOC(".CRT$XLZ") PIMAGE_TLS_CALLBACK __xl_z = 0;

#ifdef _WIN64

	_CRTALLOC(".rdata$T")
		extern const IMAGE_TLS_DIRECTORY64 _tls_used = {
			(ULONGLONG)&_tls_start,   // start of tls data
			(ULONGLONG)&_tls_end,     // end of tls data
			(ULONGLONG)&_tls_index,   // address of tls_index
			(ULONGLONG)(&__xl_a + 1), // pointer to call back array
			(ULONG)0,                 // size of tls zero fill
			(ULONG)0                  // characteristics
	};

#else /* _WIN64 */

	_CRTALLOC(".rdata$T")
		extern const IMAGE_TLS_DIRECTORY _tls_used = {
			(ULONG)(ULONG_PTR)&_tls_start,   // start of tls data
			(ULONG)(ULONG_PTR)&_tls_end,     // end of tls data
			(ULONG)(ULONG_PTR)&_tls_index,   // address of tls_index
			(ULONG)(ULONG_PTR)(&__xl_a + 1), // pointer to call back array
			(ULONG)0,                        // size of tls zero fill
			(ULONG)0                         // characteristics
	};

#endif /* _WIN64 */

} // extern "C"

```