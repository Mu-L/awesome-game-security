Project Path: arc_gmh5225_Kernel_Anti-Cheat_tu_4iq3p

Source Tree:

```txt
arc_gmh5225_Kernel_Anti-Cheat_tu_4iq3p
├── README.md
└── ac
    ├── ac.filters
    ├── ac.inf
    ├── ac.sln
    ├── ac.user
    ├── ac.vcxproj
    ├── defs.h
    ├── handles.c
    ├── hypervisor.c
    ├── main.c
    ├── nmi.c
    ├── pool.c
    ├── serial.c
    ├── threads.c
    ├── traces.c
    └── utils.c

```

`README.md`:

```md
# *Legal Disclaimer
***The use of this project is the sole responsibility of the user. I am not responsible for any consequences arising from the use of this tool.***

# Features :

    NMI StackWalking
    Hypervisor Detection
    Big Pool scanning
    UUID
    Scanning system threads
    Checking PIDDBCacheTable for KDmapper & Drvmap


# The NMI Stackwalking :
First we register an NMI callback that will be called when a hardware interupt occurs. inside the NMI callback you can see we capture the stack using RtlCaptureStackBackTrace and store the results in a list. 
**code:**
    BOOLEAN NmiCallback(PVOID context, BOOLEAN handled)
    {
    	UNREFERENCED_PARAMETER(context);
    	UNREFERENCED_PARAMETER(handled);
     
    	PVOID* stackTrace = ExAllocatePoolWithTag(NonPagedPool, 0x1000, AC_POOL_TAG);
     
    	if (!stackTrace)
    		return TRUE;
     
    	//Walk the stack and record information for each frame
    	USHORT capturedFrames = RtlCaptureStackBackTrace(0, 0x1000 / 8, stackTrace, NULL);
     
    	// Loop through g_PageOfpStackWalkResult list, 
    	// if empty it has been checked by the DetectionThread,
    	// and we can store the stackTrace and the capturedFrames in the list.
    	for (int i = 0; i < 0x1000 / 0x10; i += 2)
    	{
    		if (((DWORD64*)g_PageOfpStackWalkResult)[i] == 0)
    		{
    			((DWORD64*)g_PageOfpStackWalkResult)[i] = (ULONG64)stackTrace;
    			((DWORD64*)g_PageOfpStackWalkResult)[i + 1] = capturedFrames;
    			break;
    		}
    	}
     
    	return TRUE;
    }

Then when we get the results inside our list we can iterate through it and check one of the frame values is not in a valid module.
**Code:**

    // Loop through the g_PageOfpStackWalkResult list
    		for (INT i = 0; i < 0x1000 / 0x10; i += 2)
    		{
    			// Check if current item of g_PageOfpStackWalkResult is there
    			if (((DWORD64*)g_PageOfpStackWalkResult)[i] == 0)
    				continue;
     
    			// Check if the stackTrace is valid and there are captured frames to loop through
    			if (MmIsAddressValid(((PVOID*)g_PageOfpStackWalkResult)[i]) && ((DWORD64*)g_PageOfpStackWalkResult)[i + 1])
    			{
    				// Loop through the captured frames
    				for (SIZE_T j = 0; i < ((DWORD64*)g_PageOfpStackWalkResult)[i + 1]; j++)
    				{
    					ULONG64 CurrentFrameValue = (((DWORD64**)g_PageOfpStackWalkResult)[i])[j];
     
    					// Check if the CurrentFrameValue is an address in kernel 
    					if (CurrentFrameValue < 0xFFFF000000000000)
    						break;
     
    					// Check if CurrentFrameValue is in a kernel module.
    					// If not, we have found something.
    					if (IsAdressOutsideModulelist(CurrentFrameValue))
    						DbgPrintEx(0, 0, "Unsigned code : %llx", CurrentFrameValue);
    				}
    			}
     
    			// Remove the stackTrace and the capturedFrames out of the list,
    			// So the NMI callback can store new ones.
    			ExFreePoolWithTag(((PVOID*)g_PageOfpStackWalkResult)[i], AC_POOL_TAG);
    			((DWORD64*)g_PageOfpStackWalkResult)[i] = 0;
    			((DWORD64*)g_PageOfpStackWalkResult)[i + 1] = 0;
    		}

At last we can fire an NMI using HalSendNMI whenever we want to.
**Code:**

    BOOLEAN FireNMI(INT core, PKAFFINITY_EX affinity)
    {
    	KeInitializeAffinityEx(affinity);
    	KeAddProcessorAffinityEx(affinity, core);
     
    	HalSendNMI(affinity);
     
    	return TRUE;
    }
     
    // Fire an NMI for eac core on the system with 100 ms delay
    for (ULONG i = 0; i < KeQueryActiveProcessorCountEx(0); i++)
    {
    	FireNMI(i, g_NmiAffinity);
    	DelayExecutionThread(100);
    }

- Improve the NMI callback
- Improve the SystemThread scanning
- Maybe add more features

```

`ac/ac.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="TestNMICallback.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hal.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="helper.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stuff.h">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ac/ac.inf`:

```inf
;
; ac.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=sd ; TODO: edit Class
ClassGuid={c498d9b1-b2d0-4149-9434-9444230a43fe} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=ac.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
ac_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
ac.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%ac.DeviceDesc%=ac_Device, Root\ac ; TODO: edit hw-id

[ac_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
ac.sys

;-------------- Service installation
[ac_Device.NT.Services]
AddService = ac,%SPSVCINST_ASSOCSERVICE%, ac_Service_Inst

; -------------- ac driver install sections
[ac_Service_Inst]
DisplayName    = %ac.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\ac.sys

;
;--- ac_Device Coinstaller installation ------
;

[ac_Device.NT.CoInstallers]
AddReg=ac_Device_CoInstaller_AddReg
CopyFiles=ac_Device_CoInstaller_CopyFiles

[ac_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[ac_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[ac_Device.NT.Wdf]
KmdfService =  ac, ac_wdfsect
[ac_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ac Installation Disk"
ac.DeviceDesc = "ac Device"
ac.SVCDESC = "ac Service"

```

`ac/ac.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32922.545
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ac", "ac.vcxproj", "{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM.ActiveCfg = Debug|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM.Build.0 = Debug|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM.Deploy.0 = Debug|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM64.Build.0 = Debug|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x64.ActiveCfg = Debug|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x64.Build.0 = Debug|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x64.Deploy.0 = Debug|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x86.ActiveCfg = Debug|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x86.Build.0 = Debug|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Debug|x86.Deploy.0 = Debug|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM.ActiveCfg = Release|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM.Build.0 = Release|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM.Deploy.0 = Release|ARM
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM64.ActiveCfg = Release|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM64.Build.0 = Release|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|ARM64.Deploy.0 = Release|ARM64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x64.ActiveCfg = Release|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x64.Build.0 = Release|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x64.Deploy.0 = Release|x64
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x86.ActiveCfg = Release|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x86.Build.0 = Release|Win32
		{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {340E45E7-F88E-4806-896E-6B37B6B05EAC}
	EndGlobalSection
EndGlobal

```

`ac/ac.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`ac/ac.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3B5F4A5D-34F4-4ACB-8012-BBBE7A97CFA3}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>TestNMICallback</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <TimeStampServer>http://timestamp.globalsign.com/scripts/timstamp.dll</TimeStampServer>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>SHA1</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>SHA1</FileDigestAlgorithm>
    </DriverSign>
    <ClCompile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="ac.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="hypervisor.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="nmi.c" />
    <ClCompile Include="handles.c" />
    <ClCompile Include="pool.c" />
    <ClCompile Include="serial.c" />
    <ClCompile Include="threads.c" />
    <ClCompile Include="traces.c" />
    <ClCompile Include="utils.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ac/defs.h`:

```h
#pragma once

#include <intrin.h>
#include <ntifs.h>
#include <ntstrsafe.h>
#include <windef.h>

// Defines
#define AC_POOL_TAG 'BCmN'

// Disable Warnings
#pragma warning(disable : 4996)
#pragma warning(disable : 4200)
#pragma warning(disable : 4310)
#pragma warning(disable : 4022)
#pragma warning(disable : 6387)
#pragma warning(disable : 6011)
#pragma warning(disable : 4201)
#pragma warning(disable : 4047)
#pragma warning(disable : 4024)

// Structs + Enums
typedef struct _SYSTEM_HANDLE
{
	ULONG 	uIdProcess;
	UCHAR 	ObjectType;
	UCHAR 	Flags;
	USHORT 	Handle;
	PVOID 	pObject;
	ACCESS_MASK 	GrantedAccess;
}SYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION {
	ULONG			uCount;
	SYSTEM_HANDLE	Handles[ANYSIZE_ARRAY];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_BIGPOOL_ENTRY {
	union {
		PVOID VirtualAddress;
		ULONG_PTR NonPaged : 1;
	};
	ULONG_PTR SizeInBytes;
	union {
		UCHAR Tag[4];
		ULONG TagULong;
	};
} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
	ULONG Count;
	SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ANYSIZE_ARRAY];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;

typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
	struct _GUID BootIdentifier;
	enum _FIRMWARE_TYPE FirmwareType;
	unsigned __int64 BootFlags;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, * PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

typedef struct _KAFFINITY_EX
{
	USHORT Count;
	USHORT Size;
	ULONG Reserved;
	ULONGLONG Bitmap[20];
} KAFFINITY_EX, * PKAFFINITY_EX;

typedef struct _PiDDBCacheEntry
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16];
} PiDDBCacheEntry, * PPiDDBCacheEntry;

typedef struct _MM_UNLOADED_DRIVER
{
	UNICODE_STRING 	Name;
	PVOID 			ModuleStart;
	PVOID 			ModuleEnd;
	ULONG64 		UnloadTime;
} MM_UNLOADED_DRIVER, * PMM_UNLOADED_DRIVER;

typedef struct _NMI_CONTEXT
{
	INT NumFired;
} NMI_CONTEXT, * PNMI_CONTEXT;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation,
	SystemLocksInformation,
	SystemStackTraceInformation,
	SystemPagedPoolInformation,
	SystemNonPagedPoolInformation,
	SystemHandleInformation,
	SystemObjectInformation,
	SystemPageFileInformation,
	SystemVdmInstemulInformation,
	SystemVdmBopInformation,
	SystemFileCacheInformation,
	SystemPoolTagInformation,
	SystemInterruptInformation,
	SystemDpcBehaviorInformation,
	SystemFullMemoryInformation,
	SystemLoadGdiDriverInformation,
	SystemUnloadGdiDriverInformation,
	SystemTimeAdjustmentInformation,
	SystemSummaryMemoryInformation,
	SystemNextEventIdInformation,
	SystemEventIdsInformation,
	SystemCrashDumpInformation,
	SystemExceptionInformation,
	SystemCrashDumpStateInformation,
	SystemKernelDebuggerInformation,
	SystemContextSwitchInformation,
	SystemRegistryQuotaInformation,
	SystemExtendServiceTableInformation,
	SystemPrioritySeperation,
	SystemPlugPlayBusInformation,
	SystemDockInformation,
	SystemProcessorSpeedInformation,
	SystemCurrentTimeZoneInformation,
	SystemLookasideInformation
} SYSTEM_INFORMATION_CLASS, * PSYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_MODULE_ENTRY
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
	ULONG Count;
	SYSTEM_MODULE_ENTRY Module[0];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _DIRECTORY_BASIC_INFORMATION {
	UNICODE_STRING ObjectName;
	UNICODE_STRING ObjectTypeName;
} DIRECTORY_BASIC_INFORMATION, * PDIRECTORY_BASIC_INFORMATION;

// Function Declarations
VOID PrintBootUUID();
VOID StartNMI();
VOID StopNMI();
VOID CheckPIDDBCacheTable();
VOID HypervisorDetection();
VOID ScanBigPool();
VOID ScanSystemThreads();
VOID CheckPhysicalMemHandles();

VOID Log(char* text);
VOID DelayExecutionThread(INT64 ms);
VOID WaitThreadTerminate(HANDLE ThreadHandle);
VOID GetThreadStartAddress(PETHREAD ThreadObj, uintptr_t* pStartAddr);
BOOL IsAdressOutsideModulelist(uintptr_t address);
BOOL DataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask);
INT64 SecInNs(INT64 ms);
PVOID ResolveRelativeAddress(PVOID Instruction, ULONG OffsetOffset, ULONG InstructionSize);
PVOID GetKernelBase(OUT PULONG pSize);
UINT64 FindPattern(UINT64 dwAddress, UINT64 dwLen, BYTE* bMask, char* szMask);
PSYSTEM_HANDLE_INFORMATION GetHandleList();

// Imports
VOID KeInitializeAffinityEx(PKAFFINITY_EX affinity);
VOID KeAddProcessorAffinityEx(PKAFFINITY_EX affinity, INT num);
VOID HalSendNMI(PKAFFINITY_EX affinity);
NTSTATUS MmCopyVirtualMemory(PEPROCESS SourceProcess, PVOID SourceAddress, PEPROCESS TargetProcess, PVOID TargetAddress, SIZE_T BufferSize, KPROCESSOR_MODE PreviousMode, PSIZE_T ReturnSize);
NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);
NTSTATUS NtQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);
__int64 __fastcall PsGetProcessSectionBaseAddress(__int64 a1);

```

`ac/handles.c`:

```c
#include "defs.h"

VOID CheckPhysicalMemHandles()
{
	DbgPrintEx(0, 0, "Checking PhysicalMemHandles");
	
	PVOID					   Object;
	HANDLE                     hPhysMem;
	UNICODE_STRING             phys_mem_str;
	OBJECT_ATTRIBUTES		   oaAttributes;
	PSYSTEM_HANDLE_INFORMATION handles = GetHandleList();

	RtlInitUnicodeString(&phys_mem_str, L"\\Device\\PhysicalMemory");
	InitializeObjectAttributes(&oaAttributes, &phys_mem_str, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, (HANDLE)NULL, (PSECURITY_DESCRIPTOR)NULL);
	ZwOpenSection(&hPhysMem, SECTION_ALL_ACCESS, &oaAttributes);
	ObReferenceObjectByHandle(hPhysMem, 1, NULL, KernelMode, &Object, NULL);
	ZwClose(hPhysMem);

	__try {
		for (ULONG i = 0; i < handles->uCount; i++) 
		{	
			if (handles->Handles[i].uIdProcess == 4)
				continue; 

			if (handles->Handles[i].pObject == Object) 
			{ 
				if (!ObIsKernelHandle((HANDLE)handles->Handles[i].Handle))
					DbgPrint("Usermode PhysicalMemory handle detected, pid = %d, access = 0x%x.\n", handles->Handles[i].uIdProcess, handles->Handles[i].GrantedAccess);
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) { }

	ObDereferenceObject(Object);

	ExFreePoolWithTag(handles, AC_POOL_TAG);

	DbgPrintEx(0, 0, "Finished Checking PhysicalMemHandles");
}
```

`ac/hypervisor.c`:

```c
#include "defs.h"

VOID HypervisorDetection()
{
	DbgPrintEx(0, 0, "HyperVisor Detection Started : ");

	__try {
		__vmx_vmread(0, 0);
		DbgPrint("Detected Hypervisor\n");
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {}

	DbgPrintEx(0, 0, "HyperVisor Detection Finished");
}
```

`ac/main.c`:

```c
#include "defs.h"

VOID DriverUnload(PDRIVER_OBJECT drvObj)
{
	UNREFERENCED_PARAMETER(drvObj);
	
	StopNMI();

	DbgPrintEx(0, 0, "========   Vasie Meme Anticheat Unloaded   ========\n");
}

NTSTATUS DriverEntry(PDRIVER_OBJECT drvObj, PUNICODE_STRING regPath)
{
	UNREFERENCED_PARAMETER(regPath);

	drvObj->DriverUnload = DriverUnload;

    DbgPrintEx(0, 0, "========   Vasie Meme Anticheat Entry   ========\n");

	PrintBootUUID();
	
	ScanSystemThreads();
	ScanBigPool();

	CheckPhysicalMemHandles();
    CheckPIDDBCacheTable();
	
	HypervisorDetection();

	StartNMI();

	return STATUS_SUCCESS;
}
```

`ac/nmi.c`:

```c
#include "defs.h"

PVOID               g_NmiCallbackHandle;
PKAFFINITY_EX       g_NmiAffinity;
PNMI_CONTEXT        g_NmiContext;
PVOID               g_PageOfpStackWalkResult;
BOOLEAN             NMIStop;
HANDLE              SendNMIThreadHandle;

BOOLEAN FireNMI(INT core, PKAFFINITY_EX affinity)
{
	KeInitializeAffinityEx(affinity);
	KeAddProcessorAffinityEx(affinity, core);

	HalSendNMI(affinity);

	return TRUE;
}

VOID DetectionThread(PVOID StartContext)
{
	UNREFERENCED_PARAMETER(StartContext);

	while (!NMIStop)
	{
		// Fire an NMI for eac core on the system with 100 ms delay
		for (ULONG i = 0; i < KeQueryActiveProcessorCountEx(0); i++)
		{
			FireNMI(i, g_NmiAffinity);
			DelayExecutionThread(100);
		}

		// Loop through the g_PageOfpStackWalkResult list
		for (INT i = 0; i < 0x1000 / 0x10; i += 2)
		{
			// Check if current item of g_PageOfpStackWalkResult is there
			if (((DWORD64*)g_PageOfpStackWalkResult)[i] == 0)
				continue;

			// Check if the stackTrace is valid and there are captured frames to loop through
			if (MmIsAddressValid(((PVOID*)g_PageOfpStackWalkResult)[i]) && ((DWORD64*)g_PageOfpStackWalkResult)[i + 1])
			{
				// Loop through the captured frames
				for (SIZE_T j = 0; i < ((DWORD64*)g_PageOfpStackWalkResult)[i + 1]; j++)
				{
					ULONG64 CurrentFrameValue = (((DWORD64**)g_PageOfpStackWalkResult)[i])[j];

					// Check if the CurrentFrameValue is an address in kernel 
					if (CurrentFrameValue < 0xFFFF000000000000)
						break;

					// Check if CurrentFrameValue is in a kernel module.
					// If not, we have found something.
					if (IsAdressOutsideModulelist(CurrentFrameValue))
						DbgPrintEx(0, 0, "Unsigned code : %llx", CurrentFrameValue);
				}
			}

			// Remove the stackTrace and the capturedFrames out of the list,
			// So the NMI callback can store new ones.
			ExFreePoolWithTag(((PVOID*)g_PageOfpStackWalkResult)[i], AC_POOL_TAG);
			((DWORD64*)g_PageOfpStackWalkResult)[i] = 0;
			((DWORD64*)g_PageOfpStackWalkResult)[i + 1] = 0;
		}
	}
	PsTerminateSystemThread(STATUS_SUCCESS);
}


BOOLEAN NmiCallback(PVOID context, BOOLEAN handled)
{
	UNREFERENCED_PARAMETER(context);
	UNREFERENCED_PARAMETER(handled);

	PVOID* stackTrace = ExAllocatePoolWithTag(NonPagedPool, 0x1000, AC_POOL_TAG);

	if (!stackTrace)
		return TRUE;

	// Captures a stack back trace by walking up the stack and recording the information for each frame 
	USHORT capturedFrames = RtlCaptureStackBackTrace(0, 0x1000 / 8, stackTrace, NULL);

	// Loop through g_PageOfpStackWalkResult list, 
	// if empty it has been checked by the DetectionThread,
	// and we can store the stackTrace and the capturedFrames in the list.
	for (int i = 0; i < 0x1000 / 0x10; i += 2)
	{
		if (((DWORD64*)g_PageOfpStackWalkResult)[i] == 0)
		{
			((DWORD64*)g_PageOfpStackWalkResult)[i] = (ULONG64)stackTrace;
			((DWORD64*)g_PageOfpStackWalkResult)[i + 1] = capturedFrames;
			break;
		}
	}

	return TRUE;
}

VOID StartNMI()
{
	DbgPrintEx(0, 0, "Started NMI callback : (Could produce false positives)");

	ULONG numCores = KeQueryActiveProcessorCountEx(0);
	ULONG nmiContextLength = numCores * sizeof(NMI_CONTEXT);

	g_NmiContext = (PNMI_CONTEXT)ExAllocatePoolWithTag(NonPagedPool, nmiContextLength, AC_POOL_TAG);
	g_NmiAffinity = ExAllocatePoolWithTag(NonPagedPool, sizeof(KAFFINITY_EX), AC_POOL_TAG);
	g_PageOfpStackWalkResult = ExAllocatePoolWithTag(NonPagedPool, 0x1000, AC_POOL_TAG);

	g_NmiCallbackHandle = KeRegisterNmiCallback(NmiCallback, g_NmiContext);

	if (!g_NmiAffinity || !g_NmiContext || !g_NmiCallbackHandle || !g_PageOfpStackWalkResult)
		return;

	memset(g_NmiContext, 0, nmiContextLength);
	memset(g_PageOfpStackWalkResult, 0, 0x1000);

	PsCreateSystemThread(&SendNMIThreadHandle, 0, NULL, NULL, NULL, &DetectionThread, NULL);
}

VOID StopNMI()
{

	NMIStop = TRUE;
	WaitThreadTerminate(SendNMIThreadHandle);

	if (g_NmiCallbackHandle) KeDeregisterNmiCallback(g_NmiCallbackHandle);
	if (g_NmiAffinity) ExFreePoolWithTag(g_NmiAffinity, AC_POOL_TAG);
	if (g_NmiContext) ExFreePoolWithTag(g_NmiContext, AC_POOL_TAG);
	if (g_PageOfpStackWalkResult) ExFreePoolWithTag(g_PageOfpStackWalkResult, AC_POOL_TAG);

	DbgPrintEx(0, 0, "Stopped NMI callback");

}

```

`ac/pool.c`:

```c
#include "defs.h"

VOID ScanBigPool()
{
	DbgPrintEx(0, 0, "Scanning Big Pool :");

	ULONG len = 4 * 1024 * 1024;
	PVOID mem = ExAllocatePoolWithTag(NonPagedPool, len, AC_POOL_TAG);

	if (!NT_SUCCESS(ZwQuerySystemInformation(0x42, mem, len, &len)))
		return;

	PSYSTEM_BIGPOOL_INFORMATION pBuf = (PSYSTEM_BIGPOOL_INFORMATION)mem;
	for (ULONG i = 0; i < pBuf->Count; i++) {
		__try {

			if (pBuf->AllocatedInfo[i].TagULong != 'SldT')
				return;

			DbgPrint("[FLAG] TdlS pooltag detected\n");

			PVOID page = MmMapIoSpaceEx(MmGetPhysicalAddress((void*)pBuf->AllocatedInfo[i].VirtualAddress), PAGE_SIZE, PAGE_READWRITE);

			if ((uintptr_t)page + 0x184 == 0x0B024BC8B48)
				DbgPrint("[DETECTION] 0x0B024BC8B48 found at pool + 0x184\n");

			MmUnmapIoSpace(page, PAGE_SIZE);

		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
		}
	}

	ExFreePoolWithTag(mem, AC_POOL_TAG);

	DbgPrintEx(0, 0, "Finished Scanning Big Pool :");
}
```

`ac/serial.c`:

```c
#include "defs.h"

VOID PrintBootUUID()
{	
	ULONG neededSize = 8 * 1024 * 1024;

	PSYSTEM_BOOT_ENVIRONMENT_INFORMATION pBootInfo = ExAllocatePoolWithTag(NonPagedPool, neededSize, AC_POOL_TAG);
	if (!pBootInfo)
		return;

	if (ZwQuerySystemInformation(0x5a, pBootInfo, neededSize, 0) != STATUS_SUCCESS)
		return;

	DbgPrint("UUID : %08X-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X\n", pBootInfo->BootIdentifier.Data1, pBootInfo->BootIdentifier.Data2, pBootInfo->BootIdentifier.Data3, pBootInfo->BootIdentifier.Data4[0], pBootInfo->BootIdentifier.Data4[1], pBootInfo->BootIdentifier.Data4[2], pBootInfo->BootIdentifier.Data4[3], pBootInfo->BootIdentifier.Data4[4], pBootInfo->BootIdentifier.Data4[5], pBootInfo->BootIdentifier.Data4[6], pBootInfo->BootIdentifier.Data4[7]);
	ExFreePoolWithTag(pBootInfo, AC_POOL_TAG);
	
}
```

`ac/threads.c`:

```c
#include "defs.h"

VOID ScanSystemThreads()
{
	DbgPrintEx(0, 0, "Scanning SystemThreads : (Could produce false positives)");

	for (ULONG thrd_id = 4; thrd_id < 0x30000; thrd_id += 4)
	{
		PETHREAD ThreadObj;

		if (!NT_SUCCESS(PsLookupThreadByThreadId((HANDLE)thrd_id, &ThreadObj)))
			continue;

		if (!PsIsSystemThread(ThreadObj) || ThreadObj == KeGetCurrentThread())
			continue;

		uintptr_t start_addr;
		GetThreadStartAddress(ThreadObj, &start_addr);

		if (IsAdressOutsideModulelist(start_addr))
			DbgPrint("Startaddress not valid : %llx", start_addr);

		if (start_addr && (memcmp((void*)start_addr, "\xFF\xE1", 2) == 0)) 
			DbgPrint("Startaddress jmp rcx : %llx", start_addr);
	}

	DbgPrintEx(0, 0, "Stopped Scanning SystemThreads");
}
```

`ac/traces.c`:

```c
#include "defs.h"

VOID CheckPIDDBCacheTable()
{
    DbgPrintEx(0, 0, "Scanning PIDDBCacheTable : ");
    
    PVOID base = GetKernelBase(NULL);
    if (!base)
        return;

    UINT64 PiDDBLockPtr = FindPattern((UINT64)base, (UINT64)0xFFFFFFFFFF, (BYTE*)"\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x4C\x8B\x8C", "xxx????x????xxx");
    if (!PiDDBLockPtr)
        return;

    UINT64 PiDDBCacheTablePtr = FindPattern((UINT64)base, (UINT64)0xFFFFFFFFFF, (BYTE*)"\x66\x03\xD2\x48\x8D\x0D", "xxxxxx");
    if (!PiDDBCacheTablePtr)
        return;

    PERESOURCE PiDDBLock; PRTL_AVL_TABLE table;

    PiDDBCacheTablePtr = ((uintptr_t)PiDDBCacheTablePtr + 3);

    PiDDBLock = (PERESOURCE)(ResolveRelativeAddress((PVOID)PiDDBLockPtr, 3, 7));
    table = (PRTL_AVL_TABLE)(ResolveRelativeAddress((PVOID)PiDDBCacheTablePtr, 3, 7));

    ExAcquireResourceExclusiveLite(PiDDBLock, TRUE);

    for (PiDDBCacheEntry* p = (PiDDBCacheEntry*)RtlEnumerateGenericTableAvl(table, TRUE);
        p != NULL;
        p = (PiDDBCacheEntry*)RtlEnumerateGenericTableAvl(table, FALSE)) {
        if (p->TimeDateStamp == 0x5284eac3)
            DbgPrint("kdmapper detected, driver: %wZ\n", p->DriverName);
        if (p->TimeDateStamp == 0x57CD1415)
            DbgPrint("drvmap detected, driver: %wZ\n", p->DriverName);
    }

    ExReleaseResourceLite(PiDDBLock);
    
    DbgPrintEx(0, 0, "Finished Scanning PIDDBCacheTable");
}

```

`ac/utils.c`:

```c
#include "defs.h"

INT64 SecInNs(INT64 ms)
{
	return (ms * 10000);
}

VOID DelayExecutionThread(INT64 ms)
{
	LARGE_INTEGER nDelay;
	memset(&nDelay, 0, sizeof(nDelay));

	nDelay.QuadPart -= SecInNs(ms);

	KeDelayExecutionThread(KernelMode, FALSE, &nDelay);
}

VOID WaitThreadTerminate(HANDLE ThreadHandle)
{
	if (ThreadHandle != NULL)
	{
		PETHREAD ThreadObject = NULL;

		if (NT_SUCCESS(ObReferenceObjectByHandle(ThreadHandle, THREAD_ALL_ACCESS, NULL, KernelMode, (PVOID*)(&ThreadObject), NULL)))
		{
			KeWaitForSingleObject((PVOID)(ThreadObject), Executive, KernelMode, FALSE, NULL);
			ObDereferenceObject((PVOID)(ThreadObject));
		}
	}
}

BOOL IsAdressOutsideModulelist(uintptr_t address)
{
	BOOLEAN OutsideModulelist = TRUE;
	PSYSTEM_MODULE_INFORMATION pSystemInfoBuffer;
	ULONG SystemInfoBufferSize = 0;

	ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &SystemInfoBufferSize);

	pSystemInfoBuffer = (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, (SIZE_T)SystemInfoBufferSize * 2, AC_POOL_TAG);
	
	memset(pSystemInfoBuffer, 0, (SIZE_T)SystemInfoBufferSize * 2);
	ZwQuerySystemInformation(SystemModuleInformation, pSystemInfoBuffer, (SIZE_T)SystemInfoBufferSize * 2, &SystemInfoBufferSize);

	for (ULONG l = 0; l < pSystemInfoBuffer->Count; l++)
	{
		if (address >= (ULONG64)pSystemInfoBuffer->Module[l].ImageBase &&
			address <= (ULONG64)pSystemInfoBuffer->Module[l].ImageBase + pSystemInfoBuffer->Module[l].ImageSize)
		{
			OutsideModulelist = FALSE;
			break;
		}
	}

	return OutsideModulelist;
}

BOOL DataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask)
{
    for (; *szMask; ++szMask, ++pData, ++bMask) if (*szMask == 'x' && *pData != *bMask) return 0;
    return (*szMask) == 0;
}

UINT64 FindPattern(UINT64 dwAddress, UINT64 dwLen, BYTE* bMask, char* szMask)
{
    for (UINT64 i = 0; i < dwLen; i++) if (DataCompare((BYTE*)(dwAddress + i), bMask, szMask)) return (UINT64)(dwAddress + i);
    return 0;
}

PVOID ResolveRelativeAddress(PVOID Instruction, ULONG OffsetOffset, ULONG InstructionSize)
{
    ULONG_PTR Instr = (ULONG_PTR)Instruction;
    LONG RipOffset = *(PLONG)(Instr + OffsetOffset);
    PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

    return ResolvedAddr;
}

PVOID GetKernelBase(OUT PULONG pSize)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG bytes = 0;
    PRTL_PROCESS_MODULES pMods = NULL;
    PVOID checkPtr = NULL;
    UNICODE_STRING routineName;
	PVOID g_KernelBase = NULL;
	ULONG g_KernelSize = 0;

    if (g_KernelBase != NULL)
    {
        if (pSize)
            *pSize = g_KernelSize;
        return g_KernelBase;
    }

    RtlUnicodeStringInit(&routineName, L"NtOpenFile");

    checkPtr = MmGetSystemRoutineAddress(&routineName);
    if (checkPtr == NULL)
        return NULL;

    status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
    if (bytes == 0)
    {
        return NULL;
    }

    pMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, AC_POOL_TAG);

    status = ZwQuerySystemInformation(SystemModuleInformation, pMods, bytes, &bytes);

    if (NT_SUCCESS(status))
    {
        PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->Modules;

        for (ULONG i = 0; i < pMods->NumberOfModules; i++)
        {
            if (checkPtr >= pMod[i].ImageBase &&
                checkPtr < (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize))
            {
                g_KernelBase = pMod[i].ImageBase;
                g_KernelSize = pMod[i].ImageSize;
                if (pSize)
                    *pSize = g_KernelSize;
                break;
            }
        }
    }

    if (pMods)
        ExFreePoolWithTag(pMods, AC_POOL_TAG);

    return g_KernelBase;
}

VOID GetThreadStartAddress(PETHREAD ThreadObj, uintptr_t* pStartAddr)
{
	HANDLE hThread;
	uintptr_t start_addr;
	ULONG returned_bytes;

	if (!NT_SUCCESS(ObOpenObjectByPointer(ThreadObj, OBJ_KERNEL_HANDLE, NULL, GENERIC_READ, *PsThreadType, KernelMode, &hThread)))
		return;

	if (!NT_SUCCESS(NtQueryInformationThread(hThread, ThreadQuerySetWin32StartAddress, &start_addr, sizeof(start_addr), &returned_bytes)))
	{
		NtClose(hThread);
		return;
	}

	if (!MmIsAddressValid((void*)start_addr))
		return;

	*pStartAddr = start_addr;

	NtClose(hThread);
}

PSYSTEM_HANDLE_INFORMATION GetHandleList()
{
	ULONG neededSize = 8 * 1024 * 1024;

	PSYSTEM_HANDLE_INFORMATION pHandleList;

	pHandleList = (PSYSTEM_HANDLE_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, neededSize, AC_POOL_TAG);
	ZwQuerySystemInformation(SystemHandleInformation, pHandleList, neededSize, 0);
	return pHandleList;
}
```