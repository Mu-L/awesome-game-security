Project Path: arc_gmh5225_valo-driver_k4p_2ho9

Source Tree:

```txt
arc_gmh5225_valo-driver_k4p_2ho9
├── README.md
├── build
│   ├── WdNisDrv.sys
│   ├── WdNisDrv.sys_sig
│   ├── dataptr_driver.pdb
│   ├── dataptr_driver.sys
│   ├── dataptr_driver.sys.bak
│   ├── dataptr_driver_signed.sys
│   ├── driver
│   │   └── dataptr_driver.sys
│   ├── driver.sys
│   ├── pdb_dosyalar
│   │   ├── dataptr_driver.Build.CppClean.log
│   │   ├── dataptr_driver.iobj
│   │   ├── dataptr_driver.sys.recipe
│   │   ├── driver.log
│   │   ├── driver.tlog
│   │   │   ├── CL.13272.write.1.tlog
│   │   │   ├── CL.command.1.tlog
│   │   │   ├── CL.read.1.tlog
│   │   │   ├── driver.lastbuildstate
│   │   │   ├── link.command.1.tlog
│   │   │   ├── link.read.1.tlog
│   │   │   └── link.write.1.tlog
│   │   ├── entry.obj
│   │   ├── mouse.obj
│   │   └── vc142.pdb
│   └── sigthief.py
├── clean.hpp
├── defines.h
├── driver.filters
├── driver.sln
├── driver.user
├── driver.vcxproj
├── driver.vcxproj.user
├── entry.cpp
├── globals.h
├── imports.h
├── mouse.cpp
├── mouse.hpp
├── struct.h
└── utils.h

```

`README.md`:

```md
# Goofy Valorant External Cheat Drivers
> Valorant Drivers For Your External Paste

if u sell this u are a fucktard <3

## Requirements

https://learn.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk

## Need Help!?

in my discord i have valorant spoofer

(https://discord.gg/badware)


```

`build/pdb_dosyalar/dataptr_driver.Build.CppClean.log`:

```log
c:\users\fffffffff\desktop\madapexmem\kernelmode\build\pdb_dosyalar\entry.obj
c:\users\fffffffff\desktop\madapexmem\kernelmode\build\pdb_dosyalar\mouse.obj
c:\users\fffffffff\desktop\madapexmem\kernelmode\build\pdb_dosyalar\vc142.pdb
c:\users\fffffffff\desktop\madapexmem\kernelmode\build\dataptr_driver.sys
c:\users\fffffffff\desktop\madapexmem\kernelmode\build\pdb_dosyalar\dataptr_driver.iobj
c:\users\fffffffff\desktop\madapexmem\kernelmode\build\dataptr_driver.pdb
c:\users\fffffffff\desktop\madapexmem\kernelmode\build\pdb_dosyalar\driver.tlog\cl.19552.write.1.tlog
c:\users\fffffffff\desktop\madapexmem\kernelmode\build\pdb_dosyalar\driver.tlog\cl.command.1.tlog
c:\users\fffffffff\desktop\madapexmem\kernelmode\build\pdb_dosyalar\driver.tlog\cl.read.1.tlog
c:\users\fffffffff\desktop\madapexmem\kernelmode\build\pdb_dosyalar\driver.tlog\link.command.1.tlog
c:\users\fffffffff\desktop\madapexmem\kernelmode\build\pdb_dosyalar\driver.tlog\link.read.1.tlog
c:\users\fffffffff\desktop\madapexmem\kernelmode\build\pdb_dosyalar\driver.tlog\link.write.1.tlog

```

`build/pdb_dosyalar/dataptr_driver.sys.recipe`:

```recipe
<?xml version="1.0" encoding="utf-8"?>
<Project>
  <ProjectOutputs>
    <ProjectOutput>
      <FullPath>C:\Users\FFFFFFFFF\Desktop\madapexmem\kernelmode\build\dataptr_driver.sys</FullPath>
    </ProjectOutput>
  </ProjectOutputs>
  <ContentFiles />
  <SatelliteDlls />
  <NonRecipeFileRefs />
</Project>
```

`build/pdb_dosyalar/driver.log`:

```log
C:\Users\FFFFFFFFF\Desktop\madapexmem\kernelmode\driver.vcxproj(35,5): warning MSB4011: "C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Microsoft\VC\v160\BuildCustomizations\masm.props" cannot be imported again. It was already imported at "C:\Program Files (x86)\Windows Kits\10\build\WindowsDriver.Shared.props (352,3)". This is most likely a build authoring error. This subsequent import will be ignored. 
C:\Users\FFFFFFFFF\Desktop\madapexmem\kernelmode\driver.vcxproj(112,5): warning MSB4011: "C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Microsoft\VC\v160\BuildCustomizations\masm.targets" cannot be imported again. It was already imported at "C:\Program Files (x86)\Windows Kits\10\build\WindowsDriver.common.targets (1878,3)". This is most likely a build authoring error. This subsequent import will be ignored. 
  Building 'driver' with toolset 'WindowsKernelModeDriver10.0' and the 'Universal' target platform.
  entry.cpp
  mouse.cpp
C:\Users\FFFFFFFFF\Desktop\madapexmem\kernelmode\imports.h(2,1): warning C4117: macro name '_KERNEL_MODE' is reserved, '#define' ignored (compiling source file entry.cpp)
C:\Users\FFFFFFFFF\Desktop\madapexmem\kernelmode\utils.h(299,70): warning C4311: 'reinterpret_cast': pointer truncation from 'HANDLE' to 'int' (compiling source file entry.cpp)
  Generating code
  Finished generating code
  driver.vcxproj -> C:\Users\FFFFFFFFF\Desktop\madapexmem\kernelmode\build\dataptr_driver.sys
  Driver is 'Universal'.
  Inf2Cat task was skipped as there were no inf files to process
  

```

`build/pdb_dosyalar/driver.tlog/CL.13272.write.1.tlog`:

```tlog
^C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\ENTRY.CPP|C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\MOUSE.CPP
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\MOUSE.OBJ
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\ENTRY.OBJ
^C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\ENTRY.CPP
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\VC142.PDB
^C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\MOUSE.CPP
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\VC142.PDB

```

`build/pdb_dosyalar/driver.tlog/CL.command.1.tlog`:

```tlog
^C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\ENTRY.CPP
/c /IC:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\ /Zi /nologo /W1 /WX- /diagnostics:column /sdl- /Ox /Ob2 /Oi /Ot /Oy- /GL /D _WIN64 /D _AMD64_ /D AMD64 /D _WIN32_WINNT=0x0A00 /D WINVER=0x0A00 /D WINNT=1 /D NTDDI_VERSION=0x0A000008 /D _WINDLL /D KMDF_VERSION_MAJOR=1 /D KMDF_VERSION_MINOR=15 /GF /Gm- /Zp8 /GS- /Gy /fp:fast /fp:except- /Qspectre /guard:ehcont- /Zc:wchar_t- /Zc:forScope /Zc:inline /GR- /std:c++latest /Fo"C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\\" /Fd"C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\VC142.PDB" /external:W1 /Gz /wd4603 /wd4627 /wd4986 /wd4987 /FI"C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WARNING.H" /FC /kernel -cbstring -d2epilogunwind  /d1nodatetime /d1import_no_registry /d2AllowCompatibleILVersions /d2Zi+  C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\ENTRY.CPP
^C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\MOUSE.CPP
/c /IC:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\ /Zi /nologo /W1 /WX- /diagnostics:column /sdl- /Ox /Ob2 /Oi /Ot /Oy- /GL /D _WIN64 /D _AMD64_ /D AMD64 /D _WIN32_WINNT=0x0A00 /D WINVER=0x0A00 /D WINNT=1 /D NTDDI_VERSION=0x0A000008 /D _WINDLL /D KMDF_VERSION_MAJOR=1 /D KMDF_VERSION_MINOR=15 /GF /Gm- /Zp8 /GS- /Gy /fp:fast /fp:except- /Qspectre /guard:ehcont- /Zc:wchar_t- /Zc:forScope /Zc:inline /GR- /std:c++latest /Fo"C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\\" /Fd"C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\VC142.PDB" /external:W1 /Gz /wd4603 /wd4627 /wd4986 /wd4987 /FI"C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WARNING.H" /FC /kernel -cbstring -d2epilogunwind  /d1nodatetime /d1import_no_registry /d2AllowCompatibleILVersions /d2Zi+  C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\MOUSE.CPP

```

`build/pdb_dosyalar/driver.tlog/CL.read.1.tlog`:

```tlog
^C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\MOUSE.CPP
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WARNING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SUPPRESS.H
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\MOUSE.HPP
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\KM\NTIFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\KM\NTDDK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\KM\WDM.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EXCPT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SAL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CONCURRENCYSAL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VADEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\NTDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WCTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MEMCPY_S.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\ERRNO.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\NTSTATUS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\BUGCODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\NTIOLOGC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\KM\MCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\DPFILTER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\EVNTPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\DEVPROPDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\KM\NTNLS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\NTDDMOU.H
^C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\ENTRY.CPP
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WARNING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SUPPRESS.H
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\IMPORTS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\KM\NTIFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\KM\NTDDK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\KM\WDM.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EXCPT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SAL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CONCURRENCYSAL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VADEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\NTDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WCTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MEMCPY_S.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\ERRNO.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\NTSTATUS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\BUGCODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\NTIOLOGC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\KM\MCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\DPFILTER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\EVNTPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\DEVPROPDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\KM\NTNLS.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INTRIN.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INTRIN0.INL.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SETJMP.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\IMMINTRIN.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\WMMINTRIN.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\NMMINTRIN.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\SMMINTRIN.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TMMINTRIN.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\PMMINTRIN.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\EMMINTRIN.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XMMINTRIN.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\MMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\MALLOC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MALLOC.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ZMMINTRIN.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\AMMINTRIN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\KM\NTIMAGE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\PSHPACK8.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\WINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\MINWINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\KM\NTSTRSAFE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_STDIO_CONFIG.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDARG.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\STDINT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDINT
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\YVALS_CORE.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XKEYCHECK.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDDEF
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDDEF.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XTR1COMMON
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\UTILITY
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\TYPE_TRAITS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\XSTDDEF
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDLIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\STDLIB.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_SEARCH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WSTDLIB.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\LIMITS.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INITIALIZER_LIST
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CONCEPTS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\VCRUNTIME_NEW.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\COMPARE
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\BIT
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\INTRIN0.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\ISA_AVAILABILITY.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\LIMITS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CFLOAT
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\FLOAT.H
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CLIMITS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CWCHAR
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\INCLUDE\CSTDIO
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\WCHAR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WCONIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WDIRECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_SHARE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WPROCESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\CORECRT_WTIME.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SYS\STAT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\UCRT\SYS\TYPES.H
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\GLOBALS.H
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\DEFINES.H
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\UTILS.H
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\MOUSE.HPP
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.19041.0\SHARED\NTDDMOU.H
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\CLEAN.HPP

```

`build/pdb_dosyalar/driver.tlog/driver.lastbuildstate`:

```lastbuildstate
PlatformToolSet=WindowsKernelModeDriver10.0:VCToolArchitecture=Native32Bit:VCToolsVersion=14.29.30133:TargetPlatformVersion=10.0.19041.0:
Release|x64|C:\Users\FFFFFFFFF\Desktop\madapexmem\kernelmode\|

```

`build/pdb_dosyalar/driver.tlog/link.command.1.tlog`:

```tlog
^C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\ENTRY.OBJ|C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\MOUSE.OBJ
/OUT:"C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\DATAPTR_DRIVER.SYS" /VERSION:"10.0" /INCREMENTAL:NO /NOLOGO /WX /SECTION:"INIT,d" NTOSKRNL.LIB MSVCRT.LIB "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\KM\X64\BUFFEROVERFLOWFASTFAILK.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\KM\X64\NTOSKRNL.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\KM\X64\HAL.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\KM\X64\WMILIB.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFLDR.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFDRIVERENTRY.LIB" /NODEFAULTLIB /MANIFEST:NO /DEBUG /PDB:"C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\DATAPTR_DRIVER.PDB" /ASSEMBLYDEBUG:DISABLE /SUBSYSTEM:NATIVE,"10.00" /LARGEADDRESSAWARE /Driver /OPT:REF /OPT:ICF /LTCG /LTCGOUT:"C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\DATAPTR_DRIVER.IOBJ" /ENTRY:"driver_entry" /RELEASE /IMPLIB:"C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\DATAPTR_DRIVER.LIB" /MERGE:"_TEXT=.text;_PAGE=PAGE" /MACHINE:X64 /PROFILE /CETCOMPAT:NO /SAFESEH:NO /EMITPOGOPHASEINFO /kernel /IGNORE:4198,4010,4037,4039,4065,4070,4078,4087,4089,4221,4108,4088,4218,4218,4235 /osversion:10.0 /pdbcompress /debugtype:pdata /DLL C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\ENTRY.OBJ
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\MOUSE.OBJ

```

`build/pdb_dosyalar/driver.tlog/link.read.1.tlog`:

```tlog
^C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\ENTRY.OBJ|C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\MOUSE.OBJ
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\KM\X64\NTOSKRNL.LIB
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\LIB\SPECTRE\X64\MSVCRT.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\KM\X64\BUFFEROVERFLOWFASTFAILK.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\KM\X64\HAL.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.19041.0\KM\X64\WMILIB.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFLDR.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFDRIVERENTRY.LIB
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\ENTRY.OBJ
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\MOUSE.OBJ
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\BIN\HOSTX86\X64\C2.DLL
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2019\COMMUNITY\VC\TOOLS\MSVC\14.29.30133\BIN\HOSTX86\X64\1033\LINKUI.DLL
C:\WINDOWS\SYSTEM32\TZRES.DLL

```

`build/pdb_dosyalar/driver.tlog/link.write.1.tlog`:

```tlog
^C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\ENTRY.OBJ|C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\MOUSE.OBJ
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\DATAPTR_DRIVER.SYS
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\PDB_DOSYALAR\DATAPTR_DRIVER.IOBJ
C:\USERS\FFFFFFFFF\DESKTOP\MADAPEXMEM\KERNELMODE\BUILD\DATAPTR_DRIVER.PDB

```

`build/sigthief.py`:

```py
#!/usr/bin/env python3
# LICENSE: BSD-3
# Copyright: Josh Pitts @midnite_runr

import sys
import struct
import shutil
import io
from optparse import OptionParser


def gather_file_info_win(binary):
        """
        Borrowed from BDF...
        I could just skip to certLOC... *shrug*
        """
        flItms = {}
        binary = open(binary, 'rb')
        binary.seek(int('3C', 16))
        flItms['buffer'] = 0
        flItms['JMPtoCodeAddress'] = 0
        flItms['dis_frm_pehdrs_sectble'] = 248
        flItms['pe_header_location'] = struct.unpack('<i', binary.read(4))[0]
        # Start of COFF
        flItms['COFF_Start'] = flItms['pe_header_location'] + 4
        binary.seek(flItms['COFF_Start'])
        flItms['MachineType'] = struct.unpack('<H', binary.read(2))[0]
        binary.seek(flItms['COFF_Start'] + 2, 0)
        flItms['NumberOfSections'] = struct.unpack('<H', binary.read(2))[0]
        flItms['TimeDateStamp'] = struct.unpack('<I', binary.read(4))[0]
        binary.seek(flItms['COFF_Start'] + 16, 0)
        flItms['SizeOfOptionalHeader'] = struct.unpack('<H', binary.read(2))[0]
        flItms['Characteristics'] = struct.unpack('<H', binary.read(2))[0]
        #End of COFF
        flItms['OptionalHeader_start'] = flItms['COFF_Start'] + 20

        #if flItms['SizeOfOptionalHeader']:
            #Begin Standard Fields section of Optional Header
        binary.seek(flItms['OptionalHeader_start'])
        flItms['Magic'] = struct.unpack('<H', binary.read(2))[0]
        flItms['MajorLinkerVersion'] = struct.unpack("!B", binary.read(1))[0]
        flItms['MinorLinkerVersion'] = struct.unpack("!B", binary.read(1))[0]
        flItms['SizeOfCode'] = struct.unpack("<I", binary.read(4))[0]
        flItms['SizeOfInitializedData'] = struct.unpack("<I", binary.read(4))[0]
        flItms['SizeOfUninitializedData'] = struct.unpack("<I",
                                                               binary.read(4))[0]
        flItms['AddressOfEntryPoint'] = struct.unpack('<I', binary.read(4))[0]
        flItms['PatchLocation'] = flItms['AddressOfEntryPoint']
        flItms['BaseOfCode'] = struct.unpack('<I', binary.read(4))[0]
        if flItms['Magic'] != 0x20B:
            flItms['BaseOfData'] = struct.unpack('<I', binary.read(4))[0]
        # End Standard Fields section of Optional Header
        # Begin Windows-Specific Fields of Optional Header
        if flItms['Magic'] == 0x20B:
            flItms['ImageBase'] = struct.unpack('<Q', binary.read(8))[0]
        else:
            flItms['ImageBase'] = struct.unpack('<I', binary.read(4))[0]
        flItms['SectionAlignment'] = struct.unpack('<I', binary.read(4))[0]
        flItms['FileAlignment'] = struct.unpack('<I', binary.read(4))[0]
        flItms['MajorOperatingSystemVersion'] = struct.unpack('<H',
                                                                   binary.read(2))[0]
        flItms['MinorOperatingSystemVersion'] = struct.unpack('<H',
                                                                   binary.read(2))[0]
        flItms['MajorImageVersion'] = struct.unpack('<H', binary.read(2))[0]
        flItms['MinorImageVersion'] = struct.unpack('<H', binary.read(2))[0]
        flItms['MajorSubsystemVersion'] = struct.unpack('<H', binary.read(2))[0]
        flItms['MinorSubsystemVersion'] = struct.unpack('<H', binary.read(2))[0]
        flItms['Win32VersionValue'] = struct.unpack('<I', binary.read(4))[0]
        flItms['SizeOfImageLoc'] = binary.tell()
        flItms['SizeOfImage'] = struct.unpack('<I', binary.read(4))[0]
        flItms['SizeOfHeaders'] = struct.unpack('<I', binary.read(4))[0]
        flItms['CheckSum'] = struct.unpack('<I', binary.read(4))[0]
        flItms['Subsystem'] = struct.unpack('<H', binary.read(2))[0]
        flItms['DllCharacteristics'] = struct.unpack('<H', binary.read(2))[0]
        if flItms['Magic'] == 0x20B:
            flItms['SizeOfStackReserve'] = struct.unpack('<Q', binary.read(8))[0]
            flItms['SizeOfStackCommit'] = struct.unpack('<Q', binary.read(8))[0]
            flItms['SizeOfHeapReserve'] = struct.unpack('<Q', binary.read(8))[0]
            flItms['SizeOfHeapCommit'] = struct.unpack('<Q', binary.read(8))[0]

        else:
            flItms['SizeOfStackReserve'] = struct.unpack('<I', binary.read(4))[0]
            flItms['SizeOfStackCommit'] = struct.unpack('<I', binary.read(4))[0]
            flItms['SizeOfHeapReserve'] = struct.unpack('<I', binary.read(4))[0]
            flItms['SizeOfHeapCommit'] = struct.unpack('<I', binary.read(4))[0]
        flItms['LoaderFlags'] = struct.unpack('<I', binary.read(4))[0]  # zero
        flItms['NumberofRvaAndSizes'] = struct.unpack('<I', binary.read(4))[0]
        # End Windows-Specific Fields of Optional Header
        # Begin Data Directories of Optional Header
        flItms['ExportTableRVA'] = struct.unpack('<I', binary.read(4))[0]
        flItms['ExportTableSize'] = struct.unpack('<I', binary.read(4))[0]
        flItms['ImportTableLOCInPEOptHdrs'] = binary.tell()
        #ImportTable SIZE|LOC
        flItms['ImportTableRVA'] = struct.unpack('<I', binary.read(4))[0]
        flItms['ImportTableSize'] = struct.unpack('<I', binary.read(4))[0]
        flItms['ResourceTable'] = struct.unpack('<Q', binary.read(8))[0]
        flItms['ExceptionTable'] = struct.unpack('<Q', binary.read(8))[0]
        flItms['CertTableLOC'] = binary.tell()
        flItms['CertLOC'] = struct.unpack("<I", binary.read(4))[0]
        flItms['CertSize'] = struct.unpack("<I", binary.read(4))[0]
        binary.close()
        return flItms


def copyCert(exe):
    flItms = gather_file_info_win(exe)

    if flItms['CertLOC'] == 0 or flItms['CertSize'] == 0:
        # not signed
        print("Input file Not signed!")
        sys.exit(-1)

    with open(exe, 'rb') as f:
        f.seek(flItms['CertLOC'], 0)
        cert = f.read(flItms['CertSize'])
    return cert


def writeCert(cert, exe, output):
    flItms = gather_file_info_win(exe)
    
    if not output: 
        output = output = str(exe) + "_signed"

    shutil.copy2(exe, output)
    
    print("Output file: {0}".format(output))

    with open(exe, 'rb') as g:
        with open(output, 'wb') as f:
            f.write(g.read())
            f.seek(0)
            f.seek(flItms['CertTableLOC'], 0)
            f.write(struct.pack("<I", len(open(exe, 'rb').read())))
            f.write(struct.pack("<I", len(cert)))
            f.seek(0, io.SEEK_END)
            f.write(cert)

    print("Signature appended. \nFIN.")


def outputCert(exe, output):
    cert = copyCert(exe)
    if not output:
        output = str(exe) + "_sig"

    print("Output file: {0}".format(output))

    open(output, 'wb').write(cert)

    print("Signature ripped. \nFIN.")


def check_sig(exe):
    flItms = gather_file_info_win(exe)
 
    if flItms['CertLOC'] == 0 or flItms['CertSize'] == 0:
        # not signed
        print("Inputfile Not signed!")
    else:
        print("Inputfile is signed!")


def truncate(exe, output):
    flItms = gather_file_info_win(exe)
 
    if flItms['CertLOC'] == 0 or flItms['CertSize'] == 0:
        # not signed
        print("Inputfile Not signed!")
        sys.exit(-1)
    else:
        print( "Inputfile is signed!")

    if not output:
        output = str(exe) + "_nosig"

    print("Output file: {0}".format(output))

    shutil.copy2(exe, output)

    with open(output, "r+b") as binary:
        print('Overwriting certificate table pointer and truncating binary')
        binary.seek(-flItms['CertSize'], io.SEEK_END)
        binary.truncate()
        binary.seek(flItms['CertTableLOC'], 0)
        binary.write(b"\x00\x00\x00\x00\x00\x00\x00\x00")

    print("Signature removed. \nFIN.")


def signfile(exe, sigfile, output):
    flItms = gather_file_info_win(exe)
    
    cert = open(sigfile, 'rb').read()

    if not output: 
        output = output = str(exe) + "_signed"

    shutil.copy2(exe, output)
    
    print("Output file: {0}".format(output))
    
    with open(exe, 'rb') as g:
        with open(output, 'wb') as f:
            f.write(g.read())
            f.seek(0)
            f.seek(flItms['CertTableLOC'], 0)
            f.write(struct.pack("<I", len(open(exe, 'rb').read())))
            f.write(struct.pack("<I", len(cert)))
            f.seek(0, io.SEEK_END)
            f.write(cert)
    print("Signature appended. \nFIN.")


if __name__ == "__main__":
    usage = 'usage: %prog [options]'
    print("\n\n!! New Version available now for Dev Tier Sponsors! Sponsor here: https://github.com/sponsors/secretsquirrel\n\n")
    parser = OptionParser()
    parser.add_option("-i", "--file", dest="inputfile", 
                  help="input file", metavar="FILE")
    parser.add_option('-r', '--rip', dest='ripsig', action='store_true',
                  help='rip signature off inputfile')
    parser.add_option('-a', '--add', dest='addsig', action='store_true',
                  help='add signautre to targetfile')
    parser.add_option('-o', '--output', dest='outputfile',
                  help='output file')
    parser.add_option('-s', '--sig', dest='sigfile',
                  help='binary signature from disk')
    parser.add_option('-t', '--target', dest='targetfile',
                  help='file to append signature to')
    parser.add_option('-c', '--checksig', dest='checksig', action='store_true',
                  help='file to check if signed; does not verify signature')
    parser.add_option('-T', '--truncate', dest="truncate", action='store_true',
                  help='truncate signature (i.e. remove sig)')
    (options, args) = parser.parse_args()
    
    # rip signature
    # inputfile and rip to outputfile
    if options.inputfile and options.ripsig:
        print("Ripping signature to file!")
        outputCert(options.inputfile, options.outputfile)
        sys.exit()    

    # copy from one to another
    # inputfile and rip to targetfile to outputfile    
    if options.inputfile and options.targetfile:
        cert = copyCert(options.inputfile)
        writeCert(cert, options.targetfile, options.outputfile)
        sys.exit()

    # check signature
    # inputfile 
    if options.inputfile and options.checksig:
        check_sig(options.inputfile) 
        sys.exit()

    # add sig to target file
    if options.targetfile and options.sigfile:
        signfile(options.targetfile, options.sigfile, options.outputfile)
        sys.exit()
        
    # truncate
    if options.inputfile and options.truncate:
        truncate(options.inputfile, options.outputfile)
        sys.exit()

    parser.print_help()
    parser.error("You must do something!")


```

`clean.hpp`:

```hpp
#pragma once
//#include "struct.h"
#define log(format, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, format, __VA_ARGS__)
#define BB_POOL_TAG 'enoB'
UCHAR PiDDBLockPtr_sig[] = "\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x4C\x8B\x8C";
UCHAR PiDDBCacheTablePtr_sig[] = "\x66\x03\xD2\x48\x8D\x0D";
//you can also put the sig within the function, but some of the sig ends up on the stack and in the .text section, and causes issues when zeroing the sig memory.

EXTERN_C PVOID ResolveRelativeAddress(
	_In_ PVOID Instruction,
	_In_ ULONG OffsetOffset,
	_In_ ULONG InstructionSize
)
{
	ULONG_PTR Instr = (ULONG_PTR)Instruction;
	LONG RipOffset = *(PLONG)(Instr + OffsetOffset);
	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

	return ResolvedAddr;
}

NTSTATUS BBSearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound, int index = 0)
{
	ASSERT(ppFound != NULL && pattern != NULL && base != NULL);
	if (ppFound == NULL || pattern == NULL || base == NULL)
		return STATUS_ACCESS_DENIED; //STATUS_INVALID_PARAMETER;
	int cIndex = 0;
	for (ULONG_PTR i = 0; i < size - len; i++)
	{
		BOOLEAN found = TRUE;
		for (ULONG_PTR j = 0; j < len; j++)
		{
			if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])
			{
				found = FALSE;
				break;
			}
		}

		if (found != FALSE && cIndex++ == index)
		{
			*ppFound = (PUCHAR)base + i;
			return STATUS_SUCCESS;
		}
	}

	return STATUS_NOT_FOUND;
}

PVOID g_KernelBase = NULL;
ULONG g_KernelSize = 0;
PVOID GetKernelBase(OUT PULONG pSize)
{
	NTSTATUS status = STATUS_SUCCESS;
	ULONG bytes = 0;
	PRTL_PROCESS_MODULES pMods = NULL;
	PVOID checkPtr = NULL;
	UNICODE_STRING routineName;

	// Already found
	if (g_KernelBase != NULL)
	{
		if (pSize)
			*pSize = g_KernelSize;
		return g_KernelBase;
	}

	RtlUnicodeStringInit(&routineName, L"NtOpenFile");

	checkPtr = MmGetSystemRoutineAddress(&routineName);
	if (checkPtr == NULL)
		return NULL;

	// Protect from UserMode AV
	status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
	if (bytes == 0)
	{
		log("Invalid SystemModuleInformation size");
		return NULL;
	}

	pMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, BB_POOL_TAG);
	RtlZeroMemory(pMods, bytes);

	status = ZwQuerySystemInformation(SystemModuleInformation, pMods, bytes, &bytes);

	if (NT_SUCCESS(status))
	{
		PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->modules;

		for (ULONG i = 0; i < pMods->number_of_modules; i++)
		{
			// System routine is inside module
			if (checkPtr >= pMod[i].image_base &&
				checkPtr < (PVOID)((PUCHAR)pMod[i].image_base + pMod[i].image_size))
			{
				g_KernelBase = pMod[i].image_base;
				g_KernelSize = pMod[i].image_size;
				if (pSize)
					*pSize = g_KernelSize;
				break;
			}
		}
	}

	if (pMods)
		ExFreePoolWithTag(pMods, BB_POOL_TAG);
	log("g_KernelBase: %x", g_KernelBase);
	log("g_KernelSize: %x", g_KernelSize);
	return g_KernelBase;
}

EXTERN_C NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
	IN PVOID   ModuleAddress);
NTSTATUS BBScanSection(IN PCCHAR section, IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, OUT PVOID* ppFound, PVOID base = nullptr)
{
	//ASSERT(ppFound != NULL);
	if (ppFound == NULL)
		return STATUS_ACCESS_DENIED; //STATUS_INVALID_PARAMETER

	if (nullptr == base)
		base = GetKernelBase(&g_KernelSize);
	if (base == nullptr)
		return STATUS_ACCESS_DENIED; //STATUS_NOT_FOUND;

	PIMAGE_NT_HEADERS64 pHdr = RtlImageNtHeader(base);
	if (!pHdr)
		return STATUS_ACCESS_DENIED; // STATUS_INVALID_IMAGE_FORMAT;

	//PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)(pHdr + 1);
	PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)((uintptr_t)&pHdr->FileHeader + pHdr->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_FILE_HEADER));

	for (PIMAGE_SECTION_HEADER pSection = pFirstSection; pSection < pFirstSection + pHdr->FileHeader.NumberOfSections; pSection++)
	{
		//DbgPrint("section: %s\r\n", pSection->Name);
		ANSI_STRING s1, s2;
		RtlInitAnsiString(&s1, section);
		RtlInitAnsiString(&s2, (PCCHAR)pSection->Name);
		if (RtlCompareString(&s1, &s2, TRUE) == 0)
		{
			PVOID ptr = NULL;
			NTSTATUS status = BBSearchPattern(pattern, wildcard, len, (PUCHAR)base + pSection->VirtualAddress, pSection->Misc.VirtualSize, &ptr);
			if (NT_SUCCESS(status)) {
				*(PULONG64)ppFound = (ULONG_PTR)(ptr); //- (PUCHAR)base
				//DbgPrint("found\r\n");
				return status;
			}
			//we continue scanning because there can be multiple sections with the same name.
		}
	}

	return STATUS_ACCESS_DENIED; //STATUS_NOT_FOUND;
}
extern "C" bool LocatePiDDB(PERESOURCE * lock, PRTL_AVL_TABLE * table)
{
	PVOID PiDDBLockPtr = nullptr, PiDDBCacheTablePtr = nullptr;
	
	//PCCHAR page = "PAGE";
	if (!NT_SUCCESS(BBScanSection((PCCHAR)"PAGE", PiDDBLockPtr_sig, 0, sizeof(PiDDBLockPtr_sig) - 1, reinterpret_cast<PVOID*>(&PiDDBLockPtr)))) {
		log("Unable to find PiDDBLockPtr sig.");
		return false;
	}

	if (!NT_SUCCESS(BBScanSection((PCCHAR)"PAGE", PiDDBCacheTablePtr_sig, 0, sizeof(PiDDBCacheTablePtr_sig) - 1, reinterpret_cast<PVOID*>(&PiDDBCacheTablePtr)))) {
		log("Unable to find PiDDBCacheTablePtr sig");
		return false;
	}

	PiDDBCacheTablePtr = PVOID((uintptr_t)PiDDBCacheTablePtr + 3);

	*lock = (PERESOURCE)(ResolveRelativeAddress(PiDDBLockPtr, 3, 7));
	*table = (PRTL_AVL_TABLE)(ResolveRelativeAddress(PiDDBCacheTablePtr, 3, 7));

	return true;
}


#define MM_UNLOADED_DRIVERS_SIZE 50
typedef struct _MM_UNLOADED_DRIVER
{
	UNICODE_STRING 	Name;
	PVOID 			ModuleStart;
	PVOID 			ModuleEnd;
	ULONG64 		UnloadTime;
} MM_UNLOADED_DRIVER, * PMM_UNLOADED_DRIVER;


PMM_UNLOADED_DRIVER MmUnloadedDrivers;
PULONG				MmLastUnloadedDriver;

BOOLEAN bDataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask)
{
	for (; *szMask; ++szMask, ++pData, ++bMask)
		if (*szMask == 'x' && *pData != *bMask)
			return 0;

	return (*szMask) == 0;
}

UINT64 FindPattern(UINT64 dwAddress, UINT64 dwLen, BYTE* bMask, const char* szMask)
{
	for (UINT64 i = 0; i < dwLen; i++)
		if (bDataCompare((BYTE*)(dwAddress + i), bMask, szMask))
			return (UINT64)(dwAddress + i);

	return 0;
}
NTSTATUS FindMmDriverData(
	VOID
)
{
	/*
	 *	nt!MmLocateUnloadedDriver:
	 *	fffff801`51c70394 4c8b15a57e1500  mov     r10,qword ptr [nt!MmUnloadedDrivers (fffff801`51dc8240)]
	 *	fffff801`51c7039b 4c8bc9          mov     r9 ,rcx
	 */
	PVOID MmUnloadedDriversInstr = (PVOID)FindPattern((UINT64)g_KernelBase, g_KernelSize,
		(BYTE*)"\x4C\x8B\x15\x00\x00\x00\x00\x4C\x8B\xC9",
		"xxx????xxx"
	);

	/*
	 *	nt!MiRememberUnloadedDriver+0x59:
	 *	fffff801`5201a4c5 8b057ddddaff    mov     eax,dword ptr [nt!MmLastUnloadedDriver (fffff801`51dc8248)]
	 *	fffff801`5201a4cb 83f832          cmp     eax,32h
	*/
	PVOID MmLastUnloadedDriverInstr = (PVOID)FindPattern((UINT64)g_KernelBase, g_KernelSize,
		(BYTE*)"\x8B\x05\x00\x00\x00\x00\x83\xF8\x32",
		"xx????xxx"
	);

	if (MmUnloadedDriversInstr == NULL || MmLastUnloadedDriverInstr == NULL)
	{
		return STATUS_NOT_FOUND;
	}

	MmUnloadedDrivers = *(PMM_UNLOADED_DRIVER*)ResolveRelativeAddress(MmUnloadedDriversInstr, 3, 7);
	MmLastUnloadedDriver = (PULONG)ResolveRelativeAddress(MmLastUnloadedDriverInstr, 2, 6);
	/*log("MmUnloadedDrivers ModuleEnd: %x", MmUnloadedDrivers->ModuleEnd);
	log("MmUnloadedDrivers ModuleStart: %x", MmUnloadedDrivers->ModuleStart);
	log("MmUnloadedDrivers Name: %s", MmUnloadedDrivers->Name);
	log("MmUnloadedDrivers UnloadTime: %x", MmUnloadedDrivers->UnloadTime);*/

	log("MmUnloadedDrivers Addr: %x", MmUnloadedDrivers);
	log("MmLastUnloadedDriver Addr: %x", MmLastUnloadedDriver);
	return STATUS_SUCCESS;
}

BOOLEAN IsUnloadedDriverEntryEmpty(
	_In_ PMM_UNLOADED_DRIVER Entry
)
{
	if (Entry->Name.MaximumLength == 0 ||
		Entry->Name.Length == 0 ||
		Entry->Name.Buffer == NULL)
	{
		return TRUE;
	}

	return FALSE;
}

BOOLEAN IsMmUnloadedDriversFilled(
	VOID
)
{
	for (ULONG Index = 0; Index < MM_UNLOADED_DRIVERS_SIZE; ++Index)
	{
		PMM_UNLOADED_DRIVER Entry = &MmUnloadedDrivers[Index];
		if (IsUnloadedDriverEntryEmpty(Entry))
		{
			return FALSE;
		}
	}

	return TRUE;
}



ERESOURCE PsLoadedModuleResource;


struct PiDDBCacheEntry
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
};

namespace clear {
	void clearCache(UNICODE_STRING DriverName, ULONG timeDateStamp) {
		// first locate required variables
		PERESOURCE PiDDBLock; PRTL_AVL_TABLE PiDDBCacheTable;
		if (!LocatePiDDB(&PiDDBLock, &PiDDBCacheTable)) {
			log("ClearCache Failed");
			return;
		}

		log("Found PiDDBLock and PiDDBCacheTable");
		log("Found PiDDBLock %x", PiDDBLock);
		log("Found PiDDBCacheTable %x", PiDDBCacheTable);
		// build a lookup entry
		PiDDBCacheEntry lookupEntry = { };
		lookupEntry.DriverName = DriverName;
		lookupEntry.TimeDateStamp = timeDateStamp;

		// acquire the ddb resource lock
		ExAcquireResourceExclusiveLite(PiDDBLock, TRUE);

		// search our entry in the table
		auto pFoundEntry = (PiDDBCacheEntry*)RtlLookupElementGenericTableAvl(PiDDBCacheTable, &lookupEntry);
		if (pFoundEntry == nullptr)
		{
			// release the ddb resource lock
			ExReleaseResourceLite(PiDDBLock);
			log("ClearCache Failed (Not found)");
			return;
		}

		// first, unlink from the list
		RemoveEntryList(&pFoundEntry->List);
		// then delete the element from the avl table
		RtlDeleteElementGenericTableAvl(PiDDBCacheTable, pFoundEntry);

		// release the ddb resource lock
		ExReleaseResourceLite(PiDDBLock);
		log("ClearCache Sucessful");
	}




	NTSTATUS ClearUnloadedDriver(
		_In_ PUNICODE_STRING	DriverName,
		_In_ BOOLEAN			AccquireResource
	)
	{
		if (AccquireResource)
		{
			ExAcquireResourceExclusiveLite(&PsLoadedModuleResource, TRUE);
		}

		BOOLEAN Modified = FALSE;
		BOOLEAN Filled = IsMmUnloadedDriversFilled();

		for (ULONG Index = 0; Index < MM_UNLOADED_DRIVERS_SIZE; ++Index)
		{
			PMM_UNLOADED_DRIVER Entry = &MmUnloadedDrivers[Index];
			if (Modified)
			{
				//
				// Shift back all entries after modified one.
				//
				PMM_UNLOADED_DRIVER PrevEntry = &MmUnloadedDrivers[Index - 1];
				RtlCopyMemory(PrevEntry, Entry, sizeof(MM_UNLOADED_DRIVER));

				//
				// Zero last entry.
				//
				if (Index == MM_UNLOADED_DRIVERS_SIZE - 1)
				{
					RtlFillMemory(Entry, sizeof(MM_UNLOADED_DRIVER), 0);
				}
			}
			else if (RtlEqualUnicodeString(DriverName, &Entry->Name, TRUE))
			{
				//
				// Erase driver entry.
				//
				PVOID BufferPool = Entry->Name.Buffer;
				RtlFillMemory(Entry, sizeof(MM_UNLOADED_DRIVER), 0);
				ExFreePoolWithTag(BufferPool, 'TDmM');

				//
				// Because we are erasing last entry we want to set MmLastUnloadedDriver to 49
				// if list have been already filled.
				//
				*MmLastUnloadedDriver = (Filled ? MM_UNLOADED_DRIVERS_SIZE : *MmLastUnloadedDriver) - 1;
				Modified = TRUE;
			}
		}

		if (Modified)
		{
			ULONG64 PreviousTime = 0;

			//
			// Make UnloadTime look right.
			//
			for (LONG Index = MM_UNLOADED_DRIVERS_SIZE - 2; Index >= 0; --Index)
			{
				PMM_UNLOADED_DRIVER Entry = &MmUnloadedDrivers[Index];
				if (IsUnloadedDriverEntryEmpty(Entry))
				{
					continue;
				}

				if (PreviousTime != 0 && Entry->UnloadTime > PreviousTime)
				{
					//
					// Decrease by random value here maybe.
					//
					Entry->UnloadTime = PreviousTime - 100;
				}

				PreviousTime = Entry->UnloadTime;
			}

			//
			// Clear remaining entries.
			//
			ClearUnloadedDriver(DriverName, FALSE);
		}

		if (AccquireResource)
		{
			ExReleaseResourceLite(&PsLoadedModuleResource);
		}

		return Modified ? STATUS_SUCCESS : STATUS_NOT_FOUND;
	}
}
```

`defines.h`:

```h
#define dbg( content, ... ) DbgPrintEx( 0, 0, "[>] " content, __VA_ARGS__ )
#define rva(instruction, size) ( instruction + size + *reinterpret_cast<long*>(instruction + (size - sizeof(long))))
#define size_align(size) ((size + 0xFFF) & 0xFFFFFFFFFFFFF000)
#define to_lower_c(ch) ((ch >= 'A' && ch <= 'Z') ? (ch + 32) : ch)

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE section;
	PVOID mapped_base;
	PVOID image_base;
	ULONG image_size;
	ULONG flags;
	USHORT load_order_index;
	USHORT init_order_index;
	USHORT load_count;
	USHORT offset_to_file_name;
	UCHAR  full_path_name[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG number_of_modules;
	RTL_PROCESS_MODULE_INFORMATION modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;
typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

typedef  enum
{
	PS_COSMETIC = 0x00000000,
	PS_ENDCAP_ROUND = 0x00000000,
	PS_JOIN_ROUND = 0x00000000,
	PS_SOLID = 0x00000000,
	PS_DASH = 0x00000001,
	PS_DOT = 0x00000002,
	PS_DASHDOT = 0x00000003,
	PS_DASHDOTDOT = 0x00000004,
	PS_NULL = 0x00000005,
	PS_INSIDEFRAME = 0x00000006,
	PS_USERSTYLE = 0x00000007,
	PS_ALTERNATE = 0x00000008,
	PS_ENDCAP_SQUARE = 0x00000100,
	PS_ENDCAP_FLAT = 0x00000200,
	PS_JOIN_BEVEL = 0x00001000,
	PS_JOIN_MITER = 0x00002000,
	PS_GEOMETRIC = 0x00010000
} PenStyle;

typedef struct {
	LONG lfHeight;
	LONG lfWidth;
	LONG lfEscapement;
	LONG lfOrientation;
	LONG lfWeight;
	BYTE lfItalic;
	BYTE lfUnderline;
	BYTE lfStrikeOut;
	BYTE lfCharSet;
	BYTE lfOutPrecision;
	BYTE lfClipPrecision;
	BYTE lfQuality;
	BYTE lfPitchAndFamily;
	WCHAR lfFaceName[32];
} LOGFONTW;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY in_load_order_links;
	LIST_ENTRY in_memory_order_links;
	LIST_ENTRY in_initialization_order_links;
	PVOID dll_base;
	PVOID entry_point;
	ULONG size_of_image;
	UNICODE_STRING full_dll_name;
	UNICODE_STRING base_dll_name;
	ULONG flags;
	WORD load_count;
	WORD tls_index;
	union
	{
		LIST_ENTRY hash_links;
		struct
		{
			PVOID section_pointer;
			ULONG check_sum;
		};
	};
	union
	{
		ULONG time_date_stamp;
		PVOID loaded_imports;
	};
	void *entry_point_activation_context;
	PVOID patch_information;
	LIST_ENTRY forwarder_links;
	LIST_ENTRY service_tag_links;
	LIST_ENTRY static_links;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _RTL_CRITICAL_SECTION
{
	void *debug_info;
	LONG lock_count;
	LONG recursion_count;
	PVOID owning_thread;
	PVOID lock_semaphore;
	ULONG spin_count;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

typedef struct _PEB_LDR_DATA
{
	ULONG length;
	UCHAR initialized;
	PVOID ss_handle;
	LIST_ENTRY in_load_order_module_list;
	LIST_ENTRY in_memory_order_module_list;
	LIST_ENTRY in_initialization_order_module_list;
	PVOID entry_in_progress;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _PEB
{
	UCHAR inherited_address_space;
	UCHAR read_image_file_exec_options;
	UCHAR being_debugged;
	UCHAR bit_field;
	ULONG image_uses_large_pages : 1;
	ULONG is_protected_process : 1;
	ULONG is_legacy_process : 1;
	ULONG is_image_dynamically_relocated : 1;
	ULONG spare_bits : 4;
	PVOID mutant;
	PVOID image_base_address;
	PPEB_LDR_DATA ldr;
	void *process_parameters;
	PVOID sub_system_data;
	PVOID process_heap;
	PRTL_CRITICAL_SECTION fast_peb_lock;
	PVOID atl_thunk_s_list_ptr;
	PVOID ifeo_key;
	ULONG cross_process_flags;
	ULONG process_in_job : 1;
	ULONG process_initializing : 1;
	ULONG reserved_bits0 : 30;
	union
	{
		PVOID kernel_callback_table;
		PVOID user_shared_info_ptr;
	};
	ULONG system_reserved[1];
	ULONG spare_ulong;
	void *free_list;
	ULONG tls_expansion_counter;
	PVOID tls_bitmap;
	ULONG tls_bitmap_bits[2];
	PVOID read_only_shared_memory_base;
	PVOID hotpatch_information;
	void **read_only_static_server_data;
	PVOID ansi_code_page_data;
	PVOID oem_code_page_data;
	PVOID unicode_case_table_data;
	ULONG number_of_processors;
	ULONG nt_global_flag;
	LARGE_INTEGER critical_section_timeout;
	ULONG heap_segment_reserve;
	ULONG heap_segment_commit;
	ULONG heap_de_commit_total_free_threshold;
	ULONG heap_de_commit_free_block_threshold;
	ULONG number_of_heaps;
	ULONG maximum_number_of_heaps;
	void **process_heaps;
	PVOID gdi_shared_handle_table;
	PVOID process_starter_helper;
	ULONG gdi_dc_attribute_list;
	PRTL_CRITICAL_SECTION loader_lock;
	ULONG os_major_version;
	ULONG os_minor_version;
	WORD os_build_number;
	WORD oscsd_version;
	ULONG os_platform_id;
	ULONG image_subsystem;
	ULONG image_subsystem_major_version;
	ULONG image_subsystem_minor_version;
	ULONG image_process_affinity_mask;
	ULONG gdi_handle_buffer[34];
	PVOID post_process_init_routine;
	PVOID tls_expansion_bitmap;
	ULONG tls_expansion_bitmap_bits[32];
	ULONG session_id;
	ULARGE_INTEGER app_compat_flags;
	ULARGE_INTEGER app_compat_flags_user;
	PVOID p_shim_data;
	PVOID app_compat_info;
	UNICODE_STRING csd_version;
	void *activation_context_data;
	void *process_assembly_storage_map;
	void *system_default_activation_context_data;
	void *system_assembly_storage_map;
	ULONG minimum_stack_commit;
	void *fls_callback;
	LIST_ENTRY fls_list_head;
	PVOID fls_bitmap;
	ULONG fls_bitmap_bits4[4];
	ULONG fls_high_index;
	void* wer_registration_data;
	void* wer_ship_assert_ptr;
} PEB, *PPEB;

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER kernel_time;
	LARGE_INTEGER user_time;
	LARGE_INTEGER create_time;
	ULONG wait_time;
	PVOID start_address;
	CLIENT_ID client_id;
	KPRIORITY priority;
	LONG base_priority;
	ULONG context_switches;
	ULONG thread_state;
	KWAIT_REASON wait_reason;
}SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFO
{
	ULONG next_entry_offset;
	ULONG number_of_threads;
	LARGE_INTEGER working_set_private_size;
	ULONG hard_fault_count;
	ULONG number_of_threads_high_watermark;
	ULONGLONG cycle_time;
	LARGE_INTEGER create_time;
	LARGE_INTEGER user_time;
	LARGE_INTEGER kernel_time;
	UNICODE_STRING image_name;
	KPRIORITY base_priority;
	HANDLE unique_process_id;
	HANDLE inherited_from_unique_process_id;
	ULONG handle_count;
	ULONG session_id;
	ULONG_PTR unique_process_key;
	SIZE_T peak_virtual_size;
	SIZE_T virtual_size;
	ULONG page_fault_count;
	SIZE_T peak_working_set_size;
	SIZE_T working_set_size;
	SIZE_T quota_peak_paged_pool_usage;
	SIZE_T quota_paged_pool_usage;
	SIZE_T quota_peak_non_paged_pool_usage;
	SIZE_T quota_non_paged_pool_usage;
	SIZE_T pagefile_usage;
	SIZE_T peak_pagefile_usage;
	SIZE_T private_page_count;
	LARGE_INTEGER read_operation_count;
	LARGE_INTEGER write_operation_count;
	LARGE_INTEGER other_operation_count;
	LARGE_INTEGER read_transfer_count;
	LARGE_INTEGER write_transfer_count;
	LARGE_INTEGER other_transfer_count;
	SYSTEM_THREAD_INFORMATION threads[1];
}SYSTEM_PROCESS_INFO, *PSYSTEM_PROCESS_INFO;

typedef struct _SYSTEM_BIGPOOL_ENTRY
{
	union {
		PVOID VirtualAddress;
		ULONG_PTR NonPaged : 1;
	};
	ULONG_PTR SizeInBytes;
	union {
		UCHAR Tag[4];
		ULONG TagUlong;
	};
} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;

//burası sağolsun yoksa yapamıcaktı ahshqwue http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/bigpool.htm
typedef struct _SYSTEM_BIGPOOL_INFORMATION {
	ULONG Count;
	SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ANYSIZE_ARRAY];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;

extern "C"
{
	NTKERNELAPI
		PVOID
		PsGetProcessSectionBaseAddress(
			__in PEPROCESS Process
		);
	NTSYSAPI NTSTATUS RtlCreateUserThread(HANDLE, PVOID, BOOLEAN, ULONG, SIZE_T, SIZE_T, PVOID, PVOID, PHANDLE, PCLIENT_ID);
	__declspec( dllimport ) NTSTATUS ZwWaitForMultipleObjects( unsigned long, HANDLE[], WAIT_TYPE, BOOLEAN, LARGE_INTEGER * );
	__declspec( dllimport ) PPEB PsGetProcessPeb( PEPROCESS );
	__declspec( dllimport ) NTSTATUS __stdcall ZwQuerySystemInformation( SYSTEM_INFORMATION_CLASS, void *, unsigned long, unsigned long * );
	NTKERNELAPI
		NTSTATUS
		MmCopyVirtualMemory(
			PEPROCESS SourceProcess,
			PVOID SourceAddress,
			PEPROCESS TarGet,
			PVOID TargetAddress,
			SIZE_T BufferSize,
			KPROCESSOR_MODE PreviousMode,
			PSIZE_T ReturnSize
		);
	__declspec( dllimport ) void *__stdcall RtlFindExportedRoutineByName( void *, PCCH );
}

```

`driver.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="imports.h" />
    <ClInclude Include="globals.h" />
    <ClInclude Include="defines.h">
      <Filter>library</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>library</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="library">
      <UniqueIdentifier>{356c43a3-865f-461a-8786-a87dfd44ef57}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`driver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32630.194
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "driver", "driver.vcxproj", "{3B725F50-D74E-4CE5-B3AE-3D68AAED5E83}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3B725F50-D74E-4CE5-B3AE-3D68AAED5E83}.Release|x64.ActiveCfg = Release|x64
		{3B725F50-D74E-4CE5-B3AE-3D68AAED5E83}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {09C34AA8-0325-4297-92F2-E8B274EA6213}
	EndGlobalSection
EndGlobal

```

`driver.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerCommand>
    </LocalDebuggerCommand>
    <LocalDebuggerCommandArguments>$(TargetPath)</LocalDebuggerCommandArguments>
  </PropertyGroup>
</Project>
```

`driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3B725F50-D74E-4CE5-B3AE-3D68AAED5E83}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>
    </TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>GDI_Discord</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
    <ProjectName>driver</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>NotSet</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetExt>.sys</TargetExt>
    <IncludePath>$(windowssdkdir_10)include\$(targetplatformversion)\km;$(IncludePath;$(IncludePath)</IncludePath>
    <LibraryPath>$(windowssdkdir_10)lib\$(targetplatformversion)\km\x64;$(LibraryPath)</LibraryPath>
    <IntDir>$(SolutionDir)build\pdb_dosyalar\</IntDir>
    <TargetName>dataptr_driver</TargetName>
    <OutDir>$(SolutionDir)build\</OutDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <FloatingPointModel>Fast</FloatingPointModel>
      <FloatingPointExceptions>false</FloatingPointExceptions>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <GuardEHContMetadata>false</GuardEHContMetadata>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>false</ExceptionHandling>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <WarningLevel>Level1</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
    </Link>
    <Link>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>driver_entry</EntryPointSymbol>
      <CETCompat>false</CETCompat>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
      <SubSystem>Native</SubSystem>
      <LargeAddressAware>true</LargeAddressAware>
      <AdditionalOptions>/EMITPOGOPHASEINFO %(AdditionalOptions)</AdditionalOptions>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AssemblyDebug>false</AssemblyDebug>
      <AdditionalDependencies>ntoskrnl.lib;msvcrt.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="clean.hpp" />
    <ClInclude Include="defines.h" />
    <ClInclude Include="globals.h" />
    <ClInclude Include="imports.h" />
    <ClInclude Include="mouse.hpp" />
    <ClInclude Include="struct.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp" />
    <ClCompile Include="mouse.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`driver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`entry.cpp`:

```cpp
#include "imports.h"
#include "mouse.hpp"
#include "clean.hpp"
struct _requests {
	uint32_t    src_pid;
	uint64_t    src_addr;
	uint32_t    dst_pid;
	uint64_t    dst_addr;
	size_t        size;
	size_t transfer;
	std::uintptr_t   buffer;
	uint32_t	pid;
	int request_key;
	std::uintptr_t allocation;
	int x;
	int y;
};

NTSTATUS write_process_memory(uint32_t pid, uint32_t user_pid, uintptr_t addr, uintptr_t buffer, size_t size, size_t* bytes_written)
{
	NTSTATUS status = STATUS_SUCCESS;
	PEPROCESS user_proc;
	PsLookupProcessByProcessId((HANDLE)user_pid, &user_proc);
	PEPROCESS target_proc;
	PsLookupProcessByProcessId((HANDLE)pid, &target_proc);

	size_t processed;
	status = MmCopyVirtualMemory(user_proc, (void*)buffer, target_proc, (void*)addr, size, UserMode, &processed);

	ObDereferenceObject(user_proc);
	ObDereferenceObject(target_proc);

	if (!NT_SUCCESS(status)) return status;
	if (bytes_written) *bytes_written = processed;

	if (processed != size)
		return STATUS_FAIL_CHECK;
	return STATUS_SUCCESS;
}
NTSTATUS read_process_memory(uint32_t pid, uint32_t user_pid, uintptr_t addr, uintptr_t buffer, size_t size, size_t* bytes_read)
{
	NTSTATUS status = STATUS_SUCCESS;
	PEPROCESS user_proc;
	PsLookupProcessByProcessId((HANDLE)user_pid, &user_proc);
	PEPROCESS target_proc;
	PsLookupProcessByProcessId((HANDLE)pid, &target_proc);

	size_t processed;
	status = MmCopyVirtualMemory(target_proc, (void*)addr, user_proc, (void*)buffer, size, UserMode, &processed);
	if (!NT_SUCCESS(status)) return status;
	if (bytes_read) *bytes_read = processed;

	if (processed != size)
		return STATUS_FAIL_CHECK;
	return STATUS_SUCCESS;
}
MOUSE_OBJECT mouse_obj = { 0 };

bool core_dispatcher(_requests* pstruct)
{
	if (pstruct->request_key == 31)//1337
	{
		PEPROCESS game;
		NTSTATUS status = PsLookupProcessByProcessId((HANDLE)pstruct->pid, &game);
		uint64_t deger = (uintptr_t)PsGetProcessSectionBaseAddress(game);
		pstruct->allocation = deger;
		dbg("baseaddr: %p", deger);
	}
	else if (pstruct->request_key == 32)
	{
		NTSTATUS status = read_process_memory(pstruct->pid, pstruct->dst_pid, pstruct->src_addr, pstruct->buffer, pstruct->size, &pstruct->transfer);

	}
	else if (pstruct->request_key == 33)
	{
		NTSTATUS status = write_process_memory(pstruct->pid, pstruct->dst_pid, pstruct->src_addr, pstruct->buffer, pstruct->size, &pstruct->transfer);

	}
	else if (pstruct->request_key == 1337)//31
	{
		if (!mouse_obj.service_callback || !mouse_obj.mouse_device) { mouse::init_mouse(&mouse_obj); }
		mouse::mouse_event(mouse_obj, pstruct->x, pstruct->y, 0);

	}
	
	return true;
}
void hook_fn(std::uintptr_t rcx)
{
	_requests* in = (_requests*)rcx;
	core_dispatcher(in);
}
auto clear_traces()-> bool
{
	UNICODE_STRING driver_name = RTL_CONSTANT_STRING(L"Capcom.sys");//Capcom.sys 0x57cd1415 (timeDateStamp)
	//log("Hello from Kernel Mode");
	clear::clearCache(driver_name, 0x57cd1415);
	FindMmDriverData();
	if (clear::ClearUnloadedDriver(&driver_name, true) == STATUS_SUCCESS) 
		return true;
	
	else 
		return false;
	
}
auto driver_entry() -> const NTSTATUS
{
	bool cleaning_state = clear_traces();
    std::uintptr_t win32k = utils::get_system_module(L"win32k.sys");
	globals::hook_address = win32k + 0x65A18; //0x65A08
	globals::original_hook_pointer = *reinterpret_cast<std::uintptr_t*>(globals::hook_address);
	*reinterpret_cast<std::uintptr_t*>(globals::hook_address) = reinterpret_cast<std::uintptr_t>(&hook_fn);
	return STATUS_SUCCESS;
}
```

`globals.h`:

```h
namespace globals
{
	uintptr_t ntoskrnl = 0; //
	uintptr_t win32kbase = 0; //
	uintptr_t win32kfull = 0; //
	//yukardakiler eskiden kalma quad chained yapýoydum ţimdi 1 taneye geçirdim.
	 
	std::uintptr_t original_hook_pointer = 0;
	std::uintptr_t hook_address = 0;
}
```

`imports.h`:

```h
#define _AMD64_ 1
#define _KERNEL_MODE 1
extern "C" int _fltused = 0;

#include <ntifs.h>
#include <ntddk.h>
#include <intrin.h>
#include <ntimage.h>
#include <windef.h>
#include <intrin.h>
#include <ntstrsafe.h>
#include <ntdef.h>
#include <stdint.h>
#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>
#include <type_traits>
#include "globals.h"
#include "defines.h"
#include "utils.h"
```

`mouse.cpp`:

```cpp
#include "mouse.hpp"

NTSTATUS mouse::init_mouse(PMOUSE_OBJECT mouse_obj)
{
	UNICODE_STRING class_string;
	RtlInitUnicodeString(&class_string, L"\\Driver\\MouClass");

	PDRIVER_OBJECT class_driver_object = NULL;
	NTSTATUS status = ObReferenceObjectByName(&class_string, OBJ_CASE_INSENSITIVE, NULL, 0, *IoDriverObjectType, KernelMode, NULL, (PVOID*)&class_driver_object);
	if (!NT_SUCCESS(status)) { return status; }

	UNICODE_STRING hid_string;
	RtlInitUnicodeString(&hid_string, L"\\Driver\\MouHID");

	PDRIVER_OBJECT hid_driver_object = NULL;
	status = ObReferenceObjectByName(&hid_string, OBJ_CASE_INSENSITIVE, NULL, 0, *IoDriverObjectType, KernelMode, NULL, (PVOID*)&hid_driver_object);
	if (!NT_SUCCESS(status))
	{
		if (class_driver_object) { ObDereferenceObject(class_driver_object); }
		return status;
	}

	PVOID class_driver_base = NULL;

	PDEVICE_OBJECT hid_device_object = hid_driver_object->DeviceObject;
	while (hid_device_object && !mouse_obj->service_callback)
	{
		PDEVICE_OBJECT class_device_object = class_driver_object->DeviceObject;
		while (class_device_object && !mouse_obj->service_callback)
		{
			if (!class_device_object->NextDevice && !mouse_obj->mouse_device)
			{
				mouse_obj->mouse_device = class_device_object;
			}

			PULONG_PTR device_extension = (PULONG_PTR)hid_device_object->DeviceExtension;
			ULONG_PTR device_ext_size = ((ULONG_PTR)hid_device_object->DeviceObjectExtension - (ULONG_PTR)hid_device_object->DeviceExtension) / 4;
			class_driver_base = class_driver_object->DriverStart;
			for (ULONG_PTR i = 0; i < device_ext_size; i++)
			{
				if (device_extension[i] == (ULONG_PTR)class_device_object && device_extension[i + 1] > (ULONG_PTR)class_driver_object)
				{
					mouse_obj->service_callback = (MouseClassServiceCallback)(device_extension[i + 1]);
					break;
				}
			}
			class_device_object = class_device_object->NextDevice;
		}
		hid_device_object = hid_device_object->AttachedDevice;
	}

	if (!mouse_obj->mouse_device)
	{
		PDEVICE_OBJECT target_device_object = class_driver_object->DeviceObject;
		while (target_device_object)
		{
			if (!target_device_object->NextDevice)
			{
				mouse_obj->mouse_device = target_device_object;
				break;
			}
			target_device_object = target_device_object->NextDevice;
		}
	}

	ObDereferenceObject(class_driver_object);
	ObDereferenceObject(hid_driver_object);

	DbgPrintEx(0, 0, "[norsefire]: Mouse initialized\n");

	return STATUS_SUCCESS;
}

void mouse::mouse_event(MOUSE_OBJECT mouse_obj, long x, long y, unsigned short button_flags)
{
	ULONG input_data;
	KIRQL irql;
	MOUSE_INPUT_DATA mid = { 0 };

	mid.LastX = x;
	mid.LastY = y;
	mid.ButtonFlags = button_flags;

	KeRaiseIrql(DISPATCH_LEVEL, &irql);
	mouse_obj.service_callback(mouse_obj.mouse_device, &mid, (PMOUSE_INPUT_DATA)&mid + 1, &input_data);
	KeLowerIrql(irql);
}

```

`mouse.hpp`:

```hpp
#pragma once
#include <ntifs.h>
#include <ntddmou.h>

extern "C"
NTKERNELAPI
PVOID
NTAPI
PsGetProcessWow64Process(
	_In_ PEPROCESS Process
);

//extern "C"
//NTKERNELAPI
//NTSTATUS
//NTAPI
//MmCopyVirtualMemory(
//	_In_ PEPROCESS FromProcess,
//	_In_ PVOID FromAddress,
//	_In_ PEPROCESS ToProcess,
//	_Out_ PVOID ToAddress,
//	_In_ SIZE_T BufferSize,
//	_In_ KPROCESSOR_MODE PreviousMode,
//	_Out_ PSIZE_T NumberOfBytesCopied
//);

extern "C"
NTSYSAPI
NTSTATUS
NTAPI
ObReferenceObjectByName(
	_In_ PUNICODE_STRING ObjectName,
	_In_ ULONG Attributes,
	_In_opt_ PACCESS_STATE AccessState,
	_In_opt_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_TYPE ObjectType,
	_In_ KPROCESSOR_MODE AccessMode,
	_Inout_opt_ PVOID ParseContext,
	_Out_ PVOID * Object
);
typedef struct _PEB_LDR_DATA32
{
	ULONG Length;
	UCHAR Initialized;
	ULONG SsHandle;
	LIST_ENTRY32 InLoadOrderModuleList;
	LIST_ENTRY32 InMemoryOrderModuleList;
	LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, * PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32
{
	LIST_ENTRY32 InLoadOrderLinks;
	LIST_ENTRY32 InMemoryOrderLinks;
	LIST_ENTRY32 InInitializationOrderLinks;
	ULONG DllBase;
	ULONG EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING32 FullDllName;
	UNICODE_STRING32 BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY32 HashLinks;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, * PLDR_DATA_TABLE_ENTRY32;

typedef struct _PEB32
{
	UCHAR InheritedAddressSpace;
	UCHAR ReadImageFileExecOptions;
	UCHAR BeingDebugged;
	UCHAR BitField;
	ULONG Mutant;
	ULONG ImageBaseAddress;
	ULONG Ldr;
	ULONG ProcessParameters;
	ULONG SubSystemData;
	ULONG ProcessHeap;
	ULONG FastPebLock;
	ULONG AtlThunkSListPtr;
	ULONG IFEOKey;
	ULONG CrossProcessFlags;
	ULONG UserSharedInfoPtr;
	ULONG SystemReserved;
	ULONG AtlThunkSListPtr32;
	ULONG ApiSetMap;
} PEB32, * PPEB32;
//#include "definitions.hpp"

extern "C" POBJECT_TYPE * IoDriverObjectType;

typedef VOID
(*MouseClassServiceCallback)(
	PDEVICE_OBJECT DeviceObject,
	PMOUSE_INPUT_DATA InputDataStart,
	PMOUSE_INPUT_DATA InputDataEnd,
	PULONG InputDataConsumed
	);

typedef struct _MOUSE_OBJECT
{
	PDEVICE_OBJECT mouse_device;
	MouseClassServiceCallback service_callback;
} MOUSE_OBJECT, * PMOUSE_OBJECT;

namespace mouse
{
	NTSTATUS init_mouse(PMOUSE_OBJECT mouse_obj);

	void mouse_event(MOUSE_OBJECT mouse_obj, long x, long y, unsigned short button_flags);
}
```

`struct.h`:

```h
#pragma once

```

`utils.h`:

```h
namespace utils
{

    uintptr_t get_system_module(const wchar_t* name)
    {
        NTSTATUS status = STATUS_SUCCESS;
        ANSI_STRING s_name;
        UNICODE_STRING su_name;
        RtlInitUnicodeString(&su_name, name);
        RtlUnicodeStringToAnsiString(&s_name, &su_name, TRUE);

        PRTL_PROCESS_MODULES pModules = NULL;
        uint32_t szModules = 0;

        status = ZwQuerySystemInformation(SystemModuleInformation, 0, szModules, (PULONG)&szModules);
        if (!szModules)
        {
            RtlFreeAnsiString(&s_name);
            return 0;
        }

        pModules = (PRTL_PROCESS_MODULES)ExAllocatePool(NonPagedPool, szModules);
        if (!pModules)
        {
            RtlFreeAnsiString(&s_name);
            return 0;
        }
        RtlZeroMemory(pModules, szModules);

        status = ZwQuerySystemInformation(SystemModuleInformation, pModules, szModules, (PULONG)&szModules);
        if (!NT_SUCCESS(status))
        {
            RtlFreeAnsiString(&s_name);
            ExFreePool(pModules);
            return 0;
        }

        uintptr_t modBase = 0;
        PRTL_PROCESS_MODULE_INFORMATION pMods = pModules->modules;
        for (ULONG i = 0; i < pModules->number_of_modules && !modBase; i++)
        {
            RTL_PROCESS_MODULE_INFORMATION pMod = pMods[i];
            char* fullPath = (char*)pMod.full_path_name;
            if (fullPath && strlen(fullPath) > 0)
            {
                int32_t lastFound = -1;
                char* baseFullPath = (char*)pMod.full_path_name;
                while (*fullPath != 0)
                {
                    if (*fullPath == '\\')
                        lastFound = (fullPath - baseFullPath) + 1;
                    fullPath++;
                }

                if (lastFound >= 0)
                    fullPath = baseFullPath + lastFound;
            }
            else continue;

            ANSI_STRING s_fullPath;
            RtlInitAnsiString(&s_fullPath, fullPath);
            if (RtlEqualString(&s_fullPath, &s_name, TRUE))
                modBase = (uintptr_t)pMod.image_base;
        }
        RtlFreeAnsiString(&s_name);
        ExFreePool(pModules);
        return modBase;
    }
    auto find_pattern( const uintptr_t base, const char *pattern, const char *mask, const char *section = "" ) -> const uintptr_t
    {
        const auto compare_bytes = [&]( const uintptr_t base, const size_t size, const char *pattern, const char *mask ) -> const uintptr_t
        {
            const auto check_mask = []( const char *base, const char *pattern, const char *mask ) -> bool
            {
                for ( ; *mask; ++base, ++pattern, ++mask )
                {
                    if ( *mask == 'x' && *base != *pattern )
                    {
                        return false;
                    }
                }

                return true;
            };

            const auto range = size - strlen( mask );

            for ( auto i = 0ull; i < range; ++i )
            {
                if ( check_mask( ( const char * )base + i, pattern, mask ) )
                {
                    return base + i;
                }
            }

            return 0;
        };

        const auto dos = reinterpret_cast< IMAGE_DOS_HEADER * >( base );

        const auto nt = reinterpret_cast< IMAGE_NT_HEADERS * >( base + dos->e_lfanew );

        const auto sections = IMAGE_FIRST_SECTION( nt );

        for ( size_t i = 0; i < nt->FileHeader.NumberOfSections; i++ )
        {
            const auto current_section = &sections[i];

            if ( strlen( section ) > 1 && strcmp( section, ( char * )current_section->Name ) != 0 )
            {
                continue;
            }

            if ( current_section->Characteristics & IMAGE_SCN_MEM_EXECUTE )
            {
                const auto match = compare_bytes( base + current_section->VirtualAddress, current_section->Misc.VirtualSize, pattern, mask );

                if ( match )
                {
                    return match;
                }
            }
        }

        return 0;
    }

    NTSTATUS find_module_section(std::uintptr_t imageAddress, const char* sectionName, std::uintptr_t* sectionBase, std::size_t* sectionSize) {
        if (!imageAddress || reinterpret_cast<PIMAGE_DOS_HEADER>(imageAddress)->e_magic != 0x5A4D)
            return {};

        const auto ntHeader = reinterpret_cast<PIMAGE_NT_HEADERS64>(imageAddress + reinterpret_cast<PIMAGE_DOS_HEADER>(
            imageAddress)->e_lfanew);
        auto sectionHeader = IMAGE_FIRST_SECTION(ntHeader);

        for (std::uint16_t i = 0; i < ntHeader->FileHeader.NumberOfSections; ++i, ++sectionHeader)
            if (strstr(reinterpret_cast<const char*>(&sectionHeader->Name), sectionName)) {
                *sectionBase = imageAddress + sectionHeader->VirtualAddress;
                *sectionSize = sectionHeader->Misc.VirtualSize;
                return STATUS_SUCCESS;
            }

        return STATUS_NOT_FOUND;
    }

    std::uintptr_t find_pattern_size(std::uint8_t* base, const std::size_t size, const char* pattern, const char* mask) {
        const auto patternSize = strlen(mask);

        for (std::size_t i = {}; i < size - patternSize; i++)
        {
            for (std::size_t j = {}; j < patternSize; j++)
            {
                if (mask[j] != '?' && *reinterpret_cast<std::uint8_t*>(base + i + j) != static_cast<std::uint8_t>(pattern[j]))
                    break;

                if (j == patternSize - 1)
                    return reinterpret_cast<std::uintptr_t>(base) + i;
            }
        }

        return {};
    }

    auto get_system_information( const SYSTEM_INFORMATION_CLASS information_class ) -> const void *
    {
        unsigned long size = 32;
        char buffer[32];

        ZwQuerySystemInformation( information_class, buffer, size, &size );

        const auto info = ExAllocatePoolZero( NonPagedPool, size, 'KETO' );

        if ( !info )
        {
            return nullptr;
        }

        if ( ZwQuerySystemInformation( information_class, info, size, &size ) != STATUS_SUCCESS )
        {
            ExFreePool( info );
            return nullptr;
        }

        return info;
    }   

    template <typename t1, typename t2>
    auto str_i_cmp( t1 src, t2 dst, bool two ) -> bool
    {
        if ( !src || !dst )
        {
            return false;
        }

        wchar_t c1, c2;
        do 
        {
            c1 = *src++;
            c2 = *dst++;

            c1 = to_lower_c( c1 ); 
            c2 = to_lower_c( c2 );
            
            if ( !c1 && ( two ? !c2 : 1 ) )
            {
                return true;
            }
               
        } while ( c1 == c2 );

        return false;
    }

    auto get_eprocess( const char *target_name ) -> const PEPROCESS
    {
        PEPROCESS process = 0;

        const auto info = ( SYSTEM_PROCESS_INFO * )get_system_information( SystemProcessInformation );

        if ( !info )
        {
            return 0;
        }

        auto current = info;

        while ( true )
        {
            const wchar_t *process_name = current->image_name.Buffer;

            if ( !MmIsAddressValid( ( void * )process_name ) )
            {
                goto end;
            }

            if ( !str_i_cmp( target_name, process_name, true ) )
            {
                goto end;
            }

            if ( !current->unique_process_id )
            {
                goto end;
            }

            if ( PsLookupProcessByProcessId( current->unique_process_id, &process ) != STATUS_SUCCESS )
            {
                goto end;
            }

            break;

        end:
            if ( !current->next_entry_offset )
            {
                break;
            }

            current = reinterpret_cast< SYSTEM_PROCESS_INFO * > ( ( reinterpret_cast< uintptr_t > ( current ) + current->next_entry_offset ) );
        }

        ExFreePoolWithTag( info, 'KETO' );

        return process;
    }

    auto get_process_id( const char *target_name ) -> const int
    {
        int pid = 0;

        const auto info = ( SYSTEM_PROCESS_INFO * )get_system_information( SystemProcessInformation );

        if ( !info )
        {
            return 0;
        }

        auto current = info;

        while ( true )
        {
            const wchar_t *process_name = current->image_name.Buffer;

            if ( !MmIsAddressValid( ( void * )process_name ) )
            {
                goto end;
            }

            if ( !str_i_cmp( target_name, process_name, true ) )
            {
                goto end;
            }

            if ( !current->unique_process_id )
            {
                goto end;
            }

            pid = reinterpret_cast<int> ( current->unique_process_id );

            break;

        end:
            if ( !current->next_entry_offset )
            {
                break;
            }

            current = reinterpret_cast< SYSTEM_PROCESS_INFO * > ( ( reinterpret_cast< uintptr_t > ( current ) + current->next_entry_offset ) );
        }

        ExFreePoolWithTag( info, 'KETO' );

        return pid;
    }

    auto get_kernel_module( const char *name ) -> const uintptr_t
    {
        const auto to_lower = []( char *string ) -> const char *{
            for ( char *pointer = string; *pointer != '\0'; ++pointer )
            {
                *pointer = ( char )( short )tolower( *pointer );
            }

            return string;
        };

        const auto info = ( PRTL_PROCESS_MODULES )get_system_information( SystemModuleInformation );

        if ( !info )
        {
            return 0;
        }

        for ( auto i = 0ull; i < info->number_of_modules; ++i )
        {
            const auto &module = info->modules[i];

            if ( strcmp( to_lower( ( char * )module.full_path_name + module.offset_to_file_name ), name ) == 0 )
            {
                const auto address = module.image_base;

                ExFreePool( info );

                return reinterpret_cast< uintptr_t > ( address );
            }
        }

        ExFreePool( info );

        return 0;
    }

    std::uintptr_t find_guarded_region()
    {
        PSYSTEM_BIGPOOL_INFORMATION pool_information = 0;

        ULONG information_length = 0;
        NTSTATUS status = ZwQuerySystemInformation(SystemBigPoolInformation, &information_length, 0, &information_length);

        while (status == STATUS_INFO_LENGTH_MISMATCH)
        {
            if (pool_information)
                ExFreePool(pool_information);

            pool_information = (PSYSTEM_BIGPOOL_INFORMATION)ExAllocatePool(NonPagedPool, information_length);
            status = ZwQuerySystemInformation(SystemBigPoolInformation, pool_information, information_length, &information_length);
        }

        if (pool_information)
        {
            for (int i = 0; i < pool_information->Count; i++)
            {
                SYSTEM_BIGPOOL_ENTRY* allocation_entry = &pool_information->AllocatedInfo[i];
                std::uintptr_t virtual_address = (uintptr_t)allocation_entry->VirtualAddress & ~1ull;

                if (allocation_entry->NonPaged && allocation_entry->SizeInBytes == 0x200000)
                {
                    ExFreePool(pool_information);

                    return virtual_address;
                }
            }
        }

        return 0;
    }

    void free_user_memory(void* Ptr) 
    {
        SIZE_T SizeUL = 0;
        ZwFreeVirtualMemory(ZwCurrentProcess(), &Ptr, &SizeUL, MEM_RELEASE);
    }

    void* allocate_user_memory(ULONG Size, ULONG Protect = PAGE_READWRITE) 
    {
        PVOID AllocBase = nullptr; SIZE_T SizeUL = size_align(Size);

        if (!ZwAllocateVirtualMemory(ZwCurrentProcess(), &AllocBase, 0, &SizeUL, MEM_COMMIT, Protect)) 
        {
            RtlZeroMemory(AllocBase, SizeUL);
        }

        return AllocBase;
    }

    void get_module_export( const uintptr_t base, const char *name, std::uintptr_t* function_pointer )
    {
        *function_pointer = reinterpret_cast<std::uintptr_t>(RtlFindExportedRoutineByName( reinterpret_cast< void * >( base ), name ) );
    }

    auto attach_process( const int pid ) -> const PEPROCESS
    {
        if ( !pid )
        {
            return 0;
        }

        PEPROCESS process = 0;
        if ( PsLookupProcessByProcessId( reinterpret_cast< HANDLE >( pid ), &process ) != STATUS_SUCCESS )
        {
            return 0;
        }

        KeAttachProcess( process );

        return process;
    }

    auto detach_process( const PEPROCESS& process ) -> bool
    {
        if ( !process )
        {
            return false;
        }

        KeDetachProcess( );
        
        ObfDereferenceObject( process );

        return true;
    }

    std::uintptr_t find_process_module(size_t ProcessId, const wchar_t* wModuleName)
    {
        PEPROCESS process = NULL;
        PVOID baseAddress = NULL;

        NTSTATUS status = PsLookupProcessByProcessId((HANDLE)ProcessId, &process);

        if (NT_SUCCESS(status))
        {
            KeAttachProcess(process);

            UNICODE_STRING moduleName{};
            RtlInitUnicodeString(&moduleName, wModuleName);

            PLIST_ENTRY list = &(PsGetProcessPeb(process)->ldr->in_load_order_module_list);

            for (PLIST_ENTRY entry = list->Flink; entry != list; )
            {
                PLDR_DATA_TABLE_ENTRY mod = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, in_load_order_links);

                if (RtlCompareUnicodeString(&mod->base_dll_name, &moduleName, TRUE) == 0)
                {
                    baseAddress = mod->dll_base;
                }

                entry = mod->in_load_order_links.Flink;
            }

            KeDetachProcess();

            ObDereferenceObject(process);
        }

        return (UINT64)baseAddress;
    }

    auto sleep( long long ms ) -> void
    {
        LARGE_INTEGER delay;
        delay.QuadPart = -ms * 10000;
        KeDelayExecutionThread( KernelMode, false, &delay );
    }

    auto get_random_address( ) -> const uintptr_t
    {
        LARGE_INTEGER tick;
        KeQueryTickCount( &tick );

        if ( globals::win32kbase > globals::ntoskrnl )
        {
            return ( RtlRandomEx( &tick.LowPart ) % globals::ntoskrnl + globals::win32kbase );
        }

        return ( RtlRandomEx( &tick.LowPart ) % globals::win32kbase + globals::ntoskrnl );
    }
#define WINDOWS_1803 17134
#define WINDOWS_1809 17763
#define WINDOWS_1903 18362
#define WINDOWS_1909 18363
#define WINDOWS_2004 19041
#define WINDOWS_20H2 19569
#define WINDOWS_21H1 20180

    DWORD GetUserDirectoryTableBaseOffset()
    {
        RTL_OSVERSIONINFOW ver = { 0 };
        RtlGetVersion(&ver);

        switch (ver.dwBuildNumber)
        {
        case WINDOWS_1803:
            return 0x0278;
            break;
        case WINDOWS_1809:
            return 0x0278;
            break;
        case WINDOWS_1903:
            return 0x0280;
            break;
        case WINDOWS_1909:
            return 0x0280;
            break;
        case WINDOWS_2004:
            return 0x0388;
            break;
        case WINDOWS_20H2:
            return 0x0388;
            break;
        case WINDOWS_21H1:
            return 0x0388;
            break;
        default:
            return 0x0388;
        }
    }
    //bundan sonrası frostieste ait.
    //check normal dirbase if 0 then get from UserDirectoryTableBas
    ULONG_PTR GetProcessCr3(PEPROCESS pProcess)
    {
        PUCHAR process = (PUCHAR)pProcess;
        ULONG_PTR process_dirbase = *(PULONG_PTR)(process + 0x28); //dirbase x64, 32bit is 0x18
        if (process_dirbase == 0)
        {
            DWORD UserDirOffset = GetUserDirectoryTableBaseOffset();
            ULONG_PTR process_userdirbase = *(PULONG_PTR)(process + UserDirOffset);
            return process_userdirbase;
        }
        return process_dirbase;
    }

    ULONG_PTR GetKernelDirBase()
    {
        PUCHAR process = (PUCHAR)PsGetCurrentProcess();
        ULONG_PTR cr3 = *(PULONG_PTR)(process + 0x28); //dirbase x64, 32bit is 0x18
        return cr3;
    }

    NTSTATUS ReadPhysicalAddress(PVOID TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesRead)
    {
        MM_COPY_ADDRESS AddrToRead = { 0 };
        AddrToRead.PhysicalAddress.QuadPart = (LONGLONG)TargetAddress;
        return MmCopyMemory(lpBuffer, AddrToRead, Size, MM_COPY_MEMORY_PHYSICAL, BytesRead);
    }

    //MmMapIoSpaceEx limit is page 4096 byte
    NTSTATUS WritePhysicalAddress(PVOID TargetAddress, PVOID lpBuffer, SIZE_T Size, SIZE_T* BytesWritten)
    {
        if (!TargetAddress)
            return STATUS_UNSUCCESSFUL;

        PHYSICAL_ADDRESS AddrToWrite = { 0 };
        AddrToWrite.QuadPart = (LONGLONG)TargetAddress;

        PVOID pmapped_mem = MmMapIoSpaceEx(AddrToWrite, Size, PAGE_READWRITE);

        if (!pmapped_mem)
            return STATUS_UNSUCCESSFUL;

        memcpy(pmapped_mem, lpBuffer, Size);

        *BytesWritten = Size;
        MmUnmapIoSpace(pmapped_mem, Size);
        return STATUS_SUCCESS;
    }

#define PAGE_OFFSET_SIZE 12
    static const uint64_t PMASK = (~0xfull << 8) & 0xfffffffffull;

    uint64_t TranslateLinearAddress(uint64_t directoryTableBase, uint64_t virtualAddress) {
        directoryTableBase &= ~0xf;

        uint64_t pageOffset = virtualAddress & ~(~0ul << PAGE_OFFSET_SIZE);
        uint64_t pte = ((virtualAddress >> 12) & (0x1ffll));
        uint64_t pt = ((virtualAddress >> 21) & (0x1ffll));
        uint64_t pd = ((virtualAddress >> 30) & (0x1ffll));
        uint64_t pdp = ((virtualAddress >> 39) & (0x1ffll));

        SIZE_T readsize = 0;
        uint64_t pdpe = 0;
        ReadPhysicalAddress((void*)(directoryTableBase + 8 * pdp), &pdpe, sizeof(pdpe), &readsize);
        if (~pdpe & 1)
            return 0;

        uint64_t pde = 0;
        ReadPhysicalAddress((void*)((pdpe & PMASK) + 8 * pd), &pde, sizeof(pde), &readsize);
        if (~pde & 1)
            return 0;

        /* 1GB large page, use pde's 12-34 bits */
        if (pde & 0x80)
            return (pde & (~0ull << 42 >> 12)) + (virtualAddress & ~(~0ull << 30));

        uint64_t pteAddr = 0;
        ReadPhysicalAddress((void*)((pde & PMASK) + 8 * pt), &pteAddr, sizeof(pteAddr), &readsize);
        if (~pteAddr & 1)
            return 0;

        /* 2MB large page */
        if (pteAddr & 0x80)
            return (pteAddr & PMASK) + (virtualAddress & ~(~0ull << 21));

        virtualAddress = 0;
        ReadPhysicalAddress((void*)((pteAddr & PMASK) + 8 * pte), &virtualAddress, sizeof(virtualAddress), &readsize);
        virtualAddress &= PMASK;

        if (!virtualAddress)
            return 0;

        return virtualAddress + pageOffset;
    }
    NTSTATUS ReadVirtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* read)
    {
        uint64_t paddress = TranslateLinearAddress(dirbase, address);
        return ReadPhysicalAddress((void*)paddress, buffer, size, read);
    }

    NTSTATUS WriteVirtual(uint64_t dirbase, uint64_t address, uint8_t* buffer, SIZE_T size, SIZE_T* written)
    {
        uint64_t paddress = TranslateLinearAddress(dirbase, address);
        return WritePhysicalAddress((void*)paddress, buffer, size, written);
    }

    //
    NTSTATUS ReadProcessMemory(int pid, PVOID Address, PVOID AllocatedBuffer, SIZE_T size, SIZE_T* read)
    {
        PEPROCESS pProcess = NULL;
        if (pid == 0) return STATUS_UNSUCCESSFUL;

        NTSTATUS NtRet = PsLookupProcessByProcessId((HANDLE)pid, &pProcess);
        if (NtRet != STATUS_SUCCESS) return NtRet;

        ULONG_PTR process_dirbase = GetProcessCr3(pProcess);
        ObDereferenceObject(pProcess);

        SIZE_T CurOffset = 0;
        SIZE_T TotalSize = size;
        while (TotalSize)
        {

            uint64_t CurPhysAddr = TranslateLinearAddress(process_dirbase, (ULONG64)Address + CurOffset);
            if (!CurPhysAddr) return STATUS_UNSUCCESSFUL;

            ULONG64 ReadSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);
            SIZE_T BytesRead = 0;
            NtRet = ReadPhysicalAddress((void*)CurPhysAddr, (PVOID)((ULONG64)AllocatedBuffer + CurOffset), ReadSize, &BytesRead);
            TotalSize -= BytesRead;
            CurOffset += BytesRead;
            if (NtRet != STATUS_SUCCESS) break;
            if (BytesRead == 0) break;
        }

        *read = CurOffset;
        return NtRet;
    }

    NTSTATUS WriteProcessMemory(int pid, PVOID Address, PVOID AllocatedBuffer, SIZE_T size, SIZE_T* written)
    {
        PEPROCESS pProcess = NULL;
        if (pid == 0) return STATUS_UNSUCCESSFUL;

        NTSTATUS NtRet = PsLookupProcessByProcessId((HANDLE)pid, &pProcess);
        if (NtRet != STATUS_SUCCESS) return NtRet;

        ULONG_PTR process_dirbase = GetProcessCr3(pProcess);
        ObDereferenceObject(pProcess);

        SIZE_T CurOffset = 0;
        SIZE_T TotalSize = size;
        while (TotalSize)
        {
            uint64_t CurPhysAddr = TranslateLinearAddress(process_dirbase, (ULONG64)Address + CurOffset);
            if (!CurPhysAddr) return STATUS_UNSUCCESSFUL;

            ULONG64 WriteSize = min(PAGE_SIZE - (CurPhysAddr & 0xFFF), TotalSize);
            SIZE_T BytesWritten = 0;
            NtRet = WritePhysicalAddress((void*)CurPhysAddr, (PVOID)((ULONG64)AllocatedBuffer + CurOffset), WriteSize, &BytesWritten);
            TotalSize -= BytesWritten;
            CurOffset += BytesWritten;
            if (NtRet != STATUS_SUCCESS) break;
            if (BytesWritten == 0) break;
        }

        *written = CurOffset;
        return NtRet;
    }
}
```