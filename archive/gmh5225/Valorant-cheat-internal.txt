Project Path: arc_gmh5225_Valorant-cheat-internal_iwl0c54k

Source Tree:

```txt
arc_gmh5225_Valorant-cheat-internal_iwl0c54k
├── Alignments.h
├── Canvas.h
├── DLLMain.cpp
├── DaddyKermitsInternal.sln
├── DaddyKermitsInternal.vcxproj
├── DaddyKermitsInternal.vcxproj.filters
├── DaddyKermitsInternal.vcxproj.user
├── Decryptor.h
├── Entry.cpp
├── FNamePool.h
├── LICENSE
├── README.md
├── Unreal.h
├── decryption.h
├── discord-rpc.lib
├── discord_rpc.h
├── hook.h
├── internal.sln
├── internal.vcxproj
├── internal.vcxproj.filters
├── internal.vcxproj.user
├── memory.h
├── offsets.h
├── sdk.h
├── unrealengine.h
├── valorant.h
└── x64
    └── Release
        ├── DaddyKermitsInternal.dll.recipe
        ├── DaddyKermitsInternal.exp
        ├── DaddyKermitsInternal.iobj
        ├── DaddyKermitsInternal.ipdb
        ├── DaddyKermitsInternal.lib
        ├── DaddyKermitsInternal.log
        ├── DaddyKermitsInternal.pdb
        ├── DaddyKermitsInternal.vcxproj.FileListAbsolute.txt
        ├── Entry.obj
        ├── FNamePool.obj
        ├── Valorant.tlog
        │   ├── CL.command.1.tlog
        │   ├── CL.read.1.tlog
        │   ├── CL.write.1.tlog
        │   ├── Valorant.lastbuildstate
        │   ├── link.command.1.tlog
        │   ├── link.read.1.tlog
        │   ├── link.write.1.tlog
        │   └── link.write.2u.tlog
        ├── _IsIncrementalBuild
        └── vc143.pdb

```

`Alignments.h`:

```h
#pragma once

template <typename T>
FORCEINLINE constexpr T Align(T Val, uint64 Alignment)
{
	return (T)(((uint64)Val + Alignment - 1) & ~(Alignment - 1));
}
```

`Canvas.h`:

```h
#pragma once
#include "memory.h"
#include "unrealengine.h"
class UObject
{
public:
	char padding_01[0x18];
	int32_t ComparisonIndex;
	static UObject* StaticFindObject(UObject* Class, UObject* InOuter, const wchar_t* Name, bool ExactClass)
	{
		static uintptr_t StaticFindObjectAddress = VALORANT::Module + Offsets::StaticFindObject;

		auto StaticFindObjectFN = reinterpret_cast<UObject * (__fastcall*)(UObject*, UObject*, const wchar_t*, bool)>(StaticFindObjectAddress);

		return StaticFindObjectFN(Class, InOuter, Name, ExactClass);
	}
	static void ProcessEvent(void* class_, UObject* function, void* params)
	{
		reinterpret_cast<void (*)(void*, UObject*, void*)>(VALORANT::Module + Offsets::ProcessEvent)(class_, function, params);
	}
};

struct UWorld
{

};

struct UFont : UObject
{

};

UObject* DefaultMediumFont;
struct UEngine
{

};
bool bOutline = 1;
bool vischeck = 0;
bool InGame = 0;
struct UCanvas
{
	void K2_DrawLine(struct FVector2D ScreenPositionA, struct FVector2D ScreenPositionB, float Thickness, struct FLinearColor RenderColor)
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Canvas.K2_DrawLine", false);


		struct {
			FVector2D ScreenPositionA;
			FVector2D ScreenPositionB;
			float Thickness;
			FLinearColor RenderColor;
		}Args;
		Args.ScreenPositionA = ScreenPositionA;
		Args.ScreenPositionB = ScreenPositionB;
		Args.Thickness = Thickness;
		Args.RenderColor = RenderColor; 
		function->ProcessEvent(this, function, &Args);
	}
	void K2_DrawLinex(FVector2D ScreenPositionA, FVector2D ScreenPositionB, float Thickness, FLinearColor RenderColor) // CRT af doe (ironic.)
	{
		if(bOutline)
		{
			K2_DrawLine({ ScreenPositionA.X + 1, ScreenPositionA.Y }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
			K2_DrawLine({ ScreenPositionA.X - 1, ScreenPositionA.Y }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
			K2_DrawLine({ ScreenPositionA.X, ScreenPositionA.Y + 1 }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
			K2_DrawLine({ ScreenPositionA.X, ScreenPositionA.Y - 1 }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
		}
		K2_DrawLine({ ScreenPositionA.X, ScreenPositionA.Y }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, RenderColor);
	}
	void K2_DrawText(struct FString RenderText, struct FVector2D ScreenPosition, struct FVector2D Scale, struct FLinearColor RenderColor, float Kerning, struct FLinearColor ShadowColor, struct FVector2D ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, struct FLinearColor OutlineColor)
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Canvas.K2_DrawText", false);
		if(!DefaultMediumFont) 
			DefaultMediumFont = UObject::StaticFindObject(nullptr, nullptr, L"/Engine/EngineFonts/Roboto.Roboto", false);
		struct {
			UObject* RenderFont;
			FString RenderText;
			FVector2D ScreenPosition;
			FVector2D Scale;
			FLinearColor RenderColor;
			float Kerning;
			FLinearColor ShadowColor;
			FVector2D ShadowOffset;
			bool bCentreX;
			bool bCentreY;
			bool bOutlined;
			FLinearColor OutlineColor;
		}Args;
		Args.RenderFont = DefaultMediumFont;
		Args.RenderText = RenderText;
		Args.ScreenPosition = ScreenPosition;
		Args.Scale = Scale;
		Args.RenderColor = RenderColor;
		Args.Kerning = Kerning;
		Args.ShadowColor = ShadowColor;
		Args.ShadowOffset = ShadowOffset;
		Args.bCentreX = bCentreX;
		Args.bCentreY = bCentreY;
		Args.bOutlined = bOutlined;
		Args.OutlineColor = OutlineColor; 
		function->ProcessEvent(this, function, &Args);
	}
};

struct UGameInstance
{

};

struct ULocalPlayer
{

};

struct FBoxSphereBounds {
	FVector Origin;
	FVector BoxExtent;
	float SphereRadius;
};

struct FBox {
	FVector Min;
	FVector Max;

	FBox() {

		Min.X = NULL;
		Min.Y = NULL;
		Min.Z = NULL;
		
		Max.X = NULL;
		Max.Y = NULL;
		Max.Z = NULL;
	}
};

struct UStaticMeshComponent
{
	FBox GetBoundingBox()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.StaticMesh.GetBoundingBox", false);
		if (!Function)
		{
			return FBox();
		}
		struct
		{
			FBox ReturnValue;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.ReturnValue;
	}
};

struct USkeletalMeshComponent
{

	void SetAresOutlineMode(EAresOutlineMode Mode, bool bPropagateToChildren)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.MeshComponent.SetAresOutlineMode", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			EAresOutlineMode Mode;
			bool bPropagateToChildren;
		}Parameters;
		Parameters.Mode = Mode;
		Parameters.bPropagateToChildren = bPropagateToChildren;
		Function->ProcessEvent(this, Function, &Parameters);
	}
};

DWORD64 ProjectWorldToScreen;

struct APlayerState
{
	FString GetPlayerName()
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.PlayerState.GetPlayerName", false);
		if (!function)
			return L"AAresPlayerCharacter_PC_C";

		struct {
			FString Return;
		}Args;
		function->ProcessEvent(this, function, &Args);
		return Args.Return;
	}
};


struct FQuat
{
public:

	float X, Y, Z, W;

	FQuat() : X(0.f), Y(0.f), Z(0.f), W(0.f) {};

	FQuat(float InX, float InY, float InZ, float InW) : X(InX), Y(InY), Z(InZ), W(InW) {}

	FQuat(struct FRotator& R);

	FVector RotateVector(const struct FVector& V) const;
};
struct FRotator
{
	float Pitch, Yaw, Roll;

	FRotator()
		: Pitch(0), Yaw(0), Roll(0)
	{ }

	FRotator(float pitch, float yaw, float roll) : Pitch(pitch), Yaw(yaw), Roll(roll) {}

	FRotator operator+ (const FRotator& other) const { return FRotator(Pitch + other.Pitch, Yaw + other.Yaw, Roll + other.Roll); }

	FRotator operator- (const FRotator& other) const { return FRotator(Pitch - other.Pitch, Yaw - other.Yaw, Roll - other.Roll); }

	FRotator operator* (float scalar) const { return FRotator(Pitch * scalar, Yaw * scalar, Roll * scalar); }

	FRotator& operator=  (const FRotator& other) { Pitch = other.Pitch; Yaw = other.Yaw; Roll = other.Roll; return *this; }

	FRotator& operator+= (const FRotator& other) { Pitch += other.Pitch; Yaw += other.Yaw; Roll += other.Roll; return *this; }

	FRotator& operator-= (const FRotator& other) { Pitch -= other.Pitch; Yaw -= other.Yaw; Roll -= other.Roll; return *this; }

	FRotator& operator*= (const float other) { Yaw *= other; Pitch *= other; Roll *= other; return *this; }

	struct FQuat Quaternion() const;
};

constexpr auto PI = 3.1415926535897932f;
constexpr auto FLOAT_NON_FRACTIONAL = 8388608.f /* All single-precision floating point numbers greater than or equal to this have no fractional value. */;
constexpr auto INV_PI = 0.31830988618f;
constexpr auto HALF_PI = 1.57079632679f;
constexpr auto DEG_TO_RAD = PI / 180.f;
constexpr auto RADS_DIVIDED_BY_2 = DEG_TO_RAD / 2.f;

namespace classes {
	namespace defines {
		static UObject* system = nullptr;
		static UObject* game_statics = nullptr;
		static UObject* blueprint = nullptr;
		static UObject* content_library = nullptr;
	}

	static inline void init() {
		defines::system = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Default__KismetSystemLibrary", false);
		defines::game_statics = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Default__GameplayStatics", false);
		defines::blueprint = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ShooterBlueprintLibrary", false);
		defines::content_library = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ContentLibrary", false);
	}
}

namespace kismentsystemlibrary
{
	UObject* static_class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"Engine.Default__KismetSystemLibrary", false);
	}

	FString get_object_name(UObject* obj)
	{
		UObject* functions = UObject::StaticFindObject(nullptr, nullptr, L"Engine.KismetSystemLibrary.GetObjectName", false);
		if (!functions)
			return L"N/A";
		struct
		{
			UObject* obj;
			FString out;
		}Args;
		Args.obj = obj;
		functions->ProcessEvent(static_class(), functions, &Args);
		return Args.out;
	}
}
struct FMath {
	static __forceinline void SinCos(float* ScalarSin, float* ScalarCos, float  Value);
	static __forceinline float Fmod(float X, float Y);
	template<class T>
	static __forceinline T Clamp(const T X, const T Min, const T Max) { return X < Min ? Min : X < Max ? X : Max; }
};

struct FTransform
{
	FQuat Rotation;
	FVector Translation;
	char UnknownData00[0x4];
	FVector Scale3D;
	char UnknownData01[0x4];

	/** Default constructor. */
	FTransform() : Rotation(0.f, 0.f, 0.f, 1.f), Translation(0.f), Scale3D(FVector::OneVector) {};
	 
	FVector TransformPosition(FVector& V) const;

	FTransform(const FRotator& InRotation) : Rotation(InRotation.Quaternion()), Translation(FVector::ZeroVector), Scale3D(FVector::OneVector) {};
};


struct AAresEquippable : UObject
{

};

struct UAresInventory : UObject
{
	AAresEquippable* GetCurrentWeapon()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresInventory.GetCurrentEquippable", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			AAresEquippable* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};

struct AShooterCharacter : UObject
{
	UAresInventory* GetInventory()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetInventory", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			UAresInventory* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	void ClientFly()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.ClientFly", false);
		if (!Function)
		{
			return;
		}
		struct
		{
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	void Set3pMeshVisible(bool val)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.Set3PMeshVisible", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			bool a1;
		}Parameters;
		Parameters.a1 = val;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	APlayerState* GetPlayerState()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetPlayerState", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			APlayerState* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}

	int32_t GetMaxHealth()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetMaxHealth", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			int32_t Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}


	float GetMaxShield()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetMaxShield", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			float Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	float GetHealth()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetHealth", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			float Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	float GetShield()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetShield", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			float Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	FVector K2_GetActorLocation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Actor.K2_GetActorLocation", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			FVector Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	FRotator K2_GetActorRotation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Actor.K2_GetActorRotation", false);
		if (!Function)
		{
			return {0,0,0};
		}
		struct
		{
			FRotator Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	USkeletalMeshComponent* GetPawnMesh()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetPawnMesh", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			USkeletalMeshComponent* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}

	APlayerState* GetState()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetPlayerState", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			APlayerState* KekState;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.KekState;
	}
	bool IsAlive()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.IsAlive", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			bool Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};

struct APlayerCameraManager
{
	FVector GetCameraLocation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.PlayerCameraManager.GetCameraLocation", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			FVector Out;
		}Parameters; 
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};
struct APlayerController : UObject
{
	bool LineOfSightTo(AShooterCharacter* Actor, FVector ViewPoint, bool bAlternateChecks)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Controller.LineOfSightTo", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			AShooterCharacter* Actor;
			FVector ViewPoint;
			bool bAlternateChecks;
			bool Out;
		}Parameters;
		Parameters.Actor = Actor;
		Parameters.ViewPoint = ViewPoint;
		Parameters.bAlternateChecks = bAlternateChecks;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}

	FVector GetControlRotation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Controller.GetControlRotation", false);
		if (!Function)
		{
			return {0,0,0};
		}
		struct
		{
			FVector Rot;
		}Parameters; 
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Rot;
	}
	void SetControlRotation(FVector NewRot)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Controller.SetControlRotation", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			FVector Rot;
		}Parameters;
		Parameters.Rot = NewRot;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	bool ProjectWorldLocationToScreen(struct FVector WorldLocation, struct FVector2D& ScreenLocation, bool bPlayerViewportRelative)
	{  
		if (!ProjectWorldToScreen)
			ProjectWorldToScreen = (uintptr_t)GetModuleHandleA(0) + 0x4DC02D0;
		auto WorldToScreen = reinterpret_cast<bool(__fastcall*)(uintptr_t pPlayerController, FVector vWorldPos, FVector2D * vScreenPosOut, char)>(ProjectWorldToScreen);

		WorldToScreen((uintptr_t)this, WorldLocation, &ScreenLocation, (char)0);
		 
		return WorldToScreen;
	}
	void set_fov(float fov)
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresPlayerController.SetFOV", false);


		struct {
			float fov;
		}Args;
		Args.fov = fov;
		function->ProcessEvent(this, function, &Args);
	}

	AShooterCharacter* GetShooterCharacter()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresPlayerController.GetShooterCharacter", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			AShooterCharacter* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};

struct AController
{
};
namespace ShooterGameBlueprints
{
	UObject* Static_Class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ShooterBlueprintLibrary", false);
	}

	APlayerController* GetFirstLocalPlayerController(UWorld* WorldContextObject)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterBlueprintLibrary.GetFirstLocalPlayerController", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			UWorld* WorldContextObject;
			APlayerController* Out;
		}Parameters;
		Parameters.WorldContextObject = WorldContextObject;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return Parameters.Out;
	}
	TArray<AShooterCharacter*> FindAllShooterCharactersWithAlliance(UWorld* WorldContextObject, AShooterCharacter* LocalViewer, EAresAlliance Alliance, bool OnlyPlayerControlled, bool OnlyAlivePlayers)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterBlueprintLibrary.FindAllShooterCharactersWithAlliance", false);
		struct
		{
			UWorld* WorldContextObject;
			AShooterCharacter* LocalViewer;
			EAresAlliance Alliance;
			bool OnlyPlayerControlled;
			bool OnlyAlivePlayers;
			TArray<AShooterCharacter*> Out;
		}Parameters;
		Parameters.WorldContextObject = WorldContextObject;
		Parameters.LocalViewer = LocalViewer;
		Parameters.Alliance = Alliance;
		Parameters.OnlyPlayerControlled = OnlyPlayerControlled;
		Parameters.OnlyAlivePlayers = OnlyAlivePlayers;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return Parameters.Out;
	}
}

namespace AresOutlineRendering
{
	UObject* Static_Class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"Renderer.Default__AresOutlineRendering", false);
	}

	void SetOutlineColorsForRender(UWorld* WorldContextObject, FLinearColor AllyColor, FLinearColor EnemyColor)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Renderer.AresOutlineRendering.SetOutlineColorsForRender", false);
		if (!Function)
		{
			return;
		}
		struct {
			UWorld* WorldContextObject;
			FLinearColor AllyColor;
			FLinearColor EnemyColor;
		}Parameters;
		Parameters.WorldContextObject = WorldContextObject;
		Parameters.AllyColor = AllyColor;
		Parameters.EnemyColor = EnemyColor;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
	}
}

namespace BaseTeamComponent
{
	UObject* Static_Class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__BaseTeamComponent", false);
	}

	bool IsAlly(AShooterCharacter* Enemy, AShooterCharacter* Self)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.BaseTeamComponent.IsAlly", false);
		struct {
			AShooterCharacter* Enemy;
			AShooterCharacter* Self;
			bool ReturnValue;
		}Parameters;
		Parameters.Enemy = Enemy;
		Parameters.Self = Self;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return Parameters.ReturnValue;
	}
}
#pragma once
#include <Windows.h>

namespace CWINGui
{
	namespace Input
	{
		bool mouseDown[5];
		bool mouseDownAlready[256];

		bool keysDown[256];
		bool keysDownAlready[256];

		bool IsAnyMouseDown()
		{
			if (mouseDown[0]) return true;
			if (mouseDown[1]) return true;
			if (mouseDown[2]) return true;
			if (mouseDown[3]) return true;
			if (mouseDown[4]) return true;

			return false;
		}

		bool IsMouseClicked(int button, int element_id, bool repeat)
		{
			if (mouseDown[button])
			{
				if (!mouseDownAlready[element_id])
				{
					mouseDownAlready[element_id] = true;
					return true;
				}
				if (repeat)
					return true;
			}
			else
			{
				mouseDownAlready[element_id] = false;
			}
			return false;
		}
		bool IsKeyPressed(int key, bool repeat)
		{
			if (keysDown[key])
			{
				if (!keysDownAlready[key])
				{
					keysDownAlready[key] = true;
					return true;
				}
				if (repeat)
					return true;
			}
			else
			{
				keysDownAlready[key] = false;
			}
			return false;
		}

		void Handle()
		{
			if (GetAsyncKeyState(0x01))
				mouseDown[0] = true;
			else
				mouseDown[0] = false;
		}
	}
}

wchar_t* s2wc(const char* c)
{
	const size_t cSize = strlen(c) + 1;
	wchar_t* wc = new wchar_t[cSize];
	mbstowcs(wc, c, cSize);

	return wc;
}

namespace CWINGui
{
	FLinearColor RGBtoFLC69(float R, float G, float B, float A = 255)
	{
		return { R / 255, G / 255, B / 255, A / 255 };
	}
	namespace Colors
	{
		FLinearColor Text{ 1.0f, 1.0f, 1.0f, 1.0f };
		FLinearColor Text_Shadow{ 0.0f, 0.0f, 0.0f, 0.0f };
		FLinearColor Text_Outline{ 0.0f, 0.0f, 0.0f, 0.30f };

		FLinearColor Window_Background{ 0.009f, 0.009f, 0.009f, 1.0f };
		FLinearColor Window_Header{ 0.10f, 0.15f, 0.84f, 1.0f };

		FLinearColor Button_Idle{ 0.10f, 0.15f, 0.84f, 1.0f };
		FLinearColor Button_Hovered{ 0.15f, 0.20f, 0.89f, 1.0f };
		FLinearColor Button_Active{ 0.20f, 0.25f, 0.94f, 1.0f };

		FLinearColor Checkbox_Idle{ 0.17f, 0.16f, 0.23f, 1.0f };
		FLinearColor Checkbox_Hovered{ 0.22f, 0.30f, 0.72f, 1.0f };
		FLinearColor Checkbox_Enabled{ 0.20f, 0.25f, 0.94f, 1.0f };

		FLinearColor Combobox_Idle{ 0.17f, 0.16f, 0.23f, 1.0f };
		FLinearColor Combobox_Hovered{ 0.17f, 0.16f, 0.23f, 1.0f };
		FLinearColor Combobox_Elements{ 0.239f, 0.42f, 0.82f, 1.0f };

		FLinearColor Slider_Idle{ 0.17f, 0.16f, 0.23f, 1.0f };
		FLinearColor Slider_Hovered{ 0.17f, 0.16f, 0.23f, 1.0f };
		FLinearColor Slider_Progress{ 0.22f, 0.30f, 0.72f, 1.0f };
		FLinearColor Slider_Button{ 0.10f, 0.15f, 0.84f, 1.0f };

		FLinearColor ColorPicker_Background{ 0.006f, 0.006f, 0.006f, 1.0f };
	}

	namespace PostRenderer
	{
		struct DrawList
		{
			int type = -1; //1 = FilledRect, 2 = TextLeft, 3 = TextCenter, 4 = Draw_Line
			FVector2D pos;
			FVector2D size;
			FLinearColor color;
			const wchar_t* name;
			bool outline;

			FVector2D from;
			FVector2D to;
			int thickness;
		};
		DrawList drawlist[128];

		void drawFilledRect(FVector2D pos, float w, float h, FLinearColor color)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 1;
					drawlist[i].pos = pos;
					drawlist[i].size = FVector2D{ w, h };
					drawlist[i].color = color;
					return;
				}
			}
		}
		void TextLeft(const wchar_t* name, FVector2D pos, FLinearColor color, bool outline)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 2;
					drawlist[i].name = name;
					drawlist[i].pos = pos;
					drawlist[i].outline = outline;
					drawlist[i].color = color;
					return;
				}
			}
		}
		void TextCenter(const wchar_t* name, FVector2D pos, FLinearColor color, bool outline)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 3;
					drawlist[i].name = name;
					drawlist[i].pos = pos;
					drawlist[i].outline = outline;
					drawlist[i].color = color;
					return;
				}
			}
		}
		void Draw_Line(FVector2D from, FVector2D to, int thickness, FLinearColor color)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 4;
					drawlist[i].from = from;
					drawlist[i].to = to;
					drawlist[i].thickness = thickness;
					drawlist[i].color = color;
					return;
				}
			}
		}
	}

	UCanvas* canvas;


	bool hover_element = false;
	FVector2D menu_pos = FVector2D{ 0, 0 };
	float offset_x = 0.0f;
	float offset_y = 0.0f;

	FVector2D first_element_pos = FVector2D{ 0, 0 };

	FVector2D last_element_pos = FVector2D{ 0, 0 };
	FVector2D last_element_size = FVector2D{ 0, 0 };

	int current_element = -1;
	FVector2D current_element_pos = FVector2D{ 0, 0 };
	FVector2D current_element_size = FVector2D{ 0, 0 };
	int elements_count = 0;

	bool sameLine = false;

	bool pushY = false;
	float pushYvalue = 0.0f;

	void SetupCanvas(UCanvas* _canvas)
	{
		canvas = _canvas;
	}

	FVector2D CursorPos()
	{
		POINT cursorPos;
		GetCursorPos(&cursorPos);
		return FVector2D{ (float)cursorPos.x, (float)cursorPos.y };
	}
	bool MouseInZone(FVector2D pos, FVector2D size)
	{
		FVector2D cursor_pos = CursorPos();

		if (cursor_pos.X > pos.X && cursor_pos.Y > pos.Y)
			if (cursor_pos.X < pos.X + size.X && cursor_pos.Y < pos.Y + size.Y)
				return true;

		return false;
	}

	void Draw_Cursor(bool toogle)
	{
		if (toogle)
		{
			FVector2D cursorPos = CursorPos();
			canvas->K2_DrawLine(FVector2D{ cursorPos.X, cursorPos.Y }, FVector2D{ cursorPos.X + 35, cursorPos.Y + 10 }, 1, FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });


			int x = 35;
			int y = 10;
			while (y != 30) //20 steps
			{
				x -= 1; if (x < 15) x = 15;
				y += 1; if (y > 30) y = 30;

				canvas->K2_DrawLine(FVector2D{ cursorPos.X, cursorPos.Y }, FVector2D{ cursorPos.X + x, cursorPos.Y + y }, 1, FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
			}

			canvas->K2_DrawLine(FVector2D{ cursorPos.X, cursorPos.Y }, FVector2D{ cursorPos.X + 15, cursorPos.Y + 30 }, 1, FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
			canvas->K2_DrawLine(FVector2D{ cursorPos.X + 35, cursorPos.Y + 10 }, FVector2D{ cursorPos.X + 15, cursorPos.Y + 30 }, 1, FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
		}
	}

	void SameLine()
	{
		sameLine = true;
	}
	void PushNextElementY(float y, bool from_last_element = true)
	{
		pushY = true;
		if (from_last_element)
			pushYvalue = last_element_pos.Y + last_element_size.Y + y;
		else
			pushYvalue = y;
	}
	void NextColumn(float x)
	{
		offset_x = x;
		PushNextElementY(first_element_pos.Y, false);
	}
	void ClearFirstPos()
	{
		first_element_pos = FVector2D{ 0, 0 };
	}

	void xDrawTextRGB(const wchar_t* text, float x, float y, FLinearColor color)
	{
		canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, { 1.f,1.f,1.f,1.0f }, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, 0, 0, 0, { 0, 0, 0, 1 });
	}
	void yDrawTextRGB(const wchar_t* text, float x, float y, FLinearColor color)
	{
		canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, { 1.f,1.f,1.f,1.0f }, 0.f, {0, 0, 0, 1}, {0, 0}, 1, 0, 0, {0, 0, 0, 1});
	}
	void TextLeft(const wchar_t* name, FVector2D pos, FLinearColor color, bool outline)
	{ 
		xDrawTextRGB(name, pos.X, pos.Y, {1,1,1,1});
	}
	void TextCenter(const wchar_t* name, FVector2D pos, FLinearColor color, bool outline, bool kekw = 0)
	{
		if(kekw)
			yDrawTextRGB(name, pos.X, pos.Y - 10, color);
		else
			yDrawTextRGB(name, pos.X, pos.Y - 10, {1.f,1.f,1.f,1.0f});
	}

	void GetColor(FLinearColor* color, float* r, float* g, float* b, float* a)
	{
		*r = color->R;
		*g = color->G;
		*b = color->B;
		*a = color->A;
	}
	UINT32 GetColorUINT(int r, int g, int b, int a)
	{
		UINT32 result = (BYTE(a) << 24) + (BYTE(r) << 16) + (BYTE(g) << 8) + BYTE(b);
		return result;
	}

	void Draw_Line(FVector2D from, FVector2D to, int thickness, FLinearColor color)
	{
		canvas->K2_DrawLine(FVector2D{ from.X, from.Y }, FVector2D{ to.X, to.Y }, thickness, color);
	}
	void drawFilledRect(FVector2D initial_pos, float w, float h, FLinearColor color)
	{
		for (float i = 0.0f; i < h; i += 1.0f)
			canvas->K2_DrawLine(FVector2D{ initial_pos.X, initial_pos.Y + i }, FVector2D{ initial_pos.X + w, initial_pos.Y + i }, 1.0f, color);
	}
	void DrawFilledCircle(FVector2D pos, float r, FLinearColor color)
	{
		float smooth = 0.07f;

		double PI = 3.14159265359;
		int size = (int)(2.0f * PI / smooth) + 1;

		float angle = 0.0f;
		int i = 0;

		for (; angle < 2 * PI; angle += smooth, i++)
		{
			Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ pos.X + cosf(angle) * r, pos.Y + sinf(angle) * r }, 1.0f, color);
		}
	}
	void DrawCircle(FVector2D pos, int radius, int numSides, FLinearColor Color)
	{
		float PI = 3.1415927f;

		float Step = PI * 2.0 / numSides;
		int Count = 0;
		FVector2D V[128];
		for (float a = 0; a < PI * 2.0; a += Step) {
			float X1 = radius * cos(a) + pos.X;
			float Y1 = radius * sin(a) + pos.Y;
			float X2 = radius * cos(a + Step) + pos.X;
			float Y2 = radius * sin(a + Step) + pos.Y;
			V[Count].X = X1;
			V[Count].Y = Y1;
			V[Count + 1].X = X2;
			V[Count + 1].Y = Y2;
			//Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ X2, Y2 }, 1.0f, Color); // Points from Centre to ends of circle
			Draw_Line(FVector2D{ V[Count].X, V[Count].Y }, FVector2D{ X2, Y2 }, 1.0f, Color);// Circle Around
		}
	}

	FVector2D dragPos;
	bool Window(const char* name, FVector2D* pos, FVector2D size, bool isOpen)
	{
		elements_count = 0;

		if (!isOpen)
			return false;

		bool isHovered = MouseInZone(FVector2D{ pos->X, pos->Y }, size);

		//Drop last element
		if (current_element != -1 && !GetAsyncKeyState(0x1))
		{
			current_element = -1;
		}

		//Drag
		if (hover_element && GetAsyncKeyState(0x1))
		{

		}
		else if ((isHovered || dragPos.X != 0) && !hover_element)
		{
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				FVector2D cursorPos = CursorPos();

				cursorPos.X -= size.X;
				cursorPos.Y -= size.Y;

				if (dragPos.X == 0)
				{
					dragPos.X = (cursorPos.X - pos->X);
					dragPos.Y = (cursorPos.Y - pos->Y);
				}
				pos->X = cursorPos.X - dragPos.X;
				pos->Y = cursorPos.Y - dragPos.Y;
			}
			else
			{
				dragPos = FVector2D{ 0, 0 };
			}
		}
		else
		{
			hover_element = false;
		}


		offset_x = 0.0f; offset_y = 0.0f;
		menu_pos = FVector2D{ pos->X, pos->Y };
		first_element_pos = FVector2D{ 0, 0 };
		current_element_pos = FVector2D{ 0, 0 };
		current_element_size = FVector2D{ 0, 0 };
		
		//Bg
		drawFilledRect(FVector2D{ pos->X, pos->Y }, size.X, size.Y, Colors::Window_Background);
		//drawFilledRect(FVector2D{ pos->X, pos->Y }, 122, size.Y, FLinearColor{ 0.006f, 0.006f, 0.006f, 1.0f });//My tabs bg

		//Header
		drawFilledRect(FVector2D{ pos->X, pos->Y }, size.X, 25.0f, Colors::Window_Header);

		offset_y += 25.0f;

		//Title
		FVector2D titlePos = FVector2D{ pos->X + size.X / 2, pos->Y + 25 / 2 };
		TextCenter(s2wc(name), titlePos, FLinearColor{1.0f, 1.0f, 1.0f, 1.0f}, false);


		return true;
	}

	void Text(const wchar_t* text, bool center = false, bool outline = false)
	{
		elements_count++;

		float size = 25;
		FVector2D padding = FVector2D{ 10, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}

		if (!sameLine)
			offset_y += size + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + 5.0f, pos.Y};
		if (center)
			TextCenter(text, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);
		else
			TextLeft(text, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);

		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}
	bool ButtonTab(const wchar_t* name, FVector2D size, bool active)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 5, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X ;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (active)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Active);
		}
		else if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
		TextCenter(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			return true;

		return false;
	}
	bool Button(const wchar_t* name, FVector2D size)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 5, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
		//if (!TextOverlapedFromActiveElement(textPos))
		TextCenter(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			return true;

		return false;
	}
	void Checkbox(const wchar_t* name, bool* value)
	{
		elements_count++;

		float size = 18;
		FVector2D padding = FVector2D{ 10, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, FVector2D{ size, size });

		//Bg
		if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Idle);
		}

		if (!sameLine)
			offset_y += size + padding.Y;

		if (*value)
		{
			drawFilledRect(FVector2D{ pos.X + 3, pos.Y + 3 }, size - 6, size - 6, Colors::Checkbox_Enabled);
			//drawFilledRect(FVector2D{ pos.X + 9, pos.Y + 9 }, size - 18, size - 18, Colors::Checkbox_Hovered);
		}



		//Text
		FVector2D textPos = FVector2D{ pos.X + size + 5.0f, pos.Y};
		//if (!TextOverlapedFromActiveElement(textPos))
		TextLeft(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			*value = !*value;
	}
	void SliderInt(char* name, int* value, int min, int max)
	{
		elements_count++;

		FVector2D size = FVector2D{ 240, 50 };
		FVector2D slider_size = FVector2D{ 200, 10 };
		FVector2D padding = FVector2D{ 10, 15 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size);

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Bg
		if (isHovered || current_element == elements_count)
		{
			//Drag
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				current_element = elements_count;

				FVector2D cursorPos = CursorPos();
				*value = ((cursorPos.X - pos.X) * ((max - min) / slider_size.X)) + min;
				if (*value < min) *value = min;
				if (*value > max) *value = max;
			}

			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Hovered);
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress);

			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Idle);
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress);
		}


		//Value
		float oneP = slider_size.X / (max - min);
		drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, oneP * (*value - min), slider_size.Y, Colors::Slider_Progress);
		//drawFilledRect(FVector2D{ pos.X + oneP * (*value - min) - 10.0f, pos.Y + slider_size.Y - 5.0f + padding.Y }, 20.0f, 20.0f, Colors::Slider_Button);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 3.3f + padding.Y }, 10.0f, Colors::Slider_Button);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 3.3f + padding.Y }, 5.0f, Colors::Slider_Progress);
		 

		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}
	void SliderFloat(const wchar_t* name, float* value, float min, float max, const char* format = "%.0f")
	{
		elements_count++;

		FVector2D size = FVector2D{ 210, 40 };
		FVector2D slider_size = FVector2D{ 170, 7 };
		FVector2D adjust_zone = FVector2D{ 0, 20 };
		FVector2D padding = FVector2D{ 10, 15 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y - adjust_zone.Y }, FVector2D{ slider_size.X, slider_size.Y + adjust_zone.Y * 1.5f });

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Bg
		if (isHovered || current_element == elements_count)
		{
			//Drag
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				current_element = elements_count;

				FVector2D cursorPos = CursorPos();
				*value = ((cursorPos.X - pos.X) * ((max - min) / slider_size.X)) + min;
				if (*value < min) *value = min;
				if (*value > max) *value = max;
			}

			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Hovered);
			DrawFilledCircle(FVector2D{ pos.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Progress);
			DrawFilledCircle(FVector2D{ pos.X + slider_size.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Hovered);

			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Idle);
			DrawFilledCircle(FVector2D{ pos.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Progress);
			DrawFilledCircle(FVector2D{ pos.X + slider_size.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Idle);
		}


		//Text
		FVector2D textPos = FVector2D{ pos.X, pos.Y + 5 };
		TextLeft(name, textPos, Colors::Text, false);

		//Value
		float oneP = slider_size.X / (max - min);
		drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, oneP * (*value - min), slider_size.Y, Colors::Slider_Progress);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 2.66f + padding.Y }, 8.0f, Colors::Slider_Button);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 2.66f + padding.Y }, 4.0f, Colors::Slider_Progress);

		char buffer[32];
		sprintf_s(buffer, format, *value);
		FVector2D valuePos = FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 20 + padding.Y };
		TextCenter(s2wc(buffer), valuePos, Colors::Text, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}



	bool checkbox_enabled[256];
	void Combobox(const wchar_t* name, FVector2D size, int* value, const wchar_t* arg, ...)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 5, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (isHovered || checkbox_enabled[elements_count])
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Combobox_Hovered);

			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Combobox_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + size.X + 5.0f, pos.Y + size.Y / 2 };
		TextLeft((name), textPos, FLinearColor{1.0f, 1.0f, 1.0f, 1.0f}, false);

		//Elements
		bool isHovered2 = false;
		FVector2D element_pos = pos;
		int num = 0;

		if (checkbox_enabled[elements_count])
		{
			current_element_size.X = element_pos.X - 5.0f;
			current_element_size.Y = element_pos.Y - 5.0f;
		}
		va_list arguments;
		for (va_start(arguments, arg); arg != NULL; arg = va_arg(arguments, const wchar_t*))
		{
			//Selected Element
			if (num == *value)
			{
				FVector2D _textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
				TextCenter(arg, _textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
			}

			if (checkbox_enabled[elements_count])
			{
				element_pos.Y += 25.0f;

				isHovered2 = MouseInZone(FVector2D{ element_pos.X, element_pos.Y }, FVector2D{ size.X, 25.0f });
				if (isHovered2)
				{
					hover_element = true;
					PostRenderer::drawFilledRect(FVector2D{ element_pos.X, element_pos.Y }, size.X, 25.0f, Colors::Combobox_Hovered);

					//Click
					if (Input::IsMouseClicked(0, elements_count, false))
					{
						*value = num;
						checkbox_enabled[elements_count] = false;
					}
				}
				else
				{
					PostRenderer::drawFilledRect(FVector2D{ element_pos.X, element_pos.Y }, size.X, 25.0f, Colors::Combobox_Idle);
				}

				PostRenderer::TextLeft(arg, FVector2D{ element_pos.X + 5.0f, element_pos.Y + 15.0f }, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
			}
			num++;
		}
		va_end(arguments);
		if (checkbox_enabled[elements_count])
		{
			current_element_size.X = element_pos.X + 5.0f;
			current_element_size.Y = element_pos.Y + 5.0f;
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
		{
			checkbox_enabled[elements_count] = !checkbox_enabled[elements_count];
		}
		if (!isHovered && !isHovered2 && Input::IsMouseClicked(0, elements_count, false))
		{
			checkbox_enabled[elements_count] = false;
		}
	}

	int active_hotkey = -1;
	bool already_pressed = false;
	std::string VirtualKeyCodeToString(UCHAR virtualKey)
	{
		UINT scanCode = MapVirtualKey(virtualKey, MAPVK_VK_TO_VSC);

		if (virtualKey == VK_LBUTTON)
		{
			return ("MOUSE0");
		}
		if (virtualKey == VK_RBUTTON)
		{
			return ("MOUSE1");
		}
		if (virtualKey == VK_MBUTTON)
		{
			return ("MBUTTON");
		}
		if (virtualKey == VK_XBUTTON1)
		{
			return ("XBUTTON1");
		}
		if (virtualKey == VK_XBUTTON2)
		{
			return ("XBUTTON2");
		}

		CHAR szName[128];
		int result = 0;
		switch (virtualKey)
		{
		case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN:
		case VK_RCONTROL: case VK_RMENU:
		case VK_LWIN: case VK_RWIN: case VK_APPS:
		case VK_PRIOR: case VK_NEXT:
		case VK_END: case VK_HOME:
		case VK_INSERT: case VK_DELETE:
		case VK_DIVIDE:
		case VK_NUMLOCK:
			scanCode |= KF_EXTENDED;
		default:
			result = GetKeyNameTextA(scanCode << 16, szName, 128);
		}

		return szName;
	}
	void Hotkey(const char* name, FVector2D size, int* key)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 5, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y + (last_element_size.Y / 2) - size.Y / 2;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		if (active_hotkey == elements_count)
		{
			//Text
			FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
			TextCenter(L"[Press Key]", textPos, FLinearColor{1.0f, 1.0f, 1.0f, 1.0f}, false);

			if (!CWINGui::Input::IsAnyMouseDown())
			{
				already_pressed = false;
			}

			if (!already_pressed)
			{
				for (int code = 0; code < 255; code++)
				{
					if (GetAsyncKeyState(code))
					{
						*key = code;
						active_hotkey = -1;
					}
				}
			}
		}
		else
		{
			//Text
			FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
			TextCenter(s2wc(VirtualKeyCodeToString(*key).c_str()), textPos, FLinearColor{1.0f, 1.0f, 1.0f, 1.0f}, false);

			if (isHovered)
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					already_pressed = true;
					active_hotkey = elements_count;

					//Queue Fix
					for (int code = 0; code < 255; code++)
						if (GetAsyncKeyState(code)) {}
				}
			}
			else
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					active_hotkey = -1;
				}
			}
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}

	int active_picker = -1;
	FLinearColor saved_color;
	bool ColorPixel(FVector2D pos, FVector2D size, FLinearColor* original, FLinearColor color)
	{
		PostRenderer::drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, color);

		//Выбранный цвет
		if (original->R == color.R && original->G == color.G && original->B == color.B)
		{
			PostRenderer::Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ pos.X + size.X - 1, pos.Y }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(FVector2D{ pos.X, pos.Y + size.Y - 1 }, FVector2D{ pos.X + size.X - 1, pos.Y + size.Y - 1 }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ pos.X, pos.Y + size.Y - 1 }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(FVector2D{ pos.X + size.X - 1, pos.Y }, FVector2D{ pos.X + size.X - 1, pos.Y + size.Y - 1 }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
		}

		//Смена цвета
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);
		if (isHovered)
		{
			if (Input::IsMouseClicked(0, elements_count, false))
				*original = color;
		}

		return true;
	}
	void ColorPicker(const wchar_t* name, FLinearColor* color)
	{
		elements_count++;

		float size = 25;
		FVector2D padding = FVector2D{ 10, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, FVector2D{ size, size });

		if (!sameLine)
			offset_y += size + padding.Y;

		if (active_picker == elements_count)
		{
			hover_element = true;

			float sizePickerX = 250;
			float sizePickerY = 250;
			bool isHoveredPicker = MouseInZone(FVector2D{ pos.X, pos.Y }, FVector2D{ sizePickerX, sizePickerY - 60 });

			//Background
			PostRenderer::drawFilledRect(FVector2D{ pos.X, pos.Y }, sizePickerX, sizePickerY - 65, Colors::ColorPicker_Background);

			//float pixedSize = sizePickerY / pixels;
			//FLinearColor temp_color{1.0f, 1.0f, 1.0f, 1.0f};
			//float iterator = 0.0f;
			//
			//for (int y = 0; y < pixels; y++)
			//{
			//	for (int x = 0; x < pixels; x++)
			//	{
			//		ColorPixel(FVector2D{ pos.X + pixedSize * x, pos.Y + pixedSize * y }, pixedSize, color, temp_color);
			//		temp_color.R -= (1.0f - saved_color.R) / pixels;
			//		temp_color.G -= (1.0f - saved_color.G) / pixels;
			//		temp_color.B -= (1.0f - saved_color.B) / pixels;
			//	}
			//	
			//	iterator += 1.0f / pixels;
			//	temp_color = FLinearColor{ 1.0f - iterator, 1.0f - iterator, 1.0f - iterator, 1.0f };
			//}

			FVector2D pixelSize = FVector2D{ sizePickerX / 12, sizePickerY / 12 };

			//0
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 174 / 255.f, 235 / 255.f, 253 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 136 / 255.f, 225 / 255.f, 251 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 108 / 255.f, 213 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 89 / 255.f, 175 / 255.f, 213 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 76 / 255.f, 151 / 255.f, 177 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 60 / 255.f, 118 / 255.f, 140 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 43 / 255.f, 85 / 255.f, 100 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 32 / 255.f, 62 / 255.f, 74 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 255 / 255.f, 255 / 255.f, 255 / 255.f, 1.0f });
			}
			//1
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 175 / 255.f, 205 / 255.f, 252 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 132 / 255.f, 179 / 255.f, 252 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 90 / 255.f, 152 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 55 / 255.f, 120 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 49 / 255.f, 105 / 255.f, 209 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 38 / 255.f, 83 / 255.f, 165 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 28 / 255.f, 61 / 255.f, 120 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 20 / 255.f, 43 / 255.f, 86 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 247 / 255.f, 247 / 255.f, 247 / 255.f, 1.0f });
			}
			//2
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 153 / 255.f, 139 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 101 / 255.f, 79 / 255.f, 249 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 64 / 255.f, 50 / 255.f, 230 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 54 / 255.f, 38 / 255.f, 175 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 39 / 255.f, 31 / 255.f, 144 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 32 / 255.f, 25 / 255.f, 116 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 21 / 255.f, 18 / 255.f, 82 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 16 / 255.f, 13 / 255.f, 61 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 228 / 255.f, 228 / 255.f, 228 / 255.f, 1.0f });
			}
			//3
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 194 / 255.f, 144 / 255.f, 251 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 165 / 255.f, 87 / 255.f, 249 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 142 / 255.f, 57 / 255.f, 239 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 116 / 255.f, 45 / 255.f, 184 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 92 / 255.f, 37 / 255.f, 154 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 73 / 255.f, 29 / 255.f, 121 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 53 / 255.f, 21 / 255.f, 88 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 37 / 255.f, 15 / 255.f, 63 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 203 / 255.f, 203 / 255.f, 203 / 255.f, 1.0f });
			}
			//4
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 224 / 255.f, 162 / 255.f, 197 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 210 / 255.f, 112 / 255.f, 166 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 199 / 255.f, 62 / 255.f, 135 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 159 / 255.f, 49 / 255.f, 105 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 132 / 255.f, 41 / 255.f, 89 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 104 / 255.f, 32 / 255.f, 71 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 75 / 255.f, 24 / 255.f, 51 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 54 / 255.f, 14 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 175 / 255.f, 175 / 255.f, 175 / 255.f, 1.0f });
			}
			//5
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 235 / 255.f, 175 / 255.f, 176 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 227 / 255.f, 133 / 255.f, 135 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 219 / 255.f, 87 / 255.f, 88 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 215 / 255.f, 50 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 187 / 255.f, 25 / 255.f, 7 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 149 / 255.f, 20 / 255.f, 6 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 107 / 255.f, 14 / 255.f, 4 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 77 / 255.f, 9 / 255.f, 3 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 144 / 255.f, 144 / 255.f, 144 / 255.f, 1.0f });
			}
			//6
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 241 / 255.f, 187 / 255.f, 171 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 234 / 255.f, 151 / 255.f, 126 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 229 / 255.f, 115 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 227 / 255.f, 82 / 255.f, 24 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 190 / 255.f, 61 / 255.f, 15 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 150 / 255.f, 48 / 255.f, 12 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 107 / 255.f, 34 / 255.f, 8 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 79 / 255.f, 25 / 255.f, 6 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 113 / 255.f, 113 / 255.f, 113 / 255.f, 1.0f });
			}
			//7
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 245 / 255.f, 207 / 255.f, 169 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 240 / 255.f, 183 / 255.f, 122 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 236 / 255.f, 159 / 255.f, 74 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 234 / 255.f, 146 / 255.f, 37 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 193 / 255.f, 111 / 255.f, 28 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 152 / 255.f, 89 / 255.f, 22 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 110 / 255.f, 64 / 255.f, 16 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 80 / 255.f, 47 / 255.f, 12 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 82 / 255.f, 82 / 255.f, 82 / 255.f, 1.0f });
			}
			//8
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 247 / 255.f, 218 / 255.f, 170 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 244 / 255.f, 200 / 255.f, 124 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 241 / 255.f, 182 / 255.f, 77 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 239 / 255.f, 174 / 255.f, 44 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 196 / 255.f, 137 / 255.f, 34 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 154 / 255.f, 108 / 255.f, 27 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 111 / 255.f, 77 / 255.f, 19 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 80 / 255.f, 56 / 255.f, 14 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 54 / 255.f, 54 / 255.f, 54 / 255.f, 1.0f });
			}
			//9
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 254 / 255.f, 243 / 255.f, 187 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 253 / 255.f, 237 / 255.f, 153 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 253 / 255.f, 231 / 255.f, 117 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 254 / 255.f, 232 / 255.f, 85 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 242 / 255.f, 212 / 255.f, 53 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 192 / 255.f, 169 / 255.f, 42 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 138 / 255.f, 120 / 255.f, 30 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 101 / 255.f, 87 / 255.f, 22 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 29 / 255.f, 29 / 255.f, 29 / 255.f, 1.0f });
			}
			//10
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 247 / 255.f, 243 / 255.f, 185 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 243 / 255.f, 239 / 255.f, 148 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 239 / 255.f, 232 / 255.f, 111 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 235 / 255.f, 229 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 208 / 255.f, 200 / 255.f, 55 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 164 / 255.f, 157 / 255.f, 43 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 118 / 255.f, 114 / 255.f, 31 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 86 / 255.f, 82 / 255.f, 21 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 9 / 255.f, 9 / 255.f, 9 / 255.f, 1.0f });
			}
			//11
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 218 / 255.f, 232 / 255.f, 182 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 198 / 255.f, 221 / 255.f, 143 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 181 / 255.f, 210 / 255.f, 103 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 154 / 255.f, 186 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 130 / 255.f, 155 / 255.f, 64 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 102 / 255.f, 121 / 255.f, 50 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 74 / 255.f, 88 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 54 / 255.f, 64 / 255.f, 26 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 0 / 255.f, 0 / 255.f, 0 / 255.f, 1.0f });
			}



			if (isHoveredPicker)
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{

				}
			}
			else
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					active_picker = -1;
					//hover_element = false;
				}
			}
		}
		else
		{
			//Bg
			if (isHovered)
			{
				drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Hovered);
				hover_element = true;
			}
			else
			{
				drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Idle);
			}

			//Color
			drawFilledRect(FVector2D{ pos.X + 4, pos.Y + 4 }, size - 8, size - 8, *color);

			//Text
			FVector2D textPos = FVector2D{ pos.X + size + 5.0f, pos.Y - 5 };
			TextLeft(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			{
				saved_color = *color;
				active_picker = elements_count;
			}
		}


		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}


	void Render()
	{
		for (int i = 0; i < 128; i++)
		{
			if (PostRenderer::drawlist[i].type != -1)
			{
				//Filled Rect
				if (PostRenderer::drawlist[i].type == 1)
				{
					CWINGui::drawFilledRect(PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].size.X, PostRenderer::drawlist[i].size.Y, PostRenderer::drawlist[i].color);
				}
				//TextLeft
				else if (PostRenderer::drawlist[i].type == 2)
				{
					CWINGui::TextLeft((const wchar_t*)PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
				}
				//TextCenter
				else if (PostRenderer::drawlist[i].type == 3)
				{
					CWINGui::TextCenter((const wchar_t*)PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
				}
				//Draw_Line
				else if (PostRenderer::drawlist[i].type == 4)
				{
					Draw_Line(PostRenderer::drawlist[i].from, PostRenderer::drawlist[i].to, PostRenderer::drawlist[i].thickness, PostRenderer::drawlist[i].color);
				}

				PostRenderer::drawlist[i].type = -1;
			}
		}
	}
}
```

`DLLMain.cpp`:

```cpp
#include <Windows.h>
#include <cstdio>
#include "sdk.h"
#include "decryption.h"
#include "hook.h"
#include "Decryptor.h"
using PostRenderHook = void(*)(uintptr_t _this, UCanvas* canvas);
PostRenderHook pRender = 0;

uintptr_t UWorldXOR;
UWorld* UWorldClass;
UGameInstance* GameInstance;
ULocalPlayer* LocalPlayers;
ULocalPlayer* LocalPlayer;

void DrawTextRGB(UCanvas* canvas, const wchar_t* text, float x, float y, FLinearColor color, bool CenterX = 0)
{
	canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, color, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, CenterX, 0, bOutline, { 0, 0, 0, 1 });
}
void DrawTextRGBWithFString(UCanvas* canvas, FString text, float x, float y, FLinearColor color, bool CenterX = 0)
{
	canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, color, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, CenterX, 0, bOutline, { 0, 0, 0, 1 });
}

void xxDrawTextRGB(UCanvas* canvas, FString text, float x, float y, FLinearColor color)
{
	canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, color, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, 0, 0, false, { 0, 0, 0, 1 });
}
FLinearColor RGBtoFLC(float R, float G, float B)
{
	return { R / 255, G / 255, B / 255, 1 };
}

bool kekIsOff = 0; // debugging purposes ONLY solely for THAT
bool chams = 0;

static FLinearColor test_color{ 2.093f, 0.019f, 20.0f, 5.9f };
static FLinearColor MainESPColor{ 2.093f, 0.019f, 20.0f, 5.9f };
static FLinearColor behind_wall_color = RGBtoFLC(255, 255, 255);
static FLinearColor visible_color = RGBtoFLC(0, 255, 0);
static FLinearColor circlecol = RGBtoFLC(0, 255, 0);
static bool menu_opened = false;
FVector2D pos = { 100,100 };

static bool ChamsESP = false;
static bool brightchammy = false;
static bool box2d = false;
static bool PlayerNames = false;
static bool chammyteam = false;
static bool fovchanger = false;
static bool thirdperson = false;
static bool flyhack = false;
static bool healthcol = false;
static bool enableaim = false;
static bool memory = false;
static bool silent = false;
static bool drawfov = false;
int KEKWNOKEY;
static float radius = 100.0f;
static float fovchangur = 80.0f;

float ESPThickness = 1.0f;
float Lineamount = 500.0f;


void DrawBox(UCanvas* can, FVector2D& topleft, FVector2D& downright, FLinearColor clr)
{
	auto h = downright.Y - topleft.Y;
	auto w = downright.X - topleft.X;

	auto downleft = FVector2D{ topleft.X, downright.Y };
	auto topright = FVector2D{ downright.X, topleft.Y };

	auto thicc = ESPThickness;

	FLinearColor xclr = RGBtoFLC(0, 0, 0);

	can->K2_DrawLinex(topleft, { topleft.X, topleft.Y + h * 1 }, thicc, clr);
	can->K2_DrawLinex(topleft, { topleft.X + w * 1, topleft.Y }, thicc, clr);

	can->K2_DrawLinex(downright, { downright.X, downright.Y - h * 1 }, thicc, clr);
	can->K2_DrawLinex(downright, { downright.X - w * 1, downright.Y }, thicc, clr);

	can->K2_DrawLinex(downleft, { downleft.X, downleft.Y - h * 1 }, thicc, clr);
	can->K2_DrawLinex(downleft, { downleft.X + w * 1, downright.Y }, thicc, clr);

	can->K2_DrawLinex(topright, { topright.X, topright.Y + h * 1 }, thicc, clr);
	can->K2_DrawLinex(topright, { topright.X - w * 1, topright.Y }, thicc, clr);

	/*
	* OLD (remove 3 first line integrity)
	can->K2_DrawLine({topleft.X, topleft.Y + 100}, {topleft.X, topleft.Y + h * 1}, thicc, clr);
	can->K2_DrawLine({ topleft.X, topleft.Y + 100 }, { topleft.X + w * 1, topleft.Y }, thicc, clr);

	can->K2_DrawLine({ downright.X, downright.Y - 100 }, { downright.X, downright.Y - h * 1 }, thicc, clr);
	can->K2_DrawLine(downright, { downright.X - w * 1, downright.Y }, thicc, clr);

	can->K2_DrawLine(downleft, { downleft.X, downleft.Y - h * 1 }, thicc, clr);
	can->K2_DrawLine(downleft, { downleft.X + w * 1, downright.Y }, thicc, clr);

	can->K2_DrawLine(topright, { topright.X, topright.Y + h * 1 }, thicc, clr);
	can->K2_DrawLine(topright, { topright.X - w * 1, topright.Y }, thicc, clr);*/
}
uintptr_t OffsetGetActorBounds;
void GetActorBounds(AShooterCharacter* Actor, bool bOnlyCollidingComponents, FVector* Origin, FVector* BoxExtent, bool bIncludeFromChildActors)
{
	reinterpret_cast<void(*)(AShooterCharacter*, bool, FVector * pos, FVector * screen, bool)> ((uintptr_t)GetModuleHandleA(0) + 0x498aaa0)(Actor, 0, Origin, BoxExtent, 0);
}
static FVector2D scr[8];

void FMath::SinCos(float* ScalarSin, float* ScalarCos, float Value)
{
	// Map Value to y in [-pi,pi], x = 2*pi*quotient + remainder.
	float quotient = (INV_PI * 0.5f) * Value;
	if (Value >= 0.0f)
	{
		quotient = (float)((int)(quotient + 0.5f));
	}
	else
	{
		quotient = (float)((int)(quotient - 0.5f));
	}
	float y = Value - (2.0f * PI) * quotient;

	// Map y to [-pi/2,pi/2] with sin(y) = sin(Value).
	float sign;
	if (y > HALF_PI)
	{
		y = PI - y;
		sign = -1.0f;
	}
	else if (y < -HALF_PI)
	{
		y = -PI - y;
		sign = -1.0f;
	}
	else
	{
		sign = +1.0f;
	}

	float y2 = y * y;

	// 11-degree minimax approximation
	*ScalarSin = (((((-2.3889859e-08f * y2 + 2.7525562e-06f) * y2 - 0.00019840874f) * y2 + 0.0083333310f) * y2 - 0.16666667f) * y2 + 1.0f) * y;

	// 10-degree minimax approximation
	float p = ((((-2.6051615e-07f * y2 + 2.4760495e-05f) * y2 - 0.0013888378f) * y2 + 0.041666638f) * y2 - 0.5f) * y2 + 1.0f;
	*ScalarCos = sign * p;
}

float FMath::Fmod(float X, float Y)
{
	const float AbsY = fabsf(Y);
	if (AbsY <= 1.e-8f) { return 0.f; }
	const float Div = (X / Y);
	// All floats where abs(f) >= 2^23 (8388608) are whole numbers so do not need truncation, and avoid overflow in TruncToFloat as they get even larger.
	const float Quotient = fabsf(Div) < FLOAT_NON_FRACTIONAL ? truncf(Div) : Div;
	float IntPortion = Y * Quotient;

	// Rounding and imprecision could cause IntPortion to exceed X and cause the result to be outside the expected range.
	// For example Fmod(55.8, 9.3) would result in a very small negative value!
	if (fabsf(IntPortion) > fabsf(X)) { IntPortion = X; }

	const float Result = X - IntPortion;
	// Clamp to [-AbsY, AbsY] because of possible failures for very large numbers (>1e10) due to precision loss.
	// We could instead fall back to stock fmodf() for large values, however this would diverge from the SIMD VectorMod() which has no similar fallback with reasonable performance.
	return FMath::Clamp(Result, -AbsY, AbsY);
}
FQuat FRotator::Quaternion() const
{
	float SP, SY, SR;
	float CP, CY, CR;
	const float PitchNoWinding = FMath::Fmod(Pitch, 360.0f);
	const float YawNoWinding = FMath::Fmod(Yaw, 360.0f);
	const float RollNoWinding = FMath::Fmod(Roll, 360.0f);
	FMath::SinCos(&SP, &CP, PitchNoWinding * RADS_DIVIDED_BY_2);
	FMath::SinCos(&SY, &CY, YawNoWinding * RADS_DIVIDED_BY_2);
	FMath::SinCos(&SR, &CR, RollNoWinding * RADS_DIVIDED_BY_2);
	FQuat RotationQuat;
	RotationQuat.X = CR * SP * SY - SR * CP * CY;
	RotationQuat.Y = -CR * SP * CY - SR * CP * SY;
	RotationQuat.Z = CR * CP * SY - SR * SP * CY;
	RotationQuat.W = CR * CP * CY + SR * SP * SY;
	return RotationQuat;
}

const FVector FVector::ZeroVector(0.0f, 0.0f, 0.0f);
const FVector FVector::OneVector(1.0f, 1.0f, 1.0f);
FVector FTransform::TransformPosition(FVector& V) const
{
	return Rotation.RotateVector(Scale3D * V) + Translation;
}

FVector FQuat::RotateVector(const FVector& V) const
{
	const FVector Q(X, Y, Z);
	const FVector T = (Q ^ V) * 2.f;
	const FVector Result = V + (T * W) + (Q ^ T);
	return Result;
}

bool a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18;
void  Draw3DBox(UCanvas* _this, APlayerController* plc, FVector origin, FVector extends, FLinearColor col)
{
	origin -= extends / 2.f;

	// bottom plane
	FVector one = origin;
	FVector two = origin; two.X += extends.X;
	FVector three = origin; three.X += extends.X; three.Y += extends.Y;
	FVector four = origin; four.Y += extends.Y;

	FVector five = one; five.Z += extends.Z;
	FVector six = two; six.Z += extends.Z;
	FVector seven = three; seven.Z += extends.Z;
	FVector eight = four; eight.Z += extends.Z;



	if (plc->ProjectWorldLocationToScreen(one, scr[0], 0) || plc->ProjectWorldLocationToScreen(two, scr[1], 0) || plc->ProjectWorldLocationToScreen(three, scr[2], 0) || plc->ProjectWorldLocationToScreen(four, scr[3], 0))
	{
		if (plc->ProjectWorldLocationToScreen(five, scr[4], 0) || plc->ProjectWorldLocationToScreen(six, scr[5], 0) || plc->ProjectWorldLocationToScreen(seven, scr[6], 0) || plc->ProjectWorldLocationToScreen(eight, scr[7], 0))
		{
			_this->K2_DrawLine(scr[0], scr[1], ESPThickness, col);
			_this->K2_DrawLine(scr[1], scr[2], ESPThickness, col);
			_this->K2_DrawLine(scr[2], scr[3], ESPThickness, col);
			_this->K2_DrawLine(scr[3], scr[0], ESPThickness, col);

			_this->K2_DrawLine(scr[4], scr[5], ESPThickness, col);
			_this->K2_DrawLine(scr[5], scr[6], ESPThickness, col);
			_this->K2_DrawLine(scr[6], scr[7], ESPThickness, col);
			_this->K2_DrawLine(scr[7], scr[4], ESPThickness, col);

			_this->K2_DrawLine(scr[0], scr[4], ESPThickness, col);
			_this->K2_DrawLine(scr[1], scr[5], ESPThickness, col);
			_this->K2_DrawLine(scr[2], scr[6], ESPThickness, col);
			_this->K2_DrawLine(scr[3], scr[7], ESPThickness, col);
		}
	}

	// 3 copies of each vertex? trash

}

bool Render3DBox(APlayerController* controller, UCanvas* Engine, const FVector& origin, const FVector& extent, const FRotator& rotation, const FLinearColor color)
{
	FVector vertex[2][4];
	vertex[0][0] = { -extent.X, -extent.Y,  -extent.Z };
	vertex[0][1] = { extent.X, -extent.Y,  -extent.Z };
	vertex[0][2] = { extent.X, extent.Y,  -extent.Z };
	vertex[0][3] = { -extent.X, extent.Y, -extent.Z };

	vertex[1][0] = { -extent.X, -extent.Y, extent.Z };
	vertex[1][1] = { extent.X, -extent.Y, extent.Z };
	vertex[1][2] = { extent.X, extent.Y, extent.Z };
	vertex[1][3] = { -extent.X, extent.Y, extent.Z };

	FVector2D screen[2][4];
	FTransform const Transform(rotation);
	for (auto k = 0; k < 2; k++)
	{
		for (auto i = 0; i < 4; i++)
		{
			auto& vec = vertex[k][i];
			vec = Transform.TransformPosition(vec) + origin;
			if (!controller->ProjectWorldLocationToScreen(vec, screen[k][i], false)) return false;
		}

	}

	auto SurfaceScreen = reinterpret_cast<FVector2D(&)[2][4]>(screen);

	for (auto i = 0; i < 4; i++)
	{
		Engine->K2_DrawLine(SurfaceScreen[0][i], SurfaceScreen[0][(i + 1) % 4], ESPThickness, color);
		Engine->K2_DrawLine(SurfaceScreen[1][i], SurfaceScreen[1][(i + 1) % 4], ESPThickness, color);
		Engine->K2_DrawLine(SurfaceScreen[0][i], SurfaceScreen[1][i], ESPThickness, color);
	}

	return true;
}
bool healthbar = 0;
bool aimbotvischeck = 1;
void PostRender(uintptr_t _this, UCanvas* canvas)
{
	if (!canvas)
		return PostRender(_this, canvas);

	if (kekIsOff)return PostRender(_this, canvas);
	CWINGui::SetupCanvas(canvas);
	UWorld* World = Memory::ReadStub<UWorld*>(_this + 0x80);
	APlayerController* MyController = ShooterGameBlueprints::GetFirstLocalPlayerController(World);
	AShooterCharacter* MyShooter = MyController->GetShooterCharacter();
	TArray<AShooterCharacter*> Actors = ShooterGameBlueprints::FindAllShooterCharactersWithAlliance(World, MyShooter, EAresAlliance::Alliance_Any, false, true); 
	CWINGui::Input::Handle();

	if (GetAsyncKeyState(VK_INSERT) & 1) menu_opened = !menu_opened; //Our menu key 
	if (enableaim && drawfov)
	{
		CWINGui::DrawCircle({ (float)GetSystemMetrics(SM_CXSCREEN) / 2, (float)GetSystemMetrics(SM_CYSCREEN) / 2 }, radius, Lineamount, circlecol);
	}
	if (CWINGui::Window(skCrypt(" gay"), &pos, FVector2D{ 500.0f, 400.0f }, menu_opened))
	{
		//Simple Tabs
		static int tab = 0;
		if (CWINGui::ButtonTab(L"> AIM", FVector2D{ 110, 50 }, tab == 0)) tab = 0; 
		if (CWINGui::ButtonTab(L"> ESP", FVector2D{ 110, 50 }, tab == 1)) tab = 1;
		if (CWINGui::ButtonTab(L"> MISC", FVector2D{ 110, 50 }, tab == 2)) tab = 2;
		CWINGui::NextColumn(140.0f);
		//Some Elements


		if (tab == 0)
		{
			CWINGui::Checkbox(L"Toggle", &enableaim); 
			CWINGui::Checkbox(L"Memory Mode", &memory); 
			CWINGui::Checkbox(L"Only aim when player is visible", &aimbotvischeck); 
			CWINGui::Checkbox(L"Draw FOV", &drawfov); 
			CWINGui::Hotkey("Keybind", {132,32}, &KEKWNOKEY); 
			CWINGui::SliderFloat(L"Radius", &radius, 1, 2000); 
			CWINGui::ColorPicker(L"Circle color", &circlecol); 
			CWINGui::SliderFloat(L"Amount of lines in circle", &Lineamount, 10, 1000);
		}

		if (tab == 1)
		{
			CWINGui::Checkbox(L"Chams", &ChamsESP); 
			CWINGui::Checkbox(L"Bounding Boxes", &box2d); 
			CWINGui::Checkbox(L"Player Names", &PlayerNames); 
			CWINGui::Checkbox(L"Health Bar", &healthbar); 
			CWINGui::Checkbox(L"Draw Allies", &chammyteam); 
			CWINGui::Checkbox(L"Outline", &bOutline); 
			CWINGui::Checkbox(L"Replace text by health", &healthcol); 
			CWINGui::ColorPicker(L"Chams Color", &MainESPColor); 
			CWINGui::ColorPicker(L"Behind Wall Color", &behind_wall_color); 
			CWINGui::ColorPicker(L"Visible Color", &visible_color); 
			CWINGui::SliderFloat(L"ESP Thickness", &ESPThickness, 1, 10);
		}

		if (tab == 2)
		{
			CWINGui::Checkbox(L"Fly (training range only)", &flyhack); 
			CWINGui::Checkbox(L"Third Person Viewmode", &thirdperson); 
			CWINGui::Checkbox(L"Camera Slider", &fovchanger); 
			CWINGui::SliderFloat(L"FOV", &fovchangur, 0, 300);
		}

		if (tab == 3)
		{
		}


		//Color Picker
	}
	CWINGui::Draw_Cursor(menu_opened);
	CWINGui::Render();//Custom Render. I use it for drawing Combobox and ColorPicker over the menu 
	if (fovchanger)
		MyController->set_fov(fovchangur);
	for (int Index = 0; Index < Actors.Num(); Index++)
	{
		if (!Actors.IsValidIndex(Index))
			continue;

		AShooterCharacter* Actor = Actors[Index];


		if (Actor->GetHealth() == 0)
			continue;

		if (!chammyteam)
		{
			if (BaseTeamComponent::IsAlly(Actor, MyShooter))
				continue;
		}

		USkeletalMeshComponent* Mesh = Actor->GetPawnMesh();
		bool IsAlive = Actor->IsAlive();


		if (Mesh && IsAlive)
		{
			CWINGui::TextCenter(skCrypt(L"ENEMY NEARBY"), { 1920,30 }, RGBtoFLC(255, 0, 0), 1, 1);
			FLinearColor MainColor;
			if (MyController->LineOfSightTo(Actor, { 0,0,0 }, false))
				MainColor = visible_color;
			else
				MainColor = behind_wall_color;

			if (flyhack)
				MyShooter->ClientFly();
			if (box2d)
			{
				FVector Origin, Extend;
				GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				//Render3DBox(MyController, canvas, Origin, Extend, Actor->K2_GetActorRotation(), xtest_color);
				//Draw3DBox(canvas, MyController, Origin, Extend, xtest_color);
				auto location = Actor->K2_GetActorLocation(); FVector2D footPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z + (Extend.Z / 2) }, footPos, 0)) continue;

				FVector2D headPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z - (Extend.Z / 2) }, headPos, 0)) continue;


				const float height = abs(footPos.Y - headPos.Y);
				const float width = height * 0.4f;
				FVector2D top = { headPos.X - width * 0.5f, headPos.Y };
				FVector2D bottom = { headPos.X + width * 0.5f, footPos.Y };
				DrawBox(canvas, top, bottom, MainColor);
			}

			if (thirdperson)
			{
				MyShooter->Set3pMeshVisible(1);
			}
			else
			{
				MyShooter->Set3pMeshVisible(0);
			}

			if (enableaim)
			{
				if (memory)
				{
					static AShooterCharacter* closestEnemy = nullptr;
					static float closestDistance = 999999.9f;
					if (closestEnemy)
					{
						/* Obtain health and RelativeLocation */
						auto Health = Actor->GetHealth();
						auto RelativeLocation = Actor->K2_GetActorLocation();

						/* Define vectors */
						FVector Origin, Extend;
						GetActorBounds(Actor, 1, &Origin, &Extend, 0);

						/* W2S the vectors */
						auto location = Actor->K2_GetActorLocation(); FVector2D footPos;
						if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z - (Extend.Z / 2) }, footPos, 0)) continue;

						FRotator LocRotator = { DEG(asinf(location.X / location.Magnitude())), DEG(atan2f(location.Y, location.X)), 0.0f };

						if (GetAsyncKeyState(KEKWNOKEY))
							MyController->ExecSetCameraRotator(LocRotator);
					}
					else if (Actor)
					{
						closestEnemy = Actor;
					}
				}
			}

			if (healthbar)
			{
				FVector Origin, Extend;
				GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				auto location = Actor->K2_GetActorLocation(); FVector2D footPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z - (Extend.Z / 2) }, footPos, 0)) continue;

				FVector2D headPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z + (Extend.Z / 2) }, headPos, 0)) continue;

				auto maxhealth = Actor->GetMaxHealth();
				if (maxhealth >= 100)maxhealth = 100;
				const float hp = Actor->GetHealth() / maxhealth;

				const float height = abs(footPos.Y - headPos.Y);
				const float width = height * 0.4f;
				const float width2 = width * 0.5f;
				const float adjust = height * 0.025f;
				const float len = width * hp;

				FVector2D top = { headPos.X - width * 0.5f, headPos.Y };
				FVector2D bottom = { headPos.X + width * 0.5f, footPos.Y };
				auto downleft = FVector2D{ top.X, bottom.Y };
				auto topright = FVector2D{ bottom.X, top.Y };

				auto h = bottom.Y - top.Y;
				auto w = bottom.X - top.X;
				auto thicc = ESPThickness;

				canvas->K2_DrawLinex({ headPos.X - width2, footPos.Y + adjust }, { headPos.X - width2 + len, footPos.Y + adjust * 2.f }, 5, RGBtoFLC(0, 255, 0));

			}

			if (PlayerNames)
			{
				/* Define vectors */
				FVector Origin, Extend;
				FVector2D rel2d, footPos;

				/* Get bouuuuuuunds */
				GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				/* Obtain health and RelativeLocation */
				auto Health = Actor->GetHealth();
				auto RelativeLocation = Actor->K2_GetActorLocation();

				/* W2S the vectors */
				if (MyController->ProjectWorldLocationToScreen({ RelativeLocation.X, RelativeLocation.Y, RelativeLocation.Z - (Extend.Z / 2) }, footPos, 0))
				{
					if (MyController->ProjectWorldLocationToScreen(Actor->K2_GetActorLocation(), rel2d, true))
					{
						/* And print the name out */
						//int Index = Memory::ReadStub<int>(reinterpret_cast<uintptr_t>(Actor) + 0x18);
						//FName NoneFName(0);

						//std::string None = NoneFName.GetName();

						//if (None != "None") std::cout << "Nah bro it failed" << std::endl;
						//if (Player.GetName() != "")
						//{
						//	std::wstring PlayerW(Player.GetName().begin(), Player.GetName().end());
						//	DrawTextRGBWithFString(canvas, PlayerW.c_str(), footPos.X, footPos.Y + 10, MainColor, 1);
						//}
					}
				}
			}

			if (ChamsESP)
			{
				Mesh->SetAresOutlineMode(EAresOutlineMode::Outline, true);
				AresOutlineRendering::SetOutlineColorsForRender(World, MainESPColor, MainESPColor);
			}
			else
			{
				Mesh->SetAresOutlineMode(EAresOutlineMode::None, true);
			}

		}
	}

	return pRender(_this, canvas);
}



void Init()
{
	//AllocConsole();
	//freopen("CONIN$", "r", stdin);
	//freopen("CONOUT$", "w", stdout);
	VALORANT::Module = (uintptr_t)GetModuleHandleA(0);
	uintptr_t WorldKey = *(uintptr_t*)(VALORANT::Module + Offsets::Key);
	State StateKey = *(State*)(VALORANT::Module + Offsets::State);
	UWorldXOR = Decryption::Decrypt_UWorld(WorldKey, (uintptr_t*)&StateKey);
	UWorldClass = Memory::ReadStub<UWorld*>(UWorldXOR);
	GameInstance = Memory::ReadStub<UGameInstance*>((uintptr_t)UWorldClass + 0x1A0);
	LocalPlayers = Memory::ReadStub<ULocalPlayer*>((uintptr_t)GameInstance + 0x40); //this is tarray but im paster lol
	LocalPlayer = Memory::ReadStub<ULocalPlayer*>((uintptr_t)LocalPlayers); //
	APlayerController* LocalController = Memory::ReadStub<APlayerController*>((uintptr_t)LocalPlayer + 0x38);
	uintptr_t ViewportClient = Memory::ReadStub<uintptr_t>((uintptr_t)LocalPlayer + 0x78);
	uintptr_t Engine = Memory::ReadStub<uintptr_t>((uintptr_t)GameInstance + 0x28);
	DefaultMediumFont = Memory::ReadStub<UObject*>(Engine + 0xd8);
	NamePoolData = reinterpret_cast<FNamePool*>(VALORANT::Module + NamePoolDataOffset);
	Hook::VMT((void*)ViewportClient, PostRender, 0x68, (void**)&pRender);
}
extern "C" __declspec(dllexport) int NextHook(int code, WPARAM wParam, LPARAM lParam) { return CallNextHookEx(NULL, code, wParam, lParam); }


BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
	switch (ul_reason_for_call) {
	case DLL_PROCESS_ATTACH:
		Init();
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}

```

`DaddyKermitsInternal.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32922.545
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DaddyKermitsInternal", "DaddyKermitsInternal.vcxproj", "{1998D631-50F0-4719-BA07-FEB48A9ED452}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Debug|x64.ActiveCfg = Debug|x64
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Debug|x64.Build.0 = Debug|x64
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Debug|x86.ActiveCfg = Debug|Win32
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Debug|x86.Build.0 = Debug|Win32
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Release|x64.ActiveCfg = Release|x64
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Release|x64.Build.0 = Release|x64
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Release|x86.ActiveCfg = Release|Win32
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {EFC4D86C-395B-4AC9-83D2-9D4A33E8820C}
	EndGlobalSection
EndGlobal

```

`DaddyKermitsInternal.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Entry.cpp" />
    <ClCompile Include="FNamePool.h" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Alignments.h" />
    <ClInclude Include="decryption.h" />
    <ClInclude Include="Decryptor.h" />
    <ClInclude Include="discord_rpc.h" />
    <ClInclude Include="hook.h" />
    <ClInclude Include="memory.h" />
    <ClInclude Include="offsets.h" />
    <ClInclude Include="Canvas.h" />
    <ClInclude Include="Unreal.h" />
    <ClInclude Include="unrealengine.h" />
    <ClInclude Include="valorant.h" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="discord-rpc.lib" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1998d631-50f0-4719-ba07-feb48a9ed452}</ProjectGuid>
    <RootNamespace>internalforuglypasters</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Valorant</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>DaddyKermitsInternal</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;INTERNALFORUGLYPASTERS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;INTERNALFORUGLYPASTERS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;INTERNALFORUGLYPASTERS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;INTERNALFORUGLYPASTERS_EXPORTS;_WINDOWS;_USRDLL;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DaddyKermitsInternal.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Entry.cpp" />
    <ClCompile Include="FNamePool.h">
      <Filter>Decryption</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="decryption.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="hook.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="offsets.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Canvas.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="unrealengine.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="valorant.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Unreal.h">
      <Filter>Engine</Filter>
    </ClInclude>
    <ClInclude Include="Alignments.h">
      <Filter>Decryption</Filter>
    </ClInclude>
    <ClInclude Include="Decryptor.h">
      <Filter>Decryption</Filter>
    </ClInclude>
    <ClInclude Include="discord_rpc.h">
      <Filter>RPC</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Headers">
      <UniqueIdentifier>{0ff10ebb-01d8-4b4e-9e0a-b32145221c23}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine">
      <UniqueIdentifier>{b63e63fe-d5ad-4d81-a447-37a2d7ea0813}</UniqueIdentifier>
    </Filter>
    <Filter Include="Authentication">
      <UniqueIdentifier>{36659c19-e21f-4e6a-a0b6-38055fcbe2a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Decryption">
      <UniqueIdentifier>{a71d89b5-403c-4366-a46c-c9163a4ba2ae}</UniqueIdentifier>
    </Filter>
    <Filter Include="RPC">
      <UniqueIdentifier>{6041810d-05f2-4fe2-8ada-1a0bd9d4ec5c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Library Include="discord-rpc.lib">
      <Filter>RPC</Filter>
    </Library>
  </ItemGroup>
</Project>
```

`DaddyKermitsInternal.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Decryptor.h`:

```h
#pragma once
#include "Alignments.h"
#include "FNamePool.h"
#include "decryption.h" 
#include <Windows.h> 
#include <string>


uint64 BaseAddress = (uint64)GetModuleHandleA(0);
class FNamePool* NamePoolData = nullptr;
#define DecryptWideOffset 0x32D05D0
#define DecryptNonWideOffset 0x32D0560 
#define NamePoolDataOffset 0x9095380

static constexpr uint32 FNameMaxBlockBits = 13;
static constexpr uint32 FNameBlockOffsetBits = 16;
static constexpr uint32 FNameMaxBlocks = 1 << FNameMaxBlockBits;
static constexpr uint32 FNameBlockOffsets = 1 << FNameBlockOffsetBits;

struct FNameEntryId
{
	FNameEntryId() : Value(0) {}

	FNameEntryId(uint32 Id) : Value(Id) {}

	explicit operator bool() const { return Value != 0; }

	FORCEINLINE bool operator==(FNameEntryId Other) const
	{
		return Value == Other.Value;
	}

	FORCEINLINE static FNameEntryId FromUnstableInt(uint32 UnstableInt)
	{
		FNameEntryId Id;
		Id.Value = UnstableInt;
		return Id;
	}

	FORCEINLINE uint32 ToUnstableInt() const {
		return Value;
	}

	uint32 Value;
};

struct FNameEntryHandle
{
	uint32 Block = 0;
	uint32 Offset = 0;

	FNameEntryHandle(uint32 InBlock, uint32 InOffset)
		: Block(InBlock)
		, Offset(InOffset)
	{}

	FNameEntryHandle(FNameEntryId Id)
		: Block(Id.ToUnstableInt() >> FNameBlockOffsetBits)
		, Offset(Id.ToUnstableInt()& (FNameBlockOffsets - 1))
	{}

	operator FNameEntryId() const
	{
		return FNameEntryId::FromUnstableInt(Block << FNameBlockOffsetBits | Offset);
	}

	explicit operator bool() const { return Block | Offset; }
};

struct FNameEntryHeader
{
	uint16 bIsWide : 1;
	uint16 Len : 15;
};

struct FNameEntry {
	enum { NAME_SIZE = 1024 };
public:
	FORCEINLINE bool IsWide() const
	{
		return Header.bIsWide;
	}

	FORCEINLINE int32 GetNameLength() const
	{
		return Header.Len;
	}

	FORCEINLINE FNameEntryHeader GetEntryHeader() const
	{
		return Header;
	}

	static int32 GetSize(int32 Length, bool bIsPureAnsi);

	char* DecryptNonWide();

	wchar_t* DecryptWide();

	FORCEINLINE void CopyUnterminatedName(ANSICHAR* Out)
	{
		memcpy(Out, DecryptNonWide(), sizeof(ANSICHAR) * Header.Len);
	}

	FORCEINLINE void CopyUnterminatedName(WIDECHAR* Out)
	{
		memcpy(Out, DecryptWide(), sizeof(WIDECHAR) * Header.Len);
	}

	FORCEINLINE static int32 GetDataOffset()
	{
		return offsetof(FNameEntry, AnsiName);
	}

	void GetAnsiName(ANSICHAR(&Out)[NAME_SIZE]);

	void GetWideName(WIDECHAR(&Out)[NAME_SIZE]);

	WCHAR* Wchar();

	std::string String();

	FNameEntryId ComparisonId;

	FNameEntryHeader Header;

	union
	{
		ANSICHAR	AnsiName[NAME_SIZE];
		WIDECHAR	WideName[NAME_SIZE];
	};

};

void FNameEntry::GetAnsiName(ANSICHAR(&Out)[NAME_SIZE])
{
	if (!IsWide())
	{
		CopyUnterminatedName(Out);
		Out[Header.Len] = '\0';
	}
}

void FNameEntry::GetWideName(WIDECHAR(&Out)[NAME_SIZE])
{
	if (IsWide())
	{
		CopyUnterminatedName(Out);
		Out[Header.Len] = '\0';
	}
}

class FNameEntryAllocator
{
public:
	enum { Stride = alignof(FNameEntry) };
	enum { BlockSizeBytes = Stride * FNameBlockOffsets };

	void* FRWLock;
	uint32 CurrentBlock = 0;
	uint32 CurrentByteCursor = 0;
	uint8* Blocks[FNameMaxBlocks] = {};

	FORCEINLINE uint32 NumBlocks() const
	{
		return CurrentBlock + 1;
	}

	FORCEINLINE FNameEntry& Resolve(FNameEntryHandle Handle) const
	{
		if (Handle.Offset < 0 && Handle.Block > NumBlocks() && Handle.Offset * Stride < FNameBlockOffsets)
			return *reinterpret_cast<FNameEntry*>(Blocks[0] + Stride * 0);

		return *reinterpret_cast<FNameEntry*>(Blocks[Handle.Block] + Stride * Handle.Offset);
	}

};

wchar_t* FNameEntry::DecryptWide()
{

	auto _DecryptWideEntry = (__int64(__fastcall*)(FNameEntry * Entry, wchar_t* Buffer))(BaseAddress + DecryptWideOffset);

	wchar_t Buffer[1024];

	__int64 Result = _DecryptWideEntry(this, Buffer);

	return Buffer;
}

char* FNameEntry::DecryptNonWide()
{
	auto _DecryptNonWideEntry = (__int64(__fastcall*)(FNameEntry * Entry, char* Buffer))(BaseAddress + DecryptNonWideOffset);

	char Buffer[1024];

	__int64 Result = _DecryptNonWideEntry(this, Buffer);

	return Buffer;
}

std::string FNameEntry::String()
{
	if (IsWide()) {
		WCHAR* DecryptedName = DecryptWide();
		std::wstring Wide(DecryptedName, Header.Len);
		return std::string(Wide.begin(), Wide.end());
	}

	char* DecryptedName = DecryptNonWide();
	return std::string(DecryptedName, Header.Len);
}

WCHAR* FNameEntry::Wchar()
{
	if (IsWide())
		return DecryptWide();
	else
		return 0;
}

int32 FNameEntry::GetSize(int32 Length, bool bIsPureAnsi)
{
	int32 Bytes = GetDataOffset() + Length * (bIsPureAnsi ? sizeof(ANSICHAR) : sizeof(WIDECHAR));
	return Align(Bytes, alignof(FNameEntry));
}
 

class FNamePool
{
public:
	enum { MaxENames = 512 };
	FNameEntryAllocator Entries;
	/*
	* Not interested in other members.
	*/
};

struct FName {
	FNameEntryId	ComparisonIndex;

	FNameEntryId	DisplayIndex;

	uint32			Number;

	FORCEINLINE FNameEntryId GetComparisonIndex() const
	{
		return ComparisonIndex;
	}

	FORCEINLINE FNameEntryId GetDisplayIndex() const
	{
		return DisplayIndex;
	}

	FORCEINLINE bool operator==(FName Other) const
	{
		return (ComparisonIndex == Other.ComparisonIndex) && (GetNumber() == Other.GetNumber());
	}

	FORCEINLINE bool operator!=(FName Other) const
	{
		return !(*this == Other);
	}

	FORCEINLINE int32 GetNumber() const
	{
		return Number;
	}

	FName() :
		ComparisonIndex(FNameEntryId()),
		Number(0)
	{ }

	FName(int32 i, int32 n = 0) :
		ComparisonIndex(FNameEntryId(i)),
		Number(n)
	{ }

	const FNameEntry* GetDisplayNameEntry() const;

	std::string GetName();
};

const FNameEntry* FName::GetDisplayNameEntry() const
{
	return &NamePoolData->Entries.Resolve(GetDisplayIndex());
}

std::string FName::GetName()
{
	FNameEntry Entry = NamePoolData->Entries.Resolve(GetDisplayIndex());

	std::string Name = Entry.String();

	if (Number > 0) Name += '_' + std::to_string(Number);

	std::size_t Pos = Name.rfind('/');

	if (Pos != std::string::npos) Name = Name.substr(Pos + 1);

	return Name;
}
```

`Entry.cpp`:

```cpp
#include <Windows.h>
#include <cstdio>
#include "Canvas.h"
#include "decryption.h"
#include "hook.h"
#include "Decryptor.h"
using PostRenderHook = void(*)(uintptr_t _this, UCanvas* canvas);
PostRenderHook pRender = 0;

uintptr_t UWorldXOR;
UWorld* UWorldClass;
UGameInstance* GameInstance;
ULocalPlayer* LocalPlayers;
ULocalPlayer* LocalPlayer;

void DrawTextRGB(UCanvas* canvas, const wchar_t* text, float x, float y, FLinearColor color, bool CenterX = 0)
{
	canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, color, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, CenterX, 0, bOutline, { 0, 0, 0, 1 });
}
void DrawTextRGBWithFString(UCanvas* canvas, FString text, float x, float y, FLinearColor color, bool CenterX = 0)
{
	canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, color, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, CenterX, 0, bOutline, { 0, 0, 0, 1 });
}

void xxDrawTextRGB(UCanvas* canvas, FString text, float x, float y, FLinearColor color)
{
	canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, color, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, 0, 0, false, { 0, 0, 0, 1 });
}
FLinearColor RGBtoFLC(float R, float G, float B)
{
	return { R / 255, G / 255, B / 255, 1 };
}

bool kekIsOff = 0; // debugging purposes ONLY solely for THAT
bool chams = 0;

static FLinearColor test_color{ 2.093f, 0.019f, 20.0f, 5.9f };
static FLinearColor MainESPColor{ 1.0f,1.0f,1.0f,1.0f};
static FLinearColor behind_wall_color = RGBtoFLC(255, 255, 255);
static FLinearColor visible_color = RGBtoFLC(0, 255, 0);
static FLinearColor circlecol = RGBtoFLC(0, 255, 0);
static bool menu_opened = true;
FVector2D pos = { ((float)GetSystemMetrics(SM_CXSCREEN) / 2) - 500, ((float)GetSystemMetrics(SM_CYSCREEN) / 2) - 475 };

static bool ChamsESP = false;
static bool brightchammy = false;
static bool box2d = false;
static bool PlayerNames = false;
static bool chammyteam = false;
static bool fovchanger = false;
static bool thirdperson = false;
static bool flyhack = false;
static bool healthcol = false;
static bool enableaim = false;
static bool memory = false;
static bool test1 = false;
static bool silent = false;
static bool drawfov = false;
int KEKWNOKEY;
static float radius = 100.0f;
static float fovchangur = 80.0f;
int aimbotmode = 0;

float ESPThickness = 1.0f;
float Lineamount = 500.0f;
float kekw = 4.0f;


void DrawBox(UCanvas* can, FVector2D& topleft, FVector2D& downright, FLinearColor clr)
{
	auto h = downright.Y - topleft.Y;
	auto w = downright.X - topleft.X;

	auto downleft = FVector2D{ topleft.X, downright.Y };
	auto topright = FVector2D{ downright.X, topleft.Y };

	auto thicc = ESPThickness;

	FLinearColor xclr = RGBtoFLC(0, 0, 0);

	can->K2_DrawLinex( topleft, { downright.X, topleft.Y }, thicc, clr);
	can->K2_DrawLinex(topleft, { topleft.X , downright.Y }, thicc, clr);
	can->K2_DrawLinex(downright, { topleft.X , downright.Y }, thicc, clr);
	can->K2_DrawLine(downright, { downright.X, topleft.Y }, thicc, clr);
	/*
	* OLD (remove 3 first line integrity)
	can->K2_DrawLine({topleft.X, topleft.Y + 100}, {topleft.X, topleft.Y + h * 1}, thicc, clr);
	can->K2_DrawLine({ topleft.X, topleft.Y + 100 }, { topleft.X + w * 1, topleft.Y }, thicc, clr);

	can->K2_DrawLine({ downright.X, downright.Y - 100 }, { downright.X, downright.Y - h * 1 }, thicc, clr);
	can->K2_DrawLine(downright, { downright.X - w * 1, downright.Y }, thicc, clr);

	can->K2_DrawLine(downleft, { downleft.X, downleft.Y - h * 1 }, thicc, clr);
	can->K2_DrawLine(downleft, { downleft.X + w * 1, downright.Y }, thicc, clr);

	can->K2_DrawLine(topright, { topright.X, topright.Y + h * 1 }, thicc, clr);
	can->K2_DrawLine(topright, { topright.X - w * 1, topright.Y }, thicc, clr);*/
}
uintptr_t OffsetGetActorBounds;
void GetActorBounds(AShooterCharacter* Actor, bool bOnlyCollidingComponents, FVector* Origin, FVector* BoxExtent, bool bIncludeFromChildActors)
{
	reinterpret_cast<void(*)(AShooterCharacter*, bool, FVector * pos, FVector * screen, bool)> ((uintptr_t)GetModuleHandleA(0) + 0x4771E10)(Actor, 0, Origin, BoxExtent, 0);
}
static FVector2D scr[8];

void FMath::SinCos(float* ScalarSin, float* ScalarCos, float Value)
{
	// Map Value to y in [-pi,pi], x = 2*pi*quotient + remainder.
	float quotient = (INV_PI * 0.5f) * Value;
	if (Value >= 0.0f)
	{
		quotient = (float)((int)(quotient + 0.5f));
	}
	else
	{
		quotient = (float)((int)(quotient - 0.5f));
	}
	float y = Value - (2.0f * PI) * quotient;

	// Map y to [-pi/2,pi/2] with sin(y) = sin(Value).
	float sign;
	if (y > HALF_PI)
	{
		y = PI - y;
		sign = -1.0f;
	}
	else if (y < -HALF_PI)
	{
		y = -PI - y;
		sign = -1.0f;
	}
	else
	{
		sign = +1.0f;
	}

	float y2 = y * y;

	// 11-degree minimax approximation
	*ScalarSin = (((((-2.3889859e-08f * y2 + 2.7525562e-06f) * y2 - 0.00019840874f) * y2 + 0.0083333310f) * y2 - 0.16666667f) * y2 + 1.0f) * y;

	// 10-degree minimax approximation
	float p = ((((-2.6051615e-07f * y2 + 2.4760495e-05f) * y2 - 0.0013888378f) * y2 + 0.041666638f) * y2 - 0.5f) * y2 + 1.0f;
	*ScalarCos = sign * p;
}

float FMath::Fmod(float X, float Y)
{
	const float AbsY = fabsf(Y);
	if (AbsY <= 1.e-8f) { return 0.f; }
	const float Div = (X / Y);
	// All floats where abs(f) >= 2^23 (8388608) are whole numbers so do not need truncation, and avoid overflow in TruncToFloat as they get even larger.
	const float Quotient = fabsf(Div) < FLOAT_NON_FRACTIONAL ? truncf(Div) : Div;
	float IntPortion = Y * Quotient;

	// Rounding and imprecision could cause IntPortion to exceed X and cause the result to be outside the expected range.
	// For example Fmod(55.8, 9.3) would result in a very small negative value!
	if (fabsf(IntPortion) > fabsf(X)) { IntPortion = X; }

	const float Result = X - IntPortion;
	// Clamp to [-AbsY, AbsY] because of possible failures for very large numbers (>1e10) due to precision loss.
	// We could instead fall back to stock fmodf() for large values, however this would diverge from the SIMD VectorMod() which has no similar fallback with reasonable performance.
	return FMath::Clamp(Result, -AbsY, AbsY);
}
FQuat FRotator::Quaternion() const
{
	float SP, SY, SR;
	float CP, CY, CR;
	const float PitchNoWinding = FMath::Fmod(Pitch, 360.0f);
	const float YawNoWinding = FMath::Fmod(Yaw, 360.0f);
	const float RollNoWinding = FMath::Fmod(Roll, 360.0f);
	FMath::SinCos(&SP, &CP, PitchNoWinding * RADS_DIVIDED_BY_2);
	FMath::SinCos(&SY, &CY, YawNoWinding * RADS_DIVIDED_BY_2);
	FMath::SinCos(&SR, &CR, RollNoWinding * RADS_DIVIDED_BY_2);
	FQuat RotationQuat;
	RotationQuat.X = CR * SP * SY - SR * CP * CY;
	RotationQuat.Y = -CR * SP * CY - SR * CP * SY;
	RotationQuat.Z = CR * CP * SY - SR * SP * CY;
	RotationQuat.W = CR * CP * CY + SR * SP * SY;
	return RotationQuat;
}

const FVector FVector::ZeroVector(0.0f, 0.0f, 0.0f);
const FVector FVector::OneVector(1.0f, 1.0f, 1.0f);
FVector FTransform::TransformPosition(FVector& V) const
{
	return Rotation.RotateVector(Scale3D * V) + Translation;
}

FVector FQuat::RotateVector(const FVector& V) const
{
	const FVector Q(X, Y, Z);
	const FVector T = (Q ^ V) * 2.f;
	const FVector Result = V + (T * W) + (Q ^ T);
	return Result;
}

bool a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18;
void  Draw3DBox(UCanvas* _this, APlayerController* plc, FVector origin, FVector extends, FLinearColor col)
{
	origin -= extends / 2.f;

	// bottom plane
	FVector one = origin;
	FVector two = origin; two.X += extends.X;
	FVector three = origin; three.X += extends.X; three.Y += extends.Y;
	FVector four = origin; four.Y += extends.Y;

	FVector five = one; five.Z += extends.Z;
	FVector six = two; six.Z += extends.Z;
	FVector seven = three; seven.Z += extends.Z;
	FVector eight = four; eight.Z += extends.Z;



	if (plc->ProjectWorldLocationToScreen(one, scr[0], 0) || plc->ProjectWorldLocationToScreen(two, scr[1], 0) || plc->ProjectWorldLocationToScreen(three, scr[2], 0) || plc->ProjectWorldLocationToScreen(four, scr[3], 0))
	{
		if (plc->ProjectWorldLocationToScreen(five, scr[4], 0) || plc->ProjectWorldLocationToScreen(six, scr[5], 0) || plc->ProjectWorldLocationToScreen(seven, scr[6], 0) || plc->ProjectWorldLocationToScreen(eight, scr[7], 0))
		{
			_this->K2_DrawLine(scr[0], scr[1], ESPThickness, col);
			_this->K2_DrawLine(scr[1], scr[2], ESPThickness, col);
			_this->K2_DrawLine(scr[2], scr[3], ESPThickness, col);
			_this->K2_DrawLine(scr[3], scr[0], ESPThickness, col);

			_this->K2_DrawLine(scr[4], scr[5], ESPThickness, col);
			_this->K2_DrawLine(scr[5], scr[6], ESPThickness, col);
			_this->K2_DrawLine(scr[6], scr[7], ESPThickness, col);
			_this->K2_DrawLine(scr[7], scr[4], ESPThickness, col);

			_this->K2_DrawLine(scr[0], scr[4], ESPThickness, col);
			_this->K2_DrawLine(scr[1], scr[5], ESPThickness, col);
			_this->K2_DrawLine(scr[2], scr[6], ESPThickness, col);
			_this->K2_DrawLine(scr[3], scr[7], ESPThickness, col);
		}
	}
}

bool Render3DBox(APlayerController* controller, UCanvas* Engine, const FVector& origin, const FVector& extent, const FRotator& rotation, const FLinearColor color)
{
	FVector vertex[2][4];
	vertex[0][0] = { -extent.X, -extent.Y,  -extent.Z };
	vertex[0][1] = { extent.X, -extent.Y,  -extent.Z };
	vertex[0][2] = { extent.X, extent.Y,  -extent.Z };
	vertex[0][3] = { -extent.X, extent.Y, -extent.Z };

	vertex[1][0] = { -extent.X, -extent.Y, extent.Z };
	vertex[1][1] = { extent.X, -extent.Y, extent.Z };
	vertex[1][2] = { extent.X, extent.Y, extent.Z };
	vertex[1][3] = { -extent.X, extent.Y, extent.Z };

	FVector2D screen[2][4];
	FTransform const Transform(rotation);
	for (auto k = 0; k < 2; k++)
	{
		for (auto i = 0; i < 4; i++)
		{
			auto& vec = vertex[k][i];
			vec = Transform.TransformPosition(vec) + origin;
			if (!controller->ProjectWorldLocationToScreen(vec, screen[k][i], false)) return false;
		}

	}

	auto SurfaceScreen = reinterpret_cast<FVector2D(&)[2][4]>(screen);

	for (auto i = 0; i < 4; i++)
	{
		Engine->K2_DrawLine(SurfaceScreen[0][i], SurfaceScreen[0][(i + 1) % 4], ESPThickness, color);
		Engine->K2_DrawLine(SurfaceScreen[1][i], SurfaceScreen[1][(i + 1) % 4], ESPThickness, color);
		Engine->K2_DrawLine(SurfaceScreen[0][i], SurfaceScreen[1][i], ESPThickness, color);
	}

	return true;
}
bool healthbar = 0;
bool snaplinenz = 0;
bool weaponesp = 0;
bool aimbotvischeck = 1;
bool shieldbar = 0;

FString character_name(FString in)
{
	if (in.ToString().find("Training") != std::string::npos)
		return FString(L"NPC");
	if (in.ToString().find("BountyHunter_PC_C") != std::string::npos)
		return FString(L"Fade");
	if (in.ToString().find("Stealth_PC_C") != std::string::npos)
		return FString(L"Yoru");
	if (in.ToString().find("Pandemic_PC_C") != std::string::npos)
		return FString(L"Viper");
	if (in.ToString().find("Hunter_PC_C") != std::string::npos)
		return FString(L"Sova");
	if (in.ToString().find("Guide_PC_C") != std::string::npos)
		return FString(L"Skye");
	if (in.ToString().find("Thorne_PC_C") != std::string::npos)
		return FString(L"Sage");
	if (in.ToString().find("Vampire_PC_C") != std::string::npos)
		return FString(L"Reyna");
	if (in.ToString().find("Clay_PC_C") != std::string::npos)
		return FString(L"Raze");
	if (in.ToString().find("Phoenix_PC_C") != std::string::npos)
		return FString(L"Phoenix");
	if (in.ToString().find("Wraith_PC_C") != std::string::npos)
		return FString(L"Omen");
	if (in.ToString().find("Sprinter_PC_C") != std::string::npos)
		return FString(L"Neon");
	if (in.ToString().find("Killjoy_PC_C") != std::string::npos)
		return FString(L"Killjoy");
	if (in.ToString().find("Grenadier_PC_C") != std::string::npos)
		return FString(L"Kayo");
	if (in.ToString().find("Wushu_PC_C") != std::string::npos)
		return FString(L"Jett");
	if (in.ToString().find("Gumshoe_PC_C") != std::string::npos)
		return FString(L"Cypher");
	if (in.ToString().find("Deadeye_PC_C") != std::string::npos)
		return FString(L"Chamber");
	if (in.ToString().find("Sarge_PC_C") != std::string::npos)
		return FString(L"Brimstone");
	if (in.ToString().find("Breach_PC_C") != std::string::npos)
		return FString(L"Breach");
	if (in.ToString().find("Rift_TargetingForm_PC_C") != std::string::npos)
		return FString(L"Astra");
	if (in.ToString().find("Rift_PC_C") != std::string::npos)
		return FString(L"Astra");
	if (in.ToString().find("Mage_PC_C") != std::string::npos)
		return FString(L"Harbor");
	else
		return FString(L"N/A");
}
FString weapon_name(FString in)
{
	if (in.ToString().find("Ability_Melee_Base_C") != std::string::npos)
		return FString(L"Melee");
	if (in.ToString().find("BasePistol_C") != std::string::npos)
		return FString(L"Classic");
	if (in.ToString().find("TrainingBotBasePistol_C") != std::string::npos)
		return FString(L"Classic");
	if (in.ToString().find("SawedOffShotgun_C") != std::string::npos)
		return FString(L"Shorty");
	if (in.ToString().find("AutomaticPistol_C") != std::string::npos)
		return FString(L"Frenzy");
	if (in.ToString().find("LugerPistol_C") != std::string::npos)
		return FString(L"Ghost");
	if (in.ToString().find("RevolverPistol_C") != std::string::npos)
		return FString(L"Sheriff");
	if (in.ToString().find("Vector_C") != std::string::npos)
		return FString(L"Stinger");
	if (in.ToString().find("SubMachineGun_MP5_C") != std::string::npos)
		return FString(L"Spectre");
	if (in.ToString().find("PumpShotgun_C") != std::string::npos)
		return FString(L"Bucky");
	if (in.ToString().find("AssaultRifle_Burst_C") != std::string::npos)
		return FString(L"Bulldog");
	if (in.ToString().find("DMR_C") != std::string::npos)
		return FString(L"Guardian");
	if (in.ToString().find("AssaultRifle_ACR_C") != std::string::npos)
		return FString(L"Phantom");
	if (in.ToString().find("AssaultRifle_AK_C") != std::string::npos)
		return FString(L"Vandal");
	if (in.ToString().find("LeverSniperRifle_C") != std::string::npos)
		return FString(L"Marshall");
	if (in.ToString().find("BoltSniper_C") != std::string::npos)
		return FString(L"Operator");
	if (in.ToString().find("LightMachineGun_C") != std::string::npos)
		return FString(L"Ares");
	if (in.ToString().find("HeavyMachineGun_C") != std::string::npos)
		return FString(L"Odin");
	else
		return FString(L"N/A");
}


void PostRender(uintptr_t _this, UCanvas* canvas)
{
	if (!canvas)
		return PostRender(_this, canvas);

	if (kekIsOff)return PostRender(_this, canvas);
	CWINGui::SetupCanvas(canvas);
	UWorld* World = Memory::ReadStub<UWorld*>(_this + 0x80);
	APlayerController* MyController = ShooterGameBlueprints::GetFirstLocalPlayerController(World);
	AShooterCharacter* MyShooter = MyController->GetShooterCharacter();
	TArray<AShooterCharacter*> Actors = ShooterGameBlueprints::FindAllShooterCharactersWithAlliance(World, MyShooter, EAresAlliance::Alliance_Any, false, true); 
	CWINGui::Input::Handle();

	if (GetAsyncKeyState(VK_INSERT) & 1) menu_opened = !menu_opened; //Our menu key 
	if (enableaim && drawfov)
	{
		CWINGui::DrawCircle({ (float)GetSystemMetrics(SM_CXSCREEN) / 2, (float)GetSystemMetrics(SM_CYSCREEN) / 2 }, radius, Lineamount, circlecol);
	}
	if (CWINGui::Window(skCrypt("DaddyKermit Internal"), &pos, FVector2D{ 500.0f, 475.0f }, menu_opened))
	{
		//Simple Tabs
		static int tab = 0;
		if (CWINGui::ButtonTab(L"Aimbot", FVector2D{ 110, 35 }, tab == 0)) tab = 0; 
		if (CWINGui::ButtonTab(L"Visuals", FVector2D{ 110, 35 }, tab == 1)) tab = 1;
		if (CWINGui::ButtonTab(L"Exploits", FVector2D{ 110, 35 }, tab == 2)) tab = 2; 
		if (CWINGui::ButtonTab(L"Misc", FVector2D{ 110, 35 }, tab == 4)) tab = 4; 
		CWINGui::NextColumn(140.0f);
		//Some Elements


		if (tab == 0)
		{
			CWINGui::Checkbox(L"Toggle", &enableaim); 
			CWINGui::Checkbox(L"Memory Mode", &memory);
			CWINGui::Checkbox(L"Silent test (beta)", &test1);
			CWINGui::Checkbox(L"Only aim when player is visible", &aimbotvischeck); 
			CWINGui::Checkbox(L"Draw FOV", &drawfov); 
			CWINGui::Hotkey("Keybind", {132,32}, &KEKWNOKEY); 
			CWINGui::SliderFloat(L"Radius", &radius, 1, 2000); 
			CWINGui::ColorPicker(L"Circle color", &circlecol); 
			CWINGui::SliderFloat(L"Amount of lines in circle", &Lineamount, 10, 1000);
		}

		if (tab == 1)
		{
			CWINGui::Checkbox(L"Chams", &ChamsESP); 
			CWINGui::Checkbox(L"Bounding Boxes", &box2d); 
			CWINGui::Checkbox(L"Player Names", &PlayerNames); 
			CWINGui::Checkbox(L"Health Bar", &healthbar);
			CWINGui::Checkbox(L"Shield Bar", &shieldbar);
			CWINGui::Checkbox(L"Snap Line", &snaplinenz);
			CWINGui::Checkbox(L"Draw Allies", &chammyteam); 
			CWINGui::Checkbox(L"Outline", &bOutline); 
			CWINGui::Checkbox(L"Replace text by health", &healthcol);
			CWINGui::Checkbox(L"Current weapon", &weaponesp);
			CWINGui::ColorPicker(L"Chams Color", &MainESPColor); 
			CWINGui::ColorPicker(L"Behind Wall Color", &behind_wall_color); 
			CWINGui::ColorPicker(L"Visible Color", &visible_color); 
			CWINGui::SliderFloat(L"ESP Thickness", &ESPThickness, 1, 10);
		}

		if (tab == 2)
		{
			CWINGui::Checkbox(L"Fly (training range only)", &flyhack); 
			CWINGui::Checkbox(L"Third Person Viewmode", &thirdperson); 
		}
		 
		if (tab == 4)
		{
			CWINGui::Checkbox(L"Visible Check (Line of sight to)", &vischeck);
			CWINGui::Checkbox(L"Camera Slider", &fovchanger);
			CWINGui::SliderFloat(L"FOV", &fovchangur, 0, 300);
			CWINGui::Text(L"t.me/Nutware");
		} 

		if (InGame)
			CWINGui::Text(L"-> IN GAME");
		else
			CWINGui::Text(L"-> IN LOBBY");
		//Color Picker
	}
	//CWINGui::Draw_Cursor(menu_opened); // Dont need this ugly ass cursor
	CWINGui::Render();//Custom Render. I use it for drawing Combobox and ColorPicker over the menu 
	if (fovchanger)
		MyController->set_fov(fovchangur);
	for (int Index = 0; Index < Actors.Num(); Index++)
	{
		if (!Actors.IsValidIndex(Index) )
			continue;

		AShooterCharacter* Actor = Actors[Index];

		if (Actor->GetHealth() == 0)
			continue;

		if (!MyShooter) continue;

		if (kismentsystemlibrary::get_object_name(Actor).ToString().find("_PC") != std::string::npos)
			InGame = 1;
		else
			InGame = 0;

		USkeletalMeshComponent* Mesh = Actor->GetPawnMesh(); 
		//if (Actor->IsAlive()) continue;

		if (BaseTeamComponent::IsAlly(Actor, MyShooter))
			continue;

		if (!InGame) continue;

		if (Mesh && Actor->IsAlive())
		{ 
			FLinearColor MainColor;
			if(vischeck)
			{
				if (MyController->LineOfSightTo(Actor, { 0,0,0 }, false))
					MainColor = visible_color;
				else
					MainColor = behind_wall_color;
			}
			else
			{
				MainColor = visible_color;
			}

			if (flyhack)
			{ 
				MyShooter->ClientFly();
			}

			if (box2d)
			{
				FVector Origin, Extend;
				GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				//Render3DBox(MyController, canvas, Origin, Extend, Actor->K2_GetActorRotation(), xtest_color);
				//Draw3DBox(canvas, MyController, Origin, Extend, xtest_color);
				auto location = Actor->K2_GetActorLocation(); FVector2D footPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z + (Extend.Z / 2) }, footPos, 0)) continue;

				FVector2D headPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z - (Extend.Z / 2) }, headPos, 0)) continue;


				const float height = abs(footPos.Y - headPos.Y);
				const float width = height * 0.4f;
				FVector2D top = { headPos.X - width * 0.5f, headPos.Y };
				FVector2D bottom = { headPos.X + width * 0.5f, footPos.Y };
				DrawBox(canvas, top, bottom, MainColor);
			}

			if (thirdperson)
			{
				MyShooter->Set3pMeshVisible(1);
			}
			else 	
			{
				MyShooter->Set3pMeshVisible(0);
			}

			if (enableaim)
			{
				if (memory) // SHIT AIMBOT
				{
					static AShooterCharacter* closestEnemy = nullptr;
					static float closestDistance = 999999.9f;
					if (closestEnemy)
					{
						/* Obtain health and RelativeLocation */
						auto Health = Actor->GetHealth();
						auto RelativeLocation = Actor->K2_GetActorLocation();

						/* Define vectors */
						FVector Origin, Extend;
						GetActorBounds(Actor, 1, &Origin, &Extend, 0);

						/* W2S the vectors */
						auto location = Actor->K2_GetActorLocation(); FVector2D footPos;
						if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z + (Extend.Z) }, footPos, 0)) continue;

						FVector original_rotation = MyController->GetControlRotation();
						FVector kek3 = { location.X, location.Y, location.Z + (Extend.Z / 2) };
						FVector vector_pos =  kek3 - MyShooter->K2_GetActorLocation();
						float distance = (double)(sqrtf(vector_pos.X * vector_pos.X + vector_pos.Y * vector_pos.Y + vector_pos.Z * vector_pos.Z));
						float X, Y, Z;
						X = -((acosf(vector_pos.Z / distance) * (float)(180.0f / 3.14159265358979323846264338327950288419716939937510)) - 90.f);
						Y = atan2f(vector_pos.Y, vector_pos.X) * (float)(180.0f / 3.14159265358979323846264338327950288419716939937510);
						Z = 0; 
						{
							if (vischeck)
							{
								if(MyController->LineOfSightTo(Actor, {0,0,0}, false))
								{
									if (test1)
									{
										if (GetAsyncKeyState(KEKWNOKEY))
											MyController->SetControlRotation({ X - kekw ,Y ,Z });
										MyController->SetControlRotation(original_rotation);

									}
									else
									{
										if (GetAsyncKeyState(KEKWNOKEY))
											MyController->SetControlRotation({ X - kekw ,Y ,Z });
									}
								}
							}
							else
							{
								if (test1)
								{
									if (GetAsyncKeyState(KEKWNOKEY))
										MyController->SetControlRotation({ X - kekw ,Y ,Z });
									MyController->SetControlRotation(original_rotation);

								}
								else
								{
									if (GetAsyncKeyState(KEKWNOKEY))
										MyController->SetControlRotation({ X - kekw ,Y ,Z });
								}
							}
						}
					}
					else if (Actor)
					{
						closestEnemy = Actor;
					}
				}
			}

			if(snaplinenz)
			{
				FVector Origin, Extend;
				GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				auto location = Actor->K2_GetActorLocation(); FVector2D footPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z - (Extend.Z / 2) }, footPos, 0)) continue;

				FVector2D headPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z + (Extend.Z / 2) }, headPos, 0)) continue;

				canvas->K2_DrawLine({ (float)GetSystemMetrics(SM_CXSCREEN) / 2, (float)GetSystemMetrics(SM_CYSCREEN) }, headPos, ESPThickness, MainColor);
			}

			if (healthbar)
			{
				FVector Origin, Extend;
				GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				auto location = Actor->K2_GetActorLocation(); FVector2D footPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z - (Extend.Z / 2) }, footPos, 0)) continue;

				FVector2D headPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z + (Extend.Z / 2) }, headPos, 0)) continue;

				auto maxhealth = Actor->GetMaxHealth();
				if (maxhealth >= 100)maxhealth = 100;
				const float hp = Actor->GetHealth() / maxhealth;

				const float height = abs(footPos.Y - headPos.Y);
				const float width = height * 0.4f;
				const float width2 = width * 0.5f;
				const float adjust = height * 0.025f;
				const float len = width * hp;

				FVector2D top = { headPos.X - width * 0.5f, headPos.Y };
				FVector2D bottom = { headPos.X + width * 0.5f, footPos.Y };
				auto downleft = FVector2D{ top.X, bottom.Y };
				auto topright = FVector2D{ bottom.X, top.Y };

				auto h = bottom.Y - top.Y;
				auto w = bottom.X - top.X;
				auto thicc = ESPThickness;

				canvas->K2_DrawLinex({ headPos.X - width2, footPos.Y + adjust }, { headPos.X - width2 + len, footPos.Y + adjust * 2.f }, 5, RGBtoFLC(0, 255, 0));

			}

			if (shieldbar)
			{
				FVector Origin, Extend;
				GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				auto location = Actor->K2_GetActorLocation(); FVector2D footPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z - (Extend.Z / 2) }, footPos, 0)) continue;

				FVector2D headPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z + (Extend.Z / 2) }, headPos, 0)) continue;

				auto maxhealth = Actor->GetMaxShield();
				if (maxhealth >= 100)maxhealth = 100;
				const float hp = Actor->GetShield() / maxhealth;

				const float height = abs(footPos.Y - headPos.Y);
				const float width = height * 0.4f;
				const float width2 = width * 0.5f;
				const float adjust = height * 0.025f;
				const float len = width * hp;

				FVector2D top = { headPos.X - width * 0.5f, headPos.Y };
				FVector2D bottom = { headPos.X + width * 0.5f, footPos.Y };
				auto downleft = FVector2D{ top.X, bottom.Y };
				auto topright = FVector2D{ bottom.X, top.Y };

				auto h = bottom.Y - top.Y;
				auto w = bottom.X - top.X;
				auto thicc = ESPThickness;

				canvas->K2_DrawLinex({ headPos.X - width2, footPos.Y + adjust }, { headPos.X - width2 + len, footPos.Y + adjust * 2.f }, 5, RGBtoFLC(0, 0, 255));

			}

			if (PlayerNames)
			{
				/* Define vectors */
				FVector Origin, Extend;
				FVector2D rel2d, footPos;

				/* Get bouuuuuuunds */
				GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				/* Obtain health and RelativeLocation */ 
				auto RelativeLocation = Actor->K2_GetActorLocation();

				/* W2S the vectors */
				if (MyController->ProjectWorldLocationToScreen({ RelativeLocation.X, RelativeLocation.Y, RelativeLocation.Z - (Extend.Z / 2) }, footPos, 0))
				{
					if (MyController->ProjectWorldLocationToScreen(Actor->K2_GetActorLocation(), rel2d, true))
					{
						DrawTextRGBWithFString(canvas, character_name(kismentsystemlibrary::get_object_name(Actor)), footPos.X, footPos.Y + 10, MainColor, 1);
					}
				}
			}

			if (weaponesp)
			{
				/* Define vectors */
				FVector Origin, Extend;
				FVector2D rel2d, footPos;

				/* Get bouuuuuuunds */
				GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				/* Obtain health and RelativeLocation */ 
				auto RelativeLocation = Actor->K2_GetActorLocation();

				/* W2S the vectors */
				if (MyController->ProjectWorldLocationToScreen({ RelativeLocation.X, RelativeLocation.Y, RelativeLocation.Z + (Extend.Z / 2) }, footPos, 0))
				{
					if (MyController->ProjectWorldLocationToScreen(Actor->K2_GetActorLocation(), rel2d, true))
					{
						DrawTextRGBWithFString(canvas, weapon_name(kismentsystemlibrary::get_object_name(Actor->GetInventory()->GetCurrentWeapon())), footPos.X, footPos.Y - 30, MainColor, 1);
					}
				}
			}

			if (ChamsESP)
			{
				Mesh->SetAresOutlineMode(EAresOutlineMode::Outline, true);
				AresOutlineRendering::SetOutlineColorsForRender(World, {MainESPColor.R * 2, MainESPColor.G * 2, MainESPColor.B * 2, MainESPColor.A * 5.9f}, { MainESPColor.R * 2, MainESPColor.G * 2, MainESPColor.B * 2, MainESPColor.A * 5.9f });
			}
			else
			{
				Mesh->SetAresOutlineMode(EAresOutlineMode::None, true);
			}

		}
	}

	return pRender(_this, canvas);
}



void Init()
{
	//AllocConsole();
	//freopen("CONIN$", "r", stdin);
	//freopen("CONOUT$", "w", stdout);
	VALORANT::Module = (uintptr_t)GetModuleHandleA(0);
	uintptr_t WorldKey = *(uintptr_t*)(VALORANT::Module + Offsets::Key);
	State StateKey = *(State*)(VALORANT::Module + Offsets::State);
	UWorldXOR = Decryption::Decrypt_UWorld(WorldKey, (uintptr_t*)&StateKey);
	UWorldClass = Memory::ReadStub<UWorld*>(UWorldXOR);
	GameInstance = Memory::ReadStub<UGameInstance*>((uintptr_t)UWorldClass + 0x1A0);
	LocalPlayers = Memory::ReadStub<ULocalPlayer*>((uintptr_t)GameInstance + 0x40); //this is tarray but im paster lol
	LocalPlayer = Memory::ReadStub<ULocalPlayer*>((uintptr_t)LocalPlayers); //
	APlayerController* LocalController = Memory::ReadStub<APlayerController*>((uintptr_t)LocalPlayer + 0x38);
	uintptr_t ViewportClient = Memory::ReadStub<uintptr_t>((uintptr_t)LocalPlayer + 0x78);
	uintptr_t Engine = Memory::ReadStub<uintptr_t>((uintptr_t)GameInstance + 0x28);
	DefaultMediumFont = Memory::ReadStub<UObject*>(Engine + 0xd8);
	NamePoolData = reinterpret_cast<FNamePool*>(VALORANT::Module + NamePoolDataOffset);
	Hook::VMT((void*)ViewportClient, PostRender, 0x68, (void**)&pRender);
}
extern "C" __declspec(dllexport) int NextHook(int code, WPARAM wParam, LPARAM lParam) { return CallNextHookEx(NULL, code, wParam, lParam); }


BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
	switch (ul_reason_for_call) {
	case DLL_PROCESS_ATTACH:
		Init();
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}
// Unknownskids.me
```

`LICENSE`:

```
Mozilla Public License Version 2.0
==================================

1. Definitions
--------------

1.1. "Contributor"
    means each individual or legal entity that creates, contributes to
    the creation of, or owns Covered Software.

1.2. "Contributor Version"
    means the combination of the Contributions of others (if any) used
    by a Contributor and that particular Contributor's Contribution.

1.3. "Contribution"
    means Covered Software of a particular Contributor.

1.4. "Covered Software"
    means Source Code Form to which the initial Contributor has attached
    the notice in Exhibit A, the Executable Form of such Source Code
    Form, and Modifications of such Source Code Form, in each case
    including portions thereof.

1.5. "Incompatible With Secondary Licenses"
    means

    (a) that the initial Contributor has attached the notice described
        in Exhibit B to the Covered Software; or

    (b) that the Covered Software was made available under the terms of
        version 1.1 or earlier of the License, but not also under the
        terms of a Secondary License.

1.6. "Executable Form"
    means any form of the work other than Source Code Form.

1.7. "Larger Work"
    means a work that combines Covered Software with other material, in
    a separate file or files, that is not Covered Software.

1.8. "License"
    means this document.

1.9. "Licensable"
    means having the right to grant, to the maximum extent possible,
    whether at the time of the initial grant or subsequently, any and
    all of the rights conveyed by this License.

1.10. "Modifications"
    means any of the following:

    (a) any file in Source Code Form that results from an addition to,
        deletion from, or modification of the contents of Covered
        Software; or

    (b) any new file in Source Code Form that contains any Covered
        Software.

1.11. "Patent Claims" of a Contributor
    means any patent claim(s), including without limitation, method,
    process, and apparatus claims, in any patent Licensable by such
    Contributor that would be infringed, but for the grant of the
    License, by the making, using, selling, offering for sale, having
    made, import, or transfer of either its Contributions or its
    Contributor Version.

1.12. "Secondary License"
    means either the GNU General Public License, Version 2.0, the GNU
    Lesser General Public License, Version 2.1, the GNU Affero General
    Public License, Version 3.0, or any later versions of those
    licenses.

1.13. "Source Code Form"
    means the form of the work preferred for making modifications.

1.14. "You" (or "Your")
    means an individual or a legal entity exercising rights under this
    License. For legal entities, "You" includes any entity that
    controls, is controlled by, or is under common control with You. For
    purposes of this definition, "control" means (a) the power, direct
    or indirect, to cause the direction or management of such entity,
    whether by contract or otherwise, or (b) ownership of more than
    fifty percent (50%) of the outstanding shares or beneficial
    ownership of such entity.

2. License Grants and Conditions
--------------------------------

2.1. Grants

Each Contributor hereby grants You a world-wide, royalty-free,
non-exclusive license:

(a) under intellectual property rights (other than patent or trademark)
    Licensable by such Contributor to use, reproduce, make available,
    modify, display, perform, distribute, and otherwise exploit its
    Contributions, either on an unmodified basis, with Modifications, or
    as part of a Larger Work; and

(b) under Patent Claims of such Contributor to make, use, sell, offer
    for sale, have made, import, and otherwise transfer either its
    Contributions or its Contributor Version.

2.2. Effective Date

The licenses granted in Section 2.1 with respect to any Contribution
become effective for each Contribution on the date the Contributor first
distributes such Contribution.

2.3. Limitations on Grant Scope

The licenses granted in this Section 2 are the only rights granted under
this License. No additional rights or licenses will be implied from the
distribution or licensing of Covered Software under this License.
Notwithstanding Section 2.1(b) above, no patent license is granted by a
Contributor:

(a) for any code that a Contributor has removed from Covered Software;
    or

(b) for infringements caused by: (i) Your and any other third party's
    modifications of Covered Software, or (ii) the combination of its
    Contributions with other software (except as part of its Contributor
    Version); or

(c) under Patent Claims infringed by Covered Software in the absence of
    its Contributions.

This License does not grant any rights in the trademarks, service marks,
or logos of any Contributor (except as may be necessary to comply with
the notice requirements in Section 3.4).

2.4. Subsequent Licenses

No Contributor makes additional grants as a result of Your choice to
distribute the Covered Software under a subsequent version of this
License (see Section 10.2) or under the terms of a Secondary License (if
permitted under the terms of Section 3.3).

2.5. Representation

Each Contributor represents that the Contributor believes its
Contributions are its original creation(s) or it has sufficient rights
to grant the rights to its Contributions conveyed by this License.

2.6. Fair Use

This License is not intended to limit any rights You have under
applicable copyright doctrines of fair use, fair dealing, or other
equivalents.

2.7. Conditions

Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted
in Section 2.1.

3. Responsibilities
-------------------

3.1. Distribution of Source Form

All distribution of Covered Software in Source Code Form, including any
Modifications that You create or to which You contribute, must be under
the terms of this License. You must inform recipients that the Source
Code Form of the Covered Software is governed by the terms of this
License, and how they can obtain a copy of this License. You may not
attempt to alter or restrict the recipients' rights in the Source Code
Form.

3.2. Distribution of Executable Form

If You distribute Covered Software in Executable Form then:

(a) such Covered Software must also be made available in Source Code
    Form, as described in Section 3.1, and You must inform recipients of
    the Executable Form how they can obtain a copy of such Source Code
    Form by reasonable means in a timely manner, at a charge no more
    than the cost of distribution to the recipient; and

(b) You may distribute such Executable Form under the terms of this
    License, or sublicense it under different terms, provided that the
    license for the Executable Form does not attempt to limit or alter
    the recipients' rights in the Source Code Form under this License.

3.3. Distribution of a Larger Work

You may create and distribute a Larger Work under terms of Your choice,
provided that You also comply with the requirements of this License for
the Covered Software. If the Larger Work is a combination of Covered
Software with a work governed by one or more Secondary Licenses, and the
Covered Software is not Incompatible With Secondary Licenses, this
License permits You to additionally distribute such Covered Software
under the terms of such Secondary License(s), so that the recipient of
the Larger Work may, at their option, further distribute the Covered
Software under the terms of either this License or such Secondary
License(s).

3.4. Notices

You may not remove or alter the substance of any license notices
(including copyright notices, patent notices, disclaimers of warranty,
or limitations of liability) contained within the Source Code Form of
the Covered Software, except that You may alter any license notices to
the extent required to remedy known factual inaccuracies.

3.5. Application of Additional Terms

You may choose to offer, and to charge a fee for, warranty, support,
indemnity or liability obligations to one or more recipients of Covered
Software. However, You may do so only on Your own behalf, and not on
behalf of any Contributor. You must make it absolutely clear that any
such warranty, support, indemnity, or liability obligation is offered by
You alone, and You hereby agree to indemnify every Contributor for any
liability incurred by such Contributor as a result of warranty, support,
indemnity or liability terms You offer. You may include additional
disclaimers of warranty and limitations of liability specific to any
jurisdiction.

4. Inability to Comply Due to Statute or Regulation
---------------------------------------------------

If it is impossible for You to comply with any of the terms of this
License with respect to some or all of the Covered Software due to
statute, judicial order, or regulation then You must: (a) comply with
the terms of this License to the maximum extent possible; and (b)
describe the limitations and the code they affect. Such description must
be placed in a text file included with all distributions of the Covered
Software under this License. Except to the extent prohibited by statute
or regulation, such description must be sufficiently detailed for a
recipient of ordinary skill to be able to understand it.

5. Termination
--------------

5.1. The rights granted under this License will terminate automatically
if You fail to comply with any of its terms. However, if You become
compliant, then the rights granted under this License from a particular
Contributor are reinstated (a) provisionally, unless and until such
Contributor explicitly and finally terminates Your grants, and (b) on an
ongoing basis, if such Contributor fails to notify You of the
non-compliance by some reasonable means prior to 60 days after You have
come back into compliance. Moreover, Your grants from a particular
Contributor are reinstated on an ongoing basis if such Contributor
notifies You of the non-compliance by some reasonable means, this is the
first time You have received notice of non-compliance with this License
from such Contributor, and You become compliant prior to 30 days after
Your receipt of the notice.

5.2. If You initiate litigation against any entity by asserting a patent
infringement claim (excluding declaratory judgment actions,
counter-claims, and cross-claims) alleging that a Contributor Version
directly or indirectly infringes any patent, then the rights granted to
You by any and all Contributors for the Covered Software under Section
2.1 of this License shall terminate.

5.3. In the event of termination under Sections 5.1 or 5.2 above, all
end user license agreements (excluding distributors and resellers) which
have been validly granted by You or Your distributors under this License
prior to termination shall survive termination.

************************************************************************
*                                                                      *
*  6. Disclaimer of Warranty                                           *
*  -------------------------                                           *
*                                                                      *
*  Covered Software is provided under this License on an "as is"       *
*  basis, without warranty of any kind, either expressed, implied, or  *
*  statutory, including, without limitation, warranties that the       *
*  Covered Software is free of defects, merchantable, fit for a        *
*  particular purpose or non-infringing. The entire risk as to the     *
*  quality and performance of the Covered Software is with You.        *
*  Should any Covered Software prove defective in any respect, You     *
*  (not any Contributor) assume the cost of any necessary servicing,   *
*  repair, or correction. This disclaimer of warranty constitutes an   *
*  essential part of this License. No use of any Covered Software is   *
*  authorized under this License except under this disclaimer.         *
*                                                                      *
************************************************************************

************************************************************************
*                                                                      *
*  7. Limitation of Liability                                          *
*  --------------------------                                          *
*                                                                      *
*  Under no circumstances and under no legal theory, whether tort      *
*  (including negligence), contract, or otherwise, shall any           *
*  Contributor, or anyone who distributes Covered Software as          *
*  permitted above, be liable to You for any direct, indirect,         *
*  special, incidental, or consequential damages of any character      *
*  including, without limitation, damages for lost profits, loss of    *
*  goodwill, work stoppage, computer failure or malfunction, or any    *
*  and all other commercial damages or losses, even if such party      *
*  shall have been informed of the possibility of such damages. This   *
*  limitation of liability shall not apply to liability for death or   *
*  personal injury resulting from such party's negligence to the       *
*  extent applicable law prohibits such limitation. Some               *
*  jurisdictions do not allow the exclusion or limitation of           *
*  incidental or consequential damages, so this exclusion and          *
*  limitation may not apply to You.                                    *
*                                                                      *
************************************************************************

8. Litigation
-------------

Any litigation relating to this License may be brought only in the
courts of a jurisdiction where the defendant maintains its principal
place of business and such litigation shall be governed by laws of that
jurisdiction, without reference to its conflict-of-law provisions.
Nothing in this Section shall prevent a party's ability to bring
cross-claims or counter-claims.

9. Miscellaneous
----------------

This License represents the complete agreement concerning the subject
matter hereof. If any provision of this License is held to be
unenforceable, such provision shall be reformed only to the extent
necessary to make it enforceable. Any law or regulation which provides
that the language of a contract shall be construed against the drafter
shall not be used to construe this License against a Contributor.

10. Versions of the License
---------------------------

10.1. New Versions

Mozilla Foundation is the license steward. Except as provided in Section
10.3, no one other than the license steward has the right to modify or
publish new versions of this License. Each version will be given a
distinguishing version number.

10.2. Effect of New Versions

You may distribute the Covered Software under the terms of the version
of the License under which You originally received the Covered Software,
or under the terms of any subsequent version published by the license
steward.

10.3. Modified Versions

If you create software not governed by this License, and you want to
create a new license for such software, you may create and use a
modified version of this License if you rename the license and remove
any references to the name of the license steward (except to note that
such modified license differs from this License).

10.4. Distributing Source Code Form that is Incompatible With Secondary
Licenses

If You choose to distribute Source Code Form that is Incompatible With
Secondary Licenses under the terms of this version of the License, the
notice described in Exhibit B of this License must be attached.

Exhibit A - Source Code Form License Notice
-------------------------------------------

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.

If it is not possible or desirable to put the notice in a particular
file, then You may include the notice in a location (such as a LICENSE
file in a relevant directory) where a recipient would be likely to look
for such a notice.

You may add additional accurate notices of copyright ownership.

Exhibit B - "Incompatible With Secondary Licenses" Notice
---------------------------------------------------------

  This Source Code Form is "Incompatible With Secondary Licenses", as
  defined by the Mozilla Public License, v. 2.0.

```

`README.md`:

```md
## Valorant Internal


     
      
## ⚙ How to Setup
- You need to **create** a [Driver Kernel](https://www.youtube.com/watch?v=xh5cCUuQfL8&t=1090s&ab_channel=EthanEDITS) and when it's done you put the Source in the Driver folder.
- You can also use the Cheat's Driver but its detected, will get you banned in a few matches.
- It's time for fun / use it at your own risk 
- Other question & help / Message Me 
###### ❌ You cannot use public drivers like mapper because they are old versions. I recommend you to create your own will be the best. 
- I recommend to make your own driver.
    
     
   
## FEATURE     

#### Aimbot 
- Basic Aimbot (Works kinda shitty)
- Memory Aimbot
- Silent Aim (Beta)

#### ESP
- Box, Chams, Glow
#### Misc
- FOV Changer
#### Exploits
- ThirdPerson


##### Open - Close Menu
###### - The default is [Insert] , but you can manually switch to the button you want.

---


https://discord.gg/cheesy


(not my source just posting cause ive seen alot of rats on the valorant cheat section so im posting this for the ppl that know me)





```

`decryption.h`:

```h
#ifndef DEFS_H
#define DEFS_H
#pragma once

/*____________________________________________________________________________________________________________

Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file

skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+

							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define skCrypt(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()

/*________________________________________________________________________________

MIT License

Copyright (c) 2020 skadro

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

________________________________________________________________________________*/
#if defined(__GNUC__)
typedef          long long ll;
typedef unsigned long long ull;
#define __int64 long long
#define __int32 int
#define __int16 short
#define __int8  char
#define MAKELL(num) num ## LL
#define FMT_64 "ll"
#elif defined(_MSC_VER)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "I64"
#elif defined (__BORLANDC__)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "L"
#else
#error "unknown compiler"
#endif

typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned long ulong;

typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef ll              int64;
typedef ll              sint64;
typedef ull             uint64;

// Partially defined types. They are used when the decompiler does not know
// anything about the type except its size.
#define _BYTE  uint8
#define _WORD  uint16
#define _DWORD uint32
#define _QWORD uint64
#if !defined(_MSC_VER)
#define _LONGLONG __int128
#endif

// Non-standard boolean types. They are used when the decompiler can not use
// the standard "bool" type because of the size mistmatch but the possible
// values are only 0 and 1. See also 'BOOL' type below.
typedef int8 _BOOL1;
typedef int16 _BOOL2;
typedef int32 _BOOL4;

//#ifndef _WINDOWS_
//typedef int8 BYTE;
//typedef int16 WORD;
//typedef int32 DWORD;
//typedef int32 LONG;
//typedef int BOOL;       // uppercase BOOL is usually 4 bytes
//#endif
//typedef int64 QWORD;
#ifndef __cplusplus
typedef int bool;       // we want to use bool in our C programs
#endif

#define __pure          // pure function: always returns the same value, has no
						// side effects

// Non-returning function
#if defined(__GNUC__)
#define __noreturn  __attribute__((noreturn))
#else
#define __noreturn  __declspec(noreturn)
#endif


#ifndef NULL
#define NULL 0
#endif

// An ANSI character. 8-bit fixed-width representation of 7-bit characters.
typedef char				ANSICHAR;

// A wide character. In-memory only. ?-bit fixed-width representation of the platform's natural wide character set. Could be different sizes on different platforms.
typedef wchar_t				WIDECHAR;

// An 8-bit character type. In-memory only. 8-bit representation. Should really be char8_t but making this the generic option is easier for compilers which don't fully support C++11 yet (i.e. MSVC).
typedef uint8				CHAR8;

// A 16-bit character type. In-memory only.  16-bit representation. Should really be char16_t but making this the generic option is easier for compilers which don't fully support C++11 yet (i.e. MSVC).
typedef uint16				CHAR16;

// A 32-bit character type. In-memory only. 32-bit representation. Should really be char32_t but making this the generic option is easier for compilers which don't fully support C++11 yet (i.e. MSVC).
typedef uint32				CHAR32;

// A switchable character. In-memory only. Either ANSICHAR or WIDECHAR, depending on a licensee's requirements.
typedef WIDECHAR			TCHAR;
// Some convenience macros to make partial accesses nicer
#define LAST_IND(x,part_type)    (sizeof(x)/sizeof(part_type) - 1)
#if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN
#  define LOW_IND(x,part_type)   LAST_IND(x,part_type)
#  define HIGH_IND(x,part_type)  0
#else
#  define HIGH_IND(x,part_type)  LAST_IND(x,part_type)
#  define LOW_IND(x,part_type)   0
#endif
// first unsigned macros:
//#define LODWORD(x)  (*((DWORD*)&(x)))  // low dword
//#define HIDWORD(x)  (*((DWORD*)&(x)+1))

#define BYTEn(x, n)   (*((_BYTE*)&(x)+n))
#define WORDn(x, n)   (*((_WORD*)&(x)+n))
#define DWORDn(x, n)  (*((_DWORD*)&(x)+n))

#define LOBYTE(x)  BYTEn(x,LOW_IND(x,_BYTE))
#define LOWORD(x)  WORDn(x,LOW_IND(x,_WORD))
#define LODWORD(x) DWORDn(x,LOW_IND(x,_DWORD))
#define HIBYTE(x)  BYTEn(x,HIGH_IND(x,_BYTE))
#define HIWORD(x)  WORDn(x,HIGH_IND(x,_WORD))
#define HIDWORD(x) DWORDn(x,HIGH_IND(x,_DWORD))
#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)
#define BYTE2(x)   BYTEn(x,  2)
#define BYTE3(x)   BYTEn(x,  3)
#define BYTE4(x)   BYTEn(x,  4)
#define BYTE5(x)   BYTEn(x,  5)
#define BYTE6(x)   BYTEn(x,  6)
#define BYTE7(x)   BYTEn(x,  7)
#define BYTE8(x)   BYTEn(x,  8)
#define BYTE9(x)   BYTEn(x,  9)
#define BYTE10(x)  BYTEn(x, 10)
#define BYTE11(x)  BYTEn(x, 11)
#define BYTE12(x)  BYTEn(x, 12)
#define BYTE13(x)  BYTEn(x, 13)
#define BYTE14(x)  BYTEn(x, 14)
#define BYTE15(x)  BYTEn(x, 15)
#define WORD1(x)   WORDn(x,  1)
#define WORD2(x)   WORDn(x,  2)         // third word of the object, unsigned
#define WORD3(x)   WORDn(x,  3)
#define WORD4(x)   WORDn(x,  4)
#define WORD5(x)   WORDn(x,  5)
#define WORD6(x)   WORDn(x,  6)
#define WORD7(x)   WORDn(x,  7)

// now signed macros (the same but with sign extension)
#define SBYTEn(x, n)   (*((int8*)&(x)+n))
#define SWORDn(x, n)   (*((int16*)&(x)+n))
#define SDWORDn(x, n)  (*((int32*)&(x)+n))

#define SLOBYTE(x)  SBYTEn(x,LOW_IND(x,int8))
#define SLOWORD(x)  SWORDn(x,LOW_IND(x,int16))
#define SLODWORD(x) SDWORDn(x,LOW_IND(x,int32))
#define SHIBYTE(x)  SBYTEn(x,HIGH_IND(x,int8))
#define SHIWORD(x)  SWORDn(x,HIGH_IND(x,int16))
#define SHIDWORD(x) SDWORDn(x,HIGH_IND(x,int32))
#define SBYTE1(x)   SBYTEn(x,  1)
#define SBYTE2(x)   SBYTEn(x,  2)
#define SBYTE3(x)   SBYTEn(x,  3)
#define SBYTE4(x)   SBYTEn(x,  4)
#define SBYTE5(x)   SBYTEn(x,  5)
#define SBYTE6(x)   SBYTEn(x,  6)
#define SBYTE7(x)   SBYTEn(x,  7)
#define SBYTE8(x)   SBYTEn(x,  8)
#define SBYTE9(x)   SBYTEn(x,  9)
#define SBYTE10(x)  SBYTEn(x, 10)
#define SBYTE11(x)  SBYTEn(x, 11)
#define SBYTE12(x)  SBYTEn(x, 12)
#define SBYTE13(x)  SBYTEn(x, 13)
#define SBYTE14(x)  SBYTEn(x, 14)
#define SBYTE15(x)  SBYTEn(x, 15)
#define SWORD1(x)   SWORDn(x,  1)
#define SWORD2(x)   SWORDn(x,  2)
#define SWORD3(x)   SWORDn(x,  3)
#define SWORD4(x)   SWORDn(x,  4)
#define SWORD5(x)   SWORDn(x,  5)
#define SWORD6(x)   SWORDn(x,  6)
#define SWORD7(x)   SWORDn(x,  7)


// Helper functions to represent some assembly instructions.

#ifdef __cplusplus

// compile time assertion
#define __CASSERT_N0__(l) COMPILE_TIME_ASSERT_ ## l
#define __CASSERT_N1__(l) __CASSERT_N0__(l)
#define CASSERT(cnd) typedef char __CASSERT_N1__(__LINE__) [(cnd) ? 1 : -1]

// check that unsigned multiplication does not overflow
template<class T> bool is_mul_ok(T count, T elsize)
{
	CASSERT((T)(-1) > 0); // make sure T is unsigned
	if (elsize == 0 || count == 0)
		return true;
	return count <= ((T)(-1)) / elsize;
}

// multiplication that saturates (yields the biggest value) instead of overflowing
// such a construct is useful in "operator new[]"
template<class T> bool saturated_mul(T count, T elsize)
{
	return is_mul_ok(count, elsize) ? count * elsize : T(-1);
}

#include <stddef.h> // for size_t
#include <cstdint>

// memcpy() with determined behavoir: it always copies
// from the start to the end of the buffer
// note: it copies byte by byte, so it is not equivalent to, for example, rep movsd
inline void* qmemcpy(void* dst, const void* src, size_t cnt)
{
	char* out = (char*)dst;
	const char* in = (const char*)src;
	while (cnt > 0)
	{
		*out++ = *in++;
		--cnt;
	}
	return dst;
}

// Generate a reference to pair of operands
template<class T>  int16 __PAIR__(int8  high, T low) { return (((int16)high) << sizeof(high) * 8) | uint8(low); }
template<class T>  int32 __PAIR__(int16 high, T low) { return (((int32)high) << sizeof(high) * 8) | uint16(low); }
template<class T>  int64 __PAIR__(int32 high, T low) { return (((int64)high) << sizeof(high) * 8) | uint32(low); }
template<class T> uint16 __PAIR__(uint8  high, T low) { return (((uint16)high) << sizeof(high) * 8) | uint8(low); }
template<class T> uint32 __PAIR__(uint16 high, T low) { return (((uint32)high) << sizeof(high) * 8) | uint16(low); }
template<class T> uint64 __PAIR__(uint32 high, T low) { return (((uint64)high) << sizeof(high) * 8) | uint32(low); }

// rotate left
template<class T> T __ROL__(T value, int count)
{
	const uint nbits = sizeof(T) * 8;

	if (count > 0)
	{
		count %= nbits;
		T high = value >> (nbits - count);
		if (T(-1) < 0)
			high &= ~((T(-1) << count));
		value <<= count;
		value |= high;
	}
	else
	{
		count = -count % nbits;
		T low = value << (nbits - count);
		value >>= count;
		value |= low;
	}
	return value;
}

inline uint8  __ROL1__(uint8  value, int count) { return __ROL__((uint8)value, count); }
inline uint16 __ROL2__(uint16 value, int count) { return __ROL__((uint16)value, count); }
inline uint32 __ROL4__(uint32 value, int count) { return __ROL__((uint32)value, count); }
inline uint64 __ROL8__(uint64 value, int count) { return __ROL__((uint64)value, count); }
inline uint8  __ROR1__(uint8  value, int count) { return __ROL__((uint8)value, -count); }
inline uint16 __ROR2__(uint16 value, int count) { return __ROL__((uint16)value, -count); }
inline uint32 __ROR4__(uint32 value, int count) { return __ROL__((uint32)value, -count); }
inline uint64 __ROR8__(uint64 value, int count) { return __ROL__((uint64)value, -count); }

// carry flag of left shift
template<class T> int8 __MKCSHL__(T value, uint count)
{
	const uint nbits = sizeof(T) * 8;
	count %= nbits;

	return (value >> (nbits - count)) & 1;
}

// carry flag of right shift
template<class T> int8 __MKCSHR__(T value, uint count)
{
	return (value >> (count - 1)) & 1;
}

// sign flag
template<class T> int8 __SETS__(T x)
{
	if (sizeof(T) == 1)
		return int8(x) < 0;
	if (sizeof(T) == 2)
		return int16(x) < 0;
	if (sizeof(T) == 4)
		return int32(x) < 0;
	return int64(x) < 0;
}

// overflow flag of subtraction (x-y)
template<class T, class U> int8 __OFSUB__(T x, U y)
{
	if (sizeof(T) < sizeof(U))
	{
		U x2 = x;
		int8 sx = __SETS__(x2);
		return (sx ^ __SETS__(y)) & (sx ^ __SETS__(x2 - y));
	}
	else
	{
		T y2 = y;
		int8 sx = __SETS__(x);
		return (sx ^ __SETS__(y2)) & (sx ^ __SETS__(x - y2));
	}
}

// overflow flag of addition (x+y)
template<class T, class U> int8 __OFADD__(T x, U y)
{
	if (sizeof(T) < sizeof(U))
	{
		U x2 = x;
		int8 sx = __SETS__(x2);
		return ((1 ^ sx) ^ __SETS__(y)) & (sx ^ __SETS__(x2 + y));
	}
	else
	{
		T y2 = y;
		int8 sx = __SETS__(x);
		return ((1 ^ sx) ^ __SETS__(y2)) & (sx ^ __SETS__(x + y2));
	}
}

// carry flag of subtraction (x-y)
template<class T, class U> int8 __CFSUB__(T x, U y)
{
	int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
	if (size == 1)
		return uint8(x) < uint8(y);
	if (size == 2)
		return uint16(x) < uint16(y);
	if (size == 4)
		return uint32(x) < uint32(y);
	return uint64(x) < uint64(y);
}

// carry flag of addition (x+y)
template<class T, class U> int8 __CFADD__(T x, U y)
{
	int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
	if (size == 1)
		return uint8(x) > uint8(x + y);
	if (size == 2)
		return uint16(x) > uint16(x + y);
	if (size == 4)
		return uint32(x) > uint32(x + y);
	return uint64(x) > uint64(x + y);
}



#else
// The following definition is not quite correct because it always returns
// uint64. The above C++ functions are good, though.
#define __PAIR__(high, low) (((uint64)(high)<<sizeof(high)*8) | low)
// For C, we just provide macros, they are not quite correct.
#define __ROL__(x, y) __rotl__(x, y)      // Rotate left
#define __ROR__(x, y) __rotr__(x, y)      // Rotate right
#define __CFSHL__(x, y) invalid_operation // Generate carry flag for (x<<y)
#define __CFSHR__(x, y) invalid_operation // Generate carry flag for (x>>y)
#define __CFADD__(x, y) invalid_operation // Generate carry flag for (x+y)
#define __CFSUB__(x, y) invalid_operation // Generate carry flag for (x-y)
#define __OFADD__(x, y) invalid_operation // Generate overflow flag for (x+y)
#define __OFSUB__(x, y) invalid_operation // Generate overflow flag for (x-y)
#endif

// No definition for rcl/rcr because the carry flag is unknown
#define __RCL__(x, y)    invalid_operation // Rotate left thru carry
#define __RCR__(x, y)    invalid_operation // Rotate right thru carry
#define __MKCRCL__(x, y) invalid_operation // Generate carry flag for a RCL
#define __MKCRCR__(x, y) invalid_operation // Generate carry flag for a RCR
#define __SETP__(x, y)   invalid_operation // Generate parity flag for (x-y)

// In the decompilation listing there are some objects declarared as _UNKNOWN
// because we could not determine their types. Since the C compiler does not
// accept void item declarations, we replace them by anything of our choice,
// for example a char:

#define _UNKNOWN char

//#ifdef _MSC_VER
//#define snprintf _snprintf
//#define vsnprintf _vsnprintf
//#endif
struct State {
	uintptr_t keys[7];
};
namespace Decryption
{

	__forceinline __int64 Decrypt_UWorld(const uint32_t key, const uintptr_t* state)
	{

		unsigned __int64 v19; // r11
		unsigned __int64 v20; // r8
		unsigned __int64 v21; // r9
		unsigned int v22; // er10
		unsigned __int64 v23; // rcx
		unsigned __int64 v24; // rdx
		unsigned __int64 v25; // rcx
		int v26; // ebx
		unsigned int v27; // ecx
		__int64 v28; // rax
		unsigned __int64 v29; // r8
		unsigned __int64 v30; // r8
		unsigned __int64 v31; // rcx
		unsigned __int64 v32; // rdx
		unsigned __int64 v33; // rcx

		v19 = 2685821657736338717i64
			* ((unsigned int)key ^ (unsigned int)(key << 25) ^ (((unsigned int)key ^ ((unsigned __int64)(unsigned int)key >> 15)) >> 12))
			% 7;
		v20 = state[v19];
		v21 = (2685821657736338717i64
			* ((unsigned int)key ^ (unsigned int)(key << 25) ^ (((unsigned int)key ^ ((unsigned __int64)(unsigned int)key >> 15)) >> 12))) >> 32;
		v22 = (unsigned int)v19 % 7;
		if (!((unsigned int)v19 % 7))
		{
			v23 = (2 * (v20 - (unsigned int)(v21 - 1))) ^ ((2 * (v20 - (unsigned int)(v21 - 1))) ^ ((v20
				- (unsigned int)(v21 - 1)) >> 1)) & 0x5555555555555555i64;
			v24 = (4 * v23) ^ ((4 * v23) ^ (v23 >> 2)) & 0x3333333333333333i64;
			v25 = (16 * v24) ^ ((16 * v24) ^ (v24 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
			v20 = __ROL8__((v25 << 8) ^ ((v25 << 8) ^ (v25 >> 8)) & 0xFF00FF00FF00FFi64, 32);
		LABEL_26:
			v26 = 2 * v19;
			goto LABEL_27;
		}
		if (v22 != 1)
			goto LABEL_26;
		v26 = 2 * v19;
		v20 = __ROL8__(v20 - (unsigned int)(2 * v19 + v21), (unsigned __int8)(((int)v21 + (int)v19) % 0x3Fu) + 1);
	LABEL_27:
		v27 = v26 + v21;
		if (v22 == 2)
			v20 = ~(v20 - v27);
		switch (v22)
		{
		case 3u:
			v28 = 2 * ((2 * v20) ^ ((2 * v20) ^ (v20 >> 1)) & 0x5555555555555555i64);
			v20 = v28 ^ (v28 ^ (((2 * v20) ^ ((2 * v20) ^ (v20 >> 1)) & 0x5555555555555555i64) >> 1)) & 0x5555555555555555i64;
			break;
		case 4u:
			v29 = __ROR8__(v20, (unsigned __int8)(v27 % 0x3F) + 1);
			v20 = (2 * v29) ^ ((2 * v29) ^ (v29 >> 1)) & 0x5555555555555555i64;
			break;
		case 5u:
			v30 = __ROR8__(v20, (unsigned __int8)(v27 % 0x3F) + 1);
			v31 = (2 * v30) ^ ((2 * v30) ^ (v30 >> 1)) & 0x5555555555555555i64;
			v32 = (4 * v31) ^ ((4 * v31) ^ (v31 >> 2)) & 0x3333333333333333i64;
			v33 = (16 * v32) ^ ((16 * v32) ^ (v32 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
			v20 = __ROL8__((v33 << 8) ^ ((v33 << 8) ^ (v33 >> 8)) & 0xFF00FF00FF00FFi64, 32);
			break;
		case 6u:
			v20 = ~v20 - (unsigned int)(v21 + v19);
			break;
		}
		return v20 ^ (unsigned int)key;
	}

}
#endif
```

`discord_rpc.h`:

```h
#pragma once
#include <stdint.h>

// clang-format off

#if defined(DISCORD_DYNAMIC_LIB)
#  if defined(_WIN32)
#    if defined(DISCORD_BUILDING_SDK)
#      define DISCORD_EXPORT __declspec(dllexport)
#    else
#      define DISCORD_EXPORT __declspec(dllimport)
#    endif
#  else
#    define DISCORD_EXPORT __attribute__((visibility("default")))
#  endif
#else
#  define DISCORD_EXPORT
#endif

// clang-format on

#ifdef __cplusplus
extern "C" {
#endif

    typedef struct DiscordRichPresence {
        const char* state;   /* max 128 bytes */
        const char* details; /* max 128 bytes */
        int64_t startTimestamp;
        int64_t endTimestamp;
        const char* largeImageKey;  /* max 32 bytes */
        const char* largeImageText; /* max 128 bytes */
        const char* smallImageKey;  /* max 32 bytes */
        const char* smallImageText; /* max 128 bytes */
        const char* partyId;        /* max 128 bytes */
        int partySize;
        int partyMax;
        const char* matchSecret;    /* max 128 bytes */
        const char* joinSecret;     /* max 128 bytes */
        const char* spectateSecret; /* max 128 bytes */
        int8_t instance;
    } DiscordRichPresence;

    typedef struct DiscordJoinRequest {
        const char* userId;
        const char* username;
        const char* discriminator;
        const char* avatar;
    } DiscordJoinRequest;

    typedef struct DiscordEventHandlers {
        void (*ready)(void);
        void (*disconnected)(int errorCode, const char* message);
        void (*errored)(int errorCode, const char* message);
        void (*joinGame)(const char* joinSecret);
        void (*spectateGame)(const char* spectateSecret);
        void (*joinRequest)(const DiscordJoinRequest* request);
    } DiscordEventHandlers;

#define DISCORD_REPLY_NO 0
#define DISCORD_REPLY_YES 1
#define DISCORD_REPLY_IGNORE 2

    DISCORD_EXPORT void Discord_Initialize(const char* applicationId,
        DiscordEventHandlers* handlers,
        int autoRegister,
        const char* optionalSteamId);
    DISCORD_EXPORT void Discord_Shutdown(void);

    /* checks for incoming messages, dispatches callbacks */
    DISCORD_EXPORT void Discord_RunCallbacks(void);

    /* If you disable the lib starting its own io thread, you'll need to call this from your own */
#ifdef DISCORD_DISABLE_IO_THREAD
    DISCORD_EXPORT void Discord_UpdateConnection(void);
#endif

    DISCORD_EXPORT void Discord_UpdatePresence(const DiscordRichPresence* presence);
    DISCORD_EXPORT void Discord_ClearPresence(void);

    DISCORD_EXPORT void Discord_Respond(const char* userid, /* DISCORD_REPLY_ */ int reply);

#ifdef __cplusplus
} /* extern "C" */
#endif

```

`hook.h`:

```h
#pragma once
#include <cstdint>
namespace Hook
{
	void VMT(void* addr, void* pDes, int index, void** ret)
	{
		auto vtable = *(uintptr_t**)addr;
		int methods = 0;
		do {
			++methods;
		} while (*(uintptr_t*)((uintptr_t)vtable + (methods * 0x8)));
		auto vtable_buf = new uint64_t[methods * 0x8];
		for (auto count = 0; count < methods; ++count) {
			vtable_buf[count] = *(uintptr_t*)((uintptr_t)vtable + (count * 0x8));

			*ret = (void*)vtable[index];

			vtable_buf[index] = (uintptr_t)(pDes);
			*(uint64_t**)addr = vtable_buf;
		}
	}
}
```

`internal.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32922.545
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "internal", "internal.vcxproj", "{1998D631-50F0-4719-BA07-FEB48A9ED452}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Debug|x64.ActiveCfg = Debug|x64
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Debug|x64.Build.0 = Debug|x64
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Debug|x86.ActiveCfg = Debug|Win32
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Debug|x86.Build.0 = Debug|Win32
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Release|x64.ActiveCfg = Release|x64
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Release|x64.Build.0 = Release|x64
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Release|x86.ActiveCfg = Release|Win32
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {EFC4D86C-395B-4AC9-83D2-9D4A33E8820C}
	EndGlobalSection
EndGlobal

```

`internal.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Entry.cpp" />
    <ClCompile Include="FNamePool.h" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Alignments.h" />
    <ClInclude Include="decryption.h" />
    <ClInclude Include="Decryptor.h" />
    <ClInclude Include="discord_rpc.h" />
    <ClInclude Include="hook.h" />
    <ClInclude Include="memory.h" />
    <ClInclude Include="offsets.h" />
    <ClInclude Include="Canvas.h" />
    <ClInclude Include="Unreal.h" />
    <ClInclude Include="unrealengine.h" />
    <ClInclude Include="valorant.h" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="discord-rpc.lib" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1998d631-50f0-4719-ba07-feb48a9ed452}</ProjectGuid>
    <RootNamespace>internalforuglypasters</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Valorant</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>internal</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;INTERNALFORUGLYPASTERS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;INTERNALFORUGLYPASTERS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;INTERNALFORUGLYPASTERS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;INTERNALFORUGLYPASTERS_EXPORTS;_WINDOWS;_USRDLL;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`internal.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Entry.cpp" />
    <ClCompile Include="Cloud.cpp">
      <Filter>Authentication</Filter>
    </ClCompile>
    <ClCompile Include="FNamePool.h">
      <Filter>Decryption</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="decryption.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="hook.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="offsets.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Canvas.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="unrealengine.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="valorant.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Unreal.h">
      <Filter>Engine</Filter>
    </ClInclude>
    <ClInclude Include="Alignments.h">
      <Filter>Decryption</Filter>
    </ClInclude>
    <ClInclude Include="Decryptor.h">
      <Filter>Decryption</Filter>
    </ClInclude>
    <ClInclude Include="discord_rpc.h">
      <Filter>RPC</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Headers">
      <UniqueIdentifier>{0ff10ebb-01d8-4b4e-9e0a-b32145221c23}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine">
      <UniqueIdentifier>{b63e63fe-d5ad-4d81-a447-37a2d7ea0813}</UniqueIdentifier>
    </Filter>
    <Filter Include="Authentication">
      <UniqueIdentifier>{36659c19-e21f-4e6a-a0b6-38055fcbe2a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Decryption">
      <UniqueIdentifier>{a71d89b5-403c-4366-a46c-c9163a4ba2ae}</UniqueIdentifier>
    </Filter>
    <Filter Include="RPC">
      <UniqueIdentifier>{6041810d-05f2-4fe2-8ada-1a0bd9d4ec5c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Library Include="discord-rpc.lib">
      <Filter>RPC</Filter>
    </Library>
  </ItemGroup>
</Project>
```

`internal.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`memory.h`:

```h
#pragma once
#include <cstdint>
#include "offsets.h"
#include "valorant.h"
namespace Memory
{
	template <typename T>
	T ReadStub(std::uintptr_t Address)
	{
		return reinterpret_cast<T(*)(std::uintptr_t)>(VALORANT::Module + Offsets::TriggerVEH)(Address - 0x8);
	}
	//template <typename T>
	//void WriteStub(std::uintptr_t Address, T other)
	//{
	//	reinterpret_cast<T(*)(std::uintptr_t)>(VALORANT::Module + Offsets::TriggerVEH)(Address - 0x8) = other;
	//}
}
```

`offsets.h`:

```h
#pragma once
namespace Offsets
{
	constexpr auto
		Key = 0x9005C00, //uworld_key 
		State = 0x8E73B00,  //uworld_state 
		ProcessEvent = 0x3322680,
		StaticFindObject = 0x3360890,
		TriggerVEH = 0x1B6D880,
		GetActorBounds = 0x478ADC0;  //void GetActorBounds(bool bOnlyCollidingComponents, struct FVector& Origin, struct FVector& BoxExtent, bool bIncludeFromChildActors); // Function Engine.Actor.GetActorBounds // (Final|Native|Public|HasOutParms|HasDefaults|BlueprintCallable|BlueprintPure|Const)
}

```

`sdk.h`:

```h
#pragma once
#include "memory.h"
#include "unrealengine.h"
class UObject
{
public:
	char padding_01[0x18];
	int32_t ComparisonIndex;
	static UObject* StaticFindObject(UObject* Class, UObject* InOuter, const wchar_t* Name, bool ExactClass)
	{
		static uintptr_t StaticFindObjectAddress = VALORANT::Module + Offsets::StaticFindObject;

		auto StaticFindObjectFN = reinterpret_cast<UObject * (__fastcall*)(UObject*, UObject*, const wchar_t*, bool)>(StaticFindObjectAddress);

		return StaticFindObjectFN(Class, InOuter, Name, ExactClass);
	}
	static void ProcessEvent(void* class_, UObject* function, void* params)
	{
		reinterpret_cast<void (*)(void*, UObject*, void*)>(VALORANT::Module + Offsets::ProcessEvent)(class_, function, params);
	}
};

struct UWorld
{

};

struct UFont : UObject
{

};

UObject* DefaultMediumFont;
struct UEngine
{

};
bool bOutline = 1;
struct UCanvas
{
	void K2_DrawLine(struct FVector2D ScreenPositionA, struct FVector2D ScreenPositionB, float Thickness, struct FLinearColor RenderColor)
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Canvas.K2_DrawLine", false);


		struct {
			FVector2D ScreenPositionA;
			FVector2D ScreenPositionB;
			float Thickness;
			FLinearColor RenderColor;
		}Args;
		Args.ScreenPositionA = ScreenPositionA;
		Args.ScreenPositionB = ScreenPositionB;
		Args.Thickness = Thickness;
		Args.RenderColor = RenderColor; 
		function->ProcessEvent(this, function, &Args);
	}
	void K2_DrawLinex(FVector2D ScreenPositionA, FVector2D ScreenPositionB, float Thickness, FLinearColor RenderColor) // CRT af doe (ironic.)
	{
		if(bOutline)
		{
			K2_DrawLine({ ScreenPositionA.X + 1, ScreenPositionA.Y }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
			K2_DrawLine({ ScreenPositionA.X - 1, ScreenPositionA.Y }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
			K2_DrawLine({ ScreenPositionA.X, ScreenPositionA.Y + 1 }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
			K2_DrawLine({ ScreenPositionA.X, ScreenPositionA.Y - 1 }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
		}
		K2_DrawLine({ ScreenPositionA.X, ScreenPositionA.Y }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, RenderColor);
	}
	void K2_DrawText(struct FString RenderText, struct FVector2D ScreenPosition, struct FVector2D Scale, struct FLinearColor RenderColor, float Kerning, struct FLinearColor ShadowColor, struct FVector2D ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, struct FLinearColor OutlineColor)
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Canvas.K2_DrawText", false);
		if(!DefaultMediumFont) 
			DefaultMediumFont = UObject::StaticFindObject(nullptr, nullptr, L"/Engine/EngineFonts/Roboto.Roboto", false);
		struct {
			UObject* RenderFont;
			FString RenderText;
			FVector2D ScreenPosition;
			FVector2D Scale;
			FLinearColor RenderColor;
			float Kerning;
			FLinearColor ShadowColor;
			FVector2D ShadowOffset;
			bool bCentreX;
			bool bCentreY;
			bool bOutlined;
			FLinearColor OutlineColor;
		}Args;
		Args.RenderFont = DefaultMediumFont;
		Args.RenderText = RenderText;
		Args.ScreenPosition = ScreenPosition;
		Args.Scale = Scale;
		Args.RenderColor = RenderColor;
		Args.Kerning = Kerning;
		Args.ShadowColor = ShadowColor;
		Args.ShadowOffset = ShadowOffset;
		Args.bCentreX = bCentreX;
		Args.bCentreY = bCentreY;
		Args.bOutlined = bOutlined;
		Args.OutlineColor = OutlineColor; 
		function->ProcessEvent(this, function, &Args);
	}
};

struct UGameInstance
{

};

struct ULocalPlayer
{

};

struct FBoxSphereBounds {
	FVector Origin;
	FVector BoxExtent;
	float SphereRadius;
};

struct FBox {
	FVector Min;
	FVector Max;

	FBox() {

		Min.X = NULL;
		Min.Y = NULL;
		Min.Z = NULL;
		
		Max.X = NULL;
		Max.Y = NULL;
		Max.Z = NULL;
	}
};

struct UStaticMeshComponent
{
	FBox GetBoundingBox()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.StaticMesh.GetBoundingBox", false);
		if (!Function)
		{
			return FBox();
		}
		struct
		{
			FBox ReturnValue;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.ReturnValue;
	}
};

struct USkeletalMeshComponent
{

	void SetAresOutlineMode(EAresOutlineMode Mode, bool bPropagateToChildren)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.MeshComponent.SetAresOutlineMode", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			EAresOutlineMode Mode;
			bool bPropagateToChildren;
		}Parameters;
		Parameters.Mode = Mode;
		Parameters.bPropagateToChildren = bPropagateToChildren;
		Function->ProcessEvent(this, Function, &Parameters);
	}
};

DWORD64 ProjectWorldToScreen;

struct APlayerState
{
	FString GetPlayerName()
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.PlayerState.GetPlayerName", false);
		if (!function)
			return L"AAresPlayerCharacter_PC_C";

		struct {
			FString Return;
		}Args;
		function->ProcessEvent(this, function, &Args);
		return Args.Return;
	}
};


struct FQuat
{
public:

	float X, Y, Z, W;

	FQuat() : X(0.f), Y(0.f), Z(0.f), W(0.f) {};

	FQuat(float InX, float InY, float InZ, float InW) : X(InX), Y(InY), Z(InZ), W(InW) {}

	FQuat(struct FRotator& R);

	FVector RotateVector(const struct FVector& V) const;
};
struct FRotator
{
	float Pitch, Yaw, Roll;

	FRotator()
		: Pitch(0), Yaw(0), Roll(0)
	{ }

	FRotator(float pitch, float yaw, float roll) : Pitch(pitch), Yaw(yaw), Roll(roll) {}

	FRotator operator+ (const FRotator& other) const { return FRotator(Pitch + other.Pitch, Yaw + other.Yaw, Roll + other.Roll); }

	FRotator operator- (const FRotator& other) const { return FRotator(Pitch - other.Pitch, Yaw - other.Yaw, Roll - other.Roll); }

	FRotator operator* (float scalar) const { return FRotator(Pitch * scalar, Yaw * scalar, Roll * scalar); }

	FRotator& operator=  (const FRotator& other) { Pitch = other.Pitch; Yaw = other.Yaw; Roll = other.Roll; return *this; }

	FRotator& operator+= (const FRotator& other) { Pitch += other.Pitch; Yaw += other.Yaw; Roll += other.Roll; return *this; }

	FRotator& operator-= (const FRotator& other) { Pitch -= other.Pitch; Yaw -= other.Yaw; Roll -= other.Roll; return *this; }

	FRotator& operator*= (const float other) { Yaw *= other; Pitch *= other; Roll *= other; return *this; }

	struct FQuat Quaternion() const;
};

constexpr auto PI = 3.1415926535897932f;
constexpr auto FLOAT_NON_FRACTIONAL = 8388608.f /* All single-precision floating point numbers greater than or equal to this have no fractional value. */;
constexpr auto INV_PI = 0.31830988618f;
constexpr auto HALF_PI = 1.57079632679f;
constexpr auto DEG_TO_RAD = PI / 180.f;
constexpr auto RADS_DIVIDED_BY_2 = DEG_TO_RAD / 2.f;

namespace classes {
	namespace defines {
		static UObject* system = nullptr;
		static UObject* game_statics = nullptr;
		static UObject* blueprint = nullptr;
		static UObject* content_library = nullptr;
	}

	static inline void init() {
		defines::system = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Default__KismetSystemLibrary", false);
		defines::game_statics = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Default__GameplayStatics", false);
		defines::blueprint = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ShooterBlueprintLibrary", false);
		defines::content_library = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ContentLibrary", false);
	}
}

namespace kismentsystemlibrary
{
	UObject* static_class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"Engine.Default__KismetSystemLibrary", false);
	}

	FString get_object_name(UObject* obj)
	{
		UObject* functions = UObject::StaticFindObject(nullptr, nullptr, L"Engine.KismentSystemLibrary.GetObjectName", false);
		if (!functions)
			return L"N/A";
		struct
		{
			UObject* obj;
			FString out;
		}Args;
		Args.obj = obj;
		functions->ProcessEvent(static_class(), functions, &Args);
		return Args.out;
	}
}
struct FMath {
	static __forceinline void SinCos(float* ScalarSin, float* ScalarCos, float  Value);
	static __forceinline float Fmod(float X, float Y);
	template<class T>
	static __forceinline T Clamp(const T X, const T Min, const T Max) { return X < Min ? Min : X < Max ? X : Max; }
};

struct FTransform
{
	FQuat Rotation;
	FVector Translation;
	char UnknownData00[0x4];
	FVector Scale3D;
	char UnknownData01[0x4];

	/** Default constructor. */
	FTransform() : Rotation(0.f, 0.f, 0.f, 1.f), Translation(0.f), Scale3D(FVector::OneVector) {};
	 
	FVector TransformPosition(FVector& V) const;

	FTransform(const FRotator& InRotation) : Rotation(InRotation.Quaternion()), Translation(FVector::ZeroVector), Scale3D(FVector::OneVector) {};
};


struct AShooterCharacter : UObject
{
	void ClientFly()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.ClientFly", false);
		if (!Function)
		{
			return;
		}
		struct
		{
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	void Set3pMeshVisible(bool val)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.Set3PMeshVisible", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			bool a1;
		}Parameters;
		Parameters.a1 = val;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	APlayerState* GetPlayerState()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetPlayerState", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			APlayerState* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}

	int32_t GetMaxHealth()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetMaxHealth", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			int32_t Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	float GetHealth()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetHealth", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			float Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	FVector K2_GetActorLocation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Actor.K2_GetActorLocation", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			FVector Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	FRotator K2_GetActorRotation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Actor.K2_GetActorRotation", false);
		if (!Function)
		{
			return {0,0,0};
		}
		struct
		{
			FRotator Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	USkeletalMeshComponent* GetPawnMesh()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetPawnMesh", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			USkeletalMeshComponent* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}

	APlayerState* GetState()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetPlayerState", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			APlayerState* KekState;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.KekState;
	}
	bool IsAlive()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.IsAlive", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			bool Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};

struct APlayerCameraManager
{
	FVector GetCameraLocation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.PlayerCameraManager.GetCameraLocation", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			FVector Out;
		}Parameters; 
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};
struct APlayerController : UObject
{
	bool LineOfSightTo(AShooterCharacter* Actor, FVector ViewPoint, bool bAlternateChecks)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Controller.LineOfSightTo", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			AShooterCharacter* Actor;
			FVector ViewPoint;
			bool bAlternateChecks;
			bool Out;
		}Parameters;
		Parameters.Actor = Actor;
		Parameters.ViewPoint = ViewPoint;
		Parameters.bAlternateChecks = bAlternateChecks;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	void ExecSetCameraRotator(FRotator NewRot)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Controller.SetControlRotation", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			FRotator Rot;
		}Parameters;
		Parameters.Rot = NewRot;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	bool ProjectWorldLocationToScreen(struct FVector WorldLocation, struct FVector2D& ScreenLocation, bool bPlayerViewportRelative)
	{  
		if (!ProjectWorldToScreen)
			ProjectWorldToScreen = (uintptr_t)GetModuleHandleA(0) + 0x4fd7c60;
		auto WorldToScreen = reinterpret_cast<bool(__fastcall*)(uintptr_t pPlayerController, FVector vWorldPos, FVector2D * vScreenPosOut, char)>(ProjectWorldToScreen);

		WorldToScreen((uintptr_t)this, WorldLocation, &ScreenLocation, (char)0);
		 
		return WorldToScreen;
	}
	void set_fov(float fov)
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresPlayerController.SetFOV", false);


		struct {
			float fov;
		}Args;
		Args.fov = fov;
		function->ProcessEvent(this, function, &Args);
	}

	AShooterCharacter* GetShooterCharacter()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresPlayerController.GetShooterCharacter", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			AShooterCharacter* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};

struct AController
{
};
namespace ShooterGameBlueprints
{
	UObject* Static_Class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ShooterBlueprintLibrary", false);
	}

	APlayerController* GetFirstLocalPlayerController(UWorld* WorldContextObject)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterBlueprintLibrary.GetFirstLocalPlayerController", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			UWorld* WorldContextObject;
			APlayerController* Out;
		}Parameters;
		Parameters.WorldContextObject = WorldContextObject;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return Parameters.Out;
	}
	TArray<AShooterCharacter*> FindAllShooterCharactersWithAlliance(UWorld* WorldContextObject, AShooterCharacter* LocalViewer, EAresAlliance Alliance, bool OnlyPlayerControlled, bool OnlyAlivePlayers)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterBlueprintLibrary.FindAllShooterCharactersWithAlliance", false);
		struct
		{
			UWorld* WorldContextObject;
			AShooterCharacter* LocalViewer;
			EAresAlliance Alliance;
			bool OnlyPlayerControlled;
			bool OnlyAlivePlayers;
			TArray<AShooterCharacter*> Out;
		}Parameters;
		Parameters.WorldContextObject = WorldContextObject;
		Parameters.LocalViewer = LocalViewer;
		Parameters.Alliance = Alliance;
		Parameters.OnlyPlayerControlled = OnlyPlayerControlled;
		Parameters.OnlyAlivePlayers = OnlyAlivePlayers;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return Parameters.Out;
	}
}

namespace AresOutlineRendering
{
	UObject* Static_Class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"Renderer.Default__AresOutlineRendering", false);
	}

	void SetOutlineColorsForRender(UWorld* WorldContextObject, FLinearColor AllyColor, FLinearColor EnemyColor)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Renderer.AresOutlineRendering.SetOutlineColorsForRender", false);
		if (!Function)
		{
			return;
		}
		struct {
			UWorld* WorldContextObject;
			FLinearColor AllyColor;
			FLinearColor EnemyColor;
		}Parameters;
		Parameters.WorldContextObject = WorldContextObject;
		Parameters.AllyColor = AllyColor;
		Parameters.EnemyColor = EnemyColor;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
	}
}

namespace BaseTeamComponent
{
	UObject* Static_Class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__BaseTeamComponent", false);
	}

	bool IsAlly(AShooterCharacter* Enemy, AShooterCharacter* Self)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.BaseTeamComponent.IsAlly", false);
		struct {
			AShooterCharacter* Enemy;
			AShooterCharacter* Self;
			bool ReturnValue;
		}Parameters;
		Parameters.Enemy = Enemy;
		Parameters.Self = Self;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return Parameters.ReturnValue;
	}
}
#pragma once
#include <Windows.h>

namespace CWINGui
{
	namespace Input
	{
		bool mouseDown[5];
		bool mouseDownAlready[256];

		bool keysDown[256];
		bool keysDownAlready[256];

		bool IsAnyMouseDown()
		{
			if (mouseDown[0]) return true;
			if (mouseDown[1]) return true;
			if (mouseDown[2]) return true;
			if (mouseDown[3]) return true;
			if (mouseDown[4]) return true;

			return false;
		}

		bool IsMouseClicked(int button, int element_id, bool repeat)
		{
			if (mouseDown[button])
			{
				if (!mouseDownAlready[element_id])
				{
					mouseDownAlready[element_id] = true;
					return true;
				}
				if (repeat)
					return true;
			}
			else
			{
				mouseDownAlready[element_id] = false;
			}
			return false;
		}
		bool IsKeyPressed(int key, bool repeat)
		{
			if (keysDown[key])
			{
				if (!keysDownAlready[key])
				{
					keysDownAlready[key] = true;
					return true;
				}
				if (repeat)
					return true;
			}
			else
			{
				keysDownAlready[key] = false;
			}
			return false;
		}

		void Handle()
		{
			if (GetAsyncKeyState(0x01))
				mouseDown[0] = true;
			else
				mouseDown[0] = false;
		}
	}
}

wchar_t* s2wc(const char* c)
{
	const size_t cSize = strlen(c) + 1;
	wchar_t* wc = new wchar_t[cSize];
	mbstowcs(wc, c, cSize);

	return wc;
}

namespace CWINGui
{
	FLinearColor RGBtoFLC69(float R, float G, float B, float A = 255)
	{
		return { R / 255, G / 255, B / 255, A / 255 };
	}
	namespace Colors
	{
		FLinearColor Text{ 1.0f, 1.0f, 1.0f, 1.0f };
		FLinearColor Text_Shadow{ 0.0f, 0.0f, 0.0f, 0.0f };
		FLinearColor Text_Outline{ 0.0f, 0.0f, 0.0f, 0.30f };

		FLinearColor Window_Background{ 0.009f, 0.009f, 0.009f, 1.0f };
		FLinearColor Window_Header{ 0.10f, 0.15f, 0.84f, 1.0f };

		FLinearColor Button_Idle{ 0.10f, 0.15f, 0.84f, 1.0f };
		FLinearColor Button_Hovered{ 0.15f, 0.20f, 0.89f, 1.0f };
		FLinearColor Button_Active{ 0.20f, 0.25f, 0.94f, 1.0f };

		FLinearColor Checkbox_Idle{ 0.0f,0.0f,0.0f,1.0f };
		FLinearColor Checkbox_Hovered{ 1.0f,1.0f,1.0f,1.0f };
		FLinearColor Checkbox_Enabled{ 1.0f,1.0f,1.0f,1.0f };

		FLinearColor Combobox_Idle{ 0.17f, 0.16f, 0.23f, 1.0f };
		FLinearColor Combobox_Hovered{ 0.17f, 0.16f, 0.23f, 1.0f };
		FLinearColor Combobox_Elements{ 0.239f, 0.42f, 0.82f, 1.0f };

		FLinearColor Slider_Idle{ 1.0f,1.0f,1.0f,1.0f };
		FLinearColor Slider_Hovered{ 1.0f,1.0f,1.0f,1.0f };
		FLinearColor Slider_Progress{ 0.0f,0.0f,0.0f,1.0f };
		FLinearColor Slider_Button{ 0.0f,0.0f,0.0f,1.0f };

		FLinearColor ColorPicker_Background{ 0.0f,0.0f,0.0f,1.0f };
	}

	namespace PostRenderer
	{
		struct DrawList
		{
			int type = -1; //1 = FilledRect, 2 = TextLeft, 3 = TextCenter, 4 = Draw_Line
			FVector2D pos;
			FVector2D size;
			FLinearColor color;
			char* name;
			bool outline;

			FVector2D from;
			FVector2D to;
			int thickness;
		};
		DrawList drawlist[128];

		void drawFilledRect(FVector2D pos, float w, float h, FLinearColor color)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 1;
					drawlist[i].pos = pos;
					drawlist[i].size = FVector2D{ w, h };
					drawlist[i].color = color;
					return;
				}
			}
		}
		void TextLeft(char* name, FVector2D pos, FLinearColor color, bool outline)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 2;
					drawlist[i].name = name;
					drawlist[i].pos = pos;
					drawlist[i].outline = outline;
					drawlist[i].color = color;
					return;
				}
			}
		}
		void TextCenter(char* name, FVector2D pos, FLinearColor color, bool outline)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 3;
					drawlist[i].name = name;
					drawlist[i].pos = pos;
					drawlist[i].outline = outline;
					drawlist[i].color = color;
					return;
				}
			}
		}
		void Draw_Line(FVector2D from, FVector2D to, int thickness, FLinearColor color)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 4;
					drawlist[i].from = from;
					drawlist[i].to = to;
					drawlist[i].thickness = thickness;
					drawlist[i].color = color;
					return;
				}
			}
		}
	}

	UCanvas* canvas;


	bool hover_element = false;
	FVector2D menu_pos = FVector2D{ 0, 0 };
	float offset_x = 0.0f;
	float offset_y = 0.0f;

	FVector2D first_element_pos = FVector2D{ 0, 0 };

	FVector2D last_element_pos = FVector2D{ 0, 0 };
	FVector2D last_element_size = FVector2D{ 0, 0 };

	int current_element = -1;
	FVector2D current_element_pos = FVector2D{ 0, 0 };
	FVector2D current_element_size = FVector2D{ 0, 0 };
	int elements_count = 0;

	bool sameLine = false;

	bool pushY = false;
	float pushYvalue = 0.0f;

	void SetupCanvas(UCanvas* _canvas)
	{
		canvas = _canvas;
	}

	FVector2D CursorPos()
	{
		POINT cursorPos;
		GetCursorPos(&cursorPos);
		return FVector2D{ (float)cursorPos.x, (float)cursorPos.y };
	}
	bool MouseInZone(FVector2D pos, FVector2D size)
	{
		FVector2D cursor_pos = CursorPos();

		if (cursor_pos.X > pos.X && cursor_pos.Y > pos.Y)
			if (cursor_pos.X < pos.X + size.X && cursor_pos.Y < pos.Y + size.Y)
				return true;

		return false;
	}

	void Draw_Cursor(bool toogle)
	{
		if (toogle)
		{
			FVector2D cursorPos = CursorPos();
			canvas->K2_DrawLine(FVector2D{ cursorPos.X, cursorPos.Y }, FVector2D{ cursorPos.X + 35, cursorPos.Y + 10 }, 1, FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });


			int x = 35;
			int y = 10;
			while (y != 30) //20 steps
			{
				x -= 1; if (x < 15) x = 15;
				y += 1; if (y > 30) y = 30;

				canvas->K2_DrawLine(FVector2D{ cursorPos.X, cursorPos.Y }, FVector2D{ cursorPos.X + x, cursorPos.Y + y }, 1, FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
			}

			canvas->K2_DrawLine(FVector2D{ cursorPos.X, cursorPos.Y }, FVector2D{ cursorPos.X + 15, cursorPos.Y + 30 }, 1, FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
			canvas->K2_DrawLine(FVector2D{ cursorPos.X + 35, cursorPos.Y + 10 }, FVector2D{ cursorPos.X + 15, cursorPos.Y + 30 }, 1, FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
		}
	}

	void SameLine()
	{
		sameLine = true;
	}
	void PushNextElementY(float y, bool from_last_element = true)
	{
		pushY = true;
		if (from_last_element)
			pushYvalue = last_element_pos.Y + last_element_size.Y + y;
		else
			pushYvalue = y;
	}
	void NextColumn(float x)
	{
		offset_x = x;
		PushNextElementY(first_element_pos.Y, false);
	}
	void ClearFirstPos()
	{
		first_element_pos = FVector2D{ 0, 0 };
	}

	void xDrawTextRGB(const wchar_t* text, float x, float y, FLinearColor color)
	{
		canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, { 0.f,0.f,0.f,1.0f }, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, 0, 0, 0, { 0, 0, 0, 1 });
	}
	void yDrawTextRGB(const wchar_t* text, float x, float y, FLinearColor color)
	{
		canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, {0.f,0.f,0.f,1.0f}, 0.f, {0, 0, 0, 1}, {0, 0}, 1, 0, 0, {0, 0, 0, 1});
	}
	void TextLeft(const wchar_t* name, FVector2D pos, FLinearColor color, bool outline)
	{ 
		xDrawTextRGB(name, pos.X, pos.Y, {1,1,1,1});
	}
	void TextCenter(const wchar_t* name, FVector2D pos, FLinearColor color, bool outline, bool kekw = 0)
	{
		if(kekw)
			yDrawTextRGB(name, pos.X, pos.Y - 10, color);
		else
			yDrawTextRGB(name, pos.X, pos.Y - 10, {0.f,0.f,0.f,1.0f});
	}

	void GetColor(FLinearColor* color, float* r, float* g, float* b, float* a)
	{
		*r = color->R;
		*g = color->G;
		*b = color->B;
		*a = color->A;
	}
	UINT32 GetColorUINT(int r, int g, int b, int a)
	{
		UINT32 result = (BYTE(a) << 24) + (BYTE(r) << 16) + (BYTE(g) << 8) + BYTE(b);
		return result;
	}

	void Draw_Line(FVector2D from, FVector2D to, int thickness, FLinearColor color)
	{
		canvas->K2_DrawLine(FVector2D{ from.X, from.Y }, FVector2D{ to.X, to.Y }, thickness, color);
	}
	void drawFilledRect(FVector2D initial_pos, float w, float h, FLinearColor color)
	{
		for (float i = 0.0f; i < h; i += 1.0f)
			canvas->K2_DrawLine(FVector2D{ initial_pos.X, initial_pos.Y + i }, FVector2D{ initial_pos.X + w, initial_pos.Y + i }, 1.0f, color);
	}
	void DrawFilledCircle(FVector2D pos, float r, FLinearColor color)
	{
		float smooth = 0.07f;

		double PI = 3.14159265359;
		int size = (int)(2.0f * PI / smooth) + 1;

		float angle = 0.0f;
		int i = 0;

		for (; angle < 2 * PI; angle += smooth, i++)
		{
			Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ pos.X + cosf(angle) * r, pos.Y + sinf(angle) * r }, 1.0f, color);
		}
	}
	void DrawCircle(FVector2D pos, int radius, int numSides, FLinearColor Color)
	{
		float PI = 3.1415927f;

		float Step = PI * 2.0 / numSides;
		int Count = 0;
		FVector2D V[128];
		for (float a = 0; a < PI * 2.0; a += Step) {
			float X1 = radius * cos(a) + pos.X;
			float Y1 = radius * sin(a) + pos.Y;
			float X2 = radius * cos(a + Step) + pos.X;
			float Y2 = radius * sin(a + Step) + pos.Y;
			V[Count].X = X1;
			V[Count].Y = Y1;
			V[Count + 1].X = X2;
			V[Count + 1].Y = Y2;
			//Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ X2, Y2 }, 1.0f, Color); // Points from Centre to ends of circle
			Draw_Line(FVector2D{ V[Count].X, V[Count].Y }, FVector2D{ X2, Y2 }, 1.0f, Color);// Circle Around
		}
	}

	FVector2D dragPos;
	bool Window(const char* name, FVector2D* pos, FVector2D size, bool isOpen)
	{
		elements_count = 0;

		if (!isOpen)
			return false;

		bool isHovered = MouseInZone(FVector2D{ pos->X, pos->Y }, size);

		//Drop last element
		if (current_element != -1 && !GetAsyncKeyState(0x1))
		{
			current_element = -1;
		}

		//Drag
		if (hover_element && GetAsyncKeyState(0x1))
		{

		}
		else if ((isHovered || dragPos.X != 0) && !hover_element)
		{
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				FVector2D cursorPos = CursorPos();

				cursorPos.X -= size.X;
				cursorPos.Y -= size.Y;

				if (dragPos.X == 0)
				{
					dragPos.X = (cursorPos.X - pos->X);
					dragPos.Y = (cursorPos.Y - pos->Y);
				}
				pos->X = cursorPos.X - dragPos.X;
				pos->Y = cursorPos.Y - dragPos.Y;
			}
			else
			{
				dragPos = FVector2D{ 0, 0 };
			}
		}
		else
		{
			hover_element = false;
		}


		offset_x = 0.0f; offset_y = 0.0f;
		menu_pos = FVector2D{ pos->X, pos->Y };
		first_element_pos = FVector2D{ 0, 0 };
		current_element_pos = FVector2D{ 0, 0 };
		current_element_size = FVector2D{ 0, 0 };

		//Bg
		drawFilledRect(FVector2D{ pos->X, pos->Y }, size.X, size.Y, RGBtoFLC69(255,255,255));
		//drawFilledRect(FVector2D{ pos->X, pos->Y }, 122, size.Y, FLinearColor{ 0.006f, 0.006f, 0.006f, 1.0f });//My tabs bg

		//Header
		//drawFilledRect(FVector2D{ pos->X, pos->Y }, size.X, 25.0f, RGBtoFLC69(255,0,0));

		offset_y += 25.0f;

		//Title
		FVector2D titlePos = FVector2D{ pos->X + size.X / 2, pos->Y + 25 / 2 };
		TextLeft(s2wc(name), titlePos, FLinearColor{0.0f,0.0f,0.0f,0.0f}, false);

		return true;
	}

	void Text(const wchar_t* text, bool center = false, bool outline = false)
	{
		elements_count++;

		float size = 25;
		FVector2D padding = FVector2D{ 10, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}

		if (!sameLine)
			offset_y += size + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + 5.0f, pos.Y + size / 2 };
		if (center)
			TextCenter(text, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);
		else
			TextLeft(text, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);

		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}
	bool ButtonTab(const wchar_t* name, FVector2D size, bool active)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 5, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X ;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (active)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y,  RGBtoFLC69(255,0,0,160));
		}
		else if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, RGBtoFLC69(255, 0, 0, 180));
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, RGBtoFLC69(255, 0, 0, 255));
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
		if(active)
			TextCenter(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, 1);
		else
			TextCenter(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, 1);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			return true;

		return false;
	}
	bool Button(const wchar_t* name, FVector2D size)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 5, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
		//if (!TextOverlapedFromActiveElement(textPos))
		TextCenter(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			return true;

		return false;
	}
	void Checkbox(const wchar_t* name, bool* value)
	{
		elements_count++;

		float size = 18;
		FVector2D padding = FVector2D{ 10, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, FVector2D{ size, size });

		//Bg
		if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X + 3, pos.Y + 3 }, size - 6, size - 6, Colors::Checkbox_Enabled);
		}

		if (!sameLine)
			offset_y += size + padding.Y;

		if (*value)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Idle);
			//drawFilledRect(FVector2D{ pos.X + 9, pos.Y + 9 }, size - 18, size - 18, Colors::Checkbox_Hovered);
		}



		//Text
		FVector2D textPos = FVector2D{ pos.X + size + 5.0f, pos.Y  };
		//if (!TextOverlapedFromActiveElement(textPos))
		TextLeft(name, textPos, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			*value = !*value;
	}
	void SliderInt(char* name, int* value, int min, int max)
	{
		elements_count++;

		FVector2D size = FVector2D{ 240, 50 };
		FVector2D slider_size = FVector2D{ 200, 10 };
		FVector2D padding = FVector2D{ 10, 15 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size);

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Bg
		if (isHovered || current_element == elements_count)
		{
			//Drag
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				current_element = elements_count;

				FVector2D cursorPos = CursorPos();
				*value = ((cursorPos.X - pos.X) * ((max - min) / slider_size.X)) + min;
				if (*value < min) *value = min;
				if (*value > max) *value = max;
			}

			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Hovered);
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress);

			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Idle);
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress);
		}


		//Value
		float oneP = slider_size.X / (max - min);
		drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, oneP * (*value - min), slider_size.Y, Colors::Slider_Progress);
		//drawFilledRect(FVector2D{ pos.X + oneP * (*value - min) - 10.0f, pos.Y + slider_size.Y - 5.0f + padding.Y }, 20.0f, 20.0f, Colors::Slider_Button);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 3.3f + padding.Y }, 10.0f, Colors::Slider_Button);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 3.3f + padding.Y }, 5.0f, Colors::Slider_Progress);
		 

		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}
	void SliderFloat(const wchar_t* name, float* value, float min, float max, const char* format = "%.0f")
	{
		elements_count++;

		FVector2D size = FVector2D{ 210, 40 };
		FVector2D slider_size = FVector2D{ 170, 7 };
		FVector2D adjust_zone = FVector2D{ 0, 20 };
		FVector2D padding = FVector2D{ 10, 15 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y - adjust_zone.Y }, FVector2D{ slider_size.X, slider_size.Y + adjust_zone.Y * 1.5f });

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Bg
		if (isHovered || current_element == elements_count)
		{
			//Drag
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				current_element = elements_count;

				FVector2D cursorPos = CursorPos();
				*value = ((cursorPos.X - pos.X) * ((max - min) / slider_size.X)) + min;
				if (*value < min) *value = min;
				if (*value > max) *value = max;
			}

			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Hovered);
			DrawFilledCircle(FVector2D{ pos.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Progress);
			DrawFilledCircle(FVector2D{ pos.X + slider_size.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Hovered);

			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Idle);
			DrawFilledCircle(FVector2D{ pos.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Progress);
			DrawFilledCircle(FVector2D{ pos.X + slider_size.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Idle);
		}


		//Text
		FVector2D textPos = FVector2D{ pos.X, pos.Y + 5 };
		TextLeft(name, textPos, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f }, false);

		//Value
		float oneP = slider_size.X / (max - min);
		drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, oneP * (*value - min), slider_size.Y, Colors::Slider_Progress);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 2.66f + padding.Y }, 8.0f, Colors::Slider_Button);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 2.66f + padding.Y }, 4.0f, Colors::Slider_Progress);
		 
		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}



	bool checkbox_enabled[256];
	void Combobox(const wchar_t* name, FVector2D size, int* value, const char* arg, ...)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 5, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (isHovered || checkbox_enabled[elements_count])
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Combobox_Hovered);

			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Combobox_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + size.X + 5.0f, pos.Y + size.Y / 2 };
		TextLeft(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

		//Elements
		bool isHovered2 = false;
		FVector2D element_pos = pos;
		int num = 0;

		if (checkbox_enabled[elements_count])
		{
			current_element_size.X = element_pos.X - 5.0f;
			current_element_size.Y = element_pos.Y - 5.0f;
		}
		va_list arguments;
		for (va_start(arguments, arg); arg != NULL; arg = va_arg(arguments, const char*))
		{
			//Selected Element
			if (num == *value)
			{
				FVector2D _textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
				TextCenter((const wchar_t*)arg, _textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
			}

			if (checkbox_enabled[elements_count])
			{
				element_pos.Y += 25.0f;

				isHovered2 = MouseInZone(FVector2D{ element_pos.X, element_pos.Y }, FVector2D{ size.X, 25.0f });
				if (isHovered2)
				{
					hover_element = true;
					PostRenderer::drawFilledRect(FVector2D{ element_pos.X, element_pos.Y }, size.X, 25.0f, Colors::Combobox_Hovered);

					//Click
					if (Input::IsMouseClicked(0, elements_count, false))
					{
						*value = num;
						checkbox_enabled[elements_count] = false;
					}
				}
				else
				{
					PostRenderer::drawFilledRect(FVector2D{ element_pos.X, element_pos.Y }, size.X, 25.0f, Colors::Combobox_Idle);
				}

				PostRenderer::TextLeft((char*)arg, FVector2D{ element_pos.X + 5.0f, element_pos.Y + 15.0f }, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
			}
			num++;
		}
		va_end(arguments);
		if (checkbox_enabled[elements_count])
		{
			current_element_size.X = element_pos.X + 5.0f;
			current_element_size.Y = element_pos.Y + 5.0f;
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
		{
			checkbox_enabled[elements_count] = !checkbox_enabled[elements_count];
		}
		if (!isHovered && !isHovered2 && Input::IsMouseClicked(0, elements_count, false))
		{
			checkbox_enabled[elements_count] = false;
		}
	}

	int active_hotkey = -1;
	bool already_pressed = false;
	std::string VirtualKeyCodeToString(UCHAR virtualKey)
	{
		UINT scanCode = MapVirtualKey(virtualKey, MAPVK_VK_TO_VSC);

		if (virtualKey == VK_LBUTTON)
		{
			return ("MOUSE0");
		}
		if (virtualKey == VK_RBUTTON)
		{
			return ("MOUSE1");
		}
		if (virtualKey == VK_MBUTTON)
		{
			return ("MBUTTON");
		}
		if (virtualKey == VK_XBUTTON1)
		{
			return ("XBUTTON1");
		}
		if (virtualKey == VK_XBUTTON2)
		{
			return ("XBUTTON2");
		}

		CHAR szName[128];
		int result = 0;
		switch (virtualKey)
		{
		case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN:
		case VK_RCONTROL: case VK_RMENU:
		case VK_LWIN: case VK_RWIN: case VK_APPS:
		case VK_PRIOR: case VK_NEXT:
		case VK_END: case VK_HOME:
		case VK_INSERT: case VK_DELETE:
		case VK_DIVIDE:
		case VK_NUMLOCK:
			scanCode |= KF_EXTENDED;
		default:
			result = GetKeyNameTextA(scanCode << 16, szName, 128);
		}

		return szName;
	}
	void Hotkey(const char* name, FVector2D size, int* key)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 5, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y + (last_element_size.Y / 2) - size.Y / 2;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		if (active_hotkey == elements_count)
		{
			//Text
			FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
			TextCenter((const wchar_t*)("[Press Key]"), textPos, FLinearColor{1.0f, 1.0f, 1.0f, 1.0f}, false);

			if (!CWINGui::Input::IsAnyMouseDown())
			{
				already_pressed = false;
			}

			if (!already_pressed)
			{
				for (int code = 0; code < 255; code++)
				{
					if (GetAsyncKeyState(code))
					{
						*key = code;
						active_hotkey = -1;
					}
				}
			}
		}
		else
		{
			//Text
			FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
			TextCenter((const wchar_t*)VirtualKeyCodeToString(*key).c_str(), textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (isHovered)
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					already_pressed = true;
					active_hotkey = elements_count;

					//Queue Fix
					for (int code = 0; code < 255; code++)
						if (GetAsyncKeyState(code)) {}
				}
			}
			else
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					active_hotkey = -1;
				}
			}
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}

	int active_picker = -1;
	FLinearColor saved_color;
	bool ColorPixel(FVector2D pos, FVector2D size, FLinearColor* original, FLinearColor color)
	{
		PostRenderer::drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, color);

		//Выбранный цвет
		if (original->R == color.R && original->G == color.G && original->B == color.B)
		{
			PostRenderer::Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ pos.X + size.X - 1, pos.Y }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(FVector2D{ pos.X, pos.Y + size.Y - 1 }, FVector2D{ pos.X + size.X - 1, pos.Y + size.Y - 1 }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ pos.X, pos.Y + size.Y - 1 }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(FVector2D{ pos.X + size.X - 1, pos.Y }, FVector2D{ pos.X + size.X - 1, pos.Y + size.Y - 1 }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
		}

		//Смена цвета
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);
		if (isHovered)
		{
			if (Input::IsMouseClicked(0, elements_count, false))
				*original = color;
		}

		return true;
	}
	void ColorPicker(const wchar_t* name, FLinearColor* color)
	{
		elements_count++;

		float size = 25;
		FVector2D padding = FVector2D{ 10, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, FVector2D{ size, size });

		if (!sameLine)
			offset_y += size + padding.Y;

		if (active_picker == elements_count)
		{
			hover_element = true;

			float sizePickerX = 250;
			float sizePickerY = 250;
			bool isHoveredPicker = MouseInZone(FVector2D{ pos.X, pos.Y }, FVector2D{ sizePickerX, sizePickerY - 60 });

			//Background
			PostRenderer::drawFilledRect(FVector2D{ pos.X, pos.Y }, sizePickerX, sizePickerY - 65, Colors::ColorPicker_Background);

			//float pixedSize = sizePickerY / pixels;
			//FLinearColor temp_color{1.0f, 1.0f, 1.0f, 1.0f};
			//float iterator = 0.0f;
			//
			//for (int y = 0; y < pixels; y++)
			//{
			//	for (int x = 0; x < pixels; x++)
			//	{
			//		ColorPixel(FVector2D{ pos.X + pixedSize * x, pos.Y + pixedSize * y }, pixedSize, color, temp_color);
			//		temp_color.R -= (1.0f - saved_color.R) / pixels;
			//		temp_color.G -= (1.0f - saved_color.G) / pixels;
			//		temp_color.B -= (1.0f - saved_color.B) / pixels;
			//	}
			//	
			//	iterator += 1.0f / pixels;
			//	temp_color = FLinearColor{ 1.0f - iterator, 1.0f - iterator, 1.0f - iterator, 1.0f };
			//}

			FVector2D pixelSize = FVector2D{ sizePickerX / 12, sizePickerY / 12 };

			//0
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 174 / 255.f, 235 / 255.f, 253 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 136 / 255.f, 225 / 255.f, 251 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 108 / 255.f, 213 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 89 / 255.f, 175 / 255.f, 213 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 76 / 255.f, 151 / 255.f, 177 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 60 / 255.f, 118 / 255.f, 140 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 43 / 255.f, 85 / 255.f, 100 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 32 / 255.f, 62 / 255.f, 74 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 255 / 255.f, 255 / 255.f, 255 / 255.f, 1.0f });
			}
			//1
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 175 / 255.f, 205 / 255.f, 252 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 132 / 255.f, 179 / 255.f, 252 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 90 / 255.f, 152 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 55 / 255.f, 120 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 49 / 255.f, 105 / 255.f, 209 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 38 / 255.f, 83 / 255.f, 165 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 28 / 255.f, 61 / 255.f, 120 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 20 / 255.f, 43 / 255.f, 86 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 247 / 255.f, 247 / 255.f, 247 / 255.f, 1.0f });
			}
			//2
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 153 / 255.f, 139 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 101 / 255.f, 79 / 255.f, 249 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 64 / 255.f, 50 / 255.f, 230 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 54 / 255.f, 38 / 255.f, 175 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 39 / 255.f, 31 / 255.f, 144 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 32 / 255.f, 25 / 255.f, 116 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 21 / 255.f, 18 / 255.f, 82 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 16 / 255.f, 13 / 255.f, 61 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 228 / 255.f, 228 / 255.f, 228 / 255.f, 1.0f });
			}
			//3
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 194 / 255.f, 144 / 255.f, 251 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 165 / 255.f, 87 / 255.f, 249 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 142 / 255.f, 57 / 255.f, 239 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 116 / 255.f, 45 / 255.f, 184 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 92 / 255.f, 37 / 255.f, 154 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 73 / 255.f, 29 / 255.f, 121 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 53 / 255.f, 21 / 255.f, 88 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 37 / 255.f, 15 / 255.f, 63 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 203 / 255.f, 203 / 255.f, 203 / 255.f, 1.0f });
			}
			//4
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 224 / 255.f, 162 / 255.f, 197 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 210 / 255.f, 112 / 255.f, 166 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 199 / 255.f, 62 / 255.f, 135 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 159 / 255.f, 49 / 255.f, 105 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 132 / 255.f, 41 / 255.f, 89 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 104 / 255.f, 32 / 255.f, 71 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 75 / 255.f, 24 / 255.f, 51 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 54 / 255.f, 14 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 175 / 255.f, 175 / 255.f, 175 / 255.f, 1.0f });
			}
			//5
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 235 / 255.f, 175 / 255.f, 176 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 227 / 255.f, 133 / 255.f, 135 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 219 / 255.f, 87 / 255.f, 88 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 215 / 255.f, 50 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 187 / 255.f, 25 / 255.f, 7 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 149 / 255.f, 20 / 255.f, 6 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 107 / 255.f, 14 / 255.f, 4 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 77 / 255.f, 9 / 255.f, 3 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 144 / 255.f, 144 / 255.f, 144 / 255.f, 1.0f });
			}
			//6
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 241 / 255.f, 187 / 255.f, 171 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 234 / 255.f, 151 / 255.f, 126 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 229 / 255.f, 115 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 227 / 255.f, 82 / 255.f, 24 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 190 / 255.f, 61 / 255.f, 15 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 150 / 255.f, 48 / 255.f, 12 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 107 / 255.f, 34 / 255.f, 8 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 79 / 255.f, 25 / 255.f, 6 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 113 / 255.f, 113 / 255.f, 113 / 255.f, 1.0f });
			}
			//7
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 245 / 255.f, 207 / 255.f, 169 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 240 / 255.f, 183 / 255.f, 122 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 236 / 255.f, 159 / 255.f, 74 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 234 / 255.f, 146 / 255.f, 37 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 193 / 255.f, 111 / 255.f, 28 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 152 / 255.f, 89 / 255.f, 22 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 110 / 255.f, 64 / 255.f, 16 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 80 / 255.f, 47 / 255.f, 12 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 82 / 255.f, 82 / 255.f, 82 / 255.f, 1.0f });
			}
			//8
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 247 / 255.f, 218 / 255.f, 170 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 244 / 255.f, 200 / 255.f, 124 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 241 / 255.f, 182 / 255.f, 77 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 239 / 255.f, 174 / 255.f, 44 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 196 / 255.f, 137 / 255.f, 34 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 154 / 255.f, 108 / 255.f, 27 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 111 / 255.f, 77 / 255.f, 19 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 80 / 255.f, 56 / 255.f, 14 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 54 / 255.f, 54 / 255.f, 54 / 255.f, 1.0f });
			}
			//9
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 254 / 255.f, 243 / 255.f, 187 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 253 / 255.f, 237 / 255.f, 153 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 253 / 255.f, 231 / 255.f, 117 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 254 / 255.f, 232 / 255.f, 85 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 242 / 255.f, 212 / 255.f, 53 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 192 / 255.f, 169 / 255.f, 42 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 138 / 255.f, 120 / 255.f, 30 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 101 / 255.f, 87 / 255.f, 22 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 29 / 255.f, 29 / 255.f, 29 / 255.f, 1.0f });
			}
			//10
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 247 / 255.f, 243 / 255.f, 185 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 243 / 255.f, 239 / 255.f, 148 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 239 / 255.f, 232 / 255.f, 111 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 235 / 255.f, 229 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 208 / 255.f, 200 / 255.f, 55 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 164 / 255.f, 157 / 255.f, 43 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 118 / 255.f, 114 / 255.f, 31 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 86 / 255.f, 82 / 255.f, 21 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 9 / 255.f, 9 / 255.f, 9 / 255.f, 1.0f });
			}
			//11
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 218 / 255.f, 232 / 255.f, 182 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 198 / 255.f, 221 / 255.f, 143 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 181 / 255.f, 210 / 255.f, 103 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 154 / 255.f, 186 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 130 / 255.f, 155 / 255.f, 64 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 102 / 255.f, 121 / 255.f, 50 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 74 / 255.f, 88 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 54 / 255.f, 64 / 255.f, 26 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 0 / 255.f, 0 / 255.f, 0 / 255.f, 1.0f });
			}



			if (isHoveredPicker)
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{

				}
			}
			else
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					active_picker = -1;
					//hover_element = false;
				}
			}
		}
		else
		{
			//Bg
			if (isHovered)
			{
				drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Hovered);
				hover_element = true;
			}
			else
			{
				drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Idle);
			}

			//Color
			drawFilledRect(FVector2D{ pos.X + 4, pos.Y + 4 }, size - 8, size - 8, *color);

			//Text
			FVector2D textPos = FVector2D{ pos.X + size + 5.0f, pos.Y - 5 };
			TextLeft(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			{
				saved_color = *color;
				active_picker = elements_count;
			}
		}


		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}


	void Render()
	{
		for (int i = 0; i < 128; i++)
		{
			if (PostRenderer::drawlist[i].type != -1)
			{
				//Filled Rect
				if (PostRenderer::drawlist[i].type == 1)
				{
					CWINGui::drawFilledRect(PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].size.X, PostRenderer::drawlist[i].size.Y, PostRenderer::drawlist[i].color);
				}
				//TextLeft
				else if (PostRenderer::drawlist[i].type == 2)
				{
					CWINGui::TextLeft((const wchar_t*)PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
				}
				//TextCenter
				else if (PostRenderer::drawlist[i].type == 3)
				{
					CWINGui::TextCenter((const wchar_t*)PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
				}
				//Draw_Line
				else if (PostRenderer::drawlist[i].type == 4)
				{
					Draw_Line(PostRenderer::drawlist[i].from, PostRenderer::drawlist[i].to, PostRenderer::drawlist[i].thickness, PostRenderer::drawlist[i].color);
				}

				PostRenderer::drawlist[i].type = -1;
			}
		}
	}
}
```

`unrealengine.h`:

```h
#pragma once
#include <math.h>
#include <corecrt_math_defines.h>
#include <cstdlib>
#include <cstdint>
#include <iostream>
#include <vector>
#include <stringapiset.h>
#define RAD(degs) float(degs) * PI / 180.0f
#define DEG(rads) float(rads) * 180.0f / PI
struct FVector
{
	float X, Y, Z;

	FVector() : X(0.f), Y(0.f), Z(0.f) {}

	FVector(float x, float y, float z) : X(x), Y(y), Z(z) {}

	FVector(float InF) : X(InF), Y(InF), Z(InF) { }


	inline float Dot(const FVector& b) const { return (X * b.X) + (Y * b.Y) + (Z * b.Z); }

	inline float MagnitudeSqr() const { return Dot(*this); }

	inline float Magnitude() const { return std::sqrtf(MagnitudeSqr()); }

	float Size() const { return sqrtf(X * X + Y * Y + Z * Z); }

	float Sum() const { return X + Y + Z; }

	float Size2D() const { return sqrtf(X * X + Y * Y); }

	float SizeSquared() const { return X * X + Y * Y + Z * Z; }

	float DistTo(const FVector& V) const { return (*this - V).Size(); }

	FVector operator+(const FVector& other) const { return FVector(X + other.X, Y + other.Y, Z + other.Z); }

	FVector operator-(const FVector& other) const { return FVector(X - other.X, Y - other.Y, Z - other.Z); }

	FVector operator*(const FVector& V) const { return FVector(X * V.X, Y * V.Y, Z * V.Z); }

	FVector operator/(const FVector& V) const { return FVector(X / V.X, Y / V.Y, Z / V.Z); }

	bool operator==(const FVector& V) const { return X == V.X && Y == V.Y && Z == V.Z; }

	bool operator!=(const FVector& V) const { return X != V.X || Y != V.Y || Z != V.Z; }

	FVector operator-() const { return FVector(-X, -Y, -Z); }

	FVector operator+(float Bias) const { return FVector(X + Bias, Y + Bias, Z + Bias); }

	FVector operator-(float Bias) const { return FVector(X - Bias, Y - Bias, Z - Bias); }

	FVector operator*(float Scale) const { return FVector(X * Scale, Y * Scale, Z * Scale); } const

		FVector operator/(float Scale) const { const float RScale = 1.f / Scale; return FVector(X * RScale, Y * RScale, Z * RScale); }

	FVector operator=(const FVector& V) { X = V.X; Y = V.Y; Z = V.Z; return *this; }

	FVector operator+=(const FVector& V) { X += V.X; Y += V.Y; Z += V.Z; return *this; }

	FVector operator-=(const FVector& V) { X -= V.X; Y -= V.Y; Z -= V.Z; return *this; }

	FVector operator*=(const FVector& V) { X *= V.X; Y *= V.Y; Z *= V.Z; return *this; }

	FVector operator/=(const FVector& V) { X /= V.X; Y /= V.Y; Z /= V.Z; return *this; }

	FVector operator*=(float Scale) { X *= Scale; Y *= Scale; Z *= Scale; return *this; }

	FVector operator/=(float V) { const float RV = 1.f / V; X *= RV; Y *= RV; Z *= RV; return *this; }

	float operator|(const FVector& V) const { return X * V.X + Y * V.Y + Z * V.Z; }

	FVector operator^(const FVector& V) const { return FVector(Y * V.Z - Z * V.Y, Z * V.X - X * V.Z, X * V.Y - Y * V.X); }
	inline float Distance(FVector v) {
		return float(sqrtf(powf(v.X - X, 2.0) + powf(v.Y - Y, 2.0) + powf(v.Z - Z, 2.0)));
	}
	bool IsValid()
	{
		if (X == 0 || Y == 0 || Z == 0)
			return false;
		else
			return true;
	}
	static const FVector ZeroVector;

	static const FVector OneVector;
};
class FLinearColor
{
public:
	float R, G, B, A;
};
struct FVector2D
{
	float X, Y;

	FVector2D() : X(0), Y(0) {}

	FVector2D(float x, float y) : X(x), Y(y) {}

	float Size() const;

	FVector2D operator + (const FVector2D& other) const { return FVector2D(X + other.X, Y + other.Y); }

	FVector2D operator- (const FVector2D& other) const { return FVector2D(X - other.X, Y - other.Y); }

	FVector2D operator* (float scalar) const { return FVector2D(X * scalar, Y * scalar); }

	FVector2D& operator=  (const FVector2D& other) { X = other.X; Y = other.Y; return *this; }

	FVector2D& operator+= (const FVector2D& other) { X += other.X; Y += other.Y; return *this; }

	FVector2D& operator-= (const FVector2D& other) { X -= other.X; Y -= other.Y; return *this; }

	FVector2D& operator*= (const float other) { X *= other; Y *= other; return *this; }

	friend bool operator==(const FVector2D& one, const FVector2D& two) { return one.X == two.X && one.Y == two.Y; }

	friend bool operator!=(const FVector2D& one, const FVector2D& two) { return !(one == two); }

	friend bool operator>(const FVector2D& one, const FVector2D& two) { return one.X > two.X && one.Y > two.Y; }

	friend bool operator<(const FVector2D& one, const FVector2D& two) { return one.X < two.X&& one.Y < two.Y; }
	bool IsValid()
	{
		if (X == 0 || Y == 0)
			return false;
		else
			return true;
	}
};
struct alignas(16) FPlane : public FVector {
	float W;
};
enum class EAresAlliance : uint8_t {
	Alliance_Ally = 0,
	Alliance_Enemy = 1,
	Alliance_Neutral = 2,
	Alliance_Any = 3,
	Alliance_Count = 4,
	Alliance_MAX = 5
};
enum class EAresOutlineMode : uint8_t {
	None = 0,
	Outline = 1,
	Block = 2,
	Enemy = 3,
	AlwaysOutline = 4,
	AlwaysEnemy = 5,
	EAresOutlineMode_MAX = 6
};
struct FMatrix {
	struct FPlane XPlane;
	struct FPlane YPlane;
	struct FPlane ZPlane;
	struct FPlane WPlane;
};

static FMatrix ToMatrix(FVector rot) {
	FVector origin = FVector{};
	float radPitch = (rot.X * float(M_PI) / 180.f);
	float radYaw = (rot.Y * float(M_PI) / 180.f);
	float radRoll = (rot.Z * float(M_PI) / 180.f);

	float SP = sinf(radPitch);
	float CP = cosf(radPitch);
	float SY = sinf(radYaw);
	float CY = cosf(radYaw);
	float SR = sinf(radRoll);
	float CR = cosf(radRoll);

	FMatrix matrix;
	matrix.XPlane.X = CP * CY;
	matrix.XPlane.Y = CP * SY;
	matrix.XPlane.Z = SP;
	matrix.XPlane.W = 0.f;

	matrix.YPlane.X = SR * SP * CY - CR * SY;
	matrix.YPlane.Y = SR * SP * SY + CR * CY;
	matrix.YPlane.Z = -SR * CP;
	matrix.YPlane.W = 0.f;

	matrix.ZPlane.X = -(CR * SP * CY + SR * SY);
	matrix.ZPlane.Y = CY * SR - CR * SP * SY;
	matrix.ZPlane.Z = CR * CP;
	matrix.ZPlane.W = 0.f;

	matrix.WPlane.X = origin.X;
	matrix.WPlane.Y = origin.Y;
	matrix.WPlane.Z = origin.Z;
	matrix.WPlane.W = 1.f;

	return matrix;
}
template<class T>
struct TArray
{
	friend class FString;

public:
	TArray()
	{
		Data = nullptr;
		Count = Max = 0;
	}

	TArray(T* data, int32_t count, int32_t max)
		: Data(data),
		Count(count),
		Max(max)
	{
	}

	int Num() const
	{
		return Count;
	}

	T& operator[](int i)
	{
		return Data[i];
	}

	const T& operator[](int i) const
	{
		return Data[i];
	}

	bool IsValidIndex(int i) const
	{
		return i < Num();
	}



private:
	T* Data;
	int32_t Count;
	int32_t Max;
};
class FString : public TArray<wchar_t>
{
public:
	inline FString()
	{
	};

	FString(const wchar_t* other)
	{
		Max = Count = *other ? static_cast<int>(std::wcslen(other)) + 1 : 0;

		if (Count)
		{
			Data = const_cast<wchar_t*>(other);
		}
	};
	FString(const wchar_t* other, int count)
	{
		Data = const_cast<wchar_t*>(other);;
		Max = Count = count;
	};

	inline bool IsValid() const
	{
		return Data != nullptr;
	}

	inline const wchar_t* wide() const
	{
		return Data;
	}

	int multi(char* name, int size) const
	{
		return WideCharToMultiByte(CP_UTF8, 0, Data, Count, name, size, nullptr, nullptr) - 1;
	}

	std::string ToString() const
	{
		auto length = std::wcslen(Data);

		std::string str(length, '\0');

		std::use_facet<std::ctype<wchar_t>>(std::locale()).narrow(Data, Data + length, '?', &str[0]);

		return str;
	}
};
```

`valorant.h`:

```h
#pragma once
#include <cstdint>
namespace VALORANT
{
	uintptr_t Module;
}
```

`x64/Release/DaddyKermitsInternal.dll.recipe`:

```recipe
<?xml version="1.0" encoding="utf-8"?>
<Project>
  <ProjectOutputs>
    <ProjectOutput>
      <FullPath>C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.dll</FullPath>
    </ProjectOutput>
  </ProjectOutputs>
  <ContentFiles />
  <SatelliteDlls />
  <NonRecipeFileRefs />
</Project>
```

`x64/Release/DaddyKermitsInternal.log`:

```log
  Entry.cpp
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(43,135): warning C4099: 'FLinearColor': type name first seen using 'class' now seen using 'struct'
C:\Users\s\Desktop\Valorant-Internal-main\unrealengine.h(91,7): message : see declaration of 'FLinearColor'
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(71,44): warning C4099: 'FString': type name first seen using 'class' now seen using 'struct'
C:\Users\s\Desktop\Valorant-Internal-main\unrealengine.h(244,7): message : see declaration of 'FString'
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(71,134): warning C4099: 'FLinearColor': type name first seen using 'class' now seen using 'struct'
C:\Users\s\Desktop\Valorant-Internal-main\unrealengine.h(91,7): message : see declaration of 'FLinearColor'
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(71,182): warning C4099: 'FLinearColor': type name first seen using 'class' now seen using 'struct'
C:\Users\s\Desktop\Valorant-Internal-main\unrealengine.h(91,7): message : see declaration of 'FLinearColor'
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(71,293): warning C4099: 'FLinearColor': type name first seen using 'class' now seen using 'struct'
C:\Users\s\Desktop\Valorant-Internal-main\unrealengine.h(91,7): message : see declaration of 'FLinearColor'
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(1006,129): warning C4305: 'argument': truncation from 'double' to 'float'
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(1010,123): warning C4305: 'argument': truncation from 'double' to 'float'
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(1039,77): warning C4244: 'argument': conversion from 'int' to 'float', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(1058,104): warning C4244: 'argument': conversion from 'float' to 'int', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(1065,14): warning C4244: 'initializing': conversion from 'double' to 'float', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(1078,72): warning C4244: 'argument': conversion from 'float' to 'int', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(1386,70): warning C4244: '=': conversion from 'float' to 'int', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(1753,95): warning C4244: 'argument': conversion from 'float' to 'int', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(1754,121): warning C4244: 'argument': conversion from 'float' to 'int', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(1755,95): warning C4244: 'argument': conversion from 'float' to 'int', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Canvas.h(1756,121): warning C4244: 'argument': conversion from 'float' to 'int', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\decryption.h(285,1): warning C4005: 'LOBYTE': macro redefinition
C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\shared\minwindef.h(206,1): message : see previous definition of 'LOBYTE'
C:\Users\s\Desktop\Valorant-Internal-main\decryption.h(286,1): warning C4005: 'LOWORD': macro redefinition
C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\shared\minwindef.h(204,1): message : see previous definition of 'LOWORD'
C:\Users\s\Desktop\Valorant-Internal-main\decryption.h(288,1): warning C4005: 'HIBYTE': macro redefinition
C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\shared\minwindef.h(207,1): message : see previous definition of 'HIBYTE'
C:\Users\s\Desktop\Valorant-Internal-main\decryption.h(289,1): warning C4005: 'HIWORD': macro redefinition
C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\shared\minwindef.h(205,1): message : see previous definition of 'HIWORD'
C:\Users\s\Desktop\Valorant-Internal-main\decryption.h(595,12): warning C4244: '=': conversion from 'unsigned __int64' to 'int', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\decryption.h(600,11): warning C4244: '=': conversion from 'unsigned __int64' to 'int', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\decryption.h(603,13): warning C4244: '=': conversion from 'unsigned __int64' to 'unsigned int', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Entry.cpp(18,126): warning C4305: 'argument': truncation from 'double' to 'float'
C:\Users\s\Desktop\Valorant-Internal-main\Entry.cpp(22,126): warning C4305: 'argument': truncation from 'double' to 'float'
C:\Users\s\Desktop\Valorant-Internal-main\Entry.cpp(27,117): warning C4305: 'argument': truncation from 'double' to 'float'
C:\Users\s\Desktop\Valorant-Internal-main\Entry.cpp(389,119): warning C4244: 'argument': conversion from 'float' to 'int', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Entry.cpp(389,111): warning C4244: 'argument': conversion from 'float' to 'int', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Entry.cpp(556,22): warning C4244: 'initializing': conversion from 'double' to 'float', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Entry.cpp(756,41): warning C4244: 'argument': conversion from 'uintptr_t' to 'const uint32_t', possible loss of data
C:\Users\s\Desktop\Valorant-Internal-main\Entry.cpp(768,110): warning C4244: 'return': conversion from 'LRESULT' to 'int', possible loss of data
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring(2857,53): warning C4244: 'argument': conversion from 'wchar_t' to 'const _Elem', possible loss of data
          with
          [
              _Elem=char
          ]
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring(2718,1): message : see reference to function template instantiation 'void std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Construct_from_iter<wchar_t*,wchar_t*,_Size_type>(_Iter,const _Sent,_Size)' being compiled
          with
          [
              _Size_type=unsigned __int64,
              _Iter=wchar_t *,
              _Sent=wchar_t *,
              _Size=unsigned __int64
          ]
C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring(2718,37): message : see reference to function template instantiation 'void std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Construct_from_iter<wchar_t*,wchar_t*,_Size_type>(_Iter,const _Sent,_Size)' being compiled
          with
          [
              _Size_type=unsigned __int64,
              _Iter=wchar_t *,
              _Sent=wchar_t *,
              _Size=unsigned __int64
          ]
C:\Users\s\Desktop\Valorant-Internal-main\Decryptor.h(207,13): message : see reference to function template instantiation 'std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<std::_String_iterator<std::_String_val<std::_Simple_types<_Elem>>>,0>(_Iter,_Iter,const _Alloc &)' being compiled
          with
          [
              _Elem=wchar_t,
              _Iter=std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,
              _Alloc=std::allocator<char>
          ]
C:\Users\s\Desktop\Valorant-Internal-main\Decryptor.h(207,3): message : see reference to function template instantiation 'std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<std::_String_iterator<std::_String_val<std::_Simple_types<_Elem>>>,0>(_Iter,_Iter,const _Alloc &)' being compiled
          with
          [
              _Elem=wchar_t,
              _Iter=std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,
              _Alloc=std::allocator<char>
          ]
     Creating library C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.lib and object C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.exp
  Generating code
  6 of 242 functions ( 2.5%) were compiled, the rest were copied from previous compilation.
    4 functions were new in current compilation
    1 functions had inline decision re-evaluated but remain unchanged
  Finished generating code
  DaddyKermitsInternal.vcxproj -> C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.dll

```

`x64/Release/DaddyKermitsInternal.vcxproj.FileListAbsolute.txt`:

```txt
C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.dll

```

`x64/Release/Valorant.tlog/CL.command.1.tlog`:

```tlog
^C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\FNAMEPOOL.H
/c /Zi /nologo /W3 /WX- /diagnostics:column /sdl /O2 /Oi /GL /D NDEBUG /D INTERNALFORUGLYPASTERS_EXPORTS /D _WINDOWS /D _USRDLL /D _CRT_SECURE_NO_WARNINGS /D _WINDLL /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /permissive- /Fo"X64\RELEASE\\" /Fd"X64\RELEASE\VC143.PDB" /external:W3 /Gd /TP /FC C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\FNAMEPOOL.H
^C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\ENTRY.CPP
/c /Zi /nologo /W3 /WX- /diagnostics:column /sdl /O2 /Oi /GL /D NDEBUG /D INTERNALFORUGLYPASTERS_EXPORTS /D _WINDOWS /D _USRDLL /D _CRT_SECURE_NO_WARNINGS /D _WINDLL /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /permissive- /Fo"X64\RELEASE\\" /Fd"X64\RELEASE\VC143.PDB" /external:W3 /Gd /TP /FC C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\ENTRY.CPP

```

`x64/Release/Valorant.tlog/CL.read.1.tlog`:

```tlog
^C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\FNAMEPOOL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\STRING
^C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\ENTRY.CPP
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\BIN\HOSTX64\X64\1033\CLUI.DLL
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINDOWS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\EXCPT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VCRUNTIME.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\SAL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CONCURRENCYSAL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VADEFS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\STDARG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\MINWINDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINNT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_WCTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_MEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_MEMCPY_S.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\ERRNO.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VCRUNTIME_STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_WSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\PSHPACK2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\PSHPACK8.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\APISETCCONV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\MINWINBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\APIQUERY2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\PROCESSENV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\FILEAPIFROMAPP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\FILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\DEBUGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\UTILAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\HANDLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\ERRHANDLINGAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\FIBERSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\NAMEDPIPEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\PROFILEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\HEAPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\IOAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\SYNCHAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\INTERLOCKEDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\PROCESSTHREADSAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\SYSINFOAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\MEMORYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\ENCLAVEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\THREADPOOLLEGACYAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\THREADPOOLAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\JOBAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\JOBAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WOW64APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\LIBLOADERAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\SECURITYBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\NAMESPACEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\SYSTEMTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\PROCESSTOPOLOGYAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\SECURITYAPPCONTAINER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\REALTIMEAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WINERROR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\TIMEZONEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINGDI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINUSER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\TVOUT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINNLS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\DATETIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\STRINGAPISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINCON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINCONTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\CONSOLEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\CONSOLEAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\CONSOLEAPI3.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\VERRSRC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINREG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\REASON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINNETWK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WNNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\CDERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\DDE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\DDEML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\DLGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\LZEXPAND.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\MMSYSTEM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\MMSYSCOM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\MCIAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\MMISCAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\MMISCAPI2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\PLAYSOUNDAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\MMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\TIMEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\JOYSTICKAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\NB30.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\RPC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\RPCDCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\RPCDCEP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\RPCNSI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\RPCNTERR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\RPCASYNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\SHELLAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINPERF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINSOCK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\INADDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\BCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\NCRYPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\DPAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINSCARD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\RPCNDR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\RPCNSIP.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\RPCSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WTYPESBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINIOCTL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\WINSMCRD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINSPOOL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\PRSHT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\OLE2.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\OBJBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\COMBASEAPI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\STDLIB.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_MALLOC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_SEARCH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\STDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_WSTDLIB.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\LIMITS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\UNKNWNBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\OBJIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\CGUID.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\COML2API.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\OBJIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\UNKNWN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\PROPIDLBASE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\OAIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\URLMON.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\OLEIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\SERVPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\MSXML.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\PROPIDL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\OLEAUTO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\COMMDLG.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\SHARED\STRALIGN.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\WINSVC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\MCX.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\IMM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UM\IME_CMODES.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CSTDIO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\YVALS_CORE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XKEYCHECK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\STDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_WSTDIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_STDIO_CONFIG.H
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\CANVAS.H
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\MEMORY.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CSTDINT
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\STDINT.H
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\OFFSETS.H
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\VALORANT.H
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\UNREALENGINE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_MATH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_MATH_DEFINES.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CSTDLIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\IOSTREAM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\ISTREAM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\OSTREAM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\IOS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XLOCNUM
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CLIMITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CMATH
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\YVALS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CRTDBG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VCRUNTIME_NEW_DEBUG.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VCRUNTIME_NEW.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CRTDEFS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\USE_ANSI.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XTR1COMMON
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\INTRIN0.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\INTRIN0.INL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\ITERATOR
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\IOSFWD
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CSTRING
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CWCHAR
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\WCHAR.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_WCONIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_WDIRECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_WIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_SHARE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_WPROCESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_WTIME.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\SYS\STAT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\SYS\TYPES.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XSTDDEF
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CSTDDEF
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\INITIALIZER_LIST
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XUTILITY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\__MSVC_ITER_CORE.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\UTILITY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\TYPE_TRAITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\STREAMBUF
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XIOSBASE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\SHARE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\SYSTEM_ERROR
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\__MSVC_SYSTEM_ERROR_ABI.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CERRNO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\STDEXCEPT
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\EXCEPTION
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\MALLOC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VCRUNTIME_EXCEPTION.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\EH.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\CORECRT_TERMINATE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XSTRING
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XMEMORY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\LIMITS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CFLOAT
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\FLOAT.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\ISA_AVAILABILITY.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\NEW
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XATOMIC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XCALL_ONCE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XERRC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\ATOMIC
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XTHREADS.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XTIMEC.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CTIME
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\TIME.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XLOCALE
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\MEMORY
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\TYPEINFO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VCRUNTIME_TYPEINFO.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XFACET
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\XLOCINFO
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\__MSVC_XLOCINFO_TYPES.HPP
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CCTYPE
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\CLOCALE
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.22000.0\UCRT\LOCALE.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\VECTOR
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\DECRYPTION.H
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\HOOK.H
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\DECRYPTOR.H
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\ALIGNMENTS.H
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\FNAMEPOOL.H
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\INCLUDE\STRING

```

`x64/Release/Valorant.tlog/CL.write.1.tlog`:

```tlog
^C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\ENTRY.CPP|C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\FNAMEPOOL.H
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\VC143.PDB
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\FNAMEPOOL.OBJ
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\ENTRY.OBJ
^C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\FNAMEPOOL.H
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\VC143.PDB
^C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\ENTRY.CPP
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\VC143.PDB
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\ENTRY.OBJ

```

`x64/Release/Valorant.tlog/Valorant.lastbuildstate`:

```lastbuildstate
PlatformToolSet=v143:VCToolArchitecture=Native64Bit:VCToolsVersion=14.34.31933:TargetPlatformVersion=10.0.22000.0:
Release|x64|C:\Users\s\Desktop\Valorant-Internal-main\|

```

`x64/Release/Valorant.tlog/link.command.1.tlog`:

```tlog
^C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\DISCORD-RPC.LIB|C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\ENTRY.OBJ|C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\FNAMEPOOL.OBJ
/OUT:"C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\DADDYKERMITSINTERNAL.DLL" /INCREMENTAL:NO /NOLOGO KERNEL32.LIB USER32.LIB GDI32.LIB WINSPOOL.LIB COMDLG32.LIB ADVAPI32.LIB SHELL32.LIB OLE32.LIB OLEAUT32.LIB UUID.LIB ODBC32.LIB ODBCCP32.LIB /MANIFEST /MANIFESTUAC:NO /manifest:embed /DEBUG /PDB:"C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\DADDYKERMITSINTERNAL.PDB" /SUBSYSTEM:WINDOWS /OPT:REF /OPT:ICF /LTCG:incremental /LTCGOUT:"X64\RELEASE\DADDYKERMITSINTERNAL.IOBJ" /TLBID:1 /DYNAMICBASE /NXCOMPAT /IMPLIB:"C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\DADDYKERMITSINTERNAL.LIB" /MACHINE:X64 /DLL X64\RELEASE\ENTRY.OBJ
X64\RELEASE\FNAMEPOOL.OBJ
"DISCORD-RPC.LIB"

```

`x64/Release/Valorant.tlog/link.read.1.tlog`:

```tlog
^C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\DISCORD-RPC.LIB|C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\ENTRY.OBJ|C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\FNAMEPOOL.OBJ
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UM\X64\KERNEL32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UM\X64\USER32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UM\X64\GDI32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UM\X64\WINSPOOL.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UM\X64\COMDLG32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UM\X64\ADVAPI32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UM\X64\SHELL32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UM\X64\OLE32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UM\X64\OLEAUT32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UM\X64\UUID.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UM\X64\ODBC32.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UM\X64\ODBCCP32.LIB
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\ENTRY.OBJ
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\FNAMEPOOL.OBJ
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\DISCORD-RPC.LIB
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\BIN\HOSTX64\X64\C2.DLL
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\LIB\X64\MSVCPRT.LIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\LIB\X64\MSVCRT.LIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\LIB\X64\OLDNAMES.LIB
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\LIB\X64\VCRUNTIME.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.22000.0\UCRT\X64\UCRT.LIB
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\BIN\HOSTX64\X64\1033\LINKUI.DLL
C:\PROGRAM FILES\MICROSOFT VISUAL STUDIO\2022\COMMUNITY\VC\TOOLS\MSVC\14.34.31933\BIN\HOSTX64\X64\CVTRES.EXE
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\VC143.PDB

```

`x64/Release/Valorant.tlog/link.write.1.tlog`:

```tlog
^C:\Users\s\Desktop\Valorant-Internal-main\DaddyKermitsInternal.vcxproj
C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.lib
C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.exp
C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.ipdb
C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.iobj
^C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\DISCORD-RPC.LIB|C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\ENTRY.OBJ|C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\FNAMEPOOL.OBJ
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\DADDYKERMITSINTERNAL.DLL
C:\USERS\S\DESKTOP\VALORANT-INTERNAL-MAIN\X64\RELEASE\DADDYKERMITSINTERNAL.PDB

```

`x64/Release/Valorant.tlog/link.write.2u.tlog`:

```tlog
^C:\Users\s\Desktop\Valorant-Internal-main\DaddyKermitsInternal.vcxproj
C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.lib
C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.exp
C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.ipdb
C:\Users\s\Desktop\Valorant-Internal-main\x64\Release\DaddyKermitsInternal.iobj

```

`x64/Release/_IsIncrementalBuild`:

```
x64\Release\\_IsIncrementalBuild

```