Project Path: arc_gmh5225_EAC-EasyAntiCheat-Src-1_mlg44kc3

Source Tree:

```txt
arc_gmh5225_EAC-EasyAntiCheat-Src-1_mlg44kc3
├── EasyAntiCheat.sys
│   ├── cheatpages.c
│   ├── disk.c
│   ├── dispatchhook.c
│   ├── dr.c
│   ├── driver.c
│   ├── handles.c
│   ├── hiddenprocess.c
│   ├── hwid.c
│   ├── kernelpatch.c
│   ├── mac.c
│   ├── physmem.c
│   ├── pooltags.c
│   ├── process.c
│   ├── servicetable.c
│   ├── suspiciousmodules.c
│   ├── systemthread.c
│   ├── tdl.c
│   └── vm.asm
└── README.md

```

`EasyAntiCheat.sys/cheatpages.c`:

```c
Checked memory types:
[non-shared only ]  Executable.
[non-shared only ]  Executable and read-only.
[including shared]  Executable and read/write.
[non-shared only ]  Executable and copy-on-write.
[non-shared only ]  Non-cacheable and executable.
[non-shared only ]  Non-cacheable, executable, and read-only.
[including shared]  Non-cacheable, executable, and read/write.
[non-shared only ]  Non-cacheable, executable, and copy-on-write.
[non-shared only ]  Guard page and executable.
[non-shared only ]  Guard page, executable, and read-only.
[including shared]  Guard page, executable, and read/write.
[non-shared only ]  Guard page, executable, and copy-on-write.
[non-shared only ]  Non-cacheable, guard page, and executable.
[non-shared only ]  Non-cacheable, guard page, executable, and read-only.
[including shared]  Non-cacheable, guard page, executable, and read/write.
[non-shared only ]  Non-cacheable, guard page, executable, and copy-on-write.

char __fastcall ScanProcessWorkingSet(__int64 process, char previousMode, WORKINGSET_DETECTION_BUFFER **outDetectionBuffer)
{
  char v3; // bp
  MEMORY_WORKING_SET_INFORMATION *wsi; // rax MAPDST
  WORKINGSET_DETECTION_BUFFER *detectionBuffer; // rax MAPDST
  ULONG_PTR v12; // r12
  int *info; // rbx
  unsigned __int64 protection; // rax

  v3 = 0;
  if ( !outDetectionBuffer )
    return 0;
  *outDetectionBuffer = 0i64;
  wsi = (MEMORY_WORKING_SET_INFORMATION *)AllocatePool(0x100000i64);
  if ( !wsi )
    return v3;
  if ( !QueryVirtualMemory0(0i64, process, 1u, (__int64)wsi, previousMode, 0x100000i64) )// MemoryWorkingSetInformation
    goto LABEL_33;
  detectionBuffer = (WORKINGSET_DETECTION_BUFFER *)AllocatePool(2048i64);
  if ( detectionBuffer )
  {
    memset(detectionBuffer, 0, 2048ui64);
    detectionBuffer->usedBytes = 16;
    detectionBuffer->maxSize = 2048;
  }
  *outDetectionBuffer = detectionBuffer;
  if ( !detectionBuffer )
    goto LABEL_33;
  v12 = 0i64;
  if ( !wsi->NumberOfEntries )
    goto LABEL_32;
  info = (int *)wsi->WorkingSetInfo;
  do
  {
    protection = *(_QWORD *)info & 0x1Fi64;
    if ( protection > 19 )
    {
      if ( protection == 22 )
        goto check_entry;                       // Guard page, executable, and read/write.
      if ( protection != 23 )
      {
        if ( protection <= 25 )
          goto skip_entry;
        if ( protection > 27 )
        {
          if ( protection == 30 )
            goto check_entry;                   // Non-cacheable, guard page, executable, and read/write.
          if ( protection != 31 )
            goto skip_entry;
        }
      }
    }
    else if ( protection < 18 )
    {
      if ( protection < 2 )
        goto skip_entry;
      if ( protection > 3 )
      {
        if ( protection == 6 )
          goto check_entry;                     // Executable and read/write.
        if ( protection != 7 )
        {
          if ( protection <= 9 )
            goto skip_entry;
          if ( protection > 0xB )
          {
            if ( protection == 14 )
              goto check_entry;                 // Non-cacheable, executable, and read/write.
            if ( protection != 15 )
              goto skip_entry;
          }
        }
      }
    }
    if ( previousMode && !_bittest64((const signed __int64 *)info, 8u) )// bit 8 = shared
    {
check_entry:
      v3 = 1;
      CheckWorkingSetEntry(*outDetectionBuffer, info, previousMode);
    }
skip_entry:
    ++v12;
    info += 2;
  }
  while ( v12 < wsi->NumberOfEntries );
  if ( !v3 )
  {
LABEL_32:
    FreePool((__int64)*outDetectionBuffer);
    *outDetectionBuffer = 0i64;
  }
LABEL_33:
  FreePool((__int64)wsi);
  return v3;
}

char __usercall CheckWorkingSetEntry@<al>(WORKINGSET_DETECTION_BUFFER *detectionBuffer@<rdx>, int *pWsiInfo@<r8>, signed int previousMode@<r14d>)
{
  unsigned __int64 v3; // rax
  void *address; // rdi
  unsigned __int64 v7; // r9
  WORKINGSET_DETECTION_ENTRY *prevEntry; // r8
  int wsiInfo; // eax
  __int64 v10; // rdx
  UNICODE_STRING mappedFilename; // [rsp+30h] [rbp-88h]
  UNICODE_STRING string; // [rsp+40h] [rbp-78h]
  WORKINGSET_DETECTION_ENTRY detectionEntry; // [rsp+50h] [rbp-68h]
  MEMORY_BASIC_INFORMATION mbi; // [rsp+78h] [rbp-40h]

  detectionEntry.address = 0i64;
  LOBYTE(v3) = 0;
  address = (void *)(*(_QWORD *)pWsiInfo & 0xFFFFFFFFFFFFF000ui64);// extract page address
  *(_QWORD *)&detectionEntry.offsetFromAllocationBase = 0i64;
  *(_QWORD *)&detectionEntry.isShared = 0i64;
  *(_QWORD *)&detectionEntry.mappedFilename[7] = 0i64;
  detectionEntry.mappedFilename[15] = 0;
  if ( !detectionBuffer )
    return v3;
  LODWORD(v3) = detectionBuffer->maxSize;
  if ( (unsigned int)v3 < 0x10 )
    return v3;
  LODWORD(v3) = v3 - detectionBuffer->usedBytes;
  ++detectionBuffer->unk123;
  if ( (unsigned int)v3 < 33 )
    return v3;
  mbi.BaseAddress = address;
  LOBYTE(v3) = (signed int)QueryVirtualMemory((__int64)address, -1i64, 0, (__int64)&mbi, previousMode, 48i64, 0i64) >= 0;
  if ( !(_BYTE)v3 )
  {
    detectionEntry.address = (__int64)address;
LABEL_14:
    wsiInfo = *pWsiInfo;
    v10 = (unsigned int)detectionBuffer->count;
    detectionEntry.isShared = (*pWsiInfo & 0x100i64) != 0;
    detectionEntry.protection = wsiInfo & 0x1F;
    detectionBuffer->count = v10 + 1;
    LOBYTE(v3) = (unsigned __int64)memmove(&detectionBuffer->entries[v10], &detectionEntry, 33ui64);
    detectionBuffer->usedBytes += 33;
    return v3;
  }
  v7 = 0i64;
  if ( !detectionBuffer->count )
  {
LABEL_9:
    detectionEntry.address = (__int64)mbi.AllocationBase;
    detectionEntry.offsetFromAllocationBase = (_DWORD)address - LODWORD(mbi.AllocationBase);
    if ( GetMappedFilename(-1i64, (__int64)mbi.AllocationBase, (__int64)&mappedFilename, previousMode) )
    {
      if ( sub_289F0(&mappedFilename.Length, (__int64)&string) )
        CopyUnicodeStringToAnsiBuffer((__int64)detectionEntry.mappedFilename, 16i64, &string);
      FreeUnicodeString(&mappedFilename);
    }
    goto LABEL_14;
  }
  prevEntry = detectionBuffer->entries;
  while ( (PVOID)prevEntry->address != mbi.AllocationBase )
  {
    v3 = (unsigned int)detectionBuffer->count;
    ++v7;
    ++prevEntry;
    if ( v7 >= v3 )
      goto LABEL_9;
  }
  return v3;
}
```

`EasyAntiCheat.sys/disk.c`:

```c
void __usercall SendDiskInformation(unsigned int a1@<ecx>, signed int a2@<r14d>)
{
  int crc32; // ebx
  unsigned int packetValueUnk; // ecx
  UNICODE_STRING deviceSerial; // [rsp+20h] [rbp-18h]

  deviceSerial.Length = 0;
  *(_QWORD *)&deviceSerial.MaximumLength = 0i64;
  crc32 = 0;
  *(_DWORD *)((char *)&deviceSerial.Buffer + 2) = 0;
  HIWORD(deviceSerial.Buffer) = 0;
  if ( QueryFilesystemDeviceSerial(3i64, &deviceSerial, a2)
    && deviceSerial.Buffer
    && deviceSerial.Length
    && deviceSerial.MaximumLength )
  {
    crc32 = HashCRC32((char *)deviceSerial.Buffer, deviceSerial.Length, deviceSerial.Length);
  }
  if ( !a1 || !crc32 || (packetValueUnk = 316, a1 != crc32) )
    packetValueUnk = 315;
  SendHWIDDataToServer(packetValueUnk, a1, crc32, &deviceSerial);
  if ( deviceSerial.Buffer && deviceSerial.Length )
  {
    if ( deviceSerial.MaximumLength )
      FreeUnicodeString(&deviceSerial);
  }
}

char __usercall QueryFilesystemDeviceSerial@<al>(__int64 a1@<rcx>, UNICODE_STRING *outData@<rdx>, signed int a3@<r14d>)
{
  char success; // bl
  _DEVICE_OBJECT *deviceObject; // rax MAPDST
  _DEVICE_OBJECT *filesystemDevice; // rax MAPDST
  UNICODE_STRING driverName; // [rsp+20h] [rbp-18h]

  success = 0;
  if ( !outData || KeGetCurrentIrql() || (unsigned __int8)import_KeAreAllApcsDisabled(a1) )
    return 0;
  InitializeUnicodeStringWithCStr(&driverName, (_WORD *)(StringTable + 4419));// \Driver\disk
  deviceObject = (_DEVICE_OBJECT *)GetLastDeviceObjectForDriver(&driverName, a3);
  if ( deviceObject )
  {
    filesystemDevice = (_DEVICE_OBJECT *)IoGetDeviceAttachmentBaseRef(deviceObject);
    if ( filesystemDevice )
    {
      if ( filesystemDevice != deviceObject )
        success = QueryDriveSmartOrStorageData(filesystemDevice, 3, outData);// 3 = query serial
      ObfDereferenceObject(filesystemDevice);
    }
    ObfDereferenceObject(deviceObject);
  }
  return success;
}

__int64 __usercall GetLastDeviceObjectForDriver@<rax>(UNICODE_STRING *driverName@<rcx>, signed int a2@<r14d>)
{
  unsigned int v2; // ebx
  __int64 lastDeviceObject; // r12
  _IMAGE_DOS_HEADER *v4; // rax
  __int64 IoDeviceObject; // rsi
  signed int status1; // edi MAPDST
  unsigned int access; // ST20_4
  unsigned int status0; // eax
  unsigned int bufferSize; // ebp
  __int64 deviceObjectList; // rsi
  __int64 lastDeviceIndex; // rcx
  PVOID *currentDeviceObject; // rdi
  PVOID *v16; // [rsp+20h] [rbp-78h]
  __int64 v17; // [rsp+28h] [rbp-70h]
  OBJECT_ATTRIBUTES objectAttributes; // [rsp+40h] [rbp-58h]
  __int64 deviceObjectNumber; // [rsp+A0h] [rbp+8h]
  PVOID driverObject; // [rsp+A8h] [rbp+10h]
  __int64 driverHandle; // [rsp+B0h] [rbp+18h]

  v2 = 0;
  lastDeviceObject = 0i64;
  LODWORD(deviceObjectNumber) = 0;
  if ( !driverName || !driverName->Buffer || !driverName->Length || !driverName->MaximumLength )
    return 0i64;
  objectAttributes.Length = 48;
  objectAttributes.RootDirectory = 0i64;
  objectAttributes.Attributes = 576;
  objectAttributes.ObjectName = driverName;
  objectAttributes.SecurityDescriptor = 0i64;
  objectAttributes.SecurityQualityOfService = 0i64;
  v4 = (_IMAGE_DOS_HEADER *)qword_4D8C8;
  if ( qword_4D8C8 || (v4 = FindExport(&unk_46B38), IoDeviceObject = 0i64, (qword_4D8C8 = (__int64)v4) != 0) )
    IoDeviceObject = *(_QWORD *)&v4->e_magic;
  if ( IoDeviceObject )
  {
    status1 = 0xC0000002;
    if ( import_ObOpenObjectByName )
    {
      access = 0x80000000;
      status1 = import_ObOpenObjectByName(&objectAttributes, IoDeviceObject, 0i64, 0i64, access, 0i64, &driverHandle);
    }
    else
    {
      status1 = 0xC0000002;
    }
    if ( status1 >= 0 )
    {
      if ( import_ObReferenceObjectByHandle )
      {
        v17 = 0i64;
        v16 = &driverObject;
        status1 = import_ObReferenceObjectByHandle(driverHandle, 1i64, IoDeviceObject);
      }
      else
      {
        status1 = 0xC0000002;
      }
      if ( status1 >= 0 )
      {
        if ( import_IoEnumerateDeviceObjectList )
          status0 = import_IoEnumerateDeviceObjectList(driverObject, 0i64, 0i64, &deviceObjectNumber, v16, v17);
        else
          status0 = 0xC0000002;
        if ( status0 == 0xC0000023 && (unsigned int)deviceObjectNumber > 0 )
        {
          bufferSize = 8 * deviceObjectNumber;
          deviceObjectList = AllocatePool((unsigned int)(8 * deviceObjectNumber));
          if ( deviceObjectList )
          {
            if ( import_IoEnumerateDeviceObjectList )
              status1 = import_IoEnumerateDeviceObjectList(
                          driverObject,
                          deviceObjectList,
                          bufferSize,
                          &deviceObjectNumber,
                          v16,
                          v17);
            if ( status1 >= 0 && (unsigned int)deviceObjectNumber > 0 )
            {
              lastDeviceIndex = (unsigned int)(deviceObjectNumber - 1);
              lastDeviceObject = *(_QWORD *)(deviceObjectList + 8 * lastDeviceIndex);
              if ( (unsigned int)lastDeviceIndex > 0 )
              {
                currentDeviceObject = (PVOID *)deviceObjectList;
                do
                {
                  ObfDereferenceObject(*currentDeviceObject);
                  ++v2;
                  ++currentDeviceObject;
                }
                while ( v2 < (signed int)deviceObjectNumber - 1 );
              }
            }
            FreePool(deviceObjectList);
          }
        }
        ObfDereferenceObject(driverObject);
      }
      CloseHandle(driverHandle, a2);
    }
  }
  return lastDeviceObject;
}

char __fastcall QueryDriveSmartOrStorageData(_DEVICE_OBJECT *deviceObject, int whatToQueryEnum, UNICODE_STRING *outData)
{
  char success; // bl

  success = 0;
  if ( !deviceObject
    || !outData
    || whatToQueryEnum != 2 && whatToQueryEnum != 3
    || KeGetCurrentIrql()
    || (unsigned __int8)import_KeAreAllApcsDisabled(deviceObject) )
  {
    return 0;
  }
  if ( QuerySmartData(whatToQueryEnum, deviceObject, outData)
    || QueryStorageProperty(whatToQueryEnum, deviceObject, outData) )
  {
    success = 1;
  }
  return success;
}

bool __fastcall QuerySmartData(int whatToQueryEnum, _DEVICE_OBJECT *deviceObject, UNICODE_STRING *outData)
{
  bool success; // bl
  _SENDCMDOUTPARAMS *outParams; // rsi
  int querySerial; // edi
  BYTE *data; // rbp
  size_t dataLength; // rdi
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r11
  char v13; // cl
  char v14; // al
  unsigned __int8 c; // al
  ANSI_STRING ansiString; // [rsp+30h] [rbp-C8h]
  SENDCMDINPARAMS inParams; // [rsp+40h] [rbp-B8h]
  char v19; // [rsp+6Eh] [rbp-8Ah]
  char v20; // [rsp+6Fh] [rbp-89h]
  char copiedData[128]; // [rsp+70h] [rbp-88h]
                                                // https://www.winsim.com/diskid32/diskid32.cpp
  success = 0;
  if ( deviceObject && outData )
  {
    outParams = (_SENDCMDOUTPARAMS *)AllocatePool(529i64);
    if ( !outParams )
      return success;
    *(_QWORD *)&outParams->cBufferSize = 0i64;
    *(_QWORD *)outParams->DriverStatus.dwReserved = 0i64;
    outParams->bBuffer[0] = 0;
    memset(&inParams, 0, 33ui64);
    inParams.irDriveRegs.bCommandReg = -20;     // Returns ID sector for ATA
    if ( SendIoControl(
           (__int64)&dword_7C088,               // SMART_RCV_DRIVE_DATA
           deviceObject,
           (__int64)&inParams,
           33u,
           (__int64)outParams,
           529) >= 0 )
    {
      querySerial = whatToQueryEnum - 2;
      if ( !querySerial )
      {
        data = (BYTE *)outParams[3].DriverStatus.dwReserved + 2;// model number
        dataLength = 40i64;
        goto LABEL_9;
      }
      if ( querySerial == 1 )
      {
        data = outParams[1].bBuffer;            // serial number
        dataLength = 20i64;
LABEL_9:
        if ( data && dataLength > 0 )
        {
          memset(copiedData, 0, 128ui64);
          memmove(copiedData, data, dataLength);
          v11 = dataLength - 1;
          v12 = 0i64;
          if ( dataLength - 1 > 0 )
          {
            do
            {
              v13 = copiedData[v12];
              v14 = copiedData[v12 + 1];
              v12 += 2i64;
              *(&v19 + v12) = v14;
              *(&v20 + v12) = v13;
            }
            while ( v12 < v11 );
            if ( v11 > 0 )
            {
              do
              {
                c = copiedData[v11];
                if ( (c < '\t' || c > '\r') && c != 0x20 )
                {
                  if ( c )
                    break;
                }
                else
                {
                  copiedData[v11] = 0;
                }
                --v11;
              }
              while ( v11 );
            }
          }
          ansiString.Buffer = copiedData;
          SetAnsiStringLength(&ansiString, copiedData);
          success = (signed int)AnsiStringToUnicodeString(outData, &ansiString) >= 0;
        }
        goto LABEL_21;
      }
    }
LABEL_21:
    FreePool((__int64)outParams);
    return success;
  }
  return 0;
}

bool __fastcall QueryStorageProperty(int whatToQueryEnum, _DEVICE_OBJECT *driverObject, UNICODE_STRING *outData)
{
  bool status; // bl
  unsigned __int64 dataLength; // rdi
  _STORAGE_DEVICE_DESCRIPTOR *deviceDescriptor; // rsi MAPDST
  char *deviceDescriptorEnd; // rcx
  int querySerial; // ebp
  char *data; // rdx
  unsigned __int64 maxSize0; // rcx
  unsigned __int64 maxSize1; // rcx
  size_t length; // rbp
  signed __int64 v16; // rax
  unsigned __int8 c; // cl
  _STORAGE_PROPERTY_QUERY propertyQuery; // [rsp+30h] [rbp-B8h]
  ANSI_STRING ansiString; // [rsp+40h] [rbp-A8h]
  char copiedData[128]; // [rsp+50h] [rbp-98h]
  __int64 requiredSize; // [rsp+F8h] [rbp+10h]

  status = 0;
  dataLength = 0i64;
  if ( driverObject && outData )
  {
    requiredSize = 0i64;
    *(_DWORD *)propertyQuery.AdditionalParameters = 0;
    propertyQuery.QueryType = 0;
    propertyQuery.PropertyId = 0;
    if ( SendIoControl(2954240i64, driverObject, (__int64)&propertyQuery, 0xCu, (__int64)&requiredSize, 8) < 0 )
      return status;
    if ( HIDWORD(requiredSize) <= 0x28 )
      return status;
    deviceDescriptor = (_STORAGE_DEVICE_DESCRIPTOR *)AllocatePool(HIDWORD(requiredSize));
    if ( !deviceDescriptor )
      return status;
    memset(deviceDescriptor, 0, HIDWORD(requiredSize));
    *(_DWORD *)propertyQuery.AdditionalParameters = 0;
    propertyQuery.QueryType = 0;                // StorageDeviceProperty
    propertyQuery.PropertyId = 0;               // PropertyStandardQuery
    if ( SendIoControl(
           0x2D1400i64,                         // IOCTL_STORAGE_QUERY_PROPERTY
           driverObject,
           (__int64)&propertyQuery,
           0xCu,
           (__int64)deviceDescriptor,
           SHIDWORD(requiredSize)) >= 0 )
    {
      deviceDescriptorEnd = (char *)deviceDescriptor + HIDWORD(requiredSize);
      querySerial = whatToQueryEnum - 2;
      if ( querySerial )
      {
        if ( querySerial == 1 && deviceDescriptor->SerialNumberOffset )
        {
          data = (char *)deviceDescriptor + deviceDescriptor->SerialNumberOffset;
          if ( data < (char *)deviceDescriptor || data >= deviceDescriptorEnd )
            goto LABEL_24;
          maxSize0 = deviceDescriptorEnd - data;
          if ( data )
          {
            if ( maxSize0 > 0 )
            {
              do
              {
                if ( !data[dataLength] )
                  break;
                ++dataLength;
              }
              while ( dataLength < maxSize0 );
            }
            goto LABEL_24;
          }
        }
      }
      else if ( deviceDescriptor->ProductIdOffset )
      {
        data = (char *)deviceDescriptor + deviceDescriptor->ProductIdOffset;
        if ( data < (char *)deviceDescriptor || data >= deviceDescriptorEnd )
          goto LABEL_24;
        maxSize1 = deviceDescriptorEnd - data;
        if ( data )
        {
          if ( maxSize1 > 0 )
          {
            do
            {
              if ( !data[dataLength] )
                break;
              ++dataLength;
            }
            while ( dataLength < maxSize1 );
          }
LABEL_24:
          if ( data && dataLength > 0 )
          {
            length = 127i64;
            if ( dataLength < 127 )
              length = dataLength;
            memmove(copiedData, data, length);
            copiedData[length] = 0;
            if ( length )
            {
              v16 = length - 1;
              if ( length - 1 > 0 )
              {
                do
                {
                  c = copiedData[v16];
                  if ( (c < '\t' || c > '\r') && c != ' ' )
                  {
                    if ( c )
                      break;
                  }
                  else
                  {
                    copiedData[v16] = 0;
                  }
                  --v16;
                }
                while ( v16 );
              }
            }
            *(_QWORD *)&ansiString.Length = copiedData;// it's Buffer but hexrays is doing weird shit
            SetAnsiStringLength(&ansiString, copiedData);
            status = (signed int)AnsiStringToUnicodeString(outData, &ansiString) >= 0;
          }
          goto LABEL_37;
        }
      }
    }
LABEL_37:
    FreePool((__int64)deviceDescriptor);
    return status;
  }
  return 0;
}
```

`EasyAntiCheat.sys/dispatchhook.c`:

```c
char __usercall CheckDriverDispatch@<al>(DRIVER_OBJECT *driverObject@<rcx>, _DWORD *detectionData@<r8>, _DWORD *outStatus@<r9>, signed int a4@<r14d>)
{
  char v4; // bp
  PDRIVER_DISPATCH addr; // rdi
  SYSTEM_MODULE_INFORMATION *moduleInformation; // rax MAPDST
  ULONG moduleIndex; // ecx
  PVOID *cur; // r12
  _BYTE *fileName; // rdx
  unsigned __int64 nameLength; // rax
  size_t nameLength2; // rdi

  v4 = 0;
  if ( !driverObject )
  {
    if ( outStatus )
      *outStatus = 2;
    return 0;
  }
  addr = driverObject->MajorFunction[14];
  if ( !addr )
  {
    if ( outStatus )
      *outStatus = 4;
    return 0;
  }
  moduleInformation = (SYSTEM_MODULE_INFORMATION *)QuerySystemModuleInformation(a4);
  if ( !moduleInformation )
  {
    if ( outStatus )
      *outStatus = 5;
    return 0;
  }
  moduleIndex = 0;
  if ( moduleInformation->Count )
  {
    cur = &moduleInformation->Module[0].ImageBase;
    while ( (unsigned __int64)*cur < MmSystemRangeStart
         || (char *)addr < *cur
         || (char *)addr > (char *)*cur + *((unsigned int *)cur + 2) )
    {
      ++moduleIndex;
      cur += 37;
      if ( moduleIndex >= moduleInformation->Count )
        goto LABEL_29;
    }
    v4 = 1;
    if ( detectionData )
    {
      fileName = cur + 3;
      nameLength = 0i64;
      *detectionData = (_DWORD)addr - *(_DWORD *)cur;
      if ( cur == (PVOID *)0xFFFFFFFFFFFFFFE8i64 )
        goto LABEL_35;
      do
      {
        if ( !fileName[nameLength] )
          break;
        ++nameLength;
      }
      while ( nameLength < 256 );
      nameLength2 = 255i64;
      if ( nameLength < 255 )
      {
LABEL_35:
        nameLength2 = 0i64;
        if ( cur != (PVOID *)0xFFFFFFFFFFFFFFE8i64 )
        {
          do
          {
            if ( !fileName[nameLength2] )
              break;
            ++nameLength2;
          }
          while ( nameLength2 < 256 );
        }
      }
      memmove(detectionData + 2, fileName, nameLength2);
      *((_BYTE *)detectionData + nameLength2 + 8) = 0;
      detectionData[1] = *((_DWORD *)cur + 2);
    }
    if ( outStatus )
      *outStatus = 7;
  }
LABEL_29:
  FreePool((__int64)moduleInformation);
  if ( !v4 && outStatus )
    *outStatus = 6;
  return v4;
}
```

`EasyAntiCheat.sys/dr.c`:

```c
void CheckDebugRegisters()
{
  __int64 v0; // rdx
  __int64 v1; // rcx
  __int64 v2; // rax
  __int64 currentProcessID; // rax
  __int64 *v4; // rax MAPDST
  unsigned __int64 dr7; // [rsp+38h] [rbp+10h]
  unsigned __int64 dr6; // [rsp+40h] [rbp+18h]

  ReadDR6_DR7(&dr6, &dr7);
  if ( (_BYTE)dr7 )
  {
    v2 = import_PsGetCurrentProcess(v1, v0);
    if ( import_PsGetProcessId )
      currentProcessID = import_PsGetProcessId(v2);
    else
      currentProcessID = 0i64;
    v4 = sub_29404(currentProcessID);
    if ( v4 )
    {
      sub_330E0((__int64)v4, 14i64, 0);
      sub_29534((__int64)v4);
    }
  }
}
```

`EasyAntiCheat.sys/driver.c`:

```c
SYSTEM_MODULE_INFORMATION *__usercall LogAllLoadedDrivers@<rax>(signed int a1@<r14d>)
{
  signed __int64 v1; // r13
  SYSTEM_MODULE_INFORMATION *result; // rax
  SYSTEM_MODULE_INFORMATION *systemModuleInformation; // rdi
  _DWORD *logBuffer; // rsi
  _IMAGE_DOS_HEADER *moduleBuffer; // r14
  ULONG moduleIndex; // er15
  PVOID *currentModule; // r12
  __int64 moduleBase; // rcx
  signed __int64 moduleName; // rbp
  unsigned __int64 nameLength; // rbx
  __int64 offsetToFilename; // rax
  signed __int64 v12; // r13
  unsigned __int64 v13; // rdx
  _BYTE *v14; // rcx
  unsigned __int64 v15; // r8
  signed __int64 v16; // rbp
  char v17; // al
  __int64 checksumAndTimestamp; // [rsp+20h] [rbp-38h]
  ULONG entrypointRva; // [rsp+28h] [rbp-30h]
  __int16 nameLength0; // [rsp+2Ch] [rbp-2Ch]
  _IMAGE_NT_HEADERS64 *ntHeaders; // [rsp+60h] [rbp+8h]

  v1 = 4i64;
  result = (SYSTEM_MODULE_INFORMATION *)QuerySystemModuleInformation(a1);
  systemModuleInformation = result;
  if ( result )
  {
    if ( result->Count )
    {
      logBuffer = (_DWORD *)AllocatePool(0x2000i64);
      if ( logBuffer )
      {
        *logBuffer = 0;
        moduleBuffer = (_IMAGE_DOS_HEADER *)AllocatePool(4096i64);
        if ( moduleBuffer )
        {
          moduleIndex = 0;
          if ( systemModuleInformation->Count )
          {
            currentModule = &systemModuleInformation->Module[0].ImageBase;
            do
            {
              moduleBase = (__int64)*currentModule;
              if ( (unsigned __int64)*currentModule >= MmSystemRangeStart && moduleBase != EACBase )
              {
                if ( (unsigned __int64)(v1 + 270) > 0x2000 )
                  break;
                checksumAndTimestamp = 0i64;
                entrypointRva = 0;
                if ( CopyVirtualMemory(moduleBase, 4096i64, (__int64)moduleBuffer) == 4096
                  && ValidatePeHeader(moduleBuffer, 0x1000ui64, 0i64, &ntHeaders) )
                {
                  HIDWORD(checksumAndTimestamp) = ntHeaders->OptionalHeader.CheckSum;
                  LODWORD(checksumAndTimestamp) = ntHeaders->FileHeader.TimeDateStamp;
                  entrypointRva = ntHeaders->OptionalHeader.AddressOfEntryPoint;
                }
                moduleName = (signed __int64)(currentModule + 3);
                nameLength = 0i64;
                if ( currentModule != (PVOID *)0xFFFFFFFFFFFFFFE8i64 )
                {
                  do
                  {
                    if ( !*(_BYTE *)(nameLength + moduleName) )
                      break;
                    ++nameLength;
                  }
                  while ( nameLength < 0xFF );
                }
                nameLength0 = nameLength;
                if ( *((_WORD *)currentModule + 11) == 29
                  && strstrIgnoreCase((_BYTE *)currentModule + 0x18, (_BYTE *)(StringTable + 1187), 29ui64) )// \SystemRoot\system32\drivers\
                {
                  offsetToFilename = *((unsigned __int16 *)currentModule + 11);
                  moduleName += offsetToFilename;
                  LOWORD(nameLength) = nameLength - offsetToFilename;
                  nameLength0 = nameLength;
                }
                *(_QWORD *)((char *)logBuffer + v1) = checksumAndTimestamp;
                v12 = v1 + 14;
                v13 = 0x2000 - v12;
                *(_DWORD *)((char *)logBuffer + v12 - 6) = entrypointRva;
                *(_WORD *)((char *)logBuffer + v12 - 2) = nameLength0;
                v14 = (char *)logBuffer + v12;
                if ( v12 != 0x2000 && v13 <= 0x7FFFFFFF )
                {
                  if ( (unsigned __int16)nameLength <= 0x7FFFFFFEui64 )
                  {
                    v15 = (unsigned __int16)nameLength - v13;
                    v16 = moduleName - (_QWORD)v14;
                    do
                    {
                      if ( !(v15 + v13) )
                        break;
                      v17 = v14[v16];
                      if ( !v17 )
                        break;
                      *v14++ = v17;
                      --v13;
                    }
                    while ( v13 );
                    if ( !v13 )
                      --v14;
                  }
                  *v14 = 0;
                }
                v1 = (unsigned __int16)nameLength + v12;
                ++*logBuffer;
              }
              ++moduleIndex;
              currentModule += 37;
            }
            while ( moduleIndex < systemModuleInformation->Count );
          }
          FreePool((__int64)moduleBuffer);
        }
        SendPacketToServer(294i64, (__int64)logBuffer, (unsigned int)v1);
        FreePool((__int64)logBuffer);
      }
    }
    result = (SYSTEM_MODULE_INFORMATION *)FreePool((__int64)systemModuleInformation);
  }
  return result;
}

__int64 __usercall IterateDirectoriesRecursive@<rax>(UNICODE_STRING *argPath@<rdx>, __int64 *outBuffer@<rcx>, unsigned int a3@<r8d>, unsigned int a4@<r9d>, signed int a5@<r14d>, char a6)
{
  unsigned int index; // ebp
  __int64 directoryObject; // rbx
  signed int status; // eax
  OBJECT_DIRECTORY_INFORMATION *objectInfo; // rsi
  bool isDirectory; // al MAPDST
  bool isRoot; // bl
  unsigned __int16 fullLength; // r8
  DRIVER_OBJECT *driver; // rax MAPDST
  __int64 v16; // rax
  __int64 a6a; // [rsp+20h] [rbp-98h]
  bool isDriver; // [rsp+40h] [rbp-78h]
  int v21; // [rsp+44h] [rbp-74h]
  UNICODE_STRING path; // [rsp+48h] [rbp-70h]
  __int64 directoryHandle; // [rsp+58h] [rbp-60h]
  UNICODE_STRING argPathCopy; // [rsp+60h] [rbp-58h]
  OBJECT_ATTRIBUTES objectAttributes; // [rsp+70h] [rbp-48h]

  index = 0;
  v21 = 0;
  if ( !outBuffer )
    return 0i64;
  if ( !argPath )
    return 0i64;
  if ( !argPath->Buffer )
    return 0i64;
  if ( !argPath->Length )
    return 0i64;
  if ( !argPath->MaximumLength )
    return 0i64;
  if ( !a3 )
    return 0i64;
  if ( !a4 )
    return 0i64;
  directoryObject = GetDirectoryObjectType(a5);
  if ( !directoryObject || !AllocateCopyUnicodeString((__int64)&argPathCopy, argPath) )
    return 0i64;
  objectAttributes.Length = 48;
  objectAttributes.RootDirectory = 0i64;
  objectAttributes.ObjectName = &argPathCopy;
  objectAttributes.Attributes = 512;
  objectAttributes.SecurityDescriptor = 0i64;
  objectAttributes.SecurityQualityOfService = 0i64;
  if ( import_ObOpenObjectByName )
    status = import_ObOpenObjectByName(&objectAttributes, directoryObject, 0i64, 0i64, 1, 0i64, &directoryHandle);
  else
    status = 0xC0000002;
  if ( status >= 0 )
  {
    objectInfo = (OBJECT_DIRECTORY_INFORMATION *)AllocatePool(1024i64);
    if ( objectInfo )
    {
      if ( a3 > 0 )
      {
        do
        {
          LOBYTE(a6a) = 0;
          if ( (signed int)GetNextDirectoryObject((__int64)objectInfo, directoryHandle, 0x400u, a5, a6a, (__int64)&v21) < 0 )
            break;
          isDriver = CompareUnicodeStrings((__int64)&objectInfo->TypeName, (_WORD *)(StringTable + 1247)) == 0;// Driver
          isDirectory = CompareUnicodeStrings((__int64)&objectInfo->TypeName, (_WORD *)(StringTable + 1261)) == 0;// Directory
          if ( (isDriver || isDirectory)
            && argPath->Buffer
            && argPath->Length
            && argPath->MaximumLength
            && objectInfo->Name.Buffer
            && objectInfo->Name.Length
            && objectInfo->Name.MaximumLength )
          {
            isRoot = CompareUnicodeStrings((__int64)argPath, (_WORD *)(StringTable + 1217)) == 0;// \
            fullLength = objectInfo->Name.Length + argPath->Length;
            if ( !isRoot )
              fullLength += 2;
            if ( AllocatePoolForUnicodeString((__int64)&path, argPath, fullLength) )
            {
              if ( !isRoot && StringTable != 4294966079 )
                CopyUnicodeString(&path, StringTable + 1217);// \
              if ( (signed int)AppendUnicodeString(&path, objectInfo) >= 0 )
              {
                if ( isDirectory && a4 > 0 )
                {
                  index += IterateDirectoriesRecursive(&path, &outBuffer[index], a3 - index, a4 - 1, a5, a6);
                }
                else if ( isDriver )
                {
                  driver = (DRIVER_OBJECT *)OpenDriver(&path.Length);
                  if ( driver )
                  {
                    if ( !a6 || driver->DriverSection && driver->DriverStart && driver->DriverSize )
                    {
                      v16 = index++;
                      outBuffer[v16] = (__int64)driver;
                    }
                    else
                    {
                      ObfDereferenceObject(driver);
                    }
                  }
                }
              }
              FreeUnicodeString(&path);
            }
          }
        }
        while ( index < a3 );
      }
      FreePool((__int64)objectInfo);
    }
    CloseHandle(directoryHandle, a5);
  }
  FreeUnicodeString(&argPathCopy);
  return index;
}

char __usercall CheckDriverObjects@<al>(_QWORD *a1@<rcx>, _DWORD *a2@<rdx>, __int64 detectionBuffer@<r8>, signed int a4@<r14d>)
{
  char v4; // bl
  __int64 directoryObject; // rdi
  SYSTEM_MODULE_INFORMATION *moduleInfo; // rsi
  signed int v10; // ST20_4
  signed int v11; // eax
  OBJECT_DIRECTORY_INFORMATION *objectInfo; // rdi
  __int64 v14; // [rsp+20h] [rbp-88h]
  UNICODE_STRING v15; // [rsp+40h] [rbp-68h]
  OBJECT_ATTRIBUTES v2; // [rsp+50h] [rbp-58h]
  int v17; // [rsp+B0h] [rbp+8h]
  __int64 directoryHandle; // [rsp+C8h] [rbp+20h]

  v4 = 0;
  v17 = 0;
  if ( !a1 || !a2 || !detectionBuffer )
    return 0;
  directoryObject = GetDirectoryObjectType(a4);
  if ( directoryObject )
  {
    moduleInfo = (SYSTEM_MODULE_INFORMATION *)QuerySystemModuleInformation(a4);
    if ( moduleInfo )
    {
      InitializeUnicodeStringWithCStr(&v15, (_WORD *)(StringTable + 1221));// \Driver\
      v2.Length = 48;
      v2.ObjectName = &v15;
      v2.RootDirectory = 0i64;
      v2.Attributes = 512;
      v2.SecurityDescriptor = 0i64;
      v2.SecurityQualityOfService = 0i64;
      if ( import_ObOpenObjectByName )
      {
        v10 = 1;
        v11 = import_ObOpenObjectByName(&v2, directoryObject, 0i64, 0i64, v10, 0i64, &directoryHandle);
      }
      else
      {
        v11 = 0xC0000002;
      }
      if ( v11 >= 0 )
      {
        objectInfo = (OBJECT_DIRECTORY_INFORMATION *)AllocatePool(0x400i64);
        if ( objectInfo )
        {
          while ( 1 )
          {
            LOBYTE(v14) = 0;
            if ( (signed int)GetNextDirectoryObject(
                               (__int64)objectInfo,
                               directoryHandle,
                               0x400u,
                               a4,
                               v14,
                               (__int64)&v17) < 0 )
              break;
            if ( IsDriverNotBackedByModule(objectInfo, moduleInfo, a1, a2) )
            {
              AllocateCopyUnicodeString(detectionBuffer, &objectInfo->Name);
              v4 = 1;
              break;
            }
          }
          FreePool((__int64)objectInfo);
        }
        CloseHandle(directoryHandle, a4);
      }
      FreePool((__int64)moduleInfo);
    }
  }
  return v4;
}

char __fastcall IsDriverNotBackedByModule(OBJECT_DIRECTORY_INFORMATION *objectInfo, SYSTEM_MODULE_INFORMATION *moduleInfo, _QWORD *a3, _DWORD *a4)
{
  char v4; // bl
  unsigned __int64 v6; // rsi
  int v11; // eax
  signed int v12; // eax
  unsigned __int64 driverStart; // rcx
  __int64 v15; // rcx
  int v16; // er11
  DRIVER_OBJECT *driverObject; // [rsp+40h] [rbp-38h] MAPDST
  UNICODE_STRING driverName; // [rsp+48h] [rbp-30h]

  v4 = 0;
  v6 = (unsigned __int64)EACBase >> 32;
  if ( !import_IoDriverObjectType )
  {
    import_IoDriverObjectType = (__int64)FindExport(&unk_46B38);
    if ( !import_IoDriverObjectType )
      return 0;
  }
  if ( objectInfo )
  {
    if ( moduleInfo )
    {
      if ( a3 )
      {
        if ( a4 )
        {
          if ( (_DWORD)v6 )
          {
            driverName.Buffer = (PWSTR)AllocatePool(512i64);
            if ( driverName.Buffer )
            {
              driverName.Length = 0;
              driverName.MaximumLength = 512;
              if ( StringTable == 0xFFFFFFFFFFFFEE92i64 )
                v11 = 0;
              else
                v11 = CopyUnicodeString(&driverName, StringTable + 0x116E);// \Driver\
              if ( v11 >= 0 && (signed int)AppendUnicodeString(&driverName, objectInfo) >= 0 )
              {
                v12 = import_ObReferenceObjectByName ? (unsigned int)import_ObReferenceObjectByName(
                                                                       &driverName,
                                                                       576i64,
                                                                       0i64,
                                                                       0i64,
                                                                       *(_QWORD *)import_IoDriverObjectType,
                                                                       0,
                                                                       0i64,
                                                                       &driverObject) : 0xC0000002;
                if ( v12 >= 0 )
                {
                  driverStart = (unsigned __int64)driverObject->DriverStart;
                  if ( driverStart
                    && driverObject->DriverSize
                    && driverObject->DriverSection
                    && driverStart >> 32 == v6
                    && !FindModuleForAddress((unsigned __int64)driverObject->DriverStart, moduleInfo) )
                  {
                    *a3 = v15;
                    *a4 = v16;
                    v4 = 1;
                  }
                  ObfDereferenceObject(driverObject);
                }
              }
              FreePool((__int64)driverName.Buffer);
            }
          }
        }
      }
    }
  }
  return v4;
}

char __fastcall CheckUnloadedDrivers(unsigned __int16 *a1)
{
  UNK_BUFFER2 *v1; // rsi
  char v2; // r12
  __int64 SystemTime; // rdi
  __int64 TickCount; // rbx
  signed __int64 systemTimeFromTickCount; // rbx
  __int64 (__fastcall *MmGetPhysicalAddress)(__int64); // rax
  __int64 PhysMmUnloadedDrivers; // rax
  __int64 unloadedDrivers; // rax MAPDST
  unsigned __int64 index; // r14
  signed __int64 addr; // rax
  signed __int64 decIndex; // r15
  WCHAR *v13; // r13
  USHORT nameLength; // cx
  PWSTR nameBuffer; // rdx
  signed __int64 timeSinceUnload; // rbp
  __int64 bufferPhys; // rax
  LONG v18; // eax
  signed __int64 v19; // r9
  const wchar_t *v20; // r8
  unsigned __int16 v21; // ax
  unsigned __int64 v22; // rbp
  signed __int64 sizeLeft; // r10
  unsigned __int64 v24; // rdx
  __int16 *curCh; // r8
  signed int v26; // er9
  __int16 v27; // cx
  signed __int64 v28; // r11
  __int16 v29; // cx
  __int64 v30; // r15
  _MM_UNLOADED_DRIVER unloadedDriver; // [rsp+30h] [rbp-188h]
  __int64 v33; // [rsp+60h] [rbp-158h]
  UNICODE_STRING name; // [rsp+70h] [rbp-148h]
  char printfBuffer[256]; // [rsp+80h] [rbp-138h]
  __int64 MmUnloadedDrivers; // [rsp+1C8h] [rbp+10h]
  __int64 nullbyte; // [rsp+1D0h] [rbp+18h]
  __int64 SystemTime2; // [rsp+1D8h] [rbp+20h]

  v1 = (UNK_BUFFER2 *)a1;
  nullbyte = 0i64;
  v2 = 0;
  if ( !FindMmUnloadedDrivers(&MmUnloadedDrivers) )
    return 0;
  SystemTime = MEMORY[0xFFFFF78000000014];
  TickCount = MEMORY[0xFFFFF78000000320];
  SystemTime2 = MEMORY[0xFFFFF78000000014];
  systemTimeFromTickCount = KeQueryTimeIncrement() * TickCount;
  if ( !sub_30C04((__int64)v1, 1024u) )
    return v2;
  MmGetPhysicalAddress = import_MmGetPhysicalAddress;
  v1->bytesUsed = 0;
  v1->size = 1024;
  if ( MmGetPhysicalAddress )
    PhysMmUnloadedDrivers = MmGetPhysicalAddress(MmUnloadedDrivers);
  else
    PhysMmUnloadedDrivers = qword_4DBE8;
  if ( !PhysMmUnloadedDrivers )
    goto LABEL_68;
  unloadedDrivers = MapPhysicalMemory(PhysMmUnloadedDrivers, 2000i64);
  if ( !unloadedDrivers )
    goto LABEL_68;
  index = 0i64;
  addr = unloadedDrivers + 2000;
  decIndex = 50i64;
  while ( 1 )
  {
    --decIndex;
    v13 = 0i64;
    v33 = addr - 40;
    memmove(&unloadedDriver, (const void *)(addr - 40), 40ui64);
    nameLength = unloadedDriver.Name.Length;
    nameBuffer = unloadedDriver.Name.Buffer;
    if ( !unloadedDriver.Name.Length
      && !unloadedDriver.Name.MaximumLength
      && !unloadedDriver.Name.Buffer
      && !unloadedDriver.ModuleStart
      && !unloadedDriver.ModuleEnd
      && !unloadedDriver.UnloadTime )
    {
      if ( index > 0 && !byte_4DA66 )
      {
        SendPacketToServer(351i64, 0i64, 0i64);
        byte_4DA66 = 1;
      }
      goto next_entry;
    }
    ++index;
    timeSinceUnload = SystemTime - unloadedDriver.UnloadTime;
    if ( (signed __int64)(SystemTime - unloadedDriver.UnloadTime) > systemTimeFromTickCount )
      break;
    if ( timeSinceUnload <= 36000000000i64 )
      goto check_entry;
next_entry:
    addr = v33;
    if ( !decIndex )
      goto LABEL_63;
  }
  if ( byte_4DA67 )
  {
    SendPacketToServer(350i64, 0i64, 0i64);
    nameBuffer = unloadedDriver.Name.Buffer;
    nameLength = unloadedDriver.Name.Length;
    byte_4DA67 = 1;
  }
check_entry:
  if ( nameBuffer && nameLength && unloadedDriver.Name.MaximumLength )
  {
    if ( import_MmGetPhysicalAddress )
    {
      bufferPhys = import_MmGetPhysicalAddress(nameBuffer);
      nameLength = unloadedDriver.Name.Length;
    }
    else
    {
      bufferPhys = qword_4DBE8;
    }
    if ( bufferPhys && (v13 = (WCHAR *)MapPhysicalMemory(bufferPhys, nameLength)) != 0i64 )
    {
      unloadedDriver.Name.Buffer = v13;
      MmUnloadedDrivers = unloadedDriver.Name.Length;
    }
    else
    {
      unloadedDriver.Name.Buffer = 0i64;
      unloadedDriver.Name.Length = 0;
      unloadedDriver.Name.MaximumLength = 0;
    }
  }
  v18 = CompareUnicodeStrings((__int64)&unloadedDriver, (_WORD *)(StringTable + 7242));// easyanticheat.sys
  v19 = unloadedDriver.ModuleEnd - unloadedDriver.ModuleStart;
  if ( v18 != 0 || v19 != *(_DWORD *)(qword_4E080 + 32) )
  {
    if ( unloadedDriver.Name.Buffer && unloadedDriver.Name.Length > 0xD8u )
    {
      unloadedDriver.Name.Length = 216;
      unloadedDriver.Name.Buffer[108] = 0;
    }
    v20 = (const wchar_t *)(StringTable + 7278);// %wZ 0x%X %i
    _mm_storeu_si128((__m128i *)&name, _mm_loadu_si128((const __m128i *)&unloadedDriver));
    if ( (signed int)VsnwprintfWrapper(
                       (wchar_t *)printfBuffer,
                       0x100ui64,
                       v20,
                       &name,
                       v19,
                       ((unsigned __int64)(timeSinceUnload
                                         + ((unsigned __int128)(timeSinceUnload * (signed __int128)0xD6BF94D5E57A42BDi64) >> 64)) >> 63)
                     + ((signed __int64)(timeSinceUnload
                                       + ((unsigned __int128)(timeSinceUnload * (signed __int128)0xD6BF94D5E57A42BDi64) >> 64)) >> 23)) >= 0
      && !(v1->bytesUsed & 1) )
    {
      v21 = v1->size;
      if ( !(v21 & 1) && v1->bytesUsed <= v21 && v21 <= 0xFFFEu && (v1->pool || !v1->bytesUsed && !v21) )
      {
        v22 = (unsigned __int64)v1->bytesUsed >> 1;
        sizeLeft = 0x7FFFi64;
        v24 = ((unsigned __int64)v21 >> 1) - v22;
        curCh = (__int16 *)printfBuffer;
        v26 = 0;
        v27 = 0;
        if ( (unsigned __int64)v21 >> 1 == v22 )
          goto LABEL_72;
        v28 = 2 * v22 - (_QWORD)printfBuffer + v1->pool;
        do
        {
          if ( !sizeLeft )
            break;
          if ( *curCh == (_WORD)nullbyte )
            break;
          *(__int16 *)((char *)curCh + v28) = *curCh;
          --v24;
          ++curCh;
          --sizeLeft;
          ++v27;
        }
        while ( v24 );
        SystemTime = SystemTime2;
        if ( !v24 )
        {
          if ( sizeLeft )
          {
LABEL_72:
            if ( *curCh )
              v26 = 0x80000005;
          }
        }
        v29 = 2 * (v22 + v27);
        if ( v26 >= 0 )
          v2 = 1;
        v1->bytesUsed = v29;
      }
    }
  }
  if ( v13 && import_MmUnmapVideoDisplay )
    import_MmUnmapVideoDisplay(v13, MmUnloadedDrivers);
  if ( v1->bytesUsed != v1->size )
    goto next_entry;
LABEL_63:
  v30 = unloadedDrivers;
  if ( !index )
    SendPacketToServer(349i64, 0i64, 0i64);
  if ( import_MmUnmapVideoDisplay )
    import_MmUnmapVideoDisplay(v30, 2000i64);
  if ( !v2 )
LABEL_68:
    FreeUnicodeString(v1);
  return v2;
}
```

`EasyAntiCheat.sys/handles.c`:

```c
__int64 __usercall CheckOpenedHandles@<rax>(PVOID protectedProcessID@<rcx>, __int64 a2@<rdx>, unsigned __int64 a3@<r14>)
{
  char v3; // bp
  SYSTEM_HANDLE_INFORMATION *handleInformation; // rax MAPDST
  ULONG index; // esi
  __int64 entry; // rbx
  __int64 ownerProcess; // r13
  __int64 handle; // rbp
  char v12; // r15
  signed int v13; // ebp
  __int64 v14; // [rsp+20h] [rbp-88h]
  __int64 v15; // [rsp+28h] [rbp-80h]
  __int64 v16; // [rsp+30h] [rbp-78h]
  _PROCESS_BASIC_INFORMATION processInfo; // [rsp+40h] [rbp-68h]
  char v19; // [rsp+C0h] [rbp+18h]
  __int64 duplicatedHandle; // [rsp+C8h] [rbp+20h]

  v3 = 1;
  v19 = 1;
  if ( !ReportProcess )
    return 0i64;
  handleInformation = (SYSTEM_HANDLE_INFORMATION *)QuerySystemInformation_0(
                                                     0x10u,
                                                     (unsigned __int64)qword_80000,
                                                     0x1000000u,
                                                     0i64,
                                                     a3);
  if ( !handleInformation )
    return 0i64;
  index = 0;
  if ( handleInformation->Count )
  {
    entry = (__int64)&handleInformation->Info[0].GrantedAccess;
    while ( 1 )
    {
      if ( !v3 )
        goto LABEL_24;
      if ( *(_DWORD *)(entry - 16) > 4u && *(_DWORD *)(entry - 16) != (_DWORD)protectedProcessID )
      {
        ownerProcess = GetProcessHandleFromPID(*(unsigned int *)(entry - 0x10), 1104i64);
        if ( ownerProcess )
          break;
      }
LABEL_23:
      ++index;
      entry += 24i64;
      if ( index >= handleInformation->Count )
        goto LABEL_24;
    }
    if ( !byte_4DEF2 || byte_4DEF2 == *(_BYTE *)(entry - 12) )
    {
      a3 = __readgsqword(0x188u);
      handle = *(unsigned __int16 *)(entry - 0xA);
      v12 = GetPreviousMode(a3, a3);
      SetPreviousMode(0, a3, a3);
      if ( import_NtDuplicateObject )
      {
        LODWORD(v16) = 2;
        LODWORD(v15) = 512;
        LODWORD(v14) = 0;
        v13 = import_NtDuplicateObject(ownerProcess, handle, -1i64, &duplicatedHandle, v14, v15, v16);
      }
      else
      {
        v13 = -1073741822;
      }
      SetPreviousMode(v12, a3, a3);
      if ( v13 >= 0 )
      {
        if ( (signed int)QueryProcessInformation(0, duplicatedHandle, (__int64)&processInfo, 0x30u, a3, 0i64) < 0 )
        {
          CloseHandle(duplicatedHandle, a3);
        }
        else
        {
          CloseHandle(duplicatedHandle, a3);
          byte_4DEF2 = *(_BYTE *)(entry - 12);
          if ( (PVOID)processInfo.UniqueProcessId == protectedProcessID && (unsigned int)word_E063A & *(_DWORD *)entry )
          {
            v3 = ReportProcess(
                   protectedProcessID,
                   *(unsigned int *)(entry - 0x10),// handle owner PID
                   *(unsigned __int16 *)(entry - 10),// handle
                   *(_DWORD *)entry,            // access
                   (PVOID)a2);
            v19 = v3;
            goto LABEL_22;
          }
        }
      }
      v3 = v19;
    }
LABEL_22:
    CloseHandle(ownerProcess, a3);
    goto LABEL_23;
  }
LABEL_24:
  FreePool((__int64)handleInformation);
  return index;
}
```

`EasyAntiCheat.sys/hiddenprocess.c`:

```c
__int64 FindHiddenProcess()
{
  __int64 hiddenProcess; // rbx
  __int64 *processesFromThreads; // r12
  HANDLE *processes; // r14
  unsigned int *list; // r15
  unsigned int processFromThreadCount; // eax
  __int64 processFromThreadCount0; // rsi
  unsigned int processCount; // eax MAPDST
  unsigned int processIndex; // ebp MAPDST
  __int64 *currentProcess; // r13
  __int64 processFromThreadIndex; // rdi
  __int64 *currentProcessFromThread; // rbp
  __int64 pid; // r13
  signed int status; // eax
  __int64 hiddenProcessId; // r11
  HANDLE *v17; // rax
  PVOID *v18; // rdi
  PVOID processObject; // [rsp+50h] [rbp+8h]

  hiddenProcess = 0i64;
  processesFromThreads = (__int64 *)AllocatePool(4096i64);
  if ( processesFromThreads )
  {
    processes = (HANDLE *)AllocatePool(4096i64);
    if ( processes )
    {
      list = CreateUniqueList(1);
      if ( list )
      {
        processFromThreadCount = Get512RunningProcessesFromThreads(processesFromThreads);
        processFromThreadCount0 = processFromThreadCount;
        if ( processFromThreadCount )
        {
          processCount = GetRunningProcesses(processes, 512u, 0i64, 0i64);
          if ( processCount )
          {
            if ( (_DWORD)processFromThreadCount0 != 512 && processCount != 512 )
            {
              processIndex = 0;
              if ( processCount )
              {
                currentProcess = (__int64 *)processes;
                while ( AddListEntry((__int64)list, *currentProcess, 0i64, 0) )
                {
                  ++processIndex;
                  ++currentProcess;
                  if ( processIndex >= processCount )
                    goto LABEL_12;
                }
              }
              else
              {
LABEL_12:
                processFromThreadIndex = 0i64;
                if ( (_DWORD)processFromThreadCount0 )
                {
                  currentProcessFromThread = processesFromThreads;
                  while ( 1 )
                  {
                    pid = import_PsGetProcessId ? import_PsGetProcessId(*currentProcessFromThread) : 0i64;
                    status = import_PsLookupProcessByProcessId ? (unsigned int)import_PsLookupProcessByProcessId(
                                                                                 pid,
                                                                                 &processObject) : 0xC0000002;
                    if ( status < 0 )
                      break;
                    ObfDereferenceObject(processObject);
                    if ( !IsEntryPresentInList((__int64)list, pid) )
                      break;
                    processFromThreadIndex = (unsigned int)(processFromThreadIndex + 1);
                    ++currentProcessFromThread;
                    if ( (unsigned int)processFromThreadIndex >= (unsigned int)processFromThreadCount0 )
                      goto LABEL_38;
                  }
                  hiddenProcess = processesFromThreads[processFromThreadIndex];
                  if ( hiddenProcess )
                  {
                    processCount = GetRunningProcesses(processes, 0x200u, 0i64, 0i64);
                    if ( processCount )
                    {
                      if ( import_PsGetProcessId )
                        hiddenProcessId = import_PsGetProcessId(hiddenProcess);
                      else
                        hiddenProcessId = 0i64;
                      processIndex = 0;
                      if ( processCount )
                      {
                        v17 = processes;
                        while ( *v17 != (HANDLE)hiddenProcessId )
                        {
                          ++processIndex;
                          ++v17;
                          if ( processIndex >= processCount )
                            goto LABEL_35;
                        }
                        hiddenProcess = 0i64;
                      }
LABEL_35:
                      if ( hiddenProcess )
                        IsProcessExiting(hiddenProcess);
                    }
                    else
                    {
                      hiddenProcess = 0i64;
                    }
                  }
                }
              }
            }
          }
        }
LABEL_38:
        FreeList(list);
      }
      else
      {
        processFromThreadCount0 = (unsigned int)processObject;
      }
      FreePool((__int64)processes);
    }
    else
    {
      processFromThreadCount0 = (unsigned int)processObject;
    }
    if ( (_DWORD)processFromThreadCount0 )
    {
      v18 = (PVOID *)processesFromThreads;
      do
      {
        if ( *v18 != (PVOID)hiddenProcess )
          ObfDereferenceObject(*v18);
        ++v18;
        --processFromThreadCount0;
      }
      while ( processFromThreadCount0 );
    }
    FreePool((__int64)processesFromThreads);
  }
  return hiddenProcess;
}

__int64 __fastcall Get512RunningProcessesFromThreads(__int64 *buffer)
{
  unsigned int processCount; // edi
  unsigned __int64 currentTID; // rbx
  __int64 list; // rsi
  signed int v5; // eax
  __int64 process; // r12
  PVOID threadObject; // [rsp+40h] [rbp+8h]

  processCount = 0;
  currentTID = 4i64;
  if ( buffer )
  {
    if ( GetThreadProcess(__readgsqword(0x188u)) )
    {
      list = (__int64)CreateUniqueList(1);
      if ( list )
      {
        do
        {
          if ( processCount >= 512 )
            break;
          if ( import_PsLookupThreadByThreadId )
            v5 = import_PsLookupThreadByThreadId(currentTID, &threadObject);
          else
            v5 = 0xC0000002;
          if ( v5 >= 0 )
          {
            process = GetThreadProcess((__int64)threadObject);
            if ( !IsEntryPresentInList(list, process) )
            {
              import_ObfReferenceObject(process);
              *buffer = process;
              ++processCount;
              ++buffer;
              AddListEntry(list, process, 0i64, 0);
            }
            ObfDereferenceObject(threadObject);
          }
          currentTID += 4i64;
        }
        while ( currentTID < 0x3000 );
        FreeList((PVOID)list);
      }
    }
  }
  return processCount;
}

__int64 __fastcall GetRunningProcesses(HANDLE *outProcesses, unsigned int maxCount, unsigned __int8 (__fastcall *callback)(__int64, __int64), __int64 a4)
{
  unsigned int v4; // edi
  SYSTEM_PROCESS_INFO *processInformation; // rax MAPDST
  SYSTEM_PROCESS_INFO *entry; // rbx
  __int64 pid; // rcx

  v4 = 0;
  if ( !outProcesses || !maxCount )
    return 0i64;
  processInformation = (SYSTEM_PROCESS_INFO *)QuerySystemInformation_0(
                                                5u,
                                                (unsigned __int64)qword_80000,
                                                0x1000000u,
                                                0i64,
                                                a4);
  if ( processInformation )
  {
    entry = processInformation;
    if ( maxCount )
    {
      do
      {
        pid = (__int64)entry->UniqueProcessId;
        if ( pid && (!callback || callback(pid, a4)) )
        {
          ++v4;
          *outProcesses = entry->UniqueProcessId;
          ++outProcesses;
        }
        if ( !entry->NextEntryOffset )
          break;
        entry = (SYSTEM_PROCESS_INFO *)((char *)entry + entry->NextEntryOffset);
      }
      while ( v4 < maxCount );
    }
    FreePool((__int64)processInformation);
  }
  return v4;
}
```

`EasyAntiCheat.sys/hwid.c`:

```c
char __fastcall HWID_HashProcessorFeatures(__int64 a1)
{
  __int64 v1; // rbx
  char *v3; // r11
  char *v4; // r8
  unsigned int v5; // edx
  _WORD *v6; // rcx
  char buffer[64]; // [rsp+20h] [rbp-A8h]

  v1 = a1;
  buffer[0] = 0;
  *(_QWORD *)&buffer[1] = 0i64;
  *(_QWORD *)&buffer[9] = 0i64;
  *(_WORD *)&buffer[17] = 0;
  buffer[19] = 0;
  *(_WORD *)&buffer[32] = 0;
  memset(&buffer[34], 0, 0x7Eui64);
  if ( !v1 )
    return 0;
  HashSHA(0xFFFFF78000000274i64, 0x40u, (DATA_HASH_BUFFER *)buffer);// ProcessorFeatures
  v3 = buffer;
  v4 = &buffer[34];
  v5 = 1;
  do
  {
    if ( v5 >= 0x40 )
      break;
    v5 += 2;
    v6 = (_WORD *)qword_4A230[(unsigned __int8)*v3++];
    *((_WORD *)v4 - 1) = *v6;
    *(_WORD *)v4 = v6[1];
    v4 += 4;
  }
  while ( v5 < 0x29 );
  return CreateUnicodeStringFromPWSTR(v1, &buffer[32]);
}

__int64 __fastcall HWID_GetScannedRegistryKeyName(unsigned int id)
{
  unsigned int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  unsigned int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  unsigned int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  unsigned int v13; // ecx
  int v14; // ecx
  int v15; // ecx

  if ( id <= 0xC )
  {
    if ( id == 12 )
      return StringTable + 3117;                // \Registry\Machine\Hardware\Description\System\CentralProcessor\0
    if ( id > 6 )
    {
      v6 = id - 8;
      if ( !v6 )
        return StringTable + 2843;              // SystemProductName
      v7 = v6 - 1;
      if ( !v7 )
        return StringTable + 2879;              // \Registry\Machine\Hardware\DeviceMap\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0
      v8 = v7 - 1;
      if ( !v8 )
        return StringTable + 3069;              // Identifier
      if ( v8 == 1 )
        return StringTable + 3091;              // SerialNumber
    }
    else
    {
      if ( id == 6 )
        return StringTable + 2805;              // SystemManufacturer
      v1 = id - 1;
      if ( !v1 )
        return StringTable + 2473;              // \Registry\Machine\System\CurrentControlSet\Control\SystemInformation
      v2 = v1 - 1;
      if ( !v2 )
        return StringTable + 2611;              // ComputerHardwareId
      v3 = v2 - 1;
      if ( !v3 )
        return StringTable + 2649;              // \Registry\Machine\Hardware\Description\System\BIOS
      v4 = v3 - 1;
      if ( !v4 )
        return StringTable + 2751;              // BIOSVendor
      if ( v4 == 1 )
        return StringTable + 2773;              // BIOSReleaseDate
    }
    return 0i64;
  }
  if ( id <= 0x12 )
  {
    if ( id == 18 )
      return StringTable + 3661;                // ProductId
    v9 = id - 13;
    if ( !v9 )
      return StringTable + 3247;                // ProcessorNameString
    v10 = v9 - 1;
    if ( !v10 )
      return StringTable + 3287;                // \Registry\Machine\System\CurrentControlSet\Control\Class\{4d36e968-e325-11ce-bfc1-08002be10318}\0000
    v11 = v10 - 1;
    if ( v11 )
    {
      v12 = v11 - 1;
      if ( !v12 )
        return StringTable + 3511;              // \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion
      if ( v12 == 1 )
        return StringTable + 3637;              // InstallDate
      return 0i64;
    }
    return StringTable + 3489;                  // DriverDesc
  }
  v13 = id - 19;
  if ( !v13 )
    return StringTable + 3681;                  // \Registry\Machine\Software\Microsoft\Windows\CurrentVersion\WindowsUpdate
  v14 = v13 - 1;
  if ( !v14 )
    return StringTable + 3829;                  // SusClientId
  v15 = v14 - 1;
  if ( v15 )
  {
    if ( v15 != 1 )
      return 0i64;
    return StringTable + 3489;
  }
  return StringTable + 3853;                    // \Registry\Machine\System\CurrentControlSet\Control\Class\{4d36e972-e325-11ce-bfc1-08002be10318}\0001
}

char __fastcall QueryWMIData(const __m128i *guid0, __int64 *outBuffer)
{
  char status; // bl
  _IMAGE_DOS_HEADER *IoWMIOpenBlock; // rdi
  __int64 v7; // rax
  __int128 guid1; // [rsp+20h] [rbp-28h]
  __int64 v1; // [rsp+58h] [rbp+10h]
  PVOID dataBlockObject; // [rsp+60h] [rbp+18h]

  status = 0;
  if ( !outBuffer )
    return 0;
  IoWMIOpenBlock = (_IMAGE_DOS_HEADER *)import_IoWMIOpenBlock;
  if ( !import_IoWMIOpenBlock )
  {
    IoWMIOpenBlock = FindExport((DATA_HASH_BUFFER *)&unk_46BE0);
    import_IoWMIOpenBlock = (__int64)IoWMIOpenBlock;
    if ( !IoWMIOpenBlock )
      return 0;
  }
  if ( !import_IoWMIQueryAllData )
  {
    import_IoWMIQueryAllData = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))FindExport((DATA_HASH_BUFFER *)&unk_46BF8);
    if ( !import_IoWMIQueryAllData )
      return 0;
  }
  _mm_storeu_si128((__m128i *)&guid1, _mm_loadu_si128(guid0));
  if ( ((__int64 (__fastcall *)(__int128 *, signed __int64, PVOID *))IoWMIOpenBlock)(&guid1, 1i64, &dataBlockObject) >= 0 )
  {
    LODWORD(v1) = 0;
    if ( (unsigned int)import_IoWMIQueryAllData(dataBlockObject, &v1, 0i64) == 0xC0000023 )
    {
      v7 = AllocatePool((unsigned int)v1);
      *outBuffer = v7;
      if ( v7 )
      {
        if ( (signed int)import_IoWMIQueryAllData(dataBlockObject, &v1, v7) < 0 )
          FreePool(*outBuffer);
        else
          status = 1;
      }
    }
    ObfDereferenceObject(dataBlockObject);
  }
  return status;
}

__int64 __usercall GetMachineId@<rax>(__int64 a1@<rcx>, signed int a2@<r14d>)
{
  unsigned int v2; // ebx
  DATA_HASH_BUFFER *v3; // rdi
  char v4; // al
  unsigned __int16 v6; // [rsp+20h] [rbp-18h]
  __int64 v7; // [rsp+28h] [rbp-10h]

  v2 = 0;
  v3 = (DATA_HASH_BUFFER *)a1;
  if ( a1 )
  {
    if ( StringTable == 4294963241 )
      v4 = 0;
    else                                        // MachineId
      v4 = ReadRegistryUnicodeString(StringTable + 4281, (_WORD *)(StringTable + 4055), (__int64)&v6, a2);//  \Registry\Machine\Software\Microsoft\Windows NT\CurrentVersion\Windows Activation Technologies\AdminObject\Store
    if ( v4 )
    {
      HashSHA(v7, v6, v3);
      v2 = 20;
      FreeUnicodeString(&v6);
    }
  }
  return v2;
}

char __usercall GetNtoskrnlProductVersion@<al>(UNICODE_STRING *outProductVersion@<rcx>, signed int a2@<r14d>)
{
  char v3; // di
  __int64 resourceAddr; // [rsp+20h] [rbp-28h]
  UNICODE_STRING path; // [rsp+28h] [rbp-20h]
  unsigned int size; // [rsp+58h] [rbp+10h]
  __int64 buffer; // [rsp+60h] [rbp+18h]
  _IMAGE_NT_HEADERS64 *a4; // [rsp+68h] [rbp+20h]

  v3 = 0;
  if ( GetNtoskrnlPath(&path, a2) )
  {
    if ( ReadFileW(&path, &buffer, &size) )
    {
      if ( ValidatePeHeader((_IMAGE_DOS_HEADER *)buffer, size, 0i64, &a4)
        && GetResourceSection(a4, buffer, &resourceAddr, &size) )
      {
        v3 = GetProductVersionFromResource(resourceAddr, size, outProductVersion);
      }
      if ( buffer )
        FreePool(buffer);
    }
    FreeUnicodeString(&path);
  }
  return v3;
}
```

`EasyAntiCheat.sys/kernelpatch.c`:

```c
void __usercall CheckForKernelPatches(__int64 a1@<rcx>, __int64 a2@<rdx>, signed int a3@<r14d>)
{
  signed int v5; // ebx
  _IMAGE_DOS_HEADER *ntoskrnlBase; // rbp
  int v7; // ebx
  signed int v8; // ebx
  bool v9; // sf
  unsigned int v10; // eax
  char v11; // [rsp+30h] [rbp-58h]
  __int64 v12; // [rsp+38h] [rbp-50h]
  _IMAGE_NT_HEADERS64 *v13; // [rsp+40h] [rbp-48h]
  _IMAGE_NT_HEADERS64 *a4; // [rsp+48h] [rbp-40h]
  UNICODE_STRING ntoskrnlPath; // [rsp+50h] [rbp-38h]
  char v16; // [rsp+60h] [rbp-28h]
  __int64 v17; // [rsp+68h] [rbp-20h]
  unsigned __int64 fileLength; // [rsp+A0h] [rbp+18h]
  _IMAGE_DOS_HEADER *fileBuffer; // [rsp+A8h] [rbp+20h]

  v5 = 2;
  ntoskrnlBase = (_IMAGE_DOS_HEADER *)GetNtoskrnlBase();
  if ( ntoskrnlBase && GetNtoskrnlPath(&ntoskrnlPath, a3) )
  {
    if ( (MEMORY[0xFFFFF7800000026C] > 6u
       || MEMORY[0xFFFFF7800000026C] == 6 && (MEMORY[0xFFFFF78000000270] == 2 || MEMORY[0xFFFFF78000000270] == 3))
      && CompareUnicodeStrings((__int64)&ntoskrnlPath, (_WORD *)(StringTable + 4752)) )// \SystemRoot\system32\ntoskrnl.exe
    {
      v5 = 1;
    }
    else if ( ReadFileW(&ntoskrnlPath, (__int64 *)&fileBuffer, (ULONG *)&fileLength) )
    {
      if ( (unsigned int)fileLength >= 0x1000 )
        v5 = !ValidatePeHeader(ntoskrnlBase, 0x1000ui64, &fileLength, &v13)
          || !ValidatePeHeader(fileBuffer, 0x1000ui64, &fileLength, &a4)
          || v13->FileHeader.NumberOfSections != a4->FileHeader.NumberOfSections
          || v13->FileHeader.TimeDateStamp != a4->FileHeader.TimeDateStamp
          || v13->OptionalHeader.AddressOfEntryPoint != a4->OptionalHeader.AddressOfEntryPoint
          || v13->OptionalHeader.CheckSum != a4->OptionalHeader.CheckSum
          || v13->OptionalHeader.SizeOfImage != a4->OptionalHeader.SizeOfImage;
      if ( fileBuffer )
        FreePool((__int64)fileBuffer);
    }
    FreeUnicodeString(&ntoskrnlPath);
  }
  v7 = v5 - 1;
  if ( !v7 )
  {
    v8 = -1073610745;
    goto LABEL_47;
  }
  if ( v7 == 1 )
  {
    v8 = -1073610744;
LABEL_47:
    sub_33230(a2, (unsigned int)v8);
    return;
  }
  v8 = 0;
  v9 = MEMORY[0xFFFFF7800000026C] - 6 < 0;
  if ( MEMORY[0xFFFFF7800000026C] > 6u
    || MEMORY[0xFFFFF7800000026C] == 6
    && (MEMORY[0xFFFFF78000000270] == 2 || (v9 = MEMORY[0xFFFFF78000000270] - 3 < 0, MEMORY[0xFFFFF78000000270] == 3)) )
  {
    if ( GetBCDData((_UNICODE_STRING *)&v16, (UNICODE_STRING *)&v11, a3) )
    {
      if ( v12 )
      {
        if ( CompareUnicodeStrings((__int64)&v11, (_WORD *)(StringTable + 1003))// \Windows\system32\winload.exe
          && CompareUnicodeStrings((__int64)&v11, (_WORD *)(StringTable + 1063)) )// \Windows\system32\winload.efi
        {
          v8 = 0xC0020010;
        }
        FreeUnicodeString(&v11);
      }
      if ( v17 )
      {
        if ( CompareUnicodeStrings((__int64)&v16, (_WORD *)(StringTable + 1123)) )// ntoskrnl.exe
          v8 = 0xC0020011;
        FreeUnicodeString(&v16);
      }
    }
    else
    {
      sub_3329C(a2, 81i64, 0i64);
    }
    v9 = v8 < 0;
    if ( v8 )
      goto LABEL_47;
  }
  sub_25ECC(a2, 1073807366i64, v9);
  v10 = sub_13F3C(a1, a2);
  if ( v10 == 0x40031000 )
    sub_25BF4(0x40031000, a2, a3);
  else
    sub_33230(a2, v10);
  qword_4E0D0 = 0i64;
  qword_4E0D8 = 0i64;
  qword_4E0E0 = 0i64;
  qword_4E0E8 = 0i64;
}

char __usercall GetBCDData@<al>(_UNICODE_STRING *a1@<rdx>, UNICODE_STRING *a2@<rcx>, signed int a3@<r14d>)
{
  char v3; // di
  _UNICODE_STRING *v4; // rsi
  UNICODE_STRING *v5; // rbp
  __int64 globalDataTable; // rbx
  __int64 v7; // rdx
  unsigned __int16 v9; // [rsp+20h] [rbp-128h]
  void *Src; // [rsp+28h] [rbp-120h]
  __m128i v11; // [rsp+30h] [rbp-118h]
  char Dst; // [rsp+40h] [rbp-108h]
  char v13; // [rsp+8Ch] [rbp-BCh]
  __int128 v14; // [rsp+ECh] [rbp-5Ch]
  __int16 v15; // [rsp+FCh] [rbp-4Ch]

  v3 = 0;
  v4 = a1;
  v5 = a2;
  if ( !a2 || !a1 )
    return 0;
  *(_QWORD *)&a2->Length = 0i64;
  a2->Buffer = 0i64;
  *(_QWORD *)&a1->Length = 0i64;
  a1->Buffer = 0i64;
  if ( QuerySystemBootEnvironmentInformation(&v11, a3) && sub_12080((unsigned __int8 *)&v11, (__int64)&v9) )
  {
    globalDataTable = StringTable;
    v15 = 0;
    memmove(&Dst, (const void *)(StringTable + 188), 0xBCui64);// \Registry\Machine\BCD00000000\Objects\{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\Elements\xxxxxxxx
    memmove(&v13, Src, v9);
    _mm_storeu_si128((__m128i *)&v14, _mm_loadu_si128((const __m128i *)(globalDataTable + 378)));
    ReadRegistryUnicodeString(globalDataTable + 396, &Dst, (__int64)v5, a3);
    v7 = StringTable + 396;
    _mm_storeu_si128((__m128i *)&v14, _mm_loadu_si128((const __m128i *)(StringTable + 412)));
    ReadRegistryUnicodeString(v7, &Dst, (__int64)v4, a3);
    FreeUnicodeString(&v9);
  }
  if ( v5->Buffer || v4->Buffer )
    v3 = 1;
  return v3;
}
```

`EasyAntiCheat.sys/mac.c`:

```c
char __fastcall HWID_GetMacAddress(int a1, __int64 a2)
{
  char v2; // bl
  char v6; // [rsp+30h] [rbp-18h]

  v2 = 0;
  v6 = 0;
  if ( !a2 || a1 != 6 )
    return 0;
  if ( GetFirstNetworkDeviceMacAddress((__int64)&GUID_DEVINTERFACE_NET, (HWIDBuffer *)&a1) )
  {
    if ( v6 )
      v2 = 1;
  }
  return v2;
}

char __fastcall GetFirstNetworkDeviceMacAddress(__int64 deviceGuid, HWIDBuffer *hwidBuffer)
{
  char notFound; // bl
  __int64 index; // r12 MAPDST
  signed int status; // eax
  _WORD *it; // rbp MAPDST
  signed __int64 invertedSize; // rcx MAPDST
  _WORD *tempIt; // rdi MAPDST
  bool isNull; // zf
  char v20; // dl
  UNICODE_STRING symbolicLink; // [rsp+20h] [rbp-38h]
  PVOID symbolicLinks; // [rsp+70h] [rbp+18h]

  notFound = 1;
  index = 0i64;
  if ( !GetAdapterMacAddressWrapper || KeGetCurrentIrql() )
    return 0;
  status = import_IoGetDeviceInterfaces ? (unsigned int)import_IoGetDeviceInterfaces(
                                                          deviceGuid,
                                                          0i64,
                                                          0i64,
                                                          &symbolicLinks) : 0xC0000002;
  if ( status < 0 )
    return 0;
  do
  {
    it = (char *)symbolicLinks + 2 * index;
    if ( !*it )
      break;
    invertedSize = -1i64;
    tempIt = (char *)symbolicLinks + 2 * index;
    do
    {
      if ( !invertedSize )
        break;
      isNull = *tempIt == 0;
      ++tempIt;
      --invertedSize;
    }
    while ( !isNull );
    if ( strstrIgnoreCaseW((_WORD *)symbolicLinks + index, (unsigned __int16 *)(StringTable + 828), ~invertedSize - 1) != it )// \??\PCI
      goto LABEL_16;
    InitializeUnicodeStringWithCStr(&symbolicLink, it);
    if ( !hwidBuffer )
      goto LABEL_15;
    if ( GetAdapterMacAddress(hwidBuffer->hwidType, &symbolicLink, hwidBuffer->uniqueIdentifier) == 1 )
    {
      hwidBuffer->found = 1;
LABEL_15:
      notFound = 0;
      goto LABEL_16;
    }
    notFound = 1;
LABEL_16:
    invertedSize = -1i64;
    tempIt = (char *)symbolicLinks + 2 * index;
    do
    {
      if ( !invertedSize )
        break;
      isNull = *tempIt == 0;
      ++tempIt;
      --invertedSize;
    }
    while ( !isNull );
    index += ~invertedSize;
  }
  while ( notFound );
  for ( index = 0i64; notFound; index += ~invertedSize )
  {
    it = (char *)symbolicLinks + 2 * index;
    if ( !*it )
      break;
    invertedSize = -1i64;
    tempIt = (char *)symbolicLinks + 2 * index;
    do
    {
      if ( !invertedSize )
        break;
      isNull = *tempIt == 0;
      ++tempIt;
      --invertedSize;
    }
    while ( !isNull );
    if ( strstrIgnoreCaseW((_WORD *)symbolicLinks + index, (unsigned __int16 *)(StringTable + 844), ~invertedSize - 1) == it )// \??\USB
    {
      InitializeUnicodeStringWithCStr(&symbolicLink, it);
      if ( hwidBuffer )
      {
        if ( GetAdapterMacAddress(hwidBuffer->hwidType, &symbolicLink, hwidBuffer->uniqueIdentifier) != 1 )
        {
          notFound = 1;
          goto LABEL_31;
        }
        hwidBuffer->found = 1;
      }
      notFound = 0;
    }
LABEL_31:
    invertedSize = -1i64;
    tempIt = (char *)symbolicLinks + 2 * index;
    do
    {
      if ( !invertedSize )
        break;
      isNull = *tempIt == 0;
      ++tempIt;
      --invertedSize;
    }
    while ( !isNull );
  }
  index = 0i64;
  if ( notFound )
  {
    while ( 1 )
    {
      it = (char *)symbolicLinks + 2 * index;
      if ( !*it )
        goto LABEL_46;
      InitializeUnicodeStringWithCStr(&symbolicLink, it);
      if ( !hwidBuffer )
        goto LABEL_41;
      if ( GetAdapterMacAddress(hwidBuffer->hwidType, &symbolicLink, hwidBuffer->uniqueIdentifier) == 1 )
        break;
      v20 = 1;
LABEL_42:
      invertedSize = -1i64;
      tempIt = (char *)symbolicLinks + 2 * index;
      do
      {
        if ( !invertedSize )
          break;
        isNull = *tempIt == 0;
        ++tempIt;
        --invertedSize;
      }
      while ( !isNull );
      index += ~invertedSize;
      if ( !v20 )
        goto LABEL_46;
    }
    hwidBuffer->found = 1;
LABEL_41:
    v20 = 0;
    goto LABEL_42;
  }
LABEL_46:
  ExFreePoolWithTag(symbolicLinks, 0);
  return 1;
}

char __fastcall GetAdapterMacAddress(__int64 a1, UNICODE_STRING *deviceName, UNICODE_STRING *outMacAddress)
{
  char result; // al
  char status1; // r13
  int macCrc32; // ebp
  __int64 v8; // rbx
  char v10; // r12
  signed int status; // edi
  int *v12; // rax
  int v13; // ecx
  int *v14; // rax
  int v15; // ecx
  int *v16; // rax
  int v17; // ecx
  int *v18; // rax
  int v19; // ecx
  int *v20; // rax
  int v21; // ecx
  int *v22; // rax
  char *addrNtDeviceIoControlFile; // rax MAPDST
  int v24; // edi MAPDST
  char checksPassed; // si
  int status0; // eax
  int *v29; // rax
  int v30; // ecx
  int *v31; // rax
  int v32; // ecx
  int *v33; // rax
  int v34; // ecx
  int *v35; // rax
  int v36; // ecx
  int *v37; // rax
  int v38; // ecx
  int *v39; // rax
  __int64 ioctl; // [rsp+28h] [rbp-100h]
  __int64 inputSize; // [rsp+38h] [rbp-F0h]
  __int64 inputSize2; // [rsp+40h] [rbp-E8h]
  PVOID outputSize; // [rsp+48h] [rbp-E0h]
  unsigned __int8 macAddress[6]; // [rsp+60h] [rbp-C8h]
  HANDLE fileHandle; // [rsp+68h] [rbp-C0h] MAPDST
  int v46; // [rsp+70h] [rbp-B8h]
  __int16 v47; // [rsp+74h] [rbp-B4h]
  int v48; // [rsp+76h] [rbp-B2h]
  __int16 v49; // [rsp+7Ah] [rbp-AEh]
  int v50; // [rsp+7Ch] [rbp-ACh]
  __int16 v51; // [rsp+80h] [rbp-A8h]
  int v52; // [rsp+82h] [rbp-A6h]
  __int16 v53; // [rsp+86h] [rbp-A2h]
  int v54; // [rsp+88h] [rbp-A0h]
  __int16 v55; // [rsp+8Ch] [rbp-9Ch]
  int v56; // [rsp+8Eh] [rbp-9Ah]
  __int16 v57; // [rsp+92h] [rbp-96h]
  __int64 outValue; // [rsp+B0h] [rbp-78h]
  __int64 addedBytes; // [rsp+B8h] [rbp-70h] MAPDST
  struct _IO_STATUS_BLOCK statusBlock; // [rsp+C0h] [rbp-68h]
  OBJECT_ATTRIBUTES objectAttributes; // [rsp+D0h] [rbp-58h]
  int objectId; // [rsp+138h] [rbp+10h]

  result = 0;
  objectId = 0x1010101;                         // OID_802_3_PERMANENT_ADDRESS
  status1 = 0;
  macAddress[0] = 0;
  *(_DWORD *)&macAddress[1] = 0;
  macAddress[5] = 0;
  macCrc32 = 0;
  if ( deviceName
    && deviceName->Buffer
    && deviceName->Length
    && deviceName->MaximumLength
    && outMacAddress
    && (_DWORD)a1 == 6 )
  {
    if ( !KeGetCurrentIrql() && !(unsigned __int8)import_KeAreAllApcsDisabled(a1) )
    {
      objectAttributes.Length = 48;
      objectAttributes.RootDirectory = 0i64;
      objectAttributes.Attributes = 512;
      objectAttributes.ObjectName = deviceName;
      objectAttributes.SecurityDescriptor = 0i64;
      objectAttributes.SecurityQualityOfService = 0i64;
      if ( ZwCreateFile(&fileHandle, 0x120089u, &objectAttributes, &statusBlock, 0i64, 0x80u, 7u, 1u, 0x20u, 0i64, 0) < 0 )
        return status1;
      v8 = __readgsqword(0x188u);
      v10 = GetPreviousMode(v8, 0);
      SetPreviousMode(0, v8, 0);
      if ( import_NtDeviceIoControlFile )
      {
        LODWORD(outputSize) = 6;
        LODWORD(inputSize) = 4;
        LODWORD(ioctl) = 0x170002;              // IOCTL_NDIS_QUERY_GLOBAL_STATS
        status = import_NtDeviceIoControlFile(
                   fileHandle,
                   0i64,
                   0i64,
                   0i64,
                   &statusBlock,
                   ioctl,
                   &objectId,
                   inputSize,
                   macAddress,
                   outputSize);
      }
      else
      {
        status = 0xC0000002;
      }
      SetPreviousMode(v10, v8, 0);
      if ( status >= 0 )
      {
        v12 = (int *)qword_4A230[macAddress[0]];
        v47 = '-';
        v49 = '-';
        v13 = *v12;
        v51 = '-';
        v14 = (int *)qword_4A230[macAddress[1]];
        v46 = v13;
        v53 = '-';
        v15 = *v14;
        v55 = '-';
        v16 = (int *)qword_4A230[macAddress[2]];
        v48 = v15;
        v57 = 0;
        v17 = *v16;
        v18 = (int *)qword_4A230[macAddress[3]];
        v50 = v17;
        v19 = *v18;
        v20 = (int *)qword_4A230[macAddress[4]];
        v52 = v19;
        v21 = *v20;
        v22 = (int *)qword_4A230[macAddress[5]];
        v54 = v21;
        v56 = *v22;
        status1 = CreateUnicodeStringFromPWSTR((__int64)outMacAddress, &v46);
        if ( status1 )
        {
          addrNtDeviceIoControlFile = (char *)GetNtDeviceIoControlFileAddress();
          v24 = sub_1705C(addrNtDeviceIoControlFile, 0x10i64, &addedBytes);
          if ( v24 && addedBytes )
          {
            checksPassed = 0;
            addrNtDeviceIoControlFile = (char *)GetNtDeviceIoControlFileAddress();
            if ( addrNtDeviceIoControlFile )
            {
              if ( v24 == 0x1290373
                && (unsigned int)sub_1705C((char *)CallNtDeviceIoControlFilePlus10, addedBytes, &outValue) == 0x1290373
                && outValue == addedBytes )
              {
                checksPassed = 1;
                NtDeviceIoControlFilePlus10 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))&addrNtDeviceIoControlFile[addedBytes];
              }
            }
            else
            {
              checksPassed = 0;
            }
            if ( checksPassed )
            {
              if ( v24 != 0x1290373 )
              {
                if ( !byte_4D8AB )
                {
                  SendPacketToServer(353i64, (__int64)&v24, 4i64);
                  byte_4D8AB = 1;
                }
                goto LABEL_37;
              }
              macCrc32 = HashCRC32((char *)macAddress, 6u, 0);
              LODWORD(inputSize2) = 4;
              status0 = CallNtDeviceIoControlFilePlus10_KernelMode(
                          (__int64)fileHandle,
                          0,
                          0,
                          (__int64)&statusBlock,
                          0x170002,
                          (unsigned __int64)&objectId,
                          inputSize2,
                          (unsigned __int64)macAddress);
              goto LABEL_30;
            }
          }
          if ( !byte_4D8AA )
          {
            SendPacketToServer(352i64, 0i64, 0i64);
            status0 = objectId;
            byte_4D8AA = 1;
LABEL_30:
            if ( macCrc32 )
            {
              if ( status0 >= 0 )
              {
                if ( macCrc32 != (unsigned int)HashCRC32((char *)macAddress, 6u, 0) && !byte_4DA64 )
                {
                  v29 = (int *)qword_4A230[macAddress[0]];
                  v47 = 45;
                  v30 = *v29;
                  v49 = 45;
                  v31 = (int *)qword_4A230[macAddress[1]];
                  v46 = v30;
                  v51 = 45;
                  v32 = *v31;
                  v53 = 45;
                  v33 = (int *)qword_4A230[macAddress[2]];
                  v48 = v32;
                  v55 = 45;
                  v34 = *v33;
                  v35 = (int *)qword_4A230[macAddress[3]];
                  v50 = v34;
                  v57 = 0;
                  v36 = *v35;
                  v37 = (int *)qword_4A230[macAddress[4]];
                  v52 = v36;
                  v38 = *v37;
                  v39 = (int *)qword_4A230[macAddress[5]];
                  v54 = v38;
                  v56 = *v39;
                  SendPacketToServer(354i64, (__int64)&v46, 64i64);
                  byte_4DA64 = 1;
                }
              }
              else if ( !byte_4DA65 )
              {
                SendPacketToServer(355i64, (__int64)&v24, 4i64);
                byte_4DA65 = 1;
              }
            }
            goto LABEL_37;
          }
        }
      }
LABEL_37:
      CloseHandle((__int64)fileHandle, 0);
      return status1;
    }
    result = 0;
  }
  return result;
}
```

`EasyAntiCheat.sys/physmem.c`:

```c
bool __fastcall CheckForPhysicalHandle(_DWORD *a1)
{
  SYSTEM_HANDLE_INFORMATION *systemHandleInformation; // r12
  signed int v4; // er11
  PVOID v5; // rax
  unsigned __int64 index; // rbp
  PVOID sectionObjectType; // rcx
  char v8; // r13
  SYSTEM_HANDLE_TABLE_ENTRY_INFO *entry; // rsi
  char v10; // si
  char v11; // r13
  _UNICODE_STRING *v12; // rdx
  char v13; // al
  UNICODE_STRING v14; // [rsp+30h] [rbp-88h]
  UNICODE_STRING a1a; // [rsp+40h] [rbp-78h]
  char v16; // [rsp+50h] [rbp-68h]
  OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+60h] [rbp-58h]
  HANDLE SectionHandle; // [rsp+C0h] [rbp+8h]

  if ( !a1 )
    return 0;
  memset(a1, 0, 0x20ui64);
  if ( !import_ObIsKernelHandle || _InterlockedCompareExchange(&dword_4D8B0, 1, 0) )
    return 0;
  systemHandleInformation = (SYSTEM_HANDLE_INFORMATION *)QuerySystemInformation_0(
                                                           0x10u,
                                                           (unsigned __int64)qword_80000,
                                                           0x1000000u,
                                                           0i64,
                                                           1);
  if ( !systemHandleInformation )
    goto LABEL_43;
  InitializeUnicodeStringWithCStr(&a1a, (_WORD *)(StringTable + 7061));// \Device\PhysicalMemory
  ObjectAttributes.ObjectName = &a1a;
  ObjectAttributes.Length = 48;
  ObjectAttributes.RootDirectory = 0i64;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.SecurityDescriptor = 0i64;
  ObjectAttributes.SecurityQualityOfService = 0i64;
  if ( ZwOpenSection(&SectionHandle, 1u, &ObjectAttributes) >= 0 )
  {
    if ( import_ObReferenceObjectByHandle )
      v4 = import_ObReferenceObjectByHandle(SectionHandle, 1i64, 0i64);
    else
      v4 = 0xC0000002;
    v5 = SectionObjectType;
    if ( v4 < 0 )
      v5 = 0i64;
    SectionObjectType = v5;
    ZwClose(SectionHandle);
  }
  index = 0i64;
  if ( systemHandleInformation->Count <= 0 )
    goto LABEL_39;
  sectionObjectType = SectionObjectType;
  v8 = 0;
  entry = systemHandleInformation->Info;
  while ( 1 )
  {
    if ( entry->Object != sectionObjectType || !sectionObjectType || entry->ProcessId == 4 )
      goto LABEL_20;
    if ( !(unsigned __int8)import_ObIsKernelHandle(entry->Handle) )
      break;
    sectionObjectType = SectionObjectType;
LABEL_20:
    ++index;
    ++entry;
    if ( index >= systemHandleInformation->Count )
      goto LABEL_40;
  }
  if ( entry->ProcessId )
    v10 = GetProcessImageFileName(&v14, entry->ProcessId, 1);
  else
    v10 = 0;
  if ( v10 )
    v8 = sub_289F0(&v14.Length, (__int64)&v16);
  v11 = -v8;
  v12 = (_UNICODE_STRING *)((unsigned __int64)&v16 & -(signed __int64)(v11 != 0));
  if ( !a1[1] )
  {
    *(_BYTE *)a1 = 1;
    a1[1] = 13;
    if ( v12 )
    {
      if ( *(_QWORD *)(((unsigned __int64)&v16 & -(signed __int64)(v11 != 0)) + 8)
        && v12->Length
        && *(_WORD *)(((unsigned __int64)&v16 & -(signed __int64)(v11 != 0)) + 2)
        && !*((_BYTE *)a1 + 8) )
      {
        if ( a1 == (_DWORD *)-16i64 )
          v13 = 0;
        else
          v13 = AllocateCopyUnicodeString((__int64)(a1 + 4), v12);
        *((_BYTE *)a1 + 8) = v13;
      }
    }
  }
  if ( v10 )
    FreeUnicodeString(&v14);
LABEL_39:
  sectionObjectType = SectionObjectType;
LABEL_40:
  if ( sectionObjectType )
  {
    ObfDereferenceObject(sectionObjectType);
    SectionObjectType = 0i64;
  }
  FreePool((__int64)systemHandleInformation);
LABEL_43:
  _InterlockedExchange(&dword_4D8B0, 0);
  return a1[1] != 0;
}
```

`EasyAntiCheat.sys/pooltags.c`:

```c
bool __usercall CheckForBannedPooltags@<al>(signed int a1@<r14d>)
{
  signed int v1; // ebx
  SYSTEM_POOLTAG_INFORMATION *pooltagInformation; // rax
  ULONG v3; // edx
  __int64 entry; // rcx

  v1 = 0;
  pooltagInformation = (SYSTEM_POOLTAG_INFORMATION *)QuerySystemInformation_0(0x16u, 0x10000u, 0x100000u, 0i64, a1);
  if ( pooltagInformation )
  {
    v3 = 0;
    if ( pooltagInformation->Count > 0 )
    {
      entry = (__int64)&pooltagInformation->TagInfo[0].PagedAllocs;
      do
      {
        if ( v1 == 3 )
          break;
        if ( *(_DWORD *)(entry - 4) != 'rcIC' || *(_DWORD *)entry <= *(_DWORD *)(entry + 4) )
        {
          if ( *(_DWORD *)(entry - 4) == 'csIC' && *(_DWORD *)entry > *(_DWORD *)(entry + 4) )
            v1 |= 2u;
        }
        else
        {
          v1 |= 1u;
        }
        ++v3;
        entry += 40i64;
      }
      while ( v3 < pooltagInformation->Count );
    }
    FreePool((__int64)pooltagInformation);
  }
  else
  {
    v1 = 3;
  }
  return v1 == 3;
}
```

`EasyAntiCheat.sys/process.c`:

```c
char __usercall CheckProcess@<al>(__int64 a1@<rdx>, unsigned int *buffer@<rcx>, int a3@<esi>)
{
  __int64 *v4; // rdi
  char result; // al
  char *v6; // rcx
  signed int v7; // eax
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v11; // rcx
  char *v12; // r9
  unsigned __int64 v13; // rdx
  _DWORD *v14; // rdx
  char v15; // [rsp+20h] [rbp-48h]
  char v16; // [rsp+30h] [rbp-38h]
  PVOID process; // [rsp+78h] [rbp+10h] MAPDST

  v15 = 0;
  v4 = 0i64;
  if ( !buffer )
    return 0;
  v6 = (char *)buffer + 15;
  if ( v6 < (char *)buffer || (unsigned __int64)v6 >= MmUserProbeAddress )
  {
    ExRaiseAccessViolation(v6, a1);
    result = 0;
  }
  else if ( *buffer && *(_QWORD *)(buffer + 1) && buffer[3] )
  {
    if ( import_PsLookupProcessByProcessId )
      v7 = import_PsLookupProcessByProcessId(*buffer, &process);
    else
      v7 = 0xC0000002;
    if ( v7 >= 0 )
    {
      if ( AttachToProcess((__int64)process, (__int64)&v16) )
      {
        LOBYTE(v9) = 1;
        v4 = (__int64 *)CheckCurrentProcess(v9, v8);
        if ( process )
          DetachFromProcess((__int64)process, (__int64)&v16, (char)v4, a3);
      }
      ObfDereferenceObject(process);
    }
    if ( v4 )
    {
      v11 = buffer[3];
      v12 = *(char **)(buffer + 1);
      if ( buffer[3] )
      {
        v13 = (unsigned __int64)&v12[v11 - 1];
        if ( v13 < (unsigned __int64)v12 || v13 >= MmUserProbeAddress )
          ExRaiseAccessViolation(v11, v13);
      }
      v14 = (_DWORD *)*v4;
      if ( *(_DWORD *)*v4 < (unsigned int)v11 )
        LODWORD(v11) = *v14;
      memmove(v12, v14, (unsigned int)v11);
      v15 = 1;
      sub_20430(v4);
    }
    result = v15;
  }
  else
  {
    result = 0;
  }
  return result;
}

UNK_BUFFER3 *__fastcall CheckCurrentProcess(__int64 a1, __int64 a2)
{
  char v3; // r14 MAPDST
  __int64 currentProcess; // rax MAPDST
  UNK_BUFFER3 *buffer; // rax MAPDST
  _IMAGE_DOS_HEADER *v8; // rax
  _IMAGE_DOS_HEADER *v9; // rax
  unsigned int processFlags; // esi
  _IMAGE_DOS_HEADER *baseAddress; // rbx
  __int64 v12; // rdx
  bool v13; // al
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 currentProcess2; // rax MAPDST
  __int64 currentProcessID2; // rax
  bool v19; // cf
  int v20; // eax
  bool v21; // cf
  int v22; // eax
  bool v23; // cf
  int v24; // eax
  bool v25; // cf
  int v26; // eax
  bool v27; // cf
  int v28; // eax
  __int64 parentPID; // rax
  signed int v30; // eax
  PVOID v31; // rcx
  char v32; // al
  char v33; // al
  UNICODE_STRING *v34; // r13
  __int64 v35; // rdx
  _IMAGE_DOS_HEADER *v36; // rax
  unsigned __int64 v37; // rcx
  unsigned __int16 *v38; // rbx
  int v39; // eax
  unsigned int *v40; // rax
  char filename; // [rsp+50h] [rbp-38h]
  unsigned __int16 v43; // [rsp+58h] [rbp-30h]
  unsigned __int8 v44; // [rsp+5Ah] [rbp-2Eh]
  unsigned __int16 v45; // [rsp+5Ch] [rbp-2Ch]
  unsigned int v46; // [rsp+98h] [rbp+10h]
  PVOID parentProcess; // [rsp+A0h] [rbp+18h]
  __int64 currentProcessID; // [rsp+A8h] [rbp+20h]

  v3 = a1;
  v3 = 0;
  currentProcess = import_PsGetCurrentProcess(a1, a2);
  if ( import_PsGetProcessId )
    currentProcessID = import_PsGetProcessId(currentProcess);
  else
    currentProcessID = 0i64;
  buffer = (UNK_BUFFER3 *)AllocatePool(816i64);
  if ( !buffer )
    goto LABEL_99;
  memset(buffer, 0, 0x330ui64);
  v8 = (_IMAGE_DOS_HEADER *)GetProcessBaseAddress(currentProcess);
  buffer->base_address = v8;
  if ( !v8 )
  {
    v9 = (_IMAGE_DOS_HEADER *)GetUsermodeModule(0i64);
    buffer->base_address = v9;
    if ( !v9 )
      goto LABEL_99;
  }
  if ( IsWin32ConsoleSubsystem(currentProcess) )
  {
    processFlags = 0x8001;
  }
  else if ( HasComDescriptor(buffer->base_address) )
  {
    processFlags = 9;
  }
  else if ( GetUsermodeModule((UNICODE_STRING *)(StringTable + 5202)) )// msvbvm60.dll
  {
    processFlags = 17;
  }
  else
  {
    processFlags = 1;
    if ( GetUsermodeModule((UNICODE_STRING *)(StringTable + 4894)) )// perl512.dll
      processFlags = 4097;
  }
  baseAddress = buffer->base_address;
  v13 = IsDbgUiRemoteBreakinPatchedToCallLdrShutdownProcess() || HasBlankNamedSections((__int64)baseAddress, v12);
  if ( v13 )
    processFlags |= 0x20u;
  if ( IsObufuscatedByVMP((__int64)buffer->base_address, v12) )// check for .vmp0 section
    processFlags |= 0x40u;
  currentProcess2 = import_PsGetCurrentProcess(v15, v14);
  if ( import_PsGetProcessId )
    currentProcessID2 = import_PsGetProcessId(currentProcess2);
  else
    currentProcessID2 = 0i64;
  if ( !IsProtectedGameProcessMaybe(currentProcessID2) && GetProcessFileName(currentProcess2, &filename) )
  {
    v19 = *(_QWORD *)&filename < *(_QWORD *)(StringTable + 5148);// dllhost.exe
    if ( *(_QWORD *)&filename != *(_QWORD *)(StringTable + 5148)
      || (v19 = v43 < *(_WORD *)(StringTable + 5156), v43 != *(_WORD *)(StringTable + 5156))
      || (v19 = v44 < *(_BYTE *)(StringTable + 5158), v44 != *(_BYTE *)(StringTable + 5158)) )
    {
      v20 = -v19 - (v19 - 1);
    }
    else
    {
      v20 = 0;
    }
    if ( !v20 )
      goto processname_matched;
    v21 = *(_QWORD *)&filename < *(_QWORD *)(StringTable + 4545);// svchost.exe
    if ( *(_QWORD *)&filename != *(_QWORD *)(StringTable + 4545)
      || (v21 = v43 < *(_WORD *)(StringTable + 4553), v43 != *(_WORD *)(StringTable + 4553))
      || (v21 = v44 < *(_BYTE *)(StringTable + 4555), v44 != *(_BYTE *)(StringTable + 4555)) )
    {
      v22 = -v21 - (v21 - 1);
    }
    else
    {
      v22 = 0;
    }
    if ( !v22 )
      goto processname_matched;
    v23 = *(_QWORD *)&filename < *(_QWORD *)(StringTable + 5160);// taskhost.exe
    if ( *(_QWORD *)&filename != *(_QWORD *)(StringTable + 5160)
      || (v23 = *(_DWORD *)&v43 < *(_DWORD *)(StringTable + 5168), *(_DWORD *)&v43 != *(_DWORD *)(StringTable + 5168)) )
    {
      v24 = -v23 - (v23 - 1);
    }
    else
    {
      v24 = 0;
    }
    if ( !v24 )
      goto processname_matched;
    v25 = *(_QWORD *)&filename < *(_QWORD *)(StringTable + 5173);// taskhostex.exe
    if ( *(_QWORD *)&filename != *(_QWORD *)(StringTable + 5173)
      || (v25 = *(_DWORD *)&v43 < *(_DWORD *)(StringTable + 5181), *(_DWORD *)&v43 != *(_DWORD *)(StringTable + 5181))
      || (v25 = v45 < *(_WORD *)(StringTable + 5185), v45 != *(_WORD *)(StringTable + 5185)) )
    {
      v26 = -v25 - (v25 - 1);
    }
    else
    {
      v26 = 0;
    }
    if ( !v26
      || ((v27 = *(_QWORD *)&filename < *(_QWORD *)(StringTable + 5188),
           *(_QWORD *)&filename != *(_QWORD *)(StringTable + 5188))// taskhostw.exe
       || (v27 = *(_DWORD *)&v43 < *(_DWORD *)(StringTable + 5196), *(_DWORD *)&v43 != *(_DWORD *)(StringTable + 5196))
       || (v27 = (unsigned __int8)v45 < *(_BYTE *)(StringTable + 5200), (_BYTE)v45 != *(_BYTE *)(StringTable + 5200)) ? (v28 = -v27 - (v27 - 1)) : (v28 = 0),
          !v28) )
    {
processname_matched:                            // this is executed if process name equals any of listed above
      processFlags |= 0x2000u;
      if ( currentProcess2 )
      {
        if ( import_PsGetProcessInheritedFromUniqueProcessId )
          parentPID = import_PsGetProcessInheritedFromUniqueProcessId(currentProcess2);
        else
          parentPID = 0i64;
      }
      else
      {
        parentPID = 0i64;
      }
      if ( parentPID )
      {
        v30 = import_PsLookupProcessByProcessId ? (unsigned int)import_PsLookupProcessByProcessId(
                                                                  parentPID,
                                                                  &parentProcess) : -1073741822;
        if ( v30 >= 0 )
        {
          if ( MEMORY[0xFFFFF7800000026C] != 5 )
          {
            v31 = parentProcess;
            if ( !parentProcess )
            {
LABEL_72:
              processFlags |= 0x4000u;
LABEL_74:
              ObfDereferenceObject(v31);
              goto LABEL_76;
            }
            if ( !QueryTokenIntegrityLevel((__int64)parentProcess, (__int64)&v46) || v46 < 0x4000 )
            {
              v31 = parentProcess;
              goto LABEL_72;
            }
          }
          v31 = parentProcess;
          goto LABEL_74;
        }
      }
      processFlags |= 0x4000u;
    }
  }
LABEL_76:
  if ( v3 && (!currentProcess ? (v32 = 0) : (v32 = GetProcessPath(currentProcess, (__int64)&buffer->process_path)), v32)
    || v3 && GetMappedFilename(-1i64, (__int64)buffer->base_address, (__int64)&buffer->process_path, 0)
    || v3
    && (!currentProcessID ? (v33 = 0) : (v33 = GetProcessImageFileName(&buffer->process_path, currentProcessID, 0)), v33)
    || (v34 = &buffer->process_path, GetProcessPathOrCommandLine(currentProcess, 1, (__int64)&buffer->process_path)) )
  {
    buffer->success = 1;
    v34 = &buffer->process_path;
    if ( IsFileInSystemDirectory(&buffer->process_path) )
      processFlags |= 0x200u;
  }
  v36 = buffer->base_address;
  v37 = (unsigned __int64)&v36[63].e_lfanew + 3;
  if ( (_IMAGE_DOS_HEADER *)((char *)&v36[63].e_lfanew + 3) < v36 || v37 >= MmUserProbeAddress )
  {
    ExRaiseAccessViolation(v37, v35);
  }
  else
  {
    v38 = (unsigned __int16 *)((unsigned __int64)v34 & -(signed __int64)(buffer->success != 0));
    v39 = GetProcessBitness2(currentProcess);
    v40 = CopyProcessInformation(buffer->base_address, 0x1000ui64, 0i64, processFlags, v39, v38, currentProcessID, 0i64);
    *(_QWORD *)&buffer->char0 = v40;
    if ( v40 )
    {
      if ( !buffer->success && GetProcessFileName(currentProcess, &filename) )
        CopyString(*(_QWORD *)&buffer->char0 + 22i64, 0x100ui64, &filename);
      v3 = 1;
    }
  }
LABEL_99:
  if ( !v3 && buffer )
  {
    sub_20430((__int64 *)&buffer->char0);
    buffer = 0i64;
  }
  return buffer;
}

unsigned int *__fastcall CopyProcessInformation(_IMAGE_DOS_HEADER *baseAddress, unsigned __int64 a2, unsigned __int64 a3, unsigned int a4, int a5, unsigned __int16 *a6, __int16 a7, _QWORD *a8)
{
  _DWORD *buffer; // rax MAPDST
  __int64 v14; // rdx
  bool v15; // al
  _WORD *v16; // rcx
  __int64 v17; // r9
  unsigned __int64 v18; // r8
  signed int v19; // eax
  unsigned __int16 v20; // dx
  signed __int64 v21; // rdx
  __int64 v22; // r9
  _QWORD *v23; // r13
  char *v24; // rcx
  int v25; // eax
  _IMAGE_NT_HEADERS64 *v26; // rdx
  _IMAGE_SECTION_HEADER *v27; // rcx
  USHORT v28; // r8
  __int64 v29; // rdi
  int v30; // er13
  unsigned int *v31; // rax
  unsigned int *v32; // rbx
  _IMAGE_NT_HEADERS64 *ntHeader; // [rsp+28h] [rbp-E0h]
  char *Src; // [rsp+30h] [rbp-D8h]
  _DWORD *v35; // [rsp+38h] [rbp-D0h]
  _DWORD *v36; // [rsp+40h] [rbp-C8h]
  int v38; // [rsp+50h] [rbp-B8h]
  _IMAGE_SECTION_HEADER *v39; // [rsp+58h] [rbp-B0h]
  char debugstring; // [rsp+60h] [rbp-A8h]

  buffer = (_DWORD *)AllocatePool(4676i64);
  if ( !buffer )
    return 0i64;
  memset(buffer, 0, 0x244ui64);
  *(_QWORD *)(buffer + 1) = baseAddress;
  buffer[3] = a2;
  buffer[4] = a4;
  if ( a5 )
    *((_BYTE *)buffer + 20) = a5;
  else
    *((_BYTE *)buffer + 20) = 64;
  *((_WORD *)buffer + 267) = a7;
  v15 = !a6 || !*((_QWORD *)a6 + 1) || !*a6 || !a6[1];
  if ( !v15 )
  {
    v16 = (_WORD *)((char *)buffer + 22);
    v17 = 0i64;
    v18 = 0i64;
    v19 = 0;
    if ( *(_BYTE *)a6 & 1 || (v20 = a6[1], v20 & 1) || *a6 > v20 || v20 > 0xFFFEu )
    {
      v19 = 0xC000000D;
    }
    else if ( !*((_QWORD *)a6 + 1) && (*a6 || v20) )
    {
      v19 = -1073741811;
    }
    if ( v19 >= 0 )
    {
      v17 = *((_QWORD *)a6 + 1);
      v18 = (unsigned __int64)*a6 >> 1;
    }
    if ( v19 < 0 )
    {
      *v16 = 0;
    }
    else
    {
      v21 = 256i64;
      v22 = v17 - (_QWORD)v16;
      do
      {
        if ( !v18 )
          break;
        *v16 = *(_WORD *)((char *)v16 + v22);
        ++v16;
        --v21;
        --v18;
      }
      while ( v21 );
      if ( !v21 )
        --v16;
      *v16 = 0;
    }
    if ( sub_289F0(a6, (__int64)&ntHeader) )
      *((_BYTE *)buffer + 21) = (unsigned __int64)(*a6 - (unsigned int)ntHeader) >> 1;
  }
  v23 = buffer + 145;
  v35 = buffer + 145;
  if ( baseAddress && a2 && (unsigned __int64)baseAddress < MmHighestUserAddress )
  {
    v24 = (char *)baseAddress + a2 - 1;
    if ( v24 < (char *)baseAddress || (unsigned __int64)v24 >= MmUserProbeAddress )
    {
      ExRaiseAccessViolation(v24, v14);
    }
    else if ( ValidatePeHeader(baseAddress, a2, 0i64, &ntHeader) && (v25 = IsPe64Or32Bit(baseAddress), (v38 = v25) != 0) )
    {
      *((_BYTE *)buffer + 20) = v25;
      v26 = ntHeader;
      buffer[134] = ntHeader->FileHeader.TimeDateStamp;
      *((_WORD *)buffer + 270) = v26->FileHeader.Machine;
      *((_WORD *)buffer + 271) = v26->FileHeader.Characteristics;
      *((_WORD *)buffer + 284) = 0;
      if ( v25 == 64 )
        buffer[136] = v26->OptionalHeader.ImageBase;
      else
        buffer[136] = HIDWORD(v26->OptionalHeader.ImageBase);
      buffer[137] = v26->OptionalHeader.SizeOfImage;
      buffer[138] = v26->OptionalHeader.BaseOfCode;
      buffer[139] = v26->OptionalHeader.SizeOfCode;
      buffer[140] = v26->OptionalHeader.AddressOfEntryPoint;
      buffer[141] = v26->OptionalHeader.CheckSum;
      v36 = buffer + 145;
      v27 = (_IMAGE_SECTION_HEADER *)((char *)&v26->OptionalHeader + v26->FileHeader.SizeOfOptionalHeader);
      v28 = 0;
      while ( v28 < v26->FileHeader.NumberOfSections )
      {
        if ( (_IMAGE_SECTION_HEADER *)((char *)&v27->Characteristics + 3) < v27
          || (unsigned __int64)&v27->Characteristics + 3 >= MmUserProbeAddress )
        {
          ExRaiseAccessViolation(v27, v26);
          break;
        }
        *v23 = *(_QWORD *)v27->Name;
        ++*((_WORD *)buffer + 284);
        ++v28;
        ++v27;
        v39 = v27;
        ++v23;
        v36 = v23;
      }
      v35 = v23;
      if ( CopyRawDataFromDebugDirectory(baseAddress, (__int64)&debugstring) )
      {
        Src = &debugstring;
        InitAnsiString((ANSI_STRING *)&ntHeader, &debugstring);
        v29 = (unsigned __int16)ntHeader;
        memmove(v23, Src, (unsigned __int16)ntHeader);
        v23 = (_QWORD *)((char *)v23 + v29);
        v35 = v23;
        *((_WORD *)buffer + 287) = v29;
      }
    }
    else
    {
      buffer[4] |= 0x80u;
    }
  }
  v30 = (_DWORD)v23 - (_DWORD)buffer;
  *buffer = v30;
  v31 = (unsigned int *)AllocatePool((unsigned int)(v30 + a3));
  v32 = v31;
  if ( v31 )
  {
    memmove(v31, buffer, (unsigned int)*buffer);
    if ( a3 > 0 )
    {
      if ( a8 )
        *a8 = (char *)v32 + *v32;
    }
  }
  FreePool((__int64)buffer);
  return v32;
}
```

`EasyAntiCheat.sys/servicetable.c`:

```c
char __usercall CheckServiceTable@<al>(signed int a1@<r14d>)
{
  unsigned int v2; // er12
  unsigned __int64 lstar; // rax MAPDST
  unsigned __int64 lstarEnd; // rbp
  unsigned int serviceTableHash; // edi
  unsigned int systemVersion; // eax MAPDST
  __int64 packetType; // rcx
  SystemServiceDescriptorTable *ssdt; // rsi
  unsigned int *detectionBuffer; // rbp
  unsigned int *functionDetectionBuffer; // r12
  unsigned int index; // ebx
  _BYTE *functionName; // rcx
  char *zwSyscallFunction; // rax MAPDST
  __int64 syscallIndex; // rax
  char *syscallFunctionFromSDDT; // rcx
  ULONG numOfServices; // edx
  unsigned int v20; // [rsp+40h] [rbp+8h]

  systemVersion = GetSystemVersion();
  v2 = systemVersion;
  v20 = systemVersion;
  lstar = __readmsr(0xC0000082);
  lstarEnd = (lstar & 0xFFFFFFFFFFFFF000ui64) + 0xFF1;
  if ( KeGetCurrentIrql() > 1u )
    return 0;
  serviceTableHash = 0;
  if ( !lstar )
    return 0;
  if ( !IsAddressWithinNtoskrnl(lstar) )
  {
    systemVersion = GetSystemVersion();
    packetType = 328i64;
    v20 = systemVersion;
LABEL_5:
    SendPacketToServer(packetType, (__int64)&v20, 4i64);
    return 0;
  }
  if ( lstar >= lstarEnd )
  {
LABEL_14:
    ssdt = 0i64;
  }
  else
  {
    while ( 1 )
    {
      if ( (*(_DWORD *)lstar & 0xFFFFFF) == 0x158D4C// lea r10, [rip+offset]
                                                // lea r11, [rip+offset]
                                                // test [something]
        && (*(_DWORD *)(lstar + 7) & 0xFFFFFF) == 0x1D8D4C
        && *(_BYTE *)(lstar + 14) == 0xF7u )
      {
        ssdt = (SystemServiceDescriptorTable *)(*(unsigned int *)(lstar + 3) + lstar + 7);
        if ( IsAddressWithinNtoskrnl((unsigned __int64)ssdt) )
          break;
      }
      if ( ++lstar >= lstarEnd )
        goto LABEL_14;
    }
  }
  if ( !ssdt )
    return 0;
  if ( !IsAddressWithinNtoskrnl((unsigned __int64)ssdt) )
  {
    packetType = 327i64;
    goto LABEL_5;
  }
  if ( !(unsigned __int8)MmIsAddressValid(ssdt) )
    return 0;
  detectionBuffer = (unsigned int *)AllocatePool(72i64);
  memset(detectionBuffer, 0, 72ui64);
  *detectionBuffer = v2;
  functionDetectionBuffer = detectionBuffer + 3;
  index = 0;
  do
  {
    if ( index )
    {
      switch ( index )
      {
        case 1u:
          functionName = (_BYTE *)(StringTable + 4658);// ZwDeviceIoControlFile
          break;
        case 2u:
          functionName = (_BYTE *)(StringTable + 4680);// ZwQueryInformationProcess
          break;
        case 3u:
          functionName = (_BYTE *)(StringTable + 4706);// ZwQuerySystemInformation
          break;
        case 4u:
          functionName = (_BYTE *)(StringTable + 4731);// ZwQueryVirtualMemory
          break;
        default:
          functionName = 0i64;
          break;
      }
    }
    else
    {
      functionName = (_BYTE *)(StringTable + 4645);// ZwCreateFile
    }
    zwSyscallFunction = (char *)GetKernelSyscallFunctionForNtdllFunction(functionName, a1);
    if ( zwSyscallFunction )
    {
      functionDetectionBuffer[1] = UnkHashFunction(zwSyscallFunction, 0x40i64, 0i64);
      if ( GetSyscallIndexFromFunction(&v20, (unsigned __int64)zwSyscallFunction, a1) )
      {
        syscallIndex = v20;
        *functionDetectionBuffer = v20;
        if ( (unsigned int)syscallIndex > 0xFFF || (unsigned int)syscallIndex >= ssdt->NumberOfServices )
          syscallFunctionFromSDDT = 0i64;
        else
          syscallFunctionFromSDDT = (char *)ssdt->ServiceTableBase
                                  + ((unsigned __int64)*((unsigned int *)ssdt->ServiceTableBase + syscallIndex) >> 4);
        functionDetectionBuffer[2] = UnkHashFunction(syscallFunctionFromSDDT, 64i64, 0i64);
      }
    }
    ++index;
    functionDetectionBuffer += 3;
  }
  while ( index < 5 );
  numOfServices = ssdt->NumberOfServices;
  if ( numOfServices <= 0xFFF )
    serviceTableHash = HashCRC32((char *)ssdt->ServiceTableBase, 4 * numOfServices, 0);
  detectionBuffer[1] = serviceTableHash;
  detectionBuffer[2] = ssdt->NumberOfServices;
  SendPacketToServer(317i64, (__int64)detectionBuffer, 72i64);
  FreePool((__int64)detectionBuffer);
  return 1;
}

_WORD *__usercall GetKernelSyscallFunctionForNtdllFunction@<rax>(_BYTE *funcName@<rcx>, signed int a2@<r14d>)
{
  _WORD *v3; // rbx Gets kernel ZwXXX function address which  is equivallent to ntdll Nt/ZwXXX function
  _WORD *result; // rax
  unsigned int copySize; // edi
  char *ntdllExportRva; // rax
  int ntdllSyscallIndex; // er12
  unsigned int i; // edi
  char *ntdllByte; // r13
  int v12; // eax
  __int64 zwFuncIt; // rsi
  char foundRet; // r13
  int syscallIndexOffset; // er15
  unsigned int ntoskrnlOffset; // edi
  unsigned int j; // er14
  unsigned int instructionSize; // eax
  int v19; // ecx
  void *v20; // rcx
  char v21; // al
  _WORD *addr; // rcx
  _BYTE *addr0; // r8 MAPDST
  unsigned __int64 currentOffset; // rdx
  unsigned __int8 v26; // [rsp+48h] [rbp-2E0h]
  __int64 v27; // [rsp+50h] [rbp-2D8h]
  __int64 v28; // [rsp+58h] [rbp-2D0h]
  _WORD *sectionVa; // [rsp+60h] [rbp-2C8h]
  unsigned __int64 v30; // [rsp+68h] [rbp-2C0h]
  char *ntoskrnlBuffer0; // [rsp+70h] [rbp-2B8h] MAPDST
  unsigned __int8 v33; // [rsp+80h] [rbp-2A8h]
  __int64 v34; // [rsp+95h] [rbp-293h]
  __int64 v35; // [rsp+9Dh] [rbp-28Bh]
  char ntdllBuffer[64]; // [rsp+B0h] [rbp-278h]
  char ntoskrnlBuffer[120]; // [rsp+F0h] [rbp-238h]
  unsigned int size; // [rsp+330h] [rbp+8h]
  void *bufferIt; // [rsp+338h] [rbp+10h] MAPDST
  size_t instructionSize_; // [rsp+340h] [rbp+18h]
  unsigned __int64 sectionSize; // [rsp+348h] [rbp+20h]

  v3 = 0i64;
  v26 = 0;
  result = 0i64;
  v27 = 0i64;
  v28 = 0i64;
  if ( funcName && *funcName )
  {
    copySize = 0;
    if ( StringTable != 0xFFFFFFFFFFFFDB93i64
      && ReadFileA((const char *)(StringTable + 0x246D), (__int64)&bufferIt, (__int64)&size) )// \SystemRoot\system32\ntdll.dll
    {
      ntdllExportRva = GetPeExportRva((_IMAGE_DOS_HEADER *)bufferIt, size, (unsigned __int64)funcName);
      if ( ntdllExportRva )
      {
        copySize = size - (_DWORD)ntdllExportRva;
        if ( size - (unsigned int)ntdllExportRva > 64 )
          copySize = 64;
        memmove(ntdllBuffer, (char *)bufferIt + (_QWORD)ntdllExportRva, copySize);
      }
      if ( bufferIt )
        FreePool((__int64)bufferIt);
    }
    if ( copySize )
    {
      if ( GetNtoskrnlSection('txet.', &sectionVa, &sectionSize) )
      {
        ntdllSyscallIndex = 0;
        for ( i = 0; i < 0x10; i += v12 )
        {
          ntdllByte = &ntdllBuffer[i];
          v12 = GetInstructionSize(&v33, &ntdllBuffer[i], a2);
          if ( _bittest((const signed __int32 *)&v35 + 1, 0xCu) )
            break;
          if ( *ntdllByte == 0xB8u )            // mov     eax, ??h
          {
            ntdllSyscallIndex = *(_DWORD *)&ntdllBuffer[i + 1];
            break;
          }
          if ( *ntdllByte == 0xC2u || *ntdllByte == 0xC3u )
            break;
        }
        if ( ntdllSyscallIndex )
        {
          zwFuncIt = (__int64)FindExport((DATA_HASH_BUFFER *)&unk_47588);// can be any ZwXX function
          if ( zwFuncIt )
          {
            foundRet = 0;
            syscallIndexOffset = 0;
            ntoskrnlOffset = 0;
            for ( j = 0; j < 0x10; ++j )
            {
              instructionSize = GetInstructionSize(&v33, (_BYTE *)zwFuncIt, j);
              size = instructionSize;
              if ( _bittest((const signed __int32 *)&v35 + 1, 0xCu) )
                break;
              instructionSize_ = instructionSize;
              bufferIt = &ntoskrnlBuffer[ntoskrnlOffset];
              memmove(&ntoskrnlBuffer[ntoskrnlOffset], (const void *)zwFuncIt, instructionSize);
              if ( *(_BYTE *)zwFuncIt == 0xB8u )
              {
                syscallIndexOffset = ntoskrnlOffset + 1;
                *(_DWORD *)&ntoskrnlBuffer[ntoskrnlOffset + 1] = ntdllSyscallIndex;
              }
              else
              {
                if ( *(_BYTE *)zwFuncIt == 0xC2u || *(_BYTE *)zwFuncIt == 0xC3u )
                {
                  if ( *(_BYTE *)zwFuncIt == 0xC2u )
                    *(_WORD *)&ntoskrnlBuffer[ntoskrnlOffset + 1] = 0xAAAAu;
                  ntoskrnlOffset += size;
                  foundRet = 1;
                  break;
                }
                v19 = HIDWORD(v35);
                if ( _bittest(&v19, 9u) || _bittest(&v19, 8u) )
                {
                  v26 = v33;
                  v27 = v34;
                  v28 = v35;
                  v20 = bufferIt;
                  if ( bufferIt )
                  {
                    v21 = sub_17FB0((unsigned __int64)bufferIt, &v26);
                    v20 = bufferIt;
                  }
                  else
                  {
                    v21 = 0;
                  }
                  if ( !v21 )
                  {
                    memset(v20, 170, instructionSize_);
                    *(_BYTE *)bufferIt = *(_BYTE *)zwFuncIt;
                  }
                  if ( *(_BYTE *)zwFuncIt == 0xE9u )
                  {
                    ntoskrnlOffset += size;
                    goto LABEL_46;
                  }
                }
              }
              ntoskrnlOffset += size;
              zwFuncIt += instructionSize_;
            }
            if ( !foundRet )
              goto LABEL_60;
LABEL_46:
            if ( syscallIndexOffset && ntoskrnlOffset >= 2 && ntoskrnlOffset <= sectionSize )
            {
              for ( addr = sectionVa;
                    addr < (_WORD *)((char *)sectionVa + sectionSize - ntoskrnlOffset);
                    addr = (_WORD *)((char *)addr + 1) )
              {
                if ( *addr == *(_WORD *)ntoskrnlBuffer )
                {
                  addr0 = addr;
                  addr0 = addr;
                  ntoskrnlBuffer0 = ntoskrnlBuffer;
                  ntoskrnlBuffer0 = ntoskrnlBuffer;
                  currentOffset = 0i64;
                  v30 = 0i64;
                  while ( currentOffset < ntoskrnlOffset && (*addr0 == *ntoskrnlBuffer0 || *ntoskrnlBuffer0 == 0xAAu) )
                  {
                    v30 = ++currentOffset;
                    ++addr0;
                    ++ntoskrnlBuffer0;
                  }
                  if ( currentOffset == ntoskrnlOffset )
                  {
                    v3 = addr;
                    break;
                  }
                }
              }
            }
          }
        }
LABEL_60:
        result = v3;
      }
      else
      {
        result = 0i64;
      }
    }
    else
    {
      result = 0i64;
    }
  }
  return result;
}
```

`EasyAntiCheat.sys/suspiciousmodules.c`:

```c
char __fastcall CheckForSuspiciousModules(__int64 a1)
{
  char suspiciousModulesFound; // di
  __int64 *processes; // rax MAPDST
  unsigned int processCount; // esi
  __int64 *pProcess; // rbp
  __int64 v7; // rsi

  suspiciousModulesFound = 0;
  processes = (__int64 *)AllocatePool(4096i64);
  if ( processes )
  {
    processCount = Get512RunningProcessesFromThreads(processes);
    if ( processCount )
    {
      ObfDereferenceObject((PVOID)*processes);
      if ( processCount > 1 )
      {
        pProcess = processes + 1;
        v7 = processCount - 1;
        do
        {
          if ( !suspiciousModulesFound && !sub_1F140(a1) )
            suspiciousModulesFound = IsProcessRunningSuspiciousModule(*pProcess, v7);
          ObfDereferenceObject((PVOID)*pProcess);
          ++pProcess;
          --v7;
        }
        while ( v7 );
      }
    }
    FreePool((__int64)processes);
  }
  return suspiciousModulesFound;
}

char __usercall IsProcessRunningSuspiciousModule@<al>(__int64 process@<rcx>, int a2@<esi>)
{
  char v3; // bl
  char v5; // [rsp+20h] [rbp-38h]

  v3 = 0;
  if ( AttachToProcess(process, (__int64)&v5) )
  {
    if ( GetUsermodeModule((UNICODE_STRING *)(StringTable + 4830))// Dumper.dll
      && GetUsermodeModule((UNICODE_STRING *)(StringTable + 4852))// Glob.dll
      && GetUsermodeModule((UNICODE_STRING *)(StringTable + 4870))// mswsock.dll
      && GetUsermodeModule((UNICODE_STRING *)(StringTable + 4894))// perl512.dll
      || GetUsermodeModule((UNICODE_STRING *)(StringTable + 4918))// vmclientcore.dll
      || GetUsermodeModule((UNICODE_STRING *)(StringTable + 4952))// vmwarewui.dll
      || GetUsermodeModule((UNICODE_STRING *)(StringTable + 4980))// virtualbox.dll
      || GetUsermodeModule((UNICODE_STRING *)(StringTable + 5010))// qtcorevbox4.dll
      || GetUsermodeModule((UNICODE_STRING *)(StringTable + 5042))// vboxvmm.dll
      || GetUsermodeModule((UNICODE_STRING *)(StringTable + 5066)) )// netredirect.dll
    {
      v3 = 1;
    }
    if ( process )
      DetachFromProcess(process, (__int64)&v5, process, a2);
  }
  return v3;
}

char CheckRunningPrograms()
{
  char v0; // bp
  HANDLE *processes; // rax MAPDST
  unsigned int status; // er13
  unsigned int index; // esi
  HANDLE *current; // r12
  signed int v6; // eax
  char v7; // bl
  __int64 v8; // rbx
  unsigned __int64 v9; // r8
  SYSTEM_MODULE_INFORMATION *moduleInformation; // rax MAPDST
  __int64 v11; // r8
  ULONG v13; // esi
  USHORT *v14; // rdi
  CHAR *v15; // rdx
  __int64 v16; // r8
  __int64 v17; // r8
  ANSI_STRING a1; // [rsp+20h] [rbp-48h]
  char v20; // [rsp+30h] [rbp-38h]
  PVOID process; // [rsp+70h] [rbp+8h]

  v0 = 0;
  processes = (HANDLE *)AllocatePool(2048i64);
  if ( !processes )
    goto LABEL_34;
  status = GetRunningProcesses(processes, 0x100u, 0i64, 0i64);
  if ( status > 0 )
  {
    index = 0;
    current = processes;
    while ( 1 )
    {
      if ( *current )
      {
        v6 = import_PsLookupProcessByProcessId ? (unsigned int)import_PsLookupProcessByProcessId(*current, &process) : 0xC0000002;
        if ( v6 >= 0 )
        {
          v7 = GetProcessFileName((__int64)process, &v20);
          ObfDereferenceObject(process);
          if ( v7 )
          {
            v8 = StringTable;
            if ( strstrIgnoreCase(&v20, (_BYTE *)(StringTable + 8018), 7ui64)// dbgview
              || strstrIgnoreCase(&v20, (_BYTE *)(v8 + 8026), v9)// devenv
              || strstrIgnoreCase(&v20, (_BYTE *)(v8 + 8034), 3ui64) )// tv_
            {
              break;
            }
          }
        }
      }
      ++index;
      ++current;
      if ( index >= status )
        goto LABEL_16;
    }
    v0 = 1;
  }
LABEL_16:
  FreePool((__int64)processes);
  if ( !v0 )
  {
LABEL_34:
    moduleInformation = (SYSTEM_MODULE_INFORMATION *)QuerySystemModuleInformation(0);
    if ( moduleInformation )
    {
      v13 = 0;
      if ( moduleInformation->Count > 0 )
      {
        v14 = &moduleInformation->Module[0].OffsetToFileName;
        while ( 1 )
        {
          if ( *(_QWORD *)(v14 - 11) >= MmSystemRangeStart )
          {
            v15 = (char *)v14 + *v14 + 2;
            a1.Buffer = v15;
            if ( v15 )
            {
              SetAnsiStringLength(&a1, v15);
            }
            else
            {
              a1.Length = 0;
              a1.MaximumLength = 0;
            }
            LOBYTE(v11) = 1;
            if ( !(unsigned int)strstr2((__int64)&a1, (const char *)(StringTable + 8038), v11) )// Dbgv.sys
              break;
            LOBYTE(v16) = 1;
            if ( !(unsigned int)strstr2((__int64)&a1, (const char *)(StringTable + 8047), v16) )// PROCMON23.sys
              break;
            LOBYTE(v17) = 1;
            if ( !(unsigned int)strstr2((__int64)&a1, (const char *)(StringTable + 8061), v17) )// dbk64.sys
              break;
          }
          ++v13;
          v14 += 148;
          if ( v13 >= moduleInformation->Count )
            goto LABEL_30;
        }
        v0 = 1;
      }
LABEL_30:
      FreePool((__int64)moduleInformation);
    }
  }
  return v0;
}

bool __fastcall SomeModuleCheck(UNICODE_STRING *a1)
{
  UNICODE_STRING *v1; // rbx
  __int64 v2; // rdi
  bool result; // al

  v1 = a1;
  result = 0;
  if ( a1 )
  {
    if ( a1->Buffer )
    {
      if ( a1->Length )
      {
        if ( a1->MaximumLength )
        {
          v2 = StringTable;
          if ( CompareUnicodeStringsIgnoreCase(a1, (unsigned __int16 *)(StringTable + 8467))//  \System32\atmfd.dll
            || CompareUnicodeStringsIgnoreCase(v1, (unsigned __int16 *)(v2 + 8507))//  \System32\cdd.dll
            || CompareUnicodeStringsIgnoreCase(v1, (unsigned __int16 *)(v2 + 8543))// \System32\rdpdd.dll
            || CompareUnicodeStringsIgnoreCase(v1, (unsigned __int16 *)(v2 + 8583))// \System32\vga.dll
            || CompareUnicodeStringsIgnoreCase(v1, (unsigned __int16 *)(v2 + 8619)) )// \System32\workerdd.dll
          {
            result = 1;
          }
        }
      }
    }
  }
  return result;
}
```

`EasyAntiCheat.sys/systemthread.c`:

```c
__int64 ScanSystemThreads()
{
  __int64 result; // rax
  __int64 currentProcessId; // r14
  int isSystemThread; // er11
  __int64 systemBigPoolInformation; // r12
  SYSTEM_MODULE_INFORMATION *systemModuleInformation; // r13
  CONTEXT *context; // rsi
  unsigned __int64 currentThreadId; // rbx
  signed int status0; // eax
  STACKWALK_ENTRY *entry; // rdi
  __int64 v10; // rcx
  int entryIndex; // er10
  __int64 v12; // r11
  unsigned __int64 v13; // rcx
  int status1; // eax
  __int64 threadProcessId; // rax
  STACKWALK_BUFFER stackwalkBuffer; // [rsp+30h] [rbp-238h]
  PVOID threadObject; // [rsp+270h] [rbp+8h] MAPDST
  __int64 win32StartAddress; // [rsp+278h] [rbp+10h] MAPDST
 
  result = import_PsGetCurrentThreadProcessId();
  currentProcessId = result;
  if ( import_PsIsSystemThread )
  {
    result = import_PsIsSystemThread(__readgsqword(0x188u));
    isSystemThread = (unsigned __int8)result;
  }
  else
  {
    isSystemThread = 0;
  }
  if ( isSystemThread )
  {
    result = import_PsGetCurrentProcess();
    if ( result == PsInitialSystemProcess )
    {
      systemBigPoolInformation = QuerySystemInformation(0x42i64, 0x100000i64, 0x2000000i64);
      result = QuerySystemModuleInformation();
      systemModuleInformation = (SYSTEM_MODULE_INFORMATION *)result;
      if ( result )
      {
        context = (CONTEXT *)AllocatePool(0x4D0i64);
        if ( context )
        {
          currentThreadId = 4i64;
          do
          {
            if ( import_PsLookupThreadByThreadId )
              status0 = import_PsLookupThreadByThreadId(currentThreadId, &threadObject);
            else
              status0 = 0xC0000002;
            if ( status0 >= 0 )
            {
              if ( GetProcessId((__int64)threadObject) == currentProcessId
                && threadObject != (PVOID)__readgsqword(0x188u)
                && StackwalkThread((__int64)threadObject, context, &stackwalkBuffer)
                && stackwalkBuffer.EntryCount > 0u )
              {
                entry = stackwalkBuffer.Entries;
                while ( 1 )
                {
                  if ( !GetModuleEntryForAddress(entry->RipValue, &systemModuleInformation->Count) )
                  {
                    if ( !v10 )
                      break;
                    if ( !v12 )
                      break;
                    v13 = *(_QWORD *)(v12 + 24);
                    if ( !v13
                      || *(_DWORD *)(v12 + 32) <= 0u
                      || entry->RipValue < v13
                      || entry->RipValue >= v13 + *(unsigned int *)(v12 + 32) )
                    {
                      break;
                    }
                  }
                  ++entry;
                  if ( (unsigned int)(entryIndex + 1) >= stackwalkBuffer.EntryCount )
                    goto LABEL_30;
                }
                status1 = QueryWin32StartAddress((__int64)threadObject, &win32StartAddress);
                if ( status1 < 0 )
                  win32StartAddress = 0i64;
                threadProcessId = GetProcessId((__int64)threadObject);
                PerformAdditionalScans(         // This is virtualized.
                                                // Probably checks if address is within any big pool and sends report to server.
                  threadProcessId,
                  (unsigned int)currentThreadId,
                  win32StartAddress,
                  systemModuleInformation,
                  systemBigPoolInformation,
                  &stackwalkBuffer);
              }
LABEL_30:
              ObfDereferenceObject(threadObject);
            }
            currentThreadId += 4i64;
          }
          while ( currentThreadId < 0x3000 );
          FreePool((__int64)context);
        }
        result = FreePool((__int64)systemModuleInformation);
      }
      if ( systemBigPoolInformation )
        result = FreePool(systemBigPoolInformation);
    }
  }
  return result;
}
 
char __fastcall StackwalkThread(__int64 threadObject, CONTEXT *context, STACKWALK_BUFFER *stackwalkBuffer)
{
  char status; // di
  _QWORD *stackBuffer; // rax MAPDST
  size_t copiedSize; // rax
  DWORD64 startRip; // rdx
  unsigned int index; // ebp
  unsigned __int64 rip0; // rcx
  DWORD64 rsp0; // rdx
  __int64 functionTableEntry; // rax
  __int64 moduleBase; // [rsp+40h] [rbp-48h]
  __int64 v17; // [rsp+48h] [rbp-40h]
  __int64 v18; // [rsp+50h] [rbp-38h]
  unsigned __int64 sectionVa; // [rsp+90h] [rbp+8h]
  __int64 sectionSize; // [rsp+A8h] [rbp+20h]
 
  status = 0;
  if ( !threadObject )
    return 0;
  if ( !stackwalkBuffer )
    return 0;
  memset(context, 0, 0x4D0ui64);
  memset(stackwalkBuffer, 0, 0x208ui64);
  if ( !import_RtlVirtualUnwind )
  {
    import_RtlVirtualUnwind = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))FindExport((__int64)&unk_47420);
    if ( !import_RtlVirtualUnwind )
      return 0;
  }
  if ( !import_RtlLookupFunctionEntry )
  {
    import_RtlLookupFunctionEntry = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))FindExport((__int64)&unk_473F0);
    if ( !import_RtlLookupFunctionEntry )
      return 0;
  }
  stackBuffer = (_QWORD *)AllocatePool(4096i64);
  if ( stackBuffer )
  {
    copiedSize = CopyThreadKernelStack(threadObject, 4096i64, stackBuffer, 4096);
    if ( copiedSize )
    {
      if ( copiedSize != 4096 && copiedSize >= 0x48 )
      {
        if ( GetNtoskrnlSection('txet.', &sectionVa, &sectionSize) )
        {
          startRip = stackBuffer[7];
          if ( startRip >= sectionVa && startRip < sectionSize + sectionVa )
          {
            status = 1;
            context->Rip = startRip;
            context->Rsp = (DWORD64)(stackBuffer + 8);
            index = 0;
            do
            {
              rip0 = context->Rip;
              rsp0 = context->Rsp;
              stackwalkBuffer->Entries[stackwalkBuffer->EntryCount].RipValue = rip0;
			  stackwalkBuffer->Entries[stackwalkBuffer->EntryCount++].RspValue = rsp0;
              if ( rip0 < MmSystemRangeStart )
                break;
              if ( rsp0 < MmSystemRangeStart )
                break;
              functionTableEntry = import_RtlLookupFunctionEntry(rip0, &moduleBase, 0i64);
              if ( !functionTableEntry )
                break;
              import_RtlVirtualUnwind(0i64, moduleBase, context->Rip, functionTableEntry, context, &v18, &v17, 0i64);
              if ( !context->Rip )
              {
                stackwalkBuffer->Succeded = 1;
                break;
              }
              ++index;
            }
            while ( index < 0x20 );
          }
        }
      }
    }
    FinalizeFreePool((__int64)stackBuffer);
  }
  return status;
}
 
size_t __usercall CopyThreadKernelStack@<rax>(__int64 threadObject@<rcx>, __int64 maxSize@<rdx>, void *outStackBuffer@<r8>, signed int a4@<r14d>)
{
  size_t copiedSize; // rsi
  __int64 threadStateOffset; // r12 MAPDST
  __int64 kernelStackOffset; // r14
  unsigned int threadStackBaseOffset; // eax
  unsigned __int64 threadStackBase; // rdi
  unsigned int threadStackLimitOffset; // eax
  unsigned __int64 threadStackLimit; // rbp
  int isSystemThread; // er11
  const void **pKernelStack; // r12
  __int64 v16; // rdx
  unsigned int threadLockOffset; // eax
  KSPIN_LOCK *threadLock; // rcx
  void (__fastcall *v19)(_QWORD, __int64); // rax
  unsigned __int8 oldIrql; // [rsp+50h] [rbp+8h]
 
  copiedSize = 0i64;
  threadStateOffset = (unsigned int)GetThreadStateOffset(a4);
  kernelStackOffset = (unsigned int)GetKernelStackOffset();
  threadStackBaseOffset = GetThreadStackBaseOffset();
  if ( threadObject && threadStackBaseOffset )
    threadStackBase = *(_QWORD *)(threadStackBaseOffset + threadObject);
  else
    threadStackBase = 0i64;
  threadStackLimitOffset = GetThreadStackLimitOffset();
  if ( !threadObject )
    return 0i64;
  threadStackLimit = threadStackLimitOffset ? *(_QWORD *)(threadStackLimitOffset + threadObject) : 0i64;
  isSystemThread = import_PsIsSystemThread ? (unsigned __int8)import_PsIsSystemThread(threadObject) : 0;
  if ( !isSystemThread
    || !outStackBuffer
    || !(_DWORD)threadStateOffset
    || !(_DWORD)kernelStackOffset
    || !threadStackBase
    || !threadStackLimit
    || KeGetCurrentIrql() > 1u
    || threadObject == __readgsqword(0x188u) )
  {
    return 0i64;
  }
  pKernelStack = (const void **)(threadObject + kernelStackOffset);
  memset(outStackBuffer, 0, 0x1000ui64);
  if ( LockThread(&oldIrql, threadObject, 0x1000) )
  {
    if ( !(unsigned __int8)PsIsThreadTerminating(threadObject)
      && *(_BYTE *)(threadStateOffset + threadObject) == 5
      && (unsigned __int64)*pKernelStack > threadStackLimit
      && (unsigned __int64)*pKernelStack < threadStackBase
      && MmGetPhysicalAddress(*pKernelStack) )
    {
      copiedSize = threadStackBase - (_QWORD)*pKernelStack;
      if ( copiedSize > 0x1000 )
        copiedSize = 0x1000i64;
      memmove(outStackBuffer, *pKernelStack, copiedSize);
    }
    if ( MEMORY[0xFFFFF7800000026C] >= 6u && (MEMORY[0xFFFFF7800000026C] != 6 || MEMORY[0xFFFFF78000000270]) )
    {
      threadLockOffset = GetThreadLockOffset(0x1000);
      threadLock = (KSPIN_LOCK *)((threadObject + threadLockOffset) & -(signed __int64)(threadLockOffset != 0));
      if ( threadLock )
      {
        KeReleaseSpinLockFromDpcLevel(threadLock);
        __writecr8(oldIrql);
      }
    }
    else
    {
      v19 = (void (__fastcall *)(_QWORD, __int64))qword_4DF00;
      if ( qword_4DF00
        || (v19 = (void (__fastcall *)(_QWORD, __int64))FindExport((__int64)&unk_46D00),
            (qword_4DF00 = (__int64)v19) != 0) )
      {
        LOBYTE(v16) = oldIrql;
        v19(0i64, v16);
      }
    }
  }
  return copiedSize;
}
```

`EasyAntiCheat.sys/tdl.c`:

```c
SYSTEM_BIGPOOL_INFORMATION *__usercall CheckForTDL@<rax>(signed int a1@<r14d>)
{
  SYSTEM_BIGPOOL_INFORMATION *bigpoolInfo; // rax MAPDST
  ULONG index; // esi
  __int64 MmGetPhysicalAddress; // rdx
  SYSTEM_BIGPOOL_ENTRY1 *entry; // rbx
  char detectedTDL; // bp
  __int64 physicalAddress; // rax
  __int64 v8; // rax MAPDST
  unsigned __int64 v10; // rcx
  ULONG_PTR size; // rbx
  unsigned __int64 v12; // rcx
  __int64 alignedSize; // rbx
  __int64 v14; // rax
  __int64 v15; // rax MAPDST

  bigpoolInfo = (SYSTEM_BIGPOOL_INFORMATION *)QuerySystemInformation_0(0x42u, 0x100000u, 0x2000000u, 0i64, a1);
  if ( bigpoolInfo )
  {
    index = 0;
    if ( bigpoolInfo->Count )
    {
      MmGetPhysicalAddress = (__int64)import_MmGetPhysicalAddress;
      entry = (SYSTEM_BIGPOOL_ENTRY1 *)bigpoolInfo->AllocatedInfo;
      while ( 1 )
      {
        detectedTDL = 0;
        if ( *(_QWORD *)&entry->0 & 1 && entry->SizeInBytes >= 0x2000 )// if nonpaged
        {
          if ( entry->TagUlong == 'SldT' )
            break;
          if ( MmGetPhysicalAddress )
          {
            physicalAddress = ((__int64 (__fastcall *)(unsigned __int64))MmGetPhysicalAddress)((_QWORD)entry->VirtualAddress & 0xFFFFFFFFFFFFFFFEui64);
            MmGetPhysicalAddress = (__int64)import_MmGetPhysicalAddress;
          }
          else
          {
            physicalAddress = qword_4DBE8;
          }
          if ( physicalAddress )
          {
            v8 = MapPhysicalMemory(physicalAddress, 4096i64);
            if ( v8 )
            {
              if ( *(_QWORD *)(v8 + 0x184) == 0xB024BC8B48i64 )
              {
                detectedTDL = 0;
                if ( (unsigned int)HashCRC32((char *)(v8 + 0x184), 151u, 0) == 0xC8931AEB )
                  detectedTDL = 1;
              }
              if ( import_MmUnmapVideoDisplay )
                import_MmUnmapVideoDisplay(v8, 4096i64);
            }
            MmGetPhysicalAddress = (__int64)import_MmGetPhysicalAddress;
          }
        }
        else
        {
          detectedTDL = 0;
        }
        if ( detectedTDL )
          break;
        ++index;
        ++entry;
        if ( index >= bigpoolInfo->Count )
          goto LABEL_31;
      }
      v10 = (unsigned __int64)entry->VirtualAddress;
      size = entry->SizeInBytes;
      v12 = v10 & 0xFFFFFFFFFFFFFFFEui64;
      if ( size > (unsigned __int64)qword_80000 )
        size = (ULONG_PTR)qword_80000;
      alignedSize = size & 0xFFFFFFFFFFFFF000ui64;
      if ( MmGetPhysicalAddress )
        v14 = ((__int64 (__fastcall *)(unsigned __int64))MmGetPhysicalAddress)(v12);
      else
        v14 = qword_4DBE8;
      if ( v14 )
      {
        v15 = MapPhysicalMemory(v14, alignedSize);
        if ( v15 )
        {
          SendPacketToServer(133i64, v15, (unsigned int)alignedSize);
          if ( import_MmUnmapVideoDisplay )
            import_MmUnmapVideoDisplay(v15, alignedSize);
        }
      }
    }
LABEL_31:
    bigpoolInfo = (SYSTEM_BIGPOOL_INFORMATION *)FreePool((__int64)bigpoolInfo);
  }
  return bigpoolInfo;
}
```

`EasyAntiCheat.sys/vm.asm`:

```asm
.text:0000000000036C30                         ExecVMREAD      proc near               ; CODE XREF: CheckVM+21↑p
.text:0000000000036C30 0F 78 0A                                vmread  qword ptr [rdx], rcx
.text:0000000000036C33 0F 94 C0                                setz    al
.text:0000000000036C36 0F 92 C1                                setb    cl
.text:0000000000036C39 12 C1                                   adc     al, cl
.text:0000000000036C3B C3                                      retn
.text:0000000000036C3B                         ExecVMREAD      endp

.text:000000000001FD84                         CheckVM         proc near               ; DATA XREF: .pdata:000000000004F960↓o
.text:000000000001FD84
.text:000000000001FD84                         var_28          = byte ptr -28h
.text:000000000001FD84                         var_18          = dword ptr -18h
.text:000000000001FD84                         var_14          = dword ptr -14h
.text:000000000001FD84                         var_10          = dword ptr -10h
.text:000000000001FD84
.text:000000000001FD84                         ; FUNCTION CHUNK AT .text:000000000003724A SIZE 00000023 BYTES
.text:000000000001FD84
.text:000000000001FD84                         ; __unwind { // __C_specific_handler
.text:000000000001FD84 40 53                                   push    rbx
.text:000000000001FD86 48 83 EC 40                             sub     rsp, 40h
.text:000000000001FD8A B3 01                                   mov     bl, 1
.text:000000000001FD8C 88 5C 24 20                             mov     [rsp+48h+var_28], bl
.text:000000000001FD90 33 C0                                   xor     eax, eax
.text:000000000001FD92 89 44 24 30                             mov     [rsp+48h+var_18], eax
.text:000000000001FD96 89 44 24 34                             mov     [rsp+48h+var_14], eax
.text:000000000001FD9A 89 44 24 38                             mov     [rsp+48h+var_10], eax
.text:000000000001FD9E
.text:000000000001FD9E                         loc_1FD9E:                              ; DATA XREF: .rdata:0000000000049114↓o
.text:000000000001FD9E                         ;   __try { // __except at VMNotFound
.text:000000000001FD9E 48 8D 54 24 34                          lea     rdx, [rsp+48h+var_14]
.text:000000000001FDA3 33 C9                                   xor     ecx, ecx
.text:000000000001FDA5 E8 86 6E 01 00                          call    ExecVMREAD
.text:000000000001FDAA 88 5C 24 20                             mov     [rsp+48h+var_28], bl
.text:000000000001FDAE EB 16                                   jmp     short VMFound
.text:000000000001FDAE                         ;   } // starts at 1FD9E
.text:000000000001FDB0                         ; ---------------------------------------------------------------------------
.text:000000000001FDB0
.text:000000000001FDB0                         VMNotFound:                             ; DATA XREF: .rdata:0000000000049114↓o
.text:000000000001FDB0                         ;   __except(loc_3724A) // owned by 1FD9E
.text:000000000001FDB0 0F B6 5C 24 20                          movzx   ebx, [rsp+48h+var_28]
.text:000000000001FDB5 33 C0                                   xor     eax, eax
.text:000000000001FDB7 81 7C 24 30 1D 00 00 C0                 cmp     [rsp+48h+var_18], 0C000001Dh
.text:000000000001FDBF 0F 44 D8                                cmovz   ebx, eax
.text:000000000001FDC2 88 5C 24 20                             mov     [rsp+48h+var_28], bl
.text:000000000001FDC6
.text:000000000001FDC6                         VMFound:                                ; CODE XREF: CheckVM+2A↑j
.text:000000000001FDC6 F6 DB                                   neg     bl
.text:000000000001FDC8 1B C9                                   sbb     ecx, ecx
.text:000000000001FDCA 81 C1 55 01 00 00                       add     ecx, 155h
.text:000000000001FDD0 45 33 C9                                xor     r9d, r9d
.text:000000000001FDD3 45 8D 41 0C                             lea     r8d, [r9+0Ch]
.text:000000000001FDD7 48 8D 54 24 30                          lea     rdx, [rsp+48h+var_18]
.text:000000000001FDDC E8 27 09 01 00                          call    SendPacketToServer
.text:000000000001FDE1 48 83 C4 40                             add     rsp, 40h
.text:000000000001FDE5 5B                                      pop     rbx
.text:000000000001FDE6 C3                                      retn
.text:000000000001FDE6                         ; } // starts at 1FD84
.text:000000000001FDE6                         CheckVM         endp



.text:000000000001FDF0 48 89 5C 24 08                          mov     [rsp+arg_0], rbx
.text:000000000001FDF5 57                                      push    rdi
.text:000000000001FDF6 48 83 EC 50                             sub     rsp, 50h
.text:000000000001FDFA 83 64 24 20 00                          and     [rsp+58h+var_38], 0
.text:000000000001FDFF 33 D2                                   xor     edx, edx        ; Val
.text:000000000001FE01 48 8D 4C 24 24                          lea     rcx, [rsp+58h+Dst] ; Dst
.text:000000000001FE06 44 8D 42 24                             lea     r8d, [rdx+24h]  ; Size
.text:000000000001FE0A E8 11 72 01 00                          call    memset
.text:000000000001FE0F 45 0F 20 C3                             mov     r11, cr8
.text:000000000001FE13 B8 0F 00 00 00                          mov     eax, 0Fh
.text:000000000001FE18 44 0F 22 C0                             mov     cr8, rax
.text:000000000001FE1C 48 8B 7C 24 38                          mov     rdi, [rsp+58h+var_20]
.text:000000000001FE21 44 8D 48 55                             lea     r9d, [rax+55h]
.text:000000000001FE25 4D 8B D1                                mov     r10, r9
.text:000000000001FE28
.text:000000000001FE28                         loc_1FE28:                              ; CODE XREF: sub_1FDF0+70↓j
.text:000000000001FE28 0F 31                                   rdtsc
.text:000000000001FE2A 48 C1 E2 20                             shl     rdx, 20h
.text:000000000001FE2E 48 0B C2                                or      rax, rdx
.text:000000000001FE31 33 C9                                   xor     ecx, ecx
.text:000000000001FE33 4C 8B C0                                mov     r8, rax
.text:000000000001FE36 B8 01 00 00 00                          mov     eax, 1
.text:000000000001FE3B 0F A2                                   cpuid
.text:000000000001FE3D 89 44 24 20                             mov     [rsp+58h+var_38], eax
.text:000000000001FE41 89 5C 24 24                             mov     [rsp+58h+Dst], ebx
.text:000000000001FE45 89 4C 24 28                             mov     [rsp+58h+var_30], ecx
.text:000000000001FE49 89 54 24 2C                             mov     [rsp+58h+var_2C], edx
.text:000000000001FE4D 0F 31                                   rdtsc
.text:000000000001FE4F 48 C1 E2 20                             shl     rdx, 20h
.text:000000000001FE53 48 0B C2                                or      rax, rdx
.text:000000000001FE56 49 2B C0                                sub     rax, r8
.text:000000000001FE59 48 03 F8                                add     rdi, rax
.text:000000000001FE5C 49 83 EA 01                             sub     r10, 1
.text:000000000001FE60 75 C6                                   jnz     short loc_1FE28
.text:000000000001FE62 48 8B 5C 24 40                          mov     rbx, [rsp+58h+var_18]
.text:000000000001FE67 48 89 7C 24 38                          mov     [rsp+58h+var_20], rdi
.text:000000000001FE6C
.text:000000000001FE6C                         loc_1FE6C:                              ; CODE XREF: sub_1FDF0+9B↓j
.text:000000000001FE6C 0F 31                                   rdtsc
.text:000000000001FE6E 48 C1 E2 20                             shl     rdx, 20h
.text:000000000001FE72 48 0B C2                                or      rax, rdx
.text:000000000001FE75 48 8B C8                                mov     rcx, rax
.text:000000000001FE78 0F 31                                   rdtsc
.text:000000000001FE7A 48 C1 E2 20                             shl     rdx, 20h
.text:000000000001FE7E 48 0B C2                                or      rax, rdx
.text:000000000001FE81 48 2B C1                                sub     rax, rcx
.text:000000000001FE84 48 03 D8                                add     rbx, rax
.text:000000000001FE87 49 83 E9 01                             sub     r9, 1
.text:000000000001FE8B 75 DF                                   jnz     short loc_1FE6C
.text:000000000001FE8D 48 89 5C 24 40                          mov     [rsp+58h+var_18], rbx
.text:000000000001FE92 41 0F B6 CB                             movzx   ecx, r11b
.text:000000000001FE96 44 0F 22 C1                             mov     cr8, rcx
.text:000000000001FE9A 48 8D 0D 4F 73 01 00                    lea     rcx, qword_371F0
.text:000000000001FEA1 E9 B4 59 0A 00                          jmp     loc_C585A
```

`README.md`:

```md
# EasyAntiCheat-Src
 Leaked EasyAntiCheat.sys

```