Project Path: arc_gmh5225_FindFunc_ttzteu45

Source Tree:

```txt
arc_gmh5225_FindFunc_ttzteu45
├── README.md
├── findfunc
│   ├── advanced_copy.py
│   ├── backbone.py
│   ├── fftabs.py
│   ├── fftabs.ui
│   ├── findfunc_gui.py
│   ├── findfuncdialog.py
│   ├── findfuncdialog.ui
│   ├── matcher_ida.py
│   └── models.py
├── findfuncmain.py
└── img
    └── ffmain.png

```

`README.md`:

```md
# FindFunc: Advanced Filtering/Finding of Functions in IDA PRO


FindFunc is an IDA PRO plugin to find code functions that contain a certain assembly or byte pattern, reference a certain name or string, or conform to various other constraints. This is not a competitor to tools like Diaphora or BinNavi, but it is ideal to find a known function in a new binary for cases where classical bindiffing fails.


![ffmain](./img/ffmain.png)


## Filtering with Rules


The main functionality of FindFunc is letting the user specify a set of "Rules" or constraints that a code function in IDA PRO has to satisfy. FF will then find and list all functions that satisfy ALL rules (so currently all Rules are in an AND-conjunction). Exception: Rules can be "inverted" to be negative matches. Such rules thus conform to "AND NOT".

FF will schedule the rules in a smart order to minimize processing time.
Feature overview:

* Currently 6 Rules available, see below
* Code matching respects Addressing-Size-Prefix and Operand-Size-Prefix
* Aware of function chunks
* Smart scheduling of rules for performance
* Saving/Loading rules from/to file in simple ascii format
* Several independent Tabs for experimentation
* Copying rules between Tabs via clipboard (same format as file format)
* Advanced copying of instruction bytes (all, opcodes only, all except immediates)

Button "Search Functions" clears existing results and starts a fresh search,
"Refine Results" considers only results of the previous search.

### Advanced Binary Copying

A secondary feature of FF is the option to copy binary representation of instructions with the following options:

* copy all -> copy all bytes to the clipboard
* copy without immediates -> blank out (AA ?? BB) any immediate values in the instruction bytes
* opcode only -> will blank out everything except the actual opcode(s) of the instruction (and prefixes)

See "advanced copying" section below for details.
This feature nicely complements the Byte Pattern rule!




## Building and Installation

FindFunc is an IDA PRO python plugin without external package dependencies.
It can be installed by downloading the repository and copying file findfuncmain.py and folder findfunc to your IDA PRO plugin directory. No building is required.


Requirements: IDA PRO 7.x (7.6+) with python3 environment.
FindFunc is designed for x86/x64 architecture only.
It has been tested with IDA 7.6/7.7, python 3.9 and IDAPython 7.4.0 on Windows 10.




# Available Rules


Currently the following six rules are available. They are sorted here from heavy to light with regard to performance impact.
With large databases it is a good idea to first cut down the candidate-functions with a cheap rule, before doing heavy matching via e.g. Code Rules. FF will automatically schedule rules in a smart way.


### Code Pattern


Rule for filtering function based on them containing a given assembly code snippet.
This is NOT a text-search for IDAs textual disassembly representation, but rather performs advanced matching of the underlying instruction.
The snippet may contain many consecutive instructions, one per line. Function chunks are supported.
Supports special wildcard matching, in addition to literal assembly:

* "pass" -> matches any instruction with any operands
* "mov* any,any" -> matches instructions with mnemonic "mov*" (e.g. mov, movzx, ...)
                    and any two arguments.
* "mov eax, r32" -> matches any instruction with mnemonic "mov", first operand register eax and second operand any 32-bit register.
    * Analogue: r for any register, r8/r16/r32/r64 for register of a specific width, "imm" for any immediate
* "mov r64, imm" -> matches any move of a constant to a 64bit register
* "any r64,r64" -> matches any operation between two 64bit registers
* mov -> matches any instruction of mov mnemonic

more examples:

    mov r64, [r32 * 8 + 0x100]
    mov r, [r * 8 - 0x100]
    mov r64, [r32 * 8 + imm]
    pass
    mov r, word [eax + r32 * 8 - 0x100]
    any r64, r64
    push imm
    push any

**Gotchas:** Be careful when copying over assembly from IDA.
IDA mingles local variable names and other information into the instruction which leads to matching failure.
Also, labels are not supported ("call sub_123456").


Note that Code Patterns is the most expensive Rule, and if only Code Rules are present FF has no option but to disassemble the entire database. This can take up to several minutes for very large binaries. See notes on performance below.

### Immediate Value (Constant)

The function must contain the given immediate at least once in any position.
An immediate value is a value fixed in the binary representation of the instruction.
Examples for instructions matching immediate value 0x100:

    mov eax, 0x100
    mov eax, [0x100]
    and al, [eax + ebx*8 + 0x100]
    push 0x100


Note: IDA performs extensive matching of any size and any position of the immediate. If you know it to be of a specific width of 4 or 8 bytes, a byte pattern can be a little faster.

### Byte Pattern

The function must contain the given byte pattern at least once.
The pattern is of the same format as IDAs binary search, and thus supports wildcards - the perfect match for the advanced-copy feature!

Examples:

    11 22 33 44 aa bb cc
    11 22 33 ?? ?? bb cc -> ?? can be any byte

Note: Pattern matching is quiet fast and a good candidate to cut down matches quickly!

### String Reference

The function must reference the given string at least once.
The string is matched according to pythons 'fnmatch' module, and thus supports wildcard-like matching.
Matching is performed case-insensitive.
Strings of the following formats are considered: [idaapi.STRTYPE_C, idaapi.STRTYPE_C_16] (this can be changed in the Config class).

Examples:

* "TestString" -> function must reference the exact string (casing ignored) at least once
* "TestStr*" -> function must reference a string starting with 'TestStr (e.g. TestString, TestStrong) at least once (casing ignored)


Note: String matching is fast and a good choice to cut down candidates quickly!

### Name Reference

The function must reference the given name/label at least once.
The name/label is matched according to pythons 'fnmatch' module, and thus supports wildcard-like matching.
Matching is performed case-insensitive.

Examples:

* "memset" -> function must reference a location named "memset" at least once
* "mem*" -> function must reference a location starting with "mem" (memset, memcpy, memcmp) at least once


Note: Name matching is very fast and ideal to cut down candidates quickly!

### Function Size

The size of the function must be within the given limit: "min <= functionsize < max"
Data is entered as a string of the form "min,max".
The size of a function includes all of its chunks.


Note: Function size matching is very fast and ideal to cut down candidates quickly!





## Keyboard Shortcuts & GUI

For ease of use FF can be used via the following keyboard shortcuts:

* Ctrl+Alt+F -> launch/show TabWidget (main GUI)
* Ctrl+F -> start search with currently enabled rules
* Ctrl+C -> copy selected rules to clipboard
* Ctrl+V -> paste rules from clipboard into current tab (appends)
* Ctrl+S -> save selected rules to file
* Ctrl+L -> load selected rules from file (appends)
* Ctrl+A -> select all rules
* Del -> delete selected rules

Further GUI usage

* Rules can be edited by double-clicking the Data column
* Rules can be inverted (negative match) by double-clicking the invert-match column
* Rules can be enabled/disabled by double-clicking the enabled-column
* Sorting is supported both for Rule-List and Result-List
* Double-click Result item to jump to it in IDA
  * function name: jump to function start
  * any other column: jump to match of last matched rule
* Checkbox Profile: Outputs profiling information for the search
* Checkbox Debug: Dumps detailed debugging output for code rule matching - only use it if few functions make it to the code checking rule, otherwise it might take very long!




## Advanced Binary Copy

Frequently we want to search for binary patterns of assembly, but without hardcoded  addresses and values (immediates),
or even only the actual opcodes of the instruction. FindFunc makes this easy by adding three copy options to the disassembly-popupmenu:


### Copy all bytes

Copies all instruction bytes as hex-string to clipboard, for use in a Byte-Pattern-Rule (or IDAs binary search).

    B8 44332211      mov eax,11223344
    68 00000001      push 1000000
    66:894424 70     mov word ptr ss:[esp+70],ax

will be copied as

    b8 44 33 22 11 68 00 00 00 01 66 89 44 24 70


### Copy only non-immediate bytes

Copies instruction bytes for given instruction, masking out any immediate values.
Example:

    B8 44332211      mov eax,11223344
    68 00000001      push 1000000
    66:894424 70     mov word ptr ss:[esp+70],ax

will be copied as

    b8 ?? ?? ?? ?? 68 ?? ?? ?? ?? 66 89 44 24 ??
    

### Copy only opcodes

Copy all instruction bytes as hex-string to clipboard, masking out any bytes that are not the actual opcode (including sib, modrm, but keeping legacy prefixes).

    B8 44332211      mov eax,11223344
    68 00000001      push 1000000
    66:894424 70     mov word ptr ss:[esp+70],ax

will be copied as

    b8 ?? ?? ?? ?? 68 ?? ?? ?? ?? 66 89 ?? ?? ??

Note: This is a "best effort" using IDAs API, thus there may be few cases where it only works partially.
For a 100% correct solution we would have to ship a dedicated x86 disasm library.

Similar results can be achieved with Code Pattern Rules, but this might be faster,
both for user interaction and the actual search.

### Copy disasm

Copies selected disassembly to clipboard, as it appears in IDA.


## Performance

A brief word on performance:

1. name, string, funcsize are almost free in all cases
2. bytepattern is almost free for patterns length > 2
3. immediate is difficult:
    We can use idaapi search, or we can disassemble the entire database and search ourselves - we may have to do this anyways if we are looking for code patterns.
    BUT: scanning for code patterns is in fact much cheaper than scanning for an immediate.
    An api-search for all matches is relatively costly - about 1/8 as costly as disassembling the entire database.
    So: If we cut down matches with cheap rules first, then we greatly profit from disassembling the remaining functions and looking for the immediate ourselves, especially if a code-rule is present anyways.
    However: If no cheap options exist and we have to disassemble large parts of the database anyways (due to presence of code pattern rules), then using one immediate rule as a pre-filter can greatly pay off.
    api-searching ONE immediate is roughly equivalent to 1/8 searching for any number of code-pattern rules - although this also depends on many different factors...
4. code pattern are the most expensive by far, however checking one pattern vs checking many is very similar.




### Todo (unordered):

* fix IDA docking
* jcc pseudo-mnemonic
* Allow named locations in CodeRules ('call memset')
* 'ignore all following operands' option
* Rule for parameters to API calls inside function
* Rule for parent/callsite/child function requirements
* Rule for function parameters
* Regex-rule
* string/name: casing option
* automatically convert immediate rules to byte pattern if applicable?
* settings: case sensitivity, string types, range, ...
* Hexray rules?
* persist state across IDA restarts
* OR combination of rules
* Pythonification of code ;)
* Parallelization
* Automatic generation of rules to identify a function?



```

`findfunc/advanced_copy.py`:

```py
inida = True
try:
    import idc
    import idaapi
    import idautils
    import ida_bytes
    import ida_ua
    import ida_pro
except:
    inida = False

from PyQt5.Qt import QApplication

### config

# print the result of the copy operation to IDA log
logresult = True


### helper


def copy_to_clip(data):
    QApplication.clipboard().setText(data)


is64 = idaapi.get_inf_structure().is_64bit()

### copy all


def copy_all_bytes():
    """
    Copy all instruction bytes as hex string to clipboard
    e.g. 11 22 33 44
    """
    start = idc.read_selection_start()
    end = idc.read_selection_end()
    if idaapi.BADADDR in (start, end):
        ea = idc.here()
        start = idaapi.get_item_head(ea)
        end = idaapi.get_item_end(ea)
    data = idc.get_bytes(start, end - start).hex()
    data = ' '.join([data[i:i + 2] for i in range(0, len(data), 2)])
    copy_to_clip(data)
    if logresult:
        print("copy_all_bytes:     ", data)


### copy no-imm


def int_as_bytes(integer, size):
    # print(ida_pro.__MF__)  # 0 = little endian, 1 = big endian or info.is_be()
    # print(integer, hex(integer), size)
    try:
        return integer.to_bytes(size, byteorder='little', signed=integer < 0)
    except OverflowError:
        return None


def is_neg(addr):
    if is64:
        return addr & 0x8000000000000000
    else:
        return addr & 0x80000000


masks = [(8, 0), (4, 0xffffffff00000000), (2, 0xffffffffffff0000), (1, 0xffffffffffffff00)]


def get_bytes_without_imm(ins) -> str:
    """
    Copies instruction bytes for given instruction, masking out
    any immediate values.
    This is a "best effort" with the IDA api, and there may be a few cases
    where it only works partially.
    For a 100% correct solution we would have to ship our own disasm library.
    """
    bytedata = ida_bytes.get_bytes(ins.ea, ins.size)
    orgbytelen = len(bytedata)
    # print("inbytes: ", bytedata)
    for op in reversed(ins.ops):
        if op.type == idaapi.o_void:
            continue
        if op.type in (idc.o_phrase, idc.o_reg):
            # have no immediatae (exception: some strange encodings where it is zero)
            continue
        if op.type in (idc.o_near, idc.o_far):
            size = ida_ua.get_dtype_size(op.dtype)
            asbyt = int_as_bytes(op.addr, size)
            if asbyt and bytedata.endswith(asbyt):
                bytedata = bytedata[:-size]
                continue
            # only x64: rip-rel
            asbyt = int_as_bytes(op.addr - ins.ea - ins.size, size)
            if asbyt and bytedata.endswith(asbyt):
                bytedata = bytedata[:-size]
                continue
        if op.type == idaapi.o_imm:
            size = ida_ua.get_dtype_size(op.dtype)
            asbyt = int_as_bytes(op.value, size)
            if asbyt and bytedata.endswith(asbyt):
                bytedata = bytedata[:-size]
                continue
            # dtype doesnt indicate the imm size, but rather destination size
            # usually equivalent, but not always, e.g. add r64, imm
            for size, mask in masks:
                cur_val = op.value & ~mask
                asbyt = int_as_bytes(cur_val, size)
                if asbyt and bytedata.endswith(asbyt):
                    bytedata = bytedata[:-size]
                    break
        if op.type in (idaapi.o_mem, idc.o_displ):
            for size, mask in masks:
                cur_adr = op.addr & ~mask
                asbyt = int_as_bytes(cur_adr, size)
                if asbyt and bytedata.endswith(asbyt):
                    bytedata = bytedata[:-size]
                    break
                # only x64: rip-rel
                asbyt = int_as_bytes(op.addr - ins.ea - ins.size, size)
                if asbyt and bytedata.endswith(asbyt):
                    bytedata = bytedata[:-size]
                    break

    result = ""
    for x in bytedata:
        result += " {:02x}".format(x)
    for x in range(orgbytelen - len(bytedata)):
        result = result + " ??"
    # print("result: ", result)
    return result.strip()


def copy_bytes_no_imm():
    """
    Copy all instruction bytes as hex string to clipboard, masking out immediate values
    e.g. 11 22 ?? ??
    """
    start = idc.read_selection_start()
    end = idc.read_selection_end()
    if idaapi.BADADDR in (start, end):
        ea = idc.here()
        start = idaapi.get_item_head(ea)
        end = idaapi.get_item_end(ea)
    result = ""
    processed = 0
    while start + processed < end:
        ins = idautils.DecodeInstruction(start + processed)
        if not ins:
            processed += 1
            continue
        processed += ins.size
        result += " " + get_bytes_without_imm(ins)
    if logresult:
        print("copy_bytes_no_imm: ", result)
    copy_to_clip(result)


###
### copy opcodes

class bytegetter:
    """
    Helper that returns a byte of the given instruction on
    every self.getb() call, or None if no more bytes
    """
    def __init__(self, ins):
        self.done = 0
        self.bytedata = ida_bytes.get_bytes(ins.ea, ins.size)

    def getb(self):
        if self.done < len(self.bytedata):
            self.done = self.done + 1
            return self.bytedata[self.done - 1]
        return None


legacyprefix = {0xF0, 0xF2, 0xF3, 0x2E, 0x36, 0x3E, 0x26, 0x64, 0x65, 0x2E, 0x3E, 0x66, 0x67}


def getopc(ins):
    """
    Returns instruction bytes for given instruction, masking out
    any bytes that are NOT the opcodes of the instruction.
    This is a "best effort" without a dedicated disasm library, and there may be few cases
    where it only works partially.
    For a 100% correct solution we would have to ship our own disasm library.
    """
    res = []
    unk = "??"
    getter = bytegetter(ins)

    x = getter.getb()
    while x in legacyprefix:
        res += [x]  # legacy prefix
        x = getter.getb()

    while x and (x & 0xF0) == 0x40:
        res += [unk]  # REX prefix
        x = getter.getb()

    if x == 0x0F:  # multibyte opcode
        y = getter.getb()
        if y == 0x38 or y == 0x3A:
            res += [x, y, getter.getb()]
            return res
        if y == 0x0F:  # 3Dnow!
            res += [x, y]  # + last byte is (ab)used as an opcode...
            return res
        res += [x, y]
        return res

    # some say these are only for x64...
    if x == 0x62:  # EVEX: 4 + 1 opcode
        getter.getb()
        getter.getb()
        getter.getb()
        res += [x, unk, unk, unk, getter.getb()]
        return res
    if x == 0xC4:  # 3 byte evex
        getter.getb()
        getter.getb()
        res += [x, unk, unk, getter.getb()]
        return res
    if x == 0xC5:  # 2 byte evex
        getter.getb()
        res += [x, unk, getter.getb()]
        return res
    if x == 0x8F:  # 3 byte xop
        getter.getb()
        getter.getb()
        res += [x, unk, unk, getter.getb()]
        return res

    res += [x]  # normal opcode
    return res


def get_only_opcodes(ins) -> str:
    """
    Convert getopc(ins) result to string
    """
    res = getopc(ins)
    result = ""
    for x in res:
        if x is None:
            continue
        elif x == "??":
            result += " ??"
        else:
            result += " {:02x}".format(x)
    for x in range(ins.size - len(res)):
        result += " ??"
    # print("fin: ", result)
    return result.strip()


def copy_only_opcodes():
    """
    Copy all instruction bytes as hex string to clipboard,
    masking out any bytes that are not the actual opcode
    e.g. 11 ?? ?? ??
    """
    start = idc.read_selection_start()
    end = idc.read_selection_end()
    if idaapi.BADADDR in (start, end):
        ea = idc.here()
        start = idaapi.get_item_head(ea)
        end = idaapi.get_item_end(ea)
    result = ""
    processed = 0
    while start + processed < end:
        ins = idautils.DecodeInstruction(start + processed)
        if not ins:
            processed += 1
            continue
        processed += ins.size
        result += " " + get_only_opcodes(ins)
    if logresult:
        print("copy_only_opcodes: ", result)
    copy_to_clip(result)


def copy_only_disasm():
    """
    Copy all instructions as diassembly as provided by IDA
    """
    start = idc.read_selection_start()
    end = idc.read_selection_end()
    if idaapi.BADADDR in (start, end):
        ea = idc.here()
        start = idaapi.get_item_head(ea)
        end = idaapi.get_item_end(ea)
    result = ""
    processed = 0
    while start + processed < end:
        ins = idc.GetDisasm(start + processed)
        size = idc.next_head(start + processed) - (start + processed)
        if not size:
            size = 1
        processed += size
        if ins:
            result += ins + "\n"
    if logresult:
        print("copy_only_disasm: ", result)
    copy_to_clip(result)

###

# https://wiki.osdev.org/X86-64_Instruction_Encoding#VEX.2FXOP_opcodes
# https://github.com/capstone-engine/capstone/blob/master/arch/X86/X86DisassemblerDecoder.c#L749

```

`findfunc/backbone.py`:

```py
import enum
import fnmatch
from typing import List


class InstrWildcardOp(object):
    """
    Custom format to hold information about the operand of an instruction.
    This is used both for dissassembly and Code Rules entered by the user.
    """
    def __init__(self):
        self.basereg = None
        self.indexreg = None
        self.scale = 1
        self.displ = 0
        self.deref = False
        self.size = 0

    def __str__(self):
        string = f"{self.basereg} + {self.indexreg} * {self.scale} + {self.displ} (@{self.size})"
        if self.deref:
            return "[" + string + "]"
        return string


class InstrWildcard(object):
    """
    Custom format to hold information about an instruction.
    This is used both for dissassembly and Code Rules entered by the user.
    """
    def __init__(self):
        self.va = 0
        self.mmn = ""  # can be "any" to match all
        self.ops = []

    def __str__(self):
        r = f"[{hex(self.va)}]: {self.mmn}"
        for op in self.ops:
            r += " " + str(op) + ","
        return r

    def __eq__(self, other):
        """
        Dont compare them directly, as matching is much more complex than that.
        See matcher_ida.py
        """
        raise NotImplementedError("Dont compmare instructions directly.")
        return NotImplemented

    @staticmethod
    def is_int(var) -> bool:
        """
        Check if string is a valid int.
        Can be "imm" or hex value or decimal value.
        :param var: string to check
        :return: integer or "imm"
        """
        return InstrWildcard.parse_int(var) is not None

    @staticmethod
    def parse_int(var):
        """
        Convert string to int.
        Can be "imm" or hex value or decimal value.
        :param var: string to convert
        :return: int or "imm"
        """
        if var == "imm":
            return var
        try:
            if str(var).endswith('h'):
                return int(str(var)[:-1], 16)
            r = int(var)
        except ValueError:
            try:
                r = int(var, 16)
            except ValueError:
                return None
        return r

    @staticmethod
    def parse_from_str(ins: str):
        """
        Parse a user-entered Instruction string (as part of a Code Rule).
        May throw exceptions on parsing error!
        :param ins: instruction string
        :return: converted instruction
        """
        result = InstrWildcard()
        idx = ins.find(' ')
        if idx == -1:  # no args
            result.mmn = ins
            return result
        result.mmn = ins[0:idx]  # doesnt support prefixes
        result.mmn = "".join(result.mmn.split())  # remove all whitespace
        ins = ins[idx:]
        ins = "".join(ins.split())  # remove all whitespace
        # [reg + imm], [reg], [imm], [reg + reg * 1 + 555]
        for o in ins.split(','):
            op = InstrWildcardOp()
            if '[' in o:
                if "qword" in o:
                    op.size = 8
                    o = o.replace("qwordptr", "").replace("qword", "")
                elif "dword" in o:
                    op.size = 4
                    o = o.replace("dwordptr", "").replace("dword", "")
                elif "word" in o:
                    op.size = 2
                    o = o.replace("wordptr", "").replace("word", "")
                elif "byte" in o:
                    op.size = 1
                    o = o.replace("byteptr", "").replace("byte", "")
                else:
                    op.size = None  # determining right size is very complex (movzx, etc.)
                op.deref = True
                o = o.replace('[', '').replace(']', '')
            isneg = o.find('-') != -1
            opdata = o.replace('+', ' ').replace('-', ' ').replace('*', ' ')
            opdata = opdata.split()
            if len(opdata) == 0:
                pass
            elif len(opdata) == 1:  # reg,c,[reg],[c]
                if InstrWildcard.is_int(opdata[0]):
                    op.displ = InstrWildcard.parse_int(opdata[0])
                else:
                    op.basereg = opdata[0]
            elif len(opdata) == 2:  # [reg+reg],[reg+c]
                op.basereg = opdata[0]  # always reg
                if InstrWildcard.is_int(opdata[1]):
                    op.displ = InstrWildcard.parse_int(opdata[1])
                else:
                    op.indexreg = opdata[1]
            elif len(opdata) == 3:  # [reg+reg*c]
                op.basereg = opdata[0]  # always reg
                op.indexreg = opdata[1]  # always reg
                op.scale = InstrWildcard.parse_int(opdata[2])  # always scale
            elif len(opdata) == 4:  # [reg+reg*c+c]
                op.basereg = opdata[0]  # always reg
                op.indexreg = opdata[1]  # always reg
                op.scale = InstrWildcard.parse_int(opdata[2])  # always scale
                op.displ = InstrWildcard.parse_int(opdata[3])  # always displ
            if isneg:
                op.displ = op.displ * -1
                # we may need to extend some value here if we are not neg... todo alighn with ida.decode
            result.ops.append(op)
        return result


class RuleType(enum.Enum):
    unk = "Invalid"
    imm = "Immediate"
    str = "StringRef"
    name = "NameRef"
    pattern = "BytePattern"
    code = "CodePattern"
    fsize = "FunctionSize"


class Rule(object):
    """
    Base class for Rules.
    """
    def __init__(self, typ: RuleType):
        self.typ = typ
        self.enabled = True
        self.inverted = False

    def __str__(self):
        return f"Rule<{self.typ}>"

    def get_data(self):
        pass

    def set_data(self, data):
        pass

    def is_editable(self) -> bool:
        return True


class RuleFuncSize(Rule):
    """
    Rule for filtering by function size.
    examples:
    0,999  ->  functions smaller than 999 bytes
    500,1000 -> functions 500 bytes or larger and smaller than 1000 bytes
    """
    maxmax = 999999

    def __init__(self):
        super().__init__(RuleType.fsize)
        self.min = 0
        self.max = self.maxmax

    def __repr__(self):
        return f"RuleFuncSize({self.min},{self.max})"

    def get_data(self):
        return f"{self.min} <= x <= {self.max}"

    def set_data(self, data: str):
        """
        Parse user data in form "x,y" where x is minimum function size and
        y maximum.
        The rule will match any function whose size is x <= size <= y.
        :param data: input data
        :return: Nothing
        """
        if data.endswith(","):
            data += str(self.maxmax)
        data = data.replace(",", " ")
        data = data.split()
        if len(data) == 2:
            mmin = InstrWildcard.parse_int(data[0])
            mmax = InstrWildcard.parse_int(data[1])
            self.min = mmin
            self.max = mmax

    def checksize(self, size: int) -> bool:
        """
        Perform function size check
        :param size: size of functio to check
        :return: True if satisfied, False otherwise
        """
        return self.min <= size <= self.max


class RuleImmediate(Rule):
    """
    Rule for filtering function based on them referencing a given immediate value.
    The value may be referenced anywhere in the function.
    """
    def __init__(self, imm):
        super().__init__(RuleType.imm)
        self.imm = InstrWildcard.parse_int(imm)

    def __repr__(self):
        return f"RuleImmediate({self.imm})"

    def get_data(self):
        return hex(self.imm)

    def set_data(self, data):
        if isinstance(data, int):
            self.imm = data
        else:
            self.imm = InstrWildcard.parse_int(data)


class RuleStrRef(Rule):
    """
    Rule for filtering function based on them referencing a given string.
    The string may be referenced anywhere in the function.
    Supports wildcard matching by fnmatch. See fnmatch for details.
    examples:
    Success
    Succ*
    """
    def __init__(self, targetstr: str):
        super().__init__(RuleType.str)
        self.str = targetstr
        self.refs = []

    def __repr__(self):
        return f"RuleStrRef(\"{self.str}\")"

    def matches(self, s: str) -> bool:
        return fnmatch.fnmatch(s, self.str)

    def get_data(self):
        return self.str

    def set_data(self, data):
        self.str = str(data)


class RuleNameRef(Rule):
    """
    Rule for filtering function based on them referencing a given name/label.
    The name/label may be referenced anywhere in the function.
    Supports wildcard matching by fnmatch. See fnmatch for details.
    examples:
    sub_123456
    sub_123*
    """
    def __init__(self, name):
        super().__init__(RuleType.name)
        self.name = name
        self.refs = []

    def __repr__(self):
        return f"RuleNameRef(\"{self.name}\")"

    def matches(self, s: str) -> bool:
        return fnmatch.fnmatch(s, self.name)

    def get_data(self):
        return self.name

    def set_data(self, data):
        self.name = str(data)


class RuleBytePattern(Rule):
    """
    Rule for filtering function based on them containing a given byte pattern.
    Supports wildcard matching by IDAs binary search. See IDA for details.
    examples:
    11 22 ff cc
    11 ?? ?? cc
    """
    def __init__(self, pattern):
        super().__init__(RuleType.pattern)
        self.pattern = pattern
        self.patterncompiled = None

    def __repr__(self):
        return f"RuleBytePattern(\"{self.pattern}\")"

    @staticmethod
    def is_raw_pattern(pattern: str) -> bool:
        try:
            pattern = pattern.replace(" ", "").replace("??", "")
            return len(bytes.fromhex(pattern)) > 1 and len(pattern) > 2
        except ValueError:
            return False

    def get_data(self):
        return self.pattern

    def set_data(self, data):
        self.pattern = str(data)


class RuleCode(Rule):
    """
    Rule for filtering function based on them containing a given code snippet.
    Supports special wildlcard matching:

    "pass" -> matches any instruction with any operands
    "mov* any,any" -> matches instructions with mmn "mov*" (e.g. mov, movzx, ...)
                        and any two arguments.
    "mov eax, r32" -> matches any instruction with mmn "mov", first operand register eax
                        and second operand any 32-bit register.
                        Analogue: r for any register, r8/r16/r32/r64
    "mov r64, imm"   -> matches any move of a constant to a 64bit register
    more examples:
    mov r64, [r32 * 8 + 0x100]
    mov r64, [r32 * 8 - 0x100]
    mov r64, [r32 * 8 + imm]
    mov r, [r32 + r32 * 8 - 0x100]
    push imm
    push r
    """
    def __init__(self, instrlist):
        super().__init__(RuleType.code)
        self.instr_string = []
        self.instr = []
        self.set_data(instrlist)
        self.current = 0

    def __repr__(self):
        return f"RuleCode({repr(self.instr_string)})"

    def get_data(self):
        return str(self.instr_string)

    def set_data(self, data):
        if not data:
            return
        if type(data) != list:
            data = [data]
        data = [x.strip() for x in data if x.strip()]
        instr = [InstrWildcard.parse_from_str(x) for x in data]
        self.instr = instr
        self.instr_string = data
        self.clearcurrent()

    def is_editable(self) -> bool:
        return False

    def advance(self):
        self.current = self.current + 1

    def clearcurrent(self):
        self.current = 0

    def curinstr(self) -> InstrWildcard:
        return self.instr[self.current]

    def is_satisfied(self) -> bool:
        return len(self.instr) == self.current


def to_clipboard_string(data: List[Rule]) -> str:
    """
    Converts a list of rules to string for copying
    :param data: list of rules
    :return: list of rules as string
    """
    ret = ""
    for r in data:
        if isinstance(r, RuleFuncSize):
            ret += f"RuleFuncSize {r.enabled} {r.inverted} {r.min} {r.max}" + "\n"
        elif isinstance(r, RuleImmediate):
            ret += f"RuleImmediate {r.enabled} {r.inverted} {r.imm}" + "\n"
        elif isinstance(r, RuleStrRef):
            ret += f"RuleStrRef {r.enabled} {r.inverted} {r.str}" + "\n"
        elif isinstance(r, RuleNameRef):
            ret += f"RuleNameRef {r.enabled} {r.inverted} {r.name}" + "\n"
        elif isinstance(r, RuleBytePattern):
            ret += f"RuleBytePattern {r.enabled} {r.inverted} {r.pattern}" + "\n"
        elif isinstance(r, RuleCode):
            ret += f"RuleCode {r.enabled} {r.inverted} {';;'.join(r.instr_string)}" + "\n"
    return ret


def from_clipboard_string(data: str) -> List[Rule]:
    """
    Converts a string to a list of rules
    :param data: list of rules as string
    :return: string as list of rules
    """
    # allow pasting hexstring directly
    if RuleBytePattern.is_raw_pattern(data):
        return [RuleBytePattern(data)]
    ret = []
    for string in data.split("\n"):
        tokens = string.split(" ")[:3]  # 3 -> RuleName enabled inverted
        if len(tokens) != 3:
            continue
        rulename = tokens[0]
        enabled = tokens[1].lower() == "true"
        inverted = tokens[2].lower() == "true"
        string = string[len(" ".join(tokens)) + 1:]
        rule = None
        if rulename == "RuleFuncSize":
            rule = RuleFuncSize()
            rule.set_data(string)
        elif rulename == "RuleImmediate":
            rule = RuleImmediate(string)
        elif rulename == "RuleStrRef":
            rule = RuleStrRef(string)
        elif rulename == "RuleNameRef":
            rule = RuleNameRef(string)
        elif rulename == "RuleBytePattern":
            rule = RuleBytePattern(string)
        elif rulename == "RuleCode":
            instructions = string.split(";;")
            rule = RuleCode(instructions)
        if rule:
            rule.enabled = enabled
            rule.inverted = inverted
            ret.append(rule)
    return ret

```

`findfunc/fftabs.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'fftabs.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_fftabs(object):
    def setupUi(self, fftabs):
        fftabs.setObjectName("fftabs")
        fftabs.resize(1015, 630)
        self.verticalLayout = QtWidgets.QVBoxLayout(fftabs)
        self.verticalLayout.setObjectName("verticalLayout")
        self.tabWidget = QtWidgets.QTabWidget(fftabs)
        self.tabWidget.setTabsClosable(True)
        self.tabWidget.setMovable(True)
        self.tabWidget.setObjectName("tabWidget")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.tabWidget.addTab(self.tab, "")
        self.verticalLayout.addWidget(self.tabWidget)
        self.linklabel = QtWidgets.QLabel(fftabs)
        self.linklabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.linklabel.setOpenExternalLinks(True)
        self.linklabel.setObjectName("linklabel")
        self.verticalLayout.addWidget(self.linklabel)

        self.retranslateUi(fftabs)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(fftabs)

    def retranslateUi(self, fftabs):
        _translate = QtCore.QCoreApplication.translate
        fftabs.setWindowTitle(_translate("fftabs", "FindFunc"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("fftabs", "Tab 1"))
        self.linklabel.setText(_translate("fftabs", "ff"))

```

`findfunc/fftabs.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>fftabs</class>
 <widget class="QWidget" name="fftabs">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1015</width>
    <height>630</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>FindFunc</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QTabWidget" name="tabWidget">
     <property name="currentIndex">
      <number>0</number>
     </property>
     <property name="tabsClosable">
      <bool>true</bool>
     </property>
     <property name="movable">
      <bool>true</bool>
     </property>
     <widget class="QWidget" name="tab">
      <attribute name="title">
       <string>Tab 1</string>
      </attribute>
     </widget>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="linklabel">
     <property name="text">
      <string>ff</string>
     </property>
     <property name="alignment">
      <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
     </property>
     <property name="openExternalLinks">
      <bool>true</bool>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`findfunc/findfunc_gui.py`:

```py
import pstats
import time
import pickle
import cProfile
import io

from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QWidget, QMessageBox, QLineEdit, QApplication, QTabBar, QMenu, QFileDialog
from PyQt5.QtCore import Qt, QEvent
from PyQt5.QtGui import QCursor, QKeySequence

from findfunc.findfuncdialog import Ui_FindFunc
from findfunc.fftabs import Ui_fftabs
from findfunc.backbone import *
from findfunc.models import RuleModel, ResultModel
import findfunc.matcher_ida

### config
# use pickle format for saving rules rater than text
use_pickle_ff = False

inida = True
try:
    import idaapi
except:
    inida = False


class FindFuncTab(QWidget):
    """
    FindFunc widget, which represents one Tab.
    Features the rule table, result table and the buttons.
    """
    def __init__(self):
        super().__init__()
        self.ui = Ui_FindFunc()
        self.ui.setupUi(self)
        # self.ui.splitter.setSizes([])
        # self.ui.splitter.setStretchFactor(0, 1)
        # self.ui.splitter.setStretchFactor(1, 1)
        # self.ui.tableresults.setBaseSize(150,150)
        self.matcher = findfunc.matcher_ida.MatcherIda()
        self.model = RuleModel()
        self.resultmodel = ResultModel()
        # self.resultmodel.mydata = [ResultModel.Result(0x00000001810FD8CC, 3, "sub_3948394"), ResultModel.Result(0x00000001810FD8CC, 2, ""), ResultModel.Result(1, 2, "")]
        self.ui.tableview.setModel(self.model)
        self.ui.tableresults.setModel(self.resultmodel)
        self.ui.tableview.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
        self.ui.tableresults.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
        self.ui.tableresults.resizeColumnsToContents()
        self.ui.tableresults.horizontalHeader().setStretchLastSection(True)
        self.ui.tableresults.setAlternatingRowColors(True)
        # signals
        self.ui.tableview.doubleClicked.connect(self.tableRulesDoubleClick)
        self.ui.tableresults.doubleClicked.connect(self.resultDoubleClick)
        self.ui.btnaddimm.clicked.connect(self.addimmrule)
        self.ui.btnaddstr.clicked.connect(self.addstrrule)
        self.ui.btnaddname.clicked.connect(self.addnamerule)
        self.ui.btnaddpattern.clicked.connect(self.addbytepatternrule)
        self.ui.btnaddcode.clicked.connect(self.addcoderule)
        self.ui.btnfuncsize.clicked.connect(self.addfsizerule)
        self.ui.btnsearch.clicked.connect(self.dosearchclicked)
        self.ui.btnrefine.clicked.connect(self.dorefineclicked)
        # enable sorting
        self.ui.tableview.setSortingEnabled(True)
        self.ui.tableresults.setSortingEnabled(True)
        # menu init
        self.ui.tableview.setContextMenuPolicy(Qt.CustomContextMenu)
        self.ui.tableview.customContextMenuRequested.connect(self.reqrulemenu)
        self.ui.tableresults.setContextMenuPolicy(Qt.CustomContextMenu)
        self.ui.tableresults.customContextMenuRequested.connect(self.reqresultmenu)
        # main menu
        self.menu = QMenu('mainmenu', self.ui.tableview)
        self.menu.addAction("add imm", self.addimmrule)
        self.menu.addAction("add function size", self.addfsizerule)
        self.menu.addAction("add name ref", self.addnamerule)
        self.menu.addAction("add string ref", self.addstrrule)
        self.menu.addAction("add byte pattern", self.addbytepatternrule)
        self.menu.addAction("add code pattern", self.addcoderule)
        self.menu.addSeparator()
        act = self.menu.addAction("delete selection", self.delselrules, "del")
        self.ui.tableview.addAction(act)
        act = self.menu.addAction("copy", self.copyselrules, "ctrl+c")
        self.ui.tableview.addAction(act)
        act = self.menu.addAction("paste", self.pasteselrules, "ctrl+v")
        self.ui.tableview.addAction(act)
        self.menu.addSeparator()
        act = self.menu.addAction("save selected rules to file", self.saveselrules, "ctrl+s")
        self.ui.tableview.addAction(act)
        act = self.menu.addAction("add rules from file", self.loadselrules, "ctrl+l")
        self.ui.tableview.addAction(act)
        # result menu
        self.resmenu = QMenu('resmenu', self.ui.tableresults)
        act = self.resmenu.addAction("copy addresses", self.copyresults, "ctrl+c")
        self.ui.tableresults.addAction(act)
        self.resmenu.addAction("clear", self.clearresults)
        # menu end
        # add shortcut for search
        act = QtWidgets.QAction("find", self)
        act.setShortcut("ctrl+f")
        act.triggered.connect(self.dosearchclicked)
        self.ui.tableview.addAction(act)
        # event filters, see self.eventFilter()
        self.ui.tableview.installEventFilter(self)
        self.ui.tableresults.installEventFilter(self)
        self.show()

    def eventFilter(self, o, e):
        """
        IDA is doing funky stuff with event interception themselves,
        so we have to help out a little to make our shortcuts work.
        """
        if e.type() == QEvent.ShortcutOverride:
            if o is self.ui.tableview:
                # print(e.modifiers(), e.key(), e.text(), str(e.type()), e.matches(QKeySequence.Copy))
                e.accept()
                for a in self.ui.tableview.actions():
                    if a.shortcut() == QKeySequence(e.key() | int(e.modifiers())):
                        a.trigger()
                return True
            if o is self.ui.tableresults:
                e.accept()
                for a in self.ui.tableresults.actions():
                    if a.shortcut() == QKeySequence(e.key() | int(e.modifiers())):
                        a.trigger()
                return True
        if e.type() == QEvent.KeyPress:
            if o is self.ui.tableview:
                for a in self.ui.tableview.actions():
                    if a.shortcut() == QKeySequence(e.key() | int(e.modifiers())):
                        e.accept()
                        return True
            if o is self.ui.tableresults:
                e.accept()
                for a in self.ui.tableresults.actions():
                    if a.shortcut() == QKeySequence(e.key() | int(e.modifiers())):
                        e.accept()
                        return True
        return False

    def reqrulemenu(self):
        """
        show rule popup menu
        """
        self.menu.popup(QCursor.pos())

    def reqresultmenu(self):
        """
        show result popup menu
        """
        self.resmenu.popup(QCursor.pos())

    def clearresults(self):
        """
        clear result table
        """
        self.resultmodel.clear()

    def copyresults(self):
        """
        copy result VA as hex to clipboard
        """
        if self.ui.tableresults.selectionModel().hasSelection():
            rows = [index.row() for index in self.ui.tableresults.selectionModel().selectedRows()]
            data = [hex(self.resultmodel.mydata[x].va) for x in rows]
            string = "\n".join(data)
            if string:
                QApplication.instance().clipboard().setText(string)

    def addimmrule(self):
        data, succ = QtWidgets.QInputDialog.getText(self, 'Get Immediate',
                                                    'Function must reference immediate (in hex):', QLineEdit.Normal,
                                                    '0x100')
        if not succ:
            return False
        return self.__adddata(RuleImmediate(0), data)

    def addfsizerule(self):
        data, succ = QtWidgets.QInputDialog.getText(self, 'Get Function Size',
                                                    'Function size constraint in format "min,max" e.g. "10,20":',
                                                    QLineEdit.Normal, '10,0x20')
        if not succ:
            return False
        return self.__adddata(RuleFuncSize(), data)

    def addstrrule(self):
        data, succ = QtWidgets.QInputDialog.getText(self, 'Get String',
                                                    'Function must reference string (wildcard supported):',
                                                    QLineEdit.Normal, 'SomeClass::*')
        if not succ:
            return False
        return self.__adddata(RuleStrRef(""), data)

    def addnamerule(self):
        data, succ = QtWidgets.QInputDialog.getText(self, 'Get Name',
                                                    'Function must reference Name/Label (wildcard supported):',
                                                    QLineEdit.Normal, '_SomeNameLabel_*')
        if not succ:
            return False
        return self.__adddata(RuleNameRef(""), data)

    def addbytepatternrule(self):
        data, succ = QtWidgets.QInputDialog.getMultiLineText(self, 'Get Byte Pattern',
                                                             'Function must contain Byte Pattern (supports 11 ?? 22):',
                                                             '11 ?? 22')
        if not succ:
            return False
        return self.__adddata(RuleBytePattern(""), data)

    def addcoderule(self):
        example = "mov eax,imm\nmov r32, 0x100\npass\nmov r, r32\nmov* r64, any\nany eax,eax"
        data, succ = QtWidgets.QInputDialog.getMultiLineText(self, 'Get Code Pattern',
                                                        'Function must contain Code Pattern (See help for details):',
                                                         example)
        if not succ:
            return False
        return self.__adddata(RuleCode(""), data.split('\n'))

    def __adddata(self, rule: Rule, data):
        """
        helper
        """
        try:
            rule.set_data(data)
            self.model.add_item(rule)
        except Exception as ex:
            QMessageBox.warning(None, "Error setting value", str(ex))
            return False
        return True

    def resultDoubleClick(self, index):
        """
        result row doublelicked -> goto va
        """
        if not index.isValid():
            return None
        col = index.column()
        row = index.row()
        mydata = index.model().mydata
        if row >= len(mydata):
            return
        # jump to function start if function-name column clicked, else to last match
        va = mydata[row].va if ResultModel.col_label == col else mydata[row].lastmatch
        if not va:
            va = mydata[row].va
        findfunc.matcher_ida.gui_jump_to_va(va)

    def tableRulesDoubleClick(self, index):
        """
        Rule table double clicked: enabled/disabled, invert match or edit data
        """
        if not index.isValid():
            return None
        try:
            col = index.column()
            row = index.row()
            mydata = index.model().mydata
            if col == RuleModel.col_enabled:
                index.model().setData(index, not mydata[row].enabled)
            if col == RuleModel.col_inverted:
                index.model().setData(index, not mydata[row].inverted)
            if col == RuleModel.col_data and isinstance(mydata[row], RuleCode):
                disp = '\n'.join(mydata[row].instr_string)
                data, succ = QtWidgets.QInputDialog.getMultiLineText(self, 'Get Code Pattern',
                                                        'Function must contain Code Pattern (See help for details):',
                                                         disp)
                if succ:
                    mydata[row].set_data(data.split('\n'))
        except Exception as ex:
            QMessageBox.warning(None, "Error setting value", str(ex))
            return self.tableRulesDoubleClick(index)
        return None

    def delselrules(self):
        if self.ui.tableview.selectionModel().hasSelection():
            rows = [index.row() for index in self.ui.tableview.selectionModel().selectedRows()]
            rows.sort(reverse=True)
            for row in rows:
                self.model.del_item(row)

    def copyselrules(self):
        if self.ui.tableview.selectionModel().hasSelection():
            rows = [index.row() for index in self.ui.tableview.selectionModel().selectedRows()]
            data = [self.model.mydata[x] for x in rows]
            string = to_clipboard_string(data)
            if string:
                QApplication.instance().clipboard().setText(string)

    def pasteselrules(self):
        string = QApplication.instance().clipboard().text()
        if string:
            try:
                data = from_clipboard_string(string)
                if data:
                    self.model.mydata += data
                    self.model.layoutChanged.emit()
            except Exception as ex:
                QMessageBox.warning(self, "Error pasting rules", str(ex))

    def loadselrules(self):
        path, x = QFileDialog.getOpenFileName(self, 'Open Rule File', "", "Rules (*.rule) ;; Any (*.*)")
        if not path:
            return
        try:
            if use_pickle_ff:
                with open(path, 'rb') as handle:
                    loaded = pickle.load(handle)
                    self.model.mydata += loaded
            else:
                with open(path, 'r') as handle:
                    rules = from_clipboard_string(handle.read())
                    self.model.mydata += rules
            self.model.layoutChanged.emit()
        except Exception as ex:
            QMessageBox.warning(self, "Error reading file", str(ex))

    def saveselrules(self):
        if not self.ui.tableview.selectionModel().hasSelection():
            QMessageBox.warning(self, "Nothing", "No rules selected")
            return
        path, x = QFileDialog.getSaveFileName(self, 'Save Rule to File', "rule.rule", "Rules (*.rule) ;; Any (*.*)")
        if not path:
            return
        try:
            rows = [index.row() for index in self.ui.tableview.selectionModel().selectedRows()]
            tosave = [self.model.mydata[x] for x in rows]
            if use_pickle_ff:
                with open(path, 'wb') as handle:
                    pickle.dump(tosave, handle, protocol=3)
            else:
                with open(path, 'w') as handle:
                    handle.write(to_clipboard_string(tosave))
            QMessageBox.information(self, "Success", "Saved successfully to " + path)
        except Exception as ex:
            QMessageBox.error(self, "Error saving file", str(ex))

    def _dosearch(self, limitto: List[int]):
        """
        perform search or refine results given in limitto
        """
        if not inida:
            msg = "This is an IDA PRO plugin, copy findfuncmain.py and findfunc folder to IDA plugin dir!"
            QMessageBox.information(self, "Error", msg)
            return
        self.matcher.info.debug = self.ui.chkdebug.isChecked()
        self.matcher.info.profile = self.ui.chkprofile.isChecked()
        profiler = cProfile.Profile()
        if self.matcher.info.profile:
            profiler.enable()
        starttime = time.time()
        idaapi.show_wait_box("FindFunc: Finding Functions... ")  # todo: maybe use ida_kernwin.replace_wait_box
        results = self.matcher.do_match(self.model.mydata, limitto)
        idaapi.hide_wait_box()
        self.resultmodel.set_items([ResultModel.Result(fn.va, fn.size, len(fn.chunks) - 1, fn.name, fn.lastmatch) for fn in results])
        self.ui.tableresults.resizeColumnsToContents()
        timetaken = time.time() - starttime
        print("Results found: ", len(results))
        print('Execution time in seconds: ' + str(round(timetaken, 2)))
        if self.matcher.info.profile:
            profiler.disable()
            stream = io.StringIO()
            ps = pstats.Stats(profiler, stream=stream).sort_stats('tottime')
            ps.print_stats()
            print(stream.getvalue())
        if self.matcher.wascancelled:
            self.matcher.wascancelled = False
            QMessageBox.warning(None, "Canceled", "Search was canceled.")

    def dosearchclicked(self):
        """
        perform new search
        """
        self._dosearch([])

    def dorefineclicked(self):
        """
        refine existing results, or new search if no current results
        """
        limitto = [r.va for r in self.resultmodel.mydata]
        self._dosearch(limitto)


class TabWid(QWidget):
    """
    Widget that represents the Tabwidget.
    At the end of the tab bar there is a disabled tab that creates a new tab when clicked.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.count = 0
        self.ui = Ui_fftabs()
        self.ui.setupUi(self)
        self.ui.tabWidget.tabBar().tabBarClicked.connect(self.newTabClicked)
        self.ui.tabWidget.tabBar().tabCloseRequested.connect(self.closeTabReq)
        self.ui.tabWidget.tabBar().tabMoved.connect(self.tabmoved)
        self.clearAll()
        self.addNewTab()
        for r in [RuleImmediate(9), RuleCode("xor eax,r32"), RuleNameRef("mem*")]:
            self.ui.tabWidget.widget(0).model.add_item(r)
        print("init with config:" + str(self.ui.tabWidget.widget(0).matcher.info))

    def setInfoString(self, info: str):
        self.ui.linklabel.setText(info)

    def tabmoved(self):
        self.resetNewTabButton()

    def newTabClicked(self, index):
        if index == -1 or self.ui.tabWidget.tabBar().count() <= 1:
            self.addNewTab()

    def addNewTab(self):
        self.ui.tabWidget.addTab(FindFuncTab(), f"Tab {self.genId()}")
        self.resetNewTabButton()

    def closeTabReq(self, index):
        self.ui.tabWidget.removeTab(index)
        self.resetNewTabButton()

    def genId(self):
        self.count = self.count + 1
        return self.count

    def resetNewTabButton(self):
        """
        We want a disabled tab at the end of the tab-bar that creates a new tab when clicked.
        """
        for t in range(self.ui.tabWidget.count()):
            if not self.ui.tabWidget.isTabEnabled(t):
                self.ui.tabWidget.removeTab(t)
                break
        newtab = self.ui.tabWidget.addTab(FindFuncTab(), "new tab")
        self.ui.tabWidget.setTabEnabled(newtab, False)
        self.ui.tabWidget.tabBar().setTabButton(newtab, QTabBar.RightSide, None)

    def clearAll(self):
        for t in range(self.ui.tabWidget.count()):
            self.ui.tabWidget.removeTab(t)

```

`findfunc/findfuncdialog.py`:

```py
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'findfuncdialog.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_FindFunc(object):
    def setupUi(self, FindFunc):
        FindFunc.setObjectName("FindFunc")
        FindFunc.resize(915, 459)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(FindFunc)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.splitter = QtWidgets.QSplitter(FindFunc)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.tableresults = QtWidgets.QTableView(self.splitter)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tableresults.sizePolicy().hasHeightForWidth())
        self.tableresults.setSizePolicy(sizePolicy)
        self.tableresults.setMinimumSize(QtCore.QSize(0, 0))
        self.tableresults.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.tableresults.setBaseSize(QtCore.QSize(0, 0))
        self.tableresults.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustIgnored)
        self.tableresults.setObjectName("tableresults")
        self.tableresults.horizontalHeader().setStretchLastSection(True)
        self.layoutWidget = QtWidgets.QWidget(self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.tableview = QtWidgets.QTableView(self.layoutWidget)
        self.tableview.setObjectName("tableview")
        self.tableview.horizontalHeader().setStretchLastSection(True)
        self.verticalLayout_2.addWidget(self.tableview)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setObjectName("gridLayout")
        self.btnaddimm = QtWidgets.QPushButton(self.layoutWidget)
        self.btnaddimm.setObjectName("btnaddimm")
        self.gridLayout.addWidget(self.btnaddimm, 1, 0, 1, 1)
        self.btnfuncsize = QtWidgets.QPushButton(self.layoutWidget)
        self.btnfuncsize.setObjectName("btnfuncsize")
        self.gridLayout.addWidget(self.btnfuncsize, 0, 0, 1, 1)
        self.btnaddstr = QtWidgets.QPushButton(self.layoutWidget)
        self.btnaddstr.setObjectName("btnaddstr")
        self.gridLayout.addWidget(self.btnaddstr, 0, 1, 1, 1)
        self.btnaddname = QtWidgets.QPushButton(self.layoutWidget)
        self.btnaddname.setObjectName("btnaddname")
        self.gridLayout.addWidget(self.btnaddname, 1, 1, 1, 1)
        self.btnaddcode = QtWidgets.QPushButton(self.layoutWidget)
        self.btnaddcode.setObjectName("btnaddcode")
        self.gridLayout.addWidget(self.btnaddcode, 1, 2, 1, 1)
        self.btnaddpattern = QtWidgets.QPushButton(self.layoutWidget)
        self.btnaddpattern.setObjectName("btnaddpattern")
        self.gridLayout.addWidget(self.btnaddpattern, 0, 2, 1, 1)
        self.horizontalLayout.addLayout(self.gridLayout)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.chkdebug = QtWidgets.QCheckBox(self.layoutWidget)
        self.chkdebug.setObjectName("chkdebug")
        self.verticalLayout.addWidget(self.chkdebug)
        self.chkprofile = QtWidgets.QCheckBox(self.layoutWidget)
        self.chkprofile.setObjectName("chkprofile")
        self.verticalLayout.addWidget(self.chkprofile)
        self.horizontalLayout_2.addLayout(self.verticalLayout)
        self.btnsearch = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(1)
        sizePolicy.setHeightForWidth(self.btnsearch.sizePolicy().hasHeightForWidth())
        self.btnsearch.setSizePolicy(sizePolicy)
        self.btnsearch.setObjectName("btnsearch")
        self.horizontalLayout_2.addWidget(self.btnsearch)
        self.btnrefine = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(1)
        sizePolicy.setHeightForWidth(self.btnrefine.sizePolicy().hasHeightForWidth())
        self.btnrefine.setSizePolicy(sizePolicy)
        self.btnrefine.setObjectName("btnrefine")
        self.horizontalLayout_2.addWidget(self.btnrefine)
        self.horizontalLayout_2.setStretch(1, 1)
        self.verticalLayout_2.addLayout(self.horizontalLayout_2)
        self.horizontalLayout_3.addWidget(self.splitter)

        self.retranslateUi(FindFunc)
        QtCore.QMetaObject.connectSlotsByName(FindFunc)

    def retranslateUi(self, FindFunc):
        _translate = QtCore.QCoreApplication.translate
        FindFunc.setWindowTitle(_translate("FindFunc", "FindFunc"))
        self.btnaddimm.setText(_translate("FindFunc", "Immediate/Constant Ref"))
        self.btnfuncsize.setText(_translate("FindFunc", "Function Size"))
        self.btnaddstr.setText(_translate("FindFunc", "String Reference"))
        self.btnaddname.setText(_translate("FindFunc", "Name Reference"))
        self.btnaddcode.setText(_translate("FindFunc", "Code Pattern"))
        self.btnaddpattern.setText(_translate("FindFunc", "Byte Pattern"))
        self.chkdebug.setText(_translate("FindFunc", "Debug"))
        self.chkprofile.setText(_translate("FindFunc", "Profile"))
        self.btnsearch.setText(_translate("FindFunc", "Search Functions"))
        self.btnrefine.setText(_translate("FindFunc", "Refine Results"))

```

`findfunc/findfuncdialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>FindFunc</class>
 <widget class="QDialog" name="FindFunc">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>915</width>
    <height>459</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>FindFunc</string>
  </property>
  <layout class="QHBoxLayout" name="horizontalLayout_3">
   <item>
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <widget class="QTableView" name="tableresults">
      <property name="sizePolicy">
       <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
        <horstretch>0</horstretch>
        <verstretch>0</verstretch>
       </sizepolicy>
      </property>
      <property name="minimumSize">
       <size>
        <width>0</width>
        <height>0</height>
       </size>
      </property>
      <property name="maximumSize">
       <size>
        <width>16777215</width>
        <height>16777215</height>
       </size>
      </property>
      <property name="baseSize">
       <size>
        <width>0</width>
        <height>0</height>
       </size>
      </property>
      <property name="sizeAdjustPolicy">
       <enum>QAbstractScrollArea::AdjustIgnored</enum>
      </property>
      <attribute name="horizontalHeaderStretchLastSection">
       <bool>true</bool>
      </attribute>
     </widget>
     <widget class="QWidget" name="layoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout_2">
       <item>
        <widget class="QTableView" name="tableview">
         <attribute name="horizontalHeaderStretchLastSection">
          <bool>true</bool>
         </attribute>
        </widget>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout">
         <item>
          <layout class="QGridLayout" name="gridLayout">
           <item row="1" column="0">
            <widget class="QPushButton" name="btnaddimm">
             <property name="text">
              <string>Immediate/Constant Ref</string>
             </property>
            </widget>
           </item>
           <item row="0" column="0">
            <widget class="QPushButton" name="btnfuncsize">
             <property name="text">
              <string>Function Size</string>
             </property>
            </widget>
           </item>
           <item row="0" column="1">
            <widget class="QPushButton" name="btnaddstr">
             <property name="text">
              <string>String Reference</string>
             </property>
            </widget>
           </item>
           <item row="1" column="1">
            <widget class="QPushButton" name="btnaddname">
             <property name="text">
              <string>Name Reference</string>
             </property>
            </widget>
           </item>
           <item row="1" column="2">
            <widget class="QPushButton" name="btnaddcode">
             <property name="text">
              <string>Code Pattern</string>
             </property>
            </widget>
           </item>
           <item row="0" column="2">
            <widget class="QPushButton" name="btnaddpattern">
             <property name="text">
              <string>Byte Pattern</string>
             </property>
            </widget>
           </item>
          </layout>
         </item>
        </layout>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_2" stretch="0,1,0">
         <item>
          <layout class="QVBoxLayout" name="verticalLayout" stretch="0,0">
           <item>
            <widget class="QCheckBox" name="chkdebug">
             <property name="text">
              <string>Debug</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QCheckBox" name="chkprofile">
             <property name="text">
              <string>Profile</string>
             </property>
            </widget>
           </item>
          </layout>
         </item>
         <item>
          <widget class="QPushButton" name="btnsearch">
           <property name="sizePolicy">
            <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
             <horstretch>0</horstretch>
             <verstretch>1</verstretch>
            </sizepolicy>
           </property>
           <property name="text">
            <string>Search Functions</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="btnrefine">
           <property name="sizePolicy">
            <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
             <horstretch>0</horstretch>
             <verstretch>1</verstretch>
            </sizepolicy>
           </property>
           <property name="text">
            <string>Refine Results</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`findfunc/matcher_ida.py`:

```py
import copy
from typing import Iterable

from findfunc.backbone import *

inida = True
try:
    # from idaapi import PluginForm
    import idaapi
    import idautils
    import idc
    import ida_search
    import ida_bytes
    import ida_name
    import ida_allins
    import ida_ua
except:
    inida = False

### stuff taken from IDAs intel.hpp
### see intel.hpp for information

# // Intel 80x86 insn_t.auxpref bits
aux_natop = 0x00000800  # // operand size is not overridden by prefix
aux_natad = 0x00001000  # // addressing mode is not overridden by prefix
aux_use32 = 0x00000008  # // segment type is 32-bits
aux_use64 = 0x00000010  # // segment type is 64-bits
# // bits in insn_t.rex:
REX_W = 8  # // 64-bit operand size
REX_R = 4  # // modrm reg field extension
REX_X = 2  # // sib index field extension
REX_B = 1  # // modrm r/m, sib base, or opcode reg fields extension
VEX_L = 0x80  # // 256-bit operation (YMM register)


def ida_is_op_16(insn):
    insn.rex = insn.insnpref
    p = insn.auxpref & (aux_use32 | aux_use64 | aux_natop)
    a = p == aux_natop  # // 16-bit segment, no prefixes
    b = p == aux_use32  # // 32-bit segment, 66h
    c = p == aux_use64 and (insn.rex & REX_W) == 0  # // 64-bit segment, 66h, no rex.w
    return a or b or c


def ida_is_op_32(insn):
    insn.rex = insn.insnpref
    p = insn.auxpref & (aux_use32 | aux_use64 | aux_natop)
    a = p == 0  # // 16-bit segment, 66h
    b = p == (aux_use32 | aux_natop)  # // 32-bit segment, no prefixes
    c = p == (aux_use64 | aux_natop) and (insn.rex & REX_W) == 0  # // 64-bit segment, 66h, no rex.w
    return a or b or c


def ida_is_op_64(insn):
    insn.rex = insn.insnpref
    a = (insn.auxpref & aux_use64) != 0
    b = (insn.rex & REX_W) != 0
    # // 64-bit segment, rex.w or insns-64
    c = ((insn.auxpref & aux_natop) != 0) and ida_insn_default_opsize_64(insn)
    return (a and b) or c


def ida_insn_default_opsize_64(insn):
    jcc = (ida_allins.NN_pop, ida_allins.NN_popf, ida_allins.NN_popfq, ida_allins.NN_push, ida_allins.NN_pushf,
           ida_allins.NN_pushfq, ida_allins.NN_retn, ida_allins.NN_retf, ida_allins.NN_retnq, ida_allins.NN_retfq,
           ida_allins.NN_call, ida_allins.NN_callfi, ida_allins.NN_callni, ida_allins.NN_enter,
           ida_allins.NN_enterq, ida_allins.NN_leave, ida_allins.NN_leaveq)

    ss = (ida_allins.NN_jcxz, ida_allins.NN_jecxz, ida_allins.NN_jrcxz, ida_allins.NN_jmp, ida_allins.NN_jmpni,
          ida_allins.NN_jmpshort, ida_allins.NN_loop, ida_allins.NN_loopq, ida_allins.NN_loope,
          ida_allins.NN_loopqe, ida_allins.NN_loopne, ida_allins.NN_loopqne)

    nearbranch = {ida_allins.NN_ja, ida_allins.NN_jae, ida_allins.NN_jb, ida_allins.NN_jbe, ida_allins.NN_jc,
                  ida_allins.NN_je,
                  ida_allins.NN_jg, ida_allins.NN_jge, ida_allins.NN_jl, ida_allins.NN_jle, ida_allins.NN_jna,
                  ida_allins.NN_jnae, ida_allins.NN_jnb, ida_allins.NN_jnbe, ida_allins.NN_jnc, ida_allins.NN_jne,
                  ida_allins.NN_jng, ida_allins.NN_jnge, ida_allins.NN_jnl, ida_allins.NN_jnle, ida_allins.NN_jno,
                  ida_allins.NN_jnp, ida_allins.NN_jns, ida_allins.NN_jnz, ida_allins.NN_jo, ida_allins.NN_jp,
                  ida_allins.NN_jpe, ida_allins.NN_jpo, ida_allins.NN_js, ida_allins.NN_jz}

    insnr = insn.itype
    if insnr in jcc or insnr in ss or insnr in nearbranch:
        return True
    return False


def ida_is_ad_16(insn):
    p = insn.auxpref & (aux_use32 | aux_use64 | aux_natad)
    return p == aux_natad or p == aux_use32


def ida_is_ad_64(insn):
    p = insn.auxpref & (aux_use32 | aux_use64 | aux_natad)
    return p == (aux_natad | aux_use64)


def ida_is_ad_32(insn):
    p = insn.auxpref & (aux_use32 | aux_use64 | aux_natad)
    return p == (aux_natad | aux_use32) or p == 0 or p == aux_use64


def ida_get_insn_admode(insn):
    if ida_is_ad_64(insn):
        return 8
    if ida_is_ad_32(insn):
        return 4
    if ida_is_ad_16(insn):
        return 2
    return None


### end ida.hpp

def gui_jump_to_va(va: int):
    """
    jump to given va in IDA and switch to window
    """
    if inida:
        idaapi.jumpto(va)


class Config:
    """
    Contains various information about IDA context, e.g.
    pointersize of current processor, considered string-types,
    or image-range
    """
    def __init__(self):
        self.debug = False
        self.profile = False
        self.warnedfar = False
        if not inida:
            self.strtypes = []
            self.startva = 0
            self.endva = 0
            self.ptrsize = 8
            return
        # types of strings considered by String matching rule
        self.strtypes = [idaapi.STRTYPE_C, idaapi.STRTYPE_C_16]
        # image base
        self.startva = idaapi.get_imagebase()
        # image end
        self.endva = idaapi.get_last_seg().end_ea
        # size of pointer of current proc module
        info = idaapi.get_inf_structure()
        if info.is_64bit():
            self.ptrsize = 8
        elif info.is_32bit():
            self.ptrsize = 4
        else:
            assert "processor must be x64 or x86"

    def __str__(self):
        return f"config: [{hex(self.startva)} - {hex(self.endva)}] @{self.ptrsize} ({str(self.strtypes)})"


class Func:
    """
    Helper class represent a function to be matched.
    """
    def __init__(self):
        self.va = 0
        self.end = 0
        self.size = 0  # size including chunks
        self.lastmatch = 0  # last rule match on this va
        self.name = ""
        self.chunks = []

    def __repr__(self):
        return f"funcs({hex(self.va)} -> {hex(self.end)} = {self.size})"

    def contains_adr(self, adr):
        for chunk in self.chunks:
            if chunk[0] <= adr < chunk[1]:
                return True
        return False

    def get_as_chunks(self):
        """
        get chunks
        this includes the main function body too!
        :return: chunks
        """
        return self.chunks

    @staticmethod
    def _disasm_chunk(start: int, end: int):
        """
        generator to disasm given range
        :param start: start va
        :param end: end va
        :return: yields instructions oen by one
        """
        curva = start
        while curva < end:
            ins = idautils.DecodeInstruction(curva)
            if ins is None:
                # print(f"error disasm at {hex(curva)}")
                curva = curva + 1
                continue
            curva += ins.size
            yield ins

    def disasm(self):
        """
        generator to disasm entire function, incl. chunks
        :return: yields instructions one by one
        """
        for chunk in self.get_as_chunks():
            yield None  # function chunck separator
            for ins in self._disasm_chunk(chunk[0], chunk[1]):
                yield ins

    @staticmethod
    def adresses_to_funcs(refs: Iterable[int]):
        """
        converts list of address that may be anywhere in a function to Func functions.
        filtes against duplicates
        :param refs: list of address in functions or start of functions
        :return: yields generated Func functions one by one
        """
        deduplicate = set()
        for ref in refs:
            func = Func()
            func.va = idc.get_func_attr(ref, idc.FUNCATTR_START)
            if func.va == idaapi.BADADDR or func.va in deduplicate:
                continue
            func.end = idc.get_func_attr(ref, idc.FUNCATTR_END)
            func.chunks = list(idautils.Chunks(func.va))
            func.size = idaapi.calc_func_size(idaapi.get_func(func.va))
            func.lastmatch = ref
            deduplicate.add(func.va)
            yield func

    @staticmethod
    def adress_to_func(adr: int):
        """
        helper to convert a single function from address
        :param adr: va anywhere in function
        :return: Func function
        """
        return list(Func.adresses_to_funcs([adr]))[0]


class MatcherIda:
    """
    Main class responsible for applying rules and filtering functions accordingly.
    This class collects initial matches, refines them and returns resuls in key method
    do_match().
    Internally it converts and compares instructions,strings,names,... against user-supplied rules.
    """
    def __init__(self):
        self.info = Config()
        self.idastrings = None
        self.wascancelled = False

    # user has cancelled the search
    def iscancelled(self) -> bool:
        self.wascancelled = idaapi.user_cancelled()
        if self.wascancelled:
            print("Search cancelled...")
        return self.wascancelled

    # these functions obtain initial matches, which are then refined
    # by subsequent rules.
    # Initial matches need to be fast and cut down the input to slower rules.

    @staticmethod
    def match_initial_pos_strings(rules: List[RuleStrRef]):
        for r in rules:
            if r.inverted:
                continue
            for ref in r.refs:
                yield ref

    @staticmethod
    def match_initial_pos_names(rules: List[RuleNameRef]):
        for r in rules:
            if r.inverted:
                continue
            for va in r.refs:
                yield va

    def match_initial_pos_imm(self, rules: List[RuleImmediate]):
        for r in rules:
            if r.inverted:
                continue
            lastva = self.info.startva
            while lastva != idaapi.BADADDR:
                if self.iscancelled():
                    return
                lastva = ida_search.find_imm(lastva, idaapi.SEARCH_DOWN, r.imm)
                lastva = lastva[0]  # ??
                if lastva != idaapi.BADADDR:
                    yield lastva

    def match_initial_pos_bytes(self, rules: List[RuleBytePattern]):
        for r in rules:
            if r.inverted:
                continue
            lastva = self.info.startva
            while lastva != idaapi.BADADDR:
                lastva = ida_bytes.bin_search(lastva + 1, self.info.endva, r.patterncompiled, idaapi.BIN_SEARCH_FORWARD)
                if lastva != idaapi.BADADDR:
                    yield lastva

    @staticmethod
    def match_initial_pos_fsize(rules: List[RuleFuncSize]):
        funcfiter = idautils.Functions()
        for func in funcfiter:
            funcsize = idaapi.calc_func_size(idaapi.get_func(func))
            for rule in rules:
                if rule.inverted:
                    continue
                if rule.checksize(funcsize):
                    yield func

    # These methods refine initial matches
    # As initial matches only considere positive rules (not inverted ones),
    # all rules must be used for refining, except the single one that actually
    # generated initial matches.
    # To keep memoryp ressure low, ideally this all works as a geneartor-pipeline

    @staticmethod
    def refine_match_string(funcs: Iterable[Func], rules: List[RuleStrRef]):
        for func in funcs:
            for r in rules:
                for ref in r.refs:
                    isinfunc = func.contains_adr(ref)
                    if isinfunc:
                        passed = not r.inverted
                        if passed:
                            func.lastmatch = ref
                        break
                else:
                    passed = r.inverted
                if not passed:
                    func = None
                    break
            if func:
                yield func

    @staticmethod
    def refine_match_fsize(funcs: Iterable[Func], rules: List[RuleFuncSize]):
        for fnc in funcs:
            for rule in rules:
                isinfunc = rule.checksize(fnc.size)
                if isinfunc == rule.inverted:
                    break  # one rule mismatch is enough
            else:
                yield fnc

    @staticmethod
    def refine_match_name(funcs: Iterable[Func], rules: List[RuleNameRef]):
        for func in funcs:
            for r in rules:
                for ref in r.refs:
                    isinfunc = func.contains_adr(ref)
                    if isinfunc:
                        passed = not r.inverted
                        if passed:
                            func.lastmatch = ref
                        break
                else:
                    passed = r.inverted
                if not passed:
                    func = None
                    break
            if func:
                yield func

    def refine_match_bytes(self, funcs: Iterable[Func], rules: List[RuleBytePattern]):
        for func in funcs:
            if self.iscancelled():
                return
            for r in rules:
                for chunk in func.get_as_chunks():
                    hit = ida_bytes.bin_search(chunk[0], chunk[1], r.patterncompiled, idaapi.BIN_SEARCH_FORWARD)
                    isinfunc = hit != idaapi.BADADDR
                    if isinfunc:
                        passed = not r.inverted
                        if passed:
                            func.lastmatch = hit
                        break
                else:
                    passed = r.inverted
                if not passed:
                    func = None
                    break
            if func:
                yield func

    # CodeRule matching is the most complicated matching.
    # Some helper methods follow

    @staticmethod
    def _idains_contains_imm(ins, imm: int):
        if ins:
            for op in ins.ops:
                if op.type == idc.o_imm:
                    if op.value == imm:
                        return True
                if op.type == idc.o_displ or op.type == idc.o_mem:
                    if op.addr == imm and imm != 0:
                        return True
        return False

    def _check_op_eq(self, opx: InstrWildcardOp, oprule: InstrWildcardOp) -> bool:
        """
        Compare two instruction operands, disassembly one with one provided by a CodePattern rule.
        :param opx: disassembled operand
        :param oprule: rule operand
        :return: True if opx satisfies oprule
        """
        if oprule.basereg == "any":
            return True
        if opx.deref != oprule.deref or opx.scale != oprule.scale:
            return False
        if opx.deref and opx.size != oprule.size and oprule.size is not None:  # compare size of deref []
            return False
        derefeq = opx.displ == oprule.displ or oprule.displ == "imm"  # displ doesnt have an invalid value - can be 0
        if not derefeq:
            return False
        pointersize = self.info.ptrsize if opx.deref else opx.size
        baseregeq = opx.basereg == oprule.basereg \
                    or (opx.basereg is not None and oprule.basereg == "r") \
                    or (pointersize == 8 and oprule.basereg == "r64") \
                    or (pointersize == 4 and oprule.basereg == "r32") \
                    or (pointersize == 2 and oprule.basereg == "r16") \
                    or (pointersize == 1 and oprule.basereg == "r8")
        if not baseregeq:
            return False
        indexregeq = opx.indexreg == oprule.indexreg \
                     or (opx.indexreg is not None and oprule.indexreg == "r") \
                     or (pointersize == 8 and oprule.indexreg == "r64") \
                     or (pointersize == 4 and oprule.indexreg == "r32") \
                     or (pointersize == 2 and oprule.indexreg == "r16") \
                     or (pointersize == 1 and oprule.indexreg == "r8")
        if not indexregeq:
            return False
        return True

    def _check_instr(self, idains, rules: List[RuleCode]):
        """
        Checks a disassembled instruction against a list of CodeRules
        If the instruction satisfies the current instruction of the Rule,
        the Rules state is advanced to the next instruction to be matched.
        :param idains: the disassembled instruction
        :param rules: a list of CodeRules
        :return: Nothing
        """
        for r in rules:
            self._check_instr_on_rule(idains, r)

    def _check_instr_on_rule(self, idains, rules: RuleCode):
        """
        Checks a disassembled instruction against a list of CodeRules
        If the instruction satisfies the current instruction of the Rule,
        the Rules state is advanced to the next instruction to be matched.
        :param idains: the disassembled instruction
        :param rules: a list of CodeRules
        :return: Nothing
        """
        r = rules
        if r.is_satisfied():
            return
        curins = r.curinstr()
        if curins.mmn == "pass":  # matches any instruction
            r.advance()
            return
        if len(curins.ops) == 0:
            if not fnmatch.fnmatch(idains.mmn, curins.mmn) and curins.mmn != "any":  # match mmn
                r.clearcurrent()
            else:
                r.advance()
            return
        if len(idains.ops) != len(curins.ops):
            r.clearcurrent()
            return
        if not fnmatch.fnmatch(idains.mmn, curins.mmn) and curins.mmn != "any":  # match mmn
            r.clearcurrent()
            return
        if self.info.debug:
            print(f"---\nprep: {idains}    ==    {curins}")
        passed = True
        for opx, opy in zip(idains.ops, curins.ops):  # match operands
            if self.info.debug:
                print(f"{opx}    ==    {opy}    ->  {self._check_op_eq(opx, opy)}")
            if not self._check_op_eq(opx, opy):
                r.clearcurrent()
                passed = False
                break
        if passed:
            r.advance()  # advance rule state to next instruction to be checked

    def _ida_op_t_to_wcop(self, opida, adrsizeoverride) -> InstrWildcardOp:
        """
        Converts an operand of IDA dissassembled instruction to our own format,
        for easier matching.
        :param opida: operand by IDA
        :param adrsizeoverride: Intel instruction prefix can override the addressing size (in bytes)
        (can be None)
        :return: converted operand in our format
        """
        opout = InstrWildcardOp()
        opout.size = ida_ua.get_dtype_size(opida.dtype)
        if opida.type == idc.o_imm:  # simple immediate
            opout.displ = opida.value
        if opida.type == idc.o_reg:  # simple register
            opout.basereg = idaapi.get_reg_name(opida.reg, opout.size)
        # anyting else is more complex...
        hassib = opida.specflag1
        sib = opida.specflag2
        deref_reg_size = adrsizeoverride if adrsizeoverride else self.info.ptrsize
        index = base = breg = ireg = scale = None
        if hassib:
            base = sib & 7
            index = (sib >> 3) & 7
            scale = (sib >> 6) & 3
            breg = idaapi.get_reg_name(base, deref_reg_size)
            ireg = idaapi.get_reg_name(index, deref_reg_size)
            scale = (2 ** scale) if scale else 1
            # print(f"[{breg} + {ireg} * {sc} + {addr}]")
        addr = opida.addr
        if self.info.ptrsize == 8:
            if addr & 0x8000000000000000:
                addr = -0x10000000000000000 + addr
        else:
            if addr & 0x80000000:
                addr = -0x100000000 + addr
        if opida.type == idc.o_mem:  # [c], [ecx*8+64h] ds:0[edx*8] --> always ignore basereg
            opout.deref = True
            if hassib:  # [reg*c+x]
                opout.displ = addr
                # opout.basereg = None #always ignore
                opout.indexreg = ireg
                opout.scale = scale
            else:  # [c]
                opout.displ = addr
        if opida.type == idc.o_phrase:  # [eax+ecx*8] [ecx+edx] [edx]
            opout.deref = True
            if hassib:  # [r+r*c]
                opout.basereg = breg
                opout.indexreg = ireg
                opout.scale = scale
            else:  # [r]
                opout.basereg = idaapi.get_reg_name(opida.reg, deref_reg_size)
        if opida.type == idc.o_displ:  # [eax+ecx*8+64h]  [ebp+ecx*8+64h] [ecx+100h]
            opout.deref = True
            if hassib:  # [r+r*c+c]
                opout.basereg = breg
                opout.indexreg = ireg
                opout.displ = addr
                opout.scale = scale
            else:  # [r+c]
                opout.basereg = idaapi.get_reg_name(opida.reg, deref_reg_size)
                opout.displ = addr

        # for [rsp|esp|sp + ...] IDA sets basereg=indexreg=sp
        # this is probably an IDA bug (since sp cannot be an index)
        if hassib:
            if (index == base == idautils.procregs.sp.reg) and (scale == 1):
                opout.indexreg = None
        return opout

    def _idains_to_myins(self, idains) -> InstrWildcard:
        """
        Converts IDA instruction to our format for easier comparison.
        :param idains: instruction disassembled by IDA
        :return: converted instructoin in our format
        """
        myins = InstrWildcard()
        myins.va = idains.ea
        myins.mmn = idains.get_canon_mnem()  # perf opt: only convert instructions if mmn matches...
        for op in idains.ops:
            if op.type == idaapi.o_void:
                break
            if op.type in (idc.o_far, idc.o_near):
                if not self.info.warnedfar:
                    self.info.warnedfar = True
                    print("near and far operands not supported")
                continue
            # if self.info.debug:
            #     print("is_op", ida_is_op_16(ins), ida_is_op_32(ins), ida_is_op_64(ins))
            #     print("is_add", ida_is_ad_16(ins), ida_is_ad_32(ins), ida_is_ad_64(ins))
            adrsizeoverrideprefix = ida_get_insn_admode(idains)
            o = self._ida_op_t_to_wcop(op, adrsizeoverrideprefix)
            myins.ops.append(o)
        return myins

    def refine_match_code_and_imm(self, funcs: Iterable[Func], rcode: List[RuleCode], rimm: List[RuleImmediate]):
        """
        Refine Imm and Code Rules.
        Do it in one go so we dont have to dissassemble twice. See notes on performance in do_match.
        :param funcs: list of candidate functions
        :param rcode: code rules
        :param rimm: imm rules
        :return: yield functions satisfying all rules
        """
        for func in funcs:
            if self.iscancelled():
                return
            disasm = list(func.disasm())
            for r in rimm:
                for ins in disasm:
                    isinfunc = self._idains_contains_imm(ins, r.imm)
                    if isinfunc:
                        passed = not r.inverted
                        if passed:
                            func.lastmatch = ins.ea
                        break
                else:
                    passed = r.inverted
                if not passed:
                    func = None
                    break
            if not func:  # failed imm check
                continue

            if not rcode:
                yield func  # no code rules and passed imm check
                continue
            if self.info.debug:
                print(f"checking func... at {hex(func.va)} with inscount {len(disasm)}")
            # reset rules
            for r in rcode:
                r.clearcurrent()
            for ins in disasm:
                if ins is None:
                    # reset rules bc we cross over a chunk
                    for r in rcode:
                        if not r.is_satisfied():
                            r.clearcurrent()
                    continue
                myins = self._idains_to_myins(ins)
                for r in [x for x in rcode if not x.is_satisfied()]:
                    self._check_instr_on_rule(myins, r)
                    if r.is_satisfied():
                        func.lastmatch = myins.va
                #self._check_instr(myins, rcode)
            for r in rcode:
                if r.is_satisfied() == r.inverted:
                    break  # one mismatching rule is enough
            else:
                yield func
            # reset rules
            for r in rcode:
                r.clearcurrent()

    def do_match(self, rules: List[Rule], limitto: List[int] = None) -> List[Func]:
        """
        Main function for filtering Functions based on the given Rules.

        Since matching is slow, we have an interest in applying fast rules first.

        A brief word on performance:
        1. name, string, funcsize are almost free in all cases
        2. bytepattern is almost free for byte strings length > 2
        3. immediate is difficult:
            We can use idaapi search, or we can disassemble the entire database and search ourselves -
            we may have to do this anyways if we are looking for code patterns.
            BUT: scanning for code patterns is in fact much cheaper than scanning for an immediate.
            an api-search for all matches is relatively costly - about 1/8 as costly as disassembling
            the entire database.
            So: If we cut down matches with cheap rules first, then we greatly profit from disassembling
            the remaining functions and looking for the immediate ourselves, especially if a code-rule is
            present anyways.
            However: If no cheap options exist and we have to disassemble large parts of the database
            anyways (due to presence of code pattern rules), then using one immediate rule as a pre-filter
            can greatly pay off.
            api-searching ONE immediate is roughly equivalent to 1/8 searching for any number of code-pattern
            rules - although this also depends on many different factors...
        4. code pattern are the most expensive by far, however checking one pattern vs checking many
            is almost identical.
        """
        # rc = RuleCode(None)
        # rc.set_data("mov     cl, [eax+ebx*4+9]")
        # print(rc.instr[0])
        self.wascancelled = False
        activerules = copy.deepcopy([x for x in rules if x.enabled])
        if not activerules:
            return []
        print("Active rules:" + str(activerules))
        coderules = [x for x in activerules if isinstance(x, RuleCode)]

        # positive rules
        pos_byte_rules = [x for x in activerules if isinstance(x, RuleBytePattern) and not x.inverted]
        pos_imm_rules = [x for x in activerules if isinstance(x, RuleImmediate) and not x.inverted]
        pos_name_rules = [x for x in activerules if isinstance(x, RuleNameRef) and not x.inverted]
        pos_str_rules = [x for x in activerules if isinstance(x, RuleStrRef) and not x.inverted]
        pos_fsize_rules = [x for x in activerules if isinstance(x, RuleFuncSize) and not x.inverted]

        # inverted rules
        neg_byte_rules = [x for x in activerules if isinstance(x, RuleBytePattern) and x.inverted]
        neg_imm_rules = [x for x in activerules if isinstance(x, RuleImmediate) and x.inverted]
        neg_name_rules = [x for x in activerules if isinstance(x, RuleNameRef) and x.inverted]
        neg_str_rules = [x for x in activerules if isinstance(x, RuleStrRef) and x.inverted]
        neg_fsize_rules = [x for x in activerules if isinstance(x, RuleFuncSize) and x.inverted]

        # preprocessing

        # cheap
        if pos_str_rules or neg_str_rules:
            if not self.idastrings:
                self.idastrings = idautils.Strings(False)
                self.idastrings.setup(self.info.strtypes)
            # print(f"{hex(i.ea)}: len {i.length}, type {i.strtype}, {str(i)}")
            for string in self.idastrings:
                strval = str(string)
                for rule in pos_str_rules + neg_str_rules:
                    if rule.matches(strval):
                        rule.refs += list(idautils.DataRefsTo(string.ea))
        # almost free
        if pos_name_rules or neg_name_rules:
            for name in idautils.Names():
                va, n = name
                for rule in pos_name_rules + neg_name_rules:
                    if rule.matches(n):
                        rule.refs += list(idautils.CodeRefsTo(va, False))
                        rule.refs += list(idautils.DataRefsTo(va))
        # free
        for rule in pos_byte_rules + neg_byte_rules:
            rule.patterncompiled = ida_bytes.compiled_binpat_vec_t()
            ida_bytes.parse_binpat_str(rule.patterncompiled, self.info.startva, rule.pattern, 16)

        if self.iscancelled():
            return []

        # initial collection
        # pick a positive rule to cut down initial matches as drastically as possible

        if limitto:
            candidatas = limitto
        elif pos_name_rules:
            candidatas = self.match_initial_pos_names([pos_name_rules[0]])
            pos_name_rules = pos_name_rules[1:]
        elif pos_fsize_rules:
            candidatas = self.match_initial_pos_fsize([pos_fsize_rules[0]])
            pos_fsize_rules = pos_fsize_rules[1:]
        elif pos_str_rules:
            candidatas = self.match_initial_pos_strings([pos_str_rules[0]])
            pos_str_rules = pos_str_rules[1:]
        elif pos_byte_rules:
            candidatas = self.match_initial_pos_bytes([pos_byte_rules[0]])
            pos_byte_rules = pos_byte_rules[1:]
        elif pos_imm_rules:
            candidatas = self.match_initial_pos_imm([pos_imm_rules[0]])
            pos_imm_rules = pos_imm_rules[1:]
        else:
            # only option is to disasm the full database -> slow
            print(
                "It seems only code patterns are available for initial matching, which necessitates disassembling the whole database.")
            print(
                "This can be slow. To speed up the process add positiv name > string > function size > bytes > immediate constraints.")
            candidatas = idautils.Functions()

        # refinement
        # refine against all positive and negative functions

        candidatas = Func.adresses_to_funcs(candidatas)
        if pos_fsize_rules or neg_fsize_rules:
            candidatas = self.refine_match_fsize(candidatas, pos_fsize_rules + neg_fsize_rules)
        if pos_str_rules or neg_str_rules:
            candidatas = self.refine_match_string(candidatas, pos_str_rules + neg_str_rules)
        if pos_name_rules or neg_name_rules:
            candidatas = self.refine_match_name(candidatas, pos_name_rules + neg_name_rules)
        if pos_byte_rules or neg_byte_rules:
            candidatas = self.refine_match_bytes(candidatas, pos_byte_rules + neg_byte_rules)
        if coderules or pos_imm_rules or neg_imm_rules:
            candidatas = self.refine_match_code_and_imm(candidatas, coderules, pos_imm_rules + neg_imm_rules)

        candidatas = list(candidatas)

        for c in candidatas:
            c.name = ida_name.get_short_name(c.va)

        # a = b = 0
        # for c in candidatas:
        #    a = a + c.end - c.va
        #    b = b + sum((x[1] - x[0] for x in c.chunks))
        #    if self.info.debug:
        #        print(hex(c.va), [(hex(x[0]), hex(x[1])) for x in c.chunks])
        # print("fsize: ", a, " chunk size: ", b - a)
        return candidatas

```

`findfunc/models.py`:

```py
from PyQt5 import QtCore, QtGui
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QMessageBox

from findfunc.backbone import *
from typing import List


class ResultModel(QtCore.QAbstractTableModel):
    """
    Model that holds the matched functions after a search was performed.
    """
    col_va = 0
    col_size = 1
    col_chunks = 2
    col_label = 3

    class Result:
        """
        Helper class to efficiently hold the information about a matched function
        shown in result table.
        """
        def __init__(self, va, size, chunks, name, lastmatch):
            self.va = va
            self.size = size
            self.chunks = chunks
            self.name = name
            self.lastmatch = lastmatch

    def __init__(self):
        QtCore.QAbstractTableModel.__init__(self)
        self.mydata = []
        self.headerdata = ["VA", "Size", "Chunks", "Name"]

    def columnCount(self, index=QtCore.QModelIndex()):
        return len(self.headerdata)

    def rowCount(self, index=QtCore.QModelIndex()):
        return len(self.mydata)

    def headerData(self, section: int, orientation: Qt.Orientation, role: int = ...):
        if role == Qt.DisplayRole:
            if orientation == Qt.Horizontal:
                return self.headerdata[section]
        return None

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        col = index.column()
        if role == Qt.DisplayRole:
            d = self.mydata[index.row()]
            if col == self.col_va:
                return hex(d.va)
            if col == self.col_size:
                return d.size
            if col == self.col_chunks:
                return d.chunks
            if col == self.col_label:
                return d.name

    def sort(self, col, order=Qt.AscendingOrder):
        if col == self.col_va:
            self.mydata = sorted(self.mydata, key=lambda x: x.va)
        if col == self.col_size:
            self.mydata = sorted(self.mydata, key=lambda x: x.size)
        if col == self.col_chunks:
            self.mydata = sorted(self.mydata, key=lambda x: x.chunks)
        if col == self.col_label:
            self.mydata = sorted(self.mydata, key=lambda x: x.name)
        if order == Qt.DescendingOrder:
            self.mydata.reverse()
        self.layoutChanged.emit()

    def add_item(self, item: Result):
        self.mydata.append(item)
        self.layoutChanged.emit()

    def set_items(self, items: List[Result]):
        self.mydata = items
        self.layoutChanged.emit()

    def clear(self):
        self.mydata = []
        self.layoutChanged.emit()

    def del_item(self, row: int):
        if row < len(self.mydata):
            self.mydata.remove(self.mydata[row])
            self.layoutChanged.emit()


class RuleModel(QtCore.QAbstractTableModel):
    """
    Model to hold all Rules in a tab/findfunc widget.
    """
    col_enabled = 0
    col_typ = 1
    col_inverted = 2
    col_data = 3

    def __init__(self):
        QtCore.QAbstractTableModel.__init__(self)
        self.mydata = []
        self.headerdata = ["Enabled", "Type", "Invert Match", "Data"]

    def columnCount(self, index=QtCore.QModelIndex()):
        return len(self.headerdata)

    def rowCount(self, index=QtCore.QModelIndex()):
        return len(self.mydata)

    def headerData(self, section: int, orientation: Qt.Orientation, role: int = ...):
        if role == Qt.DisplayRole:
            if orientation == Qt.Horizontal:
                return self.headerdata[section]
        return None

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None
        col = index.column()
        if role in (Qt.DisplayRole, Qt.EditRole):
            d = self.mydata[index.row()]
            if col == self.col_enabled:
                return d.enabled
            if col == self.col_inverted:
                return d.inverted
            if col == self.col_typ:
                return d.typ.value
            if col == self.col_data:
                # special handling for editing function size rules
                if role == Qt.EditRole and isinstance(d, RuleFuncSize):
                    return str(d.min) + "," + str(d.max)
                return d.get_data()
            return None
        if role == Qt.ForegroundRole:
            d = self.mydata[index.row()]
            if not d.enabled:
                return QtGui.QBrush(Qt.gray)
            return None
        if role == Qt.BackgroundRole:
            d = self.mydata[index.row()]
            if d.enabled and d.inverted:
                return QtGui.QBrush(QColor(Qt.cyan).lighter())
            return None
        if role == Qt.ToolTipRole:
            if col == self.col_data:
                d = self.mydata[index.row()]
                if isinstance(d, RuleImmediate):
                    return int(d.get_data(), 16)
            return None
        if role == Qt.TextAlignmentRole:
            return Qt.AlignCenter
        if role == Qt.CheckStateRole:
            return None
        return None

    def setData(self, index, value, role=Qt.EditRole):
        if not index.isValid():
            return False
        if role == Qt.EditRole:
            col = index.column()
            if col == self.col_enabled:
                self.mydata[index.row()].enabled = value
                self.layoutChanged.emit()
                return True
            if col == self.col_inverted:
                self.mydata[index.row()].inverted = value
                self.layoutChanged.emit()
                return True
            if col == self.col_data:
                try:
                    self.mydata[index.row()].set_data(value)
                    self.dataChanged.emit(index, index)
                    return True
                except Exception as ex:
                    QMessageBox.warning(None, "Error changing value", str(ex))
                    return False
        return False

    def flags(self, index):
        flags = super().flags(index)
        if index.row() >= len(self.mydata) or index.row() < 0:
            return flags
        d = self.mydata[index.row()]
        if index.column() == self.col_data and d.is_editable():
            flags |= Qt.ItemIsEditable
        return flags

    def sort(self, col, order=Qt.AscendingOrder):
        if col == self.col_enabled:
            self.mydata = sorted(self.mydata, key=lambda x: x.enabled)
        if col == self.col_typ:
            self.mydata = sorted(self.mydata, key=lambda x: str(x.typ))
        if col == self.col_inverted:
            self.mydata = sorted(self.mydata, key=lambda x: x.inverted)
        if col == self.col_data:
            self.mydata = sorted(self.mydata, key=lambda x: x.get_data())
        if order == Qt.DescendingOrder:
            self.mydata.reverse()
        self.layoutChanged.emit()

    def add_item(self, item: Rule):
        self.mydata.append(item)
        self.layoutChanged.emit()

    def del_item(self, row: int):
        if row < len(self.mydata):
            self.mydata.remove(self.mydata[row])
            self.layoutChanged.emit()

```

`findfuncmain.py`:

```py
import sys

from PyQt5.QtWidgets import QApplication

from findfunc import findfunc_gui

inida = True
try:
    # from idaapi import PluginForm
    import idc
    import idaapi
    import idautils
    import ida_bytes
    import ida_ua
    import ida_pro
except:
    inida = False
    print("not in ida")

if inida:
    from findfunc.advanced_copy import copy_all_bytes, copy_bytes_no_imm, copy_only_opcodes, copy_only_disasm


__AUTHOR__ = 'feber'

PLUGIN_NAME = "FindFunc (x86/x64)"
PLUGIN_HOTKEY = 'ctrl+alt+f'
VERSION = '1.0'
WINDOWTITLE = f'{PLUGIN_NAME} {VERSION}'
INFOSTR = f'For usage see: ' '<a href="https://github.com/FelixBer/FindFunc">https://github.com/FelixBer/FindFunc</a>'


if __name__ == "__main__":
    app = QApplication(sys.argv)
    tabwid = findfunc_gui.TabWid()
    tabwid.setInfoString(INFOSTR)
    tabwid.setWindowTitle(WINDOWTITLE)
    tabwid.show()
    if not inida:
        sys.exit(app.exec_())


# plugin stuff

def PLUGIN_ENTRY():
    return FindFunc()


class FindFunc(idaapi.plugin_t):
    """
    Main Plugin Class
    """
    flags = idaapi.PLUGIN_PROC  # | idaapi.PLUGIN_FIX #| idaapi.PLUGIN_HIDE
    comment = "Function Finder and Advanced copying of instruction bytes"
    help = f"Edit->Plugin->FindFunc or {PLUGIN_HOTKEY}. Also: disasm->rightclick->copy all|opcode|noimm"
    wanted_name = PLUGIN_NAME
    wanted_hotkey = PLUGIN_HOTKEY

    ACTION_COPY_BYTES = "feber:copy_bytes"
    ACTION_COPY_OPC = "feber:copy_opc"
    ACTION_COPY_NO_IMM = "feber:copy_no_imm"
    ACTION_COPY_DISASM = "feber:copy_disasm"

    def init(self):
        # see advanced_copy for details
        action_desc = idaapi.action_desc_t(
            self.ACTION_COPY_BYTES,
            "copy all bytes",
            ACActionHandler(copy_all_bytes),
            "ctrl+alt+b",  # hotkey
            "copy all selected bytes as hex",
            31
        )
        assert idaapi.register_action(action_desc), "Action registration failed"
        action_desc = idaapi.action_desc_t(
            self.ACTION_COPY_OPC,
            "copy opcodes only",
            ACActionHandler(copy_only_opcodes),
            "ctrl+alt+o",  # hotkey
            "copy selected opcodes as hex, wildcard out non-opcode bytes",
            31
        )
        assert idaapi.register_action(action_desc), "Action registration failed"
        action_desc = idaapi.action_desc_t(
            self.ACTION_COPY_NO_IMM,
            "copy bytes no immediates",
            ACActionHandler(copy_bytes_no_imm),
            "ctrl+alt+i",  # hotkey
            "copy instruction bytes, wildcard out all immediates",
            31
        )
        assert idaapi.register_action(action_desc), "Action registration failed"
        action_desc = idaapi.action_desc_t(
            self.ACTION_COPY_DISASM,
            "copy disasm",
            ACActionHandler(copy_only_disasm),
            "ctrl+alt+d",  # hotkey
            "copy disasm lines only",
            31
        )
        assert idaapi.register_action(action_desc), "Action registration failed"

        self.maintabwidgtet = findfunc_gui.TabWid()
        self.maintabwidgtet.setInfoString(INFOSTR)
        self.maintabwidgtet.setWindowTitle(WINDOWTITLE)

        self.hooks = ACUiHook()
        self.hooks.hook()

        idaapi.msg("%s %s by %s loaded\n" % (self.wanted_name, VERSION, __AUTHOR__))
        return idaapi.PLUGIN_KEEP

    def run(self, arg):
        """
        Edit->Plugins->... or hotkey
        """
        self.maintabwidgtet.show()

    def term(self):
        self.hooks.unhook()
        idaapi.unregister_action(self.ACTION_COPY_BYTES)
        idaapi.unregister_action(self.ACTION_COPY_OPC)
        idaapi.unregister_action(self.ACTION_COPY_NO_IMM)


# plugin helper stuff


class ACActionHandler(idaapi.action_handler_t):
    """
    Action handling helper
    """
    def __init__(self, action_function):
        idaapi.action_handler_t.__init__(self)
        self.action_function = action_function

    def activate(self, ctx):
        self.action_function()
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class ACUiHook(idaapi.UI_Hooks):
    """
    Show context menus in disasm widgets
    """
    def finish_populating_widget_popup(self, widget, popup):
        """
        Right click menu is about to be shown
        """
        form_type = idaapi.get_widget_type(widget)

        if form_type == idaapi.BWN_DISASMS:
            idaapi.attach_action_to_popup(
                widget,
                popup,
                FindFunc.ACTION_COPY_BYTES,
                # "copy all bytes",
                # idaapi.SETMENU_APP
            )
            idaapi.attach_action_to_popup(
                widget,
                popup,
                FindFunc.ACTION_COPY_NO_IMM,
            )
            idaapi.attach_action_to_popup(
                widget,
                popup,
                FindFunc.ACTION_COPY_OPC,
            )
            idaapi.attach_action_to_popup(
                widget,
                popup,
                FindFunc.ACTION_COPY_DISASM,
            )
        return 0

```